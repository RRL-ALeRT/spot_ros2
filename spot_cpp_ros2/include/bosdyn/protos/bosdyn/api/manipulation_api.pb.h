// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/manipulation_api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fmanipulation_5fapi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fmanipulation_5fapi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/geometry.pb.h"
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/image.pb.h"
#include "bosdyn/api/lease.pb.h"
#include "bosdyn/api/robot_state.pb.h"
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fmanipulation_5fapi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
namespace bosdyn {
namespace api {
class AllowableOrientation;
struct AllowableOrientationDefaultTypeInternal;
extern AllowableOrientationDefaultTypeInternal _AllowableOrientation_default_instance_;
class ApiGraspOverride;
struct ApiGraspOverrideDefaultTypeInternal;
extern ApiGraspOverrideDefaultTypeInternal _ApiGraspOverride_default_instance_;
class ApiGraspOverrideRequest;
struct ApiGraspOverrideRequestDefaultTypeInternal;
extern ApiGraspOverrideRequestDefaultTypeInternal _ApiGraspOverrideRequest_default_instance_;
class ApiGraspOverrideResponse;
struct ApiGraspOverrideResponseDefaultTypeInternal;
extern ApiGraspOverrideResponseDefaultTypeInternal _ApiGraspOverrideResponse_default_instance_;
class ApiGraspedCarryStateOverride;
struct ApiGraspedCarryStateOverrideDefaultTypeInternal;
extern ApiGraspedCarryStateOverrideDefaultTypeInternal _ApiGraspedCarryStateOverride_default_instance_;
class GraspParams;
struct GraspParamsDefaultTypeInternal;
extern GraspParamsDefaultTypeInternal _GraspParams_default_instance_;
class ManipulationApiFeedbackRequest;
struct ManipulationApiFeedbackRequestDefaultTypeInternal;
extern ManipulationApiFeedbackRequestDefaultTypeInternal _ManipulationApiFeedbackRequest_default_instance_;
class ManipulationApiFeedbackResponse;
struct ManipulationApiFeedbackResponseDefaultTypeInternal;
extern ManipulationApiFeedbackResponseDefaultTypeInternal _ManipulationApiFeedbackResponse_default_instance_;
class ManipulationApiRequest;
struct ManipulationApiRequestDefaultTypeInternal;
extern ManipulationApiRequestDefaultTypeInternal _ManipulationApiRequest_default_instance_;
class ManipulationApiResponse;
struct ManipulationApiResponseDefaultTypeInternal;
extern ManipulationApiResponseDefaultTypeInternal _ManipulationApiResponse_default_instance_;
class PickObject;
struct PickObjectDefaultTypeInternal;
extern PickObjectDefaultTypeInternal _PickObject_default_instance_;
class PickObjectExecutePlan;
struct PickObjectExecutePlanDefaultTypeInternal;
extern PickObjectExecutePlanDefaultTypeInternal _PickObjectExecutePlan_default_instance_;
class PickObjectInImage;
struct PickObjectInImageDefaultTypeInternal;
extern PickObjectInImageDefaultTypeInternal _PickObjectInImage_default_instance_;
class PickObjectRayInWorld;
struct PickObjectRayInWorldDefaultTypeInternal;
extern PickObjectRayInWorldDefaultTypeInternal _PickObjectRayInWorld_default_instance_;
class RotationWithTolerance;
struct RotationWithToleranceDefaultTypeInternal;
extern RotationWithToleranceDefaultTypeInternal _RotationWithTolerance_default_instance_;
class SqueezeGrasp;
struct SqueezeGraspDefaultTypeInternal;
extern SqueezeGraspDefaultTypeInternal _SqueezeGrasp_default_instance_;
class VectorAlignmentWithTolerance;
struct VectorAlignmentWithToleranceDefaultTypeInternal;
extern VectorAlignmentWithToleranceDefaultTypeInternal _VectorAlignmentWithTolerance_default_instance_;
class WalkToObjectInImage;
struct WalkToObjectInImageDefaultTypeInternal;
extern WalkToObjectInImageDefaultTypeInternal _WalkToObjectInImage_default_instance_;
class WalkToObjectRayInWorld;
struct WalkToObjectRayInWorldDefaultTypeInternal;
extern WalkToObjectRayInWorldDefaultTypeInternal _WalkToObjectRayInWorld_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::AllowableOrientation* Arena::CreateMaybeMessage<::bosdyn::api::AllowableOrientation>(Arena*);
template<> ::bosdyn::api::ApiGraspOverride* Arena::CreateMaybeMessage<::bosdyn::api::ApiGraspOverride>(Arena*);
template<> ::bosdyn::api::ApiGraspOverrideRequest* Arena::CreateMaybeMessage<::bosdyn::api::ApiGraspOverrideRequest>(Arena*);
template<> ::bosdyn::api::ApiGraspOverrideResponse* Arena::CreateMaybeMessage<::bosdyn::api::ApiGraspOverrideResponse>(Arena*);
template<> ::bosdyn::api::ApiGraspedCarryStateOverride* Arena::CreateMaybeMessage<::bosdyn::api::ApiGraspedCarryStateOverride>(Arena*);
template<> ::bosdyn::api::GraspParams* Arena::CreateMaybeMessage<::bosdyn::api::GraspParams>(Arena*);
template<> ::bosdyn::api::ManipulationApiFeedbackRequest* Arena::CreateMaybeMessage<::bosdyn::api::ManipulationApiFeedbackRequest>(Arena*);
template<> ::bosdyn::api::ManipulationApiFeedbackResponse* Arena::CreateMaybeMessage<::bosdyn::api::ManipulationApiFeedbackResponse>(Arena*);
template<> ::bosdyn::api::ManipulationApiRequest* Arena::CreateMaybeMessage<::bosdyn::api::ManipulationApiRequest>(Arena*);
template<> ::bosdyn::api::ManipulationApiResponse* Arena::CreateMaybeMessage<::bosdyn::api::ManipulationApiResponse>(Arena*);
template<> ::bosdyn::api::PickObject* Arena::CreateMaybeMessage<::bosdyn::api::PickObject>(Arena*);
template<> ::bosdyn::api::PickObjectExecutePlan* Arena::CreateMaybeMessage<::bosdyn::api::PickObjectExecutePlan>(Arena*);
template<> ::bosdyn::api::PickObjectInImage* Arena::CreateMaybeMessage<::bosdyn::api::PickObjectInImage>(Arena*);
template<> ::bosdyn::api::PickObjectRayInWorld* Arena::CreateMaybeMessage<::bosdyn::api::PickObjectRayInWorld>(Arena*);
template<> ::bosdyn::api::RotationWithTolerance* Arena::CreateMaybeMessage<::bosdyn::api::RotationWithTolerance>(Arena*);
template<> ::bosdyn::api::SqueezeGrasp* Arena::CreateMaybeMessage<::bosdyn::api::SqueezeGrasp>(Arena*);
template<> ::bosdyn::api::VectorAlignmentWithTolerance* Arena::CreateMaybeMessage<::bosdyn::api::VectorAlignmentWithTolerance>(Arena*);
template<> ::bosdyn::api::WalkToObjectInImage* Arena::CreateMaybeMessage<::bosdyn::api::WalkToObjectInImage>(Arena*);
template<> ::bosdyn::api::WalkToObjectRayInWorld* Arena::CreateMaybeMessage<::bosdyn::api::WalkToObjectRayInWorld>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum ApiGraspOverride_Override : int {
  ApiGraspOverride_Override_OVERRIDE_UNKNOWN = 0,
  ApiGraspOverride_Override_OVERRIDE_HOLDING = 1,
  ApiGraspOverride_Override_OVERRIDE_NOT_HOLDING = 2,
  ApiGraspOverride_Override_ApiGraspOverride_Override_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ApiGraspOverride_Override_ApiGraspOverride_Override_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ApiGraspOverride_Override_IsValid(int value);
constexpr ApiGraspOverride_Override ApiGraspOverride_Override_Override_MIN = ApiGraspOverride_Override_OVERRIDE_UNKNOWN;
constexpr ApiGraspOverride_Override ApiGraspOverride_Override_Override_MAX = ApiGraspOverride_Override_OVERRIDE_NOT_HOLDING;
constexpr int ApiGraspOverride_Override_Override_ARRAYSIZE = ApiGraspOverride_Override_Override_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ApiGraspOverride_Override_descriptor();
template<typename T>
inline const std::string& ApiGraspOverride_Override_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ApiGraspOverride_Override>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ApiGraspOverride_Override_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ApiGraspOverride_Override_descriptor(), enum_t_value);
}
inline bool ApiGraspOverride_Override_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ApiGraspOverride_Override* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ApiGraspOverride_Override>(
    ApiGraspOverride_Override_descriptor(), name, value);
}
enum GraspPositionConstraint : int {
  GRASP_POSITION_CONSTRAINT_UNKNOWN = 0,
  GRASP_POSITION_CONSTRAINT_NORMAL = 1,
  GRASP_POSITION_CONSTRAINT_FIXED_AT_USER_POSITION = 2,
  GraspPositionConstraint_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GraspPositionConstraint_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GraspPositionConstraint_IsValid(int value);
constexpr GraspPositionConstraint GraspPositionConstraint_MIN = GRASP_POSITION_CONSTRAINT_UNKNOWN;
constexpr GraspPositionConstraint GraspPositionConstraint_MAX = GRASP_POSITION_CONSTRAINT_FIXED_AT_USER_POSITION;
constexpr int GraspPositionConstraint_ARRAYSIZE = GraspPositionConstraint_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GraspPositionConstraint_descriptor();
template<typename T>
inline const std::string& GraspPositionConstraint_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GraspPositionConstraint>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GraspPositionConstraint_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GraspPositionConstraint_descriptor(), enum_t_value);
}
inline bool GraspPositionConstraint_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GraspPositionConstraint* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GraspPositionConstraint>(
    GraspPositionConstraint_descriptor(), name, value);
}
enum ManipulationFeedbackState : int {
  MANIP_STATE_UNKNOWN = 0,
  MANIP_STATE_DONE = 1,
  MANIP_STATE_SEARCHING_FOR_GRASP = 2,
  MANIP_STATE_MOVING_TO_GRASP = 3,
  MANIP_STATE_GRASPING_OBJECT = 4,
  MANIP_STATE_PLACING_OBJECT = 5,
  MANIP_STATE_GRASP_SUCCEEDED = 6,
  MANIP_STATE_GRASP_FAILED = 7,
  MANIP_STATE_GRASP_PLANNING_SUCCEEDED = 11,
  MANIP_STATE_GRASP_PLANNING_NO_SOLUTION = 8,
  MANIP_STATE_GRASP_FAILED_TO_RAYCAST_INTO_MAP = 9,
  MANIP_STATE_GRASP_PLANNING_WAITING_DATA_AT_EDGE = 13,
  MANIP_STATE_WALKING_TO_OBJECT = 10,
  MANIP_STATE_ATTEMPTING_RAYCASTING = 12,
  MANIP_STATE_MOVING_TO_PLACE = 14,
  MANIP_STATE_PLACE_FAILED_TO_RAYCAST_INTO_MAP = 15,
  MANIP_STATE_PLACE_SUCCEEDED = 16,
  MANIP_STATE_PLACE_FAILED = 17,
  ManipulationFeedbackState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ManipulationFeedbackState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ManipulationFeedbackState_IsValid(int value);
constexpr ManipulationFeedbackState ManipulationFeedbackState_MIN = MANIP_STATE_UNKNOWN;
constexpr ManipulationFeedbackState ManipulationFeedbackState_MAX = MANIP_STATE_PLACE_FAILED;
constexpr int ManipulationFeedbackState_ARRAYSIZE = ManipulationFeedbackState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ManipulationFeedbackState_descriptor();
template<typename T>
inline const std::string& ManipulationFeedbackState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ManipulationFeedbackState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ManipulationFeedbackState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ManipulationFeedbackState_descriptor(), enum_t_value);
}
inline bool ManipulationFeedbackState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ManipulationFeedbackState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ManipulationFeedbackState>(
    ManipulationFeedbackState_descriptor(), name, value);
}
enum ManipulationCameraSource : int {
  MANIPULATION_CAMERA_SOURCE_UNKNOWN = 0,
  MANIPULATION_CAMERA_SOURCE_STEREO = 1,
  MANIPULATION_CAMERA_SOURCE_HAND = 2,
  ManipulationCameraSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ManipulationCameraSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ManipulationCameraSource_IsValid(int value);
constexpr ManipulationCameraSource ManipulationCameraSource_MIN = MANIPULATION_CAMERA_SOURCE_UNKNOWN;
constexpr ManipulationCameraSource ManipulationCameraSource_MAX = MANIPULATION_CAMERA_SOURCE_HAND;
constexpr int ManipulationCameraSource_ARRAYSIZE = ManipulationCameraSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ManipulationCameraSource_descriptor();
template<typename T>
inline const std::string& ManipulationCameraSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ManipulationCameraSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ManipulationCameraSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ManipulationCameraSource_descriptor(), enum_t_value);
}
inline bool ManipulationCameraSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ManipulationCameraSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ManipulationCameraSource>(
    ManipulationCameraSource_descriptor(), name, value);
}
enum WalkGazeMode : int {
  PICK_WALK_GAZE_UNKNOWN = 0,
  PICK_AUTO_WALK_AND_GAZE = 1,
  PICK_AUTO_GAZE = 2,
  PICK_NO_AUTO_WALK_OR_GAZE = 3,
  PICK_PLAN_ONLY = 4,
  WalkGazeMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WalkGazeMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WalkGazeMode_IsValid(int value);
constexpr WalkGazeMode WalkGazeMode_MIN = PICK_WALK_GAZE_UNKNOWN;
constexpr WalkGazeMode WalkGazeMode_MAX = PICK_PLAN_ONLY;
constexpr int WalkGazeMode_ARRAYSIZE = WalkGazeMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WalkGazeMode_descriptor();
template<typename T>
inline const std::string& WalkGazeMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WalkGazeMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WalkGazeMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WalkGazeMode_descriptor(), enum_t_value);
}
inline bool WalkGazeMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WalkGazeMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WalkGazeMode>(
    WalkGazeMode_descriptor(), name, value);
}
// ===================================================================

class WalkToObjectRayInWorld final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.WalkToObjectRayInWorld) */ {
 public:
  inline WalkToObjectRayInWorld() : WalkToObjectRayInWorld(nullptr) {}
  ~WalkToObjectRayInWorld() override;
  explicit PROTOBUF_CONSTEXPR WalkToObjectRayInWorld(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WalkToObjectRayInWorld(const WalkToObjectRayInWorld& from);
  WalkToObjectRayInWorld(WalkToObjectRayInWorld&& from) noexcept
    : WalkToObjectRayInWorld() {
    *this = ::std::move(from);
  }

  inline WalkToObjectRayInWorld& operator=(const WalkToObjectRayInWorld& from) {
    CopyFrom(from);
    return *this;
  }
  inline WalkToObjectRayInWorld& operator=(WalkToObjectRayInWorld&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WalkToObjectRayInWorld& default_instance() {
    return *internal_default_instance();
  }
  static inline const WalkToObjectRayInWorld* internal_default_instance() {
    return reinterpret_cast<const WalkToObjectRayInWorld*>(
               &_WalkToObjectRayInWorld_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(WalkToObjectRayInWorld& a, WalkToObjectRayInWorld& b) {
    a.Swap(&b);
  }
  inline void Swap(WalkToObjectRayInWorld* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WalkToObjectRayInWorld* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WalkToObjectRayInWorld* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WalkToObjectRayInWorld>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WalkToObjectRayInWorld& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WalkToObjectRayInWorld& from) {
    WalkToObjectRayInWorld::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WalkToObjectRayInWorld* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.WalkToObjectRayInWorld";
  }
  protected:
  explicit WalkToObjectRayInWorld(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFieldNumber = 3,
    kRayStartRtFrameFieldNumber = 1,
    kRayEndRtFrameFieldNumber = 2,
    kOffsetDistanceFieldNumber = 4,
  };
  // string frame_name = 3;
  void clear_frame_name();
  const std::string& frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name();
  PROTOBUF_NODISCARD std::string* release_frame_name();
  void set_allocated_frame_name(std::string* frame_name);
  private:
  const std::string& _internal_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name(const std::string& value);
  std::string* _internal_mutable_frame_name();
  public:

  // .bosdyn.api.Vec3 ray_start_rt_frame = 1;
  bool has_ray_start_rt_frame() const;
  private:
  bool _internal_has_ray_start_rt_frame() const;
  public:
  void clear_ray_start_rt_frame();
  const ::bosdyn::api::Vec3& ray_start_rt_frame() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_ray_start_rt_frame();
  ::bosdyn::api::Vec3* mutable_ray_start_rt_frame();
  void set_allocated_ray_start_rt_frame(::bosdyn::api::Vec3* ray_start_rt_frame);
  private:
  const ::bosdyn::api::Vec3& _internal_ray_start_rt_frame() const;
  ::bosdyn::api::Vec3* _internal_mutable_ray_start_rt_frame();
  public:
  void unsafe_arena_set_allocated_ray_start_rt_frame(
      ::bosdyn::api::Vec3* ray_start_rt_frame);
  ::bosdyn::api::Vec3* unsafe_arena_release_ray_start_rt_frame();

  // .bosdyn.api.Vec3 ray_end_rt_frame = 2;
  bool has_ray_end_rt_frame() const;
  private:
  bool _internal_has_ray_end_rt_frame() const;
  public:
  void clear_ray_end_rt_frame();
  const ::bosdyn::api::Vec3& ray_end_rt_frame() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_ray_end_rt_frame();
  ::bosdyn::api::Vec3* mutable_ray_end_rt_frame();
  void set_allocated_ray_end_rt_frame(::bosdyn::api::Vec3* ray_end_rt_frame);
  private:
  const ::bosdyn::api::Vec3& _internal_ray_end_rt_frame() const;
  ::bosdyn::api::Vec3* _internal_mutable_ray_end_rt_frame();
  public:
  void unsafe_arena_set_allocated_ray_end_rt_frame(
      ::bosdyn::api::Vec3* ray_end_rt_frame);
  ::bosdyn::api::Vec3* unsafe_arena_release_ray_end_rt_frame();

  // .google.protobuf.FloatValue offset_distance = 4;
  bool has_offset_distance() const;
  private:
  bool _internal_has_offset_distance() const;
  public:
  void clear_offset_distance();
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& offset_distance() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_offset_distance();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_offset_distance();
  void set_allocated_offset_distance(::PROTOBUF_NAMESPACE_ID::FloatValue* offset_distance);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_offset_distance() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_offset_distance();
  public:
  void unsafe_arena_set_allocated_offset_distance(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* offset_distance);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_offset_distance();

  // @@protoc_insertion_point(class_scope:bosdyn.api.WalkToObjectRayInWorld)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_;
    ::bosdyn::api::Vec3* ray_start_rt_frame_;
    ::bosdyn::api::Vec3* ray_end_rt_frame_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* offset_distance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class WalkToObjectInImage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.WalkToObjectInImage) */ {
 public:
  inline WalkToObjectInImage() : WalkToObjectInImage(nullptr) {}
  ~WalkToObjectInImage() override;
  explicit PROTOBUF_CONSTEXPR WalkToObjectInImage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WalkToObjectInImage(const WalkToObjectInImage& from);
  WalkToObjectInImage(WalkToObjectInImage&& from) noexcept
    : WalkToObjectInImage() {
    *this = ::std::move(from);
  }

  inline WalkToObjectInImage& operator=(const WalkToObjectInImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline WalkToObjectInImage& operator=(WalkToObjectInImage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WalkToObjectInImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const WalkToObjectInImage* internal_default_instance() {
    return reinterpret_cast<const WalkToObjectInImage*>(
               &_WalkToObjectInImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(WalkToObjectInImage& a, WalkToObjectInImage& b) {
    a.Swap(&b);
  }
  inline void Swap(WalkToObjectInImage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WalkToObjectInImage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WalkToObjectInImage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WalkToObjectInImage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WalkToObjectInImage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WalkToObjectInImage& from) {
    WalkToObjectInImage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WalkToObjectInImage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.WalkToObjectInImage";
  }
  protected:
  explicit WalkToObjectInImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameImageSensorFieldNumber = 3,
    kPixelXyFieldNumber = 1,
    kTransformsSnapshotForCameraFieldNumber = 2,
    kCameraModelFieldNumber = 4,
    kOffsetDistanceFieldNumber = 5,
  };
  // string frame_name_image_sensor = 3;
  void clear_frame_name_image_sensor();
  const std::string& frame_name_image_sensor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name_image_sensor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name_image_sensor();
  PROTOBUF_NODISCARD std::string* release_frame_name_image_sensor();
  void set_allocated_frame_name_image_sensor(std::string* frame_name_image_sensor);
  private:
  const std::string& _internal_frame_name_image_sensor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name_image_sensor(const std::string& value);
  std::string* _internal_mutable_frame_name_image_sensor();
  public:

  // .bosdyn.api.Vec2 pixel_xy = 1;
  bool has_pixel_xy() const;
  private:
  bool _internal_has_pixel_xy() const;
  public:
  void clear_pixel_xy();
  const ::bosdyn::api::Vec2& pixel_xy() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec2* release_pixel_xy();
  ::bosdyn::api::Vec2* mutable_pixel_xy();
  void set_allocated_pixel_xy(::bosdyn::api::Vec2* pixel_xy);
  private:
  const ::bosdyn::api::Vec2& _internal_pixel_xy() const;
  ::bosdyn::api::Vec2* _internal_mutable_pixel_xy();
  public:
  void unsafe_arena_set_allocated_pixel_xy(
      ::bosdyn::api::Vec2* pixel_xy);
  ::bosdyn::api::Vec2* unsafe_arena_release_pixel_xy();

  // .bosdyn.api.FrameTreeSnapshot transforms_snapshot_for_camera = 2;
  bool has_transforms_snapshot_for_camera() const;
  private:
  bool _internal_has_transforms_snapshot_for_camera() const;
  public:
  void clear_transforms_snapshot_for_camera();
  const ::bosdyn::api::FrameTreeSnapshot& transforms_snapshot_for_camera() const;
  PROTOBUF_NODISCARD ::bosdyn::api::FrameTreeSnapshot* release_transforms_snapshot_for_camera();
  ::bosdyn::api::FrameTreeSnapshot* mutable_transforms_snapshot_for_camera();
  void set_allocated_transforms_snapshot_for_camera(::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_for_camera);
  private:
  const ::bosdyn::api::FrameTreeSnapshot& _internal_transforms_snapshot_for_camera() const;
  ::bosdyn::api::FrameTreeSnapshot* _internal_mutable_transforms_snapshot_for_camera();
  public:
  void unsafe_arena_set_allocated_transforms_snapshot_for_camera(
      ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_for_camera);
  ::bosdyn::api::FrameTreeSnapshot* unsafe_arena_release_transforms_snapshot_for_camera();

  // .bosdyn.api.ImageSource.PinholeModel camera_model = 4;
  bool has_camera_model() const;
  private:
  bool _internal_has_camera_model() const;
  public:
  void clear_camera_model();
  const ::bosdyn::api::ImageSource_PinholeModel& camera_model() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ImageSource_PinholeModel* release_camera_model();
  ::bosdyn::api::ImageSource_PinholeModel* mutable_camera_model();
  void set_allocated_camera_model(::bosdyn::api::ImageSource_PinholeModel* camera_model);
  private:
  const ::bosdyn::api::ImageSource_PinholeModel& _internal_camera_model() const;
  ::bosdyn::api::ImageSource_PinholeModel* _internal_mutable_camera_model();
  public:
  void unsafe_arena_set_allocated_camera_model(
      ::bosdyn::api::ImageSource_PinholeModel* camera_model);
  ::bosdyn::api::ImageSource_PinholeModel* unsafe_arena_release_camera_model();

  // .google.protobuf.FloatValue offset_distance = 5;
  bool has_offset_distance() const;
  private:
  bool _internal_has_offset_distance() const;
  public:
  void clear_offset_distance();
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& offset_distance() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_offset_distance();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_offset_distance();
  void set_allocated_offset_distance(::PROTOBUF_NAMESPACE_ID::FloatValue* offset_distance);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_offset_distance() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_offset_distance();
  public:
  void unsafe_arena_set_allocated_offset_distance(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* offset_distance);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_offset_distance();

  // @@protoc_insertion_point(class_scope:bosdyn.api.WalkToObjectInImage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_image_sensor_;
    ::bosdyn::api::Vec2* pixel_xy_;
    ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_for_camera_;
    ::bosdyn::api::ImageSource_PinholeModel* camera_model_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* offset_distance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class PickObjectRayInWorld final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PickObjectRayInWorld) */ {
 public:
  inline PickObjectRayInWorld() : PickObjectRayInWorld(nullptr) {}
  ~PickObjectRayInWorld() override;
  explicit PROTOBUF_CONSTEXPR PickObjectRayInWorld(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PickObjectRayInWorld(const PickObjectRayInWorld& from);
  PickObjectRayInWorld(PickObjectRayInWorld&& from) noexcept
    : PickObjectRayInWorld() {
    *this = ::std::move(from);
  }

  inline PickObjectRayInWorld& operator=(const PickObjectRayInWorld& from) {
    CopyFrom(from);
    return *this;
  }
  inline PickObjectRayInWorld& operator=(PickObjectRayInWorld&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PickObjectRayInWorld& default_instance() {
    return *internal_default_instance();
  }
  static inline const PickObjectRayInWorld* internal_default_instance() {
    return reinterpret_cast<const PickObjectRayInWorld*>(
               &_PickObjectRayInWorld_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PickObjectRayInWorld& a, PickObjectRayInWorld& b) {
    a.Swap(&b);
  }
  inline void Swap(PickObjectRayInWorld* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PickObjectRayInWorld* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PickObjectRayInWorld* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PickObjectRayInWorld>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PickObjectRayInWorld& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PickObjectRayInWorld& from) {
    PickObjectRayInWorld::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PickObjectRayInWorld* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PickObjectRayInWorld";
  }
  protected:
  explicit PickObjectRayInWorld(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFieldNumber = 6,
    kRayStartRtFrameFieldNumber = 1,
    kRayEndRtFrameFieldNumber = 2,
    kGraspParamsFieldNumber = 10,
    kWalkGazeModeFieldNumber = 4,
  };
  // string frame_name = 6;
  void clear_frame_name();
  const std::string& frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name();
  PROTOBUF_NODISCARD std::string* release_frame_name();
  void set_allocated_frame_name(std::string* frame_name);
  private:
  const std::string& _internal_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name(const std::string& value);
  std::string* _internal_mutable_frame_name();
  public:

  // .bosdyn.api.Vec3 ray_start_rt_frame = 1;
  bool has_ray_start_rt_frame() const;
  private:
  bool _internal_has_ray_start_rt_frame() const;
  public:
  void clear_ray_start_rt_frame();
  const ::bosdyn::api::Vec3& ray_start_rt_frame() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_ray_start_rt_frame();
  ::bosdyn::api::Vec3* mutable_ray_start_rt_frame();
  void set_allocated_ray_start_rt_frame(::bosdyn::api::Vec3* ray_start_rt_frame);
  private:
  const ::bosdyn::api::Vec3& _internal_ray_start_rt_frame() const;
  ::bosdyn::api::Vec3* _internal_mutable_ray_start_rt_frame();
  public:
  void unsafe_arena_set_allocated_ray_start_rt_frame(
      ::bosdyn::api::Vec3* ray_start_rt_frame);
  ::bosdyn::api::Vec3* unsafe_arena_release_ray_start_rt_frame();

  // .bosdyn.api.Vec3 ray_end_rt_frame = 2;
  bool has_ray_end_rt_frame() const;
  private:
  bool _internal_has_ray_end_rt_frame() const;
  public:
  void clear_ray_end_rt_frame();
  const ::bosdyn::api::Vec3& ray_end_rt_frame() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_ray_end_rt_frame();
  ::bosdyn::api::Vec3* mutable_ray_end_rt_frame();
  void set_allocated_ray_end_rt_frame(::bosdyn::api::Vec3* ray_end_rt_frame);
  private:
  const ::bosdyn::api::Vec3& _internal_ray_end_rt_frame() const;
  ::bosdyn::api::Vec3* _internal_mutable_ray_end_rt_frame();
  public:
  void unsafe_arena_set_allocated_ray_end_rt_frame(
      ::bosdyn::api::Vec3* ray_end_rt_frame);
  ::bosdyn::api::Vec3* unsafe_arena_release_ray_end_rt_frame();

  // .bosdyn.api.GraspParams grasp_params = 10;
  bool has_grasp_params() const;
  private:
  bool _internal_has_grasp_params() const;
  public:
  void clear_grasp_params();
  const ::bosdyn::api::GraspParams& grasp_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::GraspParams* release_grasp_params();
  ::bosdyn::api::GraspParams* mutable_grasp_params();
  void set_allocated_grasp_params(::bosdyn::api::GraspParams* grasp_params);
  private:
  const ::bosdyn::api::GraspParams& _internal_grasp_params() const;
  ::bosdyn::api::GraspParams* _internal_mutable_grasp_params();
  public:
  void unsafe_arena_set_allocated_grasp_params(
      ::bosdyn::api::GraspParams* grasp_params);
  ::bosdyn::api::GraspParams* unsafe_arena_release_grasp_params();

  // .bosdyn.api.WalkGazeMode walk_gaze_mode = 4;
  void clear_walk_gaze_mode();
  ::bosdyn::api::WalkGazeMode walk_gaze_mode() const;
  void set_walk_gaze_mode(::bosdyn::api::WalkGazeMode value);
  private:
  ::bosdyn::api::WalkGazeMode _internal_walk_gaze_mode() const;
  void _internal_set_walk_gaze_mode(::bosdyn::api::WalkGazeMode value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.PickObjectRayInWorld)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_;
    ::bosdyn::api::Vec3* ray_start_rt_frame_;
    ::bosdyn::api::Vec3* ray_end_rt_frame_;
    ::bosdyn::api::GraspParams* grasp_params_;
    int walk_gaze_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class PickObjectExecutePlan final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.PickObjectExecutePlan) */ {
 public:
  inline PickObjectExecutePlan() : PickObjectExecutePlan(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PickObjectExecutePlan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PickObjectExecutePlan(const PickObjectExecutePlan& from);
  PickObjectExecutePlan(PickObjectExecutePlan&& from) noexcept
    : PickObjectExecutePlan() {
    *this = ::std::move(from);
  }

  inline PickObjectExecutePlan& operator=(const PickObjectExecutePlan& from) {
    CopyFrom(from);
    return *this;
  }
  inline PickObjectExecutePlan& operator=(PickObjectExecutePlan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PickObjectExecutePlan& default_instance() {
    return *internal_default_instance();
  }
  static inline const PickObjectExecutePlan* internal_default_instance() {
    return reinterpret_cast<const PickObjectExecutePlan*>(
               &_PickObjectExecutePlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PickObjectExecutePlan& a, PickObjectExecutePlan& b) {
    a.Swap(&b);
  }
  inline void Swap(PickObjectExecutePlan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PickObjectExecutePlan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PickObjectExecutePlan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PickObjectExecutePlan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PickObjectExecutePlan& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PickObjectExecutePlan& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PickObjectExecutePlan";
  }
  protected:
  explicit PickObjectExecutePlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.PickObjectExecutePlan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class PickObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PickObject) */ {
 public:
  inline PickObject() : PickObject(nullptr) {}
  ~PickObject() override;
  explicit PROTOBUF_CONSTEXPR PickObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PickObject(const PickObject& from);
  PickObject(PickObject&& from) noexcept
    : PickObject() {
    *this = ::std::move(from);
  }

  inline PickObject& operator=(const PickObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline PickObject& operator=(PickObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PickObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const PickObject* internal_default_instance() {
    return reinterpret_cast<const PickObject*>(
               &_PickObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PickObject& a, PickObject& b) {
    a.Swap(&b);
  }
  inline void Swap(PickObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PickObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PickObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PickObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PickObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PickObject& from) {
    PickObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PickObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PickObject";
  }
  protected:
  explicit PickObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFieldNumber = 1,
    kObjectRtFrameFieldNumber = 2,
    kGraspParamsFieldNumber = 3,
  };
  // string frame_name = 1;
  void clear_frame_name();
  const std::string& frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name();
  PROTOBUF_NODISCARD std::string* release_frame_name();
  void set_allocated_frame_name(std::string* frame_name);
  private:
  const std::string& _internal_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name(const std::string& value);
  std::string* _internal_mutable_frame_name();
  public:

  // .bosdyn.api.Vec3 object_rt_frame = 2;
  bool has_object_rt_frame() const;
  private:
  bool _internal_has_object_rt_frame() const;
  public:
  void clear_object_rt_frame();
  const ::bosdyn::api::Vec3& object_rt_frame() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_object_rt_frame();
  ::bosdyn::api::Vec3* mutable_object_rt_frame();
  void set_allocated_object_rt_frame(::bosdyn::api::Vec3* object_rt_frame);
  private:
  const ::bosdyn::api::Vec3& _internal_object_rt_frame() const;
  ::bosdyn::api::Vec3* _internal_mutable_object_rt_frame();
  public:
  void unsafe_arena_set_allocated_object_rt_frame(
      ::bosdyn::api::Vec3* object_rt_frame);
  ::bosdyn::api::Vec3* unsafe_arena_release_object_rt_frame();

  // .bosdyn.api.GraspParams grasp_params = 3;
  bool has_grasp_params() const;
  private:
  bool _internal_has_grasp_params() const;
  public:
  void clear_grasp_params();
  const ::bosdyn::api::GraspParams& grasp_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::GraspParams* release_grasp_params();
  ::bosdyn::api::GraspParams* mutable_grasp_params();
  void set_allocated_grasp_params(::bosdyn::api::GraspParams* grasp_params);
  private:
  const ::bosdyn::api::GraspParams& _internal_grasp_params() const;
  ::bosdyn::api::GraspParams* _internal_mutable_grasp_params();
  public:
  void unsafe_arena_set_allocated_grasp_params(
      ::bosdyn::api::GraspParams* grasp_params);
  ::bosdyn::api::GraspParams* unsafe_arena_release_grasp_params();

  // @@protoc_insertion_point(class_scope:bosdyn.api.PickObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_;
    ::bosdyn::api::Vec3* object_rt_frame_;
    ::bosdyn::api::GraspParams* grasp_params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class PickObjectInImage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PickObjectInImage) */ {
 public:
  inline PickObjectInImage() : PickObjectInImage(nullptr) {}
  ~PickObjectInImage() override;
  explicit PROTOBUF_CONSTEXPR PickObjectInImage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PickObjectInImage(const PickObjectInImage& from);
  PickObjectInImage(PickObjectInImage&& from) noexcept
    : PickObjectInImage() {
    *this = ::std::move(from);
  }

  inline PickObjectInImage& operator=(const PickObjectInImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PickObjectInImage& operator=(PickObjectInImage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PickObjectInImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PickObjectInImage* internal_default_instance() {
    return reinterpret_cast<const PickObjectInImage*>(
               &_PickObjectInImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PickObjectInImage& a, PickObjectInImage& b) {
    a.Swap(&b);
  }
  inline void Swap(PickObjectInImage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PickObjectInImage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PickObjectInImage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PickObjectInImage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PickObjectInImage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PickObjectInImage& from) {
    PickObjectInImage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PickObjectInImage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PickObjectInImage";
  }
  protected:
  explicit PickObjectInImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameImageSensorFieldNumber = 3,
    kPixelXyFieldNumber = 1,
    kTransformsSnapshotForCameraFieldNumber = 2,
    kCameraModelFieldNumber = 4,
    kGraspParamsFieldNumber = 10,
    kWalkGazeModeFieldNumber = 9,
  };
  // string frame_name_image_sensor = 3;
  void clear_frame_name_image_sensor();
  const std::string& frame_name_image_sensor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name_image_sensor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name_image_sensor();
  PROTOBUF_NODISCARD std::string* release_frame_name_image_sensor();
  void set_allocated_frame_name_image_sensor(std::string* frame_name_image_sensor);
  private:
  const std::string& _internal_frame_name_image_sensor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name_image_sensor(const std::string& value);
  std::string* _internal_mutable_frame_name_image_sensor();
  public:

  // .bosdyn.api.Vec2 pixel_xy = 1;
  bool has_pixel_xy() const;
  private:
  bool _internal_has_pixel_xy() const;
  public:
  void clear_pixel_xy();
  const ::bosdyn::api::Vec2& pixel_xy() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec2* release_pixel_xy();
  ::bosdyn::api::Vec2* mutable_pixel_xy();
  void set_allocated_pixel_xy(::bosdyn::api::Vec2* pixel_xy);
  private:
  const ::bosdyn::api::Vec2& _internal_pixel_xy() const;
  ::bosdyn::api::Vec2* _internal_mutable_pixel_xy();
  public:
  void unsafe_arena_set_allocated_pixel_xy(
      ::bosdyn::api::Vec2* pixel_xy);
  ::bosdyn::api::Vec2* unsafe_arena_release_pixel_xy();

  // .bosdyn.api.FrameTreeSnapshot transforms_snapshot_for_camera = 2;
  bool has_transforms_snapshot_for_camera() const;
  private:
  bool _internal_has_transforms_snapshot_for_camera() const;
  public:
  void clear_transforms_snapshot_for_camera();
  const ::bosdyn::api::FrameTreeSnapshot& transforms_snapshot_for_camera() const;
  PROTOBUF_NODISCARD ::bosdyn::api::FrameTreeSnapshot* release_transforms_snapshot_for_camera();
  ::bosdyn::api::FrameTreeSnapshot* mutable_transforms_snapshot_for_camera();
  void set_allocated_transforms_snapshot_for_camera(::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_for_camera);
  private:
  const ::bosdyn::api::FrameTreeSnapshot& _internal_transforms_snapshot_for_camera() const;
  ::bosdyn::api::FrameTreeSnapshot* _internal_mutable_transforms_snapshot_for_camera();
  public:
  void unsafe_arena_set_allocated_transforms_snapshot_for_camera(
      ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_for_camera);
  ::bosdyn::api::FrameTreeSnapshot* unsafe_arena_release_transforms_snapshot_for_camera();

  // .bosdyn.api.ImageSource.PinholeModel camera_model = 4;
  bool has_camera_model() const;
  private:
  bool _internal_has_camera_model() const;
  public:
  void clear_camera_model();
  const ::bosdyn::api::ImageSource_PinholeModel& camera_model() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ImageSource_PinholeModel* release_camera_model();
  ::bosdyn::api::ImageSource_PinholeModel* mutable_camera_model();
  void set_allocated_camera_model(::bosdyn::api::ImageSource_PinholeModel* camera_model);
  private:
  const ::bosdyn::api::ImageSource_PinholeModel& _internal_camera_model() const;
  ::bosdyn::api::ImageSource_PinholeModel* _internal_mutable_camera_model();
  public:
  void unsafe_arena_set_allocated_camera_model(
      ::bosdyn::api::ImageSource_PinholeModel* camera_model);
  ::bosdyn::api::ImageSource_PinholeModel* unsafe_arena_release_camera_model();

  // .bosdyn.api.GraspParams grasp_params = 10;
  bool has_grasp_params() const;
  private:
  bool _internal_has_grasp_params() const;
  public:
  void clear_grasp_params();
  const ::bosdyn::api::GraspParams& grasp_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::GraspParams* release_grasp_params();
  ::bosdyn::api::GraspParams* mutable_grasp_params();
  void set_allocated_grasp_params(::bosdyn::api::GraspParams* grasp_params);
  private:
  const ::bosdyn::api::GraspParams& _internal_grasp_params() const;
  ::bosdyn::api::GraspParams* _internal_mutable_grasp_params();
  public:
  void unsafe_arena_set_allocated_grasp_params(
      ::bosdyn::api::GraspParams* grasp_params);
  ::bosdyn::api::GraspParams* unsafe_arena_release_grasp_params();

  // .bosdyn.api.WalkGazeMode walk_gaze_mode = 9;
  void clear_walk_gaze_mode();
  ::bosdyn::api::WalkGazeMode walk_gaze_mode() const;
  void set_walk_gaze_mode(::bosdyn::api::WalkGazeMode value);
  private:
  ::bosdyn::api::WalkGazeMode _internal_walk_gaze_mode() const;
  void _internal_set_walk_gaze_mode(::bosdyn::api::WalkGazeMode value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.PickObjectInImage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_image_sensor_;
    ::bosdyn::api::Vec2* pixel_xy_;
    ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_for_camera_;
    ::bosdyn::api::ImageSource_PinholeModel* camera_model_;
    ::bosdyn::api::GraspParams* grasp_params_;
    int walk_gaze_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GraspParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GraspParams) */ {
 public:
  inline GraspParams() : GraspParams(nullptr) {}
  ~GraspParams() override;
  explicit PROTOBUF_CONSTEXPR GraspParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraspParams(const GraspParams& from);
  GraspParams(GraspParams&& from) noexcept
    : GraspParams() {
    *this = ::std::move(from);
  }

  inline GraspParams& operator=(const GraspParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraspParams& operator=(GraspParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraspParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraspParams* internal_default_instance() {
    return reinterpret_cast<const GraspParams*>(
               &_GraspParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GraspParams& a, GraspParams& b) {
    a.Swap(&b);
  }
  inline void Swap(GraspParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraspParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraspParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraspParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraspParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GraspParams& from) {
    GraspParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraspParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GraspParams";
  }
  protected:
  explicit GraspParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowableOrientationFieldNumber = 3,
    kGraspParamsFrameNameFieldNumber = 2,
    kGraspPalmToFingertipFieldNumber = 1,
    kPositionConstraintFieldNumber = 4,
    kManipulationCameraSourceFieldNumber = 5,
  };
  // repeated .bosdyn.api.AllowableOrientation allowable_orientation = 3;
  int allowable_orientation_size() const;
  private:
  int _internal_allowable_orientation_size() const;
  public:
  void clear_allowable_orientation();
  ::bosdyn::api::AllowableOrientation* mutable_allowable_orientation(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::AllowableOrientation >*
      mutable_allowable_orientation();
  private:
  const ::bosdyn::api::AllowableOrientation& _internal_allowable_orientation(int index) const;
  ::bosdyn::api::AllowableOrientation* _internal_add_allowable_orientation();
  public:
  const ::bosdyn::api::AllowableOrientation& allowable_orientation(int index) const;
  ::bosdyn::api::AllowableOrientation* add_allowable_orientation();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::AllowableOrientation >&
      allowable_orientation() const;

  // string grasp_params_frame_name = 2;
  void clear_grasp_params_frame_name();
  const std::string& grasp_params_frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_grasp_params_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_grasp_params_frame_name();
  PROTOBUF_NODISCARD std::string* release_grasp_params_frame_name();
  void set_allocated_grasp_params_frame_name(std::string* grasp_params_frame_name);
  private:
  const std::string& _internal_grasp_params_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_grasp_params_frame_name(const std::string& value);
  std::string* _internal_mutable_grasp_params_frame_name();
  public:

  // float grasp_palm_to_fingertip = 1;
  void clear_grasp_palm_to_fingertip();
  float grasp_palm_to_fingertip() const;
  void set_grasp_palm_to_fingertip(float value);
  private:
  float _internal_grasp_palm_to_fingertip() const;
  void _internal_set_grasp_palm_to_fingertip(float value);
  public:

  // .bosdyn.api.GraspPositionConstraint position_constraint = 4;
  void clear_position_constraint();
  ::bosdyn::api::GraspPositionConstraint position_constraint() const;
  void set_position_constraint(::bosdyn::api::GraspPositionConstraint value);
  private:
  ::bosdyn::api::GraspPositionConstraint _internal_position_constraint() const;
  void _internal_set_position_constraint(::bosdyn::api::GraspPositionConstraint value);
  public:

  // .bosdyn.api.ManipulationCameraSource manipulation_camera_source = 5;
  void clear_manipulation_camera_source();
  ::bosdyn::api::ManipulationCameraSource manipulation_camera_source() const;
  void set_manipulation_camera_source(::bosdyn::api::ManipulationCameraSource value);
  private:
  ::bosdyn::api::ManipulationCameraSource _internal_manipulation_camera_source() const;
  void _internal_set_manipulation_camera_source(::bosdyn::api::ManipulationCameraSource value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.GraspParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::AllowableOrientation > allowable_orientation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr grasp_params_frame_name_;
    float grasp_palm_to_fingertip_;
    int position_constraint_;
    int manipulation_camera_source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class AllowableOrientation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.AllowableOrientation) */ {
 public:
  inline AllowableOrientation() : AllowableOrientation(nullptr) {}
  ~AllowableOrientation() override;
  explicit PROTOBUF_CONSTEXPR AllowableOrientation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllowableOrientation(const AllowableOrientation& from);
  AllowableOrientation(AllowableOrientation&& from) noexcept
    : AllowableOrientation() {
    *this = ::std::move(from);
  }

  inline AllowableOrientation& operator=(const AllowableOrientation& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllowableOrientation& operator=(AllowableOrientation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllowableOrientation& default_instance() {
    return *internal_default_instance();
  }
  enum ConstraintCase {
    kRotationWithTolerance = 1,
    kVectorAlignmentWithTolerance = 2,
    kSqueezeGrasp = 3,
    CONSTRAINT_NOT_SET = 0,
  };

  static inline const AllowableOrientation* internal_default_instance() {
    return reinterpret_cast<const AllowableOrientation*>(
               &_AllowableOrientation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AllowableOrientation& a, AllowableOrientation& b) {
    a.Swap(&b);
  }
  inline void Swap(AllowableOrientation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllowableOrientation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllowableOrientation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllowableOrientation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllowableOrientation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllowableOrientation& from) {
    AllowableOrientation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllowableOrientation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.AllowableOrientation";
  }
  protected:
  explicit AllowableOrientation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRotationWithToleranceFieldNumber = 1,
    kVectorAlignmentWithToleranceFieldNumber = 2,
    kSqueezeGraspFieldNumber = 3,
  };
  // .bosdyn.api.RotationWithTolerance rotation_with_tolerance = 1;
  bool has_rotation_with_tolerance() const;
  private:
  bool _internal_has_rotation_with_tolerance() const;
  public:
  void clear_rotation_with_tolerance();
  const ::bosdyn::api::RotationWithTolerance& rotation_with_tolerance() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RotationWithTolerance* release_rotation_with_tolerance();
  ::bosdyn::api::RotationWithTolerance* mutable_rotation_with_tolerance();
  void set_allocated_rotation_with_tolerance(::bosdyn::api::RotationWithTolerance* rotation_with_tolerance);
  private:
  const ::bosdyn::api::RotationWithTolerance& _internal_rotation_with_tolerance() const;
  ::bosdyn::api::RotationWithTolerance* _internal_mutable_rotation_with_tolerance();
  public:
  void unsafe_arena_set_allocated_rotation_with_tolerance(
      ::bosdyn::api::RotationWithTolerance* rotation_with_tolerance);
  ::bosdyn::api::RotationWithTolerance* unsafe_arena_release_rotation_with_tolerance();

  // .bosdyn.api.VectorAlignmentWithTolerance vector_alignment_with_tolerance = 2;
  bool has_vector_alignment_with_tolerance() const;
  private:
  bool _internal_has_vector_alignment_with_tolerance() const;
  public:
  void clear_vector_alignment_with_tolerance();
  const ::bosdyn::api::VectorAlignmentWithTolerance& vector_alignment_with_tolerance() const;
  PROTOBUF_NODISCARD ::bosdyn::api::VectorAlignmentWithTolerance* release_vector_alignment_with_tolerance();
  ::bosdyn::api::VectorAlignmentWithTolerance* mutable_vector_alignment_with_tolerance();
  void set_allocated_vector_alignment_with_tolerance(::bosdyn::api::VectorAlignmentWithTolerance* vector_alignment_with_tolerance);
  private:
  const ::bosdyn::api::VectorAlignmentWithTolerance& _internal_vector_alignment_with_tolerance() const;
  ::bosdyn::api::VectorAlignmentWithTolerance* _internal_mutable_vector_alignment_with_tolerance();
  public:
  void unsafe_arena_set_allocated_vector_alignment_with_tolerance(
      ::bosdyn::api::VectorAlignmentWithTolerance* vector_alignment_with_tolerance);
  ::bosdyn::api::VectorAlignmentWithTolerance* unsafe_arena_release_vector_alignment_with_tolerance();

  // .bosdyn.api.SqueezeGrasp squeeze_grasp = 3;
  bool has_squeeze_grasp() const;
  private:
  bool _internal_has_squeeze_grasp() const;
  public:
  void clear_squeeze_grasp();
  const ::bosdyn::api::SqueezeGrasp& squeeze_grasp() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SqueezeGrasp* release_squeeze_grasp();
  ::bosdyn::api::SqueezeGrasp* mutable_squeeze_grasp();
  void set_allocated_squeeze_grasp(::bosdyn::api::SqueezeGrasp* squeeze_grasp);
  private:
  const ::bosdyn::api::SqueezeGrasp& _internal_squeeze_grasp() const;
  ::bosdyn::api::SqueezeGrasp* _internal_mutable_squeeze_grasp();
  public:
  void unsafe_arena_set_allocated_squeeze_grasp(
      ::bosdyn::api::SqueezeGrasp* squeeze_grasp);
  ::bosdyn::api::SqueezeGrasp* unsafe_arena_release_squeeze_grasp();

  void clear_constraint();
  ConstraintCase constraint_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.AllowableOrientation)
 private:
  class _Internal;
  void set_has_rotation_with_tolerance();
  void set_has_vector_alignment_with_tolerance();
  void set_has_squeeze_grasp();

  inline bool has_constraint() const;
  inline void clear_has_constraint();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ConstraintUnion {
      constexpr ConstraintUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::RotationWithTolerance* rotation_with_tolerance_;
      ::bosdyn::api::VectorAlignmentWithTolerance* vector_alignment_with_tolerance_;
      ::bosdyn::api::SqueezeGrasp* squeeze_grasp_;
    } constraint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class RotationWithTolerance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RotationWithTolerance) */ {
 public:
  inline RotationWithTolerance() : RotationWithTolerance(nullptr) {}
  ~RotationWithTolerance() override;
  explicit PROTOBUF_CONSTEXPR RotationWithTolerance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RotationWithTolerance(const RotationWithTolerance& from);
  RotationWithTolerance(RotationWithTolerance&& from) noexcept
    : RotationWithTolerance() {
    *this = ::std::move(from);
  }

  inline RotationWithTolerance& operator=(const RotationWithTolerance& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotationWithTolerance& operator=(RotationWithTolerance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotationWithTolerance& default_instance() {
    return *internal_default_instance();
  }
  static inline const RotationWithTolerance* internal_default_instance() {
    return reinterpret_cast<const RotationWithTolerance*>(
               &_RotationWithTolerance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RotationWithTolerance& a, RotationWithTolerance& b) {
    a.Swap(&b);
  }
  inline void Swap(RotationWithTolerance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotationWithTolerance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotationWithTolerance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RotationWithTolerance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RotationWithTolerance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RotationWithTolerance& from) {
    RotationWithTolerance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotationWithTolerance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RotationWithTolerance";
  }
  protected:
  explicit RotationWithTolerance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRotationEwrtFrameFieldNumber = 1,
    kThresholdRadiansFieldNumber = 2,
  };
  // .bosdyn.api.Quaternion rotation_ewrt_frame = 1;
  bool has_rotation_ewrt_frame() const;
  private:
  bool _internal_has_rotation_ewrt_frame() const;
  public:
  void clear_rotation_ewrt_frame();
  const ::bosdyn::api::Quaternion& rotation_ewrt_frame() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Quaternion* release_rotation_ewrt_frame();
  ::bosdyn::api::Quaternion* mutable_rotation_ewrt_frame();
  void set_allocated_rotation_ewrt_frame(::bosdyn::api::Quaternion* rotation_ewrt_frame);
  private:
  const ::bosdyn::api::Quaternion& _internal_rotation_ewrt_frame() const;
  ::bosdyn::api::Quaternion* _internal_mutable_rotation_ewrt_frame();
  public:
  void unsafe_arena_set_allocated_rotation_ewrt_frame(
      ::bosdyn::api::Quaternion* rotation_ewrt_frame);
  ::bosdyn::api::Quaternion* unsafe_arena_release_rotation_ewrt_frame();

  // float threshold_radians = 2;
  void clear_threshold_radians();
  float threshold_radians() const;
  void set_threshold_radians(float value);
  private:
  float _internal_threshold_radians() const;
  void _internal_set_threshold_radians(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.RotationWithTolerance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Quaternion* rotation_ewrt_frame_;
    float threshold_radians_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class VectorAlignmentWithTolerance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.VectorAlignmentWithTolerance) */ {
 public:
  inline VectorAlignmentWithTolerance() : VectorAlignmentWithTolerance(nullptr) {}
  ~VectorAlignmentWithTolerance() override;
  explicit PROTOBUF_CONSTEXPR VectorAlignmentWithTolerance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorAlignmentWithTolerance(const VectorAlignmentWithTolerance& from);
  VectorAlignmentWithTolerance(VectorAlignmentWithTolerance&& from) noexcept
    : VectorAlignmentWithTolerance() {
    *this = ::std::move(from);
  }

  inline VectorAlignmentWithTolerance& operator=(const VectorAlignmentWithTolerance& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorAlignmentWithTolerance& operator=(VectorAlignmentWithTolerance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorAlignmentWithTolerance& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorAlignmentWithTolerance* internal_default_instance() {
    return reinterpret_cast<const VectorAlignmentWithTolerance*>(
               &_VectorAlignmentWithTolerance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VectorAlignmentWithTolerance& a, VectorAlignmentWithTolerance& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorAlignmentWithTolerance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorAlignmentWithTolerance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorAlignmentWithTolerance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorAlignmentWithTolerance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorAlignmentWithTolerance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VectorAlignmentWithTolerance& from) {
    VectorAlignmentWithTolerance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorAlignmentWithTolerance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.VectorAlignmentWithTolerance";
  }
  protected:
  explicit VectorAlignmentWithTolerance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAxisOnGripperEwrtGripperFieldNumber = 1,
    kAxisToAlignWithEwrtFrameFieldNumber = 2,
    kThresholdRadiansFieldNumber = 3,
  };
  // .bosdyn.api.Vec3 axis_on_gripper_ewrt_gripper = 1;
  bool has_axis_on_gripper_ewrt_gripper() const;
  private:
  bool _internal_has_axis_on_gripper_ewrt_gripper() const;
  public:
  void clear_axis_on_gripper_ewrt_gripper();
  const ::bosdyn::api::Vec3& axis_on_gripper_ewrt_gripper() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_axis_on_gripper_ewrt_gripper();
  ::bosdyn::api::Vec3* mutable_axis_on_gripper_ewrt_gripper();
  void set_allocated_axis_on_gripper_ewrt_gripper(::bosdyn::api::Vec3* axis_on_gripper_ewrt_gripper);
  private:
  const ::bosdyn::api::Vec3& _internal_axis_on_gripper_ewrt_gripper() const;
  ::bosdyn::api::Vec3* _internal_mutable_axis_on_gripper_ewrt_gripper();
  public:
  void unsafe_arena_set_allocated_axis_on_gripper_ewrt_gripper(
      ::bosdyn::api::Vec3* axis_on_gripper_ewrt_gripper);
  ::bosdyn::api::Vec3* unsafe_arena_release_axis_on_gripper_ewrt_gripper();

  // .bosdyn.api.Vec3 axis_to_align_with_ewrt_frame = 2;
  bool has_axis_to_align_with_ewrt_frame() const;
  private:
  bool _internal_has_axis_to_align_with_ewrt_frame() const;
  public:
  void clear_axis_to_align_with_ewrt_frame();
  const ::bosdyn::api::Vec3& axis_to_align_with_ewrt_frame() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_axis_to_align_with_ewrt_frame();
  ::bosdyn::api::Vec3* mutable_axis_to_align_with_ewrt_frame();
  void set_allocated_axis_to_align_with_ewrt_frame(::bosdyn::api::Vec3* axis_to_align_with_ewrt_frame);
  private:
  const ::bosdyn::api::Vec3& _internal_axis_to_align_with_ewrt_frame() const;
  ::bosdyn::api::Vec3* _internal_mutable_axis_to_align_with_ewrt_frame();
  public:
  void unsafe_arena_set_allocated_axis_to_align_with_ewrt_frame(
      ::bosdyn::api::Vec3* axis_to_align_with_ewrt_frame);
  ::bosdyn::api::Vec3* unsafe_arena_release_axis_to_align_with_ewrt_frame();

  // float threshold_radians = 3;
  void clear_threshold_radians();
  float threshold_radians() const;
  void set_threshold_radians(float value);
  private:
  float _internal_threshold_radians() const;
  void _internal_set_threshold_radians(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.VectorAlignmentWithTolerance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec3* axis_on_gripper_ewrt_gripper_;
    ::bosdyn::api::Vec3* axis_to_align_with_ewrt_frame_;
    float threshold_radians_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SqueezeGrasp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SqueezeGrasp) */ {
 public:
  inline SqueezeGrasp() : SqueezeGrasp(nullptr) {}
  ~SqueezeGrasp() override;
  explicit PROTOBUF_CONSTEXPR SqueezeGrasp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SqueezeGrasp(const SqueezeGrasp& from);
  SqueezeGrasp(SqueezeGrasp&& from) noexcept
    : SqueezeGrasp() {
    *this = ::std::move(from);
  }

  inline SqueezeGrasp& operator=(const SqueezeGrasp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SqueezeGrasp& operator=(SqueezeGrasp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SqueezeGrasp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SqueezeGrasp* internal_default_instance() {
    return reinterpret_cast<const SqueezeGrasp*>(
               &_SqueezeGrasp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SqueezeGrasp& a, SqueezeGrasp& b) {
    a.Swap(&b);
  }
  inline void Swap(SqueezeGrasp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SqueezeGrasp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SqueezeGrasp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SqueezeGrasp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SqueezeGrasp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SqueezeGrasp& from) {
    SqueezeGrasp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SqueezeGrasp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SqueezeGrasp";
  }
  protected:
  explicit SqueezeGrasp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSqueezeGraspDisallowedFieldNumber = 1,
  };
  // bool squeeze_grasp_disallowed = 1;
  void clear_squeeze_grasp_disallowed();
  bool squeeze_grasp_disallowed() const;
  void set_squeeze_grasp_disallowed(bool value);
  private:
  bool _internal_squeeze_grasp_disallowed() const;
  void _internal_set_squeeze_grasp_disallowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SqueezeGrasp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool squeeze_grasp_disallowed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ManipulationApiFeedbackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ManipulationApiFeedbackRequest) */ {
 public:
  inline ManipulationApiFeedbackRequest() : ManipulationApiFeedbackRequest(nullptr) {}
  ~ManipulationApiFeedbackRequest() override;
  explicit PROTOBUF_CONSTEXPR ManipulationApiFeedbackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ManipulationApiFeedbackRequest(const ManipulationApiFeedbackRequest& from);
  ManipulationApiFeedbackRequest(ManipulationApiFeedbackRequest&& from) noexcept
    : ManipulationApiFeedbackRequest() {
    *this = ::std::move(from);
  }

  inline ManipulationApiFeedbackRequest& operator=(const ManipulationApiFeedbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManipulationApiFeedbackRequest& operator=(ManipulationApiFeedbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ManipulationApiFeedbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManipulationApiFeedbackRequest* internal_default_instance() {
    return reinterpret_cast<const ManipulationApiFeedbackRequest*>(
               &_ManipulationApiFeedbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ManipulationApiFeedbackRequest& a, ManipulationApiFeedbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ManipulationApiFeedbackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManipulationApiFeedbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ManipulationApiFeedbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ManipulationApiFeedbackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ManipulationApiFeedbackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ManipulationApiFeedbackRequest& from) {
    ManipulationApiFeedbackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManipulationApiFeedbackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ManipulationApiFeedbackRequest";
  }
  protected:
  explicit ManipulationApiFeedbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kManipulationCmdIdFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // int32 manipulation_cmd_id = 2;
  void clear_manipulation_cmd_id();
  int32_t manipulation_cmd_id() const;
  void set_manipulation_cmd_id(int32_t value);
  private:
  int32_t _internal_manipulation_cmd_id() const;
  void _internal_set_manipulation_cmd_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ManipulationApiFeedbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    int32_t manipulation_cmd_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ManipulationApiFeedbackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ManipulationApiFeedbackResponse) */ {
 public:
  inline ManipulationApiFeedbackResponse() : ManipulationApiFeedbackResponse(nullptr) {}
  ~ManipulationApiFeedbackResponse() override;
  explicit PROTOBUF_CONSTEXPR ManipulationApiFeedbackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ManipulationApiFeedbackResponse(const ManipulationApiFeedbackResponse& from);
  ManipulationApiFeedbackResponse(ManipulationApiFeedbackResponse&& from) noexcept
    : ManipulationApiFeedbackResponse() {
    *this = ::std::move(from);
  }

  inline ManipulationApiFeedbackResponse& operator=(const ManipulationApiFeedbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManipulationApiFeedbackResponse& operator=(ManipulationApiFeedbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ManipulationApiFeedbackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManipulationApiFeedbackResponse* internal_default_instance() {
    return reinterpret_cast<const ManipulationApiFeedbackResponse*>(
               &_ManipulationApiFeedbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ManipulationApiFeedbackResponse& a, ManipulationApiFeedbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ManipulationApiFeedbackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManipulationApiFeedbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ManipulationApiFeedbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ManipulationApiFeedbackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ManipulationApiFeedbackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ManipulationApiFeedbackResponse& from) {
    ManipulationApiFeedbackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManipulationApiFeedbackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ManipulationApiFeedbackResponse";
  }
  protected:
  explicit ManipulationApiFeedbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kTransformsSnapshotManipulationDataFieldNumber = 3,
    kCurrentStateFieldNumber = 2,
    kManipulationCmdIdFieldNumber = 4,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.FrameTreeSnapshot transforms_snapshot_manipulation_data = 3;
  bool has_transforms_snapshot_manipulation_data() const;
  private:
  bool _internal_has_transforms_snapshot_manipulation_data() const;
  public:
  void clear_transforms_snapshot_manipulation_data();
  const ::bosdyn::api::FrameTreeSnapshot& transforms_snapshot_manipulation_data() const;
  PROTOBUF_NODISCARD ::bosdyn::api::FrameTreeSnapshot* release_transforms_snapshot_manipulation_data();
  ::bosdyn::api::FrameTreeSnapshot* mutable_transforms_snapshot_manipulation_data();
  void set_allocated_transforms_snapshot_manipulation_data(::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_manipulation_data);
  private:
  const ::bosdyn::api::FrameTreeSnapshot& _internal_transforms_snapshot_manipulation_data() const;
  ::bosdyn::api::FrameTreeSnapshot* _internal_mutable_transforms_snapshot_manipulation_data();
  public:
  void unsafe_arena_set_allocated_transforms_snapshot_manipulation_data(
      ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_manipulation_data);
  ::bosdyn::api::FrameTreeSnapshot* unsafe_arena_release_transforms_snapshot_manipulation_data();

  // .bosdyn.api.ManipulationFeedbackState current_state = 2;
  void clear_current_state();
  ::bosdyn::api::ManipulationFeedbackState current_state() const;
  void set_current_state(::bosdyn::api::ManipulationFeedbackState value);
  private:
  ::bosdyn::api::ManipulationFeedbackState _internal_current_state() const;
  void _internal_set_current_state(::bosdyn::api::ManipulationFeedbackState value);
  public:

  // int32 manipulation_cmd_id = 4;
  void clear_manipulation_cmd_id();
  int32_t manipulation_cmd_id() const;
  void set_manipulation_cmd_id(int32_t value);
  private:
  int32_t _internal_manipulation_cmd_id() const;
  void _internal_set_manipulation_cmd_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ManipulationApiFeedbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_manipulation_data_;
    int current_state_;
    int32_t manipulation_cmd_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ManipulationApiResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ManipulationApiResponse) */ {
 public:
  inline ManipulationApiResponse() : ManipulationApiResponse(nullptr) {}
  ~ManipulationApiResponse() override;
  explicit PROTOBUF_CONSTEXPR ManipulationApiResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ManipulationApiResponse(const ManipulationApiResponse& from);
  ManipulationApiResponse(ManipulationApiResponse&& from) noexcept
    : ManipulationApiResponse() {
    *this = ::std::move(from);
  }

  inline ManipulationApiResponse& operator=(const ManipulationApiResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManipulationApiResponse& operator=(ManipulationApiResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ManipulationApiResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManipulationApiResponse* internal_default_instance() {
    return reinterpret_cast<const ManipulationApiResponse*>(
               &_ManipulationApiResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ManipulationApiResponse& a, ManipulationApiResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ManipulationApiResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManipulationApiResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ManipulationApiResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ManipulationApiResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ManipulationApiResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ManipulationApiResponse& from) {
    ManipulationApiResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManipulationApiResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ManipulationApiResponse";
  }
  protected:
  explicit ManipulationApiResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 6,
    kManipulationCmdIdFieldNumber = 5,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 6;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  PROTOBUF_NODISCARD ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // int32 manipulation_cmd_id = 5;
  void clear_manipulation_cmd_id();
  int32_t manipulation_cmd_id() const;
  void set_manipulation_cmd_id(int32_t value);
  private:
  int32_t _internal_manipulation_cmd_id() const;
  void _internal_set_manipulation_cmd_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ManipulationApiResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::LeaseUseResult* lease_use_result_;
    int32_t manipulation_cmd_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ManipulationApiRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ManipulationApiRequest) */ {
 public:
  inline ManipulationApiRequest() : ManipulationApiRequest(nullptr) {}
  ~ManipulationApiRequest() override;
  explicit PROTOBUF_CONSTEXPR ManipulationApiRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ManipulationApiRequest(const ManipulationApiRequest& from);
  ManipulationApiRequest(ManipulationApiRequest&& from) noexcept
    : ManipulationApiRequest() {
    *this = ::std::move(from);
  }

  inline ManipulationApiRequest& operator=(const ManipulationApiRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManipulationApiRequest& operator=(ManipulationApiRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ManipulationApiRequest& default_instance() {
    return *internal_default_instance();
  }
  enum ManipulationCmdCase {
    kWalkToObjectRayInWorld = 12,
    kWalkToObjectInImage = 13,
    kPickObject = 10,
    kPickObjectInImage = 11,
    kPickObjectRayInWorld = 4,
    kPickObjectExecutePlan = 14,
    MANIPULATION_CMD_NOT_SET = 0,
  };

  static inline const ManipulationApiRequest* internal_default_instance() {
    return reinterpret_cast<const ManipulationApiRequest*>(
               &_ManipulationApiRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ManipulationApiRequest& a, ManipulationApiRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ManipulationApiRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManipulationApiRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ManipulationApiRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ManipulationApiRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ManipulationApiRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ManipulationApiRequest& from) {
    ManipulationApiRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManipulationApiRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ManipulationApiRequest";
  }
  protected:
  explicit ManipulationApiRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 2,
    kWalkToObjectRayInWorldFieldNumber = 12,
    kWalkToObjectInImageFieldNumber = 13,
    kPickObjectFieldNumber = 10,
    kPickObjectInImageFieldNumber = 11,
    kPickObjectRayInWorldFieldNumber = 4,
    kPickObjectExecutePlanFieldNumber = 14,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // .bosdyn.api.WalkToObjectRayInWorld walk_to_object_ray_in_world = 12;
  bool has_walk_to_object_ray_in_world() const;
  private:
  bool _internal_has_walk_to_object_ray_in_world() const;
  public:
  void clear_walk_to_object_ray_in_world();
  const ::bosdyn::api::WalkToObjectRayInWorld& walk_to_object_ray_in_world() const;
  PROTOBUF_NODISCARD ::bosdyn::api::WalkToObjectRayInWorld* release_walk_to_object_ray_in_world();
  ::bosdyn::api::WalkToObjectRayInWorld* mutable_walk_to_object_ray_in_world();
  void set_allocated_walk_to_object_ray_in_world(::bosdyn::api::WalkToObjectRayInWorld* walk_to_object_ray_in_world);
  private:
  const ::bosdyn::api::WalkToObjectRayInWorld& _internal_walk_to_object_ray_in_world() const;
  ::bosdyn::api::WalkToObjectRayInWorld* _internal_mutable_walk_to_object_ray_in_world();
  public:
  void unsafe_arena_set_allocated_walk_to_object_ray_in_world(
      ::bosdyn::api::WalkToObjectRayInWorld* walk_to_object_ray_in_world);
  ::bosdyn::api::WalkToObjectRayInWorld* unsafe_arena_release_walk_to_object_ray_in_world();

  // .bosdyn.api.WalkToObjectInImage walk_to_object_in_image = 13;
  bool has_walk_to_object_in_image() const;
  private:
  bool _internal_has_walk_to_object_in_image() const;
  public:
  void clear_walk_to_object_in_image();
  const ::bosdyn::api::WalkToObjectInImage& walk_to_object_in_image() const;
  PROTOBUF_NODISCARD ::bosdyn::api::WalkToObjectInImage* release_walk_to_object_in_image();
  ::bosdyn::api::WalkToObjectInImage* mutable_walk_to_object_in_image();
  void set_allocated_walk_to_object_in_image(::bosdyn::api::WalkToObjectInImage* walk_to_object_in_image);
  private:
  const ::bosdyn::api::WalkToObjectInImage& _internal_walk_to_object_in_image() const;
  ::bosdyn::api::WalkToObjectInImage* _internal_mutable_walk_to_object_in_image();
  public:
  void unsafe_arena_set_allocated_walk_to_object_in_image(
      ::bosdyn::api::WalkToObjectInImage* walk_to_object_in_image);
  ::bosdyn::api::WalkToObjectInImage* unsafe_arena_release_walk_to_object_in_image();

  // .bosdyn.api.PickObject pick_object = 10;
  bool has_pick_object() const;
  private:
  bool _internal_has_pick_object() const;
  public:
  void clear_pick_object();
  const ::bosdyn::api::PickObject& pick_object() const;
  PROTOBUF_NODISCARD ::bosdyn::api::PickObject* release_pick_object();
  ::bosdyn::api::PickObject* mutable_pick_object();
  void set_allocated_pick_object(::bosdyn::api::PickObject* pick_object);
  private:
  const ::bosdyn::api::PickObject& _internal_pick_object() const;
  ::bosdyn::api::PickObject* _internal_mutable_pick_object();
  public:
  void unsafe_arena_set_allocated_pick_object(
      ::bosdyn::api::PickObject* pick_object);
  ::bosdyn::api::PickObject* unsafe_arena_release_pick_object();

  // .bosdyn.api.PickObjectInImage pick_object_in_image = 11;
  bool has_pick_object_in_image() const;
  private:
  bool _internal_has_pick_object_in_image() const;
  public:
  void clear_pick_object_in_image();
  const ::bosdyn::api::PickObjectInImage& pick_object_in_image() const;
  PROTOBUF_NODISCARD ::bosdyn::api::PickObjectInImage* release_pick_object_in_image();
  ::bosdyn::api::PickObjectInImage* mutable_pick_object_in_image();
  void set_allocated_pick_object_in_image(::bosdyn::api::PickObjectInImage* pick_object_in_image);
  private:
  const ::bosdyn::api::PickObjectInImage& _internal_pick_object_in_image() const;
  ::bosdyn::api::PickObjectInImage* _internal_mutable_pick_object_in_image();
  public:
  void unsafe_arena_set_allocated_pick_object_in_image(
      ::bosdyn::api::PickObjectInImage* pick_object_in_image);
  ::bosdyn::api::PickObjectInImage* unsafe_arena_release_pick_object_in_image();

  // .bosdyn.api.PickObjectRayInWorld pick_object_ray_in_world = 4;
  bool has_pick_object_ray_in_world() const;
  private:
  bool _internal_has_pick_object_ray_in_world() const;
  public:
  void clear_pick_object_ray_in_world();
  const ::bosdyn::api::PickObjectRayInWorld& pick_object_ray_in_world() const;
  PROTOBUF_NODISCARD ::bosdyn::api::PickObjectRayInWorld* release_pick_object_ray_in_world();
  ::bosdyn::api::PickObjectRayInWorld* mutable_pick_object_ray_in_world();
  void set_allocated_pick_object_ray_in_world(::bosdyn::api::PickObjectRayInWorld* pick_object_ray_in_world);
  private:
  const ::bosdyn::api::PickObjectRayInWorld& _internal_pick_object_ray_in_world() const;
  ::bosdyn::api::PickObjectRayInWorld* _internal_mutable_pick_object_ray_in_world();
  public:
  void unsafe_arena_set_allocated_pick_object_ray_in_world(
      ::bosdyn::api::PickObjectRayInWorld* pick_object_ray_in_world);
  ::bosdyn::api::PickObjectRayInWorld* unsafe_arena_release_pick_object_ray_in_world();

  // .bosdyn.api.PickObjectExecutePlan pick_object_execute_plan = 14;
  bool has_pick_object_execute_plan() const;
  private:
  bool _internal_has_pick_object_execute_plan() const;
  public:
  void clear_pick_object_execute_plan();
  const ::bosdyn::api::PickObjectExecutePlan& pick_object_execute_plan() const;
  PROTOBUF_NODISCARD ::bosdyn::api::PickObjectExecutePlan* release_pick_object_execute_plan();
  ::bosdyn::api::PickObjectExecutePlan* mutable_pick_object_execute_plan();
  void set_allocated_pick_object_execute_plan(::bosdyn::api::PickObjectExecutePlan* pick_object_execute_plan);
  private:
  const ::bosdyn::api::PickObjectExecutePlan& _internal_pick_object_execute_plan() const;
  ::bosdyn::api::PickObjectExecutePlan* _internal_mutable_pick_object_execute_plan();
  public:
  void unsafe_arena_set_allocated_pick_object_execute_plan(
      ::bosdyn::api::PickObjectExecutePlan* pick_object_execute_plan);
  ::bosdyn::api::PickObjectExecutePlan* unsafe_arena_release_pick_object_execute_plan();

  void clear_manipulation_cmd();
  ManipulationCmdCase manipulation_cmd_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.ManipulationApiRequest)
 private:
  class _Internal;
  void set_has_walk_to_object_ray_in_world();
  void set_has_walk_to_object_in_image();
  void set_has_pick_object();
  void set_has_pick_object_in_image();
  void set_has_pick_object_ray_in_world();
  void set_has_pick_object_execute_plan();

  inline bool has_manipulation_cmd() const;
  inline void clear_has_manipulation_cmd();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::Lease* lease_;
    union ManipulationCmdUnion {
      constexpr ManipulationCmdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::WalkToObjectRayInWorld* walk_to_object_ray_in_world_;
      ::bosdyn::api::WalkToObjectInImage* walk_to_object_in_image_;
      ::bosdyn::api::PickObject* pick_object_;
      ::bosdyn::api::PickObjectInImage* pick_object_in_image_;
      ::bosdyn::api::PickObjectRayInWorld* pick_object_ray_in_world_;
      ::bosdyn::api::PickObjectExecutePlan* pick_object_execute_plan_;
    } manipulation_cmd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ApiGraspOverride final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ApiGraspOverride) */ {
 public:
  inline ApiGraspOverride() : ApiGraspOverride(nullptr) {}
  ~ApiGraspOverride() override;
  explicit PROTOBUF_CONSTEXPR ApiGraspOverride(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApiGraspOverride(const ApiGraspOverride& from);
  ApiGraspOverride(ApiGraspOverride&& from) noexcept
    : ApiGraspOverride() {
    *this = ::std::move(from);
  }

  inline ApiGraspOverride& operator=(const ApiGraspOverride& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApiGraspOverride& operator=(ApiGraspOverride&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApiGraspOverride& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApiGraspOverride* internal_default_instance() {
    return reinterpret_cast<const ApiGraspOverride*>(
               &_ApiGraspOverride_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ApiGraspOverride& a, ApiGraspOverride& b) {
    a.Swap(&b);
  }
  inline void Swap(ApiGraspOverride* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApiGraspOverride* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApiGraspOverride* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApiGraspOverride>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApiGraspOverride& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApiGraspOverride& from) {
    ApiGraspOverride::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApiGraspOverride* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ApiGraspOverride";
  }
  protected:
  explicit ApiGraspOverride(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ApiGraspOverride_Override Override;
  static constexpr Override OVERRIDE_UNKNOWN =
    ApiGraspOverride_Override_OVERRIDE_UNKNOWN;
  static constexpr Override OVERRIDE_HOLDING =
    ApiGraspOverride_Override_OVERRIDE_HOLDING;
  static constexpr Override OVERRIDE_NOT_HOLDING =
    ApiGraspOverride_Override_OVERRIDE_NOT_HOLDING;
  static inline bool Override_IsValid(int value) {
    return ApiGraspOverride_Override_IsValid(value);
  }
  static constexpr Override Override_MIN =
    ApiGraspOverride_Override_Override_MIN;
  static constexpr Override Override_MAX =
    ApiGraspOverride_Override_Override_MAX;
  static constexpr int Override_ARRAYSIZE =
    ApiGraspOverride_Override_Override_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Override_descriptor() {
    return ApiGraspOverride_Override_descriptor();
  }
  template<typename T>
  static inline const std::string& Override_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Override>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Override_Name.");
    return ApiGraspOverride_Override_Name(enum_t_value);
  }
  static inline bool Override_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Override* value) {
    return ApiGraspOverride_Override_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOverrideRequestFieldNumber = 1,
  };
  // .bosdyn.api.ApiGraspOverride.Override override_request = 1;
  void clear_override_request();
  ::bosdyn::api::ApiGraspOverride_Override override_request() const;
  void set_override_request(::bosdyn::api::ApiGraspOverride_Override value);
  private:
  ::bosdyn::api::ApiGraspOverride_Override _internal_override_request() const;
  void _internal_set_override_request(::bosdyn::api::ApiGraspOverride_Override value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ApiGraspOverride)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int override_request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ApiGraspedCarryStateOverride final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ApiGraspedCarryStateOverride) */ {
 public:
  inline ApiGraspedCarryStateOverride() : ApiGraspedCarryStateOverride(nullptr) {}
  ~ApiGraspedCarryStateOverride() override;
  explicit PROTOBUF_CONSTEXPR ApiGraspedCarryStateOverride(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApiGraspedCarryStateOverride(const ApiGraspedCarryStateOverride& from);
  ApiGraspedCarryStateOverride(ApiGraspedCarryStateOverride&& from) noexcept
    : ApiGraspedCarryStateOverride() {
    *this = ::std::move(from);
  }

  inline ApiGraspedCarryStateOverride& operator=(const ApiGraspedCarryStateOverride& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApiGraspedCarryStateOverride& operator=(ApiGraspedCarryStateOverride&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApiGraspedCarryStateOverride& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApiGraspedCarryStateOverride* internal_default_instance() {
    return reinterpret_cast<const ApiGraspedCarryStateOverride*>(
               &_ApiGraspedCarryStateOverride_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ApiGraspedCarryStateOverride& a, ApiGraspedCarryStateOverride& b) {
    a.Swap(&b);
  }
  inline void Swap(ApiGraspedCarryStateOverride* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApiGraspedCarryStateOverride* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApiGraspedCarryStateOverride* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApiGraspedCarryStateOverride>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApiGraspedCarryStateOverride& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApiGraspedCarryStateOverride& from) {
    ApiGraspedCarryStateOverride::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApiGraspedCarryStateOverride* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ApiGraspedCarryStateOverride";
  }
  protected:
  explicit ApiGraspedCarryStateOverride(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverrideRequestFieldNumber = 1,
  };
  // .bosdyn.api.ManipulatorState.CarryState override_request = 1;
  void clear_override_request();
  ::bosdyn::api::ManipulatorState_CarryState override_request() const;
  void set_override_request(::bosdyn::api::ManipulatorState_CarryState value);
  private:
  ::bosdyn::api::ManipulatorState_CarryState _internal_override_request() const;
  void _internal_set_override_request(::bosdyn::api::ManipulatorState_CarryState value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ApiGraspedCarryStateOverride)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int override_request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ApiGraspOverrideRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ApiGraspOverrideRequest) */ {
 public:
  inline ApiGraspOverrideRequest() : ApiGraspOverrideRequest(nullptr) {}
  ~ApiGraspOverrideRequest() override;
  explicit PROTOBUF_CONSTEXPR ApiGraspOverrideRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApiGraspOverrideRequest(const ApiGraspOverrideRequest& from);
  ApiGraspOverrideRequest(ApiGraspOverrideRequest&& from) noexcept
    : ApiGraspOverrideRequest() {
    *this = ::std::move(from);
  }

  inline ApiGraspOverrideRequest& operator=(const ApiGraspOverrideRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApiGraspOverrideRequest& operator=(ApiGraspOverrideRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApiGraspOverrideRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApiGraspOverrideRequest* internal_default_instance() {
    return reinterpret_cast<const ApiGraspOverrideRequest*>(
               &_ApiGraspOverrideRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ApiGraspOverrideRequest& a, ApiGraspOverrideRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ApiGraspOverrideRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApiGraspOverrideRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApiGraspOverrideRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApiGraspOverrideRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApiGraspOverrideRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApiGraspOverrideRequest& from) {
    ApiGraspOverrideRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApiGraspOverrideRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ApiGraspOverrideRequest";
  }
  protected:
  explicit ApiGraspOverrideRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kCarryStateOverrideFieldNumber = 2,
    kApiGraspOverrideFieldNumber = 4,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.ApiGraspedCarryStateOverride carry_state_override = 2;
  bool has_carry_state_override() const;
  private:
  bool _internal_has_carry_state_override() const;
  public:
  void clear_carry_state_override();
  const ::bosdyn::api::ApiGraspedCarryStateOverride& carry_state_override() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ApiGraspedCarryStateOverride* release_carry_state_override();
  ::bosdyn::api::ApiGraspedCarryStateOverride* mutable_carry_state_override();
  void set_allocated_carry_state_override(::bosdyn::api::ApiGraspedCarryStateOverride* carry_state_override);
  private:
  const ::bosdyn::api::ApiGraspedCarryStateOverride& _internal_carry_state_override() const;
  ::bosdyn::api::ApiGraspedCarryStateOverride* _internal_mutable_carry_state_override();
  public:
  void unsafe_arena_set_allocated_carry_state_override(
      ::bosdyn::api::ApiGraspedCarryStateOverride* carry_state_override);
  ::bosdyn::api::ApiGraspedCarryStateOverride* unsafe_arena_release_carry_state_override();

  // .bosdyn.api.ApiGraspOverride api_grasp_override = 4;
  bool has_api_grasp_override() const;
  private:
  bool _internal_has_api_grasp_override() const;
  public:
  void clear_api_grasp_override();
  const ::bosdyn::api::ApiGraspOverride& api_grasp_override() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ApiGraspOverride* release_api_grasp_override();
  ::bosdyn::api::ApiGraspOverride* mutable_api_grasp_override();
  void set_allocated_api_grasp_override(::bosdyn::api::ApiGraspOverride* api_grasp_override);
  private:
  const ::bosdyn::api::ApiGraspOverride& _internal_api_grasp_override() const;
  ::bosdyn::api::ApiGraspOverride* _internal_mutable_api_grasp_override();
  public:
  void unsafe_arena_set_allocated_api_grasp_override(
      ::bosdyn::api::ApiGraspOverride* api_grasp_override);
  ::bosdyn::api::ApiGraspOverride* unsafe_arena_release_api_grasp_override();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ApiGraspOverrideRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::ApiGraspedCarryStateOverride* carry_state_override_;
    ::bosdyn::api::ApiGraspOverride* api_grasp_override_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ApiGraspOverrideResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ApiGraspOverrideResponse) */ {
 public:
  inline ApiGraspOverrideResponse() : ApiGraspOverrideResponse(nullptr) {}
  ~ApiGraspOverrideResponse() override;
  explicit PROTOBUF_CONSTEXPR ApiGraspOverrideResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApiGraspOverrideResponse(const ApiGraspOverrideResponse& from);
  ApiGraspOverrideResponse(ApiGraspOverrideResponse&& from) noexcept
    : ApiGraspOverrideResponse() {
    *this = ::std::move(from);
  }

  inline ApiGraspOverrideResponse& operator=(const ApiGraspOverrideResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApiGraspOverrideResponse& operator=(ApiGraspOverrideResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApiGraspOverrideResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApiGraspOverrideResponse* internal_default_instance() {
    return reinterpret_cast<const ApiGraspOverrideResponse*>(
               &_ApiGraspOverrideResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ApiGraspOverrideResponse& a, ApiGraspOverrideResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ApiGraspOverrideResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApiGraspOverrideResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApiGraspOverrideResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApiGraspOverrideResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApiGraspOverrideResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApiGraspOverrideResponse& from) {
    ApiGraspOverrideResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApiGraspOverrideResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ApiGraspOverrideResponse";
  }
  protected:
  explicit ApiGraspOverrideResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ApiGraspOverrideResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmanipulation_5fapi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// WalkToObjectRayInWorld

// .bosdyn.api.Vec3 ray_start_rt_frame = 1;
inline bool WalkToObjectRayInWorld::_internal_has_ray_start_rt_frame() const {
  return this != internal_default_instance() && _impl_.ray_start_rt_frame_ != nullptr;
}
inline bool WalkToObjectRayInWorld::has_ray_start_rt_frame() const {
  return _internal_has_ray_start_rt_frame();
}
inline const ::bosdyn::api::Vec3& WalkToObjectRayInWorld::_internal_ray_start_rt_frame() const {
  const ::bosdyn::api::Vec3* p = _impl_.ray_start_rt_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& WalkToObjectRayInWorld::ray_start_rt_frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WalkToObjectRayInWorld.ray_start_rt_frame)
  return _internal_ray_start_rt_frame();
}
inline void WalkToObjectRayInWorld::unsafe_arena_set_allocated_ray_start_rt_frame(
    ::bosdyn::api::Vec3* ray_start_rt_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ray_start_rt_frame_);
  }
  _impl_.ray_start_rt_frame_ = ray_start_rt_frame;
  if (ray_start_rt_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.WalkToObjectRayInWorld.ray_start_rt_frame)
}
inline ::bosdyn::api::Vec3* WalkToObjectRayInWorld::release_ray_start_rt_frame() {
  
  ::bosdyn::api::Vec3* temp = _impl_.ray_start_rt_frame_;
  _impl_.ray_start_rt_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* WalkToObjectRayInWorld::unsafe_arena_release_ray_start_rt_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WalkToObjectRayInWorld.ray_start_rt_frame)
  
  ::bosdyn::api::Vec3* temp = _impl_.ray_start_rt_frame_;
  _impl_.ray_start_rt_frame_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* WalkToObjectRayInWorld::_internal_mutable_ray_start_rt_frame() {
  
  if (_impl_.ray_start_rt_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.ray_start_rt_frame_ = p;
  }
  return _impl_.ray_start_rt_frame_;
}
inline ::bosdyn::api::Vec3* WalkToObjectRayInWorld::mutable_ray_start_rt_frame() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_ray_start_rt_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WalkToObjectRayInWorld.ray_start_rt_frame)
  return _msg;
}
inline void WalkToObjectRayInWorld::set_allocated_ray_start_rt_frame(::bosdyn::api::Vec3* ray_start_rt_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ray_start_rt_frame_);
  }
  if (ray_start_rt_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ray_start_rt_frame));
    if (message_arena != submessage_arena) {
      ray_start_rt_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ray_start_rt_frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ray_start_rt_frame_ = ray_start_rt_frame;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WalkToObjectRayInWorld.ray_start_rt_frame)
}

// .bosdyn.api.Vec3 ray_end_rt_frame = 2;
inline bool WalkToObjectRayInWorld::_internal_has_ray_end_rt_frame() const {
  return this != internal_default_instance() && _impl_.ray_end_rt_frame_ != nullptr;
}
inline bool WalkToObjectRayInWorld::has_ray_end_rt_frame() const {
  return _internal_has_ray_end_rt_frame();
}
inline const ::bosdyn::api::Vec3& WalkToObjectRayInWorld::_internal_ray_end_rt_frame() const {
  const ::bosdyn::api::Vec3* p = _impl_.ray_end_rt_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& WalkToObjectRayInWorld::ray_end_rt_frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WalkToObjectRayInWorld.ray_end_rt_frame)
  return _internal_ray_end_rt_frame();
}
inline void WalkToObjectRayInWorld::unsafe_arena_set_allocated_ray_end_rt_frame(
    ::bosdyn::api::Vec3* ray_end_rt_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ray_end_rt_frame_);
  }
  _impl_.ray_end_rt_frame_ = ray_end_rt_frame;
  if (ray_end_rt_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.WalkToObjectRayInWorld.ray_end_rt_frame)
}
inline ::bosdyn::api::Vec3* WalkToObjectRayInWorld::release_ray_end_rt_frame() {
  
  ::bosdyn::api::Vec3* temp = _impl_.ray_end_rt_frame_;
  _impl_.ray_end_rt_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* WalkToObjectRayInWorld::unsafe_arena_release_ray_end_rt_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WalkToObjectRayInWorld.ray_end_rt_frame)
  
  ::bosdyn::api::Vec3* temp = _impl_.ray_end_rt_frame_;
  _impl_.ray_end_rt_frame_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* WalkToObjectRayInWorld::_internal_mutable_ray_end_rt_frame() {
  
  if (_impl_.ray_end_rt_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.ray_end_rt_frame_ = p;
  }
  return _impl_.ray_end_rt_frame_;
}
inline ::bosdyn::api::Vec3* WalkToObjectRayInWorld::mutable_ray_end_rt_frame() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_ray_end_rt_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WalkToObjectRayInWorld.ray_end_rt_frame)
  return _msg;
}
inline void WalkToObjectRayInWorld::set_allocated_ray_end_rt_frame(::bosdyn::api::Vec3* ray_end_rt_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ray_end_rt_frame_);
  }
  if (ray_end_rt_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ray_end_rt_frame));
    if (message_arena != submessage_arena) {
      ray_end_rt_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ray_end_rt_frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ray_end_rt_frame_ = ray_end_rt_frame;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WalkToObjectRayInWorld.ray_end_rt_frame)
}

// string frame_name = 3;
inline void WalkToObjectRayInWorld::clear_frame_name() {
  _impl_.frame_name_.ClearToEmpty();
}
inline const std::string& WalkToObjectRayInWorld::frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WalkToObjectRayInWorld.frame_name)
  return _internal_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WalkToObjectRayInWorld::set_frame_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.WalkToObjectRayInWorld.frame_name)
}
inline std::string* WalkToObjectRayInWorld::mutable_frame_name() {
  std::string* _s = _internal_mutable_frame_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WalkToObjectRayInWorld.frame_name)
  return _s;
}
inline const std::string& WalkToObjectRayInWorld::_internal_frame_name() const {
  return _impl_.frame_name_.Get();
}
inline void WalkToObjectRayInWorld::_internal_set_frame_name(const std::string& value) {
  
  _impl_.frame_name_.Set(value, GetArenaForAllocation());
}
inline std::string* WalkToObjectRayInWorld::_internal_mutable_frame_name() {
  
  return _impl_.frame_name_.Mutable(GetArenaForAllocation());
}
inline std::string* WalkToObjectRayInWorld::release_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WalkToObjectRayInWorld.frame_name)
  return _impl_.frame_name_.Release();
}
inline void WalkToObjectRayInWorld::set_allocated_frame_name(std::string* frame_name) {
  if (frame_name != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_.SetAllocated(frame_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_.IsDefault()) {
    _impl_.frame_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WalkToObjectRayInWorld.frame_name)
}

// .google.protobuf.FloatValue offset_distance = 4;
inline bool WalkToObjectRayInWorld::_internal_has_offset_distance() const {
  return this != internal_default_instance() && _impl_.offset_distance_ != nullptr;
}
inline bool WalkToObjectRayInWorld::has_offset_distance() const {
  return _internal_has_offset_distance();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& WalkToObjectRayInWorld::_internal_offset_distance() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.offset_distance_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& WalkToObjectRayInWorld::offset_distance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WalkToObjectRayInWorld.offset_distance)
  return _internal_offset_distance();
}
inline void WalkToObjectRayInWorld::unsafe_arena_set_allocated_offset_distance(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* offset_distance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.offset_distance_);
  }
  _impl_.offset_distance_ = offset_distance;
  if (offset_distance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.WalkToObjectRayInWorld.offset_distance)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* WalkToObjectRayInWorld::release_offset_distance() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.offset_distance_;
  _impl_.offset_distance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* WalkToObjectRayInWorld::unsafe_arena_release_offset_distance() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WalkToObjectRayInWorld.offset_distance)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.offset_distance_;
  _impl_.offset_distance_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* WalkToObjectRayInWorld::_internal_mutable_offset_distance() {
  
  if (_impl_.offset_distance_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.offset_distance_ = p;
  }
  return _impl_.offset_distance_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* WalkToObjectRayInWorld::mutable_offset_distance() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_offset_distance();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WalkToObjectRayInWorld.offset_distance)
  return _msg;
}
inline void WalkToObjectRayInWorld::set_allocated_offset_distance(::PROTOBUF_NAMESPACE_ID::FloatValue* offset_distance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.offset_distance_);
  }
  if (offset_distance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(offset_distance));
    if (message_arena != submessage_arena) {
      offset_distance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offset_distance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.offset_distance_ = offset_distance;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WalkToObjectRayInWorld.offset_distance)
}

// -------------------------------------------------------------------

// WalkToObjectInImage

// .bosdyn.api.Vec2 pixel_xy = 1;
inline bool WalkToObjectInImage::_internal_has_pixel_xy() const {
  return this != internal_default_instance() && _impl_.pixel_xy_ != nullptr;
}
inline bool WalkToObjectInImage::has_pixel_xy() const {
  return _internal_has_pixel_xy();
}
inline const ::bosdyn::api::Vec2& WalkToObjectInImage::_internal_pixel_xy() const {
  const ::bosdyn::api::Vec2* p = _impl_.pixel_xy_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec2&>(
      ::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& WalkToObjectInImage::pixel_xy() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WalkToObjectInImage.pixel_xy)
  return _internal_pixel_xy();
}
inline void WalkToObjectInImage::unsafe_arena_set_allocated_pixel_xy(
    ::bosdyn::api::Vec2* pixel_xy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pixel_xy_);
  }
  _impl_.pixel_xy_ = pixel_xy;
  if (pixel_xy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.WalkToObjectInImage.pixel_xy)
}
inline ::bosdyn::api::Vec2* WalkToObjectInImage::release_pixel_xy() {
  
  ::bosdyn::api::Vec2* temp = _impl_.pixel_xy_;
  _impl_.pixel_xy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec2* WalkToObjectInImage::unsafe_arena_release_pixel_xy() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WalkToObjectInImage.pixel_xy)
  
  ::bosdyn::api::Vec2* temp = _impl_.pixel_xy_;
  _impl_.pixel_xy_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* WalkToObjectInImage::_internal_mutable_pixel_xy() {
  
  if (_impl_.pixel_xy_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArenaForAllocation());
    _impl_.pixel_xy_ = p;
  }
  return _impl_.pixel_xy_;
}
inline ::bosdyn::api::Vec2* WalkToObjectInImage::mutable_pixel_xy() {
  ::bosdyn::api::Vec2* _msg = _internal_mutable_pixel_xy();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WalkToObjectInImage.pixel_xy)
  return _msg;
}
inline void WalkToObjectInImage::set_allocated_pixel_xy(::bosdyn::api::Vec2* pixel_xy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pixel_xy_);
  }
  if (pixel_xy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pixel_xy));
    if (message_arena != submessage_arena) {
      pixel_xy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pixel_xy, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pixel_xy_ = pixel_xy;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WalkToObjectInImage.pixel_xy)
}

// .bosdyn.api.FrameTreeSnapshot transforms_snapshot_for_camera = 2;
inline bool WalkToObjectInImage::_internal_has_transforms_snapshot_for_camera() const {
  return this != internal_default_instance() && _impl_.transforms_snapshot_for_camera_ != nullptr;
}
inline bool WalkToObjectInImage::has_transforms_snapshot_for_camera() const {
  return _internal_has_transforms_snapshot_for_camera();
}
inline const ::bosdyn::api::FrameTreeSnapshot& WalkToObjectInImage::_internal_transforms_snapshot_for_camera() const {
  const ::bosdyn::api::FrameTreeSnapshot* p = _impl_.transforms_snapshot_for_camera_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::FrameTreeSnapshot&>(
      ::bosdyn::api::_FrameTreeSnapshot_default_instance_);
}
inline const ::bosdyn::api::FrameTreeSnapshot& WalkToObjectInImage::transforms_snapshot_for_camera() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WalkToObjectInImage.transforms_snapshot_for_camera)
  return _internal_transforms_snapshot_for_camera();
}
inline void WalkToObjectInImage::unsafe_arena_set_allocated_transforms_snapshot_for_camera(
    ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_for_camera) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transforms_snapshot_for_camera_);
  }
  _impl_.transforms_snapshot_for_camera_ = transforms_snapshot_for_camera;
  if (transforms_snapshot_for_camera) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.WalkToObjectInImage.transforms_snapshot_for_camera)
}
inline ::bosdyn::api::FrameTreeSnapshot* WalkToObjectInImage::release_transforms_snapshot_for_camera() {
  
  ::bosdyn::api::FrameTreeSnapshot* temp = _impl_.transforms_snapshot_for_camera_;
  _impl_.transforms_snapshot_for_camera_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::FrameTreeSnapshot* WalkToObjectInImage::unsafe_arena_release_transforms_snapshot_for_camera() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WalkToObjectInImage.transforms_snapshot_for_camera)
  
  ::bosdyn::api::FrameTreeSnapshot* temp = _impl_.transforms_snapshot_for_camera_;
  _impl_.transforms_snapshot_for_camera_ = nullptr;
  return temp;
}
inline ::bosdyn::api::FrameTreeSnapshot* WalkToObjectInImage::_internal_mutable_transforms_snapshot_for_camera() {
  
  if (_impl_.transforms_snapshot_for_camera_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::FrameTreeSnapshot>(GetArenaForAllocation());
    _impl_.transforms_snapshot_for_camera_ = p;
  }
  return _impl_.transforms_snapshot_for_camera_;
}
inline ::bosdyn::api::FrameTreeSnapshot* WalkToObjectInImage::mutable_transforms_snapshot_for_camera() {
  ::bosdyn::api::FrameTreeSnapshot* _msg = _internal_mutable_transforms_snapshot_for_camera();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WalkToObjectInImage.transforms_snapshot_for_camera)
  return _msg;
}
inline void WalkToObjectInImage::set_allocated_transforms_snapshot_for_camera(::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_for_camera) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transforms_snapshot_for_camera_);
  }
  if (transforms_snapshot_for_camera) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transforms_snapshot_for_camera));
    if (message_arena != submessage_arena) {
      transforms_snapshot_for_camera = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transforms_snapshot_for_camera, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transforms_snapshot_for_camera_ = transforms_snapshot_for_camera;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WalkToObjectInImage.transforms_snapshot_for_camera)
}

// string frame_name_image_sensor = 3;
inline void WalkToObjectInImage::clear_frame_name_image_sensor() {
  _impl_.frame_name_image_sensor_.ClearToEmpty();
}
inline const std::string& WalkToObjectInImage::frame_name_image_sensor() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WalkToObjectInImage.frame_name_image_sensor)
  return _internal_frame_name_image_sensor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WalkToObjectInImage::set_frame_name_image_sensor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_image_sensor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.WalkToObjectInImage.frame_name_image_sensor)
}
inline std::string* WalkToObjectInImage::mutable_frame_name_image_sensor() {
  std::string* _s = _internal_mutable_frame_name_image_sensor();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WalkToObjectInImage.frame_name_image_sensor)
  return _s;
}
inline const std::string& WalkToObjectInImage::_internal_frame_name_image_sensor() const {
  return _impl_.frame_name_image_sensor_.Get();
}
inline void WalkToObjectInImage::_internal_set_frame_name_image_sensor(const std::string& value) {
  
  _impl_.frame_name_image_sensor_.Set(value, GetArenaForAllocation());
}
inline std::string* WalkToObjectInImage::_internal_mutable_frame_name_image_sensor() {
  
  return _impl_.frame_name_image_sensor_.Mutable(GetArenaForAllocation());
}
inline std::string* WalkToObjectInImage::release_frame_name_image_sensor() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WalkToObjectInImage.frame_name_image_sensor)
  return _impl_.frame_name_image_sensor_.Release();
}
inline void WalkToObjectInImage::set_allocated_frame_name_image_sensor(std::string* frame_name_image_sensor) {
  if (frame_name_image_sensor != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_image_sensor_.SetAllocated(frame_name_image_sensor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_image_sensor_.IsDefault()) {
    _impl_.frame_name_image_sensor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WalkToObjectInImage.frame_name_image_sensor)
}

// .bosdyn.api.ImageSource.PinholeModel camera_model = 4;
inline bool WalkToObjectInImage::_internal_has_camera_model() const {
  return this != internal_default_instance() && _impl_.camera_model_ != nullptr;
}
inline bool WalkToObjectInImage::has_camera_model() const {
  return _internal_has_camera_model();
}
inline const ::bosdyn::api::ImageSource_PinholeModel& WalkToObjectInImage::_internal_camera_model() const {
  const ::bosdyn::api::ImageSource_PinholeModel* p = _impl_.camera_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ImageSource_PinholeModel&>(
      ::bosdyn::api::_ImageSource_PinholeModel_default_instance_);
}
inline const ::bosdyn::api::ImageSource_PinholeModel& WalkToObjectInImage::camera_model() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WalkToObjectInImage.camera_model)
  return _internal_camera_model();
}
inline void WalkToObjectInImage::unsafe_arena_set_allocated_camera_model(
    ::bosdyn::api::ImageSource_PinholeModel* camera_model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_model_);
  }
  _impl_.camera_model_ = camera_model;
  if (camera_model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.WalkToObjectInImage.camera_model)
}
inline ::bosdyn::api::ImageSource_PinholeModel* WalkToObjectInImage::release_camera_model() {
  
  ::bosdyn::api::ImageSource_PinholeModel* temp = _impl_.camera_model_;
  _impl_.camera_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ImageSource_PinholeModel* WalkToObjectInImage::unsafe_arena_release_camera_model() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WalkToObjectInImage.camera_model)
  
  ::bosdyn::api::ImageSource_PinholeModel* temp = _impl_.camera_model_;
  _impl_.camera_model_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ImageSource_PinholeModel* WalkToObjectInImage::_internal_mutable_camera_model() {
  
  if (_impl_.camera_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ImageSource_PinholeModel>(GetArenaForAllocation());
    _impl_.camera_model_ = p;
  }
  return _impl_.camera_model_;
}
inline ::bosdyn::api::ImageSource_PinholeModel* WalkToObjectInImage::mutable_camera_model() {
  ::bosdyn::api::ImageSource_PinholeModel* _msg = _internal_mutable_camera_model();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WalkToObjectInImage.camera_model)
  return _msg;
}
inline void WalkToObjectInImage::set_allocated_camera_model(::bosdyn::api::ImageSource_PinholeModel* camera_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_model_);
  }
  if (camera_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_model));
    if (message_arena != submessage_arena) {
      camera_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_model, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_model_ = camera_model;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WalkToObjectInImage.camera_model)
}

// .google.protobuf.FloatValue offset_distance = 5;
inline bool WalkToObjectInImage::_internal_has_offset_distance() const {
  return this != internal_default_instance() && _impl_.offset_distance_ != nullptr;
}
inline bool WalkToObjectInImage::has_offset_distance() const {
  return _internal_has_offset_distance();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& WalkToObjectInImage::_internal_offset_distance() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.offset_distance_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& WalkToObjectInImage::offset_distance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WalkToObjectInImage.offset_distance)
  return _internal_offset_distance();
}
inline void WalkToObjectInImage::unsafe_arena_set_allocated_offset_distance(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* offset_distance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.offset_distance_);
  }
  _impl_.offset_distance_ = offset_distance;
  if (offset_distance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.WalkToObjectInImage.offset_distance)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* WalkToObjectInImage::release_offset_distance() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.offset_distance_;
  _impl_.offset_distance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* WalkToObjectInImage::unsafe_arena_release_offset_distance() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WalkToObjectInImage.offset_distance)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.offset_distance_;
  _impl_.offset_distance_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* WalkToObjectInImage::_internal_mutable_offset_distance() {
  
  if (_impl_.offset_distance_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.offset_distance_ = p;
  }
  return _impl_.offset_distance_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* WalkToObjectInImage::mutable_offset_distance() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_offset_distance();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WalkToObjectInImage.offset_distance)
  return _msg;
}
inline void WalkToObjectInImage::set_allocated_offset_distance(::PROTOBUF_NAMESPACE_ID::FloatValue* offset_distance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.offset_distance_);
  }
  if (offset_distance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(offset_distance));
    if (message_arena != submessage_arena) {
      offset_distance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offset_distance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.offset_distance_ = offset_distance;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WalkToObjectInImage.offset_distance)
}

// -------------------------------------------------------------------

// PickObjectRayInWorld

// .bosdyn.api.Vec3 ray_start_rt_frame = 1;
inline bool PickObjectRayInWorld::_internal_has_ray_start_rt_frame() const {
  return this != internal_default_instance() && _impl_.ray_start_rt_frame_ != nullptr;
}
inline bool PickObjectRayInWorld::has_ray_start_rt_frame() const {
  return _internal_has_ray_start_rt_frame();
}
inline const ::bosdyn::api::Vec3& PickObjectRayInWorld::_internal_ray_start_rt_frame() const {
  const ::bosdyn::api::Vec3* p = _impl_.ray_start_rt_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& PickObjectRayInWorld::ray_start_rt_frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PickObjectRayInWorld.ray_start_rt_frame)
  return _internal_ray_start_rt_frame();
}
inline void PickObjectRayInWorld::unsafe_arena_set_allocated_ray_start_rt_frame(
    ::bosdyn::api::Vec3* ray_start_rt_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ray_start_rt_frame_);
  }
  _impl_.ray_start_rt_frame_ = ray_start_rt_frame;
  if (ray_start_rt_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PickObjectRayInWorld.ray_start_rt_frame)
}
inline ::bosdyn::api::Vec3* PickObjectRayInWorld::release_ray_start_rt_frame() {
  
  ::bosdyn::api::Vec3* temp = _impl_.ray_start_rt_frame_;
  _impl_.ray_start_rt_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* PickObjectRayInWorld::unsafe_arena_release_ray_start_rt_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PickObjectRayInWorld.ray_start_rt_frame)
  
  ::bosdyn::api::Vec3* temp = _impl_.ray_start_rt_frame_;
  _impl_.ray_start_rt_frame_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* PickObjectRayInWorld::_internal_mutable_ray_start_rt_frame() {
  
  if (_impl_.ray_start_rt_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.ray_start_rt_frame_ = p;
  }
  return _impl_.ray_start_rt_frame_;
}
inline ::bosdyn::api::Vec3* PickObjectRayInWorld::mutable_ray_start_rt_frame() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_ray_start_rt_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PickObjectRayInWorld.ray_start_rt_frame)
  return _msg;
}
inline void PickObjectRayInWorld::set_allocated_ray_start_rt_frame(::bosdyn::api::Vec3* ray_start_rt_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ray_start_rt_frame_);
  }
  if (ray_start_rt_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ray_start_rt_frame));
    if (message_arena != submessage_arena) {
      ray_start_rt_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ray_start_rt_frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ray_start_rt_frame_ = ray_start_rt_frame;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PickObjectRayInWorld.ray_start_rt_frame)
}

// .bosdyn.api.Vec3 ray_end_rt_frame = 2;
inline bool PickObjectRayInWorld::_internal_has_ray_end_rt_frame() const {
  return this != internal_default_instance() && _impl_.ray_end_rt_frame_ != nullptr;
}
inline bool PickObjectRayInWorld::has_ray_end_rt_frame() const {
  return _internal_has_ray_end_rt_frame();
}
inline const ::bosdyn::api::Vec3& PickObjectRayInWorld::_internal_ray_end_rt_frame() const {
  const ::bosdyn::api::Vec3* p = _impl_.ray_end_rt_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& PickObjectRayInWorld::ray_end_rt_frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PickObjectRayInWorld.ray_end_rt_frame)
  return _internal_ray_end_rt_frame();
}
inline void PickObjectRayInWorld::unsafe_arena_set_allocated_ray_end_rt_frame(
    ::bosdyn::api::Vec3* ray_end_rt_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ray_end_rt_frame_);
  }
  _impl_.ray_end_rt_frame_ = ray_end_rt_frame;
  if (ray_end_rt_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PickObjectRayInWorld.ray_end_rt_frame)
}
inline ::bosdyn::api::Vec3* PickObjectRayInWorld::release_ray_end_rt_frame() {
  
  ::bosdyn::api::Vec3* temp = _impl_.ray_end_rt_frame_;
  _impl_.ray_end_rt_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* PickObjectRayInWorld::unsafe_arena_release_ray_end_rt_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PickObjectRayInWorld.ray_end_rt_frame)
  
  ::bosdyn::api::Vec3* temp = _impl_.ray_end_rt_frame_;
  _impl_.ray_end_rt_frame_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* PickObjectRayInWorld::_internal_mutable_ray_end_rt_frame() {
  
  if (_impl_.ray_end_rt_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.ray_end_rt_frame_ = p;
  }
  return _impl_.ray_end_rt_frame_;
}
inline ::bosdyn::api::Vec3* PickObjectRayInWorld::mutable_ray_end_rt_frame() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_ray_end_rt_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PickObjectRayInWorld.ray_end_rt_frame)
  return _msg;
}
inline void PickObjectRayInWorld::set_allocated_ray_end_rt_frame(::bosdyn::api::Vec3* ray_end_rt_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ray_end_rt_frame_);
  }
  if (ray_end_rt_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ray_end_rt_frame));
    if (message_arena != submessage_arena) {
      ray_end_rt_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ray_end_rt_frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ray_end_rt_frame_ = ray_end_rt_frame;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PickObjectRayInWorld.ray_end_rt_frame)
}

// string frame_name = 6;
inline void PickObjectRayInWorld::clear_frame_name() {
  _impl_.frame_name_.ClearToEmpty();
}
inline const std::string& PickObjectRayInWorld::frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PickObjectRayInWorld.frame_name)
  return _internal_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PickObjectRayInWorld::set_frame_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.PickObjectRayInWorld.frame_name)
}
inline std::string* PickObjectRayInWorld::mutable_frame_name() {
  std::string* _s = _internal_mutable_frame_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PickObjectRayInWorld.frame_name)
  return _s;
}
inline const std::string& PickObjectRayInWorld::_internal_frame_name() const {
  return _impl_.frame_name_.Get();
}
inline void PickObjectRayInWorld::_internal_set_frame_name(const std::string& value) {
  
  _impl_.frame_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PickObjectRayInWorld::_internal_mutable_frame_name() {
  
  return _impl_.frame_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PickObjectRayInWorld::release_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PickObjectRayInWorld.frame_name)
  return _impl_.frame_name_.Release();
}
inline void PickObjectRayInWorld::set_allocated_frame_name(std::string* frame_name) {
  if (frame_name != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_.SetAllocated(frame_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_.IsDefault()) {
    _impl_.frame_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PickObjectRayInWorld.frame_name)
}

// .bosdyn.api.GraspParams grasp_params = 10;
inline bool PickObjectRayInWorld::_internal_has_grasp_params() const {
  return this != internal_default_instance() && _impl_.grasp_params_ != nullptr;
}
inline bool PickObjectRayInWorld::has_grasp_params() const {
  return _internal_has_grasp_params();
}
inline void PickObjectRayInWorld::clear_grasp_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.grasp_params_ != nullptr) {
    delete _impl_.grasp_params_;
  }
  _impl_.grasp_params_ = nullptr;
}
inline const ::bosdyn::api::GraspParams& PickObjectRayInWorld::_internal_grasp_params() const {
  const ::bosdyn::api::GraspParams* p = _impl_.grasp_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::GraspParams&>(
      ::bosdyn::api::_GraspParams_default_instance_);
}
inline const ::bosdyn::api::GraspParams& PickObjectRayInWorld::grasp_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PickObjectRayInWorld.grasp_params)
  return _internal_grasp_params();
}
inline void PickObjectRayInWorld::unsafe_arena_set_allocated_grasp_params(
    ::bosdyn::api::GraspParams* grasp_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grasp_params_);
  }
  _impl_.grasp_params_ = grasp_params;
  if (grasp_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PickObjectRayInWorld.grasp_params)
}
inline ::bosdyn::api::GraspParams* PickObjectRayInWorld::release_grasp_params() {
  
  ::bosdyn::api::GraspParams* temp = _impl_.grasp_params_;
  _impl_.grasp_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::GraspParams* PickObjectRayInWorld::unsafe_arena_release_grasp_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PickObjectRayInWorld.grasp_params)
  
  ::bosdyn::api::GraspParams* temp = _impl_.grasp_params_;
  _impl_.grasp_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::GraspParams* PickObjectRayInWorld::_internal_mutable_grasp_params() {
  
  if (_impl_.grasp_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::GraspParams>(GetArenaForAllocation());
    _impl_.grasp_params_ = p;
  }
  return _impl_.grasp_params_;
}
inline ::bosdyn::api::GraspParams* PickObjectRayInWorld::mutable_grasp_params() {
  ::bosdyn::api::GraspParams* _msg = _internal_mutable_grasp_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PickObjectRayInWorld.grasp_params)
  return _msg;
}
inline void PickObjectRayInWorld::set_allocated_grasp_params(::bosdyn::api::GraspParams* grasp_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.grasp_params_;
  }
  if (grasp_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(grasp_params);
    if (message_arena != submessage_arena) {
      grasp_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grasp_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.grasp_params_ = grasp_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PickObjectRayInWorld.grasp_params)
}

// .bosdyn.api.WalkGazeMode walk_gaze_mode = 4;
inline void PickObjectRayInWorld::clear_walk_gaze_mode() {
  _impl_.walk_gaze_mode_ = 0;
}
inline ::bosdyn::api::WalkGazeMode PickObjectRayInWorld::_internal_walk_gaze_mode() const {
  return static_cast< ::bosdyn::api::WalkGazeMode >(_impl_.walk_gaze_mode_);
}
inline ::bosdyn::api::WalkGazeMode PickObjectRayInWorld::walk_gaze_mode() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PickObjectRayInWorld.walk_gaze_mode)
  return _internal_walk_gaze_mode();
}
inline void PickObjectRayInWorld::_internal_set_walk_gaze_mode(::bosdyn::api::WalkGazeMode value) {
  
  _impl_.walk_gaze_mode_ = value;
}
inline void PickObjectRayInWorld::set_walk_gaze_mode(::bosdyn::api::WalkGazeMode value) {
  _internal_set_walk_gaze_mode(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PickObjectRayInWorld.walk_gaze_mode)
}

// -------------------------------------------------------------------

// PickObjectExecutePlan

// -------------------------------------------------------------------

// PickObject

// string frame_name = 1;
inline void PickObject::clear_frame_name() {
  _impl_.frame_name_.ClearToEmpty();
}
inline const std::string& PickObject::frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PickObject.frame_name)
  return _internal_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PickObject::set_frame_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.PickObject.frame_name)
}
inline std::string* PickObject::mutable_frame_name() {
  std::string* _s = _internal_mutable_frame_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PickObject.frame_name)
  return _s;
}
inline const std::string& PickObject::_internal_frame_name() const {
  return _impl_.frame_name_.Get();
}
inline void PickObject::_internal_set_frame_name(const std::string& value) {
  
  _impl_.frame_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PickObject::_internal_mutable_frame_name() {
  
  return _impl_.frame_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PickObject::release_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PickObject.frame_name)
  return _impl_.frame_name_.Release();
}
inline void PickObject::set_allocated_frame_name(std::string* frame_name) {
  if (frame_name != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_.SetAllocated(frame_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_.IsDefault()) {
    _impl_.frame_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PickObject.frame_name)
}

// .bosdyn.api.Vec3 object_rt_frame = 2;
inline bool PickObject::_internal_has_object_rt_frame() const {
  return this != internal_default_instance() && _impl_.object_rt_frame_ != nullptr;
}
inline bool PickObject::has_object_rt_frame() const {
  return _internal_has_object_rt_frame();
}
inline const ::bosdyn::api::Vec3& PickObject::_internal_object_rt_frame() const {
  const ::bosdyn::api::Vec3* p = _impl_.object_rt_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& PickObject::object_rt_frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PickObject.object_rt_frame)
  return _internal_object_rt_frame();
}
inline void PickObject::unsafe_arena_set_allocated_object_rt_frame(
    ::bosdyn::api::Vec3* object_rt_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.object_rt_frame_);
  }
  _impl_.object_rt_frame_ = object_rt_frame;
  if (object_rt_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PickObject.object_rt_frame)
}
inline ::bosdyn::api::Vec3* PickObject::release_object_rt_frame() {
  
  ::bosdyn::api::Vec3* temp = _impl_.object_rt_frame_;
  _impl_.object_rt_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* PickObject::unsafe_arena_release_object_rt_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PickObject.object_rt_frame)
  
  ::bosdyn::api::Vec3* temp = _impl_.object_rt_frame_;
  _impl_.object_rt_frame_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* PickObject::_internal_mutable_object_rt_frame() {
  
  if (_impl_.object_rt_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.object_rt_frame_ = p;
  }
  return _impl_.object_rt_frame_;
}
inline ::bosdyn::api::Vec3* PickObject::mutable_object_rt_frame() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_object_rt_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PickObject.object_rt_frame)
  return _msg;
}
inline void PickObject::set_allocated_object_rt_frame(::bosdyn::api::Vec3* object_rt_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.object_rt_frame_);
  }
  if (object_rt_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_rt_frame));
    if (message_arena != submessage_arena) {
      object_rt_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object_rt_frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.object_rt_frame_ = object_rt_frame;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PickObject.object_rt_frame)
}

// .bosdyn.api.GraspParams grasp_params = 3;
inline bool PickObject::_internal_has_grasp_params() const {
  return this != internal_default_instance() && _impl_.grasp_params_ != nullptr;
}
inline bool PickObject::has_grasp_params() const {
  return _internal_has_grasp_params();
}
inline void PickObject::clear_grasp_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.grasp_params_ != nullptr) {
    delete _impl_.grasp_params_;
  }
  _impl_.grasp_params_ = nullptr;
}
inline const ::bosdyn::api::GraspParams& PickObject::_internal_grasp_params() const {
  const ::bosdyn::api::GraspParams* p = _impl_.grasp_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::GraspParams&>(
      ::bosdyn::api::_GraspParams_default_instance_);
}
inline const ::bosdyn::api::GraspParams& PickObject::grasp_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PickObject.grasp_params)
  return _internal_grasp_params();
}
inline void PickObject::unsafe_arena_set_allocated_grasp_params(
    ::bosdyn::api::GraspParams* grasp_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grasp_params_);
  }
  _impl_.grasp_params_ = grasp_params;
  if (grasp_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PickObject.grasp_params)
}
inline ::bosdyn::api::GraspParams* PickObject::release_grasp_params() {
  
  ::bosdyn::api::GraspParams* temp = _impl_.grasp_params_;
  _impl_.grasp_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::GraspParams* PickObject::unsafe_arena_release_grasp_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PickObject.grasp_params)
  
  ::bosdyn::api::GraspParams* temp = _impl_.grasp_params_;
  _impl_.grasp_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::GraspParams* PickObject::_internal_mutable_grasp_params() {
  
  if (_impl_.grasp_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::GraspParams>(GetArenaForAllocation());
    _impl_.grasp_params_ = p;
  }
  return _impl_.grasp_params_;
}
inline ::bosdyn::api::GraspParams* PickObject::mutable_grasp_params() {
  ::bosdyn::api::GraspParams* _msg = _internal_mutable_grasp_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PickObject.grasp_params)
  return _msg;
}
inline void PickObject::set_allocated_grasp_params(::bosdyn::api::GraspParams* grasp_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.grasp_params_;
  }
  if (grasp_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(grasp_params);
    if (message_arena != submessage_arena) {
      grasp_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grasp_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.grasp_params_ = grasp_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PickObject.grasp_params)
}

// -------------------------------------------------------------------

// PickObjectInImage

// .bosdyn.api.Vec2 pixel_xy = 1;
inline bool PickObjectInImage::_internal_has_pixel_xy() const {
  return this != internal_default_instance() && _impl_.pixel_xy_ != nullptr;
}
inline bool PickObjectInImage::has_pixel_xy() const {
  return _internal_has_pixel_xy();
}
inline const ::bosdyn::api::Vec2& PickObjectInImage::_internal_pixel_xy() const {
  const ::bosdyn::api::Vec2* p = _impl_.pixel_xy_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec2&>(
      ::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& PickObjectInImage::pixel_xy() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PickObjectInImage.pixel_xy)
  return _internal_pixel_xy();
}
inline void PickObjectInImage::unsafe_arena_set_allocated_pixel_xy(
    ::bosdyn::api::Vec2* pixel_xy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pixel_xy_);
  }
  _impl_.pixel_xy_ = pixel_xy;
  if (pixel_xy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PickObjectInImage.pixel_xy)
}
inline ::bosdyn::api::Vec2* PickObjectInImage::release_pixel_xy() {
  
  ::bosdyn::api::Vec2* temp = _impl_.pixel_xy_;
  _impl_.pixel_xy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec2* PickObjectInImage::unsafe_arena_release_pixel_xy() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PickObjectInImage.pixel_xy)
  
  ::bosdyn::api::Vec2* temp = _impl_.pixel_xy_;
  _impl_.pixel_xy_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* PickObjectInImage::_internal_mutable_pixel_xy() {
  
  if (_impl_.pixel_xy_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArenaForAllocation());
    _impl_.pixel_xy_ = p;
  }
  return _impl_.pixel_xy_;
}
inline ::bosdyn::api::Vec2* PickObjectInImage::mutable_pixel_xy() {
  ::bosdyn::api::Vec2* _msg = _internal_mutable_pixel_xy();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PickObjectInImage.pixel_xy)
  return _msg;
}
inline void PickObjectInImage::set_allocated_pixel_xy(::bosdyn::api::Vec2* pixel_xy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pixel_xy_);
  }
  if (pixel_xy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pixel_xy));
    if (message_arena != submessage_arena) {
      pixel_xy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pixel_xy, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pixel_xy_ = pixel_xy;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PickObjectInImage.pixel_xy)
}

// .bosdyn.api.FrameTreeSnapshot transforms_snapshot_for_camera = 2;
inline bool PickObjectInImage::_internal_has_transforms_snapshot_for_camera() const {
  return this != internal_default_instance() && _impl_.transforms_snapshot_for_camera_ != nullptr;
}
inline bool PickObjectInImage::has_transforms_snapshot_for_camera() const {
  return _internal_has_transforms_snapshot_for_camera();
}
inline const ::bosdyn::api::FrameTreeSnapshot& PickObjectInImage::_internal_transforms_snapshot_for_camera() const {
  const ::bosdyn::api::FrameTreeSnapshot* p = _impl_.transforms_snapshot_for_camera_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::FrameTreeSnapshot&>(
      ::bosdyn::api::_FrameTreeSnapshot_default_instance_);
}
inline const ::bosdyn::api::FrameTreeSnapshot& PickObjectInImage::transforms_snapshot_for_camera() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PickObjectInImage.transforms_snapshot_for_camera)
  return _internal_transforms_snapshot_for_camera();
}
inline void PickObjectInImage::unsafe_arena_set_allocated_transforms_snapshot_for_camera(
    ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_for_camera) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transforms_snapshot_for_camera_);
  }
  _impl_.transforms_snapshot_for_camera_ = transforms_snapshot_for_camera;
  if (transforms_snapshot_for_camera) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PickObjectInImage.transforms_snapshot_for_camera)
}
inline ::bosdyn::api::FrameTreeSnapshot* PickObjectInImage::release_transforms_snapshot_for_camera() {
  
  ::bosdyn::api::FrameTreeSnapshot* temp = _impl_.transforms_snapshot_for_camera_;
  _impl_.transforms_snapshot_for_camera_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::FrameTreeSnapshot* PickObjectInImage::unsafe_arena_release_transforms_snapshot_for_camera() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PickObjectInImage.transforms_snapshot_for_camera)
  
  ::bosdyn::api::FrameTreeSnapshot* temp = _impl_.transforms_snapshot_for_camera_;
  _impl_.transforms_snapshot_for_camera_ = nullptr;
  return temp;
}
inline ::bosdyn::api::FrameTreeSnapshot* PickObjectInImage::_internal_mutable_transforms_snapshot_for_camera() {
  
  if (_impl_.transforms_snapshot_for_camera_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::FrameTreeSnapshot>(GetArenaForAllocation());
    _impl_.transforms_snapshot_for_camera_ = p;
  }
  return _impl_.transforms_snapshot_for_camera_;
}
inline ::bosdyn::api::FrameTreeSnapshot* PickObjectInImage::mutable_transforms_snapshot_for_camera() {
  ::bosdyn::api::FrameTreeSnapshot* _msg = _internal_mutable_transforms_snapshot_for_camera();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PickObjectInImage.transforms_snapshot_for_camera)
  return _msg;
}
inline void PickObjectInImage::set_allocated_transforms_snapshot_for_camera(::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_for_camera) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transforms_snapshot_for_camera_);
  }
  if (transforms_snapshot_for_camera) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transforms_snapshot_for_camera));
    if (message_arena != submessage_arena) {
      transforms_snapshot_for_camera = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transforms_snapshot_for_camera, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transforms_snapshot_for_camera_ = transforms_snapshot_for_camera;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PickObjectInImage.transforms_snapshot_for_camera)
}

// string frame_name_image_sensor = 3;
inline void PickObjectInImage::clear_frame_name_image_sensor() {
  _impl_.frame_name_image_sensor_.ClearToEmpty();
}
inline const std::string& PickObjectInImage::frame_name_image_sensor() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PickObjectInImage.frame_name_image_sensor)
  return _internal_frame_name_image_sensor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PickObjectInImage::set_frame_name_image_sensor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_image_sensor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.PickObjectInImage.frame_name_image_sensor)
}
inline std::string* PickObjectInImage::mutable_frame_name_image_sensor() {
  std::string* _s = _internal_mutable_frame_name_image_sensor();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PickObjectInImage.frame_name_image_sensor)
  return _s;
}
inline const std::string& PickObjectInImage::_internal_frame_name_image_sensor() const {
  return _impl_.frame_name_image_sensor_.Get();
}
inline void PickObjectInImage::_internal_set_frame_name_image_sensor(const std::string& value) {
  
  _impl_.frame_name_image_sensor_.Set(value, GetArenaForAllocation());
}
inline std::string* PickObjectInImage::_internal_mutable_frame_name_image_sensor() {
  
  return _impl_.frame_name_image_sensor_.Mutable(GetArenaForAllocation());
}
inline std::string* PickObjectInImage::release_frame_name_image_sensor() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PickObjectInImage.frame_name_image_sensor)
  return _impl_.frame_name_image_sensor_.Release();
}
inline void PickObjectInImage::set_allocated_frame_name_image_sensor(std::string* frame_name_image_sensor) {
  if (frame_name_image_sensor != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_image_sensor_.SetAllocated(frame_name_image_sensor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_image_sensor_.IsDefault()) {
    _impl_.frame_name_image_sensor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PickObjectInImage.frame_name_image_sensor)
}

// .bosdyn.api.ImageSource.PinholeModel camera_model = 4;
inline bool PickObjectInImage::_internal_has_camera_model() const {
  return this != internal_default_instance() && _impl_.camera_model_ != nullptr;
}
inline bool PickObjectInImage::has_camera_model() const {
  return _internal_has_camera_model();
}
inline const ::bosdyn::api::ImageSource_PinholeModel& PickObjectInImage::_internal_camera_model() const {
  const ::bosdyn::api::ImageSource_PinholeModel* p = _impl_.camera_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ImageSource_PinholeModel&>(
      ::bosdyn::api::_ImageSource_PinholeModel_default_instance_);
}
inline const ::bosdyn::api::ImageSource_PinholeModel& PickObjectInImage::camera_model() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PickObjectInImage.camera_model)
  return _internal_camera_model();
}
inline void PickObjectInImage::unsafe_arena_set_allocated_camera_model(
    ::bosdyn::api::ImageSource_PinholeModel* camera_model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_model_);
  }
  _impl_.camera_model_ = camera_model;
  if (camera_model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PickObjectInImage.camera_model)
}
inline ::bosdyn::api::ImageSource_PinholeModel* PickObjectInImage::release_camera_model() {
  
  ::bosdyn::api::ImageSource_PinholeModel* temp = _impl_.camera_model_;
  _impl_.camera_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ImageSource_PinholeModel* PickObjectInImage::unsafe_arena_release_camera_model() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PickObjectInImage.camera_model)
  
  ::bosdyn::api::ImageSource_PinholeModel* temp = _impl_.camera_model_;
  _impl_.camera_model_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ImageSource_PinholeModel* PickObjectInImage::_internal_mutable_camera_model() {
  
  if (_impl_.camera_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ImageSource_PinholeModel>(GetArenaForAllocation());
    _impl_.camera_model_ = p;
  }
  return _impl_.camera_model_;
}
inline ::bosdyn::api::ImageSource_PinholeModel* PickObjectInImage::mutable_camera_model() {
  ::bosdyn::api::ImageSource_PinholeModel* _msg = _internal_mutable_camera_model();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PickObjectInImage.camera_model)
  return _msg;
}
inline void PickObjectInImage::set_allocated_camera_model(::bosdyn::api::ImageSource_PinholeModel* camera_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_model_);
  }
  if (camera_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_model));
    if (message_arena != submessage_arena) {
      camera_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_model, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_model_ = camera_model;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PickObjectInImage.camera_model)
}

// .bosdyn.api.GraspParams grasp_params = 10;
inline bool PickObjectInImage::_internal_has_grasp_params() const {
  return this != internal_default_instance() && _impl_.grasp_params_ != nullptr;
}
inline bool PickObjectInImage::has_grasp_params() const {
  return _internal_has_grasp_params();
}
inline void PickObjectInImage::clear_grasp_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.grasp_params_ != nullptr) {
    delete _impl_.grasp_params_;
  }
  _impl_.grasp_params_ = nullptr;
}
inline const ::bosdyn::api::GraspParams& PickObjectInImage::_internal_grasp_params() const {
  const ::bosdyn::api::GraspParams* p = _impl_.grasp_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::GraspParams&>(
      ::bosdyn::api::_GraspParams_default_instance_);
}
inline const ::bosdyn::api::GraspParams& PickObjectInImage::grasp_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PickObjectInImage.grasp_params)
  return _internal_grasp_params();
}
inline void PickObjectInImage::unsafe_arena_set_allocated_grasp_params(
    ::bosdyn::api::GraspParams* grasp_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grasp_params_);
  }
  _impl_.grasp_params_ = grasp_params;
  if (grasp_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PickObjectInImage.grasp_params)
}
inline ::bosdyn::api::GraspParams* PickObjectInImage::release_grasp_params() {
  
  ::bosdyn::api::GraspParams* temp = _impl_.grasp_params_;
  _impl_.grasp_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::GraspParams* PickObjectInImage::unsafe_arena_release_grasp_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PickObjectInImage.grasp_params)
  
  ::bosdyn::api::GraspParams* temp = _impl_.grasp_params_;
  _impl_.grasp_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::GraspParams* PickObjectInImage::_internal_mutable_grasp_params() {
  
  if (_impl_.grasp_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::GraspParams>(GetArenaForAllocation());
    _impl_.grasp_params_ = p;
  }
  return _impl_.grasp_params_;
}
inline ::bosdyn::api::GraspParams* PickObjectInImage::mutable_grasp_params() {
  ::bosdyn::api::GraspParams* _msg = _internal_mutable_grasp_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PickObjectInImage.grasp_params)
  return _msg;
}
inline void PickObjectInImage::set_allocated_grasp_params(::bosdyn::api::GraspParams* grasp_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.grasp_params_;
  }
  if (grasp_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(grasp_params);
    if (message_arena != submessage_arena) {
      grasp_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grasp_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.grasp_params_ = grasp_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PickObjectInImage.grasp_params)
}

// .bosdyn.api.WalkGazeMode walk_gaze_mode = 9;
inline void PickObjectInImage::clear_walk_gaze_mode() {
  _impl_.walk_gaze_mode_ = 0;
}
inline ::bosdyn::api::WalkGazeMode PickObjectInImage::_internal_walk_gaze_mode() const {
  return static_cast< ::bosdyn::api::WalkGazeMode >(_impl_.walk_gaze_mode_);
}
inline ::bosdyn::api::WalkGazeMode PickObjectInImage::walk_gaze_mode() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PickObjectInImage.walk_gaze_mode)
  return _internal_walk_gaze_mode();
}
inline void PickObjectInImage::_internal_set_walk_gaze_mode(::bosdyn::api::WalkGazeMode value) {
  
  _impl_.walk_gaze_mode_ = value;
}
inline void PickObjectInImage::set_walk_gaze_mode(::bosdyn::api::WalkGazeMode value) {
  _internal_set_walk_gaze_mode(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PickObjectInImage.walk_gaze_mode)
}

// -------------------------------------------------------------------

// GraspParams

// float grasp_palm_to_fingertip = 1;
inline void GraspParams::clear_grasp_palm_to_fingertip() {
  _impl_.grasp_palm_to_fingertip_ = 0;
}
inline float GraspParams::_internal_grasp_palm_to_fingertip() const {
  return _impl_.grasp_palm_to_fingertip_;
}
inline float GraspParams::grasp_palm_to_fingertip() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GraspParams.grasp_palm_to_fingertip)
  return _internal_grasp_palm_to_fingertip();
}
inline void GraspParams::_internal_set_grasp_palm_to_fingertip(float value) {
  
  _impl_.grasp_palm_to_fingertip_ = value;
}
inline void GraspParams::set_grasp_palm_to_fingertip(float value) {
  _internal_set_grasp_palm_to_fingertip(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.GraspParams.grasp_palm_to_fingertip)
}

// string grasp_params_frame_name = 2;
inline void GraspParams::clear_grasp_params_frame_name() {
  _impl_.grasp_params_frame_name_.ClearToEmpty();
}
inline const std::string& GraspParams::grasp_params_frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GraspParams.grasp_params_frame_name)
  return _internal_grasp_params_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GraspParams::set_grasp_params_frame_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.grasp_params_frame_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.GraspParams.grasp_params_frame_name)
}
inline std::string* GraspParams::mutable_grasp_params_frame_name() {
  std::string* _s = _internal_mutable_grasp_params_frame_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GraspParams.grasp_params_frame_name)
  return _s;
}
inline const std::string& GraspParams::_internal_grasp_params_frame_name() const {
  return _impl_.grasp_params_frame_name_.Get();
}
inline void GraspParams::_internal_set_grasp_params_frame_name(const std::string& value) {
  
  _impl_.grasp_params_frame_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GraspParams::_internal_mutable_grasp_params_frame_name() {
  
  return _impl_.grasp_params_frame_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GraspParams::release_grasp_params_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GraspParams.grasp_params_frame_name)
  return _impl_.grasp_params_frame_name_.Release();
}
inline void GraspParams::set_allocated_grasp_params_frame_name(std::string* grasp_params_frame_name) {
  if (grasp_params_frame_name != nullptr) {
    
  } else {
    
  }
  _impl_.grasp_params_frame_name_.SetAllocated(grasp_params_frame_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.grasp_params_frame_name_.IsDefault()) {
    _impl_.grasp_params_frame_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GraspParams.grasp_params_frame_name)
}

// repeated .bosdyn.api.AllowableOrientation allowable_orientation = 3;
inline int GraspParams::_internal_allowable_orientation_size() const {
  return _impl_.allowable_orientation_.size();
}
inline int GraspParams::allowable_orientation_size() const {
  return _internal_allowable_orientation_size();
}
inline void GraspParams::clear_allowable_orientation() {
  _impl_.allowable_orientation_.Clear();
}
inline ::bosdyn::api::AllowableOrientation* GraspParams::mutable_allowable_orientation(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GraspParams.allowable_orientation)
  return _impl_.allowable_orientation_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::AllowableOrientation >*
GraspParams::mutable_allowable_orientation() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.GraspParams.allowable_orientation)
  return &_impl_.allowable_orientation_;
}
inline const ::bosdyn::api::AllowableOrientation& GraspParams::_internal_allowable_orientation(int index) const {
  return _impl_.allowable_orientation_.Get(index);
}
inline const ::bosdyn::api::AllowableOrientation& GraspParams::allowable_orientation(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GraspParams.allowable_orientation)
  return _internal_allowable_orientation(index);
}
inline ::bosdyn::api::AllowableOrientation* GraspParams::_internal_add_allowable_orientation() {
  return _impl_.allowable_orientation_.Add();
}
inline ::bosdyn::api::AllowableOrientation* GraspParams::add_allowable_orientation() {
  ::bosdyn::api::AllowableOrientation* _add = _internal_add_allowable_orientation();
  // @@protoc_insertion_point(field_add:bosdyn.api.GraspParams.allowable_orientation)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::AllowableOrientation >&
GraspParams::allowable_orientation() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.GraspParams.allowable_orientation)
  return _impl_.allowable_orientation_;
}

// .bosdyn.api.GraspPositionConstraint position_constraint = 4;
inline void GraspParams::clear_position_constraint() {
  _impl_.position_constraint_ = 0;
}
inline ::bosdyn::api::GraspPositionConstraint GraspParams::_internal_position_constraint() const {
  return static_cast< ::bosdyn::api::GraspPositionConstraint >(_impl_.position_constraint_);
}
inline ::bosdyn::api::GraspPositionConstraint GraspParams::position_constraint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GraspParams.position_constraint)
  return _internal_position_constraint();
}
inline void GraspParams::_internal_set_position_constraint(::bosdyn::api::GraspPositionConstraint value) {
  
  _impl_.position_constraint_ = value;
}
inline void GraspParams::set_position_constraint(::bosdyn::api::GraspPositionConstraint value) {
  _internal_set_position_constraint(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.GraspParams.position_constraint)
}

// .bosdyn.api.ManipulationCameraSource manipulation_camera_source = 5;
inline void GraspParams::clear_manipulation_camera_source() {
  _impl_.manipulation_camera_source_ = 0;
}
inline ::bosdyn::api::ManipulationCameraSource GraspParams::_internal_manipulation_camera_source() const {
  return static_cast< ::bosdyn::api::ManipulationCameraSource >(_impl_.manipulation_camera_source_);
}
inline ::bosdyn::api::ManipulationCameraSource GraspParams::manipulation_camera_source() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GraspParams.manipulation_camera_source)
  return _internal_manipulation_camera_source();
}
inline void GraspParams::_internal_set_manipulation_camera_source(::bosdyn::api::ManipulationCameraSource value) {
  
  _impl_.manipulation_camera_source_ = value;
}
inline void GraspParams::set_manipulation_camera_source(::bosdyn::api::ManipulationCameraSource value) {
  _internal_set_manipulation_camera_source(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.GraspParams.manipulation_camera_source)
}

// -------------------------------------------------------------------

// AllowableOrientation

// .bosdyn.api.RotationWithTolerance rotation_with_tolerance = 1;
inline bool AllowableOrientation::_internal_has_rotation_with_tolerance() const {
  return constraint_case() == kRotationWithTolerance;
}
inline bool AllowableOrientation::has_rotation_with_tolerance() const {
  return _internal_has_rotation_with_tolerance();
}
inline void AllowableOrientation::set_has_rotation_with_tolerance() {
  _impl_._oneof_case_[0] = kRotationWithTolerance;
}
inline void AllowableOrientation::clear_rotation_with_tolerance() {
  if (_internal_has_rotation_with_tolerance()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.constraint_.rotation_with_tolerance_;
    }
    clear_has_constraint();
  }
}
inline ::bosdyn::api::RotationWithTolerance* AllowableOrientation::release_rotation_with_tolerance() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AllowableOrientation.rotation_with_tolerance)
  if (_internal_has_rotation_with_tolerance()) {
    clear_has_constraint();
    ::bosdyn::api::RotationWithTolerance* temp = _impl_.constraint_.rotation_with_tolerance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.rotation_with_tolerance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::RotationWithTolerance& AllowableOrientation::_internal_rotation_with_tolerance() const {
  return _internal_has_rotation_with_tolerance()
      ? *_impl_.constraint_.rotation_with_tolerance_
      : reinterpret_cast< ::bosdyn::api::RotationWithTolerance&>(::bosdyn::api::_RotationWithTolerance_default_instance_);
}
inline const ::bosdyn::api::RotationWithTolerance& AllowableOrientation::rotation_with_tolerance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AllowableOrientation.rotation_with_tolerance)
  return _internal_rotation_with_tolerance();
}
inline ::bosdyn::api::RotationWithTolerance* AllowableOrientation::unsafe_arena_release_rotation_with_tolerance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.AllowableOrientation.rotation_with_tolerance)
  if (_internal_has_rotation_with_tolerance()) {
    clear_has_constraint();
    ::bosdyn::api::RotationWithTolerance* temp = _impl_.constraint_.rotation_with_tolerance_;
    _impl_.constraint_.rotation_with_tolerance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AllowableOrientation::unsafe_arena_set_allocated_rotation_with_tolerance(::bosdyn::api::RotationWithTolerance* rotation_with_tolerance) {
  clear_constraint();
  if (rotation_with_tolerance) {
    set_has_rotation_with_tolerance();
    _impl_.constraint_.rotation_with_tolerance_ = rotation_with_tolerance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AllowableOrientation.rotation_with_tolerance)
}
inline ::bosdyn::api::RotationWithTolerance* AllowableOrientation::_internal_mutable_rotation_with_tolerance() {
  if (!_internal_has_rotation_with_tolerance()) {
    clear_constraint();
    set_has_rotation_with_tolerance();
    _impl_.constraint_.rotation_with_tolerance_ = CreateMaybeMessage< ::bosdyn::api::RotationWithTolerance >(GetArenaForAllocation());
  }
  return _impl_.constraint_.rotation_with_tolerance_;
}
inline ::bosdyn::api::RotationWithTolerance* AllowableOrientation::mutable_rotation_with_tolerance() {
  ::bosdyn::api::RotationWithTolerance* _msg = _internal_mutable_rotation_with_tolerance();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AllowableOrientation.rotation_with_tolerance)
  return _msg;
}

// .bosdyn.api.VectorAlignmentWithTolerance vector_alignment_with_tolerance = 2;
inline bool AllowableOrientation::_internal_has_vector_alignment_with_tolerance() const {
  return constraint_case() == kVectorAlignmentWithTolerance;
}
inline bool AllowableOrientation::has_vector_alignment_with_tolerance() const {
  return _internal_has_vector_alignment_with_tolerance();
}
inline void AllowableOrientation::set_has_vector_alignment_with_tolerance() {
  _impl_._oneof_case_[0] = kVectorAlignmentWithTolerance;
}
inline void AllowableOrientation::clear_vector_alignment_with_tolerance() {
  if (_internal_has_vector_alignment_with_tolerance()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.constraint_.vector_alignment_with_tolerance_;
    }
    clear_has_constraint();
  }
}
inline ::bosdyn::api::VectorAlignmentWithTolerance* AllowableOrientation::release_vector_alignment_with_tolerance() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AllowableOrientation.vector_alignment_with_tolerance)
  if (_internal_has_vector_alignment_with_tolerance()) {
    clear_has_constraint();
    ::bosdyn::api::VectorAlignmentWithTolerance* temp = _impl_.constraint_.vector_alignment_with_tolerance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.vector_alignment_with_tolerance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::VectorAlignmentWithTolerance& AllowableOrientation::_internal_vector_alignment_with_tolerance() const {
  return _internal_has_vector_alignment_with_tolerance()
      ? *_impl_.constraint_.vector_alignment_with_tolerance_
      : reinterpret_cast< ::bosdyn::api::VectorAlignmentWithTolerance&>(::bosdyn::api::_VectorAlignmentWithTolerance_default_instance_);
}
inline const ::bosdyn::api::VectorAlignmentWithTolerance& AllowableOrientation::vector_alignment_with_tolerance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AllowableOrientation.vector_alignment_with_tolerance)
  return _internal_vector_alignment_with_tolerance();
}
inline ::bosdyn::api::VectorAlignmentWithTolerance* AllowableOrientation::unsafe_arena_release_vector_alignment_with_tolerance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.AllowableOrientation.vector_alignment_with_tolerance)
  if (_internal_has_vector_alignment_with_tolerance()) {
    clear_has_constraint();
    ::bosdyn::api::VectorAlignmentWithTolerance* temp = _impl_.constraint_.vector_alignment_with_tolerance_;
    _impl_.constraint_.vector_alignment_with_tolerance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AllowableOrientation::unsafe_arena_set_allocated_vector_alignment_with_tolerance(::bosdyn::api::VectorAlignmentWithTolerance* vector_alignment_with_tolerance) {
  clear_constraint();
  if (vector_alignment_with_tolerance) {
    set_has_vector_alignment_with_tolerance();
    _impl_.constraint_.vector_alignment_with_tolerance_ = vector_alignment_with_tolerance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AllowableOrientation.vector_alignment_with_tolerance)
}
inline ::bosdyn::api::VectorAlignmentWithTolerance* AllowableOrientation::_internal_mutable_vector_alignment_with_tolerance() {
  if (!_internal_has_vector_alignment_with_tolerance()) {
    clear_constraint();
    set_has_vector_alignment_with_tolerance();
    _impl_.constraint_.vector_alignment_with_tolerance_ = CreateMaybeMessage< ::bosdyn::api::VectorAlignmentWithTolerance >(GetArenaForAllocation());
  }
  return _impl_.constraint_.vector_alignment_with_tolerance_;
}
inline ::bosdyn::api::VectorAlignmentWithTolerance* AllowableOrientation::mutable_vector_alignment_with_tolerance() {
  ::bosdyn::api::VectorAlignmentWithTolerance* _msg = _internal_mutable_vector_alignment_with_tolerance();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AllowableOrientation.vector_alignment_with_tolerance)
  return _msg;
}

// .bosdyn.api.SqueezeGrasp squeeze_grasp = 3;
inline bool AllowableOrientation::_internal_has_squeeze_grasp() const {
  return constraint_case() == kSqueezeGrasp;
}
inline bool AllowableOrientation::has_squeeze_grasp() const {
  return _internal_has_squeeze_grasp();
}
inline void AllowableOrientation::set_has_squeeze_grasp() {
  _impl_._oneof_case_[0] = kSqueezeGrasp;
}
inline void AllowableOrientation::clear_squeeze_grasp() {
  if (_internal_has_squeeze_grasp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.constraint_.squeeze_grasp_;
    }
    clear_has_constraint();
  }
}
inline ::bosdyn::api::SqueezeGrasp* AllowableOrientation::release_squeeze_grasp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AllowableOrientation.squeeze_grasp)
  if (_internal_has_squeeze_grasp()) {
    clear_has_constraint();
    ::bosdyn::api::SqueezeGrasp* temp = _impl_.constraint_.squeeze_grasp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.squeeze_grasp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::SqueezeGrasp& AllowableOrientation::_internal_squeeze_grasp() const {
  return _internal_has_squeeze_grasp()
      ? *_impl_.constraint_.squeeze_grasp_
      : reinterpret_cast< ::bosdyn::api::SqueezeGrasp&>(::bosdyn::api::_SqueezeGrasp_default_instance_);
}
inline const ::bosdyn::api::SqueezeGrasp& AllowableOrientation::squeeze_grasp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AllowableOrientation.squeeze_grasp)
  return _internal_squeeze_grasp();
}
inline ::bosdyn::api::SqueezeGrasp* AllowableOrientation::unsafe_arena_release_squeeze_grasp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.AllowableOrientation.squeeze_grasp)
  if (_internal_has_squeeze_grasp()) {
    clear_has_constraint();
    ::bosdyn::api::SqueezeGrasp* temp = _impl_.constraint_.squeeze_grasp_;
    _impl_.constraint_.squeeze_grasp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AllowableOrientation::unsafe_arena_set_allocated_squeeze_grasp(::bosdyn::api::SqueezeGrasp* squeeze_grasp) {
  clear_constraint();
  if (squeeze_grasp) {
    set_has_squeeze_grasp();
    _impl_.constraint_.squeeze_grasp_ = squeeze_grasp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AllowableOrientation.squeeze_grasp)
}
inline ::bosdyn::api::SqueezeGrasp* AllowableOrientation::_internal_mutable_squeeze_grasp() {
  if (!_internal_has_squeeze_grasp()) {
    clear_constraint();
    set_has_squeeze_grasp();
    _impl_.constraint_.squeeze_grasp_ = CreateMaybeMessage< ::bosdyn::api::SqueezeGrasp >(GetArenaForAllocation());
  }
  return _impl_.constraint_.squeeze_grasp_;
}
inline ::bosdyn::api::SqueezeGrasp* AllowableOrientation::mutable_squeeze_grasp() {
  ::bosdyn::api::SqueezeGrasp* _msg = _internal_mutable_squeeze_grasp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AllowableOrientation.squeeze_grasp)
  return _msg;
}

inline bool AllowableOrientation::has_constraint() const {
  return constraint_case() != CONSTRAINT_NOT_SET;
}
inline void AllowableOrientation::clear_has_constraint() {
  _impl_._oneof_case_[0] = CONSTRAINT_NOT_SET;
}
inline AllowableOrientation::ConstraintCase AllowableOrientation::constraint_case() const {
  return AllowableOrientation::ConstraintCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RotationWithTolerance

// .bosdyn.api.Quaternion rotation_ewrt_frame = 1;
inline bool RotationWithTolerance::_internal_has_rotation_ewrt_frame() const {
  return this != internal_default_instance() && _impl_.rotation_ewrt_frame_ != nullptr;
}
inline bool RotationWithTolerance::has_rotation_ewrt_frame() const {
  return _internal_has_rotation_ewrt_frame();
}
inline const ::bosdyn::api::Quaternion& RotationWithTolerance::_internal_rotation_ewrt_frame() const {
  const ::bosdyn::api::Quaternion* p = _impl_.rotation_ewrt_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Quaternion&>(
      ::bosdyn::api::_Quaternion_default_instance_);
}
inline const ::bosdyn::api::Quaternion& RotationWithTolerance::rotation_ewrt_frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RotationWithTolerance.rotation_ewrt_frame)
  return _internal_rotation_ewrt_frame();
}
inline void RotationWithTolerance::unsafe_arena_set_allocated_rotation_ewrt_frame(
    ::bosdyn::api::Quaternion* rotation_ewrt_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_ewrt_frame_);
  }
  _impl_.rotation_ewrt_frame_ = rotation_ewrt_frame;
  if (rotation_ewrt_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RotationWithTolerance.rotation_ewrt_frame)
}
inline ::bosdyn::api::Quaternion* RotationWithTolerance::release_rotation_ewrt_frame() {
  
  ::bosdyn::api::Quaternion* temp = _impl_.rotation_ewrt_frame_;
  _impl_.rotation_ewrt_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Quaternion* RotationWithTolerance::unsafe_arena_release_rotation_ewrt_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RotationWithTolerance.rotation_ewrt_frame)
  
  ::bosdyn::api::Quaternion* temp = _impl_.rotation_ewrt_frame_;
  _impl_.rotation_ewrt_frame_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Quaternion* RotationWithTolerance::_internal_mutable_rotation_ewrt_frame() {
  
  if (_impl_.rotation_ewrt_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Quaternion>(GetArenaForAllocation());
    _impl_.rotation_ewrt_frame_ = p;
  }
  return _impl_.rotation_ewrt_frame_;
}
inline ::bosdyn::api::Quaternion* RotationWithTolerance::mutable_rotation_ewrt_frame() {
  ::bosdyn::api::Quaternion* _msg = _internal_mutable_rotation_ewrt_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RotationWithTolerance.rotation_ewrt_frame)
  return _msg;
}
inline void RotationWithTolerance::set_allocated_rotation_ewrt_frame(::bosdyn::api::Quaternion* rotation_ewrt_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_ewrt_frame_);
  }
  if (rotation_ewrt_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_ewrt_frame));
    if (message_arena != submessage_arena) {
      rotation_ewrt_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation_ewrt_frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rotation_ewrt_frame_ = rotation_ewrt_frame;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RotationWithTolerance.rotation_ewrt_frame)
}

// float threshold_radians = 2;
inline void RotationWithTolerance::clear_threshold_radians() {
  _impl_.threshold_radians_ = 0;
}
inline float RotationWithTolerance::_internal_threshold_radians() const {
  return _impl_.threshold_radians_;
}
inline float RotationWithTolerance::threshold_radians() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RotationWithTolerance.threshold_radians)
  return _internal_threshold_radians();
}
inline void RotationWithTolerance::_internal_set_threshold_radians(float value) {
  
  _impl_.threshold_radians_ = value;
}
inline void RotationWithTolerance::set_threshold_radians(float value) {
  _internal_set_threshold_radians(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RotationWithTolerance.threshold_radians)
}

// -------------------------------------------------------------------

// VectorAlignmentWithTolerance

// .bosdyn.api.Vec3 axis_on_gripper_ewrt_gripper = 1;
inline bool VectorAlignmentWithTolerance::_internal_has_axis_on_gripper_ewrt_gripper() const {
  return this != internal_default_instance() && _impl_.axis_on_gripper_ewrt_gripper_ != nullptr;
}
inline bool VectorAlignmentWithTolerance::has_axis_on_gripper_ewrt_gripper() const {
  return _internal_has_axis_on_gripper_ewrt_gripper();
}
inline const ::bosdyn::api::Vec3& VectorAlignmentWithTolerance::_internal_axis_on_gripper_ewrt_gripper() const {
  const ::bosdyn::api::Vec3* p = _impl_.axis_on_gripper_ewrt_gripper_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& VectorAlignmentWithTolerance::axis_on_gripper_ewrt_gripper() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.VectorAlignmentWithTolerance.axis_on_gripper_ewrt_gripper)
  return _internal_axis_on_gripper_ewrt_gripper();
}
inline void VectorAlignmentWithTolerance::unsafe_arena_set_allocated_axis_on_gripper_ewrt_gripper(
    ::bosdyn::api::Vec3* axis_on_gripper_ewrt_gripper) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.axis_on_gripper_ewrt_gripper_);
  }
  _impl_.axis_on_gripper_ewrt_gripper_ = axis_on_gripper_ewrt_gripper;
  if (axis_on_gripper_ewrt_gripper) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.VectorAlignmentWithTolerance.axis_on_gripper_ewrt_gripper)
}
inline ::bosdyn::api::Vec3* VectorAlignmentWithTolerance::release_axis_on_gripper_ewrt_gripper() {
  
  ::bosdyn::api::Vec3* temp = _impl_.axis_on_gripper_ewrt_gripper_;
  _impl_.axis_on_gripper_ewrt_gripper_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* VectorAlignmentWithTolerance::unsafe_arena_release_axis_on_gripper_ewrt_gripper() {
  // @@protoc_insertion_point(field_release:bosdyn.api.VectorAlignmentWithTolerance.axis_on_gripper_ewrt_gripper)
  
  ::bosdyn::api::Vec3* temp = _impl_.axis_on_gripper_ewrt_gripper_;
  _impl_.axis_on_gripper_ewrt_gripper_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* VectorAlignmentWithTolerance::_internal_mutable_axis_on_gripper_ewrt_gripper() {
  
  if (_impl_.axis_on_gripper_ewrt_gripper_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.axis_on_gripper_ewrt_gripper_ = p;
  }
  return _impl_.axis_on_gripper_ewrt_gripper_;
}
inline ::bosdyn::api::Vec3* VectorAlignmentWithTolerance::mutable_axis_on_gripper_ewrt_gripper() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_axis_on_gripper_ewrt_gripper();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.VectorAlignmentWithTolerance.axis_on_gripper_ewrt_gripper)
  return _msg;
}
inline void VectorAlignmentWithTolerance::set_allocated_axis_on_gripper_ewrt_gripper(::bosdyn::api::Vec3* axis_on_gripper_ewrt_gripper) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.axis_on_gripper_ewrt_gripper_);
  }
  if (axis_on_gripper_ewrt_gripper) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(axis_on_gripper_ewrt_gripper));
    if (message_arena != submessage_arena) {
      axis_on_gripper_ewrt_gripper = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, axis_on_gripper_ewrt_gripper, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.axis_on_gripper_ewrt_gripper_ = axis_on_gripper_ewrt_gripper;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.VectorAlignmentWithTolerance.axis_on_gripper_ewrt_gripper)
}

// .bosdyn.api.Vec3 axis_to_align_with_ewrt_frame = 2;
inline bool VectorAlignmentWithTolerance::_internal_has_axis_to_align_with_ewrt_frame() const {
  return this != internal_default_instance() && _impl_.axis_to_align_with_ewrt_frame_ != nullptr;
}
inline bool VectorAlignmentWithTolerance::has_axis_to_align_with_ewrt_frame() const {
  return _internal_has_axis_to_align_with_ewrt_frame();
}
inline const ::bosdyn::api::Vec3& VectorAlignmentWithTolerance::_internal_axis_to_align_with_ewrt_frame() const {
  const ::bosdyn::api::Vec3* p = _impl_.axis_to_align_with_ewrt_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& VectorAlignmentWithTolerance::axis_to_align_with_ewrt_frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.VectorAlignmentWithTolerance.axis_to_align_with_ewrt_frame)
  return _internal_axis_to_align_with_ewrt_frame();
}
inline void VectorAlignmentWithTolerance::unsafe_arena_set_allocated_axis_to_align_with_ewrt_frame(
    ::bosdyn::api::Vec3* axis_to_align_with_ewrt_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.axis_to_align_with_ewrt_frame_);
  }
  _impl_.axis_to_align_with_ewrt_frame_ = axis_to_align_with_ewrt_frame;
  if (axis_to_align_with_ewrt_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.VectorAlignmentWithTolerance.axis_to_align_with_ewrt_frame)
}
inline ::bosdyn::api::Vec3* VectorAlignmentWithTolerance::release_axis_to_align_with_ewrt_frame() {
  
  ::bosdyn::api::Vec3* temp = _impl_.axis_to_align_with_ewrt_frame_;
  _impl_.axis_to_align_with_ewrt_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* VectorAlignmentWithTolerance::unsafe_arena_release_axis_to_align_with_ewrt_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.VectorAlignmentWithTolerance.axis_to_align_with_ewrt_frame)
  
  ::bosdyn::api::Vec3* temp = _impl_.axis_to_align_with_ewrt_frame_;
  _impl_.axis_to_align_with_ewrt_frame_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* VectorAlignmentWithTolerance::_internal_mutable_axis_to_align_with_ewrt_frame() {
  
  if (_impl_.axis_to_align_with_ewrt_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.axis_to_align_with_ewrt_frame_ = p;
  }
  return _impl_.axis_to_align_with_ewrt_frame_;
}
inline ::bosdyn::api::Vec3* VectorAlignmentWithTolerance::mutable_axis_to_align_with_ewrt_frame() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_axis_to_align_with_ewrt_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.VectorAlignmentWithTolerance.axis_to_align_with_ewrt_frame)
  return _msg;
}
inline void VectorAlignmentWithTolerance::set_allocated_axis_to_align_with_ewrt_frame(::bosdyn::api::Vec3* axis_to_align_with_ewrt_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.axis_to_align_with_ewrt_frame_);
  }
  if (axis_to_align_with_ewrt_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(axis_to_align_with_ewrt_frame));
    if (message_arena != submessage_arena) {
      axis_to_align_with_ewrt_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, axis_to_align_with_ewrt_frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.axis_to_align_with_ewrt_frame_ = axis_to_align_with_ewrt_frame;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.VectorAlignmentWithTolerance.axis_to_align_with_ewrt_frame)
}

// float threshold_radians = 3;
inline void VectorAlignmentWithTolerance::clear_threshold_radians() {
  _impl_.threshold_radians_ = 0;
}
inline float VectorAlignmentWithTolerance::_internal_threshold_radians() const {
  return _impl_.threshold_radians_;
}
inline float VectorAlignmentWithTolerance::threshold_radians() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.VectorAlignmentWithTolerance.threshold_radians)
  return _internal_threshold_radians();
}
inline void VectorAlignmentWithTolerance::_internal_set_threshold_radians(float value) {
  
  _impl_.threshold_radians_ = value;
}
inline void VectorAlignmentWithTolerance::set_threshold_radians(float value) {
  _internal_set_threshold_radians(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.VectorAlignmentWithTolerance.threshold_radians)
}

// -------------------------------------------------------------------

// SqueezeGrasp

// bool squeeze_grasp_disallowed = 1;
inline void SqueezeGrasp::clear_squeeze_grasp_disallowed() {
  _impl_.squeeze_grasp_disallowed_ = false;
}
inline bool SqueezeGrasp::_internal_squeeze_grasp_disallowed() const {
  return _impl_.squeeze_grasp_disallowed_;
}
inline bool SqueezeGrasp::squeeze_grasp_disallowed() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SqueezeGrasp.squeeze_grasp_disallowed)
  return _internal_squeeze_grasp_disallowed();
}
inline void SqueezeGrasp::_internal_set_squeeze_grasp_disallowed(bool value) {
  
  _impl_.squeeze_grasp_disallowed_ = value;
}
inline void SqueezeGrasp::set_squeeze_grasp_disallowed(bool value) {
  _internal_set_squeeze_grasp_disallowed(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SqueezeGrasp.squeeze_grasp_disallowed)
}

// -------------------------------------------------------------------

// ManipulationApiFeedbackRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ManipulationApiFeedbackRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ManipulationApiFeedbackRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ManipulationApiFeedbackRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ManipulationApiFeedbackRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiFeedbackRequest.header)
  return _internal_header();
}
inline void ManipulationApiFeedbackRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ManipulationApiFeedbackRequest.header)
}
inline ::bosdyn::api::RequestHeader* ManipulationApiFeedbackRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ManipulationApiFeedbackRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ManipulationApiFeedbackRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ManipulationApiFeedbackRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ManipulationApiFeedbackRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ManipulationApiFeedbackRequest.header)
  return _msg;
}
inline void ManipulationApiFeedbackRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ManipulationApiFeedbackRequest.header)
}

// int32 manipulation_cmd_id = 2;
inline void ManipulationApiFeedbackRequest::clear_manipulation_cmd_id() {
  _impl_.manipulation_cmd_id_ = 0;
}
inline int32_t ManipulationApiFeedbackRequest::_internal_manipulation_cmd_id() const {
  return _impl_.manipulation_cmd_id_;
}
inline int32_t ManipulationApiFeedbackRequest::manipulation_cmd_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiFeedbackRequest.manipulation_cmd_id)
  return _internal_manipulation_cmd_id();
}
inline void ManipulationApiFeedbackRequest::_internal_set_manipulation_cmd_id(int32_t value) {
  
  _impl_.manipulation_cmd_id_ = value;
}
inline void ManipulationApiFeedbackRequest::set_manipulation_cmd_id(int32_t value) {
  _internal_set_manipulation_cmd_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ManipulationApiFeedbackRequest.manipulation_cmd_id)
}

// -------------------------------------------------------------------

// ManipulationApiFeedbackResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ManipulationApiFeedbackResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ManipulationApiFeedbackResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ManipulationApiFeedbackResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ManipulationApiFeedbackResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiFeedbackResponse.header)
  return _internal_header();
}
inline void ManipulationApiFeedbackResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ManipulationApiFeedbackResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ManipulationApiFeedbackResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ManipulationApiFeedbackResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ManipulationApiFeedbackResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ManipulationApiFeedbackResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ManipulationApiFeedbackResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ManipulationApiFeedbackResponse.header)
  return _msg;
}
inline void ManipulationApiFeedbackResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ManipulationApiFeedbackResponse.header)
}

// int32 manipulation_cmd_id = 4;
inline void ManipulationApiFeedbackResponse::clear_manipulation_cmd_id() {
  _impl_.manipulation_cmd_id_ = 0;
}
inline int32_t ManipulationApiFeedbackResponse::_internal_manipulation_cmd_id() const {
  return _impl_.manipulation_cmd_id_;
}
inline int32_t ManipulationApiFeedbackResponse::manipulation_cmd_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiFeedbackResponse.manipulation_cmd_id)
  return _internal_manipulation_cmd_id();
}
inline void ManipulationApiFeedbackResponse::_internal_set_manipulation_cmd_id(int32_t value) {
  
  _impl_.manipulation_cmd_id_ = value;
}
inline void ManipulationApiFeedbackResponse::set_manipulation_cmd_id(int32_t value) {
  _internal_set_manipulation_cmd_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ManipulationApiFeedbackResponse.manipulation_cmd_id)
}

// .bosdyn.api.ManipulationFeedbackState current_state = 2;
inline void ManipulationApiFeedbackResponse::clear_current_state() {
  _impl_.current_state_ = 0;
}
inline ::bosdyn::api::ManipulationFeedbackState ManipulationApiFeedbackResponse::_internal_current_state() const {
  return static_cast< ::bosdyn::api::ManipulationFeedbackState >(_impl_.current_state_);
}
inline ::bosdyn::api::ManipulationFeedbackState ManipulationApiFeedbackResponse::current_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiFeedbackResponse.current_state)
  return _internal_current_state();
}
inline void ManipulationApiFeedbackResponse::_internal_set_current_state(::bosdyn::api::ManipulationFeedbackState value) {
  
  _impl_.current_state_ = value;
}
inline void ManipulationApiFeedbackResponse::set_current_state(::bosdyn::api::ManipulationFeedbackState value) {
  _internal_set_current_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ManipulationApiFeedbackResponse.current_state)
}

// .bosdyn.api.FrameTreeSnapshot transforms_snapshot_manipulation_data = 3;
inline bool ManipulationApiFeedbackResponse::_internal_has_transforms_snapshot_manipulation_data() const {
  return this != internal_default_instance() && _impl_.transforms_snapshot_manipulation_data_ != nullptr;
}
inline bool ManipulationApiFeedbackResponse::has_transforms_snapshot_manipulation_data() const {
  return _internal_has_transforms_snapshot_manipulation_data();
}
inline const ::bosdyn::api::FrameTreeSnapshot& ManipulationApiFeedbackResponse::_internal_transforms_snapshot_manipulation_data() const {
  const ::bosdyn::api::FrameTreeSnapshot* p = _impl_.transforms_snapshot_manipulation_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::FrameTreeSnapshot&>(
      ::bosdyn::api::_FrameTreeSnapshot_default_instance_);
}
inline const ::bosdyn::api::FrameTreeSnapshot& ManipulationApiFeedbackResponse::transforms_snapshot_manipulation_data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiFeedbackResponse.transforms_snapshot_manipulation_data)
  return _internal_transforms_snapshot_manipulation_data();
}
inline void ManipulationApiFeedbackResponse::unsafe_arena_set_allocated_transforms_snapshot_manipulation_data(
    ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_manipulation_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transforms_snapshot_manipulation_data_);
  }
  _impl_.transforms_snapshot_manipulation_data_ = transforms_snapshot_manipulation_data;
  if (transforms_snapshot_manipulation_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ManipulationApiFeedbackResponse.transforms_snapshot_manipulation_data)
}
inline ::bosdyn::api::FrameTreeSnapshot* ManipulationApiFeedbackResponse::release_transforms_snapshot_manipulation_data() {
  
  ::bosdyn::api::FrameTreeSnapshot* temp = _impl_.transforms_snapshot_manipulation_data_;
  _impl_.transforms_snapshot_manipulation_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::FrameTreeSnapshot* ManipulationApiFeedbackResponse::unsafe_arena_release_transforms_snapshot_manipulation_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ManipulationApiFeedbackResponse.transforms_snapshot_manipulation_data)
  
  ::bosdyn::api::FrameTreeSnapshot* temp = _impl_.transforms_snapshot_manipulation_data_;
  _impl_.transforms_snapshot_manipulation_data_ = nullptr;
  return temp;
}
inline ::bosdyn::api::FrameTreeSnapshot* ManipulationApiFeedbackResponse::_internal_mutable_transforms_snapshot_manipulation_data() {
  
  if (_impl_.transforms_snapshot_manipulation_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::FrameTreeSnapshot>(GetArenaForAllocation());
    _impl_.transforms_snapshot_manipulation_data_ = p;
  }
  return _impl_.transforms_snapshot_manipulation_data_;
}
inline ::bosdyn::api::FrameTreeSnapshot* ManipulationApiFeedbackResponse::mutable_transforms_snapshot_manipulation_data() {
  ::bosdyn::api::FrameTreeSnapshot* _msg = _internal_mutable_transforms_snapshot_manipulation_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ManipulationApiFeedbackResponse.transforms_snapshot_manipulation_data)
  return _msg;
}
inline void ManipulationApiFeedbackResponse::set_allocated_transforms_snapshot_manipulation_data(::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_manipulation_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transforms_snapshot_manipulation_data_);
  }
  if (transforms_snapshot_manipulation_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transforms_snapshot_manipulation_data));
    if (message_arena != submessage_arena) {
      transforms_snapshot_manipulation_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transforms_snapshot_manipulation_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transforms_snapshot_manipulation_data_ = transforms_snapshot_manipulation_data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ManipulationApiFeedbackResponse.transforms_snapshot_manipulation_data)
}

// -------------------------------------------------------------------

// ManipulationApiResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ManipulationApiResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ManipulationApiResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ManipulationApiResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ManipulationApiResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiResponse.header)
  return _internal_header();
}
inline void ManipulationApiResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ManipulationApiResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ManipulationApiResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ManipulationApiResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ManipulationApiResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ManipulationApiResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ManipulationApiResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ManipulationApiResponse.header)
  return _msg;
}
inline void ManipulationApiResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ManipulationApiResponse.header)
}

// int32 manipulation_cmd_id = 5;
inline void ManipulationApiResponse::clear_manipulation_cmd_id() {
  _impl_.manipulation_cmd_id_ = 0;
}
inline int32_t ManipulationApiResponse::_internal_manipulation_cmd_id() const {
  return _impl_.manipulation_cmd_id_;
}
inline int32_t ManipulationApiResponse::manipulation_cmd_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiResponse.manipulation_cmd_id)
  return _internal_manipulation_cmd_id();
}
inline void ManipulationApiResponse::_internal_set_manipulation_cmd_id(int32_t value) {
  
  _impl_.manipulation_cmd_id_ = value;
}
inline void ManipulationApiResponse::set_manipulation_cmd_id(int32_t value) {
  _internal_set_manipulation_cmd_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ManipulationApiResponse.manipulation_cmd_id)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 6;
inline bool ManipulationApiResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && _impl_.lease_use_result_ != nullptr;
}
inline bool ManipulationApiResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& ManipulationApiResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = _impl_.lease_use_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::LeaseUseResult&>(
      ::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& ManipulationApiResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void ManipulationApiResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  _impl_.lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ManipulationApiResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* ManipulationApiResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* ManipulationApiResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ManipulationApiResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* ManipulationApiResponse::_internal_mutable_lease_use_result() {
  
  if (_impl_.lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArenaForAllocation());
    _impl_.lease_use_result_ = p;
  }
  return _impl_.lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* ManipulationApiResponse::mutable_lease_use_result() {
  ::bosdyn::api::LeaseUseResult* _msg = _internal_mutable_lease_use_result();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ManipulationApiResponse.lease_use_result)
  return _msg;
}
inline void ManipulationApiResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result));
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ManipulationApiResponse.lease_use_result)
}

// -------------------------------------------------------------------

// ManipulationApiRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ManipulationApiRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ManipulationApiRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ManipulationApiRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ManipulationApiRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiRequest.header)
  return _internal_header();
}
inline void ManipulationApiRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ManipulationApiRequest.header)
}
inline ::bosdyn::api::RequestHeader* ManipulationApiRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ManipulationApiRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ManipulationApiRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ManipulationApiRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ManipulationApiRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ManipulationApiRequest.header)
  return _msg;
}
inline void ManipulationApiRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ManipulationApiRequest.header)
}

// .bosdyn.api.Lease lease = 2;
inline bool ManipulationApiRequest::_internal_has_lease() const {
  return this != internal_default_instance() && _impl_.lease_ != nullptr;
}
inline bool ManipulationApiRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& ManipulationApiRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = _impl_.lease_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Lease&>(
      ::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& ManipulationApiRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiRequest.lease)
  return _internal_lease();
}
inline void ManipulationApiRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  _impl_.lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ManipulationApiRequest.lease)
}
inline ::bosdyn::api::Lease* ManipulationApiRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Lease* ManipulationApiRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ManipulationApiRequest.lease)
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* ManipulationApiRequest::_internal_mutable_lease() {
  
  if (_impl_.lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArenaForAllocation());
    _impl_.lease_ = p;
  }
  return _impl_.lease_;
}
inline ::bosdyn::api::Lease* ManipulationApiRequest::mutable_lease() {
  ::bosdyn::api::Lease* _msg = _internal_mutable_lease();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ManipulationApiRequest.lease)
  return _msg;
}
inline void ManipulationApiRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease));
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ManipulationApiRequest.lease)
}

// .bosdyn.api.WalkToObjectRayInWorld walk_to_object_ray_in_world = 12;
inline bool ManipulationApiRequest::_internal_has_walk_to_object_ray_in_world() const {
  return manipulation_cmd_case() == kWalkToObjectRayInWorld;
}
inline bool ManipulationApiRequest::has_walk_to_object_ray_in_world() const {
  return _internal_has_walk_to_object_ray_in_world();
}
inline void ManipulationApiRequest::set_has_walk_to_object_ray_in_world() {
  _impl_._oneof_case_[0] = kWalkToObjectRayInWorld;
}
inline void ManipulationApiRequest::clear_walk_to_object_ray_in_world() {
  if (_internal_has_walk_to_object_ray_in_world()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.manipulation_cmd_.walk_to_object_ray_in_world_;
    }
    clear_has_manipulation_cmd();
  }
}
inline ::bosdyn::api::WalkToObjectRayInWorld* ManipulationApiRequest::release_walk_to_object_ray_in_world() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ManipulationApiRequest.walk_to_object_ray_in_world)
  if (_internal_has_walk_to_object_ray_in_world()) {
    clear_has_manipulation_cmd();
    ::bosdyn::api::WalkToObjectRayInWorld* temp = _impl_.manipulation_cmd_.walk_to_object_ray_in_world_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.manipulation_cmd_.walk_to_object_ray_in_world_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::WalkToObjectRayInWorld& ManipulationApiRequest::_internal_walk_to_object_ray_in_world() const {
  return _internal_has_walk_to_object_ray_in_world()
      ? *_impl_.manipulation_cmd_.walk_to_object_ray_in_world_
      : reinterpret_cast< ::bosdyn::api::WalkToObjectRayInWorld&>(::bosdyn::api::_WalkToObjectRayInWorld_default_instance_);
}
inline const ::bosdyn::api::WalkToObjectRayInWorld& ManipulationApiRequest::walk_to_object_ray_in_world() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiRequest.walk_to_object_ray_in_world)
  return _internal_walk_to_object_ray_in_world();
}
inline ::bosdyn::api::WalkToObjectRayInWorld* ManipulationApiRequest::unsafe_arena_release_walk_to_object_ray_in_world() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.ManipulationApiRequest.walk_to_object_ray_in_world)
  if (_internal_has_walk_to_object_ray_in_world()) {
    clear_has_manipulation_cmd();
    ::bosdyn::api::WalkToObjectRayInWorld* temp = _impl_.manipulation_cmd_.walk_to_object_ray_in_world_;
    _impl_.manipulation_cmd_.walk_to_object_ray_in_world_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ManipulationApiRequest::unsafe_arena_set_allocated_walk_to_object_ray_in_world(::bosdyn::api::WalkToObjectRayInWorld* walk_to_object_ray_in_world) {
  clear_manipulation_cmd();
  if (walk_to_object_ray_in_world) {
    set_has_walk_to_object_ray_in_world();
    _impl_.manipulation_cmd_.walk_to_object_ray_in_world_ = walk_to_object_ray_in_world;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ManipulationApiRequest.walk_to_object_ray_in_world)
}
inline ::bosdyn::api::WalkToObjectRayInWorld* ManipulationApiRequest::_internal_mutable_walk_to_object_ray_in_world() {
  if (!_internal_has_walk_to_object_ray_in_world()) {
    clear_manipulation_cmd();
    set_has_walk_to_object_ray_in_world();
    _impl_.manipulation_cmd_.walk_to_object_ray_in_world_ = CreateMaybeMessage< ::bosdyn::api::WalkToObjectRayInWorld >(GetArenaForAllocation());
  }
  return _impl_.manipulation_cmd_.walk_to_object_ray_in_world_;
}
inline ::bosdyn::api::WalkToObjectRayInWorld* ManipulationApiRequest::mutable_walk_to_object_ray_in_world() {
  ::bosdyn::api::WalkToObjectRayInWorld* _msg = _internal_mutable_walk_to_object_ray_in_world();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ManipulationApiRequest.walk_to_object_ray_in_world)
  return _msg;
}

// .bosdyn.api.WalkToObjectInImage walk_to_object_in_image = 13;
inline bool ManipulationApiRequest::_internal_has_walk_to_object_in_image() const {
  return manipulation_cmd_case() == kWalkToObjectInImage;
}
inline bool ManipulationApiRequest::has_walk_to_object_in_image() const {
  return _internal_has_walk_to_object_in_image();
}
inline void ManipulationApiRequest::set_has_walk_to_object_in_image() {
  _impl_._oneof_case_[0] = kWalkToObjectInImage;
}
inline void ManipulationApiRequest::clear_walk_to_object_in_image() {
  if (_internal_has_walk_to_object_in_image()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.manipulation_cmd_.walk_to_object_in_image_;
    }
    clear_has_manipulation_cmd();
  }
}
inline ::bosdyn::api::WalkToObjectInImage* ManipulationApiRequest::release_walk_to_object_in_image() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ManipulationApiRequest.walk_to_object_in_image)
  if (_internal_has_walk_to_object_in_image()) {
    clear_has_manipulation_cmd();
    ::bosdyn::api::WalkToObjectInImage* temp = _impl_.manipulation_cmd_.walk_to_object_in_image_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.manipulation_cmd_.walk_to_object_in_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::WalkToObjectInImage& ManipulationApiRequest::_internal_walk_to_object_in_image() const {
  return _internal_has_walk_to_object_in_image()
      ? *_impl_.manipulation_cmd_.walk_to_object_in_image_
      : reinterpret_cast< ::bosdyn::api::WalkToObjectInImage&>(::bosdyn::api::_WalkToObjectInImage_default_instance_);
}
inline const ::bosdyn::api::WalkToObjectInImage& ManipulationApiRequest::walk_to_object_in_image() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiRequest.walk_to_object_in_image)
  return _internal_walk_to_object_in_image();
}
inline ::bosdyn::api::WalkToObjectInImage* ManipulationApiRequest::unsafe_arena_release_walk_to_object_in_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.ManipulationApiRequest.walk_to_object_in_image)
  if (_internal_has_walk_to_object_in_image()) {
    clear_has_manipulation_cmd();
    ::bosdyn::api::WalkToObjectInImage* temp = _impl_.manipulation_cmd_.walk_to_object_in_image_;
    _impl_.manipulation_cmd_.walk_to_object_in_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ManipulationApiRequest::unsafe_arena_set_allocated_walk_to_object_in_image(::bosdyn::api::WalkToObjectInImage* walk_to_object_in_image) {
  clear_manipulation_cmd();
  if (walk_to_object_in_image) {
    set_has_walk_to_object_in_image();
    _impl_.manipulation_cmd_.walk_to_object_in_image_ = walk_to_object_in_image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ManipulationApiRequest.walk_to_object_in_image)
}
inline ::bosdyn::api::WalkToObjectInImage* ManipulationApiRequest::_internal_mutable_walk_to_object_in_image() {
  if (!_internal_has_walk_to_object_in_image()) {
    clear_manipulation_cmd();
    set_has_walk_to_object_in_image();
    _impl_.manipulation_cmd_.walk_to_object_in_image_ = CreateMaybeMessage< ::bosdyn::api::WalkToObjectInImage >(GetArenaForAllocation());
  }
  return _impl_.manipulation_cmd_.walk_to_object_in_image_;
}
inline ::bosdyn::api::WalkToObjectInImage* ManipulationApiRequest::mutable_walk_to_object_in_image() {
  ::bosdyn::api::WalkToObjectInImage* _msg = _internal_mutable_walk_to_object_in_image();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ManipulationApiRequest.walk_to_object_in_image)
  return _msg;
}

// .bosdyn.api.PickObject pick_object = 10;
inline bool ManipulationApiRequest::_internal_has_pick_object() const {
  return manipulation_cmd_case() == kPickObject;
}
inline bool ManipulationApiRequest::has_pick_object() const {
  return _internal_has_pick_object();
}
inline void ManipulationApiRequest::set_has_pick_object() {
  _impl_._oneof_case_[0] = kPickObject;
}
inline void ManipulationApiRequest::clear_pick_object() {
  if (_internal_has_pick_object()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.manipulation_cmd_.pick_object_;
    }
    clear_has_manipulation_cmd();
  }
}
inline ::bosdyn::api::PickObject* ManipulationApiRequest::release_pick_object() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ManipulationApiRequest.pick_object)
  if (_internal_has_pick_object()) {
    clear_has_manipulation_cmd();
    ::bosdyn::api::PickObject* temp = _impl_.manipulation_cmd_.pick_object_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.manipulation_cmd_.pick_object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::PickObject& ManipulationApiRequest::_internal_pick_object() const {
  return _internal_has_pick_object()
      ? *_impl_.manipulation_cmd_.pick_object_
      : reinterpret_cast< ::bosdyn::api::PickObject&>(::bosdyn::api::_PickObject_default_instance_);
}
inline const ::bosdyn::api::PickObject& ManipulationApiRequest::pick_object() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiRequest.pick_object)
  return _internal_pick_object();
}
inline ::bosdyn::api::PickObject* ManipulationApiRequest::unsafe_arena_release_pick_object() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.ManipulationApiRequest.pick_object)
  if (_internal_has_pick_object()) {
    clear_has_manipulation_cmd();
    ::bosdyn::api::PickObject* temp = _impl_.manipulation_cmd_.pick_object_;
    _impl_.manipulation_cmd_.pick_object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ManipulationApiRequest::unsafe_arena_set_allocated_pick_object(::bosdyn::api::PickObject* pick_object) {
  clear_manipulation_cmd();
  if (pick_object) {
    set_has_pick_object();
    _impl_.manipulation_cmd_.pick_object_ = pick_object;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ManipulationApiRequest.pick_object)
}
inline ::bosdyn::api::PickObject* ManipulationApiRequest::_internal_mutable_pick_object() {
  if (!_internal_has_pick_object()) {
    clear_manipulation_cmd();
    set_has_pick_object();
    _impl_.manipulation_cmd_.pick_object_ = CreateMaybeMessage< ::bosdyn::api::PickObject >(GetArenaForAllocation());
  }
  return _impl_.manipulation_cmd_.pick_object_;
}
inline ::bosdyn::api::PickObject* ManipulationApiRequest::mutable_pick_object() {
  ::bosdyn::api::PickObject* _msg = _internal_mutable_pick_object();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ManipulationApiRequest.pick_object)
  return _msg;
}

// .bosdyn.api.PickObjectInImage pick_object_in_image = 11;
inline bool ManipulationApiRequest::_internal_has_pick_object_in_image() const {
  return manipulation_cmd_case() == kPickObjectInImage;
}
inline bool ManipulationApiRequest::has_pick_object_in_image() const {
  return _internal_has_pick_object_in_image();
}
inline void ManipulationApiRequest::set_has_pick_object_in_image() {
  _impl_._oneof_case_[0] = kPickObjectInImage;
}
inline void ManipulationApiRequest::clear_pick_object_in_image() {
  if (_internal_has_pick_object_in_image()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.manipulation_cmd_.pick_object_in_image_;
    }
    clear_has_manipulation_cmd();
  }
}
inline ::bosdyn::api::PickObjectInImage* ManipulationApiRequest::release_pick_object_in_image() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ManipulationApiRequest.pick_object_in_image)
  if (_internal_has_pick_object_in_image()) {
    clear_has_manipulation_cmd();
    ::bosdyn::api::PickObjectInImage* temp = _impl_.manipulation_cmd_.pick_object_in_image_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.manipulation_cmd_.pick_object_in_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::PickObjectInImage& ManipulationApiRequest::_internal_pick_object_in_image() const {
  return _internal_has_pick_object_in_image()
      ? *_impl_.manipulation_cmd_.pick_object_in_image_
      : reinterpret_cast< ::bosdyn::api::PickObjectInImage&>(::bosdyn::api::_PickObjectInImage_default_instance_);
}
inline const ::bosdyn::api::PickObjectInImage& ManipulationApiRequest::pick_object_in_image() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiRequest.pick_object_in_image)
  return _internal_pick_object_in_image();
}
inline ::bosdyn::api::PickObjectInImage* ManipulationApiRequest::unsafe_arena_release_pick_object_in_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.ManipulationApiRequest.pick_object_in_image)
  if (_internal_has_pick_object_in_image()) {
    clear_has_manipulation_cmd();
    ::bosdyn::api::PickObjectInImage* temp = _impl_.manipulation_cmd_.pick_object_in_image_;
    _impl_.manipulation_cmd_.pick_object_in_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ManipulationApiRequest::unsafe_arena_set_allocated_pick_object_in_image(::bosdyn::api::PickObjectInImage* pick_object_in_image) {
  clear_manipulation_cmd();
  if (pick_object_in_image) {
    set_has_pick_object_in_image();
    _impl_.manipulation_cmd_.pick_object_in_image_ = pick_object_in_image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ManipulationApiRequest.pick_object_in_image)
}
inline ::bosdyn::api::PickObjectInImage* ManipulationApiRequest::_internal_mutable_pick_object_in_image() {
  if (!_internal_has_pick_object_in_image()) {
    clear_manipulation_cmd();
    set_has_pick_object_in_image();
    _impl_.manipulation_cmd_.pick_object_in_image_ = CreateMaybeMessage< ::bosdyn::api::PickObjectInImage >(GetArenaForAllocation());
  }
  return _impl_.manipulation_cmd_.pick_object_in_image_;
}
inline ::bosdyn::api::PickObjectInImage* ManipulationApiRequest::mutable_pick_object_in_image() {
  ::bosdyn::api::PickObjectInImage* _msg = _internal_mutable_pick_object_in_image();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ManipulationApiRequest.pick_object_in_image)
  return _msg;
}

// .bosdyn.api.PickObjectRayInWorld pick_object_ray_in_world = 4;
inline bool ManipulationApiRequest::_internal_has_pick_object_ray_in_world() const {
  return manipulation_cmd_case() == kPickObjectRayInWorld;
}
inline bool ManipulationApiRequest::has_pick_object_ray_in_world() const {
  return _internal_has_pick_object_ray_in_world();
}
inline void ManipulationApiRequest::set_has_pick_object_ray_in_world() {
  _impl_._oneof_case_[0] = kPickObjectRayInWorld;
}
inline void ManipulationApiRequest::clear_pick_object_ray_in_world() {
  if (_internal_has_pick_object_ray_in_world()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.manipulation_cmd_.pick_object_ray_in_world_;
    }
    clear_has_manipulation_cmd();
  }
}
inline ::bosdyn::api::PickObjectRayInWorld* ManipulationApiRequest::release_pick_object_ray_in_world() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ManipulationApiRequest.pick_object_ray_in_world)
  if (_internal_has_pick_object_ray_in_world()) {
    clear_has_manipulation_cmd();
    ::bosdyn::api::PickObjectRayInWorld* temp = _impl_.manipulation_cmd_.pick_object_ray_in_world_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.manipulation_cmd_.pick_object_ray_in_world_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::PickObjectRayInWorld& ManipulationApiRequest::_internal_pick_object_ray_in_world() const {
  return _internal_has_pick_object_ray_in_world()
      ? *_impl_.manipulation_cmd_.pick_object_ray_in_world_
      : reinterpret_cast< ::bosdyn::api::PickObjectRayInWorld&>(::bosdyn::api::_PickObjectRayInWorld_default_instance_);
}
inline const ::bosdyn::api::PickObjectRayInWorld& ManipulationApiRequest::pick_object_ray_in_world() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiRequest.pick_object_ray_in_world)
  return _internal_pick_object_ray_in_world();
}
inline ::bosdyn::api::PickObjectRayInWorld* ManipulationApiRequest::unsafe_arena_release_pick_object_ray_in_world() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.ManipulationApiRequest.pick_object_ray_in_world)
  if (_internal_has_pick_object_ray_in_world()) {
    clear_has_manipulation_cmd();
    ::bosdyn::api::PickObjectRayInWorld* temp = _impl_.manipulation_cmd_.pick_object_ray_in_world_;
    _impl_.manipulation_cmd_.pick_object_ray_in_world_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ManipulationApiRequest::unsafe_arena_set_allocated_pick_object_ray_in_world(::bosdyn::api::PickObjectRayInWorld* pick_object_ray_in_world) {
  clear_manipulation_cmd();
  if (pick_object_ray_in_world) {
    set_has_pick_object_ray_in_world();
    _impl_.manipulation_cmd_.pick_object_ray_in_world_ = pick_object_ray_in_world;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ManipulationApiRequest.pick_object_ray_in_world)
}
inline ::bosdyn::api::PickObjectRayInWorld* ManipulationApiRequest::_internal_mutable_pick_object_ray_in_world() {
  if (!_internal_has_pick_object_ray_in_world()) {
    clear_manipulation_cmd();
    set_has_pick_object_ray_in_world();
    _impl_.manipulation_cmd_.pick_object_ray_in_world_ = CreateMaybeMessage< ::bosdyn::api::PickObjectRayInWorld >(GetArenaForAllocation());
  }
  return _impl_.manipulation_cmd_.pick_object_ray_in_world_;
}
inline ::bosdyn::api::PickObjectRayInWorld* ManipulationApiRequest::mutable_pick_object_ray_in_world() {
  ::bosdyn::api::PickObjectRayInWorld* _msg = _internal_mutable_pick_object_ray_in_world();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ManipulationApiRequest.pick_object_ray_in_world)
  return _msg;
}

// .bosdyn.api.PickObjectExecutePlan pick_object_execute_plan = 14;
inline bool ManipulationApiRequest::_internal_has_pick_object_execute_plan() const {
  return manipulation_cmd_case() == kPickObjectExecutePlan;
}
inline bool ManipulationApiRequest::has_pick_object_execute_plan() const {
  return _internal_has_pick_object_execute_plan();
}
inline void ManipulationApiRequest::set_has_pick_object_execute_plan() {
  _impl_._oneof_case_[0] = kPickObjectExecutePlan;
}
inline void ManipulationApiRequest::clear_pick_object_execute_plan() {
  if (_internal_has_pick_object_execute_plan()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.manipulation_cmd_.pick_object_execute_plan_;
    }
    clear_has_manipulation_cmd();
  }
}
inline ::bosdyn::api::PickObjectExecutePlan* ManipulationApiRequest::release_pick_object_execute_plan() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ManipulationApiRequest.pick_object_execute_plan)
  if (_internal_has_pick_object_execute_plan()) {
    clear_has_manipulation_cmd();
    ::bosdyn::api::PickObjectExecutePlan* temp = _impl_.manipulation_cmd_.pick_object_execute_plan_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.manipulation_cmd_.pick_object_execute_plan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::PickObjectExecutePlan& ManipulationApiRequest::_internal_pick_object_execute_plan() const {
  return _internal_has_pick_object_execute_plan()
      ? *_impl_.manipulation_cmd_.pick_object_execute_plan_
      : reinterpret_cast< ::bosdyn::api::PickObjectExecutePlan&>(::bosdyn::api::_PickObjectExecutePlan_default_instance_);
}
inline const ::bosdyn::api::PickObjectExecutePlan& ManipulationApiRequest::pick_object_execute_plan() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulationApiRequest.pick_object_execute_plan)
  return _internal_pick_object_execute_plan();
}
inline ::bosdyn::api::PickObjectExecutePlan* ManipulationApiRequest::unsafe_arena_release_pick_object_execute_plan() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.ManipulationApiRequest.pick_object_execute_plan)
  if (_internal_has_pick_object_execute_plan()) {
    clear_has_manipulation_cmd();
    ::bosdyn::api::PickObjectExecutePlan* temp = _impl_.manipulation_cmd_.pick_object_execute_plan_;
    _impl_.manipulation_cmd_.pick_object_execute_plan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ManipulationApiRequest::unsafe_arena_set_allocated_pick_object_execute_plan(::bosdyn::api::PickObjectExecutePlan* pick_object_execute_plan) {
  clear_manipulation_cmd();
  if (pick_object_execute_plan) {
    set_has_pick_object_execute_plan();
    _impl_.manipulation_cmd_.pick_object_execute_plan_ = pick_object_execute_plan;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ManipulationApiRequest.pick_object_execute_plan)
}
inline ::bosdyn::api::PickObjectExecutePlan* ManipulationApiRequest::_internal_mutable_pick_object_execute_plan() {
  if (!_internal_has_pick_object_execute_plan()) {
    clear_manipulation_cmd();
    set_has_pick_object_execute_plan();
    _impl_.manipulation_cmd_.pick_object_execute_plan_ = CreateMaybeMessage< ::bosdyn::api::PickObjectExecutePlan >(GetArenaForAllocation());
  }
  return _impl_.manipulation_cmd_.pick_object_execute_plan_;
}
inline ::bosdyn::api::PickObjectExecutePlan* ManipulationApiRequest::mutable_pick_object_execute_plan() {
  ::bosdyn::api::PickObjectExecutePlan* _msg = _internal_mutable_pick_object_execute_plan();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ManipulationApiRequest.pick_object_execute_plan)
  return _msg;
}

inline bool ManipulationApiRequest::has_manipulation_cmd() const {
  return manipulation_cmd_case() != MANIPULATION_CMD_NOT_SET;
}
inline void ManipulationApiRequest::clear_has_manipulation_cmd() {
  _impl_._oneof_case_[0] = MANIPULATION_CMD_NOT_SET;
}
inline ManipulationApiRequest::ManipulationCmdCase ManipulationApiRequest::manipulation_cmd_case() const {
  return ManipulationApiRequest::ManipulationCmdCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ApiGraspOverride

// .bosdyn.api.ApiGraspOverride.Override override_request = 1;
inline void ApiGraspOverride::clear_override_request() {
  _impl_.override_request_ = 0;
}
inline ::bosdyn::api::ApiGraspOverride_Override ApiGraspOverride::_internal_override_request() const {
  return static_cast< ::bosdyn::api::ApiGraspOverride_Override >(_impl_.override_request_);
}
inline ::bosdyn::api::ApiGraspOverride_Override ApiGraspOverride::override_request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ApiGraspOverride.override_request)
  return _internal_override_request();
}
inline void ApiGraspOverride::_internal_set_override_request(::bosdyn::api::ApiGraspOverride_Override value) {
  
  _impl_.override_request_ = value;
}
inline void ApiGraspOverride::set_override_request(::bosdyn::api::ApiGraspOverride_Override value) {
  _internal_set_override_request(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ApiGraspOverride.override_request)
}

// -------------------------------------------------------------------

// ApiGraspedCarryStateOverride

// .bosdyn.api.ManipulatorState.CarryState override_request = 1;
inline void ApiGraspedCarryStateOverride::clear_override_request() {
  _impl_.override_request_ = 0;
}
inline ::bosdyn::api::ManipulatorState_CarryState ApiGraspedCarryStateOverride::_internal_override_request() const {
  return static_cast< ::bosdyn::api::ManipulatorState_CarryState >(_impl_.override_request_);
}
inline ::bosdyn::api::ManipulatorState_CarryState ApiGraspedCarryStateOverride::override_request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ApiGraspedCarryStateOverride.override_request)
  return _internal_override_request();
}
inline void ApiGraspedCarryStateOverride::_internal_set_override_request(::bosdyn::api::ManipulatorState_CarryState value) {
  
  _impl_.override_request_ = value;
}
inline void ApiGraspedCarryStateOverride::set_override_request(::bosdyn::api::ManipulatorState_CarryState value) {
  _internal_set_override_request(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ApiGraspedCarryStateOverride.override_request)
}

// -------------------------------------------------------------------

// ApiGraspOverrideRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ApiGraspOverrideRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ApiGraspOverrideRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ApiGraspOverrideRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ApiGraspOverrideRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ApiGraspOverrideRequest.header)
  return _internal_header();
}
inline void ApiGraspOverrideRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ApiGraspOverrideRequest.header)
}
inline ::bosdyn::api::RequestHeader* ApiGraspOverrideRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ApiGraspOverrideRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ApiGraspOverrideRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ApiGraspOverrideRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ApiGraspOverrideRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ApiGraspOverrideRequest.header)
  return _msg;
}
inline void ApiGraspOverrideRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ApiGraspOverrideRequest.header)
}

// .bosdyn.api.ApiGraspOverride api_grasp_override = 4;
inline bool ApiGraspOverrideRequest::_internal_has_api_grasp_override() const {
  return this != internal_default_instance() && _impl_.api_grasp_override_ != nullptr;
}
inline bool ApiGraspOverrideRequest::has_api_grasp_override() const {
  return _internal_has_api_grasp_override();
}
inline void ApiGraspOverrideRequest::clear_api_grasp_override() {
  if (GetArenaForAllocation() == nullptr && _impl_.api_grasp_override_ != nullptr) {
    delete _impl_.api_grasp_override_;
  }
  _impl_.api_grasp_override_ = nullptr;
}
inline const ::bosdyn::api::ApiGraspOverride& ApiGraspOverrideRequest::_internal_api_grasp_override() const {
  const ::bosdyn::api::ApiGraspOverride* p = _impl_.api_grasp_override_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ApiGraspOverride&>(
      ::bosdyn::api::_ApiGraspOverride_default_instance_);
}
inline const ::bosdyn::api::ApiGraspOverride& ApiGraspOverrideRequest::api_grasp_override() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ApiGraspOverrideRequest.api_grasp_override)
  return _internal_api_grasp_override();
}
inline void ApiGraspOverrideRequest::unsafe_arena_set_allocated_api_grasp_override(
    ::bosdyn::api::ApiGraspOverride* api_grasp_override) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.api_grasp_override_);
  }
  _impl_.api_grasp_override_ = api_grasp_override;
  if (api_grasp_override) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ApiGraspOverrideRequest.api_grasp_override)
}
inline ::bosdyn::api::ApiGraspOverride* ApiGraspOverrideRequest::release_api_grasp_override() {
  
  ::bosdyn::api::ApiGraspOverride* temp = _impl_.api_grasp_override_;
  _impl_.api_grasp_override_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ApiGraspOverride* ApiGraspOverrideRequest::unsafe_arena_release_api_grasp_override() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ApiGraspOverrideRequest.api_grasp_override)
  
  ::bosdyn::api::ApiGraspOverride* temp = _impl_.api_grasp_override_;
  _impl_.api_grasp_override_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ApiGraspOverride* ApiGraspOverrideRequest::_internal_mutable_api_grasp_override() {
  
  if (_impl_.api_grasp_override_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ApiGraspOverride>(GetArenaForAllocation());
    _impl_.api_grasp_override_ = p;
  }
  return _impl_.api_grasp_override_;
}
inline ::bosdyn::api::ApiGraspOverride* ApiGraspOverrideRequest::mutable_api_grasp_override() {
  ::bosdyn::api::ApiGraspOverride* _msg = _internal_mutable_api_grasp_override();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ApiGraspOverrideRequest.api_grasp_override)
  return _msg;
}
inline void ApiGraspOverrideRequest::set_allocated_api_grasp_override(::bosdyn::api::ApiGraspOverride* api_grasp_override) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.api_grasp_override_;
  }
  if (api_grasp_override) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(api_grasp_override);
    if (message_arena != submessage_arena) {
      api_grasp_override = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, api_grasp_override, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.api_grasp_override_ = api_grasp_override;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ApiGraspOverrideRequest.api_grasp_override)
}

// .bosdyn.api.ApiGraspedCarryStateOverride carry_state_override = 2;
inline bool ApiGraspOverrideRequest::_internal_has_carry_state_override() const {
  return this != internal_default_instance() && _impl_.carry_state_override_ != nullptr;
}
inline bool ApiGraspOverrideRequest::has_carry_state_override() const {
  return _internal_has_carry_state_override();
}
inline void ApiGraspOverrideRequest::clear_carry_state_override() {
  if (GetArenaForAllocation() == nullptr && _impl_.carry_state_override_ != nullptr) {
    delete _impl_.carry_state_override_;
  }
  _impl_.carry_state_override_ = nullptr;
}
inline const ::bosdyn::api::ApiGraspedCarryStateOverride& ApiGraspOverrideRequest::_internal_carry_state_override() const {
  const ::bosdyn::api::ApiGraspedCarryStateOverride* p = _impl_.carry_state_override_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ApiGraspedCarryStateOverride&>(
      ::bosdyn::api::_ApiGraspedCarryStateOverride_default_instance_);
}
inline const ::bosdyn::api::ApiGraspedCarryStateOverride& ApiGraspOverrideRequest::carry_state_override() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ApiGraspOverrideRequest.carry_state_override)
  return _internal_carry_state_override();
}
inline void ApiGraspOverrideRequest::unsafe_arena_set_allocated_carry_state_override(
    ::bosdyn::api::ApiGraspedCarryStateOverride* carry_state_override) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.carry_state_override_);
  }
  _impl_.carry_state_override_ = carry_state_override;
  if (carry_state_override) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ApiGraspOverrideRequest.carry_state_override)
}
inline ::bosdyn::api::ApiGraspedCarryStateOverride* ApiGraspOverrideRequest::release_carry_state_override() {
  
  ::bosdyn::api::ApiGraspedCarryStateOverride* temp = _impl_.carry_state_override_;
  _impl_.carry_state_override_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ApiGraspedCarryStateOverride* ApiGraspOverrideRequest::unsafe_arena_release_carry_state_override() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ApiGraspOverrideRequest.carry_state_override)
  
  ::bosdyn::api::ApiGraspedCarryStateOverride* temp = _impl_.carry_state_override_;
  _impl_.carry_state_override_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ApiGraspedCarryStateOverride* ApiGraspOverrideRequest::_internal_mutable_carry_state_override() {
  
  if (_impl_.carry_state_override_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ApiGraspedCarryStateOverride>(GetArenaForAllocation());
    _impl_.carry_state_override_ = p;
  }
  return _impl_.carry_state_override_;
}
inline ::bosdyn::api::ApiGraspedCarryStateOverride* ApiGraspOverrideRequest::mutable_carry_state_override() {
  ::bosdyn::api::ApiGraspedCarryStateOverride* _msg = _internal_mutable_carry_state_override();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ApiGraspOverrideRequest.carry_state_override)
  return _msg;
}
inline void ApiGraspOverrideRequest::set_allocated_carry_state_override(::bosdyn::api::ApiGraspedCarryStateOverride* carry_state_override) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.carry_state_override_;
  }
  if (carry_state_override) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(carry_state_override);
    if (message_arena != submessage_arena) {
      carry_state_override = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, carry_state_override, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.carry_state_override_ = carry_state_override;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ApiGraspOverrideRequest.carry_state_override)
}

// -------------------------------------------------------------------

// ApiGraspOverrideResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ApiGraspOverrideResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ApiGraspOverrideResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ApiGraspOverrideResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ApiGraspOverrideResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ApiGraspOverrideResponse.header)
  return _internal_header();
}
inline void ApiGraspOverrideResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ApiGraspOverrideResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ApiGraspOverrideResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ApiGraspOverrideResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ApiGraspOverrideResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ApiGraspOverrideResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ApiGraspOverrideResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ApiGraspOverrideResponse.header)
  return _msg;
}
inline void ApiGraspOverrideResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ApiGraspOverrideResponse.header)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::ApiGraspOverride_Override> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ApiGraspOverride_Override>() {
  return ::bosdyn::api::ApiGraspOverride_Override_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::GraspPositionConstraint> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::GraspPositionConstraint>() {
  return ::bosdyn::api::GraspPositionConstraint_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::ManipulationFeedbackState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ManipulationFeedbackState>() {
  return ::bosdyn::api::ManipulationFeedbackState_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::ManipulationCameraSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ManipulationCameraSource>() {
  return ::bosdyn::api::ManipulationCameraSource_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::WalkGazeMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::WalkGazeMode>() {
  return ::bosdyn::api::WalkGazeMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fmanipulation_5fapi_2eproto
