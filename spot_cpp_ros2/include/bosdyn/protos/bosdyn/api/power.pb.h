// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/power.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fpower_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fpower_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/lease.pb.h"
#include "bosdyn/api/license.pb.h"
#include "bosdyn/api/robot_state.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fpower_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fpower_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fpower_2eproto;
namespace bosdyn {
namespace api {
class FanPowerCommandFeedbackRequest;
struct FanPowerCommandFeedbackRequestDefaultTypeInternal;
extern FanPowerCommandFeedbackRequestDefaultTypeInternal _FanPowerCommandFeedbackRequest_default_instance_;
class FanPowerCommandFeedbackResponse;
struct FanPowerCommandFeedbackResponseDefaultTypeInternal;
extern FanPowerCommandFeedbackResponseDefaultTypeInternal _FanPowerCommandFeedbackResponse_default_instance_;
class FanPowerCommandRequest;
struct FanPowerCommandRequestDefaultTypeInternal;
extern FanPowerCommandRequestDefaultTypeInternal _FanPowerCommandRequest_default_instance_;
class FanPowerCommandResponse;
struct FanPowerCommandResponseDefaultTypeInternal;
extern FanPowerCommandResponseDefaultTypeInternal _FanPowerCommandResponse_default_instance_;
class PowerCommandFeedbackRequest;
struct PowerCommandFeedbackRequestDefaultTypeInternal;
extern PowerCommandFeedbackRequestDefaultTypeInternal _PowerCommandFeedbackRequest_default_instance_;
class PowerCommandFeedbackResponse;
struct PowerCommandFeedbackResponseDefaultTypeInternal;
extern PowerCommandFeedbackResponseDefaultTypeInternal _PowerCommandFeedbackResponse_default_instance_;
class PowerCommandRequest;
struct PowerCommandRequestDefaultTypeInternal;
extern PowerCommandRequestDefaultTypeInternal _PowerCommandRequest_default_instance_;
class PowerCommandResponse;
struct PowerCommandResponseDefaultTypeInternal;
extern PowerCommandResponseDefaultTypeInternal _PowerCommandResponse_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::FanPowerCommandFeedbackRequest* Arena::CreateMaybeMessage<::bosdyn::api::FanPowerCommandFeedbackRequest>(Arena*);
template<> ::bosdyn::api::FanPowerCommandFeedbackResponse* Arena::CreateMaybeMessage<::bosdyn::api::FanPowerCommandFeedbackResponse>(Arena*);
template<> ::bosdyn::api::FanPowerCommandRequest* Arena::CreateMaybeMessage<::bosdyn::api::FanPowerCommandRequest>(Arena*);
template<> ::bosdyn::api::FanPowerCommandResponse* Arena::CreateMaybeMessage<::bosdyn::api::FanPowerCommandResponse>(Arena*);
template<> ::bosdyn::api::PowerCommandFeedbackRequest* Arena::CreateMaybeMessage<::bosdyn::api::PowerCommandFeedbackRequest>(Arena*);
template<> ::bosdyn::api::PowerCommandFeedbackResponse* Arena::CreateMaybeMessage<::bosdyn::api::PowerCommandFeedbackResponse>(Arena*);
template<> ::bosdyn::api::PowerCommandRequest* Arena::CreateMaybeMessage<::bosdyn::api::PowerCommandRequest>(Arena*);
template<> ::bosdyn::api::PowerCommandResponse* Arena::CreateMaybeMessage<::bosdyn::api::PowerCommandResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum PowerCommandRequest_Request : int {
  PowerCommandRequest_Request_REQUEST_UNKNOWN = 0,
  PowerCommandRequest_Request_REQUEST_OFF PROTOBUF_DEPRECATED_ENUM = 1,
  PowerCommandRequest_Request_REQUEST_ON PROTOBUF_DEPRECATED_ENUM = 2,
  PowerCommandRequest_Request_REQUEST_OFF_MOTORS = 1,
  PowerCommandRequest_Request_REQUEST_ON_MOTORS = 2,
  PowerCommandRequest_Request_REQUEST_OFF_ROBOT = 3,
  PowerCommandRequest_Request_REQUEST_CYCLE_ROBOT = 4,
  PowerCommandRequest_Request_REQUEST_OFF_PAYLOAD_PORTS = 5,
  PowerCommandRequest_Request_REQUEST_ON_PAYLOAD_PORTS = 6,
  PowerCommandRequest_Request_REQUEST_OFF_WIFI_RADIO = 7,
  PowerCommandRequest_Request_REQUEST_ON_WIFI_RADIO = 8,
  PowerCommandRequest_Request_PowerCommandRequest_Request_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PowerCommandRequest_Request_PowerCommandRequest_Request_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PowerCommandRequest_Request_IsValid(int value);
constexpr PowerCommandRequest_Request PowerCommandRequest_Request_Request_MIN = PowerCommandRequest_Request_REQUEST_UNKNOWN;
constexpr PowerCommandRequest_Request PowerCommandRequest_Request_Request_MAX = PowerCommandRequest_Request_REQUEST_ON_WIFI_RADIO;
constexpr int PowerCommandRequest_Request_Request_ARRAYSIZE = PowerCommandRequest_Request_Request_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PowerCommandRequest_Request_descriptor();
template<typename T>
inline const std::string& PowerCommandRequest_Request_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerCommandRequest_Request>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerCommandRequest_Request_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PowerCommandRequest_Request_descriptor(), enum_t_value);
}
inline bool PowerCommandRequest_Request_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerCommandRequest_Request* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PowerCommandRequest_Request>(
    PowerCommandRequest_Request_descriptor(), name, value);
}
enum FanPowerCommandResponse_Status : int {
  FanPowerCommandResponse_Status_STATUS_UNKNOWN = 0,
  FanPowerCommandResponse_Status_STATUS_OK = 1,
  FanPowerCommandResponse_Status_STATUS_TEMPERATURE_TOO_HIGH = 2,
  FanPowerCommandResponse_Status_FanPowerCommandResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FanPowerCommandResponse_Status_FanPowerCommandResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FanPowerCommandResponse_Status_IsValid(int value);
constexpr FanPowerCommandResponse_Status FanPowerCommandResponse_Status_Status_MIN = FanPowerCommandResponse_Status_STATUS_UNKNOWN;
constexpr FanPowerCommandResponse_Status FanPowerCommandResponse_Status_Status_MAX = FanPowerCommandResponse_Status_STATUS_TEMPERATURE_TOO_HIGH;
constexpr int FanPowerCommandResponse_Status_Status_ARRAYSIZE = FanPowerCommandResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FanPowerCommandResponse_Status_descriptor();
template<typename T>
inline const std::string& FanPowerCommandResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FanPowerCommandResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FanPowerCommandResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FanPowerCommandResponse_Status_descriptor(), enum_t_value);
}
inline bool FanPowerCommandResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FanPowerCommandResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FanPowerCommandResponse_Status>(
    FanPowerCommandResponse_Status_descriptor(), name, value);
}
enum FanPowerCommandFeedbackResponse_Status : int {
  FanPowerCommandFeedbackResponse_Status_STATUS_UNKNOWN = 0,
  FanPowerCommandFeedbackResponse_Status_STATUS_COMPLETE = 1,
  FanPowerCommandFeedbackResponse_Status_STATUS_RUNNING = 2,
  FanPowerCommandFeedbackResponse_Status_STATUS_TEMPERATURE_STOP = 3,
  FanPowerCommandFeedbackResponse_Status_STATUS_OVERRIDDEN_BY_COMMAND = 4,
  FanPowerCommandFeedbackResponse_Status_FanPowerCommandFeedbackResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FanPowerCommandFeedbackResponse_Status_FanPowerCommandFeedbackResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FanPowerCommandFeedbackResponse_Status_IsValid(int value);
constexpr FanPowerCommandFeedbackResponse_Status FanPowerCommandFeedbackResponse_Status_Status_MIN = FanPowerCommandFeedbackResponse_Status_STATUS_UNKNOWN;
constexpr FanPowerCommandFeedbackResponse_Status FanPowerCommandFeedbackResponse_Status_Status_MAX = FanPowerCommandFeedbackResponse_Status_STATUS_OVERRIDDEN_BY_COMMAND;
constexpr int FanPowerCommandFeedbackResponse_Status_Status_ARRAYSIZE = FanPowerCommandFeedbackResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FanPowerCommandFeedbackResponse_Status_descriptor();
template<typename T>
inline const std::string& FanPowerCommandFeedbackResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FanPowerCommandFeedbackResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FanPowerCommandFeedbackResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FanPowerCommandFeedbackResponse_Status_descriptor(), enum_t_value);
}
inline bool FanPowerCommandFeedbackResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FanPowerCommandFeedbackResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FanPowerCommandFeedbackResponse_Status>(
    FanPowerCommandFeedbackResponse_Status_descriptor(), name, value);
}
enum PowerCommandStatus : int {
  STATUS_UNKNOWN = 0,
  STATUS_IN_PROGRESS = 1,
  STATUS_SUCCESS = 2,
  STATUS_SHORE_POWER_CONNECTED = 3,
  STATUS_BATTERY_MISSING = 4,
  STATUS_COMMAND_IN_PROGRESS = 5,
  STATUS_ESTOPPED = 6,
  STATUS_FAULTED = 7,
  STATUS_INTERNAL_ERROR = 8,
  STATUS_LICENSE_ERROR = 9,
  INCOMPATIBLE_HARDWARE_ERROR = 10,
  STATUS_OVERRIDDEN = 11,
  PowerCommandStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PowerCommandStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PowerCommandStatus_IsValid(int value);
constexpr PowerCommandStatus PowerCommandStatus_MIN = STATUS_UNKNOWN;
constexpr PowerCommandStatus PowerCommandStatus_MAX = STATUS_OVERRIDDEN;
constexpr int PowerCommandStatus_ARRAYSIZE = PowerCommandStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PowerCommandStatus_descriptor();
template<typename T>
inline const std::string& PowerCommandStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerCommandStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerCommandStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PowerCommandStatus_descriptor(), enum_t_value);
}
inline bool PowerCommandStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerCommandStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PowerCommandStatus>(
    PowerCommandStatus_descriptor(), name, value);
}
// ===================================================================

class PowerCommandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PowerCommandRequest) */ {
 public:
  inline PowerCommandRequest() : PowerCommandRequest(nullptr) {}
  ~PowerCommandRequest() override;
  explicit PROTOBUF_CONSTEXPR PowerCommandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PowerCommandRequest(const PowerCommandRequest& from);
  PowerCommandRequest(PowerCommandRequest&& from) noexcept
    : PowerCommandRequest() {
    *this = ::std::move(from);
  }

  inline PowerCommandRequest& operator=(const PowerCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PowerCommandRequest& operator=(PowerCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PowerCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PowerCommandRequest* internal_default_instance() {
    return reinterpret_cast<const PowerCommandRequest*>(
               &_PowerCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PowerCommandRequest& a, PowerCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PowerCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PowerCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PowerCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PowerCommandRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PowerCommandRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PowerCommandRequest& from) {
    PowerCommandRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PowerCommandRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PowerCommandRequest";
  }
  protected:
  explicit PowerCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PowerCommandRequest_Request Request;
  static constexpr Request REQUEST_UNKNOWN =
    PowerCommandRequest_Request_REQUEST_UNKNOWN;
  PROTOBUF_DEPRECATED_ENUM static constexpr Request REQUEST_OFF =
    PowerCommandRequest_Request_REQUEST_OFF;
  PROTOBUF_DEPRECATED_ENUM static constexpr Request REQUEST_ON =
    PowerCommandRequest_Request_REQUEST_ON;
  static constexpr Request REQUEST_OFF_MOTORS =
    PowerCommandRequest_Request_REQUEST_OFF_MOTORS;
  static constexpr Request REQUEST_ON_MOTORS =
    PowerCommandRequest_Request_REQUEST_ON_MOTORS;
  static constexpr Request REQUEST_OFF_ROBOT =
    PowerCommandRequest_Request_REQUEST_OFF_ROBOT;
  static constexpr Request REQUEST_CYCLE_ROBOT =
    PowerCommandRequest_Request_REQUEST_CYCLE_ROBOT;
  static constexpr Request REQUEST_OFF_PAYLOAD_PORTS =
    PowerCommandRequest_Request_REQUEST_OFF_PAYLOAD_PORTS;
  static constexpr Request REQUEST_ON_PAYLOAD_PORTS =
    PowerCommandRequest_Request_REQUEST_ON_PAYLOAD_PORTS;
  static constexpr Request REQUEST_OFF_WIFI_RADIO =
    PowerCommandRequest_Request_REQUEST_OFF_WIFI_RADIO;
  static constexpr Request REQUEST_ON_WIFI_RADIO =
    PowerCommandRequest_Request_REQUEST_ON_WIFI_RADIO;
  static inline bool Request_IsValid(int value) {
    return PowerCommandRequest_Request_IsValid(value);
  }
  static constexpr Request Request_MIN =
    PowerCommandRequest_Request_Request_MIN;
  static constexpr Request Request_MAX =
    PowerCommandRequest_Request_Request_MAX;
  static constexpr int Request_ARRAYSIZE =
    PowerCommandRequest_Request_Request_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Request_descriptor() {
    return PowerCommandRequest_Request_descriptor();
  }
  template<typename T>
  static inline const std::string& Request_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Request>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Request_Name.");
    return PowerCommandRequest_Request_Name(enum_t_value);
  }
  static inline bool Request_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Request* value) {
    return PowerCommandRequest_Request_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 2,
    kRequestFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // .bosdyn.api.PowerCommandRequest.Request request = 3;
  void clear_request();
  ::bosdyn::api::PowerCommandRequest_Request request() const;
  void set_request(::bosdyn::api::PowerCommandRequest_Request value);
  private:
  ::bosdyn::api::PowerCommandRequest_Request _internal_request() const;
  void _internal_set_request(::bosdyn::api::PowerCommandRequest_Request value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.PowerCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::Lease* lease_;
    int request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fpower_2eproto;
};
// -------------------------------------------------------------------

class PowerCommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PowerCommandResponse) */ {
 public:
  inline PowerCommandResponse() : PowerCommandResponse(nullptr) {}
  ~PowerCommandResponse() override;
  explicit PROTOBUF_CONSTEXPR PowerCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PowerCommandResponse(const PowerCommandResponse& from);
  PowerCommandResponse(PowerCommandResponse&& from) noexcept
    : PowerCommandResponse() {
    *this = ::std::move(from);
  }

  inline PowerCommandResponse& operator=(const PowerCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PowerCommandResponse& operator=(PowerCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PowerCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PowerCommandResponse* internal_default_instance() {
    return reinterpret_cast<const PowerCommandResponse*>(
               &_PowerCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PowerCommandResponse& a, PowerCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PowerCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PowerCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PowerCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PowerCommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PowerCommandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PowerCommandResponse& from) {
    PowerCommandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PowerCommandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PowerCommandResponse";
  }
  protected:
  explicit PowerCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockingFaultsFieldNumber = 6,
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
    kStatusFieldNumber = 3,
    kPowerCommandIdFieldNumber = 4,
    kLicenseStatusFieldNumber = 5,
  };
  // repeated .bosdyn.api.SystemFault blocking_faults = 6;
  int blocking_faults_size() const;
  private:
  int _internal_blocking_faults_size() const;
  public:
  void clear_blocking_faults();
  ::bosdyn::api::SystemFault* mutable_blocking_faults(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >*
      mutable_blocking_faults();
  private:
  const ::bosdyn::api::SystemFault& _internal_blocking_faults(int index) const;
  ::bosdyn::api::SystemFault* _internal_add_blocking_faults();
  public:
  const ::bosdyn::api::SystemFault& blocking_faults(int index) const;
  ::bosdyn::api::SystemFault* add_blocking_faults();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >&
      blocking_faults() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  PROTOBUF_NODISCARD ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // .bosdyn.api.PowerCommandStatus status = 3;
  void clear_status();
  ::bosdyn::api::PowerCommandStatus status() const;
  void set_status(::bosdyn::api::PowerCommandStatus value);
  private:
  ::bosdyn::api::PowerCommandStatus _internal_status() const;
  void _internal_set_status(::bosdyn::api::PowerCommandStatus value);
  public:

  // uint32 power_command_id = 4;
  void clear_power_command_id();
  uint32_t power_command_id() const;
  void set_power_command_id(uint32_t value);
  private:
  uint32_t _internal_power_command_id() const;
  void _internal_set_power_command_id(uint32_t value);
  public:

  // .bosdyn.api.LicenseInfo.Status license_status = 5;
  void clear_license_status();
  ::bosdyn::api::LicenseInfo_Status license_status() const;
  void set_license_status(::bosdyn::api::LicenseInfo_Status value);
  private:
  ::bosdyn::api::LicenseInfo_Status _internal_license_status() const;
  void _internal_set_license_status(::bosdyn::api::LicenseInfo_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.PowerCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault > blocking_faults_;
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::LeaseUseResult* lease_use_result_;
    int status_;
    uint32_t power_command_id_;
    int license_status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fpower_2eproto;
};
// -------------------------------------------------------------------

class PowerCommandFeedbackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PowerCommandFeedbackRequest) */ {
 public:
  inline PowerCommandFeedbackRequest() : PowerCommandFeedbackRequest(nullptr) {}
  ~PowerCommandFeedbackRequest() override;
  explicit PROTOBUF_CONSTEXPR PowerCommandFeedbackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PowerCommandFeedbackRequest(const PowerCommandFeedbackRequest& from);
  PowerCommandFeedbackRequest(PowerCommandFeedbackRequest&& from) noexcept
    : PowerCommandFeedbackRequest() {
    *this = ::std::move(from);
  }

  inline PowerCommandFeedbackRequest& operator=(const PowerCommandFeedbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PowerCommandFeedbackRequest& operator=(PowerCommandFeedbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PowerCommandFeedbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PowerCommandFeedbackRequest* internal_default_instance() {
    return reinterpret_cast<const PowerCommandFeedbackRequest*>(
               &_PowerCommandFeedbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PowerCommandFeedbackRequest& a, PowerCommandFeedbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PowerCommandFeedbackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PowerCommandFeedbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PowerCommandFeedbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PowerCommandFeedbackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PowerCommandFeedbackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PowerCommandFeedbackRequest& from) {
    PowerCommandFeedbackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PowerCommandFeedbackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PowerCommandFeedbackRequest";
  }
  protected:
  explicit PowerCommandFeedbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPowerCommandIdFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // uint32 power_command_id = 2;
  void clear_power_command_id();
  uint32_t power_command_id() const;
  void set_power_command_id(uint32_t value);
  private:
  uint32_t _internal_power_command_id() const;
  void _internal_set_power_command_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.PowerCommandFeedbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    uint32_t power_command_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fpower_2eproto;
};
// -------------------------------------------------------------------

class PowerCommandFeedbackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PowerCommandFeedbackResponse) */ {
 public:
  inline PowerCommandFeedbackResponse() : PowerCommandFeedbackResponse(nullptr) {}
  ~PowerCommandFeedbackResponse() override;
  explicit PROTOBUF_CONSTEXPR PowerCommandFeedbackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PowerCommandFeedbackResponse(const PowerCommandFeedbackResponse& from);
  PowerCommandFeedbackResponse(PowerCommandFeedbackResponse&& from) noexcept
    : PowerCommandFeedbackResponse() {
    *this = ::std::move(from);
  }

  inline PowerCommandFeedbackResponse& operator=(const PowerCommandFeedbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PowerCommandFeedbackResponse& operator=(PowerCommandFeedbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PowerCommandFeedbackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PowerCommandFeedbackResponse* internal_default_instance() {
    return reinterpret_cast<const PowerCommandFeedbackResponse*>(
               &_PowerCommandFeedbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PowerCommandFeedbackResponse& a, PowerCommandFeedbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PowerCommandFeedbackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PowerCommandFeedbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PowerCommandFeedbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PowerCommandFeedbackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PowerCommandFeedbackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PowerCommandFeedbackResponse& from) {
    PowerCommandFeedbackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PowerCommandFeedbackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PowerCommandFeedbackResponse";
  }
  protected:
  explicit PowerCommandFeedbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockingFaultsFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated .bosdyn.api.SystemFault blocking_faults = 3;
  int blocking_faults_size() const;
  private:
  int _internal_blocking_faults_size() const;
  public:
  void clear_blocking_faults();
  ::bosdyn::api::SystemFault* mutable_blocking_faults(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >*
      mutable_blocking_faults();
  private:
  const ::bosdyn::api::SystemFault& _internal_blocking_faults(int index) const;
  ::bosdyn::api::SystemFault* _internal_add_blocking_faults();
  public:
  const ::bosdyn::api::SystemFault& blocking_faults(int index) const;
  ::bosdyn::api::SystemFault* add_blocking_faults();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >&
      blocking_faults() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.PowerCommandStatus status = 2;
  void clear_status();
  ::bosdyn::api::PowerCommandStatus status() const;
  void set_status(::bosdyn::api::PowerCommandStatus value);
  private:
  ::bosdyn::api::PowerCommandStatus _internal_status() const;
  void _internal_set_status(::bosdyn::api::PowerCommandStatus value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.PowerCommandFeedbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault > blocking_faults_;
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fpower_2eproto;
};
// -------------------------------------------------------------------

class FanPowerCommandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.FanPowerCommandRequest) */ {
 public:
  inline FanPowerCommandRequest() : FanPowerCommandRequest(nullptr) {}
  ~FanPowerCommandRequest() override;
  explicit PROTOBUF_CONSTEXPR FanPowerCommandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FanPowerCommandRequest(const FanPowerCommandRequest& from);
  FanPowerCommandRequest(FanPowerCommandRequest&& from) noexcept
    : FanPowerCommandRequest() {
    *this = ::std::move(from);
  }

  inline FanPowerCommandRequest& operator=(const FanPowerCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FanPowerCommandRequest& operator=(FanPowerCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FanPowerCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FanPowerCommandRequest* internal_default_instance() {
    return reinterpret_cast<const FanPowerCommandRequest*>(
               &_FanPowerCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FanPowerCommandRequest& a, FanPowerCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FanPowerCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FanPowerCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FanPowerCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FanPowerCommandRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FanPowerCommandRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FanPowerCommandRequest& from) {
    FanPowerCommandRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FanPowerCommandRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FanPowerCommandRequest";
  }
  protected:
  explicit FanPowerCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 2,
    kDurationFieldNumber = 4,
    kPercentPowerFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // .google.protobuf.Duration duration = 4;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_duration();
  void set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_duration();

  // int32 percent_power = 3;
  void clear_percent_power();
  int32_t percent_power() const;
  void set_percent_power(int32_t value);
  private:
  int32_t _internal_percent_power() const;
  void _internal_set_percent_power(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.FanPowerCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::Lease* lease_;
    ::PROTOBUF_NAMESPACE_ID::Duration* duration_;
    int32_t percent_power_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fpower_2eproto;
};
// -------------------------------------------------------------------

class FanPowerCommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.FanPowerCommandResponse) */ {
 public:
  inline FanPowerCommandResponse() : FanPowerCommandResponse(nullptr) {}
  ~FanPowerCommandResponse() override;
  explicit PROTOBUF_CONSTEXPR FanPowerCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FanPowerCommandResponse(const FanPowerCommandResponse& from);
  FanPowerCommandResponse(FanPowerCommandResponse&& from) noexcept
    : FanPowerCommandResponse() {
    *this = ::std::move(from);
  }

  inline FanPowerCommandResponse& operator=(const FanPowerCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FanPowerCommandResponse& operator=(FanPowerCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FanPowerCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FanPowerCommandResponse* internal_default_instance() {
    return reinterpret_cast<const FanPowerCommandResponse*>(
               &_FanPowerCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FanPowerCommandResponse& a, FanPowerCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FanPowerCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FanPowerCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FanPowerCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FanPowerCommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FanPowerCommandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FanPowerCommandResponse& from) {
    FanPowerCommandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FanPowerCommandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FanPowerCommandResponse";
  }
  protected:
  explicit FanPowerCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FanPowerCommandResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    FanPowerCommandResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    FanPowerCommandResponse_Status_STATUS_OK;
  static constexpr Status STATUS_TEMPERATURE_TOO_HIGH =
    FanPowerCommandResponse_Status_STATUS_TEMPERATURE_TOO_HIGH;
  static inline bool Status_IsValid(int value) {
    return FanPowerCommandResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    FanPowerCommandResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    FanPowerCommandResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    FanPowerCommandResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return FanPowerCommandResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return FanPowerCommandResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return FanPowerCommandResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
    kDesiredEndTimeFieldNumber = 4,
    kStatusFieldNumber = 3,
    kCommandIdFieldNumber = 5,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  PROTOBUF_NODISCARD ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // .google.protobuf.Timestamp desired_end_time = 4;
  bool has_desired_end_time() const;
  private:
  bool _internal_has_desired_end_time() const;
  public:
  void clear_desired_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& desired_end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_desired_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_desired_end_time();
  void set_allocated_desired_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* desired_end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_desired_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_desired_end_time();
  public:
  void unsafe_arena_set_allocated_desired_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* desired_end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_desired_end_time();

  // .bosdyn.api.FanPowerCommandResponse.Status status = 3;
  void clear_status();
  ::bosdyn::api::FanPowerCommandResponse_Status status() const;
  void set_status(::bosdyn::api::FanPowerCommandResponse_Status value);
  private:
  ::bosdyn::api::FanPowerCommandResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::FanPowerCommandResponse_Status value);
  public:

  // uint32 command_id = 5;
  void clear_command_id();
  uint32_t command_id() const;
  void set_command_id(uint32_t value);
  private:
  uint32_t _internal_command_id() const;
  void _internal_set_command_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.FanPowerCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::LeaseUseResult* lease_use_result_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* desired_end_time_;
    int status_;
    uint32_t command_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fpower_2eproto;
};
// -------------------------------------------------------------------

class FanPowerCommandFeedbackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.FanPowerCommandFeedbackRequest) */ {
 public:
  inline FanPowerCommandFeedbackRequest() : FanPowerCommandFeedbackRequest(nullptr) {}
  ~FanPowerCommandFeedbackRequest() override;
  explicit PROTOBUF_CONSTEXPR FanPowerCommandFeedbackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FanPowerCommandFeedbackRequest(const FanPowerCommandFeedbackRequest& from);
  FanPowerCommandFeedbackRequest(FanPowerCommandFeedbackRequest&& from) noexcept
    : FanPowerCommandFeedbackRequest() {
    *this = ::std::move(from);
  }

  inline FanPowerCommandFeedbackRequest& operator=(const FanPowerCommandFeedbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FanPowerCommandFeedbackRequest& operator=(FanPowerCommandFeedbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FanPowerCommandFeedbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FanPowerCommandFeedbackRequest* internal_default_instance() {
    return reinterpret_cast<const FanPowerCommandFeedbackRequest*>(
               &_FanPowerCommandFeedbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FanPowerCommandFeedbackRequest& a, FanPowerCommandFeedbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FanPowerCommandFeedbackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FanPowerCommandFeedbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FanPowerCommandFeedbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FanPowerCommandFeedbackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FanPowerCommandFeedbackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FanPowerCommandFeedbackRequest& from) {
    FanPowerCommandFeedbackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FanPowerCommandFeedbackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FanPowerCommandFeedbackRequest";
  }
  protected:
  explicit FanPowerCommandFeedbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kCommandIdFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // uint32 command_id = 2;
  void clear_command_id();
  uint32_t command_id() const;
  void set_command_id(uint32_t value);
  private:
  uint32_t _internal_command_id() const;
  void _internal_set_command_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.FanPowerCommandFeedbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    uint32_t command_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fpower_2eproto;
};
// -------------------------------------------------------------------

class FanPowerCommandFeedbackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.FanPowerCommandFeedbackResponse) */ {
 public:
  inline FanPowerCommandFeedbackResponse() : FanPowerCommandFeedbackResponse(nullptr) {}
  ~FanPowerCommandFeedbackResponse() override;
  explicit PROTOBUF_CONSTEXPR FanPowerCommandFeedbackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FanPowerCommandFeedbackResponse(const FanPowerCommandFeedbackResponse& from);
  FanPowerCommandFeedbackResponse(FanPowerCommandFeedbackResponse&& from) noexcept
    : FanPowerCommandFeedbackResponse() {
    *this = ::std::move(from);
  }

  inline FanPowerCommandFeedbackResponse& operator=(const FanPowerCommandFeedbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FanPowerCommandFeedbackResponse& operator=(FanPowerCommandFeedbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FanPowerCommandFeedbackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FanPowerCommandFeedbackResponse* internal_default_instance() {
    return reinterpret_cast<const FanPowerCommandFeedbackResponse*>(
               &_FanPowerCommandFeedbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FanPowerCommandFeedbackResponse& a, FanPowerCommandFeedbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FanPowerCommandFeedbackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FanPowerCommandFeedbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FanPowerCommandFeedbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FanPowerCommandFeedbackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FanPowerCommandFeedbackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FanPowerCommandFeedbackResponse& from) {
    FanPowerCommandFeedbackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FanPowerCommandFeedbackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FanPowerCommandFeedbackResponse";
  }
  protected:
  explicit FanPowerCommandFeedbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FanPowerCommandFeedbackResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    FanPowerCommandFeedbackResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_COMPLETE =
    FanPowerCommandFeedbackResponse_Status_STATUS_COMPLETE;
  static constexpr Status STATUS_RUNNING =
    FanPowerCommandFeedbackResponse_Status_STATUS_RUNNING;
  static constexpr Status STATUS_TEMPERATURE_STOP =
    FanPowerCommandFeedbackResponse_Status_STATUS_TEMPERATURE_STOP;
  static constexpr Status STATUS_OVERRIDDEN_BY_COMMAND =
    FanPowerCommandFeedbackResponse_Status_STATUS_OVERRIDDEN_BY_COMMAND;
  static inline bool Status_IsValid(int value) {
    return FanPowerCommandFeedbackResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    FanPowerCommandFeedbackResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    FanPowerCommandFeedbackResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    FanPowerCommandFeedbackResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return FanPowerCommandFeedbackResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return FanPowerCommandFeedbackResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return FanPowerCommandFeedbackResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kDesiredEndTimeFieldNumber = 3,
    kEarlyStopTimeFieldNumber = 4,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .google.protobuf.Timestamp desired_end_time = 3;
  bool has_desired_end_time() const;
  private:
  bool _internal_has_desired_end_time() const;
  public:
  void clear_desired_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& desired_end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_desired_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_desired_end_time();
  void set_allocated_desired_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* desired_end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_desired_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_desired_end_time();
  public:
  void unsafe_arena_set_allocated_desired_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* desired_end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_desired_end_time();

  // .google.protobuf.Timestamp early_stop_time = 4;
  bool has_early_stop_time() const;
  private:
  bool _internal_has_early_stop_time() const;
  public:
  void clear_early_stop_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& early_stop_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_early_stop_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_early_stop_time();
  void set_allocated_early_stop_time(::PROTOBUF_NAMESPACE_ID::Timestamp* early_stop_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_early_stop_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_early_stop_time();
  public:
  void unsafe_arena_set_allocated_early_stop_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* early_stop_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_early_stop_time();

  // .bosdyn.api.FanPowerCommandFeedbackResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::FanPowerCommandFeedbackResponse_Status status() const;
  void set_status(::bosdyn::api::FanPowerCommandFeedbackResponse_Status value);
  private:
  ::bosdyn::api::FanPowerCommandFeedbackResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::FanPowerCommandFeedbackResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.FanPowerCommandFeedbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* desired_end_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* early_stop_time_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fpower_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PowerCommandRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool PowerCommandRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool PowerCommandRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& PowerCommandRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& PowerCommandRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerCommandRequest.header)
  return _internal_header();
}
inline void PowerCommandRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PowerCommandRequest.header)
}
inline ::bosdyn::api::RequestHeader* PowerCommandRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* PowerCommandRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PowerCommandRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* PowerCommandRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* PowerCommandRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PowerCommandRequest.header)
  return _msg;
}
inline void PowerCommandRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PowerCommandRequest.header)
}

// .bosdyn.api.Lease lease = 2;
inline bool PowerCommandRequest::_internal_has_lease() const {
  return this != internal_default_instance() && _impl_.lease_ != nullptr;
}
inline bool PowerCommandRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& PowerCommandRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = _impl_.lease_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Lease&>(
      ::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& PowerCommandRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerCommandRequest.lease)
  return _internal_lease();
}
inline void PowerCommandRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  _impl_.lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PowerCommandRequest.lease)
}
inline ::bosdyn::api::Lease* PowerCommandRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Lease* PowerCommandRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PowerCommandRequest.lease)
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* PowerCommandRequest::_internal_mutable_lease() {
  
  if (_impl_.lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArenaForAllocation());
    _impl_.lease_ = p;
  }
  return _impl_.lease_;
}
inline ::bosdyn::api::Lease* PowerCommandRequest::mutable_lease() {
  ::bosdyn::api::Lease* _msg = _internal_mutable_lease();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PowerCommandRequest.lease)
  return _msg;
}
inline void PowerCommandRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease));
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PowerCommandRequest.lease)
}

// .bosdyn.api.PowerCommandRequest.Request request = 3;
inline void PowerCommandRequest::clear_request() {
  _impl_.request_ = 0;
}
inline ::bosdyn::api::PowerCommandRequest_Request PowerCommandRequest::_internal_request() const {
  return static_cast< ::bosdyn::api::PowerCommandRequest_Request >(_impl_.request_);
}
inline ::bosdyn::api::PowerCommandRequest_Request PowerCommandRequest::request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerCommandRequest.request)
  return _internal_request();
}
inline void PowerCommandRequest::_internal_set_request(::bosdyn::api::PowerCommandRequest_Request value) {
  
  _impl_.request_ = value;
}
inline void PowerCommandRequest::set_request(::bosdyn::api::PowerCommandRequest_Request value) {
  _internal_set_request(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PowerCommandRequest.request)
}

// -------------------------------------------------------------------

// PowerCommandResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool PowerCommandResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool PowerCommandResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& PowerCommandResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& PowerCommandResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerCommandResponse.header)
  return _internal_header();
}
inline void PowerCommandResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PowerCommandResponse.header)
}
inline ::bosdyn::api::ResponseHeader* PowerCommandResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* PowerCommandResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PowerCommandResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* PowerCommandResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* PowerCommandResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PowerCommandResponse.header)
  return _msg;
}
inline void PowerCommandResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PowerCommandResponse.header)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool PowerCommandResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && _impl_.lease_use_result_ != nullptr;
}
inline bool PowerCommandResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& PowerCommandResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = _impl_.lease_use_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::LeaseUseResult&>(
      ::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& PowerCommandResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerCommandResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void PowerCommandResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  _impl_.lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PowerCommandResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* PowerCommandResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* PowerCommandResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PowerCommandResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* PowerCommandResponse::_internal_mutable_lease_use_result() {
  
  if (_impl_.lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArenaForAllocation());
    _impl_.lease_use_result_ = p;
  }
  return _impl_.lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* PowerCommandResponse::mutable_lease_use_result() {
  ::bosdyn::api::LeaseUseResult* _msg = _internal_mutable_lease_use_result();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PowerCommandResponse.lease_use_result)
  return _msg;
}
inline void PowerCommandResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result));
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PowerCommandResponse.lease_use_result)
}

// .bosdyn.api.PowerCommandStatus status = 3;
inline void PowerCommandResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::PowerCommandStatus PowerCommandResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::PowerCommandStatus >(_impl_.status_);
}
inline ::bosdyn::api::PowerCommandStatus PowerCommandResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerCommandResponse.status)
  return _internal_status();
}
inline void PowerCommandResponse::_internal_set_status(::bosdyn::api::PowerCommandStatus value) {
  
  _impl_.status_ = value;
}
inline void PowerCommandResponse::set_status(::bosdyn::api::PowerCommandStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PowerCommandResponse.status)
}

// uint32 power_command_id = 4;
inline void PowerCommandResponse::clear_power_command_id() {
  _impl_.power_command_id_ = 0u;
}
inline uint32_t PowerCommandResponse::_internal_power_command_id() const {
  return _impl_.power_command_id_;
}
inline uint32_t PowerCommandResponse::power_command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerCommandResponse.power_command_id)
  return _internal_power_command_id();
}
inline void PowerCommandResponse::_internal_set_power_command_id(uint32_t value) {
  
  _impl_.power_command_id_ = value;
}
inline void PowerCommandResponse::set_power_command_id(uint32_t value) {
  _internal_set_power_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PowerCommandResponse.power_command_id)
}

// .bosdyn.api.LicenseInfo.Status license_status = 5;
inline void PowerCommandResponse::clear_license_status() {
  _impl_.license_status_ = 0;
}
inline ::bosdyn::api::LicenseInfo_Status PowerCommandResponse::_internal_license_status() const {
  return static_cast< ::bosdyn::api::LicenseInfo_Status >(_impl_.license_status_);
}
inline ::bosdyn::api::LicenseInfo_Status PowerCommandResponse::license_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerCommandResponse.license_status)
  return _internal_license_status();
}
inline void PowerCommandResponse::_internal_set_license_status(::bosdyn::api::LicenseInfo_Status value) {
  
  _impl_.license_status_ = value;
}
inline void PowerCommandResponse::set_license_status(::bosdyn::api::LicenseInfo_Status value) {
  _internal_set_license_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PowerCommandResponse.license_status)
}

// repeated .bosdyn.api.SystemFault blocking_faults = 6;
inline int PowerCommandResponse::_internal_blocking_faults_size() const {
  return _impl_.blocking_faults_.size();
}
inline int PowerCommandResponse::blocking_faults_size() const {
  return _internal_blocking_faults_size();
}
inline ::bosdyn::api::SystemFault* PowerCommandResponse::mutable_blocking_faults(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PowerCommandResponse.blocking_faults)
  return _impl_.blocking_faults_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >*
PowerCommandResponse::mutable_blocking_faults() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.PowerCommandResponse.blocking_faults)
  return &_impl_.blocking_faults_;
}
inline const ::bosdyn::api::SystemFault& PowerCommandResponse::_internal_blocking_faults(int index) const {
  return _impl_.blocking_faults_.Get(index);
}
inline const ::bosdyn::api::SystemFault& PowerCommandResponse::blocking_faults(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerCommandResponse.blocking_faults)
  return _internal_blocking_faults(index);
}
inline ::bosdyn::api::SystemFault* PowerCommandResponse::_internal_add_blocking_faults() {
  return _impl_.blocking_faults_.Add();
}
inline ::bosdyn::api::SystemFault* PowerCommandResponse::add_blocking_faults() {
  ::bosdyn::api::SystemFault* _add = _internal_add_blocking_faults();
  // @@protoc_insertion_point(field_add:bosdyn.api.PowerCommandResponse.blocking_faults)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >&
PowerCommandResponse::blocking_faults() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.PowerCommandResponse.blocking_faults)
  return _impl_.blocking_faults_;
}

// -------------------------------------------------------------------

// PowerCommandFeedbackRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool PowerCommandFeedbackRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool PowerCommandFeedbackRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& PowerCommandFeedbackRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& PowerCommandFeedbackRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerCommandFeedbackRequest.header)
  return _internal_header();
}
inline void PowerCommandFeedbackRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PowerCommandFeedbackRequest.header)
}
inline ::bosdyn::api::RequestHeader* PowerCommandFeedbackRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* PowerCommandFeedbackRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PowerCommandFeedbackRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* PowerCommandFeedbackRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* PowerCommandFeedbackRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PowerCommandFeedbackRequest.header)
  return _msg;
}
inline void PowerCommandFeedbackRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PowerCommandFeedbackRequest.header)
}

// uint32 power_command_id = 2;
inline void PowerCommandFeedbackRequest::clear_power_command_id() {
  _impl_.power_command_id_ = 0u;
}
inline uint32_t PowerCommandFeedbackRequest::_internal_power_command_id() const {
  return _impl_.power_command_id_;
}
inline uint32_t PowerCommandFeedbackRequest::power_command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerCommandFeedbackRequest.power_command_id)
  return _internal_power_command_id();
}
inline void PowerCommandFeedbackRequest::_internal_set_power_command_id(uint32_t value) {
  
  _impl_.power_command_id_ = value;
}
inline void PowerCommandFeedbackRequest::set_power_command_id(uint32_t value) {
  _internal_set_power_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PowerCommandFeedbackRequest.power_command_id)
}

// -------------------------------------------------------------------

// PowerCommandFeedbackResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool PowerCommandFeedbackResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool PowerCommandFeedbackResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& PowerCommandFeedbackResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& PowerCommandFeedbackResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerCommandFeedbackResponse.header)
  return _internal_header();
}
inline void PowerCommandFeedbackResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PowerCommandFeedbackResponse.header)
}
inline ::bosdyn::api::ResponseHeader* PowerCommandFeedbackResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* PowerCommandFeedbackResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PowerCommandFeedbackResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* PowerCommandFeedbackResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* PowerCommandFeedbackResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PowerCommandFeedbackResponse.header)
  return _msg;
}
inline void PowerCommandFeedbackResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PowerCommandFeedbackResponse.header)
}

// .bosdyn.api.PowerCommandStatus status = 2;
inline void PowerCommandFeedbackResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::PowerCommandStatus PowerCommandFeedbackResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::PowerCommandStatus >(_impl_.status_);
}
inline ::bosdyn::api::PowerCommandStatus PowerCommandFeedbackResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerCommandFeedbackResponse.status)
  return _internal_status();
}
inline void PowerCommandFeedbackResponse::_internal_set_status(::bosdyn::api::PowerCommandStatus value) {
  
  _impl_.status_ = value;
}
inline void PowerCommandFeedbackResponse::set_status(::bosdyn::api::PowerCommandStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PowerCommandFeedbackResponse.status)
}

// repeated .bosdyn.api.SystemFault blocking_faults = 3;
inline int PowerCommandFeedbackResponse::_internal_blocking_faults_size() const {
  return _impl_.blocking_faults_.size();
}
inline int PowerCommandFeedbackResponse::blocking_faults_size() const {
  return _internal_blocking_faults_size();
}
inline ::bosdyn::api::SystemFault* PowerCommandFeedbackResponse::mutable_blocking_faults(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PowerCommandFeedbackResponse.blocking_faults)
  return _impl_.blocking_faults_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >*
PowerCommandFeedbackResponse::mutable_blocking_faults() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.PowerCommandFeedbackResponse.blocking_faults)
  return &_impl_.blocking_faults_;
}
inline const ::bosdyn::api::SystemFault& PowerCommandFeedbackResponse::_internal_blocking_faults(int index) const {
  return _impl_.blocking_faults_.Get(index);
}
inline const ::bosdyn::api::SystemFault& PowerCommandFeedbackResponse::blocking_faults(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerCommandFeedbackResponse.blocking_faults)
  return _internal_blocking_faults(index);
}
inline ::bosdyn::api::SystemFault* PowerCommandFeedbackResponse::_internal_add_blocking_faults() {
  return _impl_.blocking_faults_.Add();
}
inline ::bosdyn::api::SystemFault* PowerCommandFeedbackResponse::add_blocking_faults() {
  ::bosdyn::api::SystemFault* _add = _internal_add_blocking_faults();
  // @@protoc_insertion_point(field_add:bosdyn.api.PowerCommandFeedbackResponse.blocking_faults)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >&
PowerCommandFeedbackResponse::blocking_faults() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.PowerCommandFeedbackResponse.blocking_faults)
  return _impl_.blocking_faults_;
}

// -------------------------------------------------------------------

// FanPowerCommandRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool FanPowerCommandRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool FanPowerCommandRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& FanPowerCommandRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& FanPowerCommandRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FanPowerCommandRequest.header)
  return _internal_header();
}
inline void FanPowerCommandRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FanPowerCommandRequest.header)
}
inline ::bosdyn::api::RequestHeader* FanPowerCommandRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* FanPowerCommandRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FanPowerCommandRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* FanPowerCommandRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* FanPowerCommandRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FanPowerCommandRequest.header)
  return _msg;
}
inline void FanPowerCommandRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FanPowerCommandRequest.header)
}

// .bosdyn.api.Lease lease = 2;
inline bool FanPowerCommandRequest::_internal_has_lease() const {
  return this != internal_default_instance() && _impl_.lease_ != nullptr;
}
inline bool FanPowerCommandRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& FanPowerCommandRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = _impl_.lease_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Lease&>(
      ::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& FanPowerCommandRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FanPowerCommandRequest.lease)
  return _internal_lease();
}
inline void FanPowerCommandRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  _impl_.lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FanPowerCommandRequest.lease)
}
inline ::bosdyn::api::Lease* FanPowerCommandRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Lease* FanPowerCommandRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FanPowerCommandRequest.lease)
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* FanPowerCommandRequest::_internal_mutable_lease() {
  
  if (_impl_.lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArenaForAllocation());
    _impl_.lease_ = p;
  }
  return _impl_.lease_;
}
inline ::bosdyn::api::Lease* FanPowerCommandRequest::mutable_lease() {
  ::bosdyn::api::Lease* _msg = _internal_mutable_lease();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FanPowerCommandRequest.lease)
  return _msg;
}
inline void FanPowerCommandRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease));
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FanPowerCommandRequest.lease)
}

// int32 percent_power = 3;
inline void FanPowerCommandRequest::clear_percent_power() {
  _impl_.percent_power_ = 0;
}
inline int32_t FanPowerCommandRequest::_internal_percent_power() const {
  return _impl_.percent_power_;
}
inline int32_t FanPowerCommandRequest::percent_power() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FanPowerCommandRequest.percent_power)
  return _internal_percent_power();
}
inline void FanPowerCommandRequest::_internal_set_percent_power(int32_t value) {
  
  _impl_.percent_power_ = value;
}
inline void FanPowerCommandRequest::set_percent_power(int32_t value) {
  _internal_set_percent_power(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.FanPowerCommandRequest.percent_power)
}

// .google.protobuf.Duration duration = 4;
inline bool FanPowerCommandRequest::_internal_has_duration() const {
  return this != internal_default_instance() && _impl_.duration_ != nullptr;
}
inline bool FanPowerCommandRequest::has_duration() const {
  return _internal_has_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& FanPowerCommandRequest::_internal_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& FanPowerCommandRequest::duration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FanPowerCommandRequest.duration)
  return _internal_duration();
}
inline void FanPowerCommandRequest::unsafe_arena_set_allocated_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_);
  }
  _impl_.duration_ = duration;
  if (duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FanPowerCommandRequest.duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* FanPowerCommandRequest::release_duration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* FanPowerCommandRequest::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FanPowerCommandRequest.duration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* FanPowerCommandRequest::_internal_mutable_duration() {
  
  if (_impl_.duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.duration_ = p;
  }
  return _impl_.duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* FanPowerCommandRequest::mutable_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FanPowerCommandRequest.duration)
  return _msg;
}
inline void FanPowerCommandRequest::set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_);
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration));
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FanPowerCommandRequest.duration)
}

// -------------------------------------------------------------------

// FanPowerCommandResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool FanPowerCommandResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool FanPowerCommandResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& FanPowerCommandResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& FanPowerCommandResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FanPowerCommandResponse.header)
  return _internal_header();
}
inline void FanPowerCommandResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FanPowerCommandResponse.header)
}
inline ::bosdyn::api::ResponseHeader* FanPowerCommandResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* FanPowerCommandResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FanPowerCommandResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* FanPowerCommandResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* FanPowerCommandResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FanPowerCommandResponse.header)
  return _msg;
}
inline void FanPowerCommandResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FanPowerCommandResponse.header)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool FanPowerCommandResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && _impl_.lease_use_result_ != nullptr;
}
inline bool FanPowerCommandResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& FanPowerCommandResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = _impl_.lease_use_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::LeaseUseResult&>(
      ::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& FanPowerCommandResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FanPowerCommandResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void FanPowerCommandResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  _impl_.lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FanPowerCommandResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* FanPowerCommandResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* FanPowerCommandResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FanPowerCommandResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* FanPowerCommandResponse::_internal_mutable_lease_use_result() {
  
  if (_impl_.lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArenaForAllocation());
    _impl_.lease_use_result_ = p;
  }
  return _impl_.lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* FanPowerCommandResponse::mutable_lease_use_result() {
  ::bosdyn::api::LeaseUseResult* _msg = _internal_mutable_lease_use_result();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FanPowerCommandResponse.lease_use_result)
  return _msg;
}
inline void FanPowerCommandResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result));
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FanPowerCommandResponse.lease_use_result)
}

// .bosdyn.api.FanPowerCommandResponse.Status status = 3;
inline void FanPowerCommandResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::FanPowerCommandResponse_Status FanPowerCommandResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::FanPowerCommandResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::FanPowerCommandResponse_Status FanPowerCommandResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FanPowerCommandResponse.status)
  return _internal_status();
}
inline void FanPowerCommandResponse::_internal_set_status(::bosdyn::api::FanPowerCommandResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void FanPowerCommandResponse::set_status(::bosdyn::api::FanPowerCommandResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.FanPowerCommandResponse.status)
}

// .google.protobuf.Timestamp desired_end_time = 4;
inline bool FanPowerCommandResponse::_internal_has_desired_end_time() const {
  return this != internal_default_instance() && _impl_.desired_end_time_ != nullptr;
}
inline bool FanPowerCommandResponse::has_desired_end_time() const {
  return _internal_has_desired_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& FanPowerCommandResponse::_internal_desired_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.desired_end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& FanPowerCommandResponse::desired_end_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FanPowerCommandResponse.desired_end_time)
  return _internal_desired_end_time();
}
inline void FanPowerCommandResponse::unsafe_arena_set_allocated_desired_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* desired_end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.desired_end_time_);
  }
  _impl_.desired_end_time_ = desired_end_time;
  if (desired_end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FanPowerCommandResponse.desired_end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FanPowerCommandResponse::release_desired_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.desired_end_time_;
  _impl_.desired_end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FanPowerCommandResponse::unsafe_arena_release_desired_end_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FanPowerCommandResponse.desired_end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.desired_end_time_;
  _impl_.desired_end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FanPowerCommandResponse::_internal_mutable_desired_end_time() {
  
  if (_impl_.desired_end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.desired_end_time_ = p;
  }
  return _impl_.desired_end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FanPowerCommandResponse::mutable_desired_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_desired_end_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FanPowerCommandResponse.desired_end_time)
  return _msg;
}
inline void FanPowerCommandResponse::set_allocated_desired_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* desired_end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.desired_end_time_);
  }
  if (desired_end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(desired_end_time));
    if (message_arena != submessage_arena) {
      desired_end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, desired_end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.desired_end_time_ = desired_end_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FanPowerCommandResponse.desired_end_time)
}

// uint32 command_id = 5;
inline void FanPowerCommandResponse::clear_command_id() {
  _impl_.command_id_ = 0u;
}
inline uint32_t FanPowerCommandResponse::_internal_command_id() const {
  return _impl_.command_id_;
}
inline uint32_t FanPowerCommandResponse::command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FanPowerCommandResponse.command_id)
  return _internal_command_id();
}
inline void FanPowerCommandResponse::_internal_set_command_id(uint32_t value) {
  
  _impl_.command_id_ = value;
}
inline void FanPowerCommandResponse::set_command_id(uint32_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.FanPowerCommandResponse.command_id)
}

// -------------------------------------------------------------------

// FanPowerCommandFeedbackRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool FanPowerCommandFeedbackRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool FanPowerCommandFeedbackRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& FanPowerCommandFeedbackRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& FanPowerCommandFeedbackRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FanPowerCommandFeedbackRequest.header)
  return _internal_header();
}
inline void FanPowerCommandFeedbackRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FanPowerCommandFeedbackRequest.header)
}
inline ::bosdyn::api::RequestHeader* FanPowerCommandFeedbackRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* FanPowerCommandFeedbackRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FanPowerCommandFeedbackRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* FanPowerCommandFeedbackRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* FanPowerCommandFeedbackRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FanPowerCommandFeedbackRequest.header)
  return _msg;
}
inline void FanPowerCommandFeedbackRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FanPowerCommandFeedbackRequest.header)
}

// uint32 command_id = 2;
inline void FanPowerCommandFeedbackRequest::clear_command_id() {
  _impl_.command_id_ = 0u;
}
inline uint32_t FanPowerCommandFeedbackRequest::_internal_command_id() const {
  return _impl_.command_id_;
}
inline uint32_t FanPowerCommandFeedbackRequest::command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FanPowerCommandFeedbackRequest.command_id)
  return _internal_command_id();
}
inline void FanPowerCommandFeedbackRequest::_internal_set_command_id(uint32_t value) {
  
  _impl_.command_id_ = value;
}
inline void FanPowerCommandFeedbackRequest::set_command_id(uint32_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.FanPowerCommandFeedbackRequest.command_id)
}

// -------------------------------------------------------------------

// FanPowerCommandFeedbackResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool FanPowerCommandFeedbackResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool FanPowerCommandFeedbackResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& FanPowerCommandFeedbackResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& FanPowerCommandFeedbackResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FanPowerCommandFeedbackResponse.header)
  return _internal_header();
}
inline void FanPowerCommandFeedbackResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FanPowerCommandFeedbackResponse.header)
}
inline ::bosdyn::api::ResponseHeader* FanPowerCommandFeedbackResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* FanPowerCommandFeedbackResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FanPowerCommandFeedbackResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* FanPowerCommandFeedbackResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* FanPowerCommandFeedbackResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FanPowerCommandFeedbackResponse.header)
  return _msg;
}
inline void FanPowerCommandFeedbackResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FanPowerCommandFeedbackResponse.header)
}

// .bosdyn.api.FanPowerCommandFeedbackResponse.Status status = 2;
inline void FanPowerCommandFeedbackResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::FanPowerCommandFeedbackResponse_Status FanPowerCommandFeedbackResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::FanPowerCommandFeedbackResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::FanPowerCommandFeedbackResponse_Status FanPowerCommandFeedbackResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FanPowerCommandFeedbackResponse.status)
  return _internal_status();
}
inline void FanPowerCommandFeedbackResponse::_internal_set_status(::bosdyn::api::FanPowerCommandFeedbackResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void FanPowerCommandFeedbackResponse::set_status(::bosdyn::api::FanPowerCommandFeedbackResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.FanPowerCommandFeedbackResponse.status)
}

// .google.protobuf.Timestamp desired_end_time = 3;
inline bool FanPowerCommandFeedbackResponse::_internal_has_desired_end_time() const {
  return this != internal_default_instance() && _impl_.desired_end_time_ != nullptr;
}
inline bool FanPowerCommandFeedbackResponse::has_desired_end_time() const {
  return _internal_has_desired_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& FanPowerCommandFeedbackResponse::_internal_desired_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.desired_end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& FanPowerCommandFeedbackResponse::desired_end_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FanPowerCommandFeedbackResponse.desired_end_time)
  return _internal_desired_end_time();
}
inline void FanPowerCommandFeedbackResponse::unsafe_arena_set_allocated_desired_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* desired_end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.desired_end_time_);
  }
  _impl_.desired_end_time_ = desired_end_time;
  if (desired_end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FanPowerCommandFeedbackResponse.desired_end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FanPowerCommandFeedbackResponse::release_desired_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.desired_end_time_;
  _impl_.desired_end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FanPowerCommandFeedbackResponse::unsafe_arena_release_desired_end_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FanPowerCommandFeedbackResponse.desired_end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.desired_end_time_;
  _impl_.desired_end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FanPowerCommandFeedbackResponse::_internal_mutable_desired_end_time() {
  
  if (_impl_.desired_end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.desired_end_time_ = p;
  }
  return _impl_.desired_end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FanPowerCommandFeedbackResponse::mutable_desired_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_desired_end_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FanPowerCommandFeedbackResponse.desired_end_time)
  return _msg;
}
inline void FanPowerCommandFeedbackResponse::set_allocated_desired_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* desired_end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.desired_end_time_);
  }
  if (desired_end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(desired_end_time));
    if (message_arena != submessage_arena) {
      desired_end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, desired_end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.desired_end_time_ = desired_end_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FanPowerCommandFeedbackResponse.desired_end_time)
}

// .google.protobuf.Timestamp early_stop_time = 4;
inline bool FanPowerCommandFeedbackResponse::_internal_has_early_stop_time() const {
  return this != internal_default_instance() && _impl_.early_stop_time_ != nullptr;
}
inline bool FanPowerCommandFeedbackResponse::has_early_stop_time() const {
  return _internal_has_early_stop_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& FanPowerCommandFeedbackResponse::_internal_early_stop_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.early_stop_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& FanPowerCommandFeedbackResponse::early_stop_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FanPowerCommandFeedbackResponse.early_stop_time)
  return _internal_early_stop_time();
}
inline void FanPowerCommandFeedbackResponse::unsafe_arena_set_allocated_early_stop_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* early_stop_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.early_stop_time_);
  }
  _impl_.early_stop_time_ = early_stop_time;
  if (early_stop_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FanPowerCommandFeedbackResponse.early_stop_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FanPowerCommandFeedbackResponse::release_early_stop_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.early_stop_time_;
  _impl_.early_stop_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FanPowerCommandFeedbackResponse::unsafe_arena_release_early_stop_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FanPowerCommandFeedbackResponse.early_stop_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.early_stop_time_;
  _impl_.early_stop_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FanPowerCommandFeedbackResponse::_internal_mutable_early_stop_time() {
  
  if (_impl_.early_stop_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.early_stop_time_ = p;
  }
  return _impl_.early_stop_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FanPowerCommandFeedbackResponse::mutable_early_stop_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_early_stop_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FanPowerCommandFeedbackResponse.early_stop_time)
  return _msg;
}
inline void FanPowerCommandFeedbackResponse::set_allocated_early_stop_time(::PROTOBUF_NAMESPACE_ID::Timestamp* early_stop_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.early_stop_time_);
  }
  if (early_stop_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(early_stop_time));
    if (message_arena != submessage_arena) {
      early_stop_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, early_stop_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.early_stop_time_ = early_stop_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FanPowerCommandFeedbackResponse.early_stop_time)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::PowerCommandRequest_Request> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::PowerCommandRequest_Request>() {
  return ::bosdyn::api::PowerCommandRequest_Request_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::FanPowerCommandResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::FanPowerCommandResponse_Status>() {
  return ::bosdyn::api::FanPowerCommandResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::FanPowerCommandFeedbackResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::FanPowerCommandFeedbackResponse_Status>() {
  return ::bosdyn::api::FanPowerCommandFeedbackResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::PowerCommandStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::PowerCommandStatus>() {
  return ::bosdyn::api::PowerCommandStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fpower_2eproto
