// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/image.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fimage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fimage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/geometry.pb.h"
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fimage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fimage_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fimage_2eproto;
namespace bosdyn {
namespace api {
class CaptureParameters;
struct CaptureParametersDefaultTypeInternal;
extern CaptureParametersDefaultTypeInternal _CaptureParameters_default_instance_;
class GetImageRequest;
struct GetImageRequestDefaultTypeInternal;
extern GetImageRequestDefaultTypeInternal _GetImageRequest_default_instance_;
class GetImageResponse;
struct GetImageResponseDefaultTypeInternal;
extern GetImageResponseDefaultTypeInternal _GetImageResponse_default_instance_;
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class ImageCapture;
struct ImageCaptureDefaultTypeInternal;
extern ImageCaptureDefaultTypeInternal _ImageCapture_default_instance_;
class ImageRequest;
struct ImageRequestDefaultTypeInternal;
extern ImageRequestDefaultTypeInternal _ImageRequest_default_instance_;
class ImageResponse;
struct ImageResponseDefaultTypeInternal;
extern ImageResponseDefaultTypeInternal _ImageResponse_default_instance_;
class ImageSource;
struct ImageSourceDefaultTypeInternal;
extern ImageSourceDefaultTypeInternal _ImageSource_default_instance_;
class ImageSource_PinholeModel;
struct ImageSource_PinholeModelDefaultTypeInternal;
extern ImageSource_PinholeModelDefaultTypeInternal _ImageSource_PinholeModel_default_instance_;
class ImageSource_PinholeModel_CameraIntrinsics;
struct ImageSource_PinholeModel_CameraIntrinsicsDefaultTypeInternal;
extern ImageSource_PinholeModel_CameraIntrinsicsDefaultTypeInternal _ImageSource_PinholeModel_CameraIntrinsics_default_instance_;
class ListImageSourcesRequest;
struct ListImageSourcesRequestDefaultTypeInternal;
extern ListImageSourcesRequestDefaultTypeInternal _ListImageSourcesRequest_default_instance_;
class ListImageSourcesResponse;
struct ListImageSourcesResponseDefaultTypeInternal;
extern ListImageSourcesResponseDefaultTypeInternal _ListImageSourcesResponse_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::CaptureParameters* Arena::CreateMaybeMessage<::bosdyn::api::CaptureParameters>(Arena*);
template<> ::bosdyn::api::GetImageRequest* Arena::CreateMaybeMessage<::bosdyn::api::GetImageRequest>(Arena*);
template<> ::bosdyn::api::GetImageResponse* Arena::CreateMaybeMessage<::bosdyn::api::GetImageResponse>(Arena*);
template<> ::bosdyn::api::Image* Arena::CreateMaybeMessage<::bosdyn::api::Image>(Arena*);
template<> ::bosdyn::api::ImageCapture* Arena::CreateMaybeMessage<::bosdyn::api::ImageCapture>(Arena*);
template<> ::bosdyn::api::ImageRequest* Arena::CreateMaybeMessage<::bosdyn::api::ImageRequest>(Arena*);
template<> ::bosdyn::api::ImageResponse* Arena::CreateMaybeMessage<::bosdyn::api::ImageResponse>(Arena*);
template<> ::bosdyn::api::ImageSource* Arena::CreateMaybeMessage<::bosdyn::api::ImageSource>(Arena*);
template<> ::bosdyn::api::ImageSource_PinholeModel* Arena::CreateMaybeMessage<::bosdyn::api::ImageSource_PinholeModel>(Arena*);
template<> ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* Arena::CreateMaybeMessage<::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics>(Arena*);
template<> ::bosdyn::api::ListImageSourcesRequest* Arena::CreateMaybeMessage<::bosdyn::api::ListImageSourcesRequest>(Arena*);
template<> ::bosdyn::api::ListImageSourcesResponse* Arena::CreateMaybeMessage<::bosdyn::api::ListImageSourcesResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum Image_Format : int {
  Image_Format_FORMAT_UNKNOWN = 0,
  Image_Format_FORMAT_JPEG = 1,
  Image_Format_FORMAT_RAW = 2,
  Image_Format_FORMAT_RLE = 3,
  Image_Format_Image_Format_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Image_Format_Image_Format_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Image_Format_IsValid(int value);
constexpr Image_Format Image_Format_Format_MIN = Image_Format_FORMAT_UNKNOWN;
constexpr Image_Format Image_Format_Format_MAX = Image_Format_FORMAT_RLE;
constexpr int Image_Format_Format_ARRAYSIZE = Image_Format_Format_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Image_Format_descriptor();
template<typename T>
inline const std::string& Image_Format_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Image_Format>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Image_Format_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Image_Format_descriptor(), enum_t_value);
}
inline bool Image_Format_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Image_Format* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Image_Format>(
    Image_Format_descriptor(), name, value);
}
enum Image_PixelFormat : int {
  Image_PixelFormat_PIXEL_FORMAT_UNKNOWN = 0,
  Image_PixelFormat_PIXEL_FORMAT_GREYSCALE_U8 = 1,
  Image_PixelFormat_PIXEL_FORMAT_RGB_U8 = 3,
  Image_PixelFormat_PIXEL_FORMAT_RGBA_U8 = 4,
  Image_PixelFormat_PIXEL_FORMAT_DEPTH_U16 = 5,
  Image_PixelFormat_PIXEL_FORMAT_GREYSCALE_U16 = 6,
  Image_PixelFormat_Image_PixelFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Image_PixelFormat_Image_PixelFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Image_PixelFormat_IsValid(int value);
constexpr Image_PixelFormat Image_PixelFormat_PixelFormat_MIN = Image_PixelFormat_PIXEL_FORMAT_UNKNOWN;
constexpr Image_PixelFormat Image_PixelFormat_PixelFormat_MAX = Image_PixelFormat_PIXEL_FORMAT_GREYSCALE_U16;
constexpr int Image_PixelFormat_PixelFormat_ARRAYSIZE = Image_PixelFormat_PixelFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Image_PixelFormat_descriptor();
template<typename T>
inline const std::string& Image_PixelFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Image_PixelFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Image_PixelFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Image_PixelFormat_descriptor(), enum_t_value);
}
inline bool Image_PixelFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Image_PixelFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Image_PixelFormat>(
    Image_PixelFormat_descriptor(), name, value);
}
enum ImageSource_ImageType : int {
  ImageSource_ImageType_IMAGE_TYPE_UNKNOWN = 0,
  ImageSource_ImageType_IMAGE_TYPE_VISUAL = 1,
  ImageSource_ImageType_IMAGE_TYPE_DEPTH = 2,
  ImageSource_ImageType_ImageSource_ImageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ImageSource_ImageType_ImageSource_ImageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ImageSource_ImageType_IsValid(int value);
constexpr ImageSource_ImageType ImageSource_ImageType_ImageType_MIN = ImageSource_ImageType_IMAGE_TYPE_UNKNOWN;
constexpr ImageSource_ImageType ImageSource_ImageType_ImageType_MAX = ImageSource_ImageType_IMAGE_TYPE_DEPTH;
constexpr int ImageSource_ImageType_ImageType_ARRAYSIZE = ImageSource_ImageType_ImageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageSource_ImageType_descriptor();
template<typename T>
inline const std::string& ImageSource_ImageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImageSource_ImageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImageSource_ImageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImageSource_ImageType_descriptor(), enum_t_value);
}
inline bool ImageSource_ImageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImageSource_ImageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImageSource_ImageType>(
    ImageSource_ImageType_descriptor(), name, value);
}
enum ImageResponse_Status : int {
  ImageResponse_Status_STATUS_UNKNOWN = 0,
  ImageResponse_Status_STATUS_OK = 1,
  ImageResponse_Status_STATUS_UNKNOWN_CAMERA = 2,
  ImageResponse_Status_STATUS_SOURCE_DATA_ERROR = 3,
  ImageResponse_Status_STATUS_IMAGE_DATA_ERROR = 4,
  ImageResponse_Status_STATUS_UNSUPPORTED_IMAGE_FORMAT_REQUESTED = 5,
  ImageResponse_Status_STATUS_UNSUPPORTED_PIXEL_FORMAT_REQUESTED = 6,
  ImageResponse_Status_STATUS_UNSUPPORTED_RESIZE_RATIO_REQUESTED = 7,
  ImageResponse_Status_ImageResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ImageResponse_Status_ImageResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ImageResponse_Status_IsValid(int value);
constexpr ImageResponse_Status ImageResponse_Status_Status_MIN = ImageResponse_Status_STATUS_UNKNOWN;
constexpr ImageResponse_Status ImageResponse_Status_Status_MAX = ImageResponse_Status_STATUS_UNSUPPORTED_RESIZE_RATIO_REQUESTED;
constexpr int ImageResponse_Status_Status_ARRAYSIZE = ImageResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageResponse_Status_descriptor();
template<typename T>
inline const std::string& ImageResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImageResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImageResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImageResponse_Status_descriptor(), enum_t_value);
}
inline bool ImageResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImageResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImageResponse_Status>(
    ImageResponse_Status_descriptor(), name, value);
}
// ===================================================================

class Image final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  ~Image() override;
  explicit PROTOBUF_CONSTEXPR Image(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Image& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Image& from) {
    Image::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Image_Format Format;
  static constexpr Format FORMAT_UNKNOWN =
    Image_Format_FORMAT_UNKNOWN;
  static constexpr Format FORMAT_JPEG =
    Image_Format_FORMAT_JPEG;
  static constexpr Format FORMAT_RAW =
    Image_Format_FORMAT_RAW;
  static constexpr Format FORMAT_RLE =
    Image_Format_FORMAT_RLE;
  static inline bool Format_IsValid(int value) {
    return Image_Format_IsValid(value);
  }
  static constexpr Format Format_MIN =
    Image_Format_Format_MIN;
  static constexpr Format Format_MAX =
    Image_Format_Format_MAX;
  static constexpr int Format_ARRAYSIZE =
    Image_Format_Format_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Format_descriptor() {
    return Image_Format_descriptor();
  }
  template<typename T>
  static inline const std::string& Format_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Format>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Format_Name.");
    return Image_Format_Name(enum_t_value);
  }
  static inline bool Format_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Format* value) {
    return Image_Format_Parse(name, value);
  }

  typedef Image_PixelFormat PixelFormat;
  static constexpr PixelFormat PIXEL_FORMAT_UNKNOWN =
    Image_PixelFormat_PIXEL_FORMAT_UNKNOWN;
  static constexpr PixelFormat PIXEL_FORMAT_GREYSCALE_U8 =
    Image_PixelFormat_PIXEL_FORMAT_GREYSCALE_U8;
  static constexpr PixelFormat PIXEL_FORMAT_RGB_U8 =
    Image_PixelFormat_PIXEL_FORMAT_RGB_U8;
  static constexpr PixelFormat PIXEL_FORMAT_RGBA_U8 =
    Image_PixelFormat_PIXEL_FORMAT_RGBA_U8;
  static constexpr PixelFormat PIXEL_FORMAT_DEPTH_U16 =
    Image_PixelFormat_PIXEL_FORMAT_DEPTH_U16;
  static constexpr PixelFormat PIXEL_FORMAT_GREYSCALE_U16 =
    Image_PixelFormat_PIXEL_FORMAT_GREYSCALE_U16;
  static inline bool PixelFormat_IsValid(int value) {
    return Image_PixelFormat_IsValid(value);
  }
  static constexpr PixelFormat PixelFormat_MIN =
    Image_PixelFormat_PixelFormat_MIN;
  static constexpr PixelFormat PixelFormat_MAX =
    Image_PixelFormat_PixelFormat_MAX;
  static constexpr int PixelFormat_ARRAYSIZE =
    Image_PixelFormat_PixelFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PixelFormat_descriptor() {
    return Image_PixelFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& PixelFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PixelFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PixelFormat_Name.");
    return Image_PixelFormat_Name(enum_t_value);
  }
  static inline bool PixelFormat_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PixelFormat* value) {
    return Image_PixelFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kColsFieldNumber = 2,
    kRowsFieldNumber = 3,
    kFormatFieldNumber = 5,
    kPixelFormatFieldNumber = 6,
  };
  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 cols = 2;
  void clear_cols();
  int32_t cols() const;
  void set_cols(int32_t value);
  private:
  int32_t _internal_cols() const;
  void _internal_set_cols(int32_t value);
  public:

  // int32 rows = 3;
  void clear_rows();
  int32_t rows() const;
  void set_rows(int32_t value);
  private:
  int32_t _internal_rows() const;
  void _internal_set_rows(int32_t value);
  public:

  // .bosdyn.api.Image.Format format = 5;
  void clear_format();
  ::bosdyn::api::Image_Format format() const;
  void set_format(::bosdyn::api::Image_Format value);
  private:
  ::bosdyn::api::Image_Format _internal_format() const;
  void _internal_set_format(::bosdyn::api::Image_Format value);
  public:

  // .bosdyn.api.Image.PixelFormat pixel_format = 6;
  void clear_pixel_format();
  ::bosdyn::api::Image_PixelFormat pixel_format() const;
  void set_pixel_format(::bosdyn::api::Image_PixelFormat value);
  private:
  ::bosdyn::api::Image_PixelFormat _internal_pixel_format() const;
  void _internal_set_pixel_format(::bosdyn::api::Image_PixelFormat value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int32_t cols_;
    int32_t rows_;
    int format_;
    int pixel_format_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class CaptureParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.CaptureParameters) */ {
 public:
  inline CaptureParameters() : CaptureParameters(nullptr) {}
  ~CaptureParameters() override;
  explicit PROTOBUF_CONSTEXPR CaptureParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaptureParameters(const CaptureParameters& from);
  CaptureParameters(CaptureParameters&& from) noexcept
    : CaptureParameters() {
    *this = ::std::move(from);
  }

  inline CaptureParameters& operator=(const CaptureParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptureParameters& operator=(CaptureParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaptureParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptureParameters* internal_default_instance() {
    return reinterpret_cast<const CaptureParameters*>(
               &_CaptureParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CaptureParameters& a, CaptureParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(CaptureParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptureParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptureParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaptureParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaptureParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaptureParameters& from) {
    CaptureParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaptureParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.CaptureParameters";
  }
  protected:
  explicit CaptureParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExposureDurationFieldNumber = 1,
    kGainFieldNumber = 2,
  };
  // .google.protobuf.Duration exposure_duration = 1;
  bool has_exposure_duration() const;
  private:
  bool _internal_has_exposure_duration() const;
  public:
  void clear_exposure_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& exposure_duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_exposure_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_exposure_duration();
  void set_allocated_exposure_duration(::PROTOBUF_NAMESPACE_ID::Duration* exposure_duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_exposure_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_exposure_duration();
  public:
  void unsafe_arena_set_allocated_exposure_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* exposure_duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_exposure_duration();

  // double gain = 2;
  void clear_gain();
  double gain() const;
  void set_gain(double value);
  private:
  double _internal_gain() const;
  void _internal_set_gain(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.CaptureParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Duration* exposure_duration_;
    double gain_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class ImageCapture final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ImageCapture) */ {
 public:
  inline ImageCapture() : ImageCapture(nullptr) {}
  ~ImageCapture() override;
  explicit PROTOBUF_CONSTEXPR ImageCapture(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageCapture(const ImageCapture& from);
  ImageCapture(ImageCapture&& from) noexcept
    : ImageCapture() {
    *this = ::std::move(from);
  }

  inline ImageCapture& operator=(const ImageCapture& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageCapture& operator=(ImageCapture&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageCapture& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageCapture* internal_default_instance() {
    return reinterpret_cast<const ImageCapture*>(
               &_ImageCapture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ImageCapture& a, ImageCapture& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageCapture* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageCapture* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageCapture* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageCapture>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageCapture& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageCapture& from) {
    ImageCapture::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageCapture* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ImageCapture";
  }
  protected:
  explicit ImageCapture(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameImageSensorFieldNumber = 5,
    kImageFieldNumber = 3,
    kCaptureParamsFieldNumber = 4,
    kAcquisitionTimeFieldNumber = 30,
    kTransformsSnapshotFieldNumber = 31,
  };
  // string frame_name_image_sensor = 5;
  void clear_frame_name_image_sensor();
  const std::string& frame_name_image_sensor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name_image_sensor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name_image_sensor();
  PROTOBUF_NODISCARD std::string* release_frame_name_image_sensor();
  void set_allocated_frame_name_image_sensor(std::string* frame_name_image_sensor);
  private:
  const std::string& _internal_frame_name_image_sensor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name_image_sensor(const std::string& value);
  std::string* _internal_mutable_frame_name_image_sensor();
  public:

  // .bosdyn.api.Image image = 3;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::bosdyn::api::Image& image() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Image* release_image();
  ::bosdyn::api::Image* mutable_image();
  void set_allocated_image(::bosdyn::api::Image* image);
  private:
  const ::bosdyn::api::Image& _internal_image() const;
  ::bosdyn::api::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::bosdyn::api::Image* image);
  ::bosdyn::api::Image* unsafe_arena_release_image();

  // .bosdyn.api.CaptureParameters capture_params = 4;
  bool has_capture_params() const;
  private:
  bool _internal_has_capture_params() const;
  public:
  void clear_capture_params();
  const ::bosdyn::api::CaptureParameters& capture_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::CaptureParameters* release_capture_params();
  ::bosdyn::api::CaptureParameters* mutable_capture_params();
  void set_allocated_capture_params(::bosdyn::api::CaptureParameters* capture_params);
  private:
  const ::bosdyn::api::CaptureParameters& _internal_capture_params() const;
  ::bosdyn::api::CaptureParameters* _internal_mutable_capture_params();
  public:
  void unsafe_arena_set_allocated_capture_params(
      ::bosdyn::api::CaptureParameters* capture_params);
  ::bosdyn::api::CaptureParameters* unsafe_arena_release_capture_params();

  // .google.protobuf.Timestamp acquisition_time = 30;
  bool has_acquisition_time() const;
  private:
  bool _internal_has_acquisition_time() const;
  public:
  void clear_acquisition_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& acquisition_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_acquisition_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_acquisition_time();
  void set_allocated_acquisition_time(::PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_acquisition_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_acquisition_time();
  public:
  void unsafe_arena_set_allocated_acquisition_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_acquisition_time();

  // .bosdyn.api.FrameTreeSnapshot transforms_snapshot = 31;
  bool has_transforms_snapshot() const;
  private:
  bool _internal_has_transforms_snapshot() const;
  public:
  void clear_transforms_snapshot();
  const ::bosdyn::api::FrameTreeSnapshot& transforms_snapshot() const;
  PROTOBUF_NODISCARD ::bosdyn::api::FrameTreeSnapshot* release_transforms_snapshot();
  ::bosdyn::api::FrameTreeSnapshot* mutable_transforms_snapshot();
  void set_allocated_transforms_snapshot(::bosdyn::api::FrameTreeSnapshot* transforms_snapshot);
  private:
  const ::bosdyn::api::FrameTreeSnapshot& _internal_transforms_snapshot() const;
  ::bosdyn::api::FrameTreeSnapshot* _internal_mutable_transforms_snapshot();
  public:
  void unsafe_arena_set_allocated_transforms_snapshot(
      ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot);
  ::bosdyn::api::FrameTreeSnapshot* unsafe_arena_release_transforms_snapshot();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ImageCapture)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_image_sensor_;
    ::bosdyn::api::Image* image_;
    ::bosdyn::api::CaptureParameters* capture_params_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_time_;
    ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class ImageSource_PinholeModel_CameraIntrinsics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics) */ {
 public:
  inline ImageSource_PinholeModel_CameraIntrinsics() : ImageSource_PinholeModel_CameraIntrinsics(nullptr) {}
  ~ImageSource_PinholeModel_CameraIntrinsics() override;
  explicit PROTOBUF_CONSTEXPR ImageSource_PinholeModel_CameraIntrinsics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageSource_PinholeModel_CameraIntrinsics(const ImageSource_PinholeModel_CameraIntrinsics& from);
  ImageSource_PinholeModel_CameraIntrinsics(ImageSource_PinholeModel_CameraIntrinsics&& from) noexcept
    : ImageSource_PinholeModel_CameraIntrinsics() {
    *this = ::std::move(from);
  }

  inline ImageSource_PinholeModel_CameraIntrinsics& operator=(const ImageSource_PinholeModel_CameraIntrinsics& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageSource_PinholeModel_CameraIntrinsics& operator=(ImageSource_PinholeModel_CameraIntrinsics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageSource_PinholeModel_CameraIntrinsics& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageSource_PinholeModel_CameraIntrinsics* internal_default_instance() {
    return reinterpret_cast<const ImageSource_PinholeModel_CameraIntrinsics*>(
               &_ImageSource_PinholeModel_CameraIntrinsics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ImageSource_PinholeModel_CameraIntrinsics& a, ImageSource_PinholeModel_CameraIntrinsics& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageSource_PinholeModel_CameraIntrinsics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageSource_PinholeModel_CameraIntrinsics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageSource_PinholeModel_CameraIntrinsics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageSource_PinholeModel_CameraIntrinsics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageSource_PinholeModel_CameraIntrinsics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageSource_PinholeModel_CameraIntrinsics& from) {
    ImageSource_PinholeModel_CameraIntrinsics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageSource_PinholeModel_CameraIntrinsics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics";
  }
  protected:
  explicit ImageSource_PinholeModel_CameraIntrinsics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFocalLengthFieldNumber = 1,
    kPrincipalPointFieldNumber = 2,
    kSkewFieldNumber = 3,
  };
  // .bosdyn.api.Vec2 focal_length = 1;
  bool has_focal_length() const;
  private:
  bool _internal_has_focal_length() const;
  public:
  void clear_focal_length();
  const ::bosdyn::api::Vec2& focal_length() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec2* release_focal_length();
  ::bosdyn::api::Vec2* mutable_focal_length();
  void set_allocated_focal_length(::bosdyn::api::Vec2* focal_length);
  private:
  const ::bosdyn::api::Vec2& _internal_focal_length() const;
  ::bosdyn::api::Vec2* _internal_mutable_focal_length();
  public:
  void unsafe_arena_set_allocated_focal_length(
      ::bosdyn::api::Vec2* focal_length);
  ::bosdyn::api::Vec2* unsafe_arena_release_focal_length();

  // .bosdyn.api.Vec2 principal_point = 2;
  bool has_principal_point() const;
  private:
  bool _internal_has_principal_point() const;
  public:
  void clear_principal_point();
  const ::bosdyn::api::Vec2& principal_point() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec2* release_principal_point();
  ::bosdyn::api::Vec2* mutable_principal_point();
  void set_allocated_principal_point(::bosdyn::api::Vec2* principal_point);
  private:
  const ::bosdyn::api::Vec2& _internal_principal_point() const;
  ::bosdyn::api::Vec2* _internal_mutable_principal_point();
  public:
  void unsafe_arena_set_allocated_principal_point(
      ::bosdyn::api::Vec2* principal_point);
  ::bosdyn::api::Vec2* unsafe_arena_release_principal_point();

  // .bosdyn.api.Vec2 skew = 3;
  bool has_skew() const;
  private:
  bool _internal_has_skew() const;
  public:
  void clear_skew();
  const ::bosdyn::api::Vec2& skew() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec2* release_skew();
  ::bosdyn::api::Vec2* mutable_skew();
  void set_allocated_skew(::bosdyn::api::Vec2* skew);
  private:
  const ::bosdyn::api::Vec2& _internal_skew() const;
  ::bosdyn::api::Vec2* _internal_mutable_skew();
  public:
  void unsafe_arena_set_allocated_skew(
      ::bosdyn::api::Vec2* skew);
  ::bosdyn::api::Vec2* unsafe_arena_release_skew();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec2* focal_length_;
    ::bosdyn::api::Vec2* principal_point_;
    ::bosdyn::api::Vec2* skew_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class ImageSource_PinholeModel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ImageSource.PinholeModel) */ {
 public:
  inline ImageSource_PinholeModel() : ImageSource_PinholeModel(nullptr) {}
  ~ImageSource_PinholeModel() override;
  explicit PROTOBUF_CONSTEXPR ImageSource_PinholeModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageSource_PinholeModel(const ImageSource_PinholeModel& from);
  ImageSource_PinholeModel(ImageSource_PinholeModel&& from) noexcept
    : ImageSource_PinholeModel() {
    *this = ::std::move(from);
  }

  inline ImageSource_PinholeModel& operator=(const ImageSource_PinholeModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageSource_PinholeModel& operator=(ImageSource_PinholeModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageSource_PinholeModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageSource_PinholeModel* internal_default_instance() {
    return reinterpret_cast<const ImageSource_PinholeModel*>(
               &_ImageSource_PinholeModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ImageSource_PinholeModel& a, ImageSource_PinholeModel& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageSource_PinholeModel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageSource_PinholeModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageSource_PinholeModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageSource_PinholeModel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageSource_PinholeModel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageSource_PinholeModel& from) {
    ImageSource_PinholeModel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageSource_PinholeModel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ImageSource.PinholeModel";
  }
  protected:
  explicit ImageSource_PinholeModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ImageSource_PinholeModel_CameraIntrinsics CameraIntrinsics;

  // accessors -------------------------------------------------------

  enum : int {
    kIntrinsicsFieldNumber = 1,
  };
  // .bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics intrinsics = 1;
  bool has_intrinsics() const;
  private:
  bool _internal_has_intrinsics() const;
  public:
  void clear_intrinsics();
  const ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics& intrinsics() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* release_intrinsics();
  ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* mutable_intrinsics();
  void set_allocated_intrinsics(::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* intrinsics);
  private:
  const ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics& _internal_intrinsics() const;
  ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* _internal_mutable_intrinsics();
  public:
  void unsafe_arena_set_allocated_intrinsics(
      ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* intrinsics);
  ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* unsafe_arena_release_intrinsics();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ImageSource.PinholeModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* intrinsics_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class ImageSource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ImageSource) */ {
 public:
  inline ImageSource() : ImageSource(nullptr) {}
  ~ImageSource() override;
  explicit PROTOBUF_CONSTEXPR ImageSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageSource(const ImageSource& from);
  ImageSource(ImageSource&& from) noexcept
    : ImageSource() {
    *this = ::std::move(from);
  }

  inline ImageSource& operator=(const ImageSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageSource& operator=(ImageSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageSource& default_instance() {
    return *internal_default_instance();
  }
  enum CameraModelsCase {
    kPinhole = 8,
    CAMERA_MODELS_NOT_SET = 0,
  };

  static inline const ImageSource* internal_default_instance() {
    return reinterpret_cast<const ImageSource*>(
               &_ImageSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ImageSource& a, ImageSource& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageSource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageSource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageSource& from) {
    ImageSource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ImageSource";
  }
  protected:
  explicit ImageSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ImageSource_PinholeModel PinholeModel;

  typedef ImageSource_ImageType ImageType;
  static constexpr ImageType IMAGE_TYPE_UNKNOWN =
    ImageSource_ImageType_IMAGE_TYPE_UNKNOWN;
  static constexpr ImageType IMAGE_TYPE_VISUAL =
    ImageSource_ImageType_IMAGE_TYPE_VISUAL;
  static constexpr ImageType IMAGE_TYPE_DEPTH =
    ImageSource_ImageType_IMAGE_TYPE_DEPTH;
  static inline bool ImageType_IsValid(int value) {
    return ImageSource_ImageType_IsValid(value);
  }
  static constexpr ImageType ImageType_MIN =
    ImageSource_ImageType_ImageType_MIN;
  static constexpr ImageType ImageType_MAX =
    ImageSource_ImageType_ImageType_MAX;
  static constexpr int ImageType_ARRAYSIZE =
    ImageSource_ImageType_ImageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ImageType_descriptor() {
    return ImageSource_ImageType_descriptor();
  }
  template<typename T>
  static inline const std::string& ImageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ImageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ImageType_Name.");
    return ImageSource_ImageType_Name(enum_t_value);
  }
  static inline bool ImageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ImageType* value) {
    return ImageSource_ImageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPixelFormatsFieldNumber = 10,
    kImageFormatsFieldNumber = 11,
    kNameFieldNumber = 2,
    kColsFieldNumber = 4,
    kRowsFieldNumber = 5,
    kDepthScaleFieldNumber = 6,
    kImageTypeFieldNumber = 9,
    kPinholeFieldNumber = 8,
  };
  // repeated .bosdyn.api.Image.PixelFormat pixel_formats = 10;
  int pixel_formats_size() const;
  private:
  int _internal_pixel_formats_size() const;
  public:
  void clear_pixel_formats();
  private:
  ::bosdyn::api::Image_PixelFormat _internal_pixel_formats(int index) const;
  void _internal_add_pixel_formats(::bosdyn::api::Image_PixelFormat value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_pixel_formats();
  public:
  ::bosdyn::api::Image_PixelFormat pixel_formats(int index) const;
  void set_pixel_formats(int index, ::bosdyn::api::Image_PixelFormat value);
  void add_pixel_formats(::bosdyn::api::Image_PixelFormat value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& pixel_formats() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_pixel_formats();

  // repeated .bosdyn.api.Image.Format image_formats = 11;
  int image_formats_size() const;
  private:
  int _internal_image_formats_size() const;
  public:
  void clear_image_formats();
  private:
  ::bosdyn::api::Image_Format _internal_image_formats(int index) const;
  void _internal_add_image_formats(::bosdyn::api::Image_Format value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_image_formats();
  public:
  ::bosdyn::api::Image_Format image_formats(int index) const;
  void set_image_formats(int index, ::bosdyn::api::Image_Format value);
  void add_image_formats(::bosdyn::api::Image_Format value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& image_formats() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_image_formats();

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 cols = 4;
  void clear_cols();
  int32_t cols() const;
  void set_cols(int32_t value);
  private:
  int32_t _internal_cols() const;
  void _internal_set_cols(int32_t value);
  public:

  // int32 rows = 5;
  void clear_rows();
  int32_t rows() const;
  void set_rows(int32_t value);
  private:
  int32_t _internal_rows() const;
  void _internal_set_rows(int32_t value);
  public:

  // double depth_scale = 6;
  void clear_depth_scale();
  double depth_scale() const;
  void set_depth_scale(double value);
  private:
  double _internal_depth_scale() const;
  void _internal_set_depth_scale(double value);
  public:

  // .bosdyn.api.ImageSource.ImageType image_type = 9;
  void clear_image_type();
  ::bosdyn::api::ImageSource_ImageType image_type() const;
  void set_image_type(::bosdyn::api::ImageSource_ImageType value);
  private:
  ::bosdyn::api::ImageSource_ImageType _internal_image_type() const;
  void _internal_set_image_type(::bosdyn::api::ImageSource_ImageType value);
  public:

  // .bosdyn.api.ImageSource.PinholeModel pinhole = 8;
  bool has_pinhole() const;
  private:
  bool _internal_has_pinhole() const;
  public:
  void clear_pinhole();
  const ::bosdyn::api::ImageSource_PinholeModel& pinhole() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ImageSource_PinholeModel* release_pinhole();
  ::bosdyn::api::ImageSource_PinholeModel* mutable_pinhole();
  void set_allocated_pinhole(::bosdyn::api::ImageSource_PinholeModel* pinhole);
  private:
  const ::bosdyn::api::ImageSource_PinholeModel& _internal_pinhole() const;
  ::bosdyn::api::ImageSource_PinholeModel* _internal_mutable_pinhole();
  public:
  void unsafe_arena_set_allocated_pinhole(
      ::bosdyn::api::ImageSource_PinholeModel* pinhole);
  ::bosdyn::api::ImageSource_PinholeModel* unsafe_arena_release_pinhole();

  void clear_camera_models();
  CameraModelsCase camera_models_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.ImageSource)
 private:
  class _Internal;
  void set_has_pinhole();

  inline bool has_camera_models() const;
  inline void clear_has_camera_models();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> pixel_formats_;
    mutable std::atomic<int> _pixel_formats_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> image_formats_;
    mutable std::atomic<int> _image_formats_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t cols_;
    int32_t rows_;
    double depth_scale_;
    int image_type_;
    union CameraModelsUnion {
      constexpr CameraModelsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::ImageSource_PinholeModel* pinhole_;
    } camera_models_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class ListImageSourcesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListImageSourcesRequest) */ {
 public:
  inline ListImageSourcesRequest() : ListImageSourcesRequest(nullptr) {}
  ~ListImageSourcesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListImageSourcesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListImageSourcesRequest(const ListImageSourcesRequest& from);
  ListImageSourcesRequest(ListImageSourcesRequest&& from) noexcept
    : ListImageSourcesRequest() {
    *this = ::std::move(from);
  }

  inline ListImageSourcesRequest& operator=(const ListImageSourcesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListImageSourcesRequest& operator=(ListImageSourcesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListImageSourcesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListImageSourcesRequest* internal_default_instance() {
    return reinterpret_cast<const ListImageSourcesRequest*>(
               &_ListImageSourcesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListImageSourcesRequest& a, ListImageSourcesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListImageSourcesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListImageSourcesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListImageSourcesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListImageSourcesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListImageSourcesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListImageSourcesRequest& from) {
    ListImageSourcesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListImageSourcesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListImageSourcesRequest";
  }
  protected:
  explicit ListImageSourcesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListImageSourcesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class ListImageSourcesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListImageSourcesResponse) */ {
 public:
  inline ListImageSourcesResponse() : ListImageSourcesResponse(nullptr) {}
  ~ListImageSourcesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListImageSourcesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListImageSourcesResponse(const ListImageSourcesResponse& from);
  ListImageSourcesResponse(ListImageSourcesResponse&& from) noexcept
    : ListImageSourcesResponse() {
    *this = ::std::move(from);
  }

  inline ListImageSourcesResponse& operator=(const ListImageSourcesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListImageSourcesResponse& operator=(ListImageSourcesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListImageSourcesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListImageSourcesResponse* internal_default_instance() {
    return reinterpret_cast<const ListImageSourcesResponse*>(
               &_ListImageSourcesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListImageSourcesResponse& a, ListImageSourcesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListImageSourcesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListImageSourcesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListImageSourcesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListImageSourcesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListImageSourcesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListImageSourcesResponse& from) {
    ListImageSourcesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListImageSourcesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListImageSourcesResponse";
  }
  protected:
  explicit ListImageSourcesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageSourcesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.ImageSource image_sources = 2;
  int image_sources_size() const;
  private:
  int _internal_image_sources_size() const;
  public:
  void clear_image_sources();
  ::bosdyn::api::ImageSource* mutable_image_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSource >*
      mutable_image_sources();
  private:
  const ::bosdyn::api::ImageSource& _internal_image_sources(int index) const;
  ::bosdyn::api::ImageSource* _internal_add_image_sources();
  public:
  const ::bosdyn::api::ImageSource& image_sources(int index) const;
  ::bosdyn::api::ImageSource* add_image_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSource >&
      image_sources() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListImageSourcesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSource > image_sources_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class ImageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ImageRequest) */ {
 public:
  inline ImageRequest() : ImageRequest(nullptr) {}
  ~ImageRequest() override;
  explicit PROTOBUF_CONSTEXPR ImageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageRequest(const ImageRequest& from);
  ImageRequest(ImageRequest&& from) noexcept
    : ImageRequest() {
    *this = ::std::move(from);
  }

  inline ImageRequest& operator=(const ImageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageRequest& operator=(ImageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageRequest* internal_default_instance() {
    return reinterpret_cast<const ImageRequest*>(
               &_ImageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ImageRequest& a, ImageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageRequest& from) {
    ImageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ImageRequest";
  }
  protected:
  explicit ImageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageSourceNameFieldNumber = 1,
    kQualityPercentFieldNumber = 2,
    kResizeRatioFieldNumber = 4,
    kImageFormatFieldNumber = 3,
    kPixelFormatFieldNumber = 5,
  };
  // string image_source_name = 1;
  void clear_image_source_name();
  const std::string& image_source_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_source_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_source_name();
  PROTOBUF_NODISCARD std::string* release_image_source_name();
  void set_allocated_image_source_name(std::string* image_source_name);
  private:
  const std::string& _internal_image_source_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_source_name(const std::string& value);
  std::string* _internal_mutable_image_source_name();
  public:

  // double quality_percent = 2;
  void clear_quality_percent();
  double quality_percent() const;
  void set_quality_percent(double value);
  private:
  double _internal_quality_percent() const;
  void _internal_set_quality_percent(double value);
  public:

  // double resize_ratio = 4;
  void clear_resize_ratio();
  double resize_ratio() const;
  void set_resize_ratio(double value);
  private:
  double _internal_resize_ratio() const;
  void _internal_set_resize_ratio(double value);
  public:

  // .bosdyn.api.Image.Format image_format = 3;
  void clear_image_format();
  ::bosdyn::api::Image_Format image_format() const;
  void set_image_format(::bosdyn::api::Image_Format value);
  private:
  ::bosdyn::api::Image_Format _internal_image_format() const;
  void _internal_set_image_format(::bosdyn::api::Image_Format value);
  public:

  // .bosdyn.api.Image.PixelFormat pixel_format = 5;
  void clear_pixel_format();
  ::bosdyn::api::Image_PixelFormat pixel_format() const;
  void set_pixel_format(::bosdyn::api::Image_PixelFormat value);
  private:
  ::bosdyn::api::Image_PixelFormat _internal_pixel_format() const;
  void _internal_set_pixel_format(::bosdyn::api::Image_PixelFormat value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ImageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_source_name_;
    double quality_percent_;
    double resize_ratio_;
    int image_format_;
    int pixel_format_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class GetImageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetImageRequest) */ {
 public:
  inline GetImageRequest() : GetImageRequest(nullptr) {}
  ~GetImageRequest() override;
  explicit PROTOBUF_CONSTEXPR GetImageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetImageRequest(const GetImageRequest& from);
  GetImageRequest(GetImageRequest&& from) noexcept
    : GetImageRequest() {
    *this = ::std::move(from);
  }

  inline GetImageRequest& operator=(const GetImageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetImageRequest& operator=(GetImageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetImageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetImageRequest* internal_default_instance() {
    return reinterpret_cast<const GetImageRequest*>(
               &_GetImageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetImageRequest& a, GetImageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetImageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetImageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetImageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetImageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetImageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetImageRequest& from) {
    GetImageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetImageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetImageRequest";
  }
  protected:
  explicit GetImageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageRequestsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.ImageRequest image_requests = 2;
  int image_requests_size() const;
  private:
  int _internal_image_requests_size() const;
  public:
  void clear_image_requests();
  ::bosdyn::api::ImageRequest* mutable_image_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageRequest >*
      mutable_image_requests();
  private:
  const ::bosdyn::api::ImageRequest& _internal_image_requests(int index) const;
  ::bosdyn::api::ImageRequest* _internal_add_image_requests();
  public:
  const ::bosdyn::api::ImageRequest& image_requests(int index) const;
  ::bosdyn::api::ImageRequest* add_image_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageRequest >&
      image_requests() const;

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetImageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageRequest > image_requests_;
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class ImageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ImageResponse) */ {
 public:
  inline ImageResponse() : ImageResponse(nullptr) {}
  ~ImageResponse() override;
  explicit PROTOBUF_CONSTEXPR ImageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageResponse(const ImageResponse& from);
  ImageResponse(ImageResponse&& from) noexcept
    : ImageResponse() {
    *this = ::std::move(from);
  }

  inline ImageResponse& operator=(const ImageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageResponse& operator=(ImageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageResponse* internal_default_instance() {
    return reinterpret_cast<const ImageResponse*>(
               &_ImageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ImageResponse& a, ImageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageResponse& from) {
    ImageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ImageResponse";
  }
  protected:
  explicit ImageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ImageResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    ImageResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    ImageResponse_Status_STATUS_OK;
  static constexpr Status STATUS_UNKNOWN_CAMERA =
    ImageResponse_Status_STATUS_UNKNOWN_CAMERA;
  static constexpr Status STATUS_SOURCE_DATA_ERROR =
    ImageResponse_Status_STATUS_SOURCE_DATA_ERROR;
  static constexpr Status STATUS_IMAGE_DATA_ERROR =
    ImageResponse_Status_STATUS_IMAGE_DATA_ERROR;
  static constexpr Status STATUS_UNSUPPORTED_IMAGE_FORMAT_REQUESTED =
    ImageResponse_Status_STATUS_UNSUPPORTED_IMAGE_FORMAT_REQUESTED;
  static constexpr Status STATUS_UNSUPPORTED_PIXEL_FORMAT_REQUESTED =
    ImageResponse_Status_STATUS_UNSUPPORTED_PIXEL_FORMAT_REQUESTED;
  static constexpr Status STATUS_UNSUPPORTED_RESIZE_RATIO_REQUESTED =
    ImageResponse_Status_STATUS_UNSUPPORTED_RESIZE_RATIO_REQUESTED;
  static inline bool Status_IsValid(int value) {
    return ImageResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ImageResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ImageResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ImageResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return ImageResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ImageResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return ImageResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kShotFieldNumber = 1,
    kSourceFieldNumber = 2,
    kStatusFieldNumber = 4,
  };
  // .bosdyn.api.ImageCapture shot = 1;
  bool has_shot() const;
  private:
  bool _internal_has_shot() const;
  public:
  void clear_shot();
  const ::bosdyn::api::ImageCapture& shot() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ImageCapture* release_shot();
  ::bosdyn::api::ImageCapture* mutable_shot();
  void set_allocated_shot(::bosdyn::api::ImageCapture* shot);
  private:
  const ::bosdyn::api::ImageCapture& _internal_shot() const;
  ::bosdyn::api::ImageCapture* _internal_mutable_shot();
  public:
  void unsafe_arena_set_allocated_shot(
      ::bosdyn::api::ImageCapture* shot);
  ::bosdyn::api::ImageCapture* unsafe_arena_release_shot();

  // .bosdyn.api.ImageSource source = 2;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::bosdyn::api::ImageSource& source() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ImageSource* release_source();
  ::bosdyn::api::ImageSource* mutable_source();
  void set_allocated_source(::bosdyn::api::ImageSource* source);
  private:
  const ::bosdyn::api::ImageSource& _internal_source() const;
  ::bosdyn::api::ImageSource* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::bosdyn::api::ImageSource* source);
  ::bosdyn::api::ImageSource* unsafe_arena_release_source();

  // .bosdyn.api.ImageResponse.Status status = 4;
  void clear_status();
  ::bosdyn::api::ImageResponse_Status status() const;
  void set_status(::bosdyn::api::ImageResponse_Status value);
  private:
  ::bosdyn::api::ImageResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::ImageResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ImageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ImageCapture* shot_;
    ::bosdyn::api::ImageSource* source_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class GetImageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetImageResponse) */ {
 public:
  inline GetImageResponse() : GetImageResponse(nullptr) {}
  ~GetImageResponse() override;
  explicit PROTOBUF_CONSTEXPR GetImageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetImageResponse(const GetImageResponse& from);
  GetImageResponse(GetImageResponse&& from) noexcept
    : GetImageResponse() {
    *this = ::std::move(from);
  }

  inline GetImageResponse& operator=(const GetImageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetImageResponse& operator=(GetImageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetImageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetImageResponse* internal_default_instance() {
    return reinterpret_cast<const GetImageResponse*>(
               &_GetImageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetImageResponse& a, GetImageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetImageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetImageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetImageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetImageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetImageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetImageResponse& from) {
    GetImageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetImageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetImageResponse";
  }
  protected:
  explicit GetImageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageResponsesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.ImageResponse image_responses = 2;
  int image_responses_size() const;
  private:
  int _internal_image_responses_size() const;
  public:
  void clear_image_responses();
  ::bosdyn::api::ImageResponse* mutable_image_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageResponse >*
      mutable_image_responses();
  private:
  const ::bosdyn::api::ImageResponse& _internal_image_responses(int index) const;
  ::bosdyn::api::ImageResponse* _internal_add_image_responses();
  public:
  const ::bosdyn::api::ImageResponse& image_responses(int index) const;
  ::bosdyn::api::ImageResponse* add_image_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageResponse >&
      image_responses() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetImageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageResponse > image_responses_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Image

// int32 cols = 2;
inline void Image::clear_cols() {
  _impl_.cols_ = 0;
}
inline int32_t Image::_internal_cols() const {
  return _impl_.cols_;
}
inline int32_t Image::cols() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Image.cols)
  return _internal_cols();
}
inline void Image::_internal_set_cols(int32_t value) {
  
  _impl_.cols_ = value;
}
inline void Image::set_cols(int32_t value) {
  _internal_set_cols(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Image.cols)
}

// int32 rows = 3;
inline void Image::clear_rows() {
  _impl_.rows_ = 0;
}
inline int32_t Image::_internal_rows() const {
  return _impl_.rows_;
}
inline int32_t Image::rows() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Image.rows)
  return _internal_rows();
}
inline void Image::_internal_set_rows(int32_t value) {
  
  _impl_.rows_ = value;
}
inline void Image::set_rows(int32_t value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Image.rows)
}

// bytes data = 4;
inline void Image::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Image::data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Image.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.Image.data)
}
inline std::string* Image::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Image.data)
  return _s;
}
inline const std::string& Image::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Image::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Image::release_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Image.data)
  return _impl_.data_.Release();
}
inline void Image::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Image.data)
}

// .bosdyn.api.Image.Format format = 5;
inline void Image::clear_format() {
  _impl_.format_ = 0;
}
inline ::bosdyn::api::Image_Format Image::_internal_format() const {
  return static_cast< ::bosdyn::api::Image_Format >(_impl_.format_);
}
inline ::bosdyn::api::Image_Format Image::format() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Image.format)
  return _internal_format();
}
inline void Image::_internal_set_format(::bosdyn::api::Image_Format value) {
  
  _impl_.format_ = value;
}
inline void Image::set_format(::bosdyn::api::Image_Format value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Image.format)
}

// .bosdyn.api.Image.PixelFormat pixel_format = 6;
inline void Image::clear_pixel_format() {
  _impl_.pixel_format_ = 0;
}
inline ::bosdyn::api::Image_PixelFormat Image::_internal_pixel_format() const {
  return static_cast< ::bosdyn::api::Image_PixelFormat >(_impl_.pixel_format_);
}
inline ::bosdyn::api::Image_PixelFormat Image::pixel_format() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Image.pixel_format)
  return _internal_pixel_format();
}
inline void Image::_internal_set_pixel_format(::bosdyn::api::Image_PixelFormat value) {
  
  _impl_.pixel_format_ = value;
}
inline void Image::set_pixel_format(::bosdyn::api::Image_PixelFormat value) {
  _internal_set_pixel_format(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Image.pixel_format)
}

// -------------------------------------------------------------------

// CaptureParameters

// .google.protobuf.Duration exposure_duration = 1;
inline bool CaptureParameters::_internal_has_exposure_duration() const {
  return this != internal_default_instance() && _impl_.exposure_duration_ != nullptr;
}
inline bool CaptureParameters::has_exposure_duration() const {
  return _internal_has_exposure_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& CaptureParameters::_internal_exposure_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.exposure_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& CaptureParameters::exposure_duration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CaptureParameters.exposure_duration)
  return _internal_exposure_duration();
}
inline void CaptureParameters::unsafe_arena_set_allocated_exposure_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* exposure_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.exposure_duration_);
  }
  _impl_.exposure_duration_ = exposure_duration;
  if (exposure_duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.CaptureParameters.exposure_duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CaptureParameters::release_exposure_duration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.exposure_duration_;
  _impl_.exposure_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CaptureParameters::unsafe_arena_release_exposure_duration() {
  // @@protoc_insertion_point(field_release:bosdyn.api.CaptureParameters.exposure_duration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.exposure_duration_;
  _impl_.exposure_duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CaptureParameters::_internal_mutable_exposure_duration() {
  
  if (_impl_.exposure_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.exposure_duration_ = p;
  }
  return _impl_.exposure_duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CaptureParameters::mutable_exposure_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_exposure_duration();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.CaptureParameters.exposure_duration)
  return _msg;
}
inline void CaptureParameters::set_allocated_exposure_duration(::PROTOBUF_NAMESPACE_ID::Duration* exposure_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.exposure_duration_);
  }
  if (exposure_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(exposure_duration));
    if (message_arena != submessage_arena) {
      exposure_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exposure_duration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.exposure_duration_ = exposure_duration;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.CaptureParameters.exposure_duration)
}

// double gain = 2;
inline void CaptureParameters::clear_gain() {
  _impl_.gain_ = 0;
}
inline double CaptureParameters::_internal_gain() const {
  return _impl_.gain_;
}
inline double CaptureParameters::gain() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CaptureParameters.gain)
  return _internal_gain();
}
inline void CaptureParameters::_internal_set_gain(double value) {
  
  _impl_.gain_ = value;
}
inline void CaptureParameters::set_gain(double value) {
  _internal_set_gain(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.CaptureParameters.gain)
}

// -------------------------------------------------------------------

// ImageCapture

// .google.protobuf.Timestamp acquisition_time = 30;
inline bool ImageCapture::_internal_has_acquisition_time() const {
  return this != internal_default_instance() && _impl_.acquisition_time_ != nullptr;
}
inline bool ImageCapture::has_acquisition_time() const {
  return _internal_has_acquisition_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ImageCapture::_internal_acquisition_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.acquisition_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ImageCapture::acquisition_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageCapture.acquisition_time)
  return _internal_acquisition_time();
}
inline void ImageCapture::unsafe_arena_set_allocated_acquisition_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acquisition_time_);
  }
  _impl_.acquisition_time_ = acquisition_time;
  if (acquisition_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageCapture.acquisition_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ImageCapture::release_acquisition_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.acquisition_time_;
  _impl_.acquisition_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ImageCapture::unsafe_arena_release_acquisition_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageCapture.acquisition_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.acquisition_time_;
  _impl_.acquisition_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ImageCapture::_internal_mutable_acquisition_time() {
  
  if (_impl_.acquisition_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.acquisition_time_ = p;
  }
  return _impl_.acquisition_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ImageCapture::mutable_acquisition_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_acquisition_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageCapture.acquisition_time)
  return _msg;
}
inline void ImageCapture::set_allocated_acquisition_time(::PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acquisition_time_);
  }
  if (acquisition_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acquisition_time));
    if (message_arena != submessage_arena) {
      acquisition_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acquisition_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.acquisition_time_ = acquisition_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageCapture.acquisition_time)
}

// .bosdyn.api.FrameTreeSnapshot transforms_snapshot = 31;
inline bool ImageCapture::_internal_has_transforms_snapshot() const {
  return this != internal_default_instance() && _impl_.transforms_snapshot_ != nullptr;
}
inline bool ImageCapture::has_transforms_snapshot() const {
  return _internal_has_transforms_snapshot();
}
inline const ::bosdyn::api::FrameTreeSnapshot& ImageCapture::_internal_transforms_snapshot() const {
  const ::bosdyn::api::FrameTreeSnapshot* p = _impl_.transforms_snapshot_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::FrameTreeSnapshot&>(
      ::bosdyn::api::_FrameTreeSnapshot_default_instance_);
}
inline const ::bosdyn::api::FrameTreeSnapshot& ImageCapture::transforms_snapshot() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageCapture.transforms_snapshot)
  return _internal_transforms_snapshot();
}
inline void ImageCapture::unsafe_arena_set_allocated_transforms_snapshot(
    ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transforms_snapshot_);
  }
  _impl_.transforms_snapshot_ = transforms_snapshot;
  if (transforms_snapshot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageCapture.transforms_snapshot)
}
inline ::bosdyn::api::FrameTreeSnapshot* ImageCapture::release_transforms_snapshot() {
  
  ::bosdyn::api::FrameTreeSnapshot* temp = _impl_.transforms_snapshot_;
  _impl_.transforms_snapshot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::FrameTreeSnapshot* ImageCapture::unsafe_arena_release_transforms_snapshot() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageCapture.transforms_snapshot)
  
  ::bosdyn::api::FrameTreeSnapshot* temp = _impl_.transforms_snapshot_;
  _impl_.transforms_snapshot_ = nullptr;
  return temp;
}
inline ::bosdyn::api::FrameTreeSnapshot* ImageCapture::_internal_mutable_transforms_snapshot() {
  
  if (_impl_.transforms_snapshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::FrameTreeSnapshot>(GetArenaForAllocation());
    _impl_.transforms_snapshot_ = p;
  }
  return _impl_.transforms_snapshot_;
}
inline ::bosdyn::api::FrameTreeSnapshot* ImageCapture::mutable_transforms_snapshot() {
  ::bosdyn::api::FrameTreeSnapshot* _msg = _internal_mutable_transforms_snapshot();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageCapture.transforms_snapshot)
  return _msg;
}
inline void ImageCapture::set_allocated_transforms_snapshot(::bosdyn::api::FrameTreeSnapshot* transforms_snapshot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transforms_snapshot_);
  }
  if (transforms_snapshot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transforms_snapshot));
    if (message_arena != submessage_arena) {
      transforms_snapshot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transforms_snapshot, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transforms_snapshot_ = transforms_snapshot;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageCapture.transforms_snapshot)
}

// string frame_name_image_sensor = 5;
inline void ImageCapture::clear_frame_name_image_sensor() {
  _impl_.frame_name_image_sensor_.ClearToEmpty();
}
inline const std::string& ImageCapture::frame_name_image_sensor() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageCapture.frame_name_image_sensor)
  return _internal_frame_name_image_sensor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageCapture::set_frame_name_image_sensor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_image_sensor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageCapture.frame_name_image_sensor)
}
inline std::string* ImageCapture::mutable_frame_name_image_sensor() {
  std::string* _s = _internal_mutable_frame_name_image_sensor();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageCapture.frame_name_image_sensor)
  return _s;
}
inline const std::string& ImageCapture::_internal_frame_name_image_sensor() const {
  return _impl_.frame_name_image_sensor_.Get();
}
inline void ImageCapture::_internal_set_frame_name_image_sensor(const std::string& value) {
  
  _impl_.frame_name_image_sensor_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageCapture::_internal_mutable_frame_name_image_sensor() {
  
  return _impl_.frame_name_image_sensor_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageCapture::release_frame_name_image_sensor() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageCapture.frame_name_image_sensor)
  return _impl_.frame_name_image_sensor_.Release();
}
inline void ImageCapture::set_allocated_frame_name_image_sensor(std::string* frame_name_image_sensor) {
  if (frame_name_image_sensor != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_image_sensor_.SetAllocated(frame_name_image_sensor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_image_sensor_.IsDefault()) {
    _impl_.frame_name_image_sensor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageCapture.frame_name_image_sensor)
}

// .bosdyn.api.Image image = 3;
inline bool ImageCapture::_internal_has_image() const {
  return this != internal_default_instance() && _impl_.image_ != nullptr;
}
inline bool ImageCapture::has_image() const {
  return _internal_has_image();
}
inline void ImageCapture::clear_image() {
  if (GetArenaForAllocation() == nullptr && _impl_.image_ != nullptr) {
    delete _impl_.image_;
  }
  _impl_.image_ = nullptr;
}
inline const ::bosdyn::api::Image& ImageCapture::_internal_image() const {
  const ::bosdyn::api::Image* p = _impl_.image_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Image&>(
      ::bosdyn::api::_Image_default_instance_);
}
inline const ::bosdyn::api::Image& ImageCapture::image() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageCapture.image)
  return _internal_image();
}
inline void ImageCapture::unsafe_arena_set_allocated_image(
    ::bosdyn::api::Image* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  _impl_.image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageCapture.image)
}
inline ::bosdyn::api::Image* ImageCapture::release_image() {
  
  ::bosdyn::api::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Image* ImageCapture::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageCapture.image)
  
  ::bosdyn::api::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Image* ImageCapture::_internal_mutable_image() {
  
  if (_impl_.image_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Image>(GetArenaForAllocation());
    _impl_.image_ = p;
  }
  return _impl_.image_;
}
inline ::bosdyn::api::Image* ImageCapture::mutable_image() {
  ::bosdyn::api::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageCapture.image)
  return _msg;
}
inline void ImageCapture::set_allocated_image(::bosdyn::api::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_ = image;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageCapture.image)
}

// .bosdyn.api.CaptureParameters capture_params = 4;
inline bool ImageCapture::_internal_has_capture_params() const {
  return this != internal_default_instance() && _impl_.capture_params_ != nullptr;
}
inline bool ImageCapture::has_capture_params() const {
  return _internal_has_capture_params();
}
inline void ImageCapture::clear_capture_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.capture_params_ != nullptr) {
    delete _impl_.capture_params_;
  }
  _impl_.capture_params_ = nullptr;
}
inline const ::bosdyn::api::CaptureParameters& ImageCapture::_internal_capture_params() const {
  const ::bosdyn::api::CaptureParameters* p = _impl_.capture_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::CaptureParameters&>(
      ::bosdyn::api::_CaptureParameters_default_instance_);
}
inline const ::bosdyn::api::CaptureParameters& ImageCapture::capture_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageCapture.capture_params)
  return _internal_capture_params();
}
inline void ImageCapture::unsafe_arena_set_allocated_capture_params(
    ::bosdyn::api::CaptureParameters* capture_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capture_params_);
  }
  _impl_.capture_params_ = capture_params;
  if (capture_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageCapture.capture_params)
}
inline ::bosdyn::api::CaptureParameters* ImageCapture::release_capture_params() {
  
  ::bosdyn::api::CaptureParameters* temp = _impl_.capture_params_;
  _impl_.capture_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::CaptureParameters* ImageCapture::unsafe_arena_release_capture_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageCapture.capture_params)
  
  ::bosdyn::api::CaptureParameters* temp = _impl_.capture_params_;
  _impl_.capture_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::CaptureParameters* ImageCapture::_internal_mutable_capture_params() {
  
  if (_impl_.capture_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::CaptureParameters>(GetArenaForAllocation());
    _impl_.capture_params_ = p;
  }
  return _impl_.capture_params_;
}
inline ::bosdyn::api::CaptureParameters* ImageCapture::mutable_capture_params() {
  ::bosdyn::api::CaptureParameters* _msg = _internal_mutable_capture_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageCapture.capture_params)
  return _msg;
}
inline void ImageCapture::set_allocated_capture_params(::bosdyn::api::CaptureParameters* capture_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.capture_params_;
  }
  if (capture_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(capture_params);
    if (message_arena != submessage_arena) {
      capture_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capture_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.capture_params_ = capture_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageCapture.capture_params)
}

// -------------------------------------------------------------------

// ImageSource_PinholeModel_CameraIntrinsics

// .bosdyn.api.Vec2 focal_length = 1;
inline bool ImageSource_PinholeModel_CameraIntrinsics::_internal_has_focal_length() const {
  return this != internal_default_instance() && _impl_.focal_length_ != nullptr;
}
inline bool ImageSource_PinholeModel_CameraIntrinsics::has_focal_length() const {
  return _internal_has_focal_length();
}
inline const ::bosdyn::api::Vec2& ImageSource_PinholeModel_CameraIntrinsics::_internal_focal_length() const {
  const ::bosdyn::api::Vec2* p = _impl_.focal_length_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec2&>(
      ::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& ImageSource_PinholeModel_CameraIntrinsics::focal_length() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.focal_length)
  return _internal_focal_length();
}
inline void ImageSource_PinholeModel_CameraIntrinsics::unsafe_arena_set_allocated_focal_length(
    ::bosdyn::api::Vec2* focal_length) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.focal_length_);
  }
  _impl_.focal_length_ = focal_length;
  if (focal_length) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.focal_length)
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::release_focal_length() {
  
  ::bosdyn::api::Vec2* temp = _impl_.focal_length_;
  _impl_.focal_length_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::unsafe_arena_release_focal_length() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.focal_length)
  
  ::bosdyn::api::Vec2* temp = _impl_.focal_length_;
  _impl_.focal_length_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::_internal_mutable_focal_length() {
  
  if (_impl_.focal_length_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArenaForAllocation());
    _impl_.focal_length_ = p;
  }
  return _impl_.focal_length_;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::mutable_focal_length() {
  ::bosdyn::api::Vec2* _msg = _internal_mutable_focal_length();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.focal_length)
  return _msg;
}
inline void ImageSource_PinholeModel_CameraIntrinsics::set_allocated_focal_length(::bosdyn::api::Vec2* focal_length) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.focal_length_);
  }
  if (focal_length) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(focal_length));
    if (message_arena != submessage_arena) {
      focal_length = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, focal_length, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.focal_length_ = focal_length;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.focal_length)
}

// .bosdyn.api.Vec2 principal_point = 2;
inline bool ImageSource_PinholeModel_CameraIntrinsics::_internal_has_principal_point() const {
  return this != internal_default_instance() && _impl_.principal_point_ != nullptr;
}
inline bool ImageSource_PinholeModel_CameraIntrinsics::has_principal_point() const {
  return _internal_has_principal_point();
}
inline const ::bosdyn::api::Vec2& ImageSource_PinholeModel_CameraIntrinsics::_internal_principal_point() const {
  const ::bosdyn::api::Vec2* p = _impl_.principal_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec2&>(
      ::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& ImageSource_PinholeModel_CameraIntrinsics::principal_point() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.principal_point)
  return _internal_principal_point();
}
inline void ImageSource_PinholeModel_CameraIntrinsics::unsafe_arena_set_allocated_principal_point(
    ::bosdyn::api::Vec2* principal_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.principal_point_);
  }
  _impl_.principal_point_ = principal_point;
  if (principal_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.principal_point)
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::release_principal_point() {
  
  ::bosdyn::api::Vec2* temp = _impl_.principal_point_;
  _impl_.principal_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::unsafe_arena_release_principal_point() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.principal_point)
  
  ::bosdyn::api::Vec2* temp = _impl_.principal_point_;
  _impl_.principal_point_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::_internal_mutable_principal_point() {
  
  if (_impl_.principal_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArenaForAllocation());
    _impl_.principal_point_ = p;
  }
  return _impl_.principal_point_;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::mutable_principal_point() {
  ::bosdyn::api::Vec2* _msg = _internal_mutable_principal_point();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.principal_point)
  return _msg;
}
inline void ImageSource_PinholeModel_CameraIntrinsics::set_allocated_principal_point(::bosdyn::api::Vec2* principal_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.principal_point_);
  }
  if (principal_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(principal_point));
    if (message_arena != submessage_arena) {
      principal_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, principal_point, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.principal_point_ = principal_point;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.principal_point)
}

// .bosdyn.api.Vec2 skew = 3;
inline bool ImageSource_PinholeModel_CameraIntrinsics::_internal_has_skew() const {
  return this != internal_default_instance() && _impl_.skew_ != nullptr;
}
inline bool ImageSource_PinholeModel_CameraIntrinsics::has_skew() const {
  return _internal_has_skew();
}
inline const ::bosdyn::api::Vec2& ImageSource_PinholeModel_CameraIntrinsics::_internal_skew() const {
  const ::bosdyn::api::Vec2* p = _impl_.skew_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec2&>(
      ::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& ImageSource_PinholeModel_CameraIntrinsics::skew() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.skew)
  return _internal_skew();
}
inline void ImageSource_PinholeModel_CameraIntrinsics::unsafe_arena_set_allocated_skew(
    ::bosdyn::api::Vec2* skew) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.skew_);
  }
  _impl_.skew_ = skew;
  if (skew) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.skew)
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::release_skew() {
  
  ::bosdyn::api::Vec2* temp = _impl_.skew_;
  _impl_.skew_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::unsafe_arena_release_skew() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.skew)
  
  ::bosdyn::api::Vec2* temp = _impl_.skew_;
  _impl_.skew_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::_internal_mutable_skew() {
  
  if (_impl_.skew_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArenaForAllocation());
    _impl_.skew_ = p;
  }
  return _impl_.skew_;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::mutable_skew() {
  ::bosdyn::api::Vec2* _msg = _internal_mutable_skew();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.skew)
  return _msg;
}
inline void ImageSource_PinholeModel_CameraIntrinsics::set_allocated_skew(::bosdyn::api::Vec2* skew) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.skew_);
  }
  if (skew) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(skew));
    if (message_arena != submessage_arena) {
      skew = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, skew, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.skew_ = skew;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.skew)
}

// -------------------------------------------------------------------

// ImageSource_PinholeModel

// .bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics intrinsics = 1;
inline bool ImageSource_PinholeModel::_internal_has_intrinsics() const {
  return this != internal_default_instance() && _impl_.intrinsics_ != nullptr;
}
inline bool ImageSource_PinholeModel::has_intrinsics() const {
  return _internal_has_intrinsics();
}
inline void ImageSource_PinholeModel::clear_intrinsics() {
  if (GetArenaForAllocation() == nullptr && _impl_.intrinsics_ != nullptr) {
    delete _impl_.intrinsics_;
  }
  _impl_.intrinsics_ = nullptr;
}
inline const ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics& ImageSource_PinholeModel::_internal_intrinsics() const {
  const ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* p = _impl_.intrinsics_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics&>(
      ::bosdyn::api::_ImageSource_PinholeModel_CameraIntrinsics_default_instance_);
}
inline const ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics& ImageSource_PinholeModel::intrinsics() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.PinholeModel.intrinsics)
  return _internal_intrinsics();
}
inline void ImageSource_PinholeModel::unsafe_arena_set_allocated_intrinsics(
    ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* intrinsics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.intrinsics_);
  }
  _impl_.intrinsics_ = intrinsics;
  if (intrinsics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageSource.PinholeModel.intrinsics)
}
inline ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* ImageSource_PinholeModel::release_intrinsics() {
  
  ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* temp = _impl_.intrinsics_;
  _impl_.intrinsics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* ImageSource_PinholeModel::unsafe_arena_release_intrinsics() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSource.PinholeModel.intrinsics)
  
  ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* temp = _impl_.intrinsics_;
  _impl_.intrinsics_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* ImageSource_PinholeModel::_internal_mutable_intrinsics() {
  
  if (_impl_.intrinsics_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics>(GetArenaForAllocation());
    _impl_.intrinsics_ = p;
  }
  return _impl_.intrinsics_;
}
inline ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* ImageSource_PinholeModel::mutable_intrinsics() {
  ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* _msg = _internal_mutable_intrinsics();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSource.PinholeModel.intrinsics)
  return _msg;
}
inline void ImageSource_PinholeModel::set_allocated_intrinsics(::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* intrinsics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.intrinsics_;
  }
  if (intrinsics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(intrinsics);
    if (message_arena != submessage_arena) {
      intrinsics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intrinsics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.intrinsics_ = intrinsics;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageSource.PinholeModel.intrinsics)
}

// -------------------------------------------------------------------

// ImageSource

// string name = 2;
inline void ImageSource::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ImageSource::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageSource::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSource.name)
}
inline std::string* ImageSource::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSource.name)
  return _s;
}
inline const std::string& ImageSource::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ImageSource::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageSource::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageSource::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSource.name)
  return _impl_.name_.Release();
}
inline void ImageSource::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageSource.name)
}

// int32 cols = 4;
inline void ImageSource::clear_cols() {
  _impl_.cols_ = 0;
}
inline int32_t ImageSource::_internal_cols() const {
  return _impl_.cols_;
}
inline int32_t ImageSource::cols() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.cols)
  return _internal_cols();
}
inline void ImageSource::_internal_set_cols(int32_t value) {
  
  _impl_.cols_ = value;
}
inline void ImageSource::set_cols(int32_t value) {
  _internal_set_cols(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSource.cols)
}

// int32 rows = 5;
inline void ImageSource::clear_rows() {
  _impl_.rows_ = 0;
}
inline int32_t ImageSource::_internal_rows() const {
  return _impl_.rows_;
}
inline int32_t ImageSource::rows() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.rows)
  return _internal_rows();
}
inline void ImageSource::_internal_set_rows(int32_t value) {
  
  _impl_.rows_ = value;
}
inline void ImageSource::set_rows(int32_t value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSource.rows)
}

// double depth_scale = 6;
inline void ImageSource::clear_depth_scale() {
  _impl_.depth_scale_ = 0;
}
inline double ImageSource::_internal_depth_scale() const {
  return _impl_.depth_scale_;
}
inline double ImageSource::depth_scale() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.depth_scale)
  return _internal_depth_scale();
}
inline void ImageSource::_internal_set_depth_scale(double value) {
  
  _impl_.depth_scale_ = value;
}
inline void ImageSource::set_depth_scale(double value) {
  _internal_set_depth_scale(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSource.depth_scale)
}

// .bosdyn.api.ImageSource.PinholeModel pinhole = 8;
inline bool ImageSource::_internal_has_pinhole() const {
  return camera_models_case() == kPinhole;
}
inline bool ImageSource::has_pinhole() const {
  return _internal_has_pinhole();
}
inline void ImageSource::set_has_pinhole() {
  _impl_._oneof_case_[0] = kPinhole;
}
inline void ImageSource::clear_pinhole() {
  if (_internal_has_pinhole()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.camera_models_.pinhole_;
    }
    clear_has_camera_models();
  }
}
inline ::bosdyn::api::ImageSource_PinholeModel* ImageSource::release_pinhole() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSource.pinhole)
  if (_internal_has_pinhole()) {
    clear_has_camera_models();
    ::bosdyn::api::ImageSource_PinholeModel* temp = _impl_.camera_models_.pinhole_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.camera_models_.pinhole_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::ImageSource_PinholeModel& ImageSource::_internal_pinhole() const {
  return _internal_has_pinhole()
      ? *_impl_.camera_models_.pinhole_
      : reinterpret_cast< ::bosdyn::api::ImageSource_PinholeModel&>(::bosdyn::api::_ImageSource_PinholeModel_default_instance_);
}
inline const ::bosdyn::api::ImageSource_PinholeModel& ImageSource::pinhole() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.pinhole)
  return _internal_pinhole();
}
inline ::bosdyn::api::ImageSource_PinholeModel* ImageSource::unsafe_arena_release_pinhole() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.ImageSource.pinhole)
  if (_internal_has_pinhole()) {
    clear_has_camera_models();
    ::bosdyn::api::ImageSource_PinholeModel* temp = _impl_.camera_models_.pinhole_;
    _impl_.camera_models_.pinhole_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ImageSource::unsafe_arena_set_allocated_pinhole(::bosdyn::api::ImageSource_PinholeModel* pinhole) {
  clear_camera_models();
  if (pinhole) {
    set_has_pinhole();
    _impl_.camera_models_.pinhole_ = pinhole;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageSource.pinhole)
}
inline ::bosdyn::api::ImageSource_PinholeModel* ImageSource::_internal_mutable_pinhole() {
  if (!_internal_has_pinhole()) {
    clear_camera_models();
    set_has_pinhole();
    _impl_.camera_models_.pinhole_ = CreateMaybeMessage< ::bosdyn::api::ImageSource_PinholeModel >(GetArenaForAllocation());
  }
  return _impl_.camera_models_.pinhole_;
}
inline ::bosdyn::api::ImageSource_PinholeModel* ImageSource::mutable_pinhole() {
  ::bosdyn::api::ImageSource_PinholeModel* _msg = _internal_mutable_pinhole();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSource.pinhole)
  return _msg;
}

// .bosdyn.api.ImageSource.ImageType image_type = 9;
inline void ImageSource::clear_image_type() {
  _impl_.image_type_ = 0;
}
inline ::bosdyn::api::ImageSource_ImageType ImageSource::_internal_image_type() const {
  return static_cast< ::bosdyn::api::ImageSource_ImageType >(_impl_.image_type_);
}
inline ::bosdyn::api::ImageSource_ImageType ImageSource::image_type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.image_type)
  return _internal_image_type();
}
inline void ImageSource::_internal_set_image_type(::bosdyn::api::ImageSource_ImageType value) {
  
  _impl_.image_type_ = value;
}
inline void ImageSource::set_image_type(::bosdyn::api::ImageSource_ImageType value) {
  _internal_set_image_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSource.image_type)
}

// repeated .bosdyn.api.Image.PixelFormat pixel_formats = 10;
inline int ImageSource::_internal_pixel_formats_size() const {
  return _impl_.pixel_formats_.size();
}
inline int ImageSource::pixel_formats_size() const {
  return _internal_pixel_formats_size();
}
inline void ImageSource::clear_pixel_formats() {
  _impl_.pixel_formats_.Clear();
}
inline ::bosdyn::api::Image_PixelFormat ImageSource::_internal_pixel_formats(int index) const {
  return static_cast< ::bosdyn::api::Image_PixelFormat >(_impl_.pixel_formats_.Get(index));
}
inline ::bosdyn::api::Image_PixelFormat ImageSource::pixel_formats(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.pixel_formats)
  return _internal_pixel_formats(index);
}
inline void ImageSource::set_pixel_formats(int index, ::bosdyn::api::Image_PixelFormat value) {
  _impl_.pixel_formats_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSource.pixel_formats)
}
inline void ImageSource::_internal_add_pixel_formats(::bosdyn::api::Image_PixelFormat value) {
  _impl_.pixel_formats_.Add(value);
}
inline void ImageSource::add_pixel_formats(::bosdyn::api::Image_PixelFormat value) {
  _internal_add_pixel_formats(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.ImageSource.pixel_formats)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ImageSource::pixel_formats() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ImageSource.pixel_formats)
  return _impl_.pixel_formats_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ImageSource::_internal_mutable_pixel_formats() {
  return &_impl_.pixel_formats_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ImageSource::mutable_pixel_formats() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ImageSource.pixel_formats)
  return _internal_mutable_pixel_formats();
}

// repeated .bosdyn.api.Image.Format image_formats = 11;
inline int ImageSource::_internal_image_formats_size() const {
  return _impl_.image_formats_.size();
}
inline int ImageSource::image_formats_size() const {
  return _internal_image_formats_size();
}
inline void ImageSource::clear_image_formats() {
  _impl_.image_formats_.Clear();
}
inline ::bosdyn::api::Image_Format ImageSource::_internal_image_formats(int index) const {
  return static_cast< ::bosdyn::api::Image_Format >(_impl_.image_formats_.Get(index));
}
inline ::bosdyn::api::Image_Format ImageSource::image_formats(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.image_formats)
  return _internal_image_formats(index);
}
inline void ImageSource::set_image_formats(int index, ::bosdyn::api::Image_Format value) {
  _impl_.image_formats_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSource.image_formats)
}
inline void ImageSource::_internal_add_image_formats(::bosdyn::api::Image_Format value) {
  _impl_.image_formats_.Add(value);
}
inline void ImageSource::add_image_formats(::bosdyn::api::Image_Format value) {
  _internal_add_image_formats(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.ImageSource.image_formats)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ImageSource::image_formats() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ImageSource.image_formats)
  return _impl_.image_formats_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ImageSource::_internal_mutable_image_formats() {
  return &_impl_.image_formats_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ImageSource::mutable_image_formats() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ImageSource.image_formats)
  return _internal_mutable_image_formats();
}

inline bool ImageSource::has_camera_models() const {
  return camera_models_case() != CAMERA_MODELS_NOT_SET;
}
inline void ImageSource::clear_has_camera_models() {
  _impl_._oneof_case_[0] = CAMERA_MODELS_NOT_SET;
}
inline ImageSource::CameraModelsCase ImageSource::camera_models_case() const {
  return ImageSource::CameraModelsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ListImageSourcesRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListImageSourcesRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListImageSourcesRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListImageSourcesRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListImageSourcesRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListImageSourcesRequest.header)
  return _internal_header();
}
inline void ListImageSourcesRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListImageSourcesRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListImageSourcesRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListImageSourcesRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListImageSourcesRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListImageSourcesRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ListImageSourcesRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListImageSourcesRequest.header)
  return _msg;
}
inline void ListImageSourcesRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListImageSourcesRequest.header)
}

// -------------------------------------------------------------------

// ListImageSourcesResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListImageSourcesResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListImageSourcesResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListImageSourcesResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListImageSourcesResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListImageSourcesResponse.header)
  return _internal_header();
}
inline void ListImageSourcesResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListImageSourcesResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListImageSourcesResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListImageSourcesResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListImageSourcesResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListImageSourcesResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ListImageSourcesResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListImageSourcesResponse.header)
  return _msg;
}
inline void ListImageSourcesResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListImageSourcesResponse.header)
}

// repeated .bosdyn.api.ImageSource image_sources = 2;
inline int ListImageSourcesResponse::_internal_image_sources_size() const {
  return _impl_.image_sources_.size();
}
inline int ListImageSourcesResponse::image_sources_size() const {
  return _internal_image_sources_size();
}
inline void ListImageSourcesResponse::clear_image_sources() {
  _impl_.image_sources_.Clear();
}
inline ::bosdyn::api::ImageSource* ListImageSourcesResponse::mutable_image_sources(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListImageSourcesResponse.image_sources)
  return _impl_.image_sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSource >*
ListImageSourcesResponse::mutable_image_sources() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ListImageSourcesResponse.image_sources)
  return &_impl_.image_sources_;
}
inline const ::bosdyn::api::ImageSource& ListImageSourcesResponse::_internal_image_sources(int index) const {
  return _impl_.image_sources_.Get(index);
}
inline const ::bosdyn::api::ImageSource& ListImageSourcesResponse::image_sources(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListImageSourcesResponse.image_sources)
  return _internal_image_sources(index);
}
inline ::bosdyn::api::ImageSource* ListImageSourcesResponse::_internal_add_image_sources() {
  return _impl_.image_sources_.Add();
}
inline ::bosdyn::api::ImageSource* ListImageSourcesResponse::add_image_sources() {
  ::bosdyn::api::ImageSource* _add = _internal_add_image_sources();
  // @@protoc_insertion_point(field_add:bosdyn.api.ListImageSourcesResponse.image_sources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSource >&
ListImageSourcesResponse::image_sources() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ListImageSourcesResponse.image_sources)
  return _impl_.image_sources_;
}

// -------------------------------------------------------------------

// ImageRequest

// string image_source_name = 1;
inline void ImageRequest::clear_image_source_name() {
  _impl_.image_source_name_.ClearToEmpty();
}
inline const std::string& ImageRequest::image_source_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageRequest.image_source_name)
  return _internal_image_source_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageRequest::set_image_source_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_source_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageRequest.image_source_name)
}
inline std::string* ImageRequest::mutable_image_source_name() {
  std::string* _s = _internal_mutable_image_source_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageRequest.image_source_name)
  return _s;
}
inline const std::string& ImageRequest::_internal_image_source_name() const {
  return _impl_.image_source_name_.Get();
}
inline void ImageRequest::_internal_set_image_source_name(const std::string& value) {
  
  _impl_.image_source_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageRequest::_internal_mutable_image_source_name() {
  
  return _impl_.image_source_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageRequest::release_image_source_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageRequest.image_source_name)
  return _impl_.image_source_name_.Release();
}
inline void ImageRequest::set_allocated_image_source_name(std::string* image_source_name) {
  if (image_source_name != nullptr) {
    
  } else {
    
  }
  _impl_.image_source_name_.SetAllocated(image_source_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_source_name_.IsDefault()) {
    _impl_.image_source_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageRequest.image_source_name)
}

// double quality_percent = 2;
inline void ImageRequest::clear_quality_percent() {
  _impl_.quality_percent_ = 0;
}
inline double ImageRequest::_internal_quality_percent() const {
  return _impl_.quality_percent_;
}
inline double ImageRequest::quality_percent() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageRequest.quality_percent)
  return _internal_quality_percent();
}
inline void ImageRequest::_internal_set_quality_percent(double value) {
  
  _impl_.quality_percent_ = value;
}
inline void ImageRequest::set_quality_percent(double value) {
  _internal_set_quality_percent(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageRequest.quality_percent)
}

// .bosdyn.api.Image.Format image_format = 3;
inline void ImageRequest::clear_image_format() {
  _impl_.image_format_ = 0;
}
inline ::bosdyn::api::Image_Format ImageRequest::_internal_image_format() const {
  return static_cast< ::bosdyn::api::Image_Format >(_impl_.image_format_);
}
inline ::bosdyn::api::Image_Format ImageRequest::image_format() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageRequest.image_format)
  return _internal_image_format();
}
inline void ImageRequest::_internal_set_image_format(::bosdyn::api::Image_Format value) {
  
  _impl_.image_format_ = value;
}
inline void ImageRequest::set_image_format(::bosdyn::api::Image_Format value) {
  _internal_set_image_format(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageRequest.image_format)
}

// double resize_ratio = 4;
inline void ImageRequest::clear_resize_ratio() {
  _impl_.resize_ratio_ = 0;
}
inline double ImageRequest::_internal_resize_ratio() const {
  return _impl_.resize_ratio_;
}
inline double ImageRequest::resize_ratio() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageRequest.resize_ratio)
  return _internal_resize_ratio();
}
inline void ImageRequest::_internal_set_resize_ratio(double value) {
  
  _impl_.resize_ratio_ = value;
}
inline void ImageRequest::set_resize_ratio(double value) {
  _internal_set_resize_ratio(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageRequest.resize_ratio)
}

// .bosdyn.api.Image.PixelFormat pixel_format = 5;
inline void ImageRequest::clear_pixel_format() {
  _impl_.pixel_format_ = 0;
}
inline ::bosdyn::api::Image_PixelFormat ImageRequest::_internal_pixel_format() const {
  return static_cast< ::bosdyn::api::Image_PixelFormat >(_impl_.pixel_format_);
}
inline ::bosdyn::api::Image_PixelFormat ImageRequest::pixel_format() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageRequest.pixel_format)
  return _internal_pixel_format();
}
inline void ImageRequest::_internal_set_pixel_format(::bosdyn::api::Image_PixelFormat value) {
  
  _impl_.pixel_format_ = value;
}
inline void ImageRequest::set_pixel_format(::bosdyn::api::Image_PixelFormat value) {
  _internal_set_pixel_format(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageRequest.pixel_format)
}

// -------------------------------------------------------------------

// GetImageRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetImageRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetImageRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetImageRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetImageRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetImageRequest.header)
  return _internal_header();
}
inline void GetImageRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetImageRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetImageRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetImageRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetImageRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetImageRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* GetImageRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetImageRequest.header)
  return _msg;
}
inline void GetImageRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetImageRequest.header)
}

// repeated .bosdyn.api.ImageRequest image_requests = 2;
inline int GetImageRequest::_internal_image_requests_size() const {
  return _impl_.image_requests_.size();
}
inline int GetImageRequest::image_requests_size() const {
  return _internal_image_requests_size();
}
inline void GetImageRequest::clear_image_requests() {
  _impl_.image_requests_.Clear();
}
inline ::bosdyn::api::ImageRequest* GetImageRequest::mutable_image_requests(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetImageRequest.image_requests)
  return _impl_.image_requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageRequest >*
GetImageRequest::mutable_image_requests() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.GetImageRequest.image_requests)
  return &_impl_.image_requests_;
}
inline const ::bosdyn::api::ImageRequest& GetImageRequest::_internal_image_requests(int index) const {
  return _impl_.image_requests_.Get(index);
}
inline const ::bosdyn::api::ImageRequest& GetImageRequest::image_requests(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetImageRequest.image_requests)
  return _internal_image_requests(index);
}
inline ::bosdyn::api::ImageRequest* GetImageRequest::_internal_add_image_requests() {
  return _impl_.image_requests_.Add();
}
inline ::bosdyn::api::ImageRequest* GetImageRequest::add_image_requests() {
  ::bosdyn::api::ImageRequest* _add = _internal_add_image_requests();
  // @@protoc_insertion_point(field_add:bosdyn.api.GetImageRequest.image_requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageRequest >&
GetImageRequest::image_requests() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.GetImageRequest.image_requests)
  return _impl_.image_requests_;
}

// -------------------------------------------------------------------

// ImageResponse

// .bosdyn.api.ImageCapture shot = 1;
inline bool ImageResponse::_internal_has_shot() const {
  return this != internal_default_instance() && _impl_.shot_ != nullptr;
}
inline bool ImageResponse::has_shot() const {
  return _internal_has_shot();
}
inline void ImageResponse::clear_shot() {
  if (GetArenaForAllocation() == nullptr && _impl_.shot_ != nullptr) {
    delete _impl_.shot_;
  }
  _impl_.shot_ = nullptr;
}
inline const ::bosdyn::api::ImageCapture& ImageResponse::_internal_shot() const {
  const ::bosdyn::api::ImageCapture* p = _impl_.shot_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ImageCapture&>(
      ::bosdyn::api::_ImageCapture_default_instance_);
}
inline const ::bosdyn::api::ImageCapture& ImageResponse::shot() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageResponse.shot)
  return _internal_shot();
}
inline void ImageResponse::unsafe_arena_set_allocated_shot(
    ::bosdyn::api::ImageCapture* shot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shot_);
  }
  _impl_.shot_ = shot;
  if (shot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageResponse.shot)
}
inline ::bosdyn::api::ImageCapture* ImageResponse::release_shot() {
  
  ::bosdyn::api::ImageCapture* temp = _impl_.shot_;
  _impl_.shot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ImageCapture* ImageResponse::unsafe_arena_release_shot() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageResponse.shot)
  
  ::bosdyn::api::ImageCapture* temp = _impl_.shot_;
  _impl_.shot_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ImageCapture* ImageResponse::_internal_mutable_shot() {
  
  if (_impl_.shot_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ImageCapture>(GetArenaForAllocation());
    _impl_.shot_ = p;
  }
  return _impl_.shot_;
}
inline ::bosdyn::api::ImageCapture* ImageResponse::mutable_shot() {
  ::bosdyn::api::ImageCapture* _msg = _internal_mutable_shot();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageResponse.shot)
  return _msg;
}
inline void ImageResponse::set_allocated_shot(::bosdyn::api::ImageCapture* shot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.shot_;
  }
  if (shot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shot);
    if (message_arena != submessage_arena) {
      shot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shot, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.shot_ = shot;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageResponse.shot)
}

// .bosdyn.api.ImageSource source = 2;
inline bool ImageResponse::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool ImageResponse::has_source() const {
  return _internal_has_source();
}
inline void ImageResponse::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::bosdyn::api::ImageSource& ImageResponse::_internal_source() const {
  const ::bosdyn::api::ImageSource* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ImageSource&>(
      ::bosdyn::api::_ImageSource_default_instance_);
}
inline const ::bosdyn::api::ImageSource& ImageResponse::source() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageResponse.source)
  return _internal_source();
}
inline void ImageResponse::unsafe_arena_set_allocated_source(
    ::bosdyn::api::ImageSource* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageResponse.source)
}
inline ::bosdyn::api::ImageSource* ImageResponse::release_source() {
  
  ::bosdyn::api::ImageSource* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ImageSource* ImageResponse::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageResponse.source)
  
  ::bosdyn::api::ImageSource* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ImageSource* ImageResponse::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ImageSource>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::bosdyn::api::ImageSource* ImageResponse::mutable_source() {
  ::bosdyn::api::ImageSource* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageResponse.source)
  return _msg;
}
inline void ImageResponse::set_allocated_source(::bosdyn::api::ImageSource* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageResponse.source)
}

// .bosdyn.api.ImageResponse.Status status = 4;
inline void ImageResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::ImageResponse_Status ImageResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::ImageResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::ImageResponse_Status ImageResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageResponse.status)
  return _internal_status();
}
inline void ImageResponse::_internal_set_status(::bosdyn::api::ImageResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void ImageResponse::set_status(::bosdyn::api::ImageResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageResponse.status)
}

// -------------------------------------------------------------------

// GetImageResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetImageResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetImageResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetImageResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetImageResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetImageResponse.header)
  return _internal_header();
}
inline void GetImageResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetImageResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetImageResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetImageResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetImageResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetImageResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* GetImageResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetImageResponse.header)
  return _msg;
}
inline void GetImageResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetImageResponse.header)
}

// repeated .bosdyn.api.ImageResponse image_responses = 2;
inline int GetImageResponse::_internal_image_responses_size() const {
  return _impl_.image_responses_.size();
}
inline int GetImageResponse::image_responses_size() const {
  return _internal_image_responses_size();
}
inline void GetImageResponse::clear_image_responses() {
  _impl_.image_responses_.Clear();
}
inline ::bosdyn::api::ImageResponse* GetImageResponse::mutable_image_responses(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetImageResponse.image_responses)
  return _impl_.image_responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageResponse >*
GetImageResponse::mutable_image_responses() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.GetImageResponse.image_responses)
  return &_impl_.image_responses_;
}
inline const ::bosdyn::api::ImageResponse& GetImageResponse::_internal_image_responses(int index) const {
  return _impl_.image_responses_.Get(index);
}
inline const ::bosdyn::api::ImageResponse& GetImageResponse::image_responses(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetImageResponse.image_responses)
  return _internal_image_responses(index);
}
inline ::bosdyn::api::ImageResponse* GetImageResponse::_internal_add_image_responses() {
  return _impl_.image_responses_.Add();
}
inline ::bosdyn::api::ImageResponse* GetImageResponse::add_image_responses() {
  ::bosdyn::api::ImageResponse* _add = _internal_add_image_responses();
  // @@protoc_insertion_point(field_add:bosdyn.api.GetImageResponse.image_responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageResponse >&
GetImageResponse::image_responses() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.GetImageResponse.image_responses)
  return _impl_.image_responses_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::Image_Format> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::Image_Format>() {
  return ::bosdyn::api::Image_Format_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::Image_PixelFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::Image_PixelFormat>() {
  return ::bosdyn::api::Image_PixelFormat_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::ImageSource_ImageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ImageSource_ImageType>() {
  return ::bosdyn::api::ImageSource_ImageType_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::ImageResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ImageResponse_Status>() {
  return ::bosdyn::api::ImageResponse_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fimage_2eproto
