// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/mission/nodes.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fmission_2fnodes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fmission_2fnodes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include <google/protobuf/duration.pb.h>
#include "bosdyn/api/alerts.pb.h"
#include "bosdyn/api/docking/docking.pb.h"
#include "bosdyn/api/geometry.pb.h"
#include "bosdyn/api/gripper_camera_param.pb.h"
#include "bosdyn/api/spot_cam/camera.pb.h"
#include "bosdyn/api/spot_cam/logging.pb.h"
#include "bosdyn/api/spot_cam/ptz.pb.h"
#include "bosdyn/api/robot_command.pb.h"
#include "bosdyn/api/power.pb.h"
#include "bosdyn/api/data_acquisition.pb.h"
#include "bosdyn/api/data_buffer.pb.h"
#include "bosdyn/api/graph_nav/graph_nav.pb.h"
#include "bosdyn/api/graph_nav/nav.pb.h"
#include "bosdyn/api/mission/util.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fmission_2fnodes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto;
namespace bosdyn {
namespace api {
namespace mission {
class BosdynDockState;
struct BosdynDockStateDefaultTypeInternal;
extern BosdynDockStateDefaultTypeInternal _BosdynDockState_default_instance_;
class BosdynGraphNavLocalize;
struct BosdynGraphNavLocalizeDefaultTypeInternal;
extern BosdynGraphNavLocalizeDefaultTypeInternal _BosdynGraphNavLocalize_default_instance_;
class BosdynGraphNavState;
struct BosdynGraphNavStateDefaultTypeInternal;
extern BosdynGraphNavStateDefaultTypeInternal _BosdynGraphNavState_default_instance_;
class BosdynGripperCameraParamsState;
struct BosdynGripperCameraParamsStateDefaultTypeInternal;
extern BosdynGripperCameraParamsStateDefaultTypeInternal _BosdynGripperCameraParamsState_default_instance_;
class BosdynNavigateRoute;
struct BosdynNavigateRouteDefaultTypeInternal;
extern BosdynNavigateRouteDefaultTypeInternal _BosdynNavigateRoute_default_instance_;
class BosdynNavigateTo;
struct BosdynNavigateToDefaultTypeInternal;
extern BosdynNavigateToDefaultTypeInternal _BosdynNavigateTo_default_instance_;
class BosdynPowerRequest;
struct BosdynPowerRequestDefaultTypeInternal;
extern BosdynPowerRequestDefaultTypeInternal _BosdynPowerRequest_default_instance_;
class BosdynRecordEvent;
struct BosdynRecordEventDefaultTypeInternal;
extern BosdynRecordEventDefaultTypeInternal _BosdynRecordEvent_default_instance_;
class BosdynRecordEvent_AdditionalParametersEntry_DoNotUse;
struct BosdynRecordEvent_AdditionalParametersEntry_DoNotUseDefaultTypeInternal;
extern BosdynRecordEvent_AdditionalParametersEntry_DoNotUseDefaultTypeInternal _BosdynRecordEvent_AdditionalParametersEntry_DoNotUse_default_instance_;
class BosdynRobotCommand;
struct BosdynRobotCommandDefaultTypeInternal;
extern BosdynRobotCommandDefaultTypeInternal _BosdynRobotCommand_default_instance_;
class BosdynRobotState;
struct BosdynRobotStateDefaultTypeInternal;
extern BosdynRobotStateDefaultTypeInternal _BosdynRobotState_default_instance_;
class ClearBehaviorFaults;
struct ClearBehaviorFaultsDefaultTypeInternal;
extern ClearBehaviorFaultsDefaultTypeInternal _ClearBehaviorFaults_default_instance_;
class Condition;
struct ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class Condition_Operand;
struct Condition_OperandDefaultTypeInternal;
extern Condition_OperandDefaultTypeInternal _Condition_Operand_default_instance_;
class ConstantResult;
struct ConstantResultDefaultTypeInternal;
extern ConstantResultDefaultTypeInternal _ConstantResult_default_instance_;
class DataAcquisition;
struct DataAcquisitionDefaultTypeInternal;
extern DataAcquisitionDefaultTypeInternal _DataAcquisition_default_instance_;
class DateToBlackboard;
struct DateToBlackboardDefaultTypeInternal;
extern DateToBlackboardDefaultTypeInternal _DateToBlackboard_default_instance_;
class DefineBlackboard;
struct DefineBlackboardDefaultTypeInternal;
extern DefineBlackboardDefaultTypeInternal _DefineBlackboard_default_instance_;
class Dock;
struct DockDefaultTypeInternal;
extern DockDefaultTypeInternal _Dock_default_instance_;
class ForDuration;
struct ForDurationDefaultTypeInternal;
extern ForDurationDefaultTypeInternal _ForDuration_default_instance_;
class FormatBlackboard;
struct FormatBlackboardDefaultTypeInternal;
extern FormatBlackboardDefaultTypeInternal _FormatBlackboard_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Prompt;
struct PromptDefaultTypeInternal;
extern PromptDefaultTypeInternal _Prompt_default_instance_;
class Prompt_Option;
struct Prompt_OptionDefaultTypeInternal;
extern Prompt_OptionDefaultTypeInternal _Prompt_Option_default_instance_;
class RemoteGrpc;
struct RemoteGrpcDefaultTypeInternal;
extern RemoteGrpcDefaultTypeInternal _RemoteGrpc_default_instance_;
class Repeat;
struct RepeatDefaultTypeInternal;
extern RepeatDefaultTypeInternal _Repeat_default_instance_;
class RestartWhenPaused;
struct RestartWhenPausedDefaultTypeInternal;
extern RestartWhenPausedDefaultTypeInternal _RestartWhenPaused_default_instance_;
class RetainLease;
struct RetainLeaseDefaultTypeInternal;
extern RetainLeaseDefaultTypeInternal _RetainLease_default_instance_;
class Retry;
struct RetryDefaultTypeInternal;
extern RetryDefaultTypeInternal _Retry_default_instance_;
class Selector;
struct SelectorDefaultTypeInternal;
extern SelectorDefaultTypeInternal _Selector_default_instance_;
class Sequence;
struct SequenceDefaultTypeInternal;
extern SequenceDefaultTypeInternal _Sequence_default_instance_;
class SetBlackboard;
struct SetBlackboardDefaultTypeInternal;
extern SetBlackboardDefaultTypeInternal _SetBlackboard_default_instance_;
class SetGripperCameraParams;
struct SetGripperCameraParamsDefaultTypeInternal;
extern SetGripperCameraParamsDefaultTypeInternal _SetGripperCameraParams_default_instance_;
class SimpleParallel;
struct SimpleParallelDefaultTypeInternal;
extern SimpleParallelDefaultTypeInternal _SimpleParallel_default_instance_;
class Sleep;
struct SleepDefaultTypeInternal;
extern SleepDefaultTypeInternal _Sleep_default_instance_;
class SpotCamLed;
struct SpotCamLedDefaultTypeInternal;
extern SpotCamLedDefaultTypeInternal _SpotCamLed_default_instance_;
class SpotCamLed_BrightnessesEntry_DoNotUse;
struct SpotCamLed_BrightnessesEntry_DoNotUseDefaultTypeInternal;
extern SpotCamLed_BrightnessesEntry_DoNotUseDefaultTypeInternal _SpotCamLed_BrightnessesEntry_DoNotUse_default_instance_;
class SpotCamPtz;
struct SpotCamPtzDefaultTypeInternal;
extern SpotCamPtzDefaultTypeInternal _SpotCamPtz_default_instance_;
class SpotCamPtz_AdjustParameters;
struct SpotCamPtz_AdjustParametersDefaultTypeInternal;
extern SpotCamPtz_AdjustParametersDefaultTypeInternal _SpotCamPtz_AdjustParameters_default_instance_;
class SpotCamResetAutofocus;
struct SpotCamResetAutofocusDefaultTypeInternal;
extern SpotCamResetAutofocusDefaultTypeInternal _SpotCamResetAutofocus_default_instance_;
class SpotCamStoreMedia;
struct SpotCamStoreMediaDefaultTypeInternal;
extern SpotCamStoreMediaDefaultTypeInternal _SpotCamStoreMedia_default_instance_;
class StoreMetadata;
struct StoreMetadataDefaultTypeInternal;
extern StoreMetadataDefaultTypeInternal _StoreMetadata_default_instance_;
class Switch;
struct SwitchDefaultTypeInternal;
extern SwitchDefaultTypeInternal _Switch_default_instance_;
class Switch_IntChildrenEntry_DoNotUse;
struct Switch_IntChildrenEntry_DoNotUseDefaultTypeInternal;
extern Switch_IntChildrenEntry_DoNotUseDefaultTypeInternal _Switch_IntChildrenEntry_DoNotUse_default_instance_;
}  // namespace mission
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::mission::BosdynDockState* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynDockState>(Arena*);
template<> ::bosdyn::api::mission::BosdynGraphNavLocalize* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynGraphNavLocalize>(Arena*);
template<> ::bosdyn::api::mission::BosdynGraphNavState* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynGraphNavState>(Arena*);
template<> ::bosdyn::api::mission::BosdynGripperCameraParamsState* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynGripperCameraParamsState>(Arena*);
template<> ::bosdyn::api::mission::BosdynNavigateRoute* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynNavigateRoute>(Arena*);
template<> ::bosdyn::api::mission::BosdynNavigateTo* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynNavigateTo>(Arena*);
template<> ::bosdyn::api::mission::BosdynPowerRequest* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynPowerRequest>(Arena*);
template<> ::bosdyn::api::mission::BosdynRecordEvent* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynRecordEvent>(Arena*);
template<> ::bosdyn::api::mission::BosdynRecordEvent_AdditionalParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynRecordEvent_AdditionalParametersEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::mission::BosdynRobotCommand* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynRobotCommand>(Arena*);
template<> ::bosdyn::api::mission::BosdynRobotState* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynRobotState>(Arena*);
template<> ::bosdyn::api::mission::ClearBehaviorFaults* Arena::CreateMaybeMessage<::bosdyn::api::mission::ClearBehaviorFaults>(Arena*);
template<> ::bosdyn::api::mission::Condition* Arena::CreateMaybeMessage<::bosdyn::api::mission::Condition>(Arena*);
template<> ::bosdyn::api::mission::Condition_Operand* Arena::CreateMaybeMessage<::bosdyn::api::mission::Condition_Operand>(Arena*);
template<> ::bosdyn::api::mission::ConstantResult* Arena::CreateMaybeMessage<::bosdyn::api::mission::ConstantResult>(Arena*);
template<> ::bosdyn::api::mission::DataAcquisition* Arena::CreateMaybeMessage<::bosdyn::api::mission::DataAcquisition>(Arena*);
template<> ::bosdyn::api::mission::DateToBlackboard* Arena::CreateMaybeMessage<::bosdyn::api::mission::DateToBlackboard>(Arena*);
template<> ::bosdyn::api::mission::DefineBlackboard* Arena::CreateMaybeMessage<::bosdyn::api::mission::DefineBlackboard>(Arena*);
template<> ::bosdyn::api::mission::Dock* Arena::CreateMaybeMessage<::bosdyn::api::mission::Dock>(Arena*);
template<> ::bosdyn::api::mission::ForDuration* Arena::CreateMaybeMessage<::bosdyn::api::mission::ForDuration>(Arena*);
template<> ::bosdyn::api::mission::FormatBlackboard* Arena::CreateMaybeMessage<::bosdyn::api::mission::FormatBlackboard>(Arena*);
template<> ::bosdyn::api::mission::Node* Arena::CreateMaybeMessage<::bosdyn::api::mission::Node>(Arena*);
template<> ::bosdyn::api::mission::Prompt* Arena::CreateMaybeMessage<::bosdyn::api::mission::Prompt>(Arena*);
template<> ::bosdyn::api::mission::Prompt_Option* Arena::CreateMaybeMessage<::bosdyn::api::mission::Prompt_Option>(Arena*);
template<> ::bosdyn::api::mission::RemoteGrpc* Arena::CreateMaybeMessage<::bosdyn::api::mission::RemoteGrpc>(Arena*);
template<> ::bosdyn::api::mission::Repeat* Arena::CreateMaybeMessage<::bosdyn::api::mission::Repeat>(Arena*);
template<> ::bosdyn::api::mission::RestartWhenPaused* Arena::CreateMaybeMessage<::bosdyn::api::mission::RestartWhenPaused>(Arena*);
template<> ::bosdyn::api::mission::RetainLease* Arena::CreateMaybeMessage<::bosdyn::api::mission::RetainLease>(Arena*);
template<> ::bosdyn::api::mission::Retry* Arena::CreateMaybeMessage<::bosdyn::api::mission::Retry>(Arena*);
template<> ::bosdyn::api::mission::Selector* Arena::CreateMaybeMessage<::bosdyn::api::mission::Selector>(Arena*);
template<> ::bosdyn::api::mission::Sequence* Arena::CreateMaybeMessage<::bosdyn::api::mission::Sequence>(Arena*);
template<> ::bosdyn::api::mission::SetBlackboard* Arena::CreateMaybeMessage<::bosdyn::api::mission::SetBlackboard>(Arena*);
template<> ::bosdyn::api::mission::SetGripperCameraParams* Arena::CreateMaybeMessage<::bosdyn::api::mission::SetGripperCameraParams>(Arena*);
template<> ::bosdyn::api::mission::SimpleParallel* Arena::CreateMaybeMessage<::bosdyn::api::mission::SimpleParallel>(Arena*);
template<> ::bosdyn::api::mission::Sleep* Arena::CreateMaybeMessage<::bosdyn::api::mission::Sleep>(Arena*);
template<> ::bosdyn::api::mission::SpotCamLed* Arena::CreateMaybeMessage<::bosdyn::api::mission::SpotCamLed>(Arena*);
template<> ::bosdyn::api::mission::SpotCamLed_BrightnessesEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::mission::SpotCamLed_BrightnessesEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::mission::SpotCamPtz* Arena::CreateMaybeMessage<::bosdyn::api::mission::SpotCamPtz>(Arena*);
template<> ::bosdyn::api::mission::SpotCamPtz_AdjustParameters* Arena::CreateMaybeMessage<::bosdyn::api::mission::SpotCamPtz_AdjustParameters>(Arena*);
template<> ::bosdyn::api::mission::SpotCamResetAutofocus* Arena::CreateMaybeMessage<::bosdyn::api::mission::SpotCamResetAutofocus>(Arena*);
template<> ::bosdyn::api::mission::SpotCamStoreMedia* Arena::CreateMaybeMessage<::bosdyn::api::mission::SpotCamStoreMedia>(Arena*);
template<> ::bosdyn::api::mission::StoreMetadata* Arena::CreateMaybeMessage<::bosdyn::api::mission::StoreMetadata>(Arena*);
template<> ::bosdyn::api::mission::Switch* Arena::CreateMaybeMessage<::bosdyn::api::mission::Switch>(Arena*);
template<> ::bosdyn::api::mission::Switch_IntChildrenEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::mission::Switch_IntChildrenEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {
namespace mission {

enum Condition_Compare : int {
  Condition_Compare_COMPARE_UNKNOWN = 0,
  Condition_Compare_COMPARE_EQ = 1,
  Condition_Compare_COMPARE_NE = 2,
  Condition_Compare_COMPARE_LT = 3,
  Condition_Compare_COMPARE_GT = 4,
  Condition_Compare_COMPARE_LE = 5,
  Condition_Compare_COMPARE_GE = 6,
  Condition_Compare_Condition_Compare_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Condition_Compare_Condition_Compare_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Condition_Compare_IsValid(int value);
constexpr Condition_Compare Condition_Compare_Compare_MIN = Condition_Compare_COMPARE_UNKNOWN;
constexpr Condition_Compare Condition_Compare_Compare_MAX = Condition_Compare_COMPARE_GE;
constexpr int Condition_Compare_Compare_ARRAYSIZE = Condition_Compare_Compare_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Condition_Compare_descriptor();
template<typename T>
inline const std::string& Condition_Compare_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Condition_Compare>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Condition_Compare_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Condition_Compare_descriptor(), enum_t_value);
}
inline bool Condition_Compare_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Condition_Compare* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Condition_Compare>(
    Condition_Compare_descriptor(), name, value);
}
enum Condition_HandleStaleness : int {
  Condition_HandleStaleness_HANDLE_STALE_UNKNOWN = 0,
  Condition_HandleStaleness_HANDLE_STALE_READ_ANYWAY = 1,
  Condition_HandleStaleness_HANDLE_STALE_RUN_UNTIL_FRESH = 2,
  Condition_HandleStaleness_HANDLE_STALE_FAIL = 3,
  Condition_HandleStaleness_Condition_HandleStaleness_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Condition_HandleStaleness_Condition_HandleStaleness_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Condition_HandleStaleness_IsValid(int value);
constexpr Condition_HandleStaleness Condition_HandleStaleness_HandleStaleness_MIN = Condition_HandleStaleness_HANDLE_STALE_UNKNOWN;
constexpr Condition_HandleStaleness Condition_HandleStaleness_HandleStaleness_MAX = Condition_HandleStaleness_HANDLE_STALE_FAIL;
constexpr int Condition_HandleStaleness_HandleStaleness_ARRAYSIZE = Condition_HandleStaleness_HandleStaleness_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Condition_HandleStaleness_descriptor();
template<typename T>
inline const std::string& Condition_HandleStaleness_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Condition_HandleStaleness>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Condition_HandleStaleness_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Condition_HandleStaleness_descriptor(), enum_t_value);
}
inline bool Condition_HandleStaleness_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Condition_HandleStaleness* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Condition_HandleStaleness>(
    Condition_HandleStaleness_descriptor(), name, value);
}
enum DataAcquisition_CompletionBehavior : int {
  DataAcquisition_CompletionBehavior_COMPLETE_UNKNOWN = 0,
  DataAcquisition_CompletionBehavior_COMPLETE_AFTER_SAVED = 1,
  DataAcquisition_CompletionBehavior_COMPLETE_AFTER_ACQUIRED = 2,
  DataAcquisition_CompletionBehavior_DataAcquisition_CompletionBehavior_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataAcquisition_CompletionBehavior_DataAcquisition_CompletionBehavior_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataAcquisition_CompletionBehavior_IsValid(int value);
constexpr DataAcquisition_CompletionBehavior DataAcquisition_CompletionBehavior_CompletionBehavior_MIN = DataAcquisition_CompletionBehavior_COMPLETE_UNKNOWN;
constexpr DataAcquisition_CompletionBehavior DataAcquisition_CompletionBehavior_CompletionBehavior_MAX = DataAcquisition_CompletionBehavior_COMPLETE_AFTER_ACQUIRED;
constexpr int DataAcquisition_CompletionBehavior_CompletionBehavior_ARRAYSIZE = DataAcquisition_CompletionBehavior_CompletionBehavior_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataAcquisition_CompletionBehavior_descriptor();
template<typename T>
inline const std::string& DataAcquisition_CompletionBehavior_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataAcquisition_CompletionBehavior>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataAcquisition_CompletionBehavior_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataAcquisition_CompletionBehavior_descriptor(), enum_t_value);
}
inline bool DataAcquisition_CompletionBehavior_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataAcquisition_CompletionBehavior* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataAcquisition_CompletionBehavior>(
    DataAcquisition_CompletionBehavior_descriptor(), name, value);
}
// ===================================================================

class Node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() override;
  explicit PROTOBUF_CONSTEXPR Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kImpl = 4,
    kNodeReference = 5,
    TYPE_NOT_SET = 0,
  };

  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Node& from) {
    Node::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Node";
  }
  protected:
  explicit Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParameterValuesFieldNumber = 6,
    kOverridesFieldNumber = 7,
    kParametersFieldNumber = 8,
    kNameFieldNumber = 1,
    kReferenceIdFieldNumber = 3,
    kUserDataFieldNumber = 2,
    kImplFieldNumber = 4,
    kNodeReferenceFieldNumber = 5,
  };
  // repeated .bosdyn.api.mission.KeyValue parameter_values = 6;
  int parameter_values_size() const;
  private:
  int _internal_parameter_values_size() const;
  public:
  void clear_parameter_values();
  ::bosdyn::api::mission::KeyValue* mutable_parameter_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
      mutable_parameter_values();
  private:
  const ::bosdyn::api::mission::KeyValue& _internal_parameter_values(int index) const;
  ::bosdyn::api::mission::KeyValue* _internal_add_parameter_values();
  public:
  const ::bosdyn::api::mission::KeyValue& parameter_values(int index) const;
  ::bosdyn::api::mission::KeyValue* add_parameter_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
      parameter_values() const;

  // repeated .bosdyn.api.mission.KeyValue overrides = 7;
  int overrides_size() const;
  private:
  int _internal_overrides_size() const;
  public:
  void clear_overrides();
  ::bosdyn::api::mission::KeyValue* mutable_overrides(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
      mutable_overrides();
  private:
  const ::bosdyn::api::mission::KeyValue& _internal_overrides(int index) const;
  ::bosdyn::api::mission::KeyValue* _internal_add_overrides();
  public:
  const ::bosdyn::api::mission::KeyValue& overrides(int index) const;
  ::bosdyn::api::mission::KeyValue* add_overrides();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
      overrides() const;

  // repeated .bosdyn.api.mission.VariableDeclaration parameters = 8;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::bosdyn::api::mission::VariableDeclaration* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >*
      mutable_parameters();
  private:
  const ::bosdyn::api::mission::VariableDeclaration& _internal_parameters(int index) const;
  ::bosdyn::api::mission::VariableDeclaration* _internal_add_parameters();
  public:
  const ::bosdyn::api::mission::VariableDeclaration& parameters(int index) const;
  ::bosdyn::api::mission::VariableDeclaration* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >&
      parameters() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string reference_id = 3;
  void clear_reference_id();
  const std::string& reference_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reference_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reference_id();
  PROTOBUF_NODISCARD std::string* release_reference_id();
  void set_allocated_reference_id(std::string* reference_id);
  private:
  const std::string& _internal_reference_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reference_id(const std::string& value);
  std::string* _internal_mutable_reference_id();
  public:

  // .bosdyn.api.mission.UserData user_data = 2;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::bosdyn::api::mission::UserData& user_data() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::UserData* release_user_data();
  ::bosdyn::api::mission::UserData* mutable_user_data();
  void set_allocated_user_data(::bosdyn::api::mission::UserData* user_data);
  private:
  const ::bosdyn::api::mission::UserData& _internal_user_data() const;
  ::bosdyn::api::mission::UserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::bosdyn::api::mission::UserData* user_data);
  ::bosdyn::api::mission::UserData* unsafe_arena_release_user_data();

  // .google.protobuf.Any impl = 4;
  bool has_impl() const;
  private:
  bool _internal_has_impl() const;
  public:
  void clear_impl();
  const ::PROTOBUF_NAMESPACE_ID::Any& impl() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_impl();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_impl();
  void set_allocated_impl(::PROTOBUF_NAMESPACE_ID::Any* impl);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_impl() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_impl();
  public:
  void unsafe_arena_set_allocated_impl(
      ::PROTOBUF_NAMESPACE_ID::Any* impl);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_impl();

  // string node_reference = 5;
  bool has_node_reference() const;
  private:
  bool _internal_has_node_reference() const;
  public:
  void clear_node_reference();
  const std::string& node_reference() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_reference(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_reference();
  PROTOBUF_NODISCARD std::string* release_node_reference();
  void set_allocated_node_reference(std::string* node_reference);
  private:
  const std::string& _internal_node_reference() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_reference(const std::string& value);
  std::string* _internal_mutable_node_reference();
  public:

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Node)
 private:
  class _Internal;
  void set_has_impl();
  void set_has_node_reference();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue > parameter_values_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue > overrides_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration > parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reference_id_;
    ::bosdyn::api::mission::UserData* user_data_;
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::Any* impl_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_reference_;
    } type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Sequence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Sequence) */ {
 public:
  inline Sequence() : Sequence(nullptr) {}
  ~Sequence() override;
  explicit PROTOBUF_CONSTEXPR Sequence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sequence(const Sequence& from);
  Sequence(Sequence&& from) noexcept
    : Sequence() {
    *this = ::std::move(from);
  }

  inline Sequence& operator=(const Sequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sequence& operator=(Sequence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sequence& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sequence* internal_default_instance() {
    return reinterpret_cast<const Sequence*>(
               &_Sequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Sequence& a, Sequence& b) {
    a.Swap(&b);
  }
  inline void Swap(Sequence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sequence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sequence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sequence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sequence& from) {
    Sequence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sequence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Sequence";
  }
  protected:
  explicit Sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 2,
    kAlwaysRestartFieldNumber = 1,
  };
  // repeated .bosdyn.api.mission.Node children = 2;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::bosdyn::api::mission::Node* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node >*
      mutable_children();
  private:
  const ::bosdyn::api::mission::Node& _internal_children(int index) const;
  ::bosdyn::api::mission::Node* _internal_add_children();
  public:
  const ::bosdyn::api::mission::Node& children(int index) const;
  ::bosdyn::api::mission::Node* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node >&
      children() const;

  // bool always_restart = 1;
  void clear_always_restart();
  bool always_restart() const;
  void set_always_restart(bool value);
  private:
  bool _internal_always_restart() const;
  void _internal_set_always_restart(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Sequence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node > children_;
    bool always_restart_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Selector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Selector) */ {
 public:
  inline Selector() : Selector(nullptr) {}
  ~Selector() override;
  explicit PROTOBUF_CONSTEXPR Selector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Selector(const Selector& from);
  Selector(Selector&& from) noexcept
    : Selector() {
    *this = ::std::move(from);
  }

  inline Selector& operator=(const Selector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Selector& operator=(Selector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Selector& default_instance() {
    return *internal_default_instance();
  }
  static inline const Selector* internal_default_instance() {
    return reinterpret_cast<const Selector*>(
               &_Selector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Selector& a, Selector& b) {
    a.Swap(&b);
  }
  inline void Swap(Selector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Selector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Selector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Selector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Selector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Selector& from) {
    Selector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Selector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Selector";
  }
  protected:
  explicit Selector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 2,
    kAlwaysRestartFieldNumber = 1,
  };
  // repeated .bosdyn.api.mission.Node children = 2;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::bosdyn::api::mission::Node* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node >*
      mutable_children();
  private:
  const ::bosdyn::api::mission::Node& _internal_children(int index) const;
  ::bosdyn::api::mission::Node* _internal_add_children();
  public:
  const ::bosdyn::api::mission::Node& children(int index) const;
  ::bosdyn::api::mission::Node* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node >&
      children() const;

  // bool always_restart = 1;
  void clear_always_restart();
  bool always_restart() const;
  void set_always_restart(bool value);
  private:
  bool _internal_always_restart() const;
  void _internal_set_always_restart(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Selector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node > children_;
    bool always_restart_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Switch_IntChildrenEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Switch_IntChildrenEntry_DoNotUse, 
    int32_t, ::bosdyn::api::mission::Node,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Switch_IntChildrenEntry_DoNotUse, 
    int32_t, ::bosdyn::api::mission::Node,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Switch_IntChildrenEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Switch_IntChildrenEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Switch_IntChildrenEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Switch_IntChildrenEntry_DoNotUse& other);
  static const Switch_IntChildrenEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Switch_IntChildrenEntry_DoNotUse*>(&_Switch_IntChildrenEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};

// -------------------------------------------------------------------

class Switch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Switch) */ {
 public:
  inline Switch() : Switch(nullptr) {}
  ~Switch() override;
  explicit PROTOBUF_CONSTEXPR Switch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Switch(const Switch& from);
  Switch(Switch&& from) noexcept
    : Switch() {
    *this = ::std::move(from);
  }

  inline Switch& operator=(const Switch& from) {
    CopyFrom(from);
    return *this;
  }
  inline Switch& operator=(Switch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Switch& default_instance() {
    return *internal_default_instance();
  }
  static inline const Switch* internal_default_instance() {
    return reinterpret_cast<const Switch*>(
               &_Switch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Switch& a, Switch& b) {
    a.Swap(&b);
  }
  inline void Swap(Switch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Switch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Switch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Switch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Switch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Switch& from) {
    Switch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Switch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Switch";
  }
  protected:
  explicit Switch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kIntChildrenFieldNumber = 3,
    kPivotValueFieldNumber = 1,
    kDefaultChildFieldNumber = 4,
    kAlwaysRestartFieldNumber = 2,
  };
  // map<int32, .bosdyn.api.mission.Node> int_children = 3;
  int int_children_size() const;
  private:
  int _internal_int_children_size() const;
  public:
  void clear_int_children();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::mission::Node >&
      _internal_int_children() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::mission::Node >*
      _internal_mutable_int_children();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::mission::Node >&
      int_children() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::mission::Node >*
      mutable_int_children();

  // .bosdyn.api.mission.Value pivot_value = 1;
  bool has_pivot_value() const;
  private:
  bool _internal_has_pivot_value() const;
  public:
  void clear_pivot_value();
  const ::bosdyn::api::mission::Value& pivot_value() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Value* release_pivot_value();
  ::bosdyn::api::mission::Value* mutable_pivot_value();
  void set_allocated_pivot_value(::bosdyn::api::mission::Value* pivot_value);
  private:
  const ::bosdyn::api::mission::Value& _internal_pivot_value() const;
  ::bosdyn::api::mission::Value* _internal_mutable_pivot_value();
  public:
  void unsafe_arena_set_allocated_pivot_value(
      ::bosdyn::api::mission::Value* pivot_value);
  ::bosdyn::api::mission::Value* unsafe_arena_release_pivot_value();

  // .bosdyn.api.mission.Node default_child = 4;
  bool has_default_child() const;
  private:
  bool _internal_has_default_child() const;
  public:
  void clear_default_child();
  const ::bosdyn::api::mission::Node& default_child() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Node* release_default_child();
  ::bosdyn::api::mission::Node* mutable_default_child();
  void set_allocated_default_child(::bosdyn::api::mission::Node* default_child);
  private:
  const ::bosdyn::api::mission::Node& _internal_default_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_default_child();
  public:
  void unsafe_arena_set_allocated_default_child(
      ::bosdyn::api::mission::Node* default_child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_default_child();

  // bool always_restart = 2;
  void clear_always_restart();
  bool always_restart() const;
  void set_always_restart(bool value);
  private:
  bool _internal_always_restart() const;
  void _internal_set_always_restart(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Switch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Switch_IntChildrenEntry_DoNotUse,
        int32_t, ::bosdyn::api::mission::Node,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> int_children_;
    ::bosdyn::api::mission::Value* pivot_value_;
    ::bosdyn::api::mission::Node* default_child_;
    bool always_restart_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Repeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Repeat) */ {
 public:
  inline Repeat() : Repeat(nullptr) {}
  ~Repeat() override;
  explicit PROTOBUF_CONSTEXPR Repeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Repeat(const Repeat& from);
  Repeat(Repeat&& from) noexcept
    : Repeat() {
    *this = ::std::move(from);
  }

  inline Repeat& operator=(const Repeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Repeat& operator=(Repeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Repeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Repeat* internal_default_instance() {
    return reinterpret_cast<const Repeat*>(
               &_Repeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Repeat& a, Repeat& b) {
    a.Swap(&b);
  }
  inline void Swap(Repeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Repeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Repeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Repeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Repeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Repeat& from) {
    Repeat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Repeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Repeat";
  }
  protected:
  explicit Repeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartCounterStateNameFieldNumber = 5,
    kChildFieldNumber = 4,
    kMaxStartsFieldNumber = 1,
    kRespectChildFailureFieldNumber = 6,
  };
  // string start_counter_state_name = 5;
  void clear_start_counter_state_name();
  const std::string& start_counter_state_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_counter_state_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_counter_state_name();
  PROTOBUF_NODISCARD std::string* release_start_counter_state_name();
  void set_allocated_start_counter_state_name(std::string* start_counter_state_name);
  private:
  const std::string& _internal_start_counter_state_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_counter_state_name(const std::string& value);
  std::string* _internal_mutable_start_counter_state_name();
  public:

  // .bosdyn.api.mission.Node child = 4;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // int32 max_starts = 1;
  void clear_max_starts();
  int32_t max_starts() const;
  void set_max_starts(int32_t value);
  private:
  int32_t _internal_max_starts() const;
  void _internal_set_max_starts(int32_t value);
  public:

  // bool respect_child_failure = 6;
  void clear_respect_child_failure();
  bool respect_child_failure() const;
  void set_respect_child_failure(bool value);
  private:
  bool _internal_respect_child_failure() const;
  void _internal_set_respect_child_failure(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Repeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_counter_state_name_;
    ::bosdyn::api::mission::Node* child_;
    int32_t max_starts_;
    bool respect_child_failure_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Retry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Retry) */ {
 public:
  inline Retry() : Retry(nullptr) {}
  ~Retry() override;
  explicit PROTOBUF_CONSTEXPR Retry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Retry(const Retry& from);
  Retry(Retry&& from) noexcept
    : Retry() {
    *this = ::std::move(from);
  }

  inline Retry& operator=(const Retry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Retry& operator=(Retry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Retry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Retry* internal_default_instance() {
    return reinterpret_cast<const Retry*>(
               &_Retry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Retry& a, Retry& b) {
    a.Swap(&b);
  }
  inline void Swap(Retry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Retry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Retry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Retry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Retry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Retry& from) {
    Retry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Retry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Retry";
  }
  protected:
  explicit Retry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttemptCounterStateNameFieldNumber = 5,
    kChildFieldNumber = 2,
    kMaxAttemptsFieldNumber = 1,
  };
  // string attempt_counter_state_name = 5;
  void clear_attempt_counter_state_name();
  const std::string& attempt_counter_state_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attempt_counter_state_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attempt_counter_state_name();
  PROTOBUF_NODISCARD std::string* release_attempt_counter_state_name();
  void set_allocated_attempt_counter_state_name(std::string* attempt_counter_state_name);
  private:
  const std::string& _internal_attempt_counter_state_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attempt_counter_state_name(const std::string& value);
  std::string* _internal_mutable_attempt_counter_state_name();
  public:

  // .bosdyn.api.mission.Node child = 2;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // int32 max_attempts = 1;
  void clear_max_attempts();
  int32_t max_attempts() const;
  void set_max_attempts(int32_t value);
  private:
  int32_t _internal_max_attempts() const;
  void _internal_set_max_attempts(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Retry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attempt_counter_state_name_;
    ::bosdyn::api::mission::Node* child_;
    int32_t max_attempts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class ForDuration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.ForDuration) */ {
 public:
  inline ForDuration() : ForDuration(nullptr) {}
  ~ForDuration() override;
  explicit PROTOBUF_CONSTEXPR ForDuration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForDuration(const ForDuration& from);
  ForDuration(ForDuration&& from) noexcept
    : ForDuration() {
    *this = ::std::move(from);
  }

  inline ForDuration& operator=(const ForDuration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForDuration& operator=(ForDuration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForDuration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForDuration* internal_default_instance() {
    return reinterpret_cast<const ForDuration*>(
               &_ForDuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ForDuration& a, ForDuration& b) {
    a.Swap(&b);
  }
  inline void Swap(ForDuration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForDuration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForDuration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForDuration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForDuration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForDuration& from) {
    ForDuration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForDuration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.ForDuration";
  }
  protected:
  explicit ForDuration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeRemainingNameFieldNumber = 3,
    kDurationFieldNumber = 1,
    kChildFieldNumber = 2,
    kTimeoutChildFieldNumber = 4,
  };
  // string time_remaining_name = 3;
  void clear_time_remaining_name();
  const std::string& time_remaining_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_remaining_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_remaining_name();
  PROTOBUF_NODISCARD std::string* release_time_remaining_name();
  void set_allocated_time_remaining_name(std::string* time_remaining_name);
  private:
  const std::string& _internal_time_remaining_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_remaining_name(const std::string& value);
  std::string* _internal_mutable_time_remaining_name();
  public:

  // .google.protobuf.Duration duration = 1;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_duration();
  void set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_duration();

  // .bosdyn.api.mission.Node child = 2;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // .bosdyn.api.mission.Node timeout_child = 4;
  bool has_timeout_child() const;
  private:
  bool _internal_has_timeout_child() const;
  public:
  void clear_timeout_child();
  const ::bosdyn::api::mission::Node& timeout_child() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Node* release_timeout_child();
  ::bosdyn::api::mission::Node* mutable_timeout_child();
  void set_allocated_timeout_child(::bosdyn::api::mission::Node* timeout_child);
  private:
  const ::bosdyn::api::mission::Node& _internal_timeout_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_timeout_child();
  public:
  void unsafe_arena_set_allocated_timeout_child(
      ::bosdyn::api::mission::Node* timeout_child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_timeout_child();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.ForDuration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_remaining_name_;
    ::PROTOBUF_NAMESPACE_ID::Duration* duration_;
    ::bosdyn::api::mission::Node* child_;
    ::bosdyn::api::mission::Node* timeout_child_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class SimpleParallel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.SimpleParallel) */ {
 public:
  inline SimpleParallel() : SimpleParallel(nullptr) {}
  ~SimpleParallel() override;
  explicit PROTOBUF_CONSTEXPR SimpleParallel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimpleParallel(const SimpleParallel& from);
  SimpleParallel(SimpleParallel&& from) noexcept
    : SimpleParallel() {
    *this = ::std::move(from);
  }

  inline SimpleParallel& operator=(const SimpleParallel& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimpleParallel& operator=(SimpleParallel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimpleParallel& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimpleParallel* internal_default_instance() {
    return reinterpret_cast<const SimpleParallel*>(
               &_SimpleParallel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SimpleParallel& a, SimpleParallel& b) {
    a.Swap(&b);
  }
  inline void Swap(SimpleParallel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimpleParallel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimpleParallel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimpleParallel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimpleParallel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SimpleParallel& from) {
    SimpleParallel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimpleParallel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.SimpleParallel";
  }
  protected:
  explicit SimpleParallel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrimaryFieldNumber = 1,
    kSecondaryFieldNumber = 2,
  };
  // .bosdyn.api.mission.Node primary = 1;
  bool has_primary() const;
  private:
  bool _internal_has_primary() const;
  public:
  void clear_primary();
  const ::bosdyn::api::mission::Node& primary() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Node* release_primary();
  ::bosdyn::api::mission::Node* mutable_primary();
  void set_allocated_primary(::bosdyn::api::mission::Node* primary);
  private:
  const ::bosdyn::api::mission::Node& _internal_primary() const;
  ::bosdyn::api::mission::Node* _internal_mutable_primary();
  public:
  void unsafe_arena_set_allocated_primary(
      ::bosdyn::api::mission::Node* primary);
  ::bosdyn::api::mission::Node* unsafe_arena_release_primary();

  // .bosdyn.api.mission.Node secondary = 2;
  bool has_secondary() const;
  private:
  bool _internal_has_secondary() const;
  public:
  void clear_secondary();
  const ::bosdyn::api::mission::Node& secondary() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Node* release_secondary();
  ::bosdyn::api::mission::Node* mutable_secondary();
  void set_allocated_secondary(::bosdyn::api::mission::Node* secondary);
  private:
  const ::bosdyn::api::mission::Node& _internal_secondary() const;
  ::bosdyn::api::mission::Node* _internal_mutable_secondary();
  public:
  void unsafe_arena_set_allocated_secondary(
      ::bosdyn::api::mission::Node* secondary);
  ::bosdyn::api::mission::Node* unsafe_arena_release_secondary();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.SimpleParallel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::mission::Node* primary_;
    ::bosdyn::api::mission::Node* secondary_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Condition_Operand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Condition.Operand) */ {
 public:
  inline Condition_Operand() : Condition_Operand(nullptr) {}
  ~Condition_Operand() override;
  explicit PROTOBUF_CONSTEXPR Condition_Operand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Condition_Operand(const Condition_Operand& from);
  Condition_Operand(Condition_Operand&& from) noexcept
    : Condition_Operand() {
    *this = ::std::move(from);
  }

  inline Condition_Operand& operator=(const Condition_Operand& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition_Operand& operator=(Condition_Operand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Condition_Operand& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kVar = 1,
    kConst = 2,
    TYPE_NOT_SET = 0,
  };

  static inline const Condition_Operand* internal_default_instance() {
    return reinterpret_cast<const Condition_Operand*>(
               &_Condition_Operand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Condition_Operand& a, Condition_Operand& b) {
    a.Swap(&b);
  }
  inline void Swap(Condition_Operand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Condition_Operand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Condition_Operand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Condition_Operand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Condition_Operand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Condition_Operand& from) {
    Condition_Operand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition_Operand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Condition.Operand";
  }
  protected:
  explicit Condition_Operand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarFieldNumber = 1,
    kConstFieldNumber = 2,
  };
  // .bosdyn.api.mission.VariableDeclaration var = 1;
  bool has_var() const;
  private:
  bool _internal_has_var() const;
  public:
  void clear_var();
  const ::bosdyn::api::mission::VariableDeclaration& var() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::VariableDeclaration* release_var();
  ::bosdyn::api::mission::VariableDeclaration* mutable_var();
  void set_allocated_var(::bosdyn::api::mission::VariableDeclaration* var);
  private:
  const ::bosdyn::api::mission::VariableDeclaration& _internal_var() const;
  ::bosdyn::api::mission::VariableDeclaration* _internal_mutable_var();
  public:
  void unsafe_arena_set_allocated_var(
      ::bosdyn::api::mission::VariableDeclaration* var);
  ::bosdyn::api::mission::VariableDeclaration* unsafe_arena_release_var();

  // .bosdyn.api.mission.ConstantValue const = 2;
  bool has_const_() const;
  private:
  bool _internal_has_const_() const;
  public:
  void clear_const_();
  const ::bosdyn::api::mission::ConstantValue& const_() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::ConstantValue* release_const_();
  ::bosdyn::api::mission::ConstantValue* mutable_const_();
  void set_allocated_const_(::bosdyn::api::mission::ConstantValue* const_);
  private:
  const ::bosdyn::api::mission::ConstantValue& _internal_const_() const;
  ::bosdyn::api::mission::ConstantValue* _internal_mutable_const_();
  public:
  void unsafe_arena_set_allocated_const_(
      ::bosdyn::api::mission::ConstantValue* const_);
  ::bosdyn::api::mission::ConstantValue* unsafe_arena_release_const_();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Condition.Operand)
 private:
  class _Internal;
  void set_has_var();
  void set_has_const_();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::mission::VariableDeclaration* var_;
      ::bosdyn::api::mission::ConstantValue* const__;
    } type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Condition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Condition) */ {
 public:
  inline Condition() : Condition(nullptr) {}
  ~Condition() override;
  explicit PROTOBUF_CONSTEXPR Condition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Condition(const Condition& from);
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition& operator=(Condition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Condition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }
  inline void Swap(Condition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Condition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Condition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Condition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Condition& from) {
    Condition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Condition";
  }
  protected:
  explicit Condition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Condition_Operand Operand;

  typedef Condition_Compare Compare;
  static constexpr Compare COMPARE_UNKNOWN =
    Condition_Compare_COMPARE_UNKNOWN;
  static constexpr Compare COMPARE_EQ =
    Condition_Compare_COMPARE_EQ;
  static constexpr Compare COMPARE_NE =
    Condition_Compare_COMPARE_NE;
  static constexpr Compare COMPARE_LT =
    Condition_Compare_COMPARE_LT;
  static constexpr Compare COMPARE_GT =
    Condition_Compare_COMPARE_GT;
  static constexpr Compare COMPARE_LE =
    Condition_Compare_COMPARE_LE;
  static constexpr Compare COMPARE_GE =
    Condition_Compare_COMPARE_GE;
  static inline bool Compare_IsValid(int value) {
    return Condition_Compare_IsValid(value);
  }
  static constexpr Compare Compare_MIN =
    Condition_Compare_Compare_MIN;
  static constexpr Compare Compare_MAX =
    Condition_Compare_Compare_MAX;
  static constexpr int Compare_ARRAYSIZE =
    Condition_Compare_Compare_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Compare_descriptor() {
    return Condition_Compare_descriptor();
  }
  template<typename T>
  static inline const std::string& Compare_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Compare>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Compare_Name.");
    return Condition_Compare_Name(enum_t_value);
  }
  static inline bool Compare_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Compare* value) {
    return Condition_Compare_Parse(name, value);
  }

  typedef Condition_HandleStaleness HandleStaleness;
  static constexpr HandleStaleness HANDLE_STALE_UNKNOWN =
    Condition_HandleStaleness_HANDLE_STALE_UNKNOWN;
  static constexpr HandleStaleness HANDLE_STALE_READ_ANYWAY =
    Condition_HandleStaleness_HANDLE_STALE_READ_ANYWAY;
  static constexpr HandleStaleness HANDLE_STALE_RUN_UNTIL_FRESH =
    Condition_HandleStaleness_HANDLE_STALE_RUN_UNTIL_FRESH;
  static constexpr HandleStaleness HANDLE_STALE_FAIL =
    Condition_HandleStaleness_HANDLE_STALE_FAIL;
  static inline bool HandleStaleness_IsValid(int value) {
    return Condition_HandleStaleness_IsValid(value);
  }
  static constexpr HandleStaleness HandleStaleness_MIN =
    Condition_HandleStaleness_HandleStaleness_MIN;
  static constexpr HandleStaleness HandleStaleness_MAX =
    Condition_HandleStaleness_HandleStaleness_MAX;
  static constexpr int HandleStaleness_ARRAYSIZE =
    Condition_HandleStaleness_HandleStaleness_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HandleStaleness_descriptor() {
    return Condition_HandleStaleness_descriptor();
  }
  template<typename T>
  static inline const std::string& HandleStaleness_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HandleStaleness>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HandleStaleness_Name.");
    return Condition_HandleStaleness_Name(enum_t_value);
  }
  static inline bool HandleStaleness_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      HandleStaleness* value) {
    return Condition_HandleStaleness_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLhsFieldNumber = 1,
    kRhsFieldNumber = 2,
    kOperationFieldNumber = 5,
    kHandleStalenessFieldNumber = 6,
  };
  // .bosdyn.api.mission.Condition.Operand lhs = 1;
  bool has_lhs() const;
  private:
  bool _internal_has_lhs() const;
  public:
  void clear_lhs();
  const ::bosdyn::api::mission::Condition_Operand& lhs() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Condition_Operand* release_lhs();
  ::bosdyn::api::mission::Condition_Operand* mutable_lhs();
  void set_allocated_lhs(::bosdyn::api::mission::Condition_Operand* lhs);
  private:
  const ::bosdyn::api::mission::Condition_Operand& _internal_lhs() const;
  ::bosdyn::api::mission::Condition_Operand* _internal_mutable_lhs();
  public:
  void unsafe_arena_set_allocated_lhs(
      ::bosdyn::api::mission::Condition_Operand* lhs);
  ::bosdyn::api::mission::Condition_Operand* unsafe_arena_release_lhs();

  // .bosdyn.api.mission.Condition.Operand rhs = 2;
  bool has_rhs() const;
  private:
  bool _internal_has_rhs() const;
  public:
  void clear_rhs();
  const ::bosdyn::api::mission::Condition_Operand& rhs() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Condition_Operand* release_rhs();
  ::bosdyn::api::mission::Condition_Operand* mutable_rhs();
  void set_allocated_rhs(::bosdyn::api::mission::Condition_Operand* rhs);
  private:
  const ::bosdyn::api::mission::Condition_Operand& _internal_rhs() const;
  ::bosdyn::api::mission::Condition_Operand* _internal_mutable_rhs();
  public:
  void unsafe_arena_set_allocated_rhs(
      ::bosdyn::api::mission::Condition_Operand* rhs);
  ::bosdyn::api::mission::Condition_Operand* unsafe_arena_release_rhs();

  // .bosdyn.api.mission.Condition.Compare operation = 5;
  void clear_operation();
  ::bosdyn::api::mission::Condition_Compare operation() const;
  void set_operation(::bosdyn::api::mission::Condition_Compare value);
  private:
  ::bosdyn::api::mission::Condition_Compare _internal_operation() const;
  void _internal_set_operation(::bosdyn::api::mission::Condition_Compare value);
  public:

  // .bosdyn.api.mission.Condition.HandleStaleness handle_staleness = 6;
  void clear_handle_staleness();
  ::bosdyn::api::mission::Condition_HandleStaleness handle_staleness() const;
  void set_handle_staleness(::bosdyn::api::mission::Condition_HandleStaleness value);
  private:
  ::bosdyn::api::mission::Condition_HandleStaleness _internal_handle_staleness() const;
  void _internal_set_handle_staleness(::bosdyn::api::mission::Condition_HandleStaleness value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Condition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::mission::Condition_Operand* lhs_;
    ::bosdyn::api::mission::Condition_Operand* rhs_;
    int operation_;
    int handle_staleness_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class BosdynRobotState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.BosdynRobotState) */ {
 public:
  inline BosdynRobotState() : BosdynRobotState(nullptr) {}
  ~BosdynRobotState() override;
  explicit PROTOBUF_CONSTEXPR BosdynRobotState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BosdynRobotState(const BosdynRobotState& from);
  BosdynRobotState(BosdynRobotState&& from) noexcept
    : BosdynRobotState() {
    *this = ::std::move(from);
  }

  inline BosdynRobotState& operator=(const BosdynRobotState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BosdynRobotState& operator=(BosdynRobotState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BosdynRobotState& default_instance() {
    return *internal_default_instance();
  }
  static inline const BosdynRobotState* internal_default_instance() {
    return reinterpret_cast<const BosdynRobotState*>(
               &_BosdynRobotState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BosdynRobotState& a, BosdynRobotState& b) {
    a.Swap(&b);
  }
  inline void Swap(BosdynRobotState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BosdynRobotState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BosdynRobotState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BosdynRobotState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BosdynRobotState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BosdynRobotState& from) {
    BosdynRobotState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BosdynRobotState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.BosdynRobotState";
  }
  protected:
  explicit BosdynRobotState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kStateNameFieldNumber = 4,
    kChildFieldNumber = 3,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string state_name = 4;
  void clear_state_name();
  const std::string& state_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state_name();
  PROTOBUF_NODISCARD std::string* release_state_name();
  void set_allocated_state_name(std::string* state_name);
  private:
  const std::string& _internal_state_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_name(const std::string& value);
  std::string* _internal_mutable_state_name();
  public:

  // .bosdyn.api.mission.Node child = 3;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.BosdynRobotState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_name_;
    ::bosdyn::api::mission::Node* child_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class BosdynDockState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.BosdynDockState) */ {
 public:
  inline BosdynDockState() : BosdynDockState(nullptr) {}
  ~BosdynDockState() override;
  explicit PROTOBUF_CONSTEXPR BosdynDockState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BosdynDockState(const BosdynDockState& from);
  BosdynDockState(BosdynDockState&& from) noexcept
    : BosdynDockState() {
    *this = ::std::move(from);
  }

  inline BosdynDockState& operator=(const BosdynDockState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BosdynDockState& operator=(BosdynDockState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BosdynDockState& default_instance() {
    return *internal_default_instance();
  }
  static inline const BosdynDockState* internal_default_instance() {
    return reinterpret_cast<const BosdynDockState*>(
               &_BosdynDockState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BosdynDockState& a, BosdynDockState& b) {
    a.Swap(&b);
  }
  inline void Swap(BosdynDockState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BosdynDockState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BosdynDockState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BosdynDockState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BosdynDockState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BosdynDockState& from) {
    BosdynDockState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BosdynDockState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.BosdynDockState";
  }
  protected:
  explicit BosdynDockState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kStateNameFieldNumber = 4,
    kChildFieldNumber = 3,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string state_name = 4;
  void clear_state_name();
  const std::string& state_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state_name();
  PROTOBUF_NODISCARD std::string* release_state_name();
  void set_allocated_state_name(std::string* state_name);
  private:
  const std::string& _internal_state_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_name(const std::string& value);
  std::string* _internal_mutable_state_name();
  public:

  // .bosdyn.api.mission.Node child = 3;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.BosdynDockState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_name_;
    ::bosdyn::api::mission::Node* child_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class BosdynRobotCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.BosdynRobotCommand) */ {
 public:
  inline BosdynRobotCommand() : BosdynRobotCommand(nullptr) {}
  ~BosdynRobotCommand() override;
  explicit PROTOBUF_CONSTEXPR BosdynRobotCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BosdynRobotCommand(const BosdynRobotCommand& from);
  BosdynRobotCommand(BosdynRobotCommand&& from) noexcept
    : BosdynRobotCommand() {
    *this = ::std::move(from);
  }

  inline BosdynRobotCommand& operator=(const BosdynRobotCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline BosdynRobotCommand& operator=(BosdynRobotCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BosdynRobotCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const BosdynRobotCommand* internal_default_instance() {
    return reinterpret_cast<const BosdynRobotCommand*>(
               &_BosdynRobotCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BosdynRobotCommand& a, BosdynRobotCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(BosdynRobotCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BosdynRobotCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BosdynRobotCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BosdynRobotCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BosdynRobotCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BosdynRobotCommand& from) {
    BosdynRobotCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BosdynRobotCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.BosdynRobotCommand";
  }
  protected:
  explicit BosdynRobotCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kCommandFieldNumber = 3,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // .bosdyn.api.RobotCommand command = 3;
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  const ::bosdyn::api::RobotCommand& command() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RobotCommand* release_command();
  ::bosdyn::api::RobotCommand* mutable_command();
  void set_allocated_command(::bosdyn::api::RobotCommand* command);
  private:
  const ::bosdyn::api::RobotCommand& _internal_command() const;
  ::bosdyn::api::RobotCommand* _internal_mutable_command();
  public:
  void unsafe_arena_set_allocated_command(
      ::bosdyn::api::RobotCommand* command);
  ::bosdyn::api::RobotCommand* unsafe_arena_release_command();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.BosdynRobotCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::bosdyn::api::RobotCommand* command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class BosdynPowerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.BosdynPowerRequest) */ {
 public:
  inline BosdynPowerRequest() : BosdynPowerRequest(nullptr) {}
  ~BosdynPowerRequest() override;
  explicit PROTOBUF_CONSTEXPR BosdynPowerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BosdynPowerRequest(const BosdynPowerRequest& from);
  BosdynPowerRequest(BosdynPowerRequest&& from) noexcept
    : BosdynPowerRequest() {
    *this = ::std::move(from);
  }

  inline BosdynPowerRequest& operator=(const BosdynPowerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BosdynPowerRequest& operator=(BosdynPowerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BosdynPowerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BosdynPowerRequest* internal_default_instance() {
    return reinterpret_cast<const BosdynPowerRequest*>(
               &_BosdynPowerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BosdynPowerRequest& a, BosdynPowerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BosdynPowerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BosdynPowerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BosdynPowerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BosdynPowerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BosdynPowerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BosdynPowerRequest& from) {
    BosdynPowerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BosdynPowerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.BosdynPowerRequest";
  }
  protected:
  explicit BosdynPowerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kRequestFieldNumber = 4,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // .bosdyn.api.PowerCommandRequest.Request request = 4;
  void clear_request();
  ::bosdyn::api::PowerCommandRequest_Request request() const;
  void set_request(::bosdyn::api::PowerCommandRequest_Request value);
  private:
  ::bosdyn::api::PowerCommandRequest_Request _internal_request() const;
  void _internal_set_request(::bosdyn::api::PowerCommandRequest_Request value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.BosdynPowerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    int request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class BosdynNavigateTo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.BosdynNavigateTo) */ {
 public:
  inline BosdynNavigateTo() : BosdynNavigateTo(nullptr) {}
  ~BosdynNavigateTo() override;
  explicit PROTOBUF_CONSTEXPR BosdynNavigateTo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BosdynNavigateTo(const BosdynNavigateTo& from);
  BosdynNavigateTo(BosdynNavigateTo&& from) noexcept
    : BosdynNavigateTo() {
    *this = ::std::move(from);
  }

  inline BosdynNavigateTo& operator=(const BosdynNavigateTo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BosdynNavigateTo& operator=(BosdynNavigateTo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BosdynNavigateTo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BosdynNavigateTo* internal_default_instance() {
    return reinterpret_cast<const BosdynNavigateTo*>(
               &_BosdynNavigateTo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BosdynNavigateTo& a, BosdynNavigateTo& b) {
    a.Swap(&b);
  }
  inline void Swap(BosdynNavigateTo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BosdynNavigateTo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BosdynNavigateTo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BosdynNavigateTo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BosdynNavigateTo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BosdynNavigateTo& from) {
    BosdynNavigateTo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BosdynNavigateTo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.BosdynNavigateTo";
  }
  protected:
  explicit BosdynNavigateTo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kDestinationWaypointIdFieldNumber = 3,
    kNavigationFeedbackResponseBlackboardKeyFieldNumber = 6,
    kNavigateToResponseBlackboardKeyFieldNumber = 7,
    kRouteGenParamsFieldNumber = 4,
    kTravelParamsFieldNumber = 5,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string destination_waypoint_id = 3;
  void clear_destination_waypoint_id();
  const std::string& destination_waypoint_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination_waypoint_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination_waypoint_id();
  PROTOBUF_NODISCARD std::string* release_destination_waypoint_id();
  void set_allocated_destination_waypoint_id(std::string* destination_waypoint_id);
  private:
  const std::string& _internal_destination_waypoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_waypoint_id(const std::string& value);
  std::string* _internal_mutable_destination_waypoint_id();
  public:

  // string navigation_feedback_response_blackboard_key = 6;
  void clear_navigation_feedback_response_blackboard_key();
  const std::string& navigation_feedback_response_blackboard_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_navigation_feedback_response_blackboard_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_navigation_feedback_response_blackboard_key();
  PROTOBUF_NODISCARD std::string* release_navigation_feedback_response_blackboard_key();
  void set_allocated_navigation_feedback_response_blackboard_key(std::string* navigation_feedback_response_blackboard_key);
  private:
  const std::string& _internal_navigation_feedback_response_blackboard_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_navigation_feedback_response_blackboard_key(const std::string& value);
  std::string* _internal_mutable_navigation_feedback_response_blackboard_key();
  public:

  // string navigate_to_response_blackboard_key = 7;
  void clear_navigate_to_response_blackboard_key();
  const std::string& navigate_to_response_blackboard_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_navigate_to_response_blackboard_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_navigate_to_response_blackboard_key();
  PROTOBUF_NODISCARD std::string* release_navigate_to_response_blackboard_key();
  void set_allocated_navigate_to_response_blackboard_key(std::string* navigate_to_response_blackboard_key);
  private:
  const std::string& _internal_navigate_to_response_blackboard_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_navigate_to_response_blackboard_key(const std::string& value);
  std::string* _internal_mutable_navigate_to_response_blackboard_key();
  public:

  // .bosdyn.api.graph_nav.RouteGenParams route_gen_params = 4;
  bool has_route_gen_params() const;
  private:
  bool _internal_has_route_gen_params() const;
  public:
  void clear_route_gen_params();
  const ::bosdyn::api::graph_nav::RouteGenParams& route_gen_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::RouteGenParams* release_route_gen_params();
  ::bosdyn::api::graph_nav::RouteGenParams* mutable_route_gen_params();
  void set_allocated_route_gen_params(::bosdyn::api::graph_nav::RouteGenParams* route_gen_params);
  private:
  const ::bosdyn::api::graph_nav::RouteGenParams& _internal_route_gen_params() const;
  ::bosdyn::api::graph_nav::RouteGenParams* _internal_mutable_route_gen_params();
  public:
  void unsafe_arena_set_allocated_route_gen_params(
      ::bosdyn::api::graph_nav::RouteGenParams* route_gen_params);
  ::bosdyn::api::graph_nav::RouteGenParams* unsafe_arena_release_route_gen_params();

  // .bosdyn.api.graph_nav.TravelParams travel_params = 5;
  bool has_travel_params() const;
  private:
  bool _internal_has_travel_params() const;
  public:
  void clear_travel_params();
  const ::bosdyn::api::graph_nav::TravelParams& travel_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::TravelParams* release_travel_params();
  ::bosdyn::api::graph_nav::TravelParams* mutable_travel_params();
  void set_allocated_travel_params(::bosdyn::api::graph_nav::TravelParams* travel_params);
  private:
  const ::bosdyn::api::graph_nav::TravelParams& _internal_travel_params() const;
  ::bosdyn::api::graph_nav::TravelParams* _internal_mutable_travel_params();
  public:
  void unsafe_arena_set_allocated_travel_params(
      ::bosdyn::api::graph_nav::TravelParams* travel_params);
  ::bosdyn::api::graph_nav::TravelParams* unsafe_arena_release_travel_params();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.BosdynNavigateTo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_waypoint_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr navigation_feedback_response_blackboard_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr navigate_to_response_blackboard_key_;
    ::bosdyn::api::graph_nav::RouteGenParams* route_gen_params_;
    ::bosdyn::api::graph_nav::TravelParams* travel_params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class BosdynNavigateRoute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.BosdynNavigateRoute) */ {
 public:
  inline BosdynNavigateRoute() : BosdynNavigateRoute(nullptr) {}
  ~BosdynNavigateRoute() override;
  explicit PROTOBUF_CONSTEXPR BosdynNavigateRoute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BosdynNavigateRoute(const BosdynNavigateRoute& from);
  BosdynNavigateRoute(BosdynNavigateRoute&& from) noexcept
    : BosdynNavigateRoute() {
    *this = ::std::move(from);
  }

  inline BosdynNavigateRoute& operator=(const BosdynNavigateRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline BosdynNavigateRoute& operator=(BosdynNavigateRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BosdynNavigateRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const BosdynNavigateRoute* internal_default_instance() {
    return reinterpret_cast<const BosdynNavigateRoute*>(
               &_BosdynNavigateRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(BosdynNavigateRoute& a, BosdynNavigateRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(BosdynNavigateRoute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BosdynNavigateRoute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BosdynNavigateRoute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BosdynNavigateRoute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BosdynNavigateRoute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BosdynNavigateRoute& from) {
    BosdynNavigateRoute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BosdynNavigateRoute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.BosdynNavigateRoute";
  }
  protected:
  explicit BosdynNavigateRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kNavigationFeedbackResponseBlackboardKeyFieldNumber = 6,
    kNavigateRouteResponseBlackboardKeyFieldNumber = 7,
    kRouteFieldNumber = 3,
    kRouteFollowParamsFieldNumber = 4,
    kTravelParamsFieldNumber = 5,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string navigation_feedback_response_blackboard_key = 6;
  void clear_navigation_feedback_response_blackboard_key();
  const std::string& navigation_feedback_response_blackboard_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_navigation_feedback_response_blackboard_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_navigation_feedback_response_blackboard_key();
  PROTOBUF_NODISCARD std::string* release_navigation_feedback_response_blackboard_key();
  void set_allocated_navigation_feedback_response_blackboard_key(std::string* navigation_feedback_response_blackboard_key);
  private:
  const std::string& _internal_navigation_feedback_response_blackboard_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_navigation_feedback_response_blackboard_key(const std::string& value);
  std::string* _internal_mutable_navigation_feedback_response_blackboard_key();
  public:

  // string navigate_route_response_blackboard_key = 7;
  void clear_navigate_route_response_blackboard_key();
  const std::string& navigate_route_response_blackboard_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_navigate_route_response_blackboard_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_navigate_route_response_blackboard_key();
  PROTOBUF_NODISCARD std::string* release_navigate_route_response_blackboard_key();
  void set_allocated_navigate_route_response_blackboard_key(std::string* navigate_route_response_blackboard_key);
  private:
  const std::string& _internal_navigate_route_response_blackboard_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_navigate_route_response_blackboard_key(const std::string& value);
  std::string* _internal_mutable_navigate_route_response_blackboard_key();
  public:

  // .bosdyn.api.graph_nav.Route route = 3;
  bool has_route() const;
  private:
  bool _internal_has_route() const;
  public:
  void clear_route();
  const ::bosdyn::api::graph_nav::Route& route() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::Route* release_route();
  ::bosdyn::api::graph_nav::Route* mutable_route();
  void set_allocated_route(::bosdyn::api::graph_nav::Route* route);
  private:
  const ::bosdyn::api::graph_nav::Route& _internal_route() const;
  ::bosdyn::api::graph_nav::Route* _internal_mutable_route();
  public:
  void unsafe_arena_set_allocated_route(
      ::bosdyn::api::graph_nav::Route* route);
  ::bosdyn::api::graph_nav::Route* unsafe_arena_release_route();

  // .bosdyn.api.graph_nav.RouteFollowingParams route_follow_params = 4;
  bool has_route_follow_params() const;
  private:
  bool _internal_has_route_follow_params() const;
  public:
  void clear_route_follow_params();
  const ::bosdyn::api::graph_nav::RouteFollowingParams& route_follow_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::RouteFollowingParams* release_route_follow_params();
  ::bosdyn::api::graph_nav::RouteFollowingParams* mutable_route_follow_params();
  void set_allocated_route_follow_params(::bosdyn::api::graph_nav::RouteFollowingParams* route_follow_params);
  private:
  const ::bosdyn::api::graph_nav::RouteFollowingParams& _internal_route_follow_params() const;
  ::bosdyn::api::graph_nav::RouteFollowingParams* _internal_mutable_route_follow_params();
  public:
  void unsafe_arena_set_allocated_route_follow_params(
      ::bosdyn::api::graph_nav::RouteFollowingParams* route_follow_params);
  ::bosdyn::api::graph_nav::RouteFollowingParams* unsafe_arena_release_route_follow_params();

  // .bosdyn.api.graph_nav.TravelParams travel_params = 5;
  bool has_travel_params() const;
  private:
  bool _internal_has_travel_params() const;
  public:
  void clear_travel_params();
  const ::bosdyn::api::graph_nav::TravelParams& travel_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::TravelParams* release_travel_params();
  ::bosdyn::api::graph_nav::TravelParams* mutable_travel_params();
  void set_allocated_travel_params(::bosdyn::api::graph_nav::TravelParams* travel_params);
  private:
  const ::bosdyn::api::graph_nav::TravelParams& _internal_travel_params() const;
  ::bosdyn::api::graph_nav::TravelParams* _internal_mutable_travel_params();
  public:
  void unsafe_arena_set_allocated_travel_params(
      ::bosdyn::api::graph_nav::TravelParams* travel_params);
  ::bosdyn::api::graph_nav::TravelParams* unsafe_arena_release_travel_params();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.BosdynNavigateRoute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr navigation_feedback_response_blackboard_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr navigate_route_response_blackboard_key_;
    ::bosdyn::api::graph_nav::Route* route_;
    ::bosdyn::api::graph_nav::RouteFollowingParams* route_follow_params_;
    ::bosdyn::api::graph_nav::TravelParams* travel_params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class BosdynGraphNavState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.BosdynGraphNavState) */ {
 public:
  inline BosdynGraphNavState() : BosdynGraphNavState(nullptr) {}
  ~BosdynGraphNavState() override;
  explicit PROTOBUF_CONSTEXPR BosdynGraphNavState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BosdynGraphNavState(const BosdynGraphNavState& from);
  BosdynGraphNavState(BosdynGraphNavState&& from) noexcept
    : BosdynGraphNavState() {
    *this = ::std::move(from);
  }

  inline BosdynGraphNavState& operator=(const BosdynGraphNavState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BosdynGraphNavState& operator=(BosdynGraphNavState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BosdynGraphNavState& default_instance() {
    return *internal_default_instance();
  }
  static inline const BosdynGraphNavState* internal_default_instance() {
    return reinterpret_cast<const BosdynGraphNavState*>(
               &_BosdynGraphNavState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BosdynGraphNavState& a, BosdynGraphNavState& b) {
    a.Swap(&b);
  }
  inline void Swap(BosdynGraphNavState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BosdynGraphNavState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BosdynGraphNavState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BosdynGraphNavState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BosdynGraphNavState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BosdynGraphNavState& from) {
    BosdynGraphNavState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BosdynGraphNavState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.BosdynGraphNavState";
  }
  protected:
  explicit BosdynGraphNavState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kStateNameFieldNumber = 4,
    kWaypointIdFieldNumber = 5,
    kChildFieldNumber = 3,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string state_name = 4;
  void clear_state_name();
  const std::string& state_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state_name();
  PROTOBUF_NODISCARD std::string* release_state_name();
  void set_allocated_state_name(std::string* state_name);
  private:
  const std::string& _internal_state_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_name(const std::string& value);
  std::string* _internal_mutable_state_name();
  public:

  // string waypoint_id = 5;
  void clear_waypoint_id();
  const std::string& waypoint_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_waypoint_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_waypoint_id();
  PROTOBUF_NODISCARD std::string* release_waypoint_id();
  void set_allocated_waypoint_id(std::string* waypoint_id);
  private:
  const std::string& _internal_waypoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_waypoint_id(const std::string& value);
  std::string* _internal_mutable_waypoint_id();
  public:

  // .bosdyn.api.mission.Node child = 3;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.BosdynGraphNavState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr waypoint_id_;
    ::bosdyn::api::mission::Node* child_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class BosdynGraphNavLocalize final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.BosdynGraphNavLocalize) */ {
 public:
  inline BosdynGraphNavLocalize() : BosdynGraphNavLocalize(nullptr) {}
  ~BosdynGraphNavLocalize() override;
  explicit PROTOBUF_CONSTEXPR BosdynGraphNavLocalize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BosdynGraphNavLocalize(const BosdynGraphNavLocalize& from);
  BosdynGraphNavLocalize(BosdynGraphNavLocalize&& from) noexcept
    : BosdynGraphNavLocalize() {
    *this = ::std::move(from);
  }

  inline BosdynGraphNavLocalize& operator=(const BosdynGraphNavLocalize& from) {
    CopyFrom(from);
    return *this;
  }
  inline BosdynGraphNavLocalize& operator=(BosdynGraphNavLocalize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BosdynGraphNavLocalize& default_instance() {
    return *internal_default_instance();
  }
  static inline const BosdynGraphNavLocalize* internal_default_instance() {
    return reinterpret_cast<const BosdynGraphNavLocalize*>(
               &_BosdynGraphNavLocalize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BosdynGraphNavLocalize& a, BosdynGraphNavLocalize& b) {
    a.Swap(&b);
  }
  inline void Swap(BosdynGraphNavLocalize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BosdynGraphNavLocalize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BosdynGraphNavLocalize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BosdynGraphNavLocalize>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BosdynGraphNavLocalize& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BosdynGraphNavLocalize& from) {
    BosdynGraphNavLocalize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BosdynGraphNavLocalize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.BosdynGraphNavLocalize";
  }
  protected:
  explicit BosdynGraphNavLocalize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kLocalizationRequestFieldNumber = 3,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // .bosdyn.api.graph_nav.SetLocalizationRequest localization_request = 3;
  bool has_localization_request() const;
  private:
  bool _internal_has_localization_request() const;
  public:
  void clear_localization_request();
  const ::bosdyn::api::graph_nav::SetLocalizationRequest& localization_request() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::SetLocalizationRequest* release_localization_request();
  ::bosdyn::api::graph_nav::SetLocalizationRequest* mutable_localization_request();
  void set_allocated_localization_request(::bosdyn::api::graph_nav::SetLocalizationRequest* localization_request);
  private:
  const ::bosdyn::api::graph_nav::SetLocalizationRequest& _internal_localization_request() const;
  ::bosdyn::api::graph_nav::SetLocalizationRequest* _internal_mutable_localization_request();
  public:
  void unsafe_arena_set_allocated_localization_request(
      ::bosdyn::api::graph_nav::SetLocalizationRequest* localization_request);
  ::bosdyn::api::graph_nav::SetLocalizationRequest* unsafe_arena_release_localization_request();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.BosdynGraphNavLocalize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::bosdyn::api::graph_nav::SetLocalizationRequest* localization_request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class BosdynRecordEvent_AdditionalParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BosdynRecordEvent_AdditionalParametersEntry_DoNotUse, 
    std::string, ::bosdyn::api::mission::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BosdynRecordEvent_AdditionalParametersEntry_DoNotUse, 
    std::string, ::bosdyn::api::mission::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  BosdynRecordEvent_AdditionalParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR BosdynRecordEvent_AdditionalParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit BosdynRecordEvent_AdditionalParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const BosdynRecordEvent_AdditionalParametersEntry_DoNotUse& other);
  static const BosdynRecordEvent_AdditionalParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BosdynRecordEvent_AdditionalParametersEntry_DoNotUse*>(&_BosdynRecordEvent_AdditionalParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.mission.BosdynRecordEvent.AdditionalParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};

// -------------------------------------------------------------------

class BosdynRecordEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.BosdynRecordEvent) */ {
 public:
  inline BosdynRecordEvent() : BosdynRecordEvent(nullptr) {}
  ~BosdynRecordEvent() override;
  explicit PROTOBUF_CONSTEXPR BosdynRecordEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BosdynRecordEvent(const BosdynRecordEvent& from);
  BosdynRecordEvent(BosdynRecordEvent&& from) noexcept
    : BosdynRecordEvent() {
    *this = ::std::move(from);
  }

  inline BosdynRecordEvent& operator=(const BosdynRecordEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BosdynRecordEvent& operator=(BosdynRecordEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BosdynRecordEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BosdynRecordEvent* internal_default_instance() {
    return reinterpret_cast<const BosdynRecordEvent*>(
               &_BosdynRecordEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BosdynRecordEvent& a, BosdynRecordEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BosdynRecordEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BosdynRecordEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BosdynRecordEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BosdynRecordEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BosdynRecordEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BosdynRecordEvent& from) {
    BosdynRecordEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BosdynRecordEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.BosdynRecordEvent";
  }
  protected:
  explicit BosdynRecordEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalParametersFieldNumber = 5,
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kEventFieldNumber = 3,
    kSucceedEarlyFieldNumber = 4,
  };
  // map<string, .bosdyn.api.mission.Value> additional_parameters = 5;
  int additional_parameters_size() const;
  private:
  int _internal_additional_parameters_size() const;
  public:
  void clear_additional_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::mission::Value >&
      _internal_additional_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::mission::Value >*
      _internal_mutable_additional_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::mission::Value >&
      additional_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::mission::Value >*
      mutable_additional_parameters();

  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // .bosdyn.api.Event event = 3;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::bosdyn::api::Event& event() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Event* release_event();
  ::bosdyn::api::Event* mutable_event();
  void set_allocated_event(::bosdyn::api::Event* event);
  private:
  const ::bosdyn::api::Event& _internal_event() const;
  ::bosdyn::api::Event* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::bosdyn::api::Event* event);
  ::bosdyn::api::Event* unsafe_arena_release_event();

  // bool succeed_early = 4;
  void clear_succeed_early();
  bool succeed_early() const;
  void set_succeed_early(bool value);
  private:
  bool _internal_succeed_early() const;
  void _internal_set_succeed_early(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.BosdynRecordEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        BosdynRecordEvent_AdditionalParametersEntry_DoNotUse,
        std::string, ::bosdyn::api::mission::Value,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> additional_parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::bosdyn::api::Event* event_;
    bool succeed_early_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class RemoteGrpc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.RemoteGrpc) */ {
 public:
  inline RemoteGrpc() : RemoteGrpc(nullptr) {}
  ~RemoteGrpc() override;
  explicit PROTOBUF_CONSTEXPR RemoteGrpc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoteGrpc(const RemoteGrpc& from);
  RemoteGrpc(RemoteGrpc&& from) noexcept
    : RemoteGrpc() {
    *this = ::std::move(from);
  }

  inline RemoteGrpc& operator=(const RemoteGrpc& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteGrpc& operator=(RemoteGrpc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteGrpc& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteGrpc* internal_default_instance() {
    return reinterpret_cast<const RemoteGrpc*>(
               &_RemoteGrpc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RemoteGrpc& a, RemoteGrpc& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteGrpc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteGrpc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteGrpc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoteGrpc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoteGrpc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoteGrpc& from) {
    RemoteGrpc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteGrpc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.RemoteGrpc";
  }
  protected:
  explicit RemoteGrpc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaseResourcesFieldNumber = 5,
    kInputsFieldNumber = 6,
    kHostFieldNumber = 1,
    kServiceNameFieldNumber = 3,
    kTimeoutFieldNumber = 4,
  };
  // repeated string lease_resources = 5;
  int lease_resources_size() const;
  private:
  int _internal_lease_resources_size() const;
  public:
  void clear_lease_resources();
  const std::string& lease_resources(int index) const;
  std::string* mutable_lease_resources(int index);
  void set_lease_resources(int index, const std::string& value);
  void set_lease_resources(int index, std::string&& value);
  void set_lease_resources(int index, const char* value);
  void set_lease_resources(int index, const char* value, size_t size);
  std::string* add_lease_resources();
  void add_lease_resources(const std::string& value);
  void add_lease_resources(std::string&& value);
  void add_lease_resources(const char* value);
  void add_lease_resources(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& lease_resources() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_lease_resources();
  private:
  const std::string& _internal_lease_resources(int index) const;
  std::string* _internal_add_lease_resources();
  public:

  // repeated .bosdyn.api.mission.KeyValue inputs = 6;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::bosdyn::api::mission::KeyValue* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
      mutable_inputs();
  private:
  const ::bosdyn::api::mission::KeyValue& _internal_inputs(int index) const;
  ::bosdyn::api::mission::KeyValue* _internal_add_inputs();
  public:
  const ::bosdyn::api::mission::KeyValue& inputs(int index) const;
  ::bosdyn::api::mission::KeyValue* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
      inputs() const;

  // string host = 1;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string service_name = 3;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // float timeout = 4;
  void clear_timeout();
  float timeout() const;
  void set_timeout(float value);
  private:
  float _internal_timeout() const;
  void _internal_set_timeout(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.RemoteGrpc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> lease_resources_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue > inputs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    float timeout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Sleep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Sleep) */ {
 public:
  inline Sleep() : Sleep(nullptr) {}
  ~Sleep() override;
  explicit PROTOBUF_CONSTEXPR Sleep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sleep(const Sleep& from);
  Sleep(Sleep&& from) noexcept
    : Sleep() {
    *this = ::std::move(from);
  }

  inline Sleep& operator=(const Sleep& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sleep& operator=(Sleep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sleep& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sleep* internal_default_instance() {
    return reinterpret_cast<const Sleep*>(
               &_Sleep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Sleep& a, Sleep& b) {
    a.Swap(&b);
  }
  inline void Swap(Sleep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sleep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sleep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sleep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sleep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sleep& from) {
    Sleep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sleep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Sleep";
  }
  protected:
  explicit Sleep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kRestartAfterStopFieldNumber = 2,
  };
  // float seconds = 1;
  void clear_seconds();
  float seconds() const;
  void set_seconds(float value);
  private:
  float _internal_seconds() const;
  void _internal_set_seconds(float value);
  public:

  // bool restart_after_stop = 2;
  void clear_restart_after_stop();
  bool restart_after_stop() const;
  void set_restart_after_stop(bool value);
  private:
  bool _internal_restart_after_stop() const;
  void _internal_set_restart_after_stop(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Sleep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float seconds_;
    bool restart_after_stop_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Prompt_Option final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Prompt.Option) */ {
 public:
  inline Prompt_Option() : Prompt_Option(nullptr) {}
  ~Prompt_Option() override;
  explicit PROTOBUF_CONSTEXPR Prompt_Option(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Prompt_Option(const Prompt_Option& from);
  Prompt_Option(Prompt_Option&& from) noexcept
    : Prompt_Option() {
    *this = ::std::move(from);
  }

  inline Prompt_Option& operator=(const Prompt_Option& from) {
    CopyFrom(from);
    return *this;
  }
  inline Prompt_Option& operator=(Prompt_Option&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Prompt_Option& default_instance() {
    return *internal_default_instance();
  }
  static inline const Prompt_Option* internal_default_instance() {
    return reinterpret_cast<const Prompt_Option*>(
               &_Prompt_Option_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Prompt_Option& a, Prompt_Option& b) {
    a.Swap(&b);
  }
  inline void Swap(Prompt_Option* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Prompt_Option* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Prompt_Option* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Prompt_Option>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Prompt_Option& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Prompt_Option& from) {
    Prompt_Option::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Prompt_Option* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Prompt.Option";
  }
  protected:
  explicit Prompt_Option(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kAnswerCodeFieldNumber = 2,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // int64 answer_code = 2;
  void clear_answer_code();
  int64_t answer_code() const;
  void set_answer_code(int64_t value);
  private:
  int64_t _internal_answer_code() const;
  void _internal_set_answer_code(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Prompt.Option)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    int64_t answer_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Prompt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Prompt) */ {
 public:
  inline Prompt() : Prompt(nullptr) {}
  ~Prompt() override;
  explicit PROTOBUF_CONSTEXPR Prompt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Prompt(const Prompt& from);
  Prompt(Prompt&& from) noexcept
    : Prompt() {
    *this = ::std::move(from);
  }

  inline Prompt& operator=(const Prompt& from) {
    CopyFrom(from);
    return *this;
  }
  inline Prompt& operator=(Prompt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Prompt& default_instance() {
    return *internal_default_instance();
  }
  static inline const Prompt* internal_default_instance() {
    return reinterpret_cast<const Prompt*>(
               &_Prompt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Prompt& a, Prompt& b) {
    a.Swap(&b);
  }
  inline void Swap(Prompt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Prompt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Prompt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Prompt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Prompt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Prompt& from) {
    Prompt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Prompt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Prompt";
  }
  protected:
  explicit Prompt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Prompt_Option Option;

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 4,
    kTextFieldNumber = 2,
    kSourceFieldNumber = 3,
    kChildFieldNumber = 5,
    kAlwaysRepromptFieldNumber = 1,
    kForAutonomousProcessingFieldNumber = 6,
    kSeverityFieldNumber = 7,
  };
  // repeated .bosdyn.api.mission.Prompt.Option options = 4;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  ::bosdyn::api::mission::Prompt_Option* mutable_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Prompt_Option >*
      mutable_options();
  private:
  const ::bosdyn::api::mission::Prompt_Option& _internal_options(int index) const;
  ::bosdyn::api::mission::Prompt_Option* _internal_add_options();
  public:
  const ::bosdyn::api::mission::Prompt_Option& options(int index) const;
  ::bosdyn::api::mission::Prompt_Option* add_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Prompt_Option >&
      options() const;

  // string text = 2;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string source = 3;
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // .bosdyn.api.mission.Node child = 5;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // bool always_reprompt = 1;
  void clear_always_reprompt();
  bool always_reprompt() const;
  void set_always_reprompt(bool value);
  private:
  bool _internal_always_reprompt() const;
  void _internal_set_always_reprompt(bool value);
  public:

  // bool for_autonomous_processing = 6;
  void clear_for_autonomous_processing();
  bool for_autonomous_processing() const;
  void set_for_autonomous_processing(bool value);
  private:
  bool _internal_for_autonomous_processing() const;
  void _internal_set_for_autonomous_processing(bool value);
  public:

  // .bosdyn.api.AlertData.SeverityLevel severity = 7;
  void clear_severity();
  ::bosdyn::api::AlertData_SeverityLevel severity() const;
  void set_severity(::bosdyn::api::AlertData_SeverityLevel value);
  private:
  ::bosdyn::api::AlertData_SeverityLevel _internal_severity() const;
  void _internal_set_severity(::bosdyn::api::AlertData_SeverityLevel value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Prompt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Prompt_Option > options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    ::bosdyn::api::mission::Node* child_;
    bool always_reprompt_;
    bool for_autonomous_processing_;
    int severity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class BosdynGripperCameraParamsState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.BosdynGripperCameraParamsState) */ {
 public:
  inline BosdynGripperCameraParamsState() : BosdynGripperCameraParamsState(nullptr) {}
  ~BosdynGripperCameraParamsState() override;
  explicit PROTOBUF_CONSTEXPR BosdynGripperCameraParamsState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BosdynGripperCameraParamsState(const BosdynGripperCameraParamsState& from);
  BosdynGripperCameraParamsState(BosdynGripperCameraParamsState&& from) noexcept
    : BosdynGripperCameraParamsState() {
    *this = ::std::move(from);
  }

  inline BosdynGripperCameraParamsState& operator=(const BosdynGripperCameraParamsState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BosdynGripperCameraParamsState& operator=(BosdynGripperCameraParamsState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BosdynGripperCameraParamsState& default_instance() {
    return *internal_default_instance();
  }
  static inline const BosdynGripperCameraParamsState* internal_default_instance() {
    return reinterpret_cast<const BosdynGripperCameraParamsState*>(
               &_BosdynGripperCameraParamsState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(BosdynGripperCameraParamsState& a, BosdynGripperCameraParamsState& b) {
    a.Swap(&b);
  }
  inline void Swap(BosdynGripperCameraParamsState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BosdynGripperCameraParamsState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BosdynGripperCameraParamsState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BosdynGripperCameraParamsState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BosdynGripperCameraParamsState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BosdynGripperCameraParamsState& from) {
    BosdynGripperCameraParamsState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BosdynGripperCameraParamsState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.BosdynGripperCameraParamsState";
  }
  protected:
  explicit BosdynGripperCameraParamsState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kStateNameFieldNumber = 4,
    kChildFieldNumber = 3,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string state_name = 4;
  void clear_state_name();
  const std::string& state_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state_name();
  PROTOBUF_NODISCARD std::string* release_state_name();
  void set_allocated_state_name(std::string* state_name);
  private:
  const std::string& _internal_state_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_name(const std::string& value);
  std::string* _internal_mutable_state_name();
  public:

  // .bosdyn.api.mission.Node child = 3;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.BosdynGripperCameraParamsState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_name_;
    ::bosdyn::api::mission::Node* child_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class SetGripperCameraParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.SetGripperCameraParams) */ {
 public:
  inline SetGripperCameraParams() : SetGripperCameraParams(nullptr) {}
  ~SetGripperCameraParams() override;
  explicit PROTOBUF_CONSTEXPR SetGripperCameraParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetGripperCameraParams(const SetGripperCameraParams& from);
  SetGripperCameraParams(SetGripperCameraParams&& from) noexcept
    : SetGripperCameraParams() {
    *this = ::std::move(from);
  }

  inline SetGripperCameraParams& operator=(const SetGripperCameraParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetGripperCameraParams& operator=(SetGripperCameraParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetGripperCameraParams& default_instance() {
    return *internal_default_instance();
  }
  enum ParamsCase {
    kParamsInBlackboardKey = 3,
    kNewParams = 4,
    PARAMS_NOT_SET = 0,
  };

  static inline const SetGripperCameraParams* internal_default_instance() {
    return reinterpret_cast<const SetGripperCameraParams*>(
               &_SetGripperCameraParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SetGripperCameraParams& a, SetGripperCameraParams& b) {
    a.Swap(&b);
  }
  inline void Swap(SetGripperCameraParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetGripperCameraParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetGripperCameraParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetGripperCameraParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetGripperCameraParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetGripperCameraParams& from) {
    SetGripperCameraParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetGripperCameraParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.SetGripperCameraParams";
  }
  protected:
  explicit SetGripperCameraParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kParamsInBlackboardKeyFieldNumber = 3,
    kNewParamsFieldNumber = 4,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string params_in_blackboard_key = 3;
  bool has_params_in_blackboard_key() const;
  private:
  bool _internal_has_params_in_blackboard_key() const;
  public:
  void clear_params_in_blackboard_key();
  const std::string& params_in_blackboard_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_params_in_blackboard_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_params_in_blackboard_key();
  PROTOBUF_NODISCARD std::string* release_params_in_blackboard_key();
  void set_allocated_params_in_blackboard_key(std::string* params_in_blackboard_key);
  private:
  const std::string& _internal_params_in_blackboard_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_params_in_blackboard_key(const std::string& value);
  std::string* _internal_mutable_params_in_blackboard_key();
  public:

  // .bosdyn.api.GripperCameraParams new_params = 4;
  bool has_new_params() const;
  private:
  bool _internal_has_new_params() const;
  public:
  void clear_new_params();
  const ::bosdyn::api::GripperCameraParams& new_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::GripperCameraParams* release_new_params();
  ::bosdyn::api::GripperCameraParams* mutable_new_params();
  void set_allocated_new_params(::bosdyn::api::GripperCameraParams* new_params);
  private:
  const ::bosdyn::api::GripperCameraParams& _internal_new_params() const;
  ::bosdyn::api::GripperCameraParams* _internal_mutable_new_params();
  public:
  void unsafe_arena_set_allocated_new_params(
      ::bosdyn::api::GripperCameraParams* new_params);
  ::bosdyn::api::GripperCameraParams* unsafe_arena_release_new_params();

  void clear_params();
  ParamsCase params_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.SetGripperCameraParams)
 private:
  class _Internal;
  void set_has_params_in_blackboard_key();
  void set_has_new_params();

  inline bool has_params() const;
  inline void clear_has_params();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    union ParamsUnion {
      constexpr ParamsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr params_in_blackboard_key_;
      ::bosdyn::api::GripperCameraParams* new_params_;
    } params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class SpotCamPtz_AdjustParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.SpotCamPtz.AdjustParameters) */ {
 public:
  inline SpotCamPtz_AdjustParameters() : SpotCamPtz_AdjustParameters(nullptr) {}
  ~SpotCamPtz_AdjustParameters() override;
  explicit PROTOBUF_CONSTEXPR SpotCamPtz_AdjustParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotCamPtz_AdjustParameters(const SpotCamPtz_AdjustParameters& from);
  SpotCamPtz_AdjustParameters(SpotCamPtz_AdjustParameters&& from) noexcept
    : SpotCamPtz_AdjustParameters() {
    *this = ::std::move(from);
  }

  inline SpotCamPtz_AdjustParameters& operator=(const SpotCamPtz_AdjustParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotCamPtz_AdjustParameters& operator=(SpotCamPtz_AdjustParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotCamPtz_AdjustParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotCamPtz_AdjustParameters* internal_default_instance() {
    return reinterpret_cast<const SpotCamPtz_AdjustParameters*>(
               &_SpotCamPtz_AdjustParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SpotCamPtz_AdjustParameters& a, SpotCamPtz_AdjustParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotCamPtz_AdjustParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotCamPtz_AdjustParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotCamPtz_AdjustParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotCamPtz_AdjustParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotCamPtz_AdjustParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotCamPtz_AdjustParameters& from) {
    SpotCamPtz_AdjustParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotCamPtz_AdjustParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.SpotCamPtz.AdjustParameters";
  }
  protected:
  explicit SpotCamPtz_AdjustParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalizationVarnameFieldNumber = 4,
    kWaypointIdFieldNumber = 5,
    kWaypointTformBodyFieldNumber = 6,
  };
  // string localization_varname = 4;
  void clear_localization_varname();
  const std::string& localization_varname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_localization_varname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_localization_varname();
  PROTOBUF_NODISCARD std::string* release_localization_varname();
  void set_allocated_localization_varname(std::string* localization_varname);
  private:
  const std::string& _internal_localization_varname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_localization_varname(const std::string& value);
  std::string* _internal_mutable_localization_varname();
  public:

  // string waypoint_id = 5;
  void clear_waypoint_id();
  const std::string& waypoint_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_waypoint_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_waypoint_id();
  PROTOBUF_NODISCARD std::string* release_waypoint_id();
  void set_allocated_waypoint_id(std::string* waypoint_id);
  private:
  const std::string& _internal_waypoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_waypoint_id(const std::string& value);
  std::string* _internal_mutable_waypoint_id();
  public:

  // .bosdyn.api.SE3Pose waypoint_tform_body = 6;
  bool has_waypoint_tform_body() const;
  private:
  bool _internal_has_waypoint_tform_body() const;
  public:
  void clear_waypoint_tform_body();
  const ::bosdyn::api::SE3Pose& waypoint_tform_body() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Pose* release_waypoint_tform_body();
  ::bosdyn::api::SE3Pose* mutable_waypoint_tform_body();
  void set_allocated_waypoint_tform_body(::bosdyn::api::SE3Pose* waypoint_tform_body);
  private:
  const ::bosdyn::api::SE3Pose& _internal_waypoint_tform_body() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_waypoint_tform_body();
  public:
  void unsafe_arena_set_allocated_waypoint_tform_body(
      ::bosdyn::api::SE3Pose* waypoint_tform_body);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_waypoint_tform_body();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.SpotCamPtz.AdjustParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr localization_varname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr waypoint_id_;
    ::bosdyn::api::SE3Pose* waypoint_tform_body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class SpotCamPtz final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.SpotCamPtz) */ {
 public:
  inline SpotCamPtz() : SpotCamPtz(nullptr) {}
  ~SpotCamPtz() override;
  explicit PROTOBUF_CONSTEXPR SpotCamPtz(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotCamPtz(const SpotCamPtz& from);
  SpotCamPtz(SpotCamPtz&& from) noexcept
    : SpotCamPtz() {
    *this = ::std::move(from);
  }

  inline SpotCamPtz& operator=(const SpotCamPtz& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotCamPtz& operator=(SpotCamPtz&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotCamPtz& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotCamPtz* internal_default_instance() {
    return reinterpret_cast<const SpotCamPtz*>(
               &_SpotCamPtz_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SpotCamPtz& a, SpotCamPtz& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotCamPtz* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotCamPtz* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotCamPtz* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotCamPtz>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotCamPtz& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotCamPtz& from) {
    SpotCamPtz::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotCamPtz* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.SpotCamPtz";
  }
  protected:
  explicit SpotCamPtz(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SpotCamPtz_AdjustParameters AdjustParameters;

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kPtzPositionFieldNumber = 3,
    kAdjustParametersFieldNumber = 4,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // .bosdyn.api.spot_cam.PtzPosition ptz_position = 3;
  bool has_ptz_position() const;
  private:
  bool _internal_has_ptz_position() const;
  public:
  void clear_ptz_position();
  const ::bosdyn::api::spot_cam::PtzPosition& ptz_position() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot_cam::PtzPosition* release_ptz_position();
  ::bosdyn::api::spot_cam::PtzPosition* mutable_ptz_position();
  void set_allocated_ptz_position(::bosdyn::api::spot_cam::PtzPosition* ptz_position);
  private:
  const ::bosdyn::api::spot_cam::PtzPosition& _internal_ptz_position() const;
  ::bosdyn::api::spot_cam::PtzPosition* _internal_mutable_ptz_position();
  public:
  void unsafe_arena_set_allocated_ptz_position(
      ::bosdyn::api::spot_cam::PtzPosition* ptz_position);
  ::bosdyn::api::spot_cam::PtzPosition* unsafe_arena_release_ptz_position();

  // .bosdyn.api.mission.SpotCamPtz.AdjustParameters adjust_parameters = 4;
  bool has_adjust_parameters() const;
  private:
  bool _internal_has_adjust_parameters() const;
  public:
  void clear_adjust_parameters();
  const ::bosdyn::api::mission::SpotCamPtz_AdjustParameters& adjust_parameters() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::SpotCamPtz_AdjustParameters* release_adjust_parameters();
  ::bosdyn::api::mission::SpotCamPtz_AdjustParameters* mutable_adjust_parameters();
  void set_allocated_adjust_parameters(::bosdyn::api::mission::SpotCamPtz_AdjustParameters* adjust_parameters);
  private:
  const ::bosdyn::api::mission::SpotCamPtz_AdjustParameters& _internal_adjust_parameters() const;
  ::bosdyn::api::mission::SpotCamPtz_AdjustParameters* _internal_mutable_adjust_parameters();
  public:
  void unsafe_arena_set_allocated_adjust_parameters(
      ::bosdyn::api::mission::SpotCamPtz_AdjustParameters* adjust_parameters);
  ::bosdyn::api::mission::SpotCamPtz_AdjustParameters* unsafe_arena_release_adjust_parameters();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.SpotCamPtz)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::bosdyn::api::spot_cam::PtzPosition* ptz_position_;
    ::bosdyn::api::mission::SpotCamPtz_AdjustParameters* adjust_parameters_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class SpotCamStoreMedia final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.SpotCamStoreMedia) */ {
 public:
  inline SpotCamStoreMedia() : SpotCamStoreMedia(nullptr) {}
  ~SpotCamStoreMedia() override;
  explicit PROTOBUF_CONSTEXPR SpotCamStoreMedia(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotCamStoreMedia(const SpotCamStoreMedia& from);
  SpotCamStoreMedia(SpotCamStoreMedia&& from) noexcept
    : SpotCamStoreMedia() {
    *this = ::std::move(from);
  }

  inline SpotCamStoreMedia& operator=(const SpotCamStoreMedia& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotCamStoreMedia& operator=(SpotCamStoreMedia&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotCamStoreMedia& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotCamStoreMedia* internal_default_instance() {
    return reinterpret_cast<const SpotCamStoreMedia*>(
               &_SpotCamStoreMedia_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SpotCamStoreMedia& a, SpotCamStoreMedia& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotCamStoreMedia* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotCamStoreMedia* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotCamStoreMedia* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotCamStoreMedia>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotCamStoreMedia& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotCamStoreMedia& from) {
    SpotCamStoreMedia::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotCamStoreMedia* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.SpotCamStoreMedia";
  }
  protected:
  explicit SpotCamStoreMedia(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kTagFieldNumber = 5,
    kCameraFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string tag = 5;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // .bosdyn.api.spot_cam.Camera camera = 3;
  bool has_camera() const;
  private:
  bool _internal_has_camera() const;
  public:
  void clear_camera();
  const ::bosdyn::api::spot_cam::Camera& camera() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot_cam::Camera* release_camera();
  ::bosdyn::api::spot_cam::Camera* mutable_camera();
  void set_allocated_camera(::bosdyn::api::spot_cam::Camera* camera);
  private:
  const ::bosdyn::api::spot_cam::Camera& _internal_camera() const;
  ::bosdyn::api::spot_cam::Camera* _internal_mutable_camera();
  public:
  void unsafe_arena_set_allocated_camera(
      ::bosdyn::api::spot_cam::Camera* camera);
  ::bosdyn::api::spot_cam::Camera* unsafe_arena_release_camera();

  // .bosdyn.api.spot_cam.Logpoint.RecordType type = 4;
  void clear_type();
  ::bosdyn::api::spot_cam::Logpoint_RecordType type() const;
  void set_type(::bosdyn::api::spot_cam::Logpoint_RecordType value);
  private:
  ::bosdyn::api::spot_cam::Logpoint_RecordType _internal_type() const;
  void _internal_set_type(::bosdyn::api::spot_cam::Logpoint_RecordType value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.SpotCamStoreMedia)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    ::bosdyn::api::spot_cam::Camera* camera_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class SpotCamLed_BrightnessesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCamLed_BrightnessesEntry_DoNotUse, 
    int32_t, float,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCamLed_BrightnessesEntry_DoNotUse, 
    int32_t, float,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT> SuperType;
  SpotCamLed_BrightnessesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SpotCamLed_BrightnessesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SpotCamLed_BrightnessesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpotCamLed_BrightnessesEntry_DoNotUse& other);
  static const SpotCamLed_BrightnessesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpotCamLed_BrightnessesEntry_DoNotUse*>(&_SpotCamLed_BrightnessesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};

// -------------------------------------------------------------------

class SpotCamLed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.SpotCamLed) */ {
 public:
  inline SpotCamLed() : SpotCamLed(nullptr) {}
  ~SpotCamLed() override;
  explicit PROTOBUF_CONSTEXPR SpotCamLed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotCamLed(const SpotCamLed& from);
  SpotCamLed(SpotCamLed&& from) noexcept
    : SpotCamLed() {
    *this = ::std::move(from);
  }

  inline SpotCamLed& operator=(const SpotCamLed& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotCamLed& operator=(SpotCamLed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotCamLed& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotCamLed* internal_default_instance() {
    return reinterpret_cast<const SpotCamLed*>(
               &_SpotCamLed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(SpotCamLed& a, SpotCamLed& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotCamLed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotCamLed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotCamLed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotCamLed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotCamLed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotCamLed& from) {
    SpotCamLed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotCamLed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.SpotCamLed";
  }
  protected:
  explicit SpotCamLed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kBrightnessesFieldNumber = 3,
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
  };
  // map<int32, float> brightnesses = 3;
  int brightnesses_size() const;
  private:
  int _internal_brightnesses_size() const;
  public:
  void clear_brightnesses();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, float >&
      _internal_brightnesses() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, float >*
      _internal_mutable_brightnesses();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, float >&
      brightnesses() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, float >*
      mutable_brightnesses();

  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.SpotCamLed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SpotCamLed_BrightnessesEntry_DoNotUse,
        int32_t, float,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT> brightnesses_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class SpotCamResetAutofocus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.SpotCamResetAutofocus) */ {
 public:
  inline SpotCamResetAutofocus() : SpotCamResetAutofocus(nullptr) {}
  ~SpotCamResetAutofocus() override;
  explicit PROTOBUF_CONSTEXPR SpotCamResetAutofocus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotCamResetAutofocus(const SpotCamResetAutofocus& from);
  SpotCamResetAutofocus(SpotCamResetAutofocus&& from) noexcept
    : SpotCamResetAutofocus() {
    *this = ::std::move(from);
  }

  inline SpotCamResetAutofocus& operator=(const SpotCamResetAutofocus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotCamResetAutofocus& operator=(SpotCamResetAutofocus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotCamResetAutofocus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotCamResetAutofocus* internal_default_instance() {
    return reinterpret_cast<const SpotCamResetAutofocus*>(
               &_SpotCamResetAutofocus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(SpotCamResetAutofocus& a, SpotCamResetAutofocus& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotCamResetAutofocus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotCamResetAutofocus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotCamResetAutofocus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotCamResetAutofocus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotCamResetAutofocus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotCamResetAutofocus& from) {
    SpotCamResetAutofocus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotCamResetAutofocus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.SpotCamResetAutofocus";
  }
  protected:
  explicit SpotCamResetAutofocus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.SpotCamResetAutofocus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Dock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Dock) */ {
 public:
  inline Dock() : Dock(nullptr) {}
  ~Dock() override;
  explicit PROTOBUF_CONSTEXPR Dock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dock(const Dock& from);
  Dock(Dock&& from) noexcept
    : Dock() {
    *this = ::std::move(from);
  }

  inline Dock& operator=(const Dock& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dock& operator=(Dock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dock& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dock* internal_default_instance() {
    return reinterpret_cast<const Dock*>(
               &_Dock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Dock& a, Dock& b) {
    a.Swap(&b);
  }
  inline void Swap(Dock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Dock& from) {
    Dock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Dock";
  }
  protected:
  explicit Dock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kCommandStatusNameFieldNumber = 5,
    kFeedbackStatusNameFieldNumber = 6,
    kDockingCommandFeedbackResponseBlackboardKeyFieldNumber = 8,
    kDockingCommandResponseBlackboardKeyFieldNumber = 9,
    kChildFieldNumber = 4,
    kDockingStationIdFieldNumber = 3,
    kPrepPoseBehaviorFieldNumber = 7,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string command_status_name = 5 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_command_status_name();
  PROTOBUF_DEPRECATED const std::string& command_status_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_command_status_name(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_command_status_name();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_command_status_name();
  PROTOBUF_DEPRECATED void set_allocated_command_status_name(std::string* command_status_name);
  private:
  const std::string& _internal_command_status_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_command_status_name(const std::string& value);
  std::string* _internal_mutable_command_status_name();
  public:

  // string feedback_status_name = 6 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_feedback_status_name();
  PROTOBUF_DEPRECATED const std::string& feedback_status_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_feedback_status_name(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_feedback_status_name();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_feedback_status_name();
  PROTOBUF_DEPRECATED void set_allocated_feedback_status_name(std::string* feedback_status_name);
  private:
  const std::string& _internal_feedback_status_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feedback_status_name(const std::string& value);
  std::string* _internal_mutable_feedback_status_name();
  public:

  // string docking_command_feedback_response_blackboard_key = 8;
  void clear_docking_command_feedback_response_blackboard_key();
  const std::string& docking_command_feedback_response_blackboard_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_docking_command_feedback_response_blackboard_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_docking_command_feedback_response_blackboard_key();
  PROTOBUF_NODISCARD std::string* release_docking_command_feedback_response_blackboard_key();
  void set_allocated_docking_command_feedback_response_blackboard_key(std::string* docking_command_feedback_response_blackboard_key);
  private:
  const std::string& _internal_docking_command_feedback_response_blackboard_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_docking_command_feedback_response_blackboard_key(const std::string& value);
  std::string* _internal_mutable_docking_command_feedback_response_blackboard_key();
  public:

  // string docking_command_response_blackboard_key = 9;
  void clear_docking_command_response_blackboard_key();
  const std::string& docking_command_response_blackboard_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_docking_command_response_blackboard_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_docking_command_response_blackboard_key();
  PROTOBUF_NODISCARD std::string* release_docking_command_response_blackboard_key();
  void set_allocated_docking_command_response_blackboard_key(std::string* docking_command_response_blackboard_key);
  private:
  const std::string& _internal_docking_command_response_blackboard_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_docking_command_response_blackboard_key(const std::string& value);
  std::string* _internal_mutable_docking_command_response_blackboard_key();
  public:

  // .bosdyn.api.mission.Node child = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  PROTOBUF_DEPRECATED void clear_child();
  PROTOBUF_DEPRECATED const ::bosdyn::api::mission::Node& child() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::bosdyn::api::mission::Node* release_child();
  PROTOBUF_DEPRECATED ::bosdyn::api::mission::Node* mutable_child();
  PROTOBUF_DEPRECATED void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  PROTOBUF_DEPRECATED ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // uint32 docking_station_id = 3;
  void clear_docking_station_id();
  uint32_t docking_station_id() const;
  void set_docking_station_id(uint32_t value);
  private:
  uint32_t _internal_docking_station_id() const;
  void _internal_set_docking_station_id(uint32_t value);
  public:

  // .bosdyn.api.docking.PrepPoseBehavior prep_pose_behavior = 7;
  void clear_prep_pose_behavior();
  ::bosdyn::api::docking::PrepPoseBehavior prep_pose_behavior() const;
  void set_prep_pose_behavior(::bosdyn::api::docking::PrepPoseBehavior value);
  private:
  ::bosdyn::api::docking::PrepPoseBehavior _internal_prep_pose_behavior() const;
  void _internal_set_prep_pose_behavior(::bosdyn::api::docking::PrepPoseBehavior value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Dock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_status_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feedback_status_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr docking_command_feedback_response_blackboard_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr docking_command_response_blackboard_key_;
    ::bosdyn::api::mission::Node* child_;
    uint32_t docking_station_id_;
    int prep_pose_behavior_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class StoreMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.StoreMetadata) */ {
 public:
  inline StoreMetadata() : StoreMetadata(nullptr) {}
  ~StoreMetadata() override;
  explicit PROTOBUF_CONSTEXPR StoreMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreMetadata(const StoreMetadata& from);
  StoreMetadata(StoreMetadata&& from) noexcept
    : StoreMetadata() {
    *this = ::std::move(from);
  }

  inline StoreMetadata& operator=(const StoreMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreMetadata& operator=(StoreMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreMetadata* internal_default_instance() {
    return reinterpret_cast<const StoreMetadata*>(
               &_StoreMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(StoreMetadata& a, StoreMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StoreMetadata& from) {
    StoreMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.StoreMetadata";
  }
  protected:
  explicit StoreMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kAcquireDataRequestNameFieldNumber = 3,
    kMetadataNameFieldNumber = 5,
    kMetadataChannelFieldNumber = 6,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string acquire_data_request_name = 3;
  void clear_acquire_data_request_name();
  const std::string& acquire_data_request_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_acquire_data_request_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_acquire_data_request_name();
  PROTOBUF_NODISCARD std::string* release_acquire_data_request_name();
  void set_allocated_acquire_data_request_name(std::string* acquire_data_request_name);
  private:
  const std::string& _internal_acquire_data_request_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_acquire_data_request_name(const std::string& value);
  std::string* _internal_mutable_acquire_data_request_name();
  public:

  // string metadata_name = 5;
  void clear_metadata_name();
  const std::string& metadata_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata_name();
  PROTOBUF_NODISCARD std::string* release_metadata_name();
  void set_allocated_metadata_name(std::string* metadata_name);
  private:
  const std::string& _internal_metadata_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata_name(const std::string& value);
  std::string* _internal_mutable_metadata_name();
  public:

  // string metadata_channel = 6;
  void clear_metadata_channel();
  const std::string& metadata_channel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata_channel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata_channel();
  PROTOBUF_NODISCARD std::string* release_metadata_channel();
  void set_allocated_metadata_channel(std::string* metadata_channel);
  private:
  const std::string& _internal_metadata_channel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata_channel(const std::string& value);
  std::string* _internal_mutable_metadata_channel();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.StoreMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr acquire_data_request_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_channel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class DataAcquisition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.DataAcquisition) */ {
 public:
  inline DataAcquisition() : DataAcquisition(nullptr) {}
  ~DataAcquisition() override;
  explicit PROTOBUF_CONSTEXPR DataAcquisition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataAcquisition(const DataAcquisition& from);
  DataAcquisition(DataAcquisition&& from) noexcept
    : DataAcquisition() {
    *this = ::std::move(from);
  }

  inline DataAcquisition& operator=(const DataAcquisition& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataAcquisition& operator=(DataAcquisition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataAcquisition& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataAcquisition* internal_default_instance() {
    return reinterpret_cast<const DataAcquisition*>(
               &_DataAcquisition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(DataAcquisition& a, DataAcquisition& b) {
    a.Swap(&b);
  }
  inline void Swap(DataAcquisition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataAcquisition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataAcquisition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataAcquisition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataAcquisition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataAcquisition& from) {
    DataAcquisition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataAcquisition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.DataAcquisition";
  }
  protected:
  explicit DataAcquisition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataAcquisition_CompletionBehavior CompletionBehavior;
  static constexpr CompletionBehavior COMPLETE_UNKNOWN =
    DataAcquisition_CompletionBehavior_COMPLETE_UNKNOWN;
  static constexpr CompletionBehavior COMPLETE_AFTER_SAVED =
    DataAcquisition_CompletionBehavior_COMPLETE_AFTER_SAVED;
  static constexpr CompletionBehavior COMPLETE_AFTER_ACQUIRED =
    DataAcquisition_CompletionBehavior_COMPLETE_AFTER_ACQUIRED;
  static inline bool CompletionBehavior_IsValid(int value) {
    return DataAcquisition_CompletionBehavior_IsValid(value);
  }
  static constexpr CompletionBehavior CompletionBehavior_MIN =
    DataAcquisition_CompletionBehavior_CompletionBehavior_MIN;
  static constexpr CompletionBehavior CompletionBehavior_MAX =
    DataAcquisition_CompletionBehavior_CompletionBehavior_MAX;
  static constexpr int CompletionBehavior_ARRAYSIZE =
    DataAcquisition_CompletionBehavior_CompletionBehavior_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CompletionBehavior_descriptor() {
    return DataAcquisition_CompletionBehavior_descriptor();
  }
  template<typename T>
  static inline const std::string& CompletionBehavior_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CompletionBehavior>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CompletionBehavior_Name.");
    return DataAcquisition_CompletionBehavior_Name(enum_t_value);
  }
  static inline bool CompletionBehavior_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CompletionBehavior* value) {
    return DataAcquisition_CompletionBehavior_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kGroupNameFormatFieldNumber = 5,
    kRequestNameInBlackboardFieldNumber = 6,
    kRequestFieldNumber = 3,
    kCompletionBehaviorFieldNumber = 4,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string group_name_format = 5;
  void clear_group_name_format();
  const std::string& group_name_format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_name_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_name_format();
  PROTOBUF_NODISCARD std::string* release_group_name_format();
  void set_allocated_group_name_format(std::string* group_name_format);
  private:
  const std::string& _internal_group_name_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_name_format(const std::string& value);
  std::string* _internal_mutable_group_name_format();
  public:

  // string request_name_in_blackboard = 6;
  void clear_request_name_in_blackboard();
  const std::string& request_name_in_blackboard() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_name_in_blackboard(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_name_in_blackboard();
  PROTOBUF_NODISCARD std::string* release_request_name_in_blackboard();
  void set_allocated_request_name_in_blackboard(std::string* request_name_in_blackboard);
  private:
  const std::string& _internal_request_name_in_blackboard() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_name_in_blackboard(const std::string& value);
  std::string* _internal_mutable_request_name_in_blackboard();
  public:

  // .bosdyn.api.AcquireDataRequest request = 3;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::bosdyn::api::AcquireDataRequest& request() const;
  PROTOBUF_NODISCARD ::bosdyn::api::AcquireDataRequest* release_request();
  ::bosdyn::api::AcquireDataRequest* mutable_request();
  void set_allocated_request(::bosdyn::api::AcquireDataRequest* request);
  private:
  const ::bosdyn::api::AcquireDataRequest& _internal_request() const;
  ::bosdyn::api::AcquireDataRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::bosdyn::api::AcquireDataRequest* request);
  ::bosdyn::api::AcquireDataRequest* unsafe_arena_release_request();

  // .bosdyn.api.mission.DataAcquisition.CompletionBehavior completion_behavior = 4;
  void clear_completion_behavior();
  ::bosdyn::api::mission::DataAcquisition_CompletionBehavior completion_behavior() const;
  void set_completion_behavior(::bosdyn::api::mission::DataAcquisition_CompletionBehavior value);
  private:
  ::bosdyn::api::mission::DataAcquisition_CompletionBehavior _internal_completion_behavior() const;
  void _internal_set_completion_behavior(::bosdyn::api::mission::DataAcquisition_CompletionBehavior value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.DataAcquisition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_name_format_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_name_in_blackboard_;
    ::bosdyn::api::AcquireDataRequest* request_;
    int completion_behavior_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class RetainLease final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.RetainLease) */ {
 public:
  inline RetainLease() : RetainLease(nullptr) {}
  ~RetainLease() override;
  explicit PROTOBUF_CONSTEXPR RetainLease(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RetainLease(const RetainLease& from);
  RetainLease(RetainLease&& from) noexcept
    : RetainLease() {
    *this = ::std::move(from);
  }

  inline RetainLease& operator=(const RetainLease& from) {
    CopyFrom(from);
    return *this;
  }
  inline RetainLease& operator=(RetainLease&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RetainLease& default_instance() {
    return *internal_default_instance();
  }
  static inline const RetainLease* internal_default_instance() {
    return reinterpret_cast<const RetainLease*>(
               &_RetainLease_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(RetainLease& a, RetainLease& b) {
    a.Swap(&b);
  }
  inline void Swap(RetainLease* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RetainLease* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RetainLease* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RetainLease>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RetainLease& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RetainLease& from) {
    RetainLease::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RetainLease* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.RetainLease";
  }
  protected:
  explicit RetainLease(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.RetainLease)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class DefineBlackboard final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.DefineBlackboard) */ {
 public:
  inline DefineBlackboard() : DefineBlackboard(nullptr) {}
  ~DefineBlackboard() override;
  explicit PROTOBUF_CONSTEXPR DefineBlackboard(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefineBlackboard(const DefineBlackboard& from);
  DefineBlackboard(DefineBlackboard&& from) noexcept
    : DefineBlackboard() {
    *this = ::std::move(from);
  }

  inline DefineBlackboard& operator=(const DefineBlackboard& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefineBlackboard& operator=(DefineBlackboard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefineBlackboard& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefineBlackboard* internal_default_instance() {
    return reinterpret_cast<const DefineBlackboard*>(
               &_DefineBlackboard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(DefineBlackboard& a, DefineBlackboard& b) {
    a.Swap(&b);
  }
  inline void Swap(DefineBlackboard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefineBlackboard* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefineBlackboard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefineBlackboard>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DefineBlackboard& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DefineBlackboard& from) {
    DefineBlackboard::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefineBlackboard* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.DefineBlackboard";
  }
  protected:
  explicit DefineBlackboard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlackboardVariablesFieldNumber = 1,
    kChildFieldNumber = 2,
  };
  // repeated .bosdyn.api.mission.KeyValue blackboard_variables = 1;
  int blackboard_variables_size() const;
  private:
  int _internal_blackboard_variables_size() const;
  public:
  void clear_blackboard_variables();
  ::bosdyn::api::mission::KeyValue* mutable_blackboard_variables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
      mutable_blackboard_variables();
  private:
  const ::bosdyn::api::mission::KeyValue& _internal_blackboard_variables(int index) const;
  ::bosdyn::api::mission::KeyValue* _internal_add_blackboard_variables();
  public:
  const ::bosdyn::api::mission::KeyValue& blackboard_variables(int index) const;
  ::bosdyn::api::mission::KeyValue* add_blackboard_variables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
      blackboard_variables() const;

  // .bosdyn.api.mission.Node child = 2;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.DefineBlackboard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue > blackboard_variables_;
    ::bosdyn::api::mission::Node* child_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class SetBlackboard final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.SetBlackboard) */ {
 public:
  inline SetBlackboard() : SetBlackboard(nullptr) {}
  ~SetBlackboard() override;
  explicit PROTOBUF_CONSTEXPR SetBlackboard(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetBlackboard(const SetBlackboard& from);
  SetBlackboard(SetBlackboard&& from) noexcept
    : SetBlackboard() {
    *this = ::std::move(from);
  }

  inline SetBlackboard& operator=(const SetBlackboard& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetBlackboard& operator=(SetBlackboard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetBlackboard& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetBlackboard* internal_default_instance() {
    return reinterpret_cast<const SetBlackboard*>(
               &_SetBlackboard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SetBlackboard& a, SetBlackboard& b) {
    a.Swap(&b);
  }
  inline void Swap(SetBlackboard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetBlackboard* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetBlackboard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetBlackboard>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetBlackboard& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetBlackboard& from) {
    SetBlackboard::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetBlackboard* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.SetBlackboard";
  }
  protected:
  explicit SetBlackboard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlackboardVariablesFieldNumber = 1,
  };
  // repeated .bosdyn.api.mission.KeyValue blackboard_variables = 1;
  int blackboard_variables_size() const;
  private:
  int _internal_blackboard_variables_size() const;
  public:
  void clear_blackboard_variables();
  ::bosdyn::api::mission::KeyValue* mutable_blackboard_variables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
      mutable_blackboard_variables();
  private:
  const ::bosdyn::api::mission::KeyValue& _internal_blackboard_variables(int index) const;
  ::bosdyn::api::mission::KeyValue* _internal_add_blackboard_variables();
  public:
  const ::bosdyn::api::mission::KeyValue& blackboard_variables(int index) const;
  ::bosdyn::api::mission::KeyValue* add_blackboard_variables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
      blackboard_variables() const;

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.SetBlackboard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue > blackboard_variables_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class FormatBlackboard final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.FormatBlackboard) */ {
 public:
  inline FormatBlackboard() : FormatBlackboard(nullptr) {}
  ~FormatBlackboard() override;
  explicit PROTOBUF_CONSTEXPR FormatBlackboard(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FormatBlackboard(const FormatBlackboard& from);
  FormatBlackboard(FormatBlackboard&& from) noexcept
    : FormatBlackboard() {
    *this = ::std::move(from);
  }

  inline FormatBlackboard& operator=(const FormatBlackboard& from) {
    CopyFrom(from);
    return *this;
  }
  inline FormatBlackboard& operator=(FormatBlackboard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FormatBlackboard& default_instance() {
    return *internal_default_instance();
  }
  static inline const FormatBlackboard* internal_default_instance() {
    return reinterpret_cast<const FormatBlackboard*>(
               &_FormatBlackboard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(FormatBlackboard& a, FormatBlackboard& b) {
    a.Swap(&b);
  }
  inline void Swap(FormatBlackboard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FormatBlackboard* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FormatBlackboard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FormatBlackboard>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FormatBlackboard& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FormatBlackboard& from) {
    FormatBlackboard::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FormatBlackboard* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.FormatBlackboard";
  }
  protected:
  explicit FormatBlackboard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kFormatFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string format = 2;
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.FormatBlackboard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class DateToBlackboard final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.DateToBlackboard) */ {
 public:
  inline DateToBlackboard() : DateToBlackboard(nullptr) {}
  ~DateToBlackboard() override;
  explicit PROTOBUF_CONSTEXPR DateToBlackboard(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DateToBlackboard(const DateToBlackboard& from);
  DateToBlackboard(DateToBlackboard&& from) noexcept
    : DateToBlackboard() {
    *this = ::std::move(from);
  }

  inline DateToBlackboard& operator=(const DateToBlackboard& from) {
    CopyFrom(from);
    return *this;
  }
  inline DateToBlackboard& operator=(DateToBlackboard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DateToBlackboard& default_instance() {
    return *internal_default_instance();
  }
  static inline const DateToBlackboard* internal_default_instance() {
    return reinterpret_cast<const DateToBlackboard*>(
               &_DateToBlackboard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(DateToBlackboard& a, DateToBlackboard& b) {
    a.Swap(&b);
  }
  inline void Swap(DateToBlackboard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DateToBlackboard* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DateToBlackboard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DateToBlackboard>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DateToBlackboard& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DateToBlackboard& from) {
    DateToBlackboard::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DateToBlackboard* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.DateToBlackboard";
  }
  protected:
  explicit DateToBlackboard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.DateToBlackboard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class ConstantResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.ConstantResult) */ {
 public:
  inline ConstantResult() : ConstantResult(nullptr) {}
  ~ConstantResult() override;
  explicit PROTOBUF_CONSTEXPR ConstantResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConstantResult(const ConstantResult& from);
  ConstantResult(ConstantResult&& from) noexcept
    : ConstantResult() {
    *this = ::std::move(from);
  }

  inline ConstantResult& operator=(const ConstantResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstantResult& operator=(ConstantResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstantResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConstantResult* internal_default_instance() {
    return reinterpret_cast<const ConstantResult*>(
               &_ConstantResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ConstantResult& a, ConstantResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ConstantResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstantResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstantResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConstantResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConstantResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConstantResult& from) {
    ConstantResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConstantResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.ConstantResult";
  }
  protected:
  explicit ConstantResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .bosdyn.api.mission.Result result = 1;
  void clear_result();
  ::bosdyn::api::mission::Result result() const;
  void set_result(::bosdyn::api::mission::Result value);
  private:
  ::bosdyn::api::mission::Result _internal_result() const;
  void _internal_set_result(::bosdyn::api::mission::Result value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.ConstantResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class RestartWhenPaused final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.RestartWhenPaused) */ {
 public:
  inline RestartWhenPaused() : RestartWhenPaused(nullptr) {}
  ~RestartWhenPaused() override;
  explicit PROTOBUF_CONSTEXPR RestartWhenPaused(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RestartWhenPaused(const RestartWhenPaused& from);
  RestartWhenPaused(RestartWhenPaused&& from) noexcept
    : RestartWhenPaused() {
    *this = ::std::move(from);
  }

  inline RestartWhenPaused& operator=(const RestartWhenPaused& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestartWhenPaused& operator=(RestartWhenPaused&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestartWhenPaused& default_instance() {
    return *internal_default_instance();
  }
  static inline const RestartWhenPaused* internal_default_instance() {
    return reinterpret_cast<const RestartWhenPaused*>(
               &_RestartWhenPaused_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(RestartWhenPaused& a, RestartWhenPaused& b) {
    a.Swap(&b);
  }
  inline void Swap(RestartWhenPaused* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestartWhenPaused* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestartWhenPaused* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RestartWhenPaused>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RestartWhenPaused& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RestartWhenPaused& from) {
    RestartWhenPaused::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestartWhenPaused* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.RestartWhenPaused";
  }
  protected:
  explicit RestartWhenPaused(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 1,
  };
  // .bosdyn.api.mission.Node child = 1;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.RestartWhenPaused)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::mission::Node* child_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class ClearBehaviorFaults final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.ClearBehaviorFaults) */ {
 public:
  inline ClearBehaviorFaults() : ClearBehaviorFaults(nullptr) {}
  ~ClearBehaviorFaults() override;
  explicit PROTOBUF_CONSTEXPR ClearBehaviorFaults(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearBehaviorFaults(const ClearBehaviorFaults& from);
  ClearBehaviorFaults(ClearBehaviorFaults&& from) noexcept
    : ClearBehaviorFaults() {
    *this = ::std::move(from);
  }

  inline ClearBehaviorFaults& operator=(const ClearBehaviorFaults& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearBehaviorFaults& operator=(ClearBehaviorFaults&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearBehaviorFaults& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearBehaviorFaults* internal_default_instance() {
    return reinterpret_cast<const ClearBehaviorFaults*>(
               &_ClearBehaviorFaults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ClearBehaviorFaults& a, ClearBehaviorFaults& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearBehaviorFaults* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearBehaviorFaults* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearBehaviorFaults* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearBehaviorFaults>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearBehaviorFaults& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearBehaviorFaults& from) {
    ClearBehaviorFaults::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearBehaviorFaults* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.ClearBehaviorFaults";
  }
  protected:
  explicit ClearBehaviorFaults(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kRobotStateBlackboardNameFieldNumber = 3,
    kClearedCauseFallBlackboardNameFieldNumber = 4,
    kClearedCauseHardwareBlackboardNameFieldNumber = 5,
    kClearedCauseLeaseTimeoutBlackboardNameFieldNumber = 6,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string robot_state_blackboard_name = 3;
  void clear_robot_state_blackboard_name();
  const std::string& robot_state_blackboard_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_state_blackboard_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_state_blackboard_name();
  PROTOBUF_NODISCARD std::string* release_robot_state_blackboard_name();
  void set_allocated_robot_state_blackboard_name(std::string* robot_state_blackboard_name);
  private:
  const std::string& _internal_robot_state_blackboard_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_state_blackboard_name(const std::string& value);
  std::string* _internal_mutable_robot_state_blackboard_name();
  public:

  // string cleared_cause_fall_blackboard_name = 4;
  void clear_cleared_cause_fall_blackboard_name();
  const std::string& cleared_cause_fall_blackboard_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cleared_cause_fall_blackboard_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cleared_cause_fall_blackboard_name();
  PROTOBUF_NODISCARD std::string* release_cleared_cause_fall_blackboard_name();
  void set_allocated_cleared_cause_fall_blackboard_name(std::string* cleared_cause_fall_blackboard_name);
  private:
  const std::string& _internal_cleared_cause_fall_blackboard_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cleared_cause_fall_blackboard_name(const std::string& value);
  std::string* _internal_mutable_cleared_cause_fall_blackboard_name();
  public:

  // string cleared_cause_hardware_blackboard_name = 5;
  void clear_cleared_cause_hardware_blackboard_name();
  const std::string& cleared_cause_hardware_blackboard_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cleared_cause_hardware_blackboard_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cleared_cause_hardware_blackboard_name();
  PROTOBUF_NODISCARD std::string* release_cleared_cause_hardware_blackboard_name();
  void set_allocated_cleared_cause_hardware_blackboard_name(std::string* cleared_cause_hardware_blackboard_name);
  private:
  const std::string& _internal_cleared_cause_hardware_blackboard_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cleared_cause_hardware_blackboard_name(const std::string& value);
  std::string* _internal_mutable_cleared_cause_hardware_blackboard_name();
  public:

  // string cleared_cause_lease_timeout_blackboard_name = 6;
  void clear_cleared_cause_lease_timeout_blackboard_name();
  const std::string& cleared_cause_lease_timeout_blackboard_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cleared_cause_lease_timeout_blackboard_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cleared_cause_lease_timeout_blackboard_name();
  PROTOBUF_NODISCARD std::string* release_cleared_cause_lease_timeout_blackboard_name();
  void set_allocated_cleared_cause_lease_timeout_blackboard_name(std::string* cleared_cause_lease_timeout_blackboard_name);
  private:
  const std::string& _internal_cleared_cause_lease_timeout_blackboard_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cleared_cause_lease_timeout_blackboard_name(const std::string& value);
  std::string* _internal_mutable_cleared_cause_lease_timeout_blackboard_name();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.ClearBehaviorFaults)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_state_blackboard_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cleared_cause_fall_blackboard_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cleared_cause_hardware_blackboard_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cleared_cause_lease_timeout_blackboard_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Node

// string name = 1;
inline void Node::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Node::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Node.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Node.name)
}
inline std::string* Node::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Node.name)
  return _s;
}
inline const std::string& Node::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Node::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Node.name)
  return _impl_.name_.Release();
}
inline void Node::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Node.name)
}

// .bosdyn.api.mission.UserData user_data = 2;
inline bool Node::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool Node::has_user_data() const {
  return _internal_has_user_data();
}
inline const ::bosdyn::api::mission::UserData& Node::_internal_user_data() const {
  const ::bosdyn::api::mission::UserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::UserData&>(
      ::bosdyn::api::mission::_UserData_default_instance_);
}
inline const ::bosdyn::api::mission::UserData& Node::user_data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Node.user_data)
  return _internal_user_data();
}
inline void Node::unsafe_arena_set_allocated_user_data(
    ::bosdyn::api::mission::UserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Node.user_data)
}
inline ::bosdyn::api::mission::UserData* Node::release_user_data() {
  
  ::bosdyn::api::mission::UserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::UserData* Node::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Node.user_data)
  
  ::bosdyn::api::mission::UserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::UserData* Node::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::UserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::bosdyn::api::mission::UserData* Node::mutable_user_data() {
  ::bosdyn::api::mission::UserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Node.user_data)
  return _msg;
}
inline void Node::set_allocated_user_data(::bosdyn::api::mission::UserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_data));
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Node.user_data)
}

// string reference_id = 3;
inline void Node::clear_reference_id() {
  _impl_.reference_id_.ClearToEmpty();
}
inline const std::string& Node::reference_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Node.reference_id)
  return _internal_reference_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_reference_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reference_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Node.reference_id)
}
inline std::string* Node::mutable_reference_id() {
  std::string* _s = _internal_mutable_reference_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Node.reference_id)
  return _s;
}
inline const std::string& Node::_internal_reference_id() const {
  return _impl_.reference_id_.Get();
}
inline void Node::_internal_set_reference_id(const std::string& value) {
  
  _impl_.reference_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_reference_id() {
  
  return _impl_.reference_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_reference_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Node.reference_id)
  return _impl_.reference_id_.Release();
}
inline void Node::set_allocated_reference_id(std::string* reference_id) {
  if (reference_id != nullptr) {
    
  } else {
    
  }
  _impl_.reference_id_.SetAllocated(reference_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reference_id_.IsDefault()) {
    _impl_.reference_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Node.reference_id)
}

// .google.protobuf.Any impl = 4;
inline bool Node::_internal_has_impl() const {
  return type_case() == kImpl;
}
inline bool Node::has_impl() const {
  return _internal_has_impl();
}
inline void Node::set_has_impl() {
  _impl_._oneof_case_[0] = kImpl;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Node::release_impl() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Node.impl)
  if (_internal_has_impl()) {
    clear_has_type();
    ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.type_.impl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.impl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Node::_internal_impl() const {
  return _internal_has_impl()
      ? *_impl_.type_.impl_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Any&>(::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Node::impl() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Node.impl)
  return _internal_impl();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Node::unsafe_arena_release_impl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.mission.Node.impl)
  if (_internal_has_impl()) {
    clear_has_type();
    ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.type_.impl_;
    _impl_.type_.impl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Node::unsafe_arena_set_allocated_impl(::PROTOBUF_NAMESPACE_ID::Any* impl) {
  clear_type();
  if (impl) {
    set_has_impl();
    _impl_.type_.impl_ = impl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Node.impl)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Node::_internal_mutable_impl() {
  if (!_internal_has_impl()) {
    clear_type();
    set_has_impl();
    _impl_.type_.impl_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Any >(GetArenaForAllocation());
  }
  return _impl_.type_.impl_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Node::mutable_impl() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_impl();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Node.impl)
  return _msg;
}

// string node_reference = 5;
inline bool Node::_internal_has_node_reference() const {
  return type_case() == kNodeReference;
}
inline bool Node::has_node_reference() const {
  return _internal_has_node_reference();
}
inline void Node::set_has_node_reference() {
  _impl_._oneof_case_[0] = kNodeReference;
}
inline void Node::clear_node_reference() {
  if (_internal_has_node_reference()) {
    _impl_.type_.node_reference_.Destroy();
    clear_has_type();
  }
}
inline const std::string& Node::node_reference() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Node.node_reference)
  return _internal_node_reference();
}
template <typename ArgT0, typename... ArgT>
inline void Node::set_node_reference(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_node_reference()) {
    clear_type();
    set_has_node_reference();
    _impl_.type_.node_reference_.InitDefault();
  }
  _impl_.type_.node_reference_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Node.node_reference)
}
inline std::string* Node::mutable_node_reference() {
  std::string* _s = _internal_mutable_node_reference();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Node.node_reference)
  return _s;
}
inline const std::string& Node::_internal_node_reference() const {
  if (_internal_has_node_reference()) {
    return _impl_.type_.node_reference_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Node::_internal_set_node_reference(const std::string& value) {
  if (!_internal_has_node_reference()) {
    clear_type();
    set_has_node_reference();
    _impl_.type_.node_reference_.InitDefault();
  }
  _impl_.type_.node_reference_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_node_reference() {
  if (!_internal_has_node_reference()) {
    clear_type();
    set_has_node_reference();
    _impl_.type_.node_reference_.InitDefault();
  }
  return _impl_.type_.node_reference_.Mutable(      GetArenaForAllocation());
}
inline std::string* Node::release_node_reference() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Node.node_reference)
  if (_internal_has_node_reference()) {
    clear_has_type();
    return _impl_.type_.node_reference_.Release();
  } else {
    return nullptr;
  }
}
inline void Node::set_allocated_node_reference(std::string* node_reference) {
  if (has_type()) {
    clear_type();
  }
  if (node_reference != nullptr) {
    set_has_node_reference();
    _impl_.type_.node_reference_.InitAllocated(node_reference, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Node.node_reference)
}

// repeated .bosdyn.api.mission.KeyValue parameter_values = 6;
inline int Node::_internal_parameter_values_size() const {
  return _impl_.parameter_values_.size();
}
inline int Node::parameter_values_size() const {
  return _internal_parameter_values_size();
}
inline ::bosdyn::api::mission::KeyValue* Node::mutable_parameter_values(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Node.parameter_values)
  return _impl_.parameter_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
Node::mutable_parameter_values() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.Node.parameter_values)
  return &_impl_.parameter_values_;
}
inline const ::bosdyn::api::mission::KeyValue& Node::_internal_parameter_values(int index) const {
  return _impl_.parameter_values_.Get(index);
}
inline const ::bosdyn::api::mission::KeyValue& Node::parameter_values(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Node.parameter_values)
  return _internal_parameter_values(index);
}
inline ::bosdyn::api::mission::KeyValue* Node::_internal_add_parameter_values() {
  return _impl_.parameter_values_.Add();
}
inline ::bosdyn::api::mission::KeyValue* Node::add_parameter_values() {
  ::bosdyn::api::mission::KeyValue* _add = _internal_add_parameter_values();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.Node.parameter_values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
Node::parameter_values() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.Node.parameter_values)
  return _impl_.parameter_values_;
}

// repeated .bosdyn.api.mission.KeyValue overrides = 7;
inline int Node::_internal_overrides_size() const {
  return _impl_.overrides_.size();
}
inline int Node::overrides_size() const {
  return _internal_overrides_size();
}
inline ::bosdyn::api::mission::KeyValue* Node::mutable_overrides(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Node.overrides)
  return _impl_.overrides_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
Node::mutable_overrides() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.Node.overrides)
  return &_impl_.overrides_;
}
inline const ::bosdyn::api::mission::KeyValue& Node::_internal_overrides(int index) const {
  return _impl_.overrides_.Get(index);
}
inline const ::bosdyn::api::mission::KeyValue& Node::overrides(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Node.overrides)
  return _internal_overrides(index);
}
inline ::bosdyn::api::mission::KeyValue* Node::_internal_add_overrides() {
  return _impl_.overrides_.Add();
}
inline ::bosdyn::api::mission::KeyValue* Node::add_overrides() {
  ::bosdyn::api::mission::KeyValue* _add = _internal_add_overrides();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.Node.overrides)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
Node::overrides() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.Node.overrides)
  return _impl_.overrides_;
}

// repeated .bosdyn.api.mission.VariableDeclaration parameters = 8;
inline int Node::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int Node::parameters_size() const {
  return _internal_parameters_size();
}
inline ::bosdyn::api::mission::VariableDeclaration* Node::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Node.parameters)
  return _impl_.parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >*
Node::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.Node.parameters)
  return &_impl_.parameters_;
}
inline const ::bosdyn::api::mission::VariableDeclaration& Node::_internal_parameters(int index) const {
  return _impl_.parameters_.Get(index);
}
inline const ::bosdyn::api::mission::VariableDeclaration& Node::parameters(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Node.parameters)
  return _internal_parameters(index);
}
inline ::bosdyn::api::mission::VariableDeclaration* Node::_internal_add_parameters() {
  return _impl_.parameters_.Add();
}
inline ::bosdyn::api::mission::VariableDeclaration* Node::add_parameters() {
  ::bosdyn::api::mission::VariableDeclaration* _add = _internal_add_parameters();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.Node.parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >&
Node::parameters() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.Node.parameters)
  return _impl_.parameters_;
}

inline bool Node::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Node::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline Node::TypeCase Node::type_case() const {
  return Node::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Sequence

// bool always_restart = 1;
inline void Sequence::clear_always_restart() {
  _impl_.always_restart_ = false;
}
inline bool Sequence::_internal_always_restart() const {
  return _impl_.always_restart_;
}
inline bool Sequence::always_restart() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Sequence.always_restart)
  return _internal_always_restart();
}
inline void Sequence::_internal_set_always_restart(bool value) {
  
  _impl_.always_restart_ = value;
}
inline void Sequence::set_always_restart(bool value) {
  _internal_set_always_restart(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Sequence.always_restart)
}

// repeated .bosdyn.api.mission.Node children = 2;
inline int Sequence::_internal_children_size() const {
  return _impl_.children_.size();
}
inline int Sequence::children_size() const {
  return _internal_children_size();
}
inline void Sequence::clear_children() {
  _impl_.children_.Clear();
}
inline ::bosdyn::api::mission::Node* Sequence::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Sequence.children)
  return _impl_.children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node >*
Sequence::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.Sequence.children)
  return &_impl_.children_;
}
inline const ::bosdyn::api::mission::Node& Sequence::_internal_children(int index) const {
  return _impl_.children_.Get(index);
}
inline const ::bosdyn::api::mission::Node& Sequence::children(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Sequence.children)
  return _internal_children(index);
}
inline ::bosdyn::api::mission::Node* Sequence::_internal_add_children() {
  return _impl_.children_.Add();
}
inline ::bosdyn::api::mission::Node* Sequence::add_children() {
  ::bosdyn::api::mission::Node* _add = _internal_add_children();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.Sequence.children)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node >&
Sequence::children() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.Sequence.children)
  return _impl_.children_;
}

// -------------------------------------------------------------------

// Selector

// bool always_restart = 1;
inline void Selector::clear_always_restart() {
  _impl_.always_restart_ = false;
}
inline bool Selector::_internal_always_restart() const {
  return _impl_.always_restart_;
}
inline bool Selector::always_restart() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Selector.always_restart)
  return _internal_always_restart();
}
inline void Selector::_internal_set_always_restart(bool value) {
  
  _impl_.always_restart_ = value;
}
inline void Selector::set_always_restart(bool value) {
  _internal_set_always_restart(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Selector.always_restart)
}

// repeated .bosdyn.api.mission.Node children = 2;
inline int Selector::_internal_children_size() const {
  return _impl_.children_.size();
}
inline int Selector::children_size() const {
  return _internal_children_size();
}
inline void Selector::clear_children() {
  _impl_.children_.Clear();
}
inline ::bosdyn::api::mission::Node* Selector::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Selector.children)
  return _impl_.children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node >*
Selector::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.Selector.children)
  return &_impl_.children_;
}
inline const ::bosdyn::api::mission::Node& Selector::_internal_children(int index) const {
  return _impl_.children_.Get(index);
}
inline const ::bosdyn::api::mission::Node& Selector::children(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Selector.children)
  return _internal_children(index);
}
inline ::bosdyn::api::mission::Node* Selector::_internal_add_children() {
  return _impl_.children_.Add();
}
inline ::bosdyn::api::mission::Node* Selector::add_children() {
  ::bosdyn::api::mission::Node* _add = _internal_add_children();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.Selector.children)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node >&
Selector::children() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.Selector.children)
  return _impl_.children_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Switch

// .bosdyn.api.mission.Value pivot_value = 1;
inline bool Switch::_internal_has_pivot_value() const {
  return this != internal_default_instance() && _impl_.pivot_value_ != nullptr;
}
inline bool Switch::has_pivot_value() const {
  return _internal_has_pivot_value();
}
inline const ::bosdyn::api::mission::Value& Switch::_internal_pivot_value() const {
  const ::bosdyn::api::mission::Value* p = _impl_.pivot_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Value&>(
      ::bosdyn::api::mission::_Value_default_instance_);
}
inline const ::bosdyn::api::mission::Value& Switch::pivot_value() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Switch.pivot_value)
  return _internal_pivot_value();
}
inline void Switch::unsafe_arena_set_allocated_pivot_value(
    ::bosdyn::api::mission::Value* pivot_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pivot_value_);
  }
  _impl_.pivot_value_ = pivot_value;
  if (pivot_value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Switch.pivot_value)
}
inline ::bosdyn::api::mission::Value* Switch::release_pivot_value() {
  
  ::bosdyn::api::mission::Value* temp = _impl_.pivot_value_;
  _impl_.pivot_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Value* Switch::unsafe_arena_release_pivot_value() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Switch.pivot_value)
  
  ::bosdyn::api::mission::Value* temp = _impl_.pivot_value_;
  _impl_.pivot_value_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Value* Switch::_internal_mutable_pivot_value() {
  
  if (_impl_.pivot_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Value>(GetArenaForAllocation());
    _impl_.pivot_value_ = p;
  }
  return _impl_.pivot_value_;
}
inline ::bosdyn::api::mission::Value* Switch::mutable_pivot_value() {
  ::bosdyn::api::mission::Value* _msg = _internal_mutable_pivot_value();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Switch.pivot_value)
  return _msg;
}
inline void Switch::set_allocated_pivot_value(::bosdyn::api::mission::Value* pivot_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pivot_value_);
  }
  if (pivot_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pivot_value));
    if (message_arena != submessage_arena) {
      pivot_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pivot_value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pivot_value_ = pivot_value;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Switch.pivot_value)
}

// bool always_restart = 2;
inline void Switch::clear_always_restart() {
  _impl_.always_restart_ = false;
}
inline bool Switch::_internal_always_restart() const {
  return _impl_.always_restart_;
}
inline bool Switch::always_restart() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Switch.always_restart)
  return _internal_always_restart();
}
inline void Switch::_internal_set_always_restart(bool value) {
  
  _impl_.always_restart_ = value;
}
inline void Switch::set_always_restart(bool value) {
  _internal_set_always_restart(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Switch.always_restart)
}

// map<int32, .bosdyn.api.mission.Node> int_children = 3;
inline int Switch::_internal_int_children_size() const {
  return _impl_.int_children_.size();
}
inline int Switch::int_children_size() const {
  return _internal_int_children_size();
}
inline void Switch::clear_int_children() {
  _impl_.int_children_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::mission::Node >&
Switch::_internal_int_children() const {
  return _impl_.int_children_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::mission::Node >&
Switch::int_children() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.mission.Switch.int_children)
  return _internal_int_children();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::mission::Node >*
Switch::_internal_mutable_int_children() {
  return _impl_.int_children_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::mission::Node >*
Switch::mutable_int_children() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.mission.Switch.int_children)
  return _internal_mutable_int_children();
}

// .bosdyn.api.mission.Node default_child = 4;
inline bool Switch::_internal_has_default_child() const {
  return this != internal_default_instance() && _impl_.default_child_ != nullptr;
}
inline bool Switch::has_default_child() const {
  return _internal_has_default_child();
}
inline void Switch::clear_default_child() {
  if (GetArenaForAllocation() == nullptr && _impl_.default_child_ != nullptr) {
    delete _impl_.default_child_;
  }
  _impl_.default_child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& Switch::_internal_default_child() const {
  const ::bosdyn::api::mission::Node* p = _impl_.default_child_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Node&>(
      ::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& Switch::default_child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Switch.default_child)
  return _internal_default_child();
}
inline void Switch::unsafe_arena_set_allocated_default_child(
    ::bosdyn::api::mission::Node* default_child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default_child_);
  }
  _impl_.default_child_ = default_child;
  if (default_child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Switch.default_child)
}
inline ::bosdyn::api::mission::Node* Switch::release_default_child() {
  
  ::bosdyn::api::mission::Node* temp = _impl_.default_child_;
  _impl_.default_child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Node* Switch::unsafe_arena_release_default_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Switch.default_child)
  
  ::bosdyn::api::mission::Node* temp = _impl_.default_child_;
  _impl_.default_child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* Switch::_internal_mutable_default_child() {
  
  if (_impl_.default_child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArenaForAllocation());
    _impl_.default_child_ = p;
  }
  return _impl_.default_child_;
}
inline ::bosdyn::api::mission::Node* Switch::mutable_default_child() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_default_child();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Switch.default_child)
  return _msg;
}
inline void Switch::set_allocated_default_child(::bosdyn::api::mission::Node* default_child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.default_child_;
  }
  if (default_child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(default_child);
    if (message_arena != submessage_arena) {
      default_child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_child, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.default_child_ = default_child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Switch.default_child)
}

// -------------------------------------------------------------------

// Repeat

// int32 max_starts = 1;
inline void Repeat::clear_max_starts() {
  _impl_.max_starts_ = 0;
}
inline int32_t Repeat::_internal_max_starts() const {
  return _impl_.max_starts_;
}
inline int32_t Repeat::max_starts() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Repeat.max_starts)
  return _internal_max_starts();
}
inline void Repeat::_internal_set_max_starts(int32_t value) {
  
  _impl_.max_starts_ = value;
}
inline void Repeat::set_max_starts(int32_t value) {
  _internal_set_max_starts(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Repeat.max_starts)
}

// .bosdyn.api.mission.Node child = 4;
inline bool Repeat::_internal_has_child() const {
  return this != internal_default_instance() && _impl_.child_ != nullptr;
}
inline bool Repeat::has_child() const {
  return _internal_has_child();
}
inline void Repeat::clear_child() {
  if (GetArenaForAllocation() == nullptr && _impl_.child_ != nullptr) {
    delete _impl_.child_;
  }
  _impl_.child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& Repeat::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Node&>(
      ::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& Repeat::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Repeat.child)
  return _internal_child();
}
inline void Repeat::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Repeat.child)
}
inline ::bosdyn::api::mission::Node* Repeat::release_child() {
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Node* Repeat::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Repeat.child)
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* Repeat::_internal_mutable_child() {
  
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArenaForAllocation());
    _impl_.child_ = p;
  }
  return _impl_.child_;
}
inline ::bosdyn::api::mission::Node* Repeat::mutable_child() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Repeat.child)
  return _msg;
}
inline void Repeat::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Repeat.child)
}

// string start_counter_state_name = 5;
inline void Repeat::clear_start_counter_state_name() {
  _impl_.start_counter_state_name_.ClearToEmpty();
}
inline const std::string& Repeat::start_counter_state_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Repeat.start_counter_state_name)
  return _internal_start_counter_state_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Repeat::set_start_counter_state_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.start_counter_state_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Repeat.start_counter_state_name)
}
inline std::string* Repeat::mutable_start_counter_state_name() {
  std::string* _s = _internal_mutable_start_counter_state_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Repeat.start_counter_state_name)
  return _s;
}
inline const std::string& Repeat::_internal_start_counter_state_name() const {
  return _impl_.start_counter_state_name_.Get();
}
inline void Repeat::_internal_set_start_counter_state_name(const std::string& value) {
  
  _impl_.start_counter_state_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Repeat::_internal_mutable_start_counter_state_name() {
  
  return _impl_.start_counter_state_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Repeat::release_start_counter_state_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Repeat.start_counter_state_name)
  return _impl_.start_counter_state_name_.Release();
}
inline void Repeat::set_allocated_start_counter_state_name(std::string* start_counter_state_name) {
  if (start_counter_state_name != nullptr) {
    
  } else {
    
  }
  _impl_.start_counter_state_name_.SetAllocated(start_counter_state_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_counter_state_name_.IsDefault()) {
    _impl_.start_counter_state_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Repeat.start_counter_state_name)
}

// bool respect_child_failure = 6;
inline void Repeat::clear_respect_child_failure() {
  _impl_.respect_child_failure_ = false;
}
inline bool Repeat::_internal_respect_child_failure() const {
  return _impl_.respect_child_failure_;
}
inline bool Repeat::respect_child_failure() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Repeat.respect_child_failure)
  return _internal_respect_child_failure();
}
inline void Repeat::_internal_set_respect_child_failure(bool value) {
  
  _impl_.respect_child_failure_ = value;
}
inline void Repeat::set_respect_child_failure(bool value) {
  _internal_set_respect_child_failure(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Repeat.respect_child_failure)
}

// -------------------------------------------------------------------

// Retry

// int32 max_attempts = 1;
inline void Retry::clear_max_attempts() {
  _impl_.max_attempts_ = 0;
}
inline int32_t Retry::_internal_max_attempts() const {
  return _impl_.max_attempts_;
}
inline int32_t Retry::max_attempts() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Retry.max_attempts)
  return _internal_max_attempts();
}
inline void Retry::_internal_set_max_attempts(int32_t value) {
  
  _impl_.max_attempts_ = value;
}
inline void Retry::set_max_attempts(int32_t value) {
  _internal_set_max_attempts(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Retry.max_attempts)
}

// .bosdyn.api.mission.Node child = 2;
inline bool Retry::_internal_has_child() const {
  return this != internal_default_instance() && _impl_.child_ != nullptr;
}
inline bool Retry::has_child() const {
  return _internal_has_child();
}
inline void Retry::clear_child() {
  if (GetArenaForAllocation() == nullptr && _impl_.child_ != nullptr) {
    delete _impl_.child_;
  }
  _impl_.child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& Retry::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Node&>(
      ::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& Retry::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Retry.child)
  return _internal_child();
}
inline void Retry::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Retry.child)
}
inline ::bosdyn::api::mission::Node* Retry::release_child() {
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Node* Retry::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Retry.child)
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* Retry::_internal_mutable_child() {
  
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArenaForAllocation());
    _impl_.child_ = p;
  }
  return _impl_.child_;
}
inline ::bosdyn::api::mission::Node* Retry::mutable_child() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Retry.child)
  return _msg;
}
inline void Retry::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Retry.child)
}

// string attempt_counter_state_name = 5;
inline void Retry::clear_attempt_counter_state_name() {
  _impl_.attempt_counter_state_name_.ClearToEmpty();
}
inline const std::string& Retry::attempt_counter_state_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Retry.attempt_counter_state_name)
  return _internal_attempt_counter_state_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Retry::set_attempt_counter_state_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.attempt_counter_state_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Retry.attempt_counter_state_name)
}
inline std::string* Retry::mutable_attempt_counter_state_name() {
  std::string* _s = _internal_mutable_attempt_counter_state_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Retry.attempt_counter_state_name)
  return _s;
}
inline const std::string& Retry::_internal_attempt_counter_state_name() const {
  return _impl_.attempt_counter_state_name_.Get();
}
inline void Retry::_internal_set_attempt_counter_state_name(const std::string& value) {
  
  _impl_.attempt_counter_state_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Retry::_internal_mutable_attempt_counter_state_name() {
  
  return _impl_.attempt_counter_state_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Retry::release_attempt_counter_state_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Retry.attempt_counter_state_name)
  return _impl_.attempt_counter_state_name_.Release();
}
inline void Retry::set_allocated_attempt_counter_state_name(std::string* attempt_counter_state_name) {
  if (attempt_counter_state_name != nullptr) {
    
  } else {
    
  }
  _impl_.attempt_counter_state_name_.SetAllocated(attempt_counter_state_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attempt_counter_state_name_.IsDefault()) {
    _impl_.attempt_counter_state_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Retry.attempt_counter_state_name)
}

// -------------------------------------------------------------------

// ForDuration

// .google.protobuf.Duration duration = 1;
inline bool ForDuration::_internal_has_duration() const {
  return this != internal_default_instance() && _impl_.duration_ != nullptr;
}
inline bool ForDuration::has_duration() const {
  return _internal_has_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ForDuration::_internal_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ForDuration::duration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.ForDuration.duration)
  return _internal_duration();
}
inline void ForDuration::unsafe_arena_set_allocated_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_);
  }
  _impl_.duration_ = duration;
  if (duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.ForDuration.duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ForDuration::release_duration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ForDuration::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.ForDuration.duration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ForDuration::_internal_mutable_duration() {
  
  if (_impl_.duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.duration_ = p;
  }
  return _impl_.duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ForDuration::mutable_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.ForDuration.duration)
  return _msg;
}
inline void ForDuration::set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_);
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration));
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.ForDuration.duration)
}

// .bosdyn.api.mission.Node child = 2;
inline bool ForDuration::_internal_has_child() const {
  return this != internal_default_instance() && _impl_.child_ != nullptr;
}
inline bool ForDuration::has_child() const {
  return _internal_has_child();
}
inline void ForDuration::clear_child() {
  if (GetArenaForAllocation() == nullptr && _impl_.child_ != nullptr) {
    delete _impl_.child_;
  }
  _impl_.child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& ForDuration::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Node&>(
      ::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& ForDuration::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.ForDuration.child)
  return _internal_child();
}
inline void ForDuration::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.ForDuration.child)
}
inline ::bosdyn::api::mission::Node* ForDuration::release_child() {
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Node* ForDuration::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.ForDuration.child)
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* ForDuration::_internal_mutable_child() {
  
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArenaForAllocation());
    _impl_.child_ = p;
  }
  return _impl_.child_;
}
inline ::bosdyn::api::mission::Node* ForDuration::mutable_child() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.ForDuration.child)
  return _msg;
}
inline void ForDuration::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.ForDuration.child)
}

// string time_remaining_name = 3;
inline void ForDuration::clear_time_remaining_name() {
  _impl_.time_remaining_name_.ClearToEmpty();
}
inline const std::string& ForDuration::time_remaining_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.ForDuration.time_remaining_name)
  return _internal_time_remaining_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ForDuration::set_time_remaining_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_remaining_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.ForDuration.time_remaining_name)
}
inline std::string* ForDuration::mutable_time_remaining_name() {
  std::string* _s = _internal_mutable_time_remaining_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.ForDuration.time_remaining_name)
  return _s;
}
inline const std::string& ForDuration::_internal_time_remaining_name() const {
  return _impl_.time_remaining_name_.Get();
}
inline void ForDuration::_internal_set_time_remaining_name(const std::string& value) {
  
  _impl_.time_remaining_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ForDuration::_internal_mutable_time_remaining_name() {
  
  return _impl_.time_remaining_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ForDuration::release_time_remaining_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.ForDuration.time_remaining_name)
  return _impl_.time_remaining_name_.Release();
}
inline void ForDuration::set_allocated_time_remaining_name(std::string* time_remaining_name) {
  if (time_remaining_name != nullptr) {
    
  } else {
    
  }
  _impl_.time_remaining_name_.SetAllocated(time_remaining_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_remaining_name_.IsDefault()) {
    _impl_.time_remaining_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.ForDuration.time_remaining_name)
}

// .bosdyn.api.mission.Node timeout_child = 4;
inline bool ForDuration::_internal_has_timeout_child() const {
  return this != internal_default_instance() && _impl_.timeout_child_ != nullptr;
}
inline bool ForDuration::has_timeout_child() const {
  return _internal_has_timeout_child();
}
inline void ForDuration::clear_timeout_child() {
  if (GetArenaForAllocation() == nullptr && _impl_.timeout_child_ != nullptr) {
    delete _impl_.timeout_child_;
  }
  _impl_.timeout_child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& ForDuration::_internal_timeout_child() const {
  const ::bosdyn::api::mission::Node* p = _impl_.timeout_child_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Node&>(
      ::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& ForDuration::timeout_child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.ForDuration.timeout_child)
  return _internal_timeout_child();
}
inline void ForDuration::unsafe_arena_set_allocated_timeout_child(
    ::bosdyn::api::mission::Node* timeout_child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timeout_child_);
  }
  _impl_.timeout_child_ = timeout_child;
  if (timeout_child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.ForDuration.timeout_child)
}
inline ::bosdyn::api::mission::Node* ForDuration::release_timeout_child() {
  
  ::bosdyn::api::mission::Node* temp = _impl_.timeout_child_;
  _impl_.timeout_child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Node* ForDuration::unsafe_arena_release_timeout_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.ForDuration.timeout_child)
  
  ::bosdyn::api::mission::Node* temp = _impl_.timeout_child_;
  _impl_.timeout_child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* ForDuration::_internal_mutable_timeout_child() {
  
  if (_impl_.timeout_child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArenaForAllocation());
    _impl_.timeout_child_ = p;
  }
  return _impl_.timeout_child_;
}
inline ::bosdyn::api::mission::Node* ForDuration::mutable_timeout_child() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_timeout_child();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.ForDuration.timeout_child)
  return _msg;
}
inline void ForDuration::set_allocated_timeout_child(::bosdyn::api::mission::Node* timeout_child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.timeout_child_;
  }
  if (timeout_child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timeout_child);
    if (message_arena != submessage_arena) {
      timeout_child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timeout_child, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timeout_child_ = timeout_child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.ForDuration.timeout_child)
}

// -------------------------------------------------------------------

// SimpleParallel

// .bosdyn.api.mission.Node primary = 1;
inline bool SimpleParallel::_internal_has_primary() const {
  return this != internal_default_instance() && _impl_.primary_ != nullptr;
}
inline bool SimpleParallel::has_primary() const {
  return _internal_has_primary();
}
inline void SimpleParallel::clear_primary() {
  if (GetArenaForAllocation() == nullptr && _impl_.primary_ != nullptr) {
    delete _impl_.primary_;
  }
  _impl_.primary_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& SimpleParallel::_internal_primary() const {
  const ::bosdyn::api::mission::Node* p = _impl_.primary_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Node&>(
      ::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& SimpleParallel::primary() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SimpleParallel.primary)
  return _internal_primary();
}
inline void SimpleParallel::unsafe_arena_set_allocated_primary(
    ::bosdyn::api::mission::Node* primary) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.primary_);
  }
  _impl_.primary_ = primary;
  if (primary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.SimpleParallel.primary)
}
inline ::bosdyn::api::mission::Node* SimpleParallel::release_primary() {
  
  ::bosdyn::api::mission::Node* temp = _impl_.primary_;
  _impl_.primary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Node* SimpleParallel::unsafe_arena_release_primary() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SimpleParallel.primary)
  
  ::bosdyn::api::mission::Node* temp = _impl_.primary_;
  _impl_.primary_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* SimpleParallel::_internal_mutable_primary() {
  
  if (_impl_.primary_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArenaForAllocation());
    _impl_.primary_ = p;
  }
  return _impl_.primary_;
}
inline ::bosdyn::api::mission::Node* SimpleParallel::mutable_primary() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_primary();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SimpleParallel.primary)
  return _msg;
}
inline void SimpleParallel::set_allocated_primary(::bosdyn::api::mission::Node* primary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.primary_;
  }
  if (primary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(primary);
    if (message_arena != submessage_arena) {
      primary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, primary, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.primary_ = primary;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SimpleParallel.primary)
}

// .bosdyn.api.mission.Node secondary = 2;
inline bool SimpleParallel::_internal_has_secondary() const {
  return this != internal_default_instance() && _impl_.secondary_ != nullptr;
}
inline bool SimpleParallel::has_secondary() const {
  return _internal_has_secondary();
}
inline void SimpleParallel::clear_secondary() {
  if (GetArenaForAllocation() == nullptr && _impl_.secondary_ != nullptr) {
    delete _impl_.secondary_;
  }
  _impl_.secondary_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& SimpleParallel::_internal_secondary() const {
  const ::bosdyn::api::mission::Node* p = _impl_.secondary_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Node&>(
      ::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& SimpleParallel::secondary() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SimpleParallel.secondary)
  return _internal_secondary();
}
inline void SimpleParallel::unsafe_arena_set_allocated_secondary(
    ::bosdyn::api::mission::Node* secondary) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.secondary_);
  }
  _impl_.secondary_ = secondary;
  if (secondary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.SimpleParallel.secondary)
}
inline ::bosdyn::api::mission::Node* SimpleParallel::release_secondary() {
  
  ::bosdyn::api::mission::Node* temp = _impl_.secondary_;
  _impl_.secondary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Node* SimpleParallel::unsafe_arena_release_secondary() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SimpleParallel.secondary)
  
  ::bosdyn::api::mission::Node* temp = _impl_.secondary_;
  _impl_.secondary_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* SimpleParallel::_internal_mutable_secondary() {
  
  if (_impl_.secondary_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArenaForAllocation());
    _impl_.secondary_ = p;
  }
  return _impl_.secondary_;
}
inline ::bosdyn::api::mission::Node* SimpleParallel::mutable_secondary() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_secondary();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SimpleParallel.secondary)
  return _msg;
}
inline void SimpleParallel::set_allocated_secondary(::bosdyn::api::mission::Node* secondary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.secondary_;
  }
  if (secondary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(secondary);
    if (message_arena != submessage_arena) {
      secondary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, secondary, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.secondary_ = secondary;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SimpleParallel.secondary)
}

// -------------------------------------------------------------------

// Condition_Operand

// .bosdyn.api.mission.VariableDeclaration var = 1;
inline bool Condition_Operand::_internal_has_var() const {
  return type_case() == kVar;
}
inline bool Condition_Operand::has_var() const {
  return _internal_has_var();
}
inline void Condition_Operand::set_has_var() {
  _impl_._oneof_case_[0] = kVar;
}
inline ::bosdyn::api::mission::VariableDeclaration* Condition_Operand::release_var() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Condition.Operand.var)
  if (_internal_has_var()) {
    clear_has_type();
    ::bosdyn::api::mission::VariableDeclaration* temp = _impl_.type_.var_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.var_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::mission::VariableDeclaration& Condition_Operand::_internal_var() const {
  return _internal_has_var()
      ? *_impl_.type_.var_
      : reinterpret_cast< ::bosdyn::api::mission::VariableDeclaration&>(::bosdyn::api::mission::_VariableDeclaration_default_instance_);
}
inline const ::bosdyn::api::mission::VariableDeclaration& Condition_Operand::var() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Condition.Operand.var)
  return _internal_var();
}
inline ::bosdyn::api::mission::VariableDeclaration* Condition_Operand::unsafe_arena_release_var() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.mission.Condition.Operand.var)
  if (_internal_has_var()) {
    clear_has_type();
    ::bosdyn::api::mission::VariableDeclaration* temp = _impl_.type_.var_;
    _impl_.type_.var_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition_Operand::unsafe_arena_set_allocated_var(::bosdyn::api::mission::VariableDeclaration* var) {
  clear_type();
  if (var) {
    set_has_var();
    _impl_.type_.var_ = var;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Condition.Operand.var)
}
inline ::bosdyn::api::mission::VariableDeclaration* Condition_Operand::_internal_mutable_var() {
  if (!_internal_has_var()) {
    clear_type();
    set_has_var();
    _impl_.type_.var_ = CreateMaybeMessage< ::bosdyn::api::mission::VariableDeclaration >(GetArenaForAllocation());
  }
  return _impl_.type_.var_;
}
inline ::bosdyn::api::mission::VariableDeclaration* Condition_Operand::mutable_var() {
  ::bosdyn::api::mission::VariableDeclaration* _msg = _internal_mutable_var();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Condition.Operand.var)
  return _msg;
}

// .bosdyn.api.mission.ConstantValue const = 2;
inline bool Condition_Operand::_internal_has_const_() const {
  return type_case() == kConst;
}
inline bool Condition_Operand::has_const_() const {
  return _internal_has_const_();
}
inline void Condition_Operand::set_has_const_() {
  _impl_._oneof_case_[0] = kConst;
}
inline ::bosdyn::api::mission::ConstantValue* Condition_Operand::release_const_() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Condition.Operand.const)
  if (_internal_has_const_()) {
    clear_has_type();
    ::bosdyn::api::mission::ConstantValue* temp = _impl_.type_.const__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.const__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::mission::ConstantValue& Condition_Operand::_internal_const_() const {
  return _internal_has_const_()
      ? *_impl_.type_.const__
      : reinterpret_cast< ::bosdyn::api::mission::ConstantValue&>(::bosdyn::api::mission::_ConstantValue_default_instance_);
}
inline const ::bosdyn::api::mission::ConstantValue& Condition_Operand::const_() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Condition.Operand.const)
  return _internal_const_();
}
inline ::bosdyn::api::mission::ConstantValue* Condition_Operand::unsafe_arena_release_const_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.mission.Condition.Operand.const)
  if (_internal_has_const_()) {
    clear_has_type();
    ::bosdyn::api::mission::ConstantValue* temp = _impl_.type_.const__;
    _impl_.type_.const__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition_Operand::unsafe_arena_set_allocated_const_(::bosdyn::api::mission::ConstantValue* const_) {
  clear_type();
  if (const_) {
    set_has_const_();
    _impl_.type_.const__ = const_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Condition.Operand.const)
}
inline ::bosdyn::api::mission::ConstantValue* Condition_Operand::_internal_mutable_const_() {
  if (!_internal_has_const_()) {
    clear_type();
    set_has_const_();
    _impl_.type_.const__ = CreateMaybeMessage< ::bosdyn::api::mission::ConstantValue >(GetArenaForAllocation());
  }
  return _impl_.type_.const__;
}
inline ::bosdyn::api::mission::ConstantValue* Condition_Operand::mutable_const_() {
  ::bosdyn::api::mission::ConstantValue* _msg = _internal_mutable_const_();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Condition.Operand.const)
  return _msg;
}

inline bool Condition_Operand::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Condition_Operand::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline Condition_Operand::TypeCase Condition_Operand::type_case() const {
  return Condition_Operand::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Condition

// .bosdyn.api.mission.Condition.Operand lhs = 1;
inline bool Condition::_internal_has_lhs() const {
  return this != internal_default_instance() && _impl_.lhs_ != nullptr;
}
inline bool Condition::has_lhs() const {
  return _internal_has_lhs();
}
inline void Condition::clear_lhs() {
  if (GetArenaForAllocation() == nullptr && _impl_.lhs_ != nullptr) {
    delete _impl_.lhs_;
  }
  _impl_.lhs_ = nullptr;
}
inline const ::bosdyn::api::mission::Condition_Operand& Condition::_internal_lhs() const {
  const ::bosdyn::api::mission::Condition_Operand* p = _impl_.lhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Condition_Operand&>(
      ::bosdyn::api::mission::_Condition_Operand_default_instance_);
}
inline const ::bosdyn::api::mission::Condition_Operand& Condition::lhs() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Condition.lhs)
  return _internal_lhs();
}
inline void Condition::unsafe_arena_set_allocated_lhs(
    ::bosdyn::api::mission::Condition_Operand* lhs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lhs_);
  }
  _impl_.lhs_ = lhs;
  if (lhs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Condition.lhs)
}
inline ::bosdyn::api::mission::Condition_Operand* Condition::release_lhs() {
  
  ::bosdyn::api::mission::Condition_Operand* temp = _impl_.lhs_;
  _impl_.lhs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Condition_Operand* Condition::unsafe_arena_release_lhs() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Condition.lhs)
  
  ::bosdyn::api::mission::Condition_Operand* temp = _impl_.lhs_;
  _impl_.lhs_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Condition_Operand* Condition::_internal_mutable_lhs() {
  
  if (_impl_.lhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Condition_Operand>(GetArenaForAllocation());
    _impl_.lhs_ = p;
  }
  return _impl_.lhs_;
}
inline ::bosdyn::api::mission::Condition_Operand* Condition::mutable_lhs() {
  ::bosdyn::api::mission::Condition_Operand* _msg = _internal_mutable_lhs();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Condition.lhs)
  return _msg;
}
inline void Condition::set_allocated_lhs(::bosdyn::api::mission::Condition_Operand* lhs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lhs_;
  }
  if (lhs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lhs);
    if (message_arena != submessage_arena) {
      lhs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lhs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lhs_ = lhs;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Condition.lhs)
}

// .bosdyn.api.mission.Condition.Operand rhs = 2;
inline bool Condition::_internal_has_rhs() const {
  return this != internal_default_instance() && _impl_.rhs_ != nullptr;
}
inline bool Condition::has_rhs() const {
  return _internal_has_rhs();
}
inline void Condition::clear_rhs() {
  if (GetArenaForAllocation() == nullptr && _impl_.rhs_ != nullptr) {
    delete _impl_.rhs_;
  }
  _impl_.rhs_ = nullptr;
}
inline const ::bosdyn::api::mission::Condition_Operand& Condition::_internal_rhs() const {
  const ::bosdyn::api::mission::Condition_Operand* p = _impl_.rhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Condition_Operand&>(
      ::bosdyn::api::mission::_Condition_Operand_default_instance_);
}
inline const ::bosdyn::api::mission::Condition_Operand& Condition::rhs() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Condition.rhs)
  return _internal_rhs();
}
inline void Condition::unsafe_arena_set_allocated_rhs(
    ::bosdyn::api::mission::Condition_Operand* rhs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rhs_);
  }
  _impl_.rhs_ = rhs;
  if (rhs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Condition.rhs)
}
inline ::bosdyn::api::mission::Condition_Operand* Condition::release_rhs() {
  
  ::bosdyn::api::mission::Condition_Operand* temp = _impl_.rhs_;
  _impl_.rhs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Condition_Operand* Condition::unsafe_arena_release_rhs() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Condition.rhs)
  
  ::bosdyn::api::mission::Condition_Operand* temp = _impl_.rhs_;
  _impl_.rhs_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Condition_Operand* Condition::_internal_mutable_rhs() {
  
  if (_impl_.rhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Condition_Operand>(GetArenaForAllocation());
    _impl_.rhs_ = p;
  }
  return _impl_.rhs_;
}
inline ::bosdyn::api::mission::Condition_Operand* Condition::mutable_rhs() {
  ::bosdyn::api::mission::Condition_Operand* _msg = _internal_mutable_rhs();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Condition.rhs)
  return _msg;
}
inline void Condition::set_allocated_rhs(::bosdyn::api::mission::Condition_Operand* rhs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rhs_;
  }
  if (rhs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rhs);
    if (message_arena != submessage_arena) {
      rhs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rhs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rhs_ = rhs;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Condition.rhs)
}

// .bosdyn.api.mission.Condition.Compare operation = 5;
inline void Condition::clear_operation() {
  _impl_.operation_ = 0;
}
inline ::bosdyn::api::mission::Condition_Compare Condition::_internal_operation() const {
  return static_cast< ::bosdyn::api::mission::Condition_Compare >(_impl_.operation_);
}
inline ::bosdyn::api::mission::Condition_Compare Condition::operation() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Condition.operation)
  return _internal_operation();
}
inline void Condition::_internal_set_operation(::bosdyn::api::mission::Condition_Compare value) {
  
  _impl_.operation_ = value;
}
inline void Condition::set_operation(::bosdyn::api::mission::Condition_Compare value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Condition.operation)
}

// .bosdyn.api.mission.Condition.HandleStaleness handle_staleness = 6;
inline void Condition::clear_handle_staleness() {
  _impl_.handle_staleness_ = 0;
}
inline ::bosdyn::api::mission::Condition_HandleStaleness Condition::_internal_handle_staleness() const {
  return static_cast< ::bosdyn::api::mission::Condition_HandleStaleness >(_impl_.handle_staleness_);
}
inline ::bosdyn::api::mission::Condition_HandleStaleness Condition::handle_staleness() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Condition.handle_staleness)
  return _internal_handle_staleness();
}
inline void Condition::_internal_set_handle_staleness(::bosdyn::api::mission::Condition_HandleStaleness value) {
  
  _impl_.handle_staleness_ = value;
}
inline void Condition::set_handle_staleness(::bosdyn::api::mission::Condition_HandleStaleness value) {
  _internal_set_handle_staleness(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Condition.handle_staleness)
}

// -------------------------------------------------------------------

// BosdynRobotState

// string service_name = 1;
inline void BosdynRobotState::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& BosdynRobotState::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRobotState.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynRobotState::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynRobotState.service_name)
}
inline std::string* BosdynRobotState::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRobotState.service_name)
  return _s;
}
inline const std::string& BosdynRobotState::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void BosdynRobotState::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynRobotState::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynRobotState::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRobotState.service_name)
  return _impl_.service_name_.Release();
}
inline void BosdynRobotState::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRobotState.service_name)
}

// string host = 2;
inline void BosdynRobotState::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& BosdynRobotState::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRobotState.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynRobotState::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynRobotState.host)
}
inline std::string* BosdynRobotState::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRobotState.host)
  return _s;
}
inline const std::string& BosdynRobotState::_internal_host() const {
  return _impl_.host_.Get();
}
inline void BosdynRobotState::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynRobotState::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynRobotState::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRobotState.host)
  return _impl_.host_.Release();
}
inline void BosdynRobotState::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRobotState.host)
}

// .bosdyn.api.mission.Node child = 3;
inline bool BosdynRobotState::_internal_has_child() const {
  return this != internal_default_instance() && _impl_.child_ != nullptr;
}
inline bool BosdynRobotState::has_child() const {
  return _internal_has_child();
}
inline void BosdynRobotState::clear_child() {
  if (GetArenaForAllocation() == nullptr && _impl_.child_ != nullptr) {
    delete _impl_.child_;
  }
  _impl_.child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& BosdynRobotState::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Node&>(
      ::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& BosdynRobotState::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRobotState.child)
  return _internal_child();
}
inline void BosdynRobotState::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynRobotState.child)
}
inline ::bosdyn::api::mission::Node* BosdynRobotState::release_child() {
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Node* BosdynRobotState::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRobotState.child)
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* BosdynRobotState::_internal_mutable_child() {
  
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArenaForAllocation());
    _impl_.child_ = p;
  }
  return _impl_.child_;
}
inline ::bosdyn::api::mission::Node* BosdynRobotState::mutable_child() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRobotState.child)
  return _msg;
}
inline void BosdynRobotState::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRobotState.child)
}

// string state_name = 4;
inline void BosdynRobotState::clear_state_name() {
  _impl_.state_name_.ClearToEmpty();
}
inline const std::string& BosdynRobotState::state_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRobotState.state_name)
  return _internal_state_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynRobotState::set_state_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynRobotState.state_name)
}
inline std::string* BosdynRobotState::mutable_state_name() {
  std::string* _s = _internal_mutable_state_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRobotState.state_name)
  return _s;
}
inline const std::string& BosdynRobotState::_internal_state_name() const {
  return _impl_.state_name_.Get();
}
inline void BosdynRobotState::_internal_set_state_name(const std::string& value) {
  
  _impl_.state_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynRobotState::_internal_mutable_state_name() {
  
  return _impl_.state_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynRobotState::release_state_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRobotState.state_name)
  return _impl_.state_name_.Release();
}
inline void BosdynRobotState::set_allocated_state_name(std::string* state_name) {
  if (state_name != nullptr) {
    
  } else {
    
  }
  _impl_.state_name_.SetAllocated(state_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_name_.IsDefault()) {
    _impl_.state_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRobotState.state_name)
}

// -------------------------------------------------------------------

// BosdynDockState

// string service_name = 1;
inline void BosdynDockState::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& BosdynDockState::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynDockState.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynDockState::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynDockState.service_name)
}
inline std::string* BosdynDockState::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynDockState.service_name)
  return _s;
}
inline const std::string& BosdynDockState::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void BosdynDockState::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynDockState::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynDockState::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynDockState.service_name)
  return _impl_.service_name_.Release();
}
inline void BosdynDockState::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynDockState.service_name)
}

// string host = 2;
inline void BosdynDockState::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& BosdynDockState::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynDockState.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynDockState::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynDockState.host)
}
inline std::string* BosdynDockState::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynDockState.host)
  return _s;
}
inline const std::string& BosdynDockState::_internal_host() const {
  return _impl_.host_.Get();
}
inline void BosdynDockState::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynDockState::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynDockState::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynDockState.host)
  return _impl_.host_.Release();
}
inline void BosdynDockState::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynDockState.host)
}

// .bosdyn.api.mission.Node child = 3;
inline bool BosdynDockState::_internal_has_child() const {
  return this != internal_default_instance() && _impl_.child_ != nullptr;
}
inline bool BosdynDockState::has_child() const {
  return _internal_has_child();
}
inline void BosdynDockState::clear_child() {
  if (GetArenaForAllocation() == nullptr && _impl_.child_ != nullptr) {
    delete _impl_.child_;
  }
  _impl_.child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& BosdynDockState::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Node&>(
      ::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& BosdynDockState::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynDockState.child)
  return _internal_child();
}
inline void BosdynDockState::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynDockState.child)
}
inline ::bosdyn::api::mission::Node* BosdynDockState::release_child() {
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Node* BosdynDockState::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynDockState.child)
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* BosdynDockState::_internal_mutable_child() {
  
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArenaForAllocation());
    _impl_.child_ = p;
  }
  return _impl_.child_;
}
inline ::bosdyn::api::mission::Node* BosdynDockState::mutable_child() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynDockState.child)
  return _msg;
}
inline void BosdynDockState::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynDockState.child)
}

// string state_name = 4;
inline void BosdynDockState::clear_state_name() {
  _impl_.state_name_.ClearToEmpty();
}
inline const std::string& BosdynDockState::state_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynDockState.state_name)
  return _internal_state_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynDockState::set_state_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynDockState.state_name)
}
inline std::string* BosdynDockState::mutable_state_name() {
  std::string* _s = _internal_mutable_state_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynDockState.state_name)
  return _s;
}
inline const std::string& BosdynDockState::_internal_state_name() const {
  return _impl_.state_name_.Get();
}
inline void BosdynDockState::_internal_set_state_name(const std::string& value) {
  
  _impl_.state_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynDockState::_internal_mutable_state_name() {
  
  return _impl_.state_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynDockState::release_state_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynDockState.state_name)
  return _impl_.state_name_.Release();
}
inline void BosdynDockState::set_allocated_state_name(std::string* state_name) {
  if (state_name != nullptr) {
    
  } else {
    
  }
  _impl_.state_name_.SetAllocated(state_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_name_.IsDefault()) {
    _impl_.state_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynDockState.state_name)
}

// -------------------------------------------------------------------

// BosdynRobotCommand

// string service_name = 1;
inline void BosdynRobotCommand::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& BosdynRobotCommand::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRobotCommand.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynRobotCommand::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynRobotCommand.service_name)
}
inline std::string* BosdynRobotCommand::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRobotCommand.service_name)
  return _s;
}
inline const std::string& BosdynRobotCommand::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void BosdynRobotCommand::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynRobotCommand::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynRobotCommand::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRobotCommand.service_name)
  return _impl_.service_name_.Release();
}
inline void BosdynRobotCommand::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRobotCommand.service_name)
}

// string host = 2;
inline void BosdynRobotCommand::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& BosdynRobotCommand::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRobotCommand.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynRobotCommand::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynRobotCommand.host)
}
inline std::string* BosdynRobotCommand::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRobotCommand.host)
  return _s;
}
inline const std::string& BosdynRobotCommand::_internal_host() const {
  return _impl_.host_.Get();
}
inline void BosdynRobotCommand::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynRobotCommand::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynRobotCommand::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRobotCommand.host)
  return _impl_.host_.Release();
}
inline void BosdynRobotCommand::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRobotCommand.host)
}

// .bosdyn.api.RobotCommand command = 3;
inline bool BosdynRobotCommand::_internal_has_command() const {
  return this != internal_default_instance() && _impl_.command_ != nullptr;
}
inline bool BosdynRobotCommand::has_command() const {
  return _internal_has_command();
}
inline const ::bosdyn::api::RobotCommand& BosdynRobotCommand::_internal_command() const {
  const ::bosdyn::api::RobotCommand* p = _impl_.command_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RobotCommand&>(
      ::bosdyn::api::_RobotCommand_default_instance_);
}
inline const ::bosdyn::api::RobotCommand& BosdynRobotCommand::command() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRobotCommand.command)
  return _internal_command();
}
inline void BosdynRobotCommand::unsafe_arena_set_allocated_command(
    ::bosdyn::api::RobotCommand* command) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.command_);
  }
  _impl_.command_ = command;
  if (command) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynRobotCommand.command)
}
inline ::bosdyn::api::RobotCommand* BosdynRobotCommand::release_command() {
  
  ::bosdyn::api::RobotCommand* temp = _impl_.command_;
  _impl_.command_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RobotCommand* BosdynRobotCommand::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRobotCommand.command)
  
  ::bosdyn::api::RobotCommand* temp = _impl_.command_;
  _impl_.command_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RobotCommand* BosdynRobotCommand::_internal_mutable_command() {
  
  if (_impl_.command_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RobotCommand>(GetArenaForAllocation());
    _impl_.command_ = p;
  }
  return _impl_.command_;
}
inline ::bosdyn::api::RobotCommand* BosdynRobotCommand::mutable_command() {
  ::bosdyn::api::RobotCommand* _msg = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRobotCommand.command)
  return _msg;
}
inline void BosdynRobotCommand::set_allocated_command(::bosdyn::api::RobotCommand* command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.command_);
  }
  if (command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command));
    if (message_arena != submessage_arena) {
      command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.command_ = command;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRobotCommand.command)
}

// -------------------------------------------------------------------

// BosdynPowerRequest

// string service_name = 1;
inline void BosdynPowerRequest::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& BosdynPowerRequest::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynPowerRequest.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynPowerRequest::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynPowerRequest.service_name)
}
inline std::string* BosdynPowerRequest::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynPowerRequest.service_name)
  return _s;
}
inline const std::string& BosdynPowerRequest::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void BosdynPowerRequest::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynPowerRequest::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynPowerRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynPowerRequest.service_name)
  return _impl_.service_name_.Release();
}
inline void BosdynPowerRequest::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynPowerRequest.service_name)
}

// string host = 2;
inline void BosdynPowerRequest::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& BosdynPowerRequest::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynPowerRequest.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynPowerRequest::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynPowerRequest.host)
}
inline std::string* BosdynPowerRequest::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynPowerRequest.host)
  return _s;
}
inline const std::string& BosdynPowerRequest::_internal_host() const {
  return _impl_.host_.Get();
}
inline void BosdynPowerRequest::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynPowerRequest::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynPowerRequest::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynPowerRequest.host)
  return _impl_.host_.Release();
}
inline void BosdynPowerRequest::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynPowerRequest.host)
}

// .bosdyn.api.PowerCommandRequest.Request request = 4;
inline void BosdynPowerRequest::clear_request() {
  _impl_.request_ = 0;
}
inline ::bosdyn::api::PowerCommandRequest_Request BosdynPowerRequest::_internal_request() const {
  return static_cast< ::bosdyn::api::PowerCommandRequest_Request >(_impl_.request_);
}
inline ::bosdyn::api::PowerCommandRequest_Request BosdynPowerRequest::request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynPowerRequest.request)
  return _internal_request();
}
inline void BosdynPowerRequest::_internal_set_request(::bosdyn::api::PowerCommandRequest_Request value) {
  
  _impl_.request_ = value;
}
inline void BosdynPowerRequest::set_request(::bosdyn::api::PowerCommandRequest_Request value) {
  _internal_set_request(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynPowerRequest.request)
}

// -------------------------------------------------------------------

// BosdynNavigateTo

// string service_name = 1;
inline void BosdynNavigateTo::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& BosdynNavigateTo::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateTo.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynNavigateTo::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynNavigateTo.service_name)
}
inline std::string* BosdynNavigateTo::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateTo.service_name)
  return _s;
}
inline const std::string& BosdynNavigateTo::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void BosdynNavigateTo::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynNavigateTo::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynNavigateTo::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateTo.service_name)
  return _impl_.service_name_.Release();
}
inline void BosdynNavigateTo::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateTo.service_name)
}

// string host = 2;
inline void BosdynNavigateTo::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& BosdynNavigateTo::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateTo.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynNavigateTo::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynNavigateTo.host)
}
inline std::string* BosdynNavigateTo::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateTo.host)
  return _s;
}
inline const std::string& BosdynNavigateTo::_internal_host() const {
  return _impl_.host_.Get();
}
inline void BosdynNavigateTo::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynNavigateTo::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynNavigateTo::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateTo.host)
  return _impl_.host_.Release();
}
inline void BosdynNavigateTo::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateTo.host)
}

// string destination_waypoint_id = 3;
inline void BosdynNavigateTo::clear_destination_waypoint_id() {
  _impl_.destination_waypoint_id_.ClearToEmpty();
}
inline const std::string& BosdynNavigateTo::destination_waypoint_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateTo.destination_waypoint_id)
  return _internal_destination_waypoint_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynNavigateTo::set_destination_waypoint_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.destination_waypoint_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynNavigateTo.destination_waypoint_id)
}
inline std::string* BosdynNavigateTo::mutable_destination_waypoint_id() {
  std::string* _s = _internal_mutable_destination_waypoint_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateTo.destination_waypoint_id)
  return _s;
}
inline const std::string& BosdynNavigateTo::_internal_destination_waypoint_id() const {
  return _impl_.destination_waypoint_id_.Get();
}
inline void BosdynNavigateTo::_internal_set_destination_waypoint_id(const std::string& value) {
  
  _impl_.destination_waypoint_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynNavigateTo::_internal_mutable_destination_waypoint_id() {
  
  return _impl_.destination_waypoint_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynNavigateTo::release_destination_waypoint_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateTo.destination_waypoint_id)
  return _impl_.destination_waypoint_id_.Release();
}
inline void BosdynNavigateTo::set_allocated_destination_waypoint_id(std::string* destination_waypoint_id) {
  if (destination_waypoint_id != nullptr) {
    
  } else {
    
  }
  _impl_.destination_waypoint_id_.SetAllocated(destination_waypoint_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destination_waypoint_id_.IsDefault()) {
    _impl_.destination_waypoint_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateTo.destination_waypoint_id)
}

// .bosdyn.api.graph_nav.RouteGenParams route_gen_params = 4;
inline bool BosdynNavigateTo::_internal_has_route_gen_params() const {
  return this != internal_default_instance() && _impl_.route_gen_params_ != nullptr;
}
inline bool BosdynNavigateTo::has_route_gen_params() const {
  return _internal_has_route_gen_params();
}
inline const ::bosdyn::api::graph_nav::RouteGenParams& BosdynNavigateTo::_internal_route_gen_params() const {
  const ::bosdyn::api::graph_nav::RouteGenParams* p = _impl_.route_gen_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::RouteGenParams&>(
      ::bosdyn::api::graph_nav::_RouteGenParams_default_instance_);
}
inline const ::bosdyn::api::graph_nav::RouteGenParams& BosdynNavigateTo::route_gen_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateTo.route_gen_params)
  return _internal_route_gen_params();
}
inline void BosdynNavigateTo::unsafe_arena_set_allocated_route_gen_params(
    ::bosdyn::api::graph_nav::RouteGenParams* route_gen_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_gen_params_);
  }
  _impl_.route_gen_params_ = route_gen_params;
  if (route_gen_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynNavigateTo.route_gen_params)
}
inline ::bosdyn::api::graph_nav::RouteGenParams* BosdynNavigateTo::release_route_gen_params() {
  
  ::bosdyn::api::graph_nav::RouteGenParams* temp = _impl_.route_gen_params_;
  _impl_.route_gen_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::RouteGenParams* BosdynNavigateTo::unsafe_arena_release_route_gen_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateTo.route_gen_params)
  
  ::bosdyn::api::graph_nav::RouteGenParams* temp = _impl_.route_gen_params_;
  _impl_.route_gen_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::RouteGenParams* BosdynNavigateTo::_internal_mutable_route_gen_params() {
  
  if (_impl_.route_gen_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::RouteGenParams>(GetArenaForAllocation());
    _impl_.route_gen_params_ = p;
  }
  return _impl_.route_gen_params_;
}
inline ::bosdyn::api::graph_nav::RouteGenParams* BosdynNavigateTo::mutable_route_gen_params() {
  ::bosdyn::api::graph_nav::RouteGenParams* _msg = _internal_mutable_route_gen_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateTo.route_gen_params)
  return _msg;
}
inline void BosdynNavigateTo::set_allocated_route_gen_params(::bosdyn::api::graph_nav::RouteGenParams* route_gen_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_gen_params_);
  }
  if (route_gen_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(route_gen_params));
    if (message_arena != submessage_arena) {
      route_gen_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route_gen_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.route_gen_params_ = route_gen_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateTo.route_gen_params)
}

// .bosdyn.api.graph_nav.TravelParams travel_params = 5;
inline bool BosdynNavigateTo::_internal_has_travel_params() const {
  return this != internal_default_instance() && _impl_.travel_params_ != nullptr;
}
inline bool BosdynNavigateTo::has_travel_params() const {
  return _internal_has_travel_params();
}
inline const ::bosdyn::api::graph_nav::TravelParams& BosdynNavigateTo::_internal_travel_params() const {
  const ::bosdyn::api::graph_nav::TravelParams* p = _impl_.travel_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::TravelParams&>(
      ::bosdyn::api::graph_nav::_TravelParams_default_instance_);
}
inline const ::bosdyn::api::graph_nav::TravelParams& BosdynNavigateTo::travel_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateTo.travel_params)
  return _internal_travel_params();
}
inline void BosdynNavigateTo::unsafe_arena_set_allocated_travel_params(
    ::bosdyn::api::graph_nav::TravelParams* travel_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.travel_params_);
  }
  _impl_.travel_params_ = travel_params;
  if (travel_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynNavigateTo.travel_params)
}
inline ::bosdyn::api::graph_nav::TravelParams* BosdynNavigateTo::release_travel_params() {
  
  ::bosdyn::api::graph_nav::TravelParams* temp = _impl_.travel_params_;
  _impl_.travel_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::TravelParams* BosdynNavigateTo::unsafe_arena_release_travel_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateTo.travel_params)
  
  ::bosdyn::api::graph_nav::TravelParams* temp = _impl_.travel_params_;
  _impl_.travel_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::TravelParams* BosdynNavigateTo::_internal_mutable_travel_params() {
  
  if (_impl_.travel_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::TravelParams>(GetArenaForAllocation());
    _impl_.travel_params_ = p;
  }
  return _impl_.travel_params_;
}
inline ::bosdyn::api::graph_nav::TravelParams* BosdynNavigateTo::mutable_travel_params() {
  ::bosdyn::api::graph_nav::TravelParams* _msg = _internal_mutable_travel_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateTo.travel_params)
  return _msg;
}
inline void BosdynNavigateTo::set_allocated_travel_params(::bosdyn::api::graph_nav::TravelParams* travel_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.travel_params_);
  }
  if (travel_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(travel_params));
    if (message_arena != submessage_arena) {
      travel_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, travel_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.travel_params_ = travel_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateTo.travel_params)
}

// string navigation_feedback_response_blackboard_key = 6;
inline void BosdynNavigateTo::clear_navigation_feedback_response_blackboard_key() {
  _impl_.navigation_feedback_response_blackboard_key_.ClearToEmpty();
}
inline const std::string& BosdynNavigateTo::navigation_feedback_response_blackboard_key() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateTo.navigation_feedback_response_blackboard_key)
  return _internal_navigation_feedback_response_blackboard_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynNavigateTo::set_navigation_feedback_response_blackboard_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.navigation_feedback_response_blackboard_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynNavigateTo.navigation_feedback_response_blackboard_key)
}
inline std::string* BosdynNavigateTo::mutable_navigation_feedback_response_blackboard_key() {
  std::string* _s = _internal_mutable_navigation_feedback_response_blackboard_key();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateTo.navigation_feedback_response_blackboard_key)
  return _s;
}
inline const std::string& BosdynNavigateTo::_internal_navigation_feedback_response_blackboard_key() const {
  return _impl_.navigation_feedback_response_blackboard_key_.Get();
}
inline void BosdynNavigateTo::_internal_set_navigation_feedback_response_blackboard_key(const std::string& value) {
  
  _impl_.navigation_feedback_response_blackboard_key_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynNavigateTo::_internal_mutable_navigation_feedback_response_blackboard_key() {
  
  return _impl_.navigation_feedback_response_blackboard_key_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynNavigateTo::release_navigation_feedback_response_blackboard_key() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateTo.navigation_feedback_response_blackboard_key)
  return _impl_.navigation_feedback_response_blackboard_key_.Release();
}
inline void BosdynNavigateTo::set_allocated_navigation_feedback_response_blackboard_key(std::string* navigation_feedback_response_blackboard_key) {
  if (navigation_feedback_response_blackboard_key != nullptr) {
    
  } else {
    
  }
  _impl_.navigation_feedback_response_blackboard_key_.SetAllocated(navigation_feedback_response_blackboard_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.navigation_feedback_response_blackboard_key_.IsDefault()) {
    _impl_.navigation_feedback_response_blackboard_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateTo.navigation_feedback_response_blackboard_key)
}

// string navigate_to_response_blackboard_key = 7;
inline void BosdynNavigateTo::clear_navigate_to_response_blackboard_key() {
  _impl_.navigate_to_response_blackboard_key_.ClearToEmpty();
}
inline const std::string& BosdynNavigateTo::navigate_to_response_blackboard_key() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateTo.navigate_to_response_blackboard_key)
  return _internal_navigate_to_response_blackboard_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynNavigateTo::set_navigate_to_response_blackboard_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.navigate_to_response_blackboard_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynNavigateTo.navigate_to_response_blackboard_key)
}
inline std::string* BosdynNavigateTo::mutable_navigate_to_response_blackboard_key() {
  std::string* _s = _internal_mutable_navigate_to_response_blackboard_key();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateTo.navigate_to_response_blackboard_key)
  return _s;
}
inline const std::string& BosdynNavigateTo::_internal_navigate_to_response_blackboard_key() const {
  return _impl_.navigate_to_response_blackboard_key_.Get();
}
inline void BosdynNavigateTo::_internal_set_navigate_to_response_blackboard_key(const std::string& value) {
  
  _impl_.navigate_to_response_blackboard_key_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynNavigateTo::_internal_mutable_navigate_to_response_blackboard_key() {
  
  return _impl_.navigate_to_response_blackboard_key_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynNavigateTo::release_navigate_to_response_blackboard_key() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateTo.navigate_to_response_blackboard_key)
  return _impl_.navigate_to_response_blackboard_key_.Release();
}
inline void BosdynNavigateTo::set_allocated_navigate_to_response_blackboard_key(std::string* navigate_to_response_blackboard_key) {
  if (navigate_to_response_blackboard_key != nullptr) {
    
  } else {
    
  }
  _impl_.navigate_to_response_blackboard_key_.SetAllocated(navigate_to_response_blackboard_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.navigate_to_response_blackboard_key_.IsDefault()) {
    _impl_.navigate_to_response_blackboard_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateTo.navigate_to_response_blackboard_key)
}

// -------------------------------------------------------------------

// BosdynNavigateRoute

// string service_name = 1;
inline void BosdynNavigateRoute::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& BosdynNavigateRoute::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateRoute.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynNavigateRoute::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynNavigateRoute.service_name)
}
inline std::string* BosdynNavigateRoute::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateRoute.service_name)
  return _s;
}
inline const std::string& BosdynNavigateRoute::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void BosdynNavigateRoute::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynNavigateRoute::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynNavigateRoute::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateRoute.service_name)
  return _impl_.service_name_.Release();
}
inline void BosdynNavigateRoute::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateRoute.service_name)
}

// string host = 2;
inline void BosdynNavigateRoute::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& BosdynNavigateRoute::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateRoute.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynNavigateRoute::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynNavigateRoute.host)
}
inline std::string* BosdynNavigateRoute::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateRoute.host)
  return _s;
}
inline const std::string& BosdynNavigateRoute::_internal_host() const {
  return _impl_.host_.Get();
}
inline void BosdynNavigateRoute::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynNavigateRoute::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynNavigateRoute::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateRoute.host)
  return _impl_.host_.Release();
}
inline void BosdynNavigateRoute::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateRoute.host)
}

// .bosdyn.api.graph_nav.Route route = 3;
inline bool BosdynNavigateRoute::_internal_has_route() const {
  return this != internal_default_instance() && _impl_.route_ != nullptr;
}
inline bool BosdynNavigateRoute::has_route() const {
  return _internal_has_route();
}
inline const ::bosdyn::api::graph_nav::Route& BosdynNavigateRoute::_internal_route() const {
  const ::bosdyn::api::graph_nav::Route* p = _impl_.route_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::Route&>(
      ::bosdyn::api::graph_nav::_Route_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Route& BosdynNavigateRoute::route() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateRoute.route)
  return _internal_route();
}
inline void BosdynNavigateRoute::unsafe_arena_set_allocated_route(
    ::bosdyn::api::graph_nav::Route* route) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_);
  }
  _impl_.route_ = route;
  if (route) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynNavigateRoute.route)
}
inline ::bosdyn::api::graph_nav::Route* BosdynNavigateRoute::release_route() {
  
  ::bosdyn::api::graph_nav::Route* temp = _impl_.route_;
  _impl_.route_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::Route* BosdynNavigateRoute::unsafe_arena_release_route() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateRoute.route)
  
  ::bosdyn::api::graph_nav::Route* temp = _impl_.route_;
  _impl_.route_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Route* BosdynNavigateRoute::_internal_mutable_route() {
  
  if (_impl_.route_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Route>(GetArenaForAllocation());
    _impl_.route_ = p;
  }
  return _impl_.route_;
}
inline ::bosdyn::api::graph_nav::Route* BosdynNavigateRoute::mutable_route() {
  ::bosdyn::api::graph_nav::Route* _msg = _internal_mutable_route();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateRoute.route)
  return _msg;
}
inline void BosdynNavigateRoute::set_allocated_route(::bosdyn::api::graph_nav::Route* route) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_);
  }
  if (route) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(route));
    if (message_arena != submessage_arena) {
      route = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.route_ = route;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateRoute.route)
}

// .bosdyn.api.graph_nav.RouteFollowingParams route_follow_params = 4;
inline bool BosdynNavigateRoute::_internal_has_route_follow_params() const {
  return this != internal_default_instance() && _impl_.route_follow_params_ != nullptr;
}
inline bool BosdynNavigateRoute::has_route_follow_params() const {
  return _internal_has_route_follow_params();
}
inline const ::bosdyn::api::graph_nav::RouteFollowingParams& BosdynNavigateRoute::_internal_route_follow_params() const {
  const ::bosdyn::api::graph_nav::RouteFollowingParams* p = _impl_.route_follow_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::RouteFollowingParams&>(
      ::bosdyn::api::graph_nav::_RouteFollowingParams_default_instance_);
}
inline const ::bosdyn::api::graph_nav::RouteFollowingParams& BosdynNavigateRoute::route_follow_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateRoute.route_follow_params)
  return _internal_route_follow_params();
}
inline void BosdynNavigateRoute::unsafe_arena_set_allocated_route_follow_params(
    ::bosdyn::api::graph_nav::RouteFollowingParams* route_follow_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_follow_params_);
  }
  _impl_.route_follow_params_ = route_follow_params;
  if (route_follow_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynNavigateRoute.route_follow_params)
}
inline ::bosdyn::api::graph_nav::RouteFollowingParams* BosdynNavigateRoute::release_route_follow_params() {
  
  ::bosdyn::api::graph_nav::RouteFollowingParams* temp = _impl_.route_follow_params_;
  _impl_.route_follow_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::RouteFollowingParams* BosdynNavigateRoute::unsafe_arena_release_route_follow_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateRoute.route_follow_params)
  
  ::bosdyn::api::graph_nav::RouteFollowingParams* temp = _impl_.route_follow_params_;
  _impl_.route_follow_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::RouteFollowingParams* BosdynNavigateRoute::_internal_mutable_route_follow_params() {
  
  if (_impl_.route_follow_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::RouteFollowingParams>(GetArenaForAllocation());
    _impl_.route_follow_params_ = p;
  }
  return _impl_.route_follow_params_;
}
inline ::bosdyn::api::graph_nav::RouteFollowingParams* BosdynNavigateRoute::mutable_route_follow_params() {
  ::bosdyn::api::graph_nav::RouteFollowingParams* _msg = _internal_mutable_route_follow_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateRoute.route_follow_params)
  return _msg;
}
inline void BosdynNavigateRoute::set_allocated_route_follow_params(::bosdyn::api::graph_nav::RouteFollowingParams* route_follow_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_follow_params_);
  }
  if (route_follow_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(route_follow_params));
    if (message_arena != submessage_arena) {
      route_follow_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route_follow_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.route_follow_params_ = route_follow_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateRoute.route_follow_params)
}

// .bosdyn.api.graph_nav.TravelParams travel_params = 5;
inline bool BosdynNavigateRoute::_internal_has_travel_params() const {
  return this != internal_default_instance() && _impl_.travel_params_ != nullptr;
}
inline bool BosdynNavigateRoute::has_travel_params() const {
  return _internal_has_travel_params();
}
inline const ::bosdyn::api::graph_nav::TravelParams& BosdynNavigateRoute::_internal_travel_params() const {
  const ::bosdyn::api::graph_nav::TravelParams* p = _impl_.travel_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::TravelParams&>(
      ::bosdyn::api::graph_nav::_TravelParams_default_instance_);
}
inline const ::bosdyn::api::graph_nav::TravelParams& BosdynNavigateRoute::travel_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateRoute.travel_params)
  return _internal_travel_params();
}
inline void BosdynNavigateRoute::unsafe_arena_set_allocated_travel_params(
    ::bosdyn::api::graph_nav::TravelParams* travel_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.travel_params_);
  }
  _impl_.travel_params_ = travel_params;
  if (travel_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynNavigateRoute.travel_params)
}
inline ::bosdyn::api::graph_nav::TravelParams* BosdynNavigateRoute::release_travel_params() {
  
  ::bosdyn::api::graph_nav::TravelParams* temp = _impl_.travel_params_;
  _impl_.travel_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::TravelParams* BosdynNavigateRoute::unsafe_arena_release_travel_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateRoute.travel_params)
  
  ::bosdyn::api::graph_nav::TravelParams* temp = _impl_.travel_params_;
  _impl_.travel_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::TravelParams* BosdynNavigateRoute::_internal_mutable_travel_params() {
  
  if (_impl_.travel_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::TravelParams>(GetArenaForAllocation());
    _impl_.travel_params_ = p;
  }
  return _impl_.travel_params_;
}
inline ::bosdyn::api::graph_nav::TravelParams* BosdynNavigateRoute::mutable_travel_params() {
  ::bosdyn::api::graph_nav::TravelParams* _msg = _internal_mutable_travel_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateRoute.travel_params)
  return _msg;
}
inline void BosdynNavigateRoute::set_allocated_travel_params(::bosdyn::api::graph_nav::TravelParams* travel_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.travel_params_);
  }
  if (travel_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(travel_params));
    if (message_arena != submessage_arena) {
      travel_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, travel_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.travel_params_ = travel_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateRoute.travel_params)
}

// string navigation_feedback_response_blackboard_key = 6;
inline void BosdynNavigateRoute::clear_navigation_feedback_response_blackboard_key() {
  _impl_.navigation_feedback_response_blackboard_key_.ClearToEmpty();
}
inline const std::string& BosdynNavigateRoute::navigation_feedback_response_blackboard_key() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateRoute.navigation_feedback_response_blackboard_key)
  return _internal_navigation_feedback_response_blackboard_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynNavigateRoute::set_navigation_feedback_response_blackboard_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.navigation_feedback_response_blackboard_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynNavigateRoute.navigation_feedback_response_blackboard_key)
}
inline std::string* BosdynNavigateRoute::mutable_navigation_feedback_response_blackboard_key() {
  std::string* _s = _internal_mutable_navigation_feedback_response_blackboard_key();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateRoute.navigation_feedback_response_blackboard_key)
  return _s;
}
inline const std::string& BosdynNavigateRoute::_internal_navigation_feedback_response_blackboard_key() const {
  return _impl_.navigation_feedback_response_blackboard_key_.Get();
}
inline void BosdynNavigateRoute::_internal_set_navigation_feedback_response_blackboard_key(const std::string& value) {
  
  _impl_.navigation_feedback_response_blackboard_key_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynNavigateRoute::_internal_mutable_navigation_feedback_response_blackboard_key() {
  
  return _impl_.navigation_feedback_response_blackboard_key_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynNavigateRoute::release_navigation_feedback_response_blackboard_key() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateRoute.navigation_feedback_response_blackboard_key)
  return _impl_.navigation_feedback_response_blackboard_key_.Release();
}
inline void BosdynNavigateRoute::set_allocated_navigation_feedback_response_blackboard_key(std::string* navigation_feedback_response_blackboard_key) {
  if (navigation_feedback_response_blackboard_key != nullptr) {
    
  } else {
    
  }
  _impl_.navigation_feedback_response_blackboard_key_.SetAllocated(navigation_feedback_response_blackboard_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.navigation_feedback_response_blackboard_key_.IsDefault()) {
    _impl_.navigation_feedback_response_blackboard_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateRoute.navigation_feedback_response_blackboard_key)
}

// string navigate_route_response_blackboard_key = 7;
inline void BosdynNavigateRoute::clear_navigate_route_response_blackboard_key() {
  _impl_.navigate_route_response_blackboard_key_.ClearToEmpty();
}
inline const std::string& BosdynNavigateRoute::navigate_route_response_blackboard_key() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateRoute.navigate_route_response_blackboard_key)
  return _internal_navigate_route_response_blackboard_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynNavigateRoute::set_navigate_route_response_blackboard_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.navigate_route_response_blackboard_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynNavigateRoute.navigate_route_response_blackboard_key)
}
inline std::string* BosdynNavigateRoute::mutable_navigate_route_response_blackboard_key() {
  std::string* _s = _internal_mutable_navigate_route_response_blackboard_key();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateRoute.navigate_route_response_blackboard_key)
  return _s;
}
inline const std::string& BosdynNavigateRoute::_internal_navigate_route_response_blackboard_key() const {
  return _impl_.navigate_route_response_blackboard_key_.Get();
}
inline void BosdynNavigateRoute::_internal_set_navigate_route_response_blackboard_key(const std::string& value) {
  
  _impl_.navigate_route_response_blackboard_key_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynNavigateRoute::_internal_mutable_navigate_route_response_blackboard_key() {
  
  return _impl_.navigate_route_response_blackboard_key_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynNavigateRoute::release_navigate_route_response_blackboard_key() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateRoute.navigate_route_response_blackboard_key)
  return _impl_.navigate_route_response_blackboard_key_.Release();
}
inline void BosdynNavigateRoute::set_allocated_navigate_route_response_blackboard_key(std::string* navigate_route_response_blackboard_key) {
  if (navigate_route_response_blackboard_key != nullptr) {
    
  } else {
    
  }
  _impl_.navigate_route_response_blackboard_key_.SetAllocated(navigate_route_response_blackboard_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.navigate_route_response_blackboard_key_.IsDefault()) {
    _impl_.navigate_route_response_blackboard_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateRoute.navigate_route_response_blackboard_key)
}

// -------------------------------------------------------------------

// BosdynGraphNavState

// string service_name = 1;
inline void BosdynGraphNavState::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& BosdynGraphNavState::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGraphNavState.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynGraphNavState::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynGraphNavState.service_name)
}
inline std::string* BosdynGraphNavState::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGraphNavState.service_name)
  return _s;
}
inline const std::string& BosdynGraphNavState::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void BosdynGraphNavState::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynGraphNavState::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynGraphNavState::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGraphNavState.service_name)
  return _impl_.service_name_.Release();
}
inline void BosdynGraphNavState::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGraphNavState.service_name)
}

// string host = 2;
inline void BosdynGraphNavState::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& BosdynGraphNavState::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGraphNavState.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynGraphNavState::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynGraphNavState.host)
}
inline std::string* BosdynGraphNavState::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGraphNavState.host)
  return _s;
}
inline const std::string& BosdynGraphNavState::_internal_host() const {
  return _impl_.host_.Get();
}
inline void BosdynGraphNavState::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynGraphNavState::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynGraphNavState::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGraphNavState.host)
  return _impl_.host_.Release();
}
inline void BosdynGraphNavState::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGraphNavState.host)
}

// .bosdyn.api.mission.Node child = 3;
inline bool BosdynGraphNavState::_internal_has_child() const {
  return this != internal_default_instance() && _impl_.child_ != nullptr;
}
inline bool BosdynGraphNavState::has_child() const {
  return _internal_has_child();
}
inline void BosdynGraphNavState::clear_child() {
  if (GetArenaForAllocation() == nullptr && _impl_.child_ != nullptr) {
    delete _impl_.child_;
  }
  _impl_.child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& BosdynGraphNavState::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Node&>(
      ::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& BosdynGraphNavState::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGraphNavState.child)
  return _internal_child();
}
inline void BosdynGraphNavState::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynGraphNavState.child)
}
inline ::bosdyn::api::mission::Node* BosdynGraphNavState::release_child() {
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Node* BosdynGraphNavState::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGraphNavState.child)
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* BosdynGraphNavState::_internal_mutable_child() {
  
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArenaForAllocation());
    _impl_.child_ = p;
  }
  return _impl_.child_;
}
inline ::bosdyn::api::mission::Node* BosdynGraphNavState::mutable_child() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGraphNavState.child)
  return _msg;
}
inline void BosdynGraphNavState::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGraphNavState.child)
}

// string state_name = 4;
inline void BosdynGraphNavState::clear_state_name() {
  _impl_.state_name_.ClearToEmpty();
}
inline const std::string& BosdynGraphNavState::state_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGraphNavState.state_name)
  return _internal_state_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynGraphNavState::set_state_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynGraphNavState.state_name)
}
inline std::string* BosdynGraphNavState::mutable_state_name() {
  std::string* _s = _internal_mutable_state_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGraphNavState.state_name)
  return _s;
}
inline const std::string& BosdynGraphNavState::_internal_state_name() const {
  return _impl_.state_name_.Get();
}
inline void BosdynGraphNavState::_internal_set_state_name(const std::string& value) {
  
  _impl_.state_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynGraphNavState::_internal_mutable_state_name() {
  
  return _impl_.state_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynGraphNavState::release_state_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGraphNavState.state_name)
  return _impl_.state_name_.Release();
}
inline void BosdynGraphNavState::set_allocated_state_name(std::string* state_name) {
  if (state_name != nullptr) {
    
  } else {
    
  }
  _impl_.state_name_.SetAllocated(state_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_name_.IsDefault()) {
    _impl_.state_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGraphNavState.state_name)
}

// string waypoint_id = 5;
inline void BosdynGraphNavState::clear_waypoint_id() {
  _impl_.waypoint_id_.ClearToEmpty();
}
inline const std::string& BosdynGraphNavState::waypoint_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGraphNavState.waypoint_id)
  return _internal_waypoint_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynGraphNavState::set_waypoint_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.waypoint_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynGraphNavState.waypoint_id)
}
inline std::string* BosdynGraphNavState::mutable_waypoint_id() {
  std::string* _s = _internal_mutable_waypoint_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGraphNavState.waypoint_id)
  return _s;
}
inline const std::string& BosdynGraphNavState::_internal_waypoint_id() const {
  return _impl_.waypoint_id_.Get();
}
inline void BosdynGraphNavState::_internal_set_waypoint_id(const std::string& value) {
  
  _impl_.waypoint_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynGraphNavState::_internal_mutable_waypoint_id() {
  
  return _impl_.waypoint_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynGraphNavState::release_waypoint_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGraphNavState.waypoint_id)
  return _impl_.waypoint_id_.Release();
}
inline void BosdynGraphNavState::set_allocated_waypoint_id(std::string* waypoint_id) {
  if (waypoint_id != nullptr) {
    
  } else {
    
  }
  _impl_.waypoint_id_.SetAllocated(waypoint_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.waypoint_id_.IsDefault()) {
    _impl_.waypoint_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGraphNavState.waypoint_id)
}

// -------------------------------------------------------------------

// BosdynGraphNavLocalize

// string service_name = 1;
inline void BosdynGraphNavLocalize::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& BosdynGraphNavLocalize::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGraphNavLocalize.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynGraphNavLocalize::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynGraphNavLocalize.service_name)
}
inline std::string* BosdynGraphNavLocalize::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGraphNavLocalize.service_name)
  return _s;
}
inline const std::string& BosdynGraphNavLocalize::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void BosdynGraphNavLocalize::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynGraphNavLocalize::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynGraphNavLocalize::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGraphNavLocalize.service_name)
  return _impl_.service_name_.Release();
}
inline void BosdynGraphNavLocalize::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGraphNavLocalize.service_name)
}

// string host = 2;
inline void BosdynGraphNavLocalize::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& BosdynGraphNavLocalize::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGraphNavLocalize.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynGraphNavLocalize::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynGraphNavLocalize.host)
}
inline std::string* BosdynGraphNavLocalize::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGraphNavLocalize.host)
  return _s;
}
inline const std::string& BosdynGraphNavLocalize::_internal_host() const {
  return _impl_.host_.Get();
}
inline void BosdynGraphNavLocalize::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynGraphNavLocalize::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynGraphNavLocalize::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGraphNavLocalize.host)
  return _impl_.host_.Release();
}
inline void BosdynGraphNavLocalize::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGraphNavLocalize.host)
}

// .bosdyn.api.graph_nav.SetLocalizationRequest localization_request = 3;
inline bool BosdynGraphNavLocalize::_internal_has_localization_request() const {
  return this != internal_default_instance() && _impl_.localization_request_ != nullptr;
}
inline bool BosdynGraphNavLocalize::has_localization_request() const {
  return _internal_has_localization_request();
}
inline const ::bosdyn::api::graph_nav::SetLocalizationRequest& BosdynGraphNavLocalize::_internal_localization_request() const {
  const ::bosdyn::api::graph_nav::SetLocalizationRequest* p = _impl_.localization_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::SetLocalizationRequest&>(
      ::bosdyn::api::graph_nav::_SetLocalizationRequest_default_instance_);
}
inline const ::bosdyn::api::graph_nav::SetLocalizationRequest& BosdynGraphNavLocalize::localization_request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGraphNavLocalize.localization_request)
  return _internal_localization_request();
}
inline void BosdynGraphNavLocalize::unsafe_arena_set_allocated_localization_request(
    ::bosdyn::api::graph_nav::SetLocalizationRequest* localization_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.localization_request_);
  }
  _impl_.localization_request_ = localization_request;
  if (localization_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynGraphNavLocalize.localization_request)
}
inline ::bosdyn::api::graph_nav::SetLocalizationRequest* BosdynGraphNavLocalize::release_localization_request() {
  
  ::bosdyn::api::graph_nav::SetLocalizationRequest* temp = _impl_.localization_request_;
  _impl_.localization_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::SetLocalizationRequest* BosdynGraphNavLocalize::unsafe_arena_release_localization_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGraphNavLocalize.localization_request)
  
  ::bosdyn::api::graph_nav::SetLocalizationRequest* temp = _impl_.localization_request_;
  _impl_.localization_request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::SetLocalizationRequest* BosdynGraphNavLocalize::_internal_mutable_localization_request() {
  
  if (_impl_.localization_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::SetLocalizationRequest>(GetArenaForAllocation());
    _impl_.localization_request_ = p;
  }
  return _impl_.localization_request_;
}
inline ::bosdyn::api::graph_nav::SetLocalizationRequest* BosdynGraphNavLocalize::mutable_localization_request() {
  ::bosdyn::api::graph_nav::SetLocalizationRequest* _msg = _internal_mutable_localization_request();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGraphNavLocalize.localization_request)
  return _msg;
}
inline void BosdynGraphNavLocalize::set_allocated_localization_request(::bosdyn::api::graph_nav::SetLocalizationRequest* localization_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.localization_request_);
  }
  if (localization_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(localization_request));
    if (message_arena != submessage_arena) {
      localization_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, localization_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.localization_request_ = localization_request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGraphNavLocalize.localization_request)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BosdynRecordEvent

// string service_name = 1;
inline void BosdynRecordEvent::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& BosdynRecordEvent::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRecordEvent.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynRecordEvent::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynRecordEvent.service_name)
}
inline std::string* BosdynRecordEvent::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRecordEvent.service_name)
  return _s;
}
inline const std::string& BosdynRecordEvent::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void BosdynRecordEvent::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynRecordEvent::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynRecordEvent::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRecordEvent.service_name)
  return _impl_.service_name_.Release();
}
inline void BosdynRecordEvent::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRecordEvent.service_name)
}

// string host = 2;
inline void BosdynRecordEvent::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& BosdynRecordEvent::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRecordEvent.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynRecordEvent::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynRecordEvent.host)
}
inline std::string* BosdynRecordEvent::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRecordEvent.host)
  return _s;
}
inline const std::string& BosdynRecordEvent::_internal_host() const {
  return _impl_.host_.Get();
}
inline void BosdynRecordEvent::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynRecordEvent::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynRecordEvent::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRecordEvent.host)
  return _impl_.host_.Release();
}
inline void BosdynRecordEvent::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRecordEvent.host)
}

// .bosdyn.api.Event event = 3;
inline bool BosdynRecordEvent::_internal_has_event() const {
  return this != internal_default_instance() && _impl_.event_ != nullptr;
}
inline bool BosdynRecordEvent::has_event() const {
  return _internal_has_event();
}
inline const ::bosdyn::api::Event& BosdynRecordEvent::_internal_event() const {
  const ::bosdyn::api::Event* p = _impl_.event_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Event&>(
      ::bosdyn::api::_Event_default_instance_);
}
inline const ::bosdyn::api::Event& BosdynRecordEvent::event() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRecordEvent.event)
  return _internal_event();
}
inline void BosdynRecordEvent::unsafe_arena_set_allocated_event(
    ::bosdyn::api::Event* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_);
  }
  _impl_.event_ = event;
  if (event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynRecordEvent.event)
}
inline ::bosdyn::api::Event* BosdynRecordEvent::release_event() {
  
  ::bosdyn::api::Event* temp = _impl_.event_;
  _impl_.event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Event* BosdynRecordEvent::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRecordEvent.event)
  
  ::bosdyn::api::Event* temp = _impl_.event_;
  _impl_.event_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Event* BosdynRecordEvent::_internal_mutable_event() {
  
  if (_impl_.event_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Event>(GetArenaForAllocation());
    _impl_.event_ = p;
  }
  return _impl_.event_;
}
inline ::bosdyn::api::Event* BosdynRecordEvent::mutable_event() {
  ::bosdyn::api::Event* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRecordEvent.event)
  return _msg;
}
inline void BosdynRecordEvent::set_allocated_event(::bosdyn::api::Event* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_);
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event));
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.event_ = event;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRecordEvent.event)
}

// bool succeed_early = 4;
inline void BosdynRecordEvent::clear_succeed_early() {
  _impl_.succeed_early_ = false;
}
inline bool BosdynRecordEvent::_internal_succeed_early() const {
  return _impl_.succeed_early_;
}
inline bool BosdynRecordEvent::succeed_early() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRecordEvent.succeed_early)
  return _internal_succeed_early();
}
inline void BosdynRecordEvent::_internal_set_succeed_early(bool value) {
  
  _impl_.succeed_early_ = value;
}
inline void BosdynRecordEvent::set_succeed_early(bool value) {
  _internal_set_succeed_early(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynRecordEvent.succeed_early)
}

// map<string, .bosdyn.api.mission.Value> additional_parameters = 5;
inline int BosdynRecordEvent::_internal_additional_parameters_size() const {
  return _impl_.additional_parameters_.size();
}
inline int BosdynRecordEvent::additional_parameters_size() const {
  return _internal_additional_parameters_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::mission::Value >&
BosdynRecordEvent::_internal_additional_parameters() const {
  return _impl_.additional_parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::mission::Value >&
BosdynRecordEvent::additional_parameters() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.mission.BosdynRecordEvent.additional_parameters)
  return _internal_additional_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::mission::Value >*
BosdynRecordEvent::_internal_mutable_additional_parameters() {
  return _impl_.additional_parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::mission::Value >*
BosdynRecordEvent::mutable_additional_parameters() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.mission.BosdynRecordEvent.additional_parameters)
  return _internal_mutable_additional_parameters();
}

// -------------------------------------------------------------------

// RemoteGrpc

// string host = 1;
inline void RemoteGrpc::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& RemoteGrpc::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RemoteGrpc.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteGrpc::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.RemoteGrpc.host)
}
inline std::string* RemoteGrpc::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RemoteGrpc.host)
  return _s;
}
inline const std::string& RemoteGrpc::_internal_host() const {
  return _impl_.host_.Get();
}
inline void RemoteGrpc::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoteGrpc::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoteGrpc::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.RemoteGrpc.host)
  return _impl_.host_.Release();
}
inline void RemoteGrpc::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.RemoteGrpc.host)
}

// string service_name = 3;
inline void RemoteGrpc::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& RemoteGrpc::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RemoteGrpc.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteGrpc::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.RemoteGrpc.service_name)
}
inline std::string* RemoteGrpc::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RemoteGrpc.service_name)
  return _s;
}
inline const std::string& RemoteGrpc::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void RemoteGrpc::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoteGrpc::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoteGrpc::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.RemoteGrpc.service_name)
  return _impl_.service_name_.Release();
}
inline void RemoteGrpc::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.RemoteGrpc.service_name)
}

// float timeout = 4;
inline void RemoteGrpc::clear_timeout() {
  _impl_.timeout_ = 0;
}
inline float RemoteGrpc::_internal_timeout() const {
  return _impl_.timeout_;
}
inline float RemoteGrpc::timeout() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RemoteGrpc.timeout)
  return _internal_timeout();
}
inline void RemoteGrpc::_internal_set_timeout(float value) {
  
  _impl_.timeout_ = value;
}
inline void RemoteGrpc::set_timeout(float value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.RemoteGrpc.timeout)
}

// repeated string lease_resources = 5;
inline int RemoteGrpc::_internal_lease_resources_size() const {
  return _impl_.lease_resources_.size();
}
inline int RemoteGrpc::lease_resources_size() const {
  return _internal_lease_resources_size();
}
inline void RemoteGrpc::clear_lease_resources() {
  _impl_.lease_resources_.Clear();
}
inline std::string* RemoteGrpc::add_lease_resources() {
  std::string* _s = _internal_add_lease_resources();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.mission.RemoteGrpc.lease_resources)
  return _s;
}
inline const std::string& RemoteGrpc::_internal_lease_resources(int index) const {
  return _impl_.lease_resources_.Get(index);
}
inline const std::string& RemoteGrpc::lease_resources(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RemoteGrpc.lease_resources)
  return _internal_lease_resources(index);
}
inline std::string* RemoteGrpc::mutable_lease_resources(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RemoteGrpc.lease_resources)
  return _impl_.lease_resources_.Mutable(index);
}
inline void RemoteGrpc::set_lease_resources(int index, const std::string& value) {
  _impl_.lease_resources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.RemoteGrpc.lease_resources)
}
inline void RemoteGrpc::set_lease_resources(int index, std::string&& value) {
  _impl_.lease_resources_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.RemoteGrpc.lease_resources)
}
inline void RemoteGrpc::set_lease_resources(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.lease_resources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.RemoteGrpc.lease_resources)
}
inline void RemoteGrpc::set_lease_resources(int index, const char* value, size_t size) {
  _impl_.lease_resources_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.RemoteGrpc.lease_resources)
}
inline std::string* RemoteGrpc::_internal_add_lease_resources() {
  return _impl_.lease_resources_.Add();
}
inline void RemoteGrpc::add_lease_resources(const std::string& value) {
  _impl_.lease_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.RemoteGrpc.lease_resources)
}
inline void RemoteGrpc::add_lease_resources(std::string&& value) {
  _impl_.lease_resources_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.RemoteGrpc.lease_resources)
}
inline void RemoteGrpc::add_lease_resources(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.lease_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.mission.RemoteGrpc.lease_resources)
}
inline void RemoteGrpc::add_lease_resources(const char* value, size_t size) {
  _impl_.lease_resources_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.mission.RemoteGrpc.lease_resources)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RemoteGrpc::lease_resources() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.RemoteGrpc.lease_resources)
  return _impl_.lease_resources_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RemoteGrpc::mutable_lease_resources() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.RemoteGrpc.lease_resources)
  return &_impl_.lease_resources_;
}

// repeated .bosdyn.api.mission.KeyValue inputs = 6;
inline int RemoteGrpc::_internal_inputs_size() const {
  return _impl_.inputs_.size();
}
inline int RemoteGrpc::inputs_size() const {
  return _internal_inputs_size();
}
inline ::bosdyn::api::mission::KeyValue* RemoteGrpc::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RemoteGrpc.inputs)
  return _impl_.inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
RemoteGrpc::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.RemoteGrpc.inputs)
  return &_impl_.inputs_;
}
inline const ::bosdyn::api::mission::KeyValue& RemoteGrpc::_internal_inputs(int index) const {
  return _impl_.inputs_.Get(index);
}
inline const ::bosdyn::api::mission::KeyValue& RemoteGrpc::inputs(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RemoteGrpc.inputs)
  return _internal_inputs(index);
}
inline ::bosdyn::api::mission::KeyValue* RemoteGrpc::_internal_add_inputs() {
  return _impl_.inputs_.Add();
}
inline ::bosdyn::api::mission::KeyValue* RemoteGrpc::add_inputs() {
  ::bosdyn::api::mission::KeyValue* _add = _internal_add_inputs();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.RemoteGrpc.inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
RemoteGrpc::inputs() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.RemoteGrpc.inputs)
  return _impl_.inputs_;
}

// -------------------------------------------------------------------

// Sleep

// float seconds = 1;
inline void Sleep::clear_seconds() {
  _impl_.seconds_ = 0;
}
inline float Sleep::_internal_seconds() const {
  return _impl_.seconds_;
}
inline float Sleep::seconds() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Sleep.seconds)
  return _internal_seconds();
}
inline void Sleep::_internal_set_seconds(float value) {
  
  _impl_.seconds_ = value;
}
inline void Sleep::set_seconds(float value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Sleep.seconds)
}

// bool restart_after_stop = 2;
inline void Sleep::clear_restart_after_stop() {
  _impl_.restart_after_stop_ = false;
}
inline bool Sleep::_internal_restart_after_stop() const {
  return _impl_.restart_after_stop_;
}
inline bool Sleep::restart_after_stop() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Sleep.restart_after_stop)
  return _internal_restart_after_stop();
}
inline void Sleep::_internal_set_restart_after_stop(bool value) {
  
  _impl_.restart_after_stop_ = value;
}
inline void Sleep::set_restart_after_stop(bool value) {
  _internal_set_restart_after_stop(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Sleep.restart_after_stop)
}

// -------------------------------------------------------------------

// Prompt_Option

// string text = 1;
inline void Prompt_Option::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& Prompt_Option::text() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.Option.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Prompt_Option::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Prompt.Option.text)
}
inline std::string* Prompt_Option::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Prompt.Option.text)
  return _s;
}
inline const std::string& Prompt_Option::_internal_text() const {
  return _impl_.text_.Get();
}
inline void Prompt_Option::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* Prompt_Option::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* Prompt_Option::release_text() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Prompt.Option.text)
  return _impl_.text_.Release();
}
inline void Prompt_Option::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Prompt.Option.text)
}

// int64 answer_code = 2;
inline void Prompt_Option::clear_answer_code() {
  _impl_.answer_code_ = int64_t{0};
}
inline int64_t Prompt_Option::_internal_answer_code() const {
  return _impl_.answer_code_;
}
inline int64_t Prompt_Option::answer_code() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.Option.answer_code)
  return _internal_answer_code();
}
inline void Prompt_Option::_internal_set_answer_code(int64_t value) {
  
  _impl_.answer_code_ = value;
}
inline void Prompt_Option::set_answer_code(int64_t value) {
  _internal_set_answer_code(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Prompt.Option.answer_code)
}

// -------------------------------------------------------------------

// Prompt

// bool always_reprompt = 1;
inline void Prompt::clear_always_reprompt() {
  _impl_.always_reprompt_ = false;
}
inline bool Prompt::_internal_always_reprompt() const {
  return _impl_.always_reprompt_;
}
inline bool Prompt::always_reprompt() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.always_reprompt)
  return _internal_always_reprompt();
}
inline void Prompt::_internal_set_always_reprompt(bool value) {
  
  _impl_.always_reprompt_ = value;
}
inline void Prompt::set_always_reprompt(bool value) {
  _internal_set_always_reprompt(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Prompt.always_reprompt)
}

// string text = 2;
inline void Prompt::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& Prompt::text() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Prompt::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Prompt.text)
}
inline std::string* Prompt::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Prompt.text)
  return _s;
}
inline const std::string& Prompt::_internal_text() const {
  return _impl_.text_.Get();
}
inline void Prompt::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* Prompt::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* Prompt::release_text() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Prompt.text)
  return _impl_.text_.Release();
}
inline void Prompt::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Prompt.text)
}

// string source = 3;
inline void Prompt::clear_source() {
  _impl_.source_.ClearToEmpty();
}
inline const std::string& Prompt::source() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Prompt::set_source(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Prompt.source)
}
inline std::string* Prompt::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Prompt.source)
  return _s;
}
inline const std::string& Prompt::_internal_source() const {
  return _impl_.source_.Get();
}
inline void Prompt::_internal_set_source(const std::string& value) {
  
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* Prompt::_internal_mutable_source() {
  
  return _impl_.source_.Mutable(GetArenaForAllocation());
}
inline std::string* Prompt::release_source() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Prompt.source)
  return _impl_.source_.Release();
}
inline void Prompt::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  _impl_.source_.SetAllocated(source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Prompt.source)
}

// repeated .bosdyn.api.mission.Prompt.Option options = 4;
inline int Prompt::_internal_options_size() const {
  return _impl_.options_.size();
}
inline int Prompt::options_size() const {
  return _internal_options_size();
}
inline void Prompt::clear_options() {
  _impl_.options_.Clear();
}
inline ::bosdyn::api::mission::Prompt_Option* Prompt::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Prompt.options)
  return _impl_.options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Prompt_Option >*
Prompt::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.Prompt.options)
  return &_impl_.options_;
}
inline const ::bosdyn::api::mission::Prompt_Option& Prompt::_internal_options(int index) const {
  return _impl_.options_.Get(index);
}
inline const ::bosdyn::api::mission::Prompt_Option& Prompt::options(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.options)
  return _internal_options(index);
}
inline ::bosdyn::api::mission::Prompt_Option* Prompt::_internal_add_options() {
  return _impl_.options_.Add();
}
inline ::bosdyn::api::mission::Prompt_Option* Prompt::add_options() {
  ::bosdyn::api::mission::Prompt_Option* _add = _internal_add_options();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.Prompt.options)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Prompt_Option >&
Prompt::options() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.Prompt.options)
  return _impl_.options_;
}

// .bosdyn.api.mission.Node child = 5;
inline bool Prompt::_internal_has_child() const {
  return this != internal_default_instance() && _impl_.child_ != nullptr;
}
inline bool Prompt::has_child() const {
  return _internal_has_child();
}
inline void Prompt::clear_child() {
  if (GetArenaForAllocation() == nullptr && _impl_.child_ != nullptr) {
    delete _impl_.child_;
  }
  _impl_.child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& Prompt::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Node&>(
      ::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& Prompt::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.child)
  return _internal_child();
}
inline void Prompt::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Prompt.child)
}
inline ::bosdyn::api::mission::Node* Prompt::release_child() {
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Node* Prompt::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Prompt.child)
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* Prompt::_internal_mutable_child() {
  
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArenaForAllocation());
    _impl_.child_ = p;
  }
  return _impl_.child_;
}
inline ::bosdyn::api::mission::Node* Prompt::mutable_child() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Prompt.child)
  return _msg;
}
inline void Prompt::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Prompt.child)
}

// bool for_autonomous_processing = 6;
inline void Prompt::clear_for_autonomous_processing() {
  _impl_.for_autonomous_processing_ = false;
}
inline bool Prompt::_internal_for_autonomous_processing() const {
  return _impl_.for_autonomous_processing_;
}
inline bool Prompt::for_autonomous_processing() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.for_autonomous_processing)
  return _internal_for_autonomous_processing();
}
inline void Prompt::_internal_set_for_autonomous_processing(bool value) {
  
  _impl_.for_autonomous_processing_ = value;
}
inline void Prompt::set_for_autonomous_processing(bool value) {
  _internal_set_for_autonomous_processing(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Prompt.for_autonomous_processing)
}

// .bosdyn.api.AlertData.SeverityLevel severity = 7;
inline void Prompt::clear_severity() {
  _impl_.severity_ = 0;
}
inline ::bosdyn::api::AlertData_SeverityLevel Prompt::_internal_severity() const {
  return static_cast< ::bosdyn::api::AlertData_SeverityLevel >(_impl_.severity_);
}
inline ::bosdyn::api::AlertData_SeverityLevel Prompt::severity() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.severity)
  return _internal_severity();
}
inline void Prompt::_internal_set_severity(::bosdyn::api::AlertData_SeverityLevel value) {
  
  _impl_.severity_ = value;
}
inline void Prompt::set_severity(::bosdyn::api::AlertData_SeverityLevel value) {
  _internal_set_severity(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Prompt.severity)
}

// -------------------------------------------------------------------

// BosdynGripperCameraParamsState

// string service_name = 1;
inline void BosdynGripperCameraParamsState::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& BosdynGripperCameraParamsState::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGripperCameraParamsState.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynGripperCameraParamsState::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynGripperCameraParamsState.service_name)
}
inline std::string* BosdynGripperCameraParamsState::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGripperCameraParamsState.service_name)
  return _s;
}
inline const std::string& BosdynGripperCameraParamsState::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void BosdynGripperCameraParamsState::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynGripperCameraParamsState::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynGripperCameraParamsState::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGripperCameraParamsState.service_name)
  return _impl_.service_name_.Release();
}
inline void BosdynGripperCameraParamsState::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGripperCameraParamsState.service_name)
}

// string host = 2;
inline void BosdynGripperCameraParamsState::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& BosdynGripperCameraParamsState::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGripperCameraParamsState.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynGripperCameraParamsState::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynGripperCameraParamsState.host)
}
inline std::string* BosdynGripperCameraParamsState::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGripperCameraParamsState.host)
  return _s;
}
inline const std::string& BosdynGripperCameraParamsState::_internal_host() const {
  return _impl_.host_.Get();
}
inline void BosdynGripperCameraParamsState::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynGripperCameraParamsState::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynGripperCameraParamsState::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGripperCameraParamsState.host)
  return _impl_.host_.Release();
}
inline void BosdynGripperCameraParamsState::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGripperCameraParamsState.host)
}

// .bosdyn.api.mission.Node child = 3;
inline bool BosdynGripperCameraParamsState::_internal_has_child() const {
  return this != internal_default_instance() && _impl_.child_ != nullptr;
}
inline bool BosdynGripperCameraParamsState::has_child() const {
  return _internal_has_child();
}
inline void BosdynGripperCameraParamsState::clear_child() {
  if (GetArenaForAllocation() == nullptr && _impl_.child_ != nullptr) {
    delete _impl_.child_;
  }
  _impl_.child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& BosdynGripperCameraParamsState::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Node&>(
      ::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& BosdynGripperCameraParamsState::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGripperCameraParamsState.child)
  return _internal_child();
}
inline void BosdynGripperCameraParamsState::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynGripperCameraParamsState.child)
}
inline ::bosdyn::api::mission::Node* BosdynGripperCameraParamsState::release_child() {
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Node* BosdynGripperCameraParamsState::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGripperCameraParamsState.child)
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* BosdynGripperCameraParamsState::_internal_mutable_child() {
  
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArenaForAllocation());
    _impl_.child_ = p;
  }
  return _impl_.child_;
}
inline ::bosdyn::api::mission::Node* BosdynGripperCameraParamsState::mutable_child() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGripperCameraParamsState.child)
  return _msg;
}
inline void BosdynGripperCameraParamsState::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGripperCameraParamsState.child)
}

// string state_name = 4;
inline void BosdynGripperCameraParamsState::clear_state_name() {
  _impl_.state_name_.ClearToEmpty();
}
inline const std::string& BosdynGripperCameraParamsState::state_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGripperCameraParamsState.state_name)
  return _internal_state_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BosdynGripperCameraParamsState::set_state_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynGripperCameraParamsState.state_name)
}
inline std::string* BosdynGripperCameraParamsState::mutable_state_name() {
  std::string* _s = _internal_mutable_state_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGripperCameraParamsState.state_name)
  return _s;
}
inline const std::string& BosdynGripperCameraParamsState::_internal_state_name() const {
  return _impl_.state_name_.Get();
}
inline void BosdynGripperCameraParamsState::_internal_set_state_name(const std::string& value) {
  
  _impl_.state_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BosdynGripperCameraParamsState::_internal_mutable_state_name() {
  
  return _impl_.state_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BosdynGripperCameraParamsState::release_state_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGripperCameraParamsState.state_name)
  return _impl_.state_name_.Release();
}
inline void BosdynGripperCameraParamsState::set_allocated_state_name(std::string* state_name) {
  if (state_name != nullptr) {
    
  } else {
    
  }
  _impl_.state_name_.SetAllocated(state_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_name_.IsDefault()) {
    _impl_.state_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGripperCameraParamsState.state_name)
}

// -------------------------------------------------------------------

// SetGripperCameraParams

// string service_name = 1;
inline void SetGripperCameraParams::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& SetGripperCameraParams::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SetGripperCameraParams.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetGripperCameraParams::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SetGripperCameraParams.service_name)
}
inline std::string* SetGripperCameraParams::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SetGripperCameraParams.service_name)
  return _s;
}
inline const std::string& SetGripperCameraParams::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void SetGripperCameraParams::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SetGripperCameraParams::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SetGripperCameraParams::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SetGripperCameraParams.service_name)
  return _impl_.service_name_.Release();
}
inline void SetGripperCameraParams::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SetGripperCameraParams.service_name)
}

// string host = 2;
inline void SetGripperCameraParams::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& SetGripperCameraParams::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SetGripperCameraParams.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetGripperCameraParams::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SetGripperCameraParams.host)
}
inline std::string* SetGripperCameraParams::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SetGripperCameraParams.host)
  return _s;
}
inline const std::string& SetGripperCameraParams::_internal_host() const {
  return _impl_.host_.Get();
}
inline void SetGripperCameraParams::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* SetGripperCameraParams::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* SetGripperCameraParams::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SetGripperCameraParams.host)
  return _impl_.host_.Release();
}
inline void SetGripperCameraParams::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SetGripperCameraParams.host)
}

// string params_in_blackboard_key = 3;
inline bool SetGripperCameraParams::_internal_has_params_in_blackboard_key() const {
  return params_case() == kParamsInBlackboardKey;
}
inline bool SetGripperCameraParams::has_params_in_blackboard_key() const {
  return _internal_has_params_in_blackboard_key();
}
inline void SetGripperCameraParams::set_has_params_in_blackboard_key() {
  _impl_._oneof_case_[0] = kParamsInBlackboardKey;
}
inline void SetGripperCameraParams::clear_params_in_blackboard_key() {
  if (_internal_has_params_in_blackboard_key()) {
    _impl_.params_.params_in_blackboard_key_.Destroy();
    clear_has_params();
  }
}
inline const std::string& SetGripperCameraParams::params_in_blackboard_key() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SetGripperCameraParams.params_in_blackboard_key)
  return _internal_params_in_blackboard_key();
}
template <typename ArgT0, typename... ArgT>
inline void SetGripperCameraParams::set_params_in_blackboard_key(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_params_in_blackboard_key()) {
    clear_params();
    set_has_params_in_blackboard_key();
    _impl_.params_.params_in_blackboard_key_.InitDefault();
  }
  _impl_.params_.params_in_blackboard_key_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SetGripperCameraParams.params_in_blackboard_key)
}
inline std::string* SetGripperCameraParams::mutable_params_in_blackboard_key() {
  std::string* _s = _internal_mutable_params_in_blackboard_key();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SetGripperCameraParams.params_in_blackboard_key)
  return _s;
}
inline const std::string& SetGripperCameraParams::_internal_params_in_blackboard_key() const {
  if (_internal_has_params_in_blackboard_key()) {
    return _impl_.params_.params_in_blackboard_key_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SetGripperCameraParams::_internal_set_params_in_blackboard_key(const std::string& value) {
  if (!_internal_has_params_in_blackboard_key()) {
    clear_params();
    set_has_params_in_blackboard_key();
    _impl_.params_.params_in_blackboard_key_.InitDefault();
  }
  _impl_.params_.params_in_blackboard_key_.Set(value, GetArenaForAllocation());
}
inline std::string* SetGripperCameraParams::_internal_mutable_params_in_blackboard_key() {
  if (!_internal_has_params_in_blackboard_key()) {
    clear_params();
    set_has_params_in_blackboard_key();
    _impl_.params_.params_in_blackboard_key_.InitDefault();
  }
  return _impl_.params_.params_in_blackboard_key_.Mutable(      GetArenaForAllocation());
}
inline std::string* SetGripperCameraParams::release_params_in_blackboard_key() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SetGripperCameraParams.params_in_blackboard_key)
  if (_internal_has_params_in_blackboard_key()) {
    clear_has_params();
    return _impl_.params_.params_in_blackboard_key_.Release();
  } else {
    return nullptr;
  }
}
inline void SetGripperCameraParams::set_allocated_params_in_blackboard_key(std::string* params_in_blackboard_key) {
  if (has_params()) {
    clear_params();
  }
  if (params_in_blackboard_key != nullptr) {
    set_has_params_in_blackboard_key();
    _impl_.params_.params_in_blackboard_key_.InitAllocated(params_in_blackboard_key, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SetGripperCameraParams.params_in_blackboard_key)
}

// .bosdyn.api.GripperCameraParams new_params = 4;
inline bool SetGripperCameraParams::_internal_has_new_params() const {
  return params_case() == kNewParams;
}
inline bool SetGripperCameraParams::has_new_params() const {
  return _internal_has_new_params();
}
inline void SetGripperCameraParams::set_has_new_params() {
  _impl_._oneof_case_[0] = kNewParams;
}
inline ::bosdyn::api::GripperCameraParams* SetGripperCameraParams::release_new_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SetGripperCameraParams.new_params)
  if (_internal_has_new_params()) {
    clear_has_params();
    ::bosdyn::api::GripperCameraParams* temp = _impl_.params_.new_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.new_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::GripperCameraParams& SetGripperCameraParams::_internal_new_params() const {
  return _internal_has_new_params()
      ? *_impl_.params_.new_params_
      : reinterpret_cast< ::bosdyn::api::GripperCameraParams&>(::bosdyn::api::_GripperCameraParams_default_instance_);
}
inline const ::bosdyn::api::GripperCameraParams& SetGripperCameraParams::new_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SetGripperCameraParams.new_params)
  return _internal_new_params();
}
inline ::bosdyn::api::GripperCameraParams* SetGripperCameraParams::unsafe_arena_release_new_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.mission.SetGripperCameraParams.new_params)
  if (_internal_has_new_params()) {
    clear_has_params();
    ::bosdyn::api::GripperCameraParams* temp = _impl_.params_.new_params_;
    _impl_.params_.new_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SetGripperCameraParams::unsafe_arena_set_allocated_new_params(::bosdyn::api::GripperCameraParams* new_params) {
  clear_params();
  if (new_params) {
    set_has_new_params();
    _impl_.params_.new_params_ = new_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.SetGripperCameraParams.new_params)
}
inline ::bosdyn::api::GripperCameraParams* SetGripperCameraParams::_internal_mutable_new_params() {
  if (!_internal_has_new_params()) {
    clear_params();
    set_has_new_params();
    _impl_.params_.new_params_ = CreateMaybeMessage< ::bosdyn::api::GripperCameraParams >(GetArenaForAllocation());
  }
  return _impl_.params_.new_params_;
}
inline ::bosdyn::api::GripperCameraParams* SetGripperCameraParams::mutable_new_params() {
  ::bosdyn::api::GripperCameraParams* _msg = _internal_mutable_new_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SetGripperCameraParams.new_params)
  return _msg;
}

inline bool SetGripperCameraParams::has_params() const {
  return params_case() != PARAMS_NOT_SET;
}
inline void SetGripperCameraParams::clear_has_params() {
  _impl_._oneof_case_[0] = PARAMS_NOT_SET;
}
inline SetGripperCameraParams::ParamsCase SetGripperCameraParams::params_case() const {
  return SetGripperCameraParams::ParamsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SpotCamPtz_AdjustParameters

// string localization_varname = 4;
inline void SpotCamPtz_AdjustParameters::clear_localization_varname() {
  _impl_.localization_varname_.ClearToEmpty();
}
inline const std::string& SpotCamPtz_AdjustParameters::localization_varname() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamPtz.AdjustParameters.localization_varname)
  return _internal_localization_varname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpotCamPtz_AdjustParameters::set_localization_varname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.localization_varname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SpotCamPtz.AdjustParameters.localization_varname)
}
inline std::string* SpotCamPtz_AdjustParameters::mutable_localization_varname() {
  std::string* _s = _internal_mutable_localization_varname();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamPtz.AdjustParameters.localization_varname)
  return _s;
}
inline const std::string& SpotCamPtz_AdjustParameters::_internal_localization_varname() const {
  return _impl_.localization_varname_.Get();
}
inline void SpotCamPtz_AdjustParameters::_internal_set_localization_varname(const std::string& value) {
  
  _impl_.localization_varname_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotCamPtz_AdjustParameters::_internal_mutable_localization_varname() {
  
  return _impl_.localization_varname_.Mutable(GetArenaForAllocation());
}
inline std::string* SpotCamPtz_AdjustParameters::release_localization_varname() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamPtz.AdjustParameters.localization_varname)
  return _impl_.localization_varname_.Release();
}
inline void SpotCamPtz_AdjustParameters::set_allocated_localization_varname(std::string* localization_varname) {
  if (localization_varname != nullptr) {
    
  } else {
    
  }
  _impl_.localization_varname_.SetAllocated(localization_varname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.localization_varname_.IsDefault()) {
    _impl_.localization_varname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamPtz.AdjustParameters.localization_varname)
}

// string waypoint_id = 5;
inline void SpotCamPtz_AdjustParameters::clear_waypoint_id() {
  _impl_.waypoint_id_.ClearToEmpty();
}
inline const std::string& SpotCamPtz_AdjustParameters::waypoint_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamPtz.AdjustParameters.waypoint_id)
  return _internal_waypoint_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpotCamPtz_AdjustParameters::set_waypoint_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.waypoint_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SpotCamPtz.AdjustParameters.waypoint_id)
}
inline std::string* SpotCamPtz_AdjustParameters::mutable_waypoint_id() {
  std::string* _s = _internal_mutable_waypoint_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamPtz.AdjustParameters.waypoint_id)
  return _s;
}
inline const std::string& SpotCamPtz_AdjustParameters::_internal_waypoint_id() const {
  return _impl_.waypoint_id_.Get();
}
inline void SpotCamPtz_AdjustParameters::_internal_set_waypoint_id(const std::string& value) {
  
  _impl_.waypoint_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotCamPtz_AdjustParameters::_internal_mutable_waypoint_id() {
  
  return _impl_.waypoint_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SpotCamPtz_AdjustParameters::release_waypoint_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamPtz.AdjustParameters.waypoint_id)
  return _impl_.waypoint_id_.Release();
}
inline void SpotCamPtz_AdjustParameters::set_allocated_waypoint_id(std::string* waypoint_id) {
  if (waypoint_id != nullptr) {
    
  } else {
    
  }
  _impl_.waypoint_id_.SetAllocated(waypoint_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.waypoint_id_.IsDefault()) {
    _impl_.waypoint_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamPtz.AdjustParameters.waypoint_id)
}

// .bosdyn.api.SE3Pose waypoint_tform_body = 6;
inline bool SpotCamPtz_AdjustParameters::_internal_has_waypoint_tform_body() const {
  return this != internal_default_instance() && _impl_.waypoint_tform_body_ != nullptr;
}
inline bool SpotCamPtz_AdjustParameters::has_waypoint_tform_body() const {
  return _internal_has_waypoint_tform_body();
}
inline const ::bosdyn::api::SE3Pose& SpotCamPtz_AdjustParameters::_internal_waypoint_tform_body() const {
  const ::bosdyn::api::SE3Pose* p = _impl_.waypoint_tform_body_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Pose&>(
      ::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& SpotCamPtz_AdjustParameters::waypoint_tform_body() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamPtz.AdjustParameters.waypoint_tform_body)
  return _internal_waypoint_tform_body();
}
inline void SpotCamPtz_AdjustParameters::unsafe_arena_set_allocated_waypoint_tform_body(
    ::bosdyn::api::SE3Pose* waypoint_tform_body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.waypoint_tform_body_);
  }
  _impl_.waypoint_tform_body_ = waypoint_tform_body;
  if (waypoint_tform_body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.SpotCamPtz.AdjustParameters.waypoint_tform_body)
}
inline ::bosdyn::api::SE3Pose* SpotCamPtz_AdjustParameters::release_waypoint_tform_body() {
  
  ::bosdyn::api::SE3Pose* temp = _impl_.waypoint_tform_body_;
  _impl_.waypoint_tform_body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Pose* SpotCamPtz_AdjustParameters::unsafe_arena_release_waypoint_tform_body() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamPtz.AdjustParameters.waypoint_tform_body)
  
  ::bosdyn::api::SE3Pose* temp = _impl_.waypoint_tform_body_;
  _impl_.waypoint_tform_body_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* SpotCamPtz_AdjustParameters::_internal_mutable_waypoint_tform_body() {
  
  if (_impl_.waypoint_tform_body_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArenaForAllocation());
    _impl_.waypoint_tform_body_ = p;
  }
  return _impl_.waypoint_tform_body_;
}
inline ::bosdyn::api::SE3Pose* SpotCamPtz_AdjustParameters::mutable_waypoint_tform_body() {
  ::bosdyn::api::SE3Pose* _msg = _internal_mutable_waypoint_tform_body();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamPtz.AdjustParameters.waypoint_tform_body)
  return _msg;
}
inline void SpotCamPtz_AdjustParameters::set_allocated_waypoint_tform_body(::bosdyn::api::SE3Pose* waypoint_tform_body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.waypoint_tform_body_);
  }
  if (waypoint_tform_body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(waypoint_tform_body));
    if (message_arena != submessage_arena) {
      waypoint_tform_body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, waypoint_tform_body, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.waypoint_tform_body_ = waypoint_tform_body;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamPtz.AdjustParameters.waypoint_tform_body)
}

// -------------------------------------------------------------------

// SpotCamPtz

// string service_name = 1;
inline void SpotCamPtz::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& SpotCamPtz::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamPtz.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpotCamPtz::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SpotCamPtz.service_name)
}
inline std::string* SpotCamPtz::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamPtz.service_name)
  return _s;
}
inline const std::string& SpotCamPtz::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void SpotCamPtz::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotCamPtz::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SpotCamPtz::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamPtz.service_name)
  return _impl_.service_name_.Release();
}
inline void SpotCamPtz::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamPtz.service_name)
}

// string host = 2;
inline void SpotCamPtz::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& SpotCamPtz::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamPtz.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpotCamPtz::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SpotCamPtz.host)
}
inline std::string* SpotCamPtz::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamPtz.host)
  return _s;
}
inline const std::string& SpotCamPtz::_internal_host() const {
  return _impl_.host_.Get();
}
inline void SpotCamPtz::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotCamPtz::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* SpotCamPtz::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamPtz.host)
  return _impl_.host_.Release();
}
inline void SpotCamPtz::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamPtz.host)
}

// .bosdyn.api.spot_cam.PtzPosition ptz_position = 3;
inline bool SpotCamPtz::_internal_has_ptz_position() const {
  return this != internal_default_instance() && _impl_.ptz_position_ != nullptr;
}
inline bool SpotCamPtz::has_ptz_position() const {
  return _internal_has_ptz_position();
}
inline const ::bosdyn::api::spot_cam::PtzPosition& SpotCamPtz::_internal_ptz_position() const {
  const ::bosdyn::api::spot_cam::PtzPosition* p = _impl_.ptz_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot_cam::PtzPosition&>(
      ::bosdyn::api::spot_cam::_PtzPosition_default_instance_);
}
inline const ::bosdyn::api::spot_cam::PtzPosition& SpotCamPtz::ptz_position() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamPtz.ptz_position)
  return _internal_ptz_position();
}
inline void SpotCamPtz::unsafe_arena_set_allocated_ptz_position(
    ::bosdyn::api::spot_cam::PtzPosition* ptz_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ptz_position_);
  }
  _impl_.ptz_position_ = ptz_position;
  if (ptz_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.SpotCamPtz.ptz_position)
}
inline ::bosdyn::api::spot_cam::PtzPosition* SpotCamPtz::release_ptz_position() {
  
  ::bosdyn::api::spot_cam::PtzPosition* temp = _impl_.ptz_position_;
  _impl_.ptz_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzPosition* SpotCamPtz::unsafe_arena_release_ptz_position() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamPtz.ptz_position)
  
  ::bosdyn::api::spot_cam::PtzPosition* temp = _impl_.ptz_position_;
  _impl_.ptz_position_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzPosition* SpotCamPtz::_internal_mutable_ptz_position() {
  
  if (_impl_.ptz_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::PtzPosition>(GetArenaForAllocation());
    _impl_.ptz_position_ = p;
  }
  return _impl_.ptz_position_;
}
inline ::bosdyn::api::spot_cam::PtzPosition* SpotCamPtz::mutable_ptz_position() {
  ::bosdyn::api::spot_cam::PtzPosition* _msg = _internal_mutable_ptz_position();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamPtz.ptz_position)
  return _msg;
}
inline void SpotCamPtz::set_allocated_ptz_position(::bosdyn::api::spot_cam::PtzPosition* ptz_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ptz_position_);
  }
  if (ptz_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ptz_position));
    if (message_arena != submessage_arena) {
      ptz_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ptz_position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ptz_position_ = ptz_position;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamPtz.ptz_position)
}

// .bosdyn.api.mission.SpotCamPtz.AdjustParameters adjust_parameters = 4;
inline bool SpotCamPtz::_internal_has_adjust_parameters() const {
  return this != internal_default_instance() && _impl_.adjust_parameters_ != nullptr;
}
inline bool SpotCamPtz::has_adjust_parameters() const {
  return _internal_has_adjust_parameters();
}
inline void SpotCamPtz::clear_adjust_parameters() {
  if (GetArenaForAllocation() == nullptr && _impl_.adjust_parameters_ != nullptr) {
    delete _impl_.adjust_parameters_;
  }
  _impl_.adjust_parameters_ = nullptr;
}
inline const ::bosdyn::api::mission::SpotCamPtz_AdjustParameters& SpotCamPtz::_internal_adjust_parameters() const {
  const ::bosdyn::api::mission::SpotCamPtz_AdjustParameters* p = _impl_.adjust_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::SpotCamPtz_AdjustParameters&>(
      ::bosdyn::api::mission::_SpotCamPtz_AdjustParameters_default_instance_);
}
inline const ::bosdyn::api::mission::SpotCamPtz_AdjustParameters& SpotCamPtz::adjust_parameters() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamPtz.adjust_parameters)
  return _internal_adjust_parameters();
}
inline void SpotCamPtz::unsafe_arena_set_allocated_adjust_parameters(
    ::bosdyn::api::mission::SpotCamPtz_AdjustParameters* adjust_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.adjust_parameters_);
  }
  _impl_.adjust_parameters_ = adjust_parameters;
  if (adjust_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.SpotCamPtz.adjust_parameters)
}
inline ::bosdyn::api::mission::SpotCamPtz_AdjustParameters* SpotCamPtz::release_adjust_parameters() {
  
  ::bosdyn::api::mission::SpotCamPtz_AdjustParameters* temp = _impl_.adjust_parameters_;
  _impl_.adjust_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::SpotCamPtz_AdjustParameters* SpotCamPtz::unsafe_arena_release_adjust_parameters() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamPtz.adjust_parameters)
  
  ::bosdyn::api::mission::SpotCamPtz_AdjustParameters* temp = _impl_.adjust_parameters_;
  _impl_.adjust_parameters_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::SpotCamPtz_AdjustParameters* SpotCamPtz::_internal_mutable_adjust_parameters() {
  
  if (_impl_.adjust_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::SpotCamPtz_AdjustParameters>(GetArenaForAllocation());
    _impl_.adjust_parameters_ = p;
  }
  return _impl_.adjust_parameters_;
}
inline ::bosdyn::api::mission::SpotCamPtz_AdjustParameters* SpotCamPtz::mutable_adjust_parameters() {
  ::bosdyn::api::mission::SpotCamPtz_AdjustParameters* _msg = _internal_mutable_adjust_parameters();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamPtz.adjust_parameters)
  return _msg;
}
inline void SpotCamPtz::set_allocated_adjust_parameters(::bosdyn::api::mission::SpotCamPtz_AdjustParameters* adjust_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.adjust_parameters_;
  }
  if (adjust_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(adjust_parameters);
    if (message_arena != submessage_arena) {
      adjust_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adjust_parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.adjust_parameters_ = adjust_parameters;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamPtz.adjust_parameters)
}

// -------------------------------------------------------------------

// SpotCamStoreMedia

// string service_name = 1;
inline void SpotCamStoreMedia::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& SpotCamStoreMedia::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamStoreMedia.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpotCamStoreMedia::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SpotCamStoreMedia.service_name)
}
inline std::string* SpotCamStoreMedia::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamStoreMedia.service_name)
  return _s;
}
inline const std::string& SpotCamStoreMedia::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void SpotCamStoreMedia::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotCamStoreMedia::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SpotCamStoreMedia::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamStoreMedia.service_name)
  return _impl_.service_name_.Release();
}
inline void SpotCamStoreMedia::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamStoreMedia.service_name)
}

// string host = 2;
inline void SpotCamStoreMedia::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& SpotCamStoreMedia::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamStoreMedia.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpotCamStoreMedia::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SpotCamStoreMedia.host)
}
inline std::string* SpotCamStoreMedia::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamStoreMedia.host)
  return _s;
}
inline const std::string& SpotCamStoreMedia::_internal_host() const {
  return _impl_.host_.Get();
}
inline void SpotCamStoreMedia::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotCamStoreMedia::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* SpotCamStoreMedia::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamStoreMedia.host)
  return _impl_.host_.Release();
}
inline void SpotCamStoreMedia::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamStoreMedia.host)
}

// .bosdyn.api.spot_cam.Camera camera = 3;
inline bool SpotCamStoreMedia::_internal_has_camera() const {
  return this != internal_default_instance() && _impl_.camera_ != nullptr;
}
inline bool SpotCamStoreMedia::has_camera() const {
  return _internal_has_camera();
}
inline const ::bosdyn::api::spot_cam::Camera& SpotCamStoreMedia::_internal_camera() const {
  const ::bosdyn::api::spot_cam::Camera* p = _impl_.camera_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot_cam::Camera&>(
      ::bosdyn::api::spot_cam::_Camera_default_instance_);
}
inline const ::bosdyn::api::spot_cam::Camera& SpotCamStoreMedia::camera() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamStoreMedia.camera)
  return _internal_camera();
}
inline void SpotCamStoreMedia::unsafe_arena_set_allocated_camera(
    ::bosdyn::api::spot_cam::Camera* camera) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_);
  }
  _impl_.camera_ = camera;
  if (camera) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.SpotCamStoreMedia.camera)
}
inline ::bosdyn::api::spot_cam::Camera* SpotCamStoreMedia::release_camera() {
  
  ::bosdyn::api::spot_cam::Camera* temp = _impl_.camera_;
  _impl_.camera_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot_cam::Camera* SpotCamStoreMedia::unsafe_arena_release_camera() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamStoreMedia.camera)
  
  ::bosdyn::api::spot_cam::Camera* temp = _impl_.camera_;
  _impl_.camera_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::Camera* SpotCamStoreMedia::_internal_mutable_camera() {
  
  if (_impl_.camera_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::Camera>(GetArenaForAllocation());
    _impl_.camera_ = p;
  }
  return _impl_.camera_;
}
inline ::bosdyn::api::spot_cam::Camera* SpotCamStoreMedia::mutable_camera() {
  ::bosdyn::api::spot_cam::Camera* _msg = _internal_mutable_camera();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamStoreMedia.camera)
  return _msg;
}
inline void SpotCamStoreMedia::set_allocated_camera(::bosdyn::api::spot_cam::Camera* camera) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_);
  }
  if (camera) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera));
    if (message_arena != submessage_arena) {
      camera = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_ = camera;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamStoreMedia.camera)
}

// .bosdyn.api.spot_cam.Logpoint.RecordType type = 4;
inline void SpotCamStoreMedia::clear_type() {
  _impl_.type_ = 0;
}
inline ::bosdyn::api::spot_cam::Logpoint_RecordType SpotCamStoreMedia::_internal_type() const {
  return static_cast< ::bosdyn::api::spot_cam::Logpoint_RecordType >(_impl_.type_);
}
inline ::bosdyn::api::spot_cam::Logpoint_RecordType SpotCamStoreMedia::type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamStoreMedia.type)
  return _internal_type();
}
inline void SpotCamStoreMedia::_internal_set_type(::bosdyn::api::spot_cam::Logpoint_RecordType value) {
  
  _impl_.type_ = value;
}
inline void SpotCamStoreMedia::set_type(::bosdyn::api::spot_cam::Logpoint_RecordType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SpotCamStoreMedia.type)
}

// string tag = 5;
inline void SpotCamStoreMedia::clear_tag() {
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& SpotCamStoreMedia::tag() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamStoreMedia.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpotCamStoreMedia::set_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SpotCamStoreMedia.tag)
}
inline std::string* SpotCamStoreMedia::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamStoreMedia.tag)
  return _s;
}
inline const std::string& SpotCamStoreMedia::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void SpotCamStoreMedia::_internal_set_tag(const std::string& value) {
  
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotCamStoreMedia::_internal_mutable_tag() {
  
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* SpotCamStoreMedia::release_tag() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamStoreMedia.tag)
  return _impl_.tag_.Release();
}
inline void SpotCamStoreMedia::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamStoreMedia.tag)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SpotCamLed

// string service_name = 1;
inline void SpotCamLed::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& SpotCamLed::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamLed.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpotCamLed::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SpotCamLed.service_name)
}
inline std::string* SpotCamLed::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamLed.service_name)
  return _s;
}
inline const std::string& SpotCamLed::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void SpotCamLed::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotCamLed::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SpotCamLed::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamLed.service_name)
  return _impl_.service_name_.Release();
}
inline void SpotCamLed::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamLed.service_name)
}

// string host = 2;
inline void SpotCamLed::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& SpotCamLed::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamLed.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpotCamLed::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SpotCamLed.host)
}
inline std::string* SpotCamLed::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamLed.host)
  return _s;
}
inline const std::string& SpotCamLed::_internal_host() const {
  return _impl_.host_.Get();
}
inline void SpotCamLed::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotCamLed::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* SpotCamLed::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamLed.host)
  return _impl_.host_.Release();
}
inline void SpotCamLed::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamLed.host)
}

// map<int32, float> brightnesses = 3;
inline int SpotCamLed::_internal_brightnesses_size() const {
  return _impl_.brightnesses_.size();
}
inline int SpotCamLed::brightnesses_size() const {
  return _internal_brightnesses_size();
}
inline void SpotCamLed::clear_brightnesses() {
  _impl_.brightnesses_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, float >&
SpotCamLed::_internal_brightnesses() const {
  return _impl_.brightnesses_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, float >&
SpotCamLed::brightnesses() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.mission.SpotCamLed.brightnesses)
  return _internal_brightnesses();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, float >*
SpotCamLed::_internal_mutable_brightnesses() {
  return _impl_.brightnesses_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, float >*
SpotCamLed::mutable_brightnesses() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.mission.SpotCamLed.brightnesses)
  return _internal_mutable_brightnesses();
}

// -------------------------------------------------------------------

// SpotCamResetAutofocus

// string service_name = 1;
inline void SpotCamResetAutofocus::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& SpotCamResetAutofocus::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamResetAutofocus.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpotCamResetAutofocus::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SpotCamResetAutofocus.service_name)
}
inline std::string* SpotCamResetAutofocus::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamResetAutofocus.service_name)
  return _s;
}
inline const std::string& SpotCamResetAutofocus::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void SpotCamResetAutofocus::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotCamResetAutofocus::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SpotCamResetAutofocus::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamResetAutofocus.service_name)
  return _impl_.service_name_.Release();
}
inline void SpotCamResetAutofocus::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamResetAutofocus.service_name)
}

// string host = 2;
inline void SpotCamResetAutofocus::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& SpotCamResetAutofocus::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamResetAutofocus.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpotCamResetAutofocus::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SpotCamResetAutofocus.host)
}
inline std::string* SpotCamResetAutofocus::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamResetAutofocus.host)
  return _s;
}
inline const std::string& SpotCamResetAutofocus::_internal_host() const {
  return _impl_.host_.Get();
}
inline void SpotCamResetAutofocus::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotCamResetAutofocus::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* SpotCamResetAutofocus::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamResetAutofocus.host)
  return _impl_.host_.Release();
}
inline void SpotCamResetAutofocus::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamResetAutofocus.host)
}

// -------------------------------------------------------------------

// Dock

// string service_name = 1;
inline void Dock::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& Dock::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Dock.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dock::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Dock.service_name)
}
inline std::string* Dock::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Dock.service_name)
  return _s;
}
inline const std::string& Dock::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void Dock::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Dock::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Dock::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Dock.service_name)
  return _impl_.service_name_.Release();
}
inline void Dock::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Dock.service_name)
}

// string host = 2;
inline void Dock::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& Dock::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Dock.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dock::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Dock.host)
}
inline std::string* Dock::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Dock.host)
  return _s;
}
inline const std::string& Dock::_internal_host() const {
  return _impl_.host_.Get();
}
inline void Dock::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* Dock::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* Dock::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Dock.host)
  return _impl_.host_.Release();
}
inline void Dock::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Dock.host)
}

// uint32 docking_station_id = 3;
inline void Dock::clear_docking_station_id() {
  _impl_.docking_station_id_ = 0u;
}
inline uint32_t Dock::_internal_docking_station_id() const {
  return _impl_.docking_station_id_;
}
inline uint32_t Dock::docking_station_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Dock.docking_station_id)
  return _internal_docking_station_id();
}
inline void Dock::_internal_set_docking_station_id(uint32_t value) {
  
  _impl_.docking_station_id_ = value;
}
inline void Dock::set_docking_station_id(uint32_t value) {
  _internal_set_docking_station_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Dock.docking_station_id)
}

// .bosdyn.api.mission.Node child = 4 [deprecated = true];
inline bool Dock::_internal_has_child() const {
  return this != internal_default_instance() && _impl_.child_ != nullptr;
}
inline bool Dock::has_child() const {
  return _internal_has_child();
}
inline void Dock::clear_child() {
  if (GetArenaForAllocation() == nullptr && _impl_.child_ != nullptr) {
    delete _impl_.child_;
  }
  _impl_.child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& Dock::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Node&>(
      ::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& Dock::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Dock.child)
  return _internal_child();
}
inline void Dock::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Dock.child)
}
inline ::bosdyn::api::mission::Node* Dock::release_child() {
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Node* Dock::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Dock.child)
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* Dock::_internal_mutable_child() {
  
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArenaForAllocation());
    _impl_.child_ = p;
  }
  return _impl_.child_;
}
inline ::bosdyn::api::mission::Node* Dock::mutable_child() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Dock.child)
  return _msg;
}
inline void Dock::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Dock.child)
}

// string command_status_name = 5 [deprecated = true];
inline void Dock::clear_command_status_name() {
  _impl_.command_status_name_.ClearToEmpty();
}
inline const std::string& Dock::command_status_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Dock.command_status_name)
  return _internal_command_status_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dock::set_command_status_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.command_status_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Dock.command_status_name)
}
inline std::string* Dock::mutable_command_status_name() {
  std::string* _s = _internal_mutable_command_status_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Dock.command_status_name)
  return _s;
}
inline const std::string& Dock::_internal_command_status_name() const {
  return _impl_.command_status_name_.Get();
}
inline void Dock::_internal_set_command_status_name(const std::string& value) {
  
  _impl_.command_status_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Dock::_internal_mutable_command_status_name() {
  
  return _impl_.command_status_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Dock::release_command_status_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Dock.command_status_name)
  return _impl_.command_status_name_.Release();
}
inline void Dock::set_allocated_command_status_name(std::string* command_status_name) {
  if (command_status_name != nullptr) {
    
  } else {
    
  }
  _impl_.command_status_name_.SetAllocated(command_status_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.command_status_name_.IsDefault()) {
    _impl_.command_status_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Dock.command_status_name)
}

// string feedback_status_name = 6 [deprecated = true];
inline void Dock::clear_feedback_status_name() {
  _impl_.feedback_status_name_.ClearToEmpty();
}
inline const std::string& Dock::feedback_status_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Dock.feedback_status_name)
  return _internal_feedback_status_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dock::set_feedback_status_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.feedback_status_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Dock.feedback_status_name)
}
inline std::string* Dock::mutable_feedback_status_name() {
  std::string* _s = _internal_mutable_feedback_status_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Dock.feedback_status_name)
  return _s;
}
inline const std::string& Dock::_internal_feedback_status_name() const {
  return _impl_.feedback_status_name_.Get();
}
inline void Dock::_internal_set_feedback_status_name(const std::string& value) {
  
  _impl_.feedback_status_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Dock::_internal_mutable_feedback_status_name() {
  
  return _impl_.feedback_status_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Dock::release_feedback_status_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Dock.feedback_status_name)
  return _impl_.feedback_status_name_.Release();
}
inline void Dock::set_allocated_feedback_status_name(std::string* feedback_status_name) {
  if (feedback_status_name != nullptr) {
    
  } else {
    
  }
  _impl_.feedback_status_name_.SetAllocated(feedback_status_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.feedback_status_name_.IsDefault()) {
    _impl_.feedback_status_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Dock.feedback_status_name)
}

// .bosdyn.api.docking.PrepPoseBehavior prep_pose_behavior = 7;
inline void Dock::clear_prep_pose_behavior() {
  _impl_.prep_pose_behavior_ = 0;
}
inline ::bosdyn::api::docking::PrepPoseBehavior Dock::_internal_prep_pose_behavior() const {
  return static_cast< ::bosdyn::api::docking::PrepPoseBehavior >(_impl_.prep_pose_behavior_);
}
inline ::bosdyn::api::docking::PrepPoseBehavior Dock::prep_pose_behavior() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Dock.prep_pose_behavior)
  return _internal_prep_pose_behavior();
}
inline void Dock::_internal_set_prep_pose_behavior(::bosdyn::api::docking::PrepPoseBehavior value) {
  
  _impl_.prep_pose_behavior_ = value;
}
inline void Dock::set_prep_pose_behavior(::bosdyn::api::docking::PrepPoseBehavior value) {
  _internal_set_prep_pose_behavior(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Dock.prep_pose_behavior)
}

// string docking_command_feedback_response_blackboard_key = 8;
inline void Dock::clear_docking_command_feedback_response_blackboard_key() {
  _impl_.docking_command_feedback_response_blackboard_key_.ClearToEmpty();
}
inline const std::string& Dock::docking_command_feedback_response_blackboard_key() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Dock.docking_command_feedback_response_blackboard_key)
  return _internal_docking_command_feedback_response_blackboard_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dock::set_docking_command_feedback_response_blackboard_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.docking_command_feedback_response_blackboard_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Dock.docking_command_feedback_response_blackboard_key)
}
inline std::string* Dock::mutable_docking_command_feedback_response_blackboard_key() {
  std::string* _s = _internal_mutable_docking_command_feedback_response_blackboard_key();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Dock.docking_command_feedback_response_blackboard_key)
  return _s;
}
inline const std::string& Dock::_internal_docking_command_feedback_response_blackboard_key() const {
  return _impl_.docking_command_feedback_response_blackboard_key_.Get();
}
inline void Dock::_internal_set_docking_command_feedback_response_blackboard_key(const std::string& value) {
  
  _impl_.docking_command_feedback_response_blackboard_key_.Set(value, GetArenaForAllocation());
}
inline std::string* Dock::_internal_mutable_docking_command_feedback_response_blackboard_key() {
  
  return _impl_.docking_command_feedback_response_blackboard_key_.Mutable(GetArenaForAllocation());
}
inline std::string* Dock::release_docking_command_feedback_response_blackboard_key() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Dock.docking_command_feedback_response_blackboard_key)
  return _impl_.docking_command_feedback_response_blackboard_key_.Release();
}
inline void Dock::set_allocated_docking_command_feedback_response_blackboard_key(std::string* docking_command_feedback_response_blackboard_key) {
  if (docking_command_feedback_response_blackboard_key != nullptr) {
    
  } else {
    
  }
  _impl_.docking_command_feedback_response_blackboard_key_.SetAllocated(docking_command_feedback_response_blackboard_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.docking_command_feedback_response_blackboard_key_.IsDefault()) {
    _impl_.docking_command_feedback_response_blackboard_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Dock.docking_command_feedback_response_blackboard_key)
}

// string docking_command_response_blackboard_key = 9;
inline void Dock::clear_docking_command_response_blackboard_key() {
  _impl_.docking_command_response_blackboard_key_.ClearToEmpty();
}
inline const std::string& Dock::docking_command_response_blackboard_key() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Dock.docking_command_response_blackboard_key)
  return _internal_docking_command_response_blackboard_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dock::set_docking_command_response_blackboard_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.docking_command_response_blackboard_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Dock.docking_command_response_blackboard_key)
}
inline std::string* Dock::mutable_docking_command_response_blackboard_key() {
  std::string* _s = _internal_mutable_docking_command_response_blackboard_key();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Dock.docking_command_response_blackboard_key)
  return _s;
}
inline const std::string& Dock::_internal_docking_command_response_blackboard_key() const {
  return _impl_.docking_command_response_blackboard_key_.Get();
}
inline void Dock::_internal_set_docking_command_response_blackboard_key(const std::string& value) {
  
  _impl_.docking_command_response_blackboard_key_.Set(value, GetArenaForAllocation());
}
inline std::string* Dock::_internal_mutable_docking_command_response_blackboard_key() {
  
  return _impl_.docking_command_response_blackboard_key_.Mutable(GetArenaForAllocation());
}
inline std::string* Dock::release_docking_command_response_blackboard_key() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Dock.docking_command_response_blackboard_key)
  return _impl_.docking_command_response_blackboard_key_.Release();
}
inline void Dock::set_allocated_docking_command_response_blackboard_key(std::string* docking_command_response_blackboard_key) {
  if (docking_command_response_blackboard_key != nullptr) {
    
  } else {
    
  }
  _impl_.docking_command_response_blackboard_key_.SetAllocated(docking_command_response_blackboard_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.docking_command_response_blackboard_key_.IsDefault()) {
    _impl_.docking_command_response_blackboard_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Dock.docking_command_response_blackboard_key)
}

// -------------------------------------------------------------------

// StoreMetadata

// string service_name = 1;
inline void StoreMetadata::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& StoreMetadata::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.StoreMetadata.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreMetadata::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.StoreMetadata.service_name)
}
inline std::string* StoreMetadata::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.StoreMetadata.service_name)
  return _s;
}
inline const std::string& StoreMetadata::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void StoreMetadata::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreMetadata::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* StoreMetadata::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.StoreMetadata.service_name)
  return _impl_.service_name_.Release();
}
inline void StoreMetadata::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.StoreMetadata.service_name)
}

// string host = 2;
inline void StoreMetadata::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& StoreMetadata::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.StoreMetadata.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreMetadata::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.StoreMetadata.host)
}
inline std::string* StoreMetadata::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.StoreMetadata.host)
  return _s;
}
inline const std::string& StoreMetadata::_internal_host() const {
  return _impl_.host_.Get();
}
inline void StoreMetadata::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreMetadata::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* StoreMetadata::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.StoreMetadata.host)
  return _impl_.host_.Release();
}
inline void StoreMetadata::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.StoreMetadata.host)
}

// string acquire_data_request_name = 3;
inline void StoreMetadata::clear_acquire_data_request_name() {
  _impl_.acquire_data_request_name_.ClearToEmpty();
}
inline const std::string& StoreMetadata::acquire_data_request_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.StoreMetadata.acquire_data_request_name)
  return _internal_acquire_data_request_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreMetadata::set_acquire_data_request_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.acquire_data_request_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.StoreMetadata.acquire_data_request_name)
}
inline std::string* StoreMetadata::mutable_acquire_data_request_name() {
  std::string* _s = _internal_mutable_acquire_data_request_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.StoreMetadata.acquire_data_request_name)
  return _s;
}
inline const std::string& StoreMetadata::_internal_acquire_data_request_name() const {
  return _impl_.acquire_data_request_name_.Get();
}
inline void StoreMetadata::_internal_set_acquire_data_request_name(const std::string& value) {
  
  _impl_.acquire_data_request_name_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreMetadata::_internal_mutable_acquire_data_request_name() {
  
  return _impl_.acquire_data_request_name_.Mutable(GetArenaForAllocation());
}
inline std::string* StoreMetadata::release_acquire_data_request_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.StoreMetadata.acquire_data_request_name)
  return _impl_.acquire_data_request_name_.Release();
}
inline void StoreMetadata::set_allocated_acquire_data_request_name(std::string* acquire_data_request_name) {
  if (acquire_data_request_name != nullptr) {
    
  } else {
    
  }
  _impl_.acquire_data_request_name_.SetAllocated(acquire_data_request_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.acquire_data_request_name_.IsDefault()) {
    _impl_.acquire_data_request_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.StoreMetadata.acquire_data_request_name)
}

// string metadata_name = 5;
inline void StoreMetadata::clear_metadata_name() {
  _impl_.metadata_name_.ClearToEmpty();
}
inline const std::string& StoreMetadata::metadata_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.StoreMetadata.metadata_name)
  return _internal_metadata_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreMetadata::set_metadata_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metadata_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.StoreMetadata.metadata_name)
}
inline std::string* StoreMetadata::mutable_metadata_name() {
  std::string* _s = _internal_mutable_metadata_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.StoreMetadata.metadata_name)
  return _s;
}
inline const std::string& StoreMetadata::_internal_metadata_name() const {
  return _impl_.metadata_name_.Get();
}
inline void StoreMetadata::_internal_set_metadata_name(const std::string& value) {
  
  _impl_.metadata_name_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreMetadata::_internal_mutable_metadata_name() {
  
  return _impl_.metadata_name_.Mutable(GetArenaForAllocation());
}
inline std::string* StoreMetadata::release_metadata_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.StoreMetadata.metadata_name)
  return _impl_.metadata_name_.Release();
}
inline void StoreMetadata::set_allocated_metadata_name(std::string* metadata_name) {
  if (metadata_name != nullptr) {
    
  } else {
    
  }
  _impl_.metadata_name_.SetAllocated(metadata_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_name_.IsDefault()) {
    _impl_.metadata_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.StoreMetadata.metadata_name)
}

// string metadata_channel = 6;
inline void StoreMetadata::clear_metadata_channel() {
  _impl_.metadata_channel_.ClearToEmpty();
}
inline const std::string& StoreMetadata::metadata_channel() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.StoreMetadata.metadata_channel)
  return _internal_metadata_channel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreMetadata::set_metadata_channel(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metadata_channel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.StoreMetadata.metadata_channel)
}
inline std::string* StoreMetadata::mutable_metadata_channel() {
  std::string* _s = _internal_mutable_metadata_channel();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.StoreMetadata.metadata_channel)
  return _s;
}
inline const std::string& StoreMetadata::_internal_metadata_channel() const {
  return _impl_.metadata_channel_.Get();
}
inline void StoreMetadata::_internal_set_metadata_channel(const std::string& value) {
  
  _impl_.metadata_channel_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreMetadata::_internal_mutable_metadata_channel() {
  
  return _impl_.metadata_channel_.Mutable(GetArenaForAllocation());
}
inline std::string* StoreMetadata::release_metadata_channel() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.StoreMetadata.metadata_channel)
  return _impl_.metadata_channel_.Release();
}
inline void StoreMetadata::set_allocated_metadata_channel(std::string* metadata_channel) {
  if (metadata_channel != nullptr) {
    
  } else {
    
  }
  _impl_.metadata_channel_.SetAllocated(metadata_channel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_channel_.IsDefault()) {
    _impl_.metadata_channel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.StoreMetadata.metadata_channel)
}

// -------------------------------------------------------------------

// DataAcquisition

// string service_name = 1;
inline void DataAcquisition::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& DataAcquisition::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.DataAcquisition.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataAcquisition::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.DataAcquisition.service_name)
}
inline std::string* DataAcquisition::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.DataAcquisition.service_name)
  return _s;
}
inline const std::string& DataAcquisition::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void DataAcquisition::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataAcquisition::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataAcquisition::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.DataAcquisition.service_name)
  return _impl_.service_name_.Release();
}
inline void DataAcquisition::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.DataAcquisition.service_name)
}

// string host = 2;
inline void DataAcquisition::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& DataAcquisition::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.DataAcquisition.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataAcquisition::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.DataAcquisition.host)
}
inline std::string* DataAcquisition::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.DataAcquisition.host)
  return _s;
}
inline const std::string& DataAcquisition::_internal_host() const {
  return _impl_.host_.Get();
}
inline void DataAcquisition::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* DataAcquisition::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* DataAcquisition::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.DataAcquisition.host)
  return _impl_.host_.Release();
}
inline void DataAcquisition::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.DataAcquisition.host)
}

// .bosdyn.api.AcquireDataRequest request = 3;
inline bool DataAcquisition::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool DataAcquisition::has_request() const {
  return _internal_has_request();
}
inline const ::bosdyn::api::AcquireDataRequest& DataAcquisition::_internal_request() const {
  const ::bosdyn::api::AcquireDataRequest* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::AcquireDataRequest&>(
      ::bosdyn::api::_AcquireDataRequest_default_instance_);
}
inline const ::bosdyn::api::AcquireDataRequest& DataAcquisition::request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.DataAcquisition.request)
  return _internal_request();
}
inline void DataAcquisition::unsafe_arena_set_allocated_request(
    ::bosdyn::api::AcquireDataRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.DataAcquisition.request)
}
inline ::bosdyn::api::AcquireDataRequest* DataAcquisition::release_request() {
  
  ::bosdyn::api::AcquireDataRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::AcquireDataRequest* DataAcquisition::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.DataAcquisition.request)
  
  ::bosdyn::api::AcquireDataRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::AcquireDataRequest* DataAcquisition::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::AcquireDataRequest>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::bosdyn::api::AcquireDataRequest* DataAcquisition::mutable_request() {
  ::bosdyn::api::AcquireDataRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.DataAcquisition.request)
  return _msg;
}
inline void DataAcquisition::set_allocated_request(::bosdyn::api::AcquireDataRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.DataAcquisition.request)
}

// .bosdyn.api.mission.DataAcquisition.CompletionBehavior completion_behavior = 4;
inline void DataAcquisition::clear_completion_behavior() {
  _impl_.completion_behavior_ = 0;
}
inline ::bosdyn::api::mission::DataAcquisition_CompletionBehavior DataAcquisition::_internal_completion_behavior() const {
  return static_cast< ::bosdyn::api::mission::DataAcquisition_CompletionBehavior >(_impl_.completion_behavior_);
}
inline ::bosdyn::api::mission::DataAcquisition_CompletionBehavior DataAcquisition::completion_behavior() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.DataAcquisition.completion_behavior)
  return _internal_completion_behavior();
}
inline void DataAcquisition::_internal_set_completion_behavior(::bosdyn::api::mission::DataAcquisition_CompletionBehavior value) {
  
  _impl_.completion_behavior_ = value;
}
inline void DataAcquisition::set_completion_behavior(::bosdyn::api::mission::DataAcquisition_CompletionBehavior value) {
  _internal_set_completion_behavior(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.DataAcquisition.completion_behavior)
}

// string group_name_format = 5;
inline void DataAcquisition::clear_group_name_format() {
  _impl_.group_name_format_.ClearToEmpty();
}
inline const std::string& DataAcquisition::group_name_format() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.DataAcquisition.group_name_format)
  return _internal_group_name_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataAcquisition::set_group_name_format(ArgT0&& arg0, ArgT... args) {
 
 _impl_.group_name_format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.DataAcquisition.group_name_format)
}
inline std::string* DataAcquisition::mutable_group_name_format() {
  std::string* _s = _internal_mutable_group_name_format();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.DataAcquisition.group_name_format)
  return _s;
}
inline const std::string& DataAcquisition::_internal_group_name_format() const {
  return _impl_.group_name_format_.Get();
}
inline void DataAcquisition::_internal_set_group_name_format(const std::string& value) {
  
  _impl_.group_name_format_.Set(value, GetArenaForAllocation());
}
inline std::string* DataAcquisition::_internal_mutable_group_name_format() {
  
  return _impl_.group_name_format_.Mutable(GetArenaForAllocation());
}
inline std::string* DataAcquisition::release_group_name_format() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.DataAcquisition.group_name_format)
  return _impl_.group_name_format_.Release();
}
inline void DataAcquisition::set_allocated_group_name_format(std::string* group_name_format) {
  if (group_name_format != nullptr) {
    
  } else {
    
  }
  _impl_.group_name_format_.SetAllocated(group_name_format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_name_format_.IsDefault()) {
    _impl_.group_name_format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.DataAcquisition.group_name_format)
}

// string request_name_in_blackboard = 6;
inline void DataAcquisition::clear_request_name_in_blackboard() {
  _impl_.request_name_in_blackboard_.ClearToEmpty();
}
inline const std::string& DataAcquisition::request_name_in_blackboard() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.DataAcquisition.request_name_in_blackboard)
  return _internal_request_name_in_blackboard();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataAcquisition::set_request_name_in_blackboard(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_name_in_blackboard_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.DataAcquisition.request_name_in_blackboard)
}
inline std::string* DataAcquisition::mutable_request_name_in_blackboard() {
  std::string* _s = _internal_mutable_request_name_in_blackboard();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.DataAcquisition.request_name_in_blackboard)
  return _s;
}
inline const std::string& DataAcquisition::_internal_request_name_in_blackboard() const {
  return _impl_.request_name_in_blackboard_.Get();
}
inline void DataAcquisition::_internal_set_request_name_in_blackboard(const std::string& value) {
  
  _impl_.request_name_in_blackboard_.Set(value, GetArenaForAllocation());
}
inline std::string* DataAcquisition::_internal_mutable_request_name_in_blackboard() {
  
  return _impl_.request_name_in_blackboard_.Mutable(GetArenaForAllocation());
}
inline std::string* DataAcquisition::release_request_name_in_blackboard() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.DataAcquisition.request_name_in_blackboard)
  return _impl_.request_name_in_blackboard_.Release();
}
inline void DataAcquisition::set_allocated_request_name_in_blackboard(std::string* request_name_in_blackboard) {
  if (request_name_in_blackboard != nullptr) {
    
  } else {
    
  }
  _impl_.request_name_in_blackboard_.SetAllocated(request_name_in_blackboard, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_name_in_blackboard_.IsDefault()) {
    _impl_.request_name_in_blackboard_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.DataAcquisition.request_name_in_blackboard)
}

// -------------------------------------------------------------------

// RetainLease

// string service_name = 1;
inline void RetainLease::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& RetainLease::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RetainLease.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RetainLease::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.RetainLease.service_name)
}
inline std::string* RetainLease::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RetainLease.service_name)
  return _s;
}
inline const std::string& RetainLease::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void RetainLease::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RetainLease::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RetainLease::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.RetainLease.service_name)
  return _impl_.service_name_.Release();
}
inline void RetainLease::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.RetainLease.service_name)
}

// string host = 2;
inline void RetainLease::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& RetainLease::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RetainLease.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RetainLease::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.RetainLease.host)
}
inline std::string* RetainLease::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RetainLease.host)
  return _s;
}
inline const std::string& RetainLease::_internal_host() const {
  return _impl_.host_.Get();
}
inline void RetainLease::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* RetainLease::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* RetainLease::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.RetainLease.host)
  return _impl_.host_.Release();
}
inline void RetainLease::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.RetainLease.host)
}

// -------------------------------------------------------------------

// DefineBlackboard

// repeated .bosdyn.api.mission.KeyValue blackboard_variables = 1;
inline int DefineBlackboard::_internal_blackboard_variables_size() const {
  return _impl_.blackboard_variables_.size();
}
inline int DefineBlackboard::blackboard_variables_size() const {
  return _internal_blackboard_variables_size();
}
inline ::bosdyn::api::mission::KeyValue* DefineBlackboard::mutable_blackboard_variables(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.DefineBlackboard.blackboard_variables)
  return _impl_.blackboard_variables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
DefineBlackboard::mutable_blackboard_variables() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.DefineBlackboard.blackboard_variables)
  return &_impl_.blackboard_variables_;
}
inline const ::bosdyn::api::mission::KeyValue& DefineBlackboard::_internal_blackboard_variables(int index) const {
  return _impl_.blackboard_variables_.Get(index);
}
inline const ::bosdyn::api::mission::KeyValue& DefineBlackboard::blackboard_variables(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.DefineBlackboard.blackboard_variables)
  return _internal_blackboard_variables(index);
}
inline ::bosdyn::api::mission::KeyValue* DefineBlackboard::_internal_add_blackboard_variables() {
  return _impl_.blackboard_variables_.Add();
}
inline ::bosdyn::api::mission::KeyValue* DefineBlackboard::add_blackboard_variables() {
  ::bosdyn::api::mission::KeyValue* _add = _internal_add_blackboard_variables();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.DefineBlackboard.blackboard_variables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
DefineBlackboard::blackboard_variables() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.DefineBlackboard.blackboard_variables)
  return _impl_.blackboard_variables_;
}

// .bosdyn.api.mission.Node child = 2;
inline bool DefineBlackboard::_internal_has_child() const {
  return this != internal_default_instance() && _impl_.child_ != nullptr;
}
inline bool DefineBlackboard::has_child() const {
  return _internal_has_child();
}
inline void DefineBlackboard::clear_child() {
  if (GetArenaForAllocation() == nullptr && _impl_.child_ != nullptr) {
    delete _impl_.child_;
  }
  _impl_.child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& DefineBlackboard::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Node&>(
      ::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& DefineBlackboard::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.DefineBlackboard.child)
  return _internal_child();
}
inline void DefineBlackboard::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.DefineBlackboard.child)
}
inline ::bosdyn::api::mission::Node* DefineBlackboard::release_child() {
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Node* DefineBlackboard::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.DefineBlackboard.child)
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* DefineBlackboard::_internal_mutable_child() {
  
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArenaForAllocation());
    _impl_.child_ = p;
  }
  return _impl_.child_;
}
inline ::bosdyn::api::mission::Node* DefineBlackboard::mutable_child() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.DefineBlackboard.child)
  return _msg;
}
inline void DefineBlackboard::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.DefineBlackboard.child)
}

// -------------------------------------------------------------------

// SetBlackboard

// repeated .bosdyn.api.mission.KeyValue blackboard_variables = 1;
inline int SetBlackboard::_internal_blackboard_variables_size() const {
  return _impl_.blackboard_variables_.size();
}
inline int SetBlackboard::blackboard_variables_size() const {
  return _internal_blackboard_variables_size();
}
inline ::bosdyn::api::mission::KeyValue* SetBlackboard::mutable_blackboard_variables(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SetBlackboard.blackboard_variables)
  return _impl_.blackboard_variables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
SetBlackboard::mutable_blackboard_variables() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.SetBlackboard.blackboard_variables)
  return &_impl_.blackboard_variables_;
}
inline const ::bosdyn::api::mission::KeyValue& SetBlackboard::_internal_blackboard_variables(int index) const {
  return _impl_.blackboard_variables_.Get(index);
}
inline const ::bosdyn::api::mission::KeyValue& SetBlackboard::blackboard_variables(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SetBlackboard.blackboard_variables)
  return _internal_blackboard_variables(index);
}
inline ::bosdyn::api::mission::KeyValue* SetBlackboard::_internal_add_blackboard_variables() {
  return _impl_.blackboard_variables_.Add();
}
inline ::bosdyn::api::mission::KeyValue* SetBlackboard::add_blackboard_variables() {
  ::bosdyn::api::mission::KeyValue* _add = _internal_add_blackboard_variables();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.SetBlackboard.blackboard_variables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
SetBlackboard::blackboard_variables() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.SetBlackboard.blackboard_variables)
  return _impl_.blackboard_variables_;
}

// -------------------------------------------------------------------

// FormatBlackboard

// string key = 1;
inline void FormatBlackboard::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& FormatBlackboard::key() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.FormatBlackboard.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FormatBlackboard::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.FormatBlackboard.key)
}
inline std::string* FormatBlackboard::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.FormatBlackboard.key)
  return _s;
}
inline const std::string& FormatBlackboard::_internal_key() const {
  return _impl_.key_.Get();
}
inline void FormatBlackboard::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* FormatBlackboard::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* FormatBlackboard::release_key() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.FormatBlackboard.key)
  return _impl_.key_.Release();
}
inline void FormatBlackboard::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.FormatBlackboard.key)
}

// string format = 2;
inline void FormatBlackboard::clear_format() {
  _impl_.format_.ClearToEmpty();
}
inline const std::string& FormatBlackboard::format() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.FormatBlackboard.format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FormatBlackboard::set_format(ArgT0&& arg0, ArgT... args) {
 
 _impl_.format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.FormatBlackboard.format)
}
inline std::string* FormatBlackboard::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.FormatBlackboard.format)
  return _s;
}
inline const std::string& FormatBlackboard::_internal_format() const {
  return _impl_.format_.Get();
}
inline void FormatBlackboard::_internal_set_format(const std::string& value) {
  
  _impl_.format_.Set(value, GetArenaForAllocation());
}
inline std::string* FormatBlackboard::_internal_mutable_format() {
  
  return _impl_.format_.Mutable(GetArenaForAllocation());
}
inline std::string* FormatBlackboard::release_format() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.FormatBlackboard.format)
  return _impl_.format_.Release();
}
inline void FormatBlackboard::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    
  } else {
    
  }
  _impl_.format_.SetAllocated(format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.format_.IsDefault()) {
    _impl_.format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.FormatBlackboard.format)
}

// -------------------------------------------------------------------

// DateToBlackboard

// string key = 1;
inline void DateToBlackboard::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& DateToBlackboard::key() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.DateToBlackboard.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DateToBlackboard::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.DateToBlackboard.key)
}
inline std::string* DateToBlackboard::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.DateToBlackboard.key)
  return _s;
}
inline const std::string& DateToBlackboard::_internal_key() const {
  return _impl_.key_.Get();
}
inline void DateToBlackboard::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* DateToBlackboard::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* DateToBlackboard::release_key() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.DateToBlackboard.key)
  return _impl_.key_.Release();
}
inline void DateToBlackboard::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.DateToBlackboard.key)
}

// -------------------------------------------------------------------

// ConstantResult

// .bosdyn.api.mission.Result result = 1;
inline void ConstantResult::clear_result() {
  _impl_.result_ = 0;
}
inline ::bosdyn::api::mission::Result ConstantResult::_internal_result() const {
  return static_cast< ::bosdyn::api::mission::Result >(_impl_.result_);
}
inline ::bosdyn::api::mission::Result ConstantResult::result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.ConstantResult.result)
  return _internal_result();
}
inline void ConstantResult::_internal_set_result(::bosdyn::api::mission::Result value) {
  
  _impl_.result_ = value;
}
inline void ConstantResult::set_result(::bosdyn::api::mission::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.ConstantResult.result)
}

// -------------------------------------------------------------------

// RestartWhenPaused

// .bosdyn.api.mission.Node child = 1;
inline bool RestartWhenPaused::_internal_has_child() const {
  return this != internal_default_instance() && _impl_.child_ != nullptr;
}
inline bool RestartWhenPaused::has_child() const {
  return _internal_has_child();
}
inline void RestartWhenPaused::clear_child() {
  if (GetArenaForAllocation() == nullptr && _impl_.child_ != nullptr) {
    delete _impl_.child_;
  }
  _impl_.child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& RestartWhenPaused::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Node&>(
      ::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& RestartWhenPaused::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RestartWhenPaused.child)
  return _internal_child();
}
inline void RestartWhenPaused::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.RestartWhenPaused.child)
}
inline ::bosdyn::api::mission::Node* RestartWhenPaused::release_child() {
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Node* RestartWhenPaused::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.RestartWhenPaused.child)
  
  ::bosdyn::api::mission::Node* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* RestartWhenPaused::_internal_mutable_child() {
  
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArenaForAllocation());
    _impl_.child_ = p;
  }
  return _impl_.child_;
}
inline ::bosdyn::api::mission::Node* RestartWhenPaused::mutable_child() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RestartWhenPaused.child)
  return _msg;
}
inline void RestartWhenPaused::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.RestartWhenPaused.child)
}

// -------------------------------------------------------------------

// ClearBehaviorFaults

// string service_name = 1;
inline void ClearBehaviorFaults::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& ClearBehaviorFaults::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.ClearBehaviorFaults.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClearBehaviorFaults::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.ClearBehaviorFaults.service_name)
}
inline std::string* ClearBehaviorFaults::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.ClearBehaviorFaults.service_name)
  return _s;
}
inline const std::string& ClearBehaviorFaults::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void ClearBehaviorFaults::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ClearBehaviorFaults::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ClearBehaviorFaults::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.ClearBehaviorFaults.service_name)
  return _impl_.service_name_.Release();
}
inline void ClearBehaviorFaults::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.ClearBehaviorFaults.service_name)
}

// string host = 2;
inline void ClearBehaviorFaults::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& ClearBehaviorFaults::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.ClearBehaviorFaults.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClearBehaviorFaults::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.ClearBehaviorFaults.host)
}
inline std::string* ClearBehaviorFaults::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.ClearBehaviorFaults.host)
  return _s;
}
inline const std::string& ClearBehaviorFaults::_internal_host() const {
  return _impl_.host_.Get();
}
inline void ClearBehaviorFaults::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* ClearBehaviorFaults::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* ClearBehaviorFaults::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.ClearBehaviorFaults.host)
  return _impl_.host_.Release();
}
inline void ClearBehaviorFaults::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.ClearBehaviorFaults.host)
}

// string robot_state_blackboard_name = 3;
inline void ClearBehaviorFaults::clear_robot_state_blackboard_name() {
  _impl_.robot_state_blackboard_name_.ClearToEmpty();
}
inline const std::string& ClearBehaviorFaults::robot_state_blackboard_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.ClearBehaviorFaults.robot_state_blackboard_name)
  return _internal_robot_state_blackboard_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClearBehaviorFaults::set_robot_state_blackboard_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.robot_state_blackboard_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.ClearBehaviorFaults.robot_state_blackboard_name)
}
inline std::string* ClearBehaviorFaults::mutable_robot_state_blackboard_name() {
  std::string* _s = _internal_mutable_robot_state_blackboard_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.ClearBehaviorFaults.robot_state_blackboard_name)
  return _s;
}
inline const std::string& ClearBehaviorFaults::_internal_robot_state_blackboard_name() const {
  return _impl_.robot_state_blackboard_name_.Get();
}
inline void ClearBehaviorFaults::_internal_set_robot_state_blackboard_name(const std::string& value) {
  
  _impl_.robot_state_blackboard_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ClearBehaviorFaults::_internal_mutable_robot_state_blackboard_name() {
  
  return _impl_.robot_state_blackboard_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ClearBehaviorFaults::release_robot_state_blackboard_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.ClearBehaviorFaults.robot_state_blackboard_name)
  return _impl_.robot_state_blackboard_name_.Release();
}
inline void ClearBehaviorFaults::set_allocated_robot_state_blackboard_name(std::string* robot_state_blackboard_name) {
  if (robot_state_blackboard_name != nullptr) {
    
  } else {
    
  }
  _impl_.robot_state_blackboard_name_.SetAllocated(robot_state_blackboard_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.robot_state_blackboard_name_.IsDefault()) {
    _impl_.robot_state_blackboard_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.ClearBehaviorFaults.robot_state_blackboard_name)
}

// string cleared_cause_fall_blackboard_name = 4;
inline void ClearBehaviorFaults::clear_cleared_cause_fall_blackboard_name() {
  _impl_.cleared_cause_fall_blackboard_name_.ClearToEmpty();
}
inline const std::string& ClearBehaviorFaults::cleared_cause_fall_blackboard_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.ClearBehaviorFaults.cleared_cause_fall_blackboard_name)
  return _internal_cleared_cause_fall_blackboard_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClearBehaviorFaults::set_cleared_cause_fall_blackboard_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cleared_cause_fall_blackboard_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.ClearBehaviorFaults.cleared_cause_fall_blackboard_name)
}
inline std::string* ClearBehaviorFaults::mutable_cleared_cause_fall_blackboard_name() {
  std::string* _s = _internal_mutable_cleared_cause_fall_blackboard_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.ClearBehaviorFaults.cleared_cause_fall_blackboard_name)
  return _s;
}
inline const std::string& ClearBehaviorFaults::_internal_cleared_cause_fall_blackboard_name() const {
  return _impl_.cleared_cause_fall_blackboard_name_.Get();
}
inline void ClearBehaviorFaults::_internal_set_cleared_cause_fall_blackboard_name(const std::string& value) {
  
  _impl_.cleared_cause_fall_blackboard_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ClearBehaviorFaults::_internal_mutable_cleared_cause_fall_blackboard_name() {
  
  return _impl_.cleared_cause_fall_blackboard_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ClearBehaviorFaults::release_cleared_cause_fall_blackboard_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.ClearBehaviorFaults.cleared_cause_fall_blackboard_name)
  return _impl_.cleared_cause_fall_blackboard_name_.Release();
}
inline void ClearBehaviorFaults::set_allocated_cleared_cause_fall_blackboard_name(std::string* cleared_cause_fall_blackboard_name) {
  if (cleared_cause_fall_blackboard_name != nullptr) {
    
  } else {
    
  }
  _impl_.cleared_cause_fall_blackboard_name_.SetAllocated(cleared_cause_fall_blackboard_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cleared_cause_fall_blackboard_name_.IsDefault()) {
    _impl_.cleared_cause_fall_blackboard_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.ClearBehaviorFaults.cleared_cause_fall_blackboard_name)
}

// string cleared_cause_hardware_blackboard_name = 5;
inline void ClearBehaviorFaults::clear_cleared_cause_hardware_blackboard_name() {
  _impl_.cleared_cause_hardware_blackboard_name_.ClearToEmpty();
}
inline const std::string& ClearBehaviorFaults::cleared_cause_hardware_blackboard_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.ClearBehaviorFaults.cleared_cause_hardware_blackboard_name)
  return _internal_cleared_cause_hardware_blackboard_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClearBehaviorFaults::set_cleared_cause_hardware_blackboard_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cleared_cause_hardware_blackboard_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.ClearBehaviorFaults.cleared_cause_hardware_blackboard_name)
}
inline std::string* ClearBehaviorFaults::mutable_cleared_cause_hardware_blackboard_name() {
  std::string* _s = _internal_mutable_cleared_cause_hardware_blackboard_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.ClearBehaviorFaults.cleared_cause_hardware_blackboard_name)
  return _s;
}
inline const std::string& ClearBehaviorFaults::_internal_cleared_cause_hardware_blackboard_name() const {
  return _impl_.cleared_cause_hardware_blackboard_name_.Get();
}
inline void ClearBehaviorFaults::_internal_set_cleared_cause_hardware_blackboard_name(const std::string& value) {
  
  _impl_.cleared_cause_hardware_blackboard_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ClearBehaviorFaults::_internal_mutable_cleared_cause_hardware_blackboard_name() {
  
  return _impl_.cleared_cause_hardware_blackboard_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ClearBehaviorFaults::release_cleared_cause_hardware_blackboard_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.ClearBehaviorFaults.cleared_cause_hardware_blackboard_name)
  return _impl_.cleared_cause_hardware_blackboard_name_.Release();
}
inline void ClearBehaviorFaults::set_allocated_cleared_cause_hardware_blackboard_name(std::string* cleared_cause_hardware_blackboard_name) {
  if (cleared_cause_hardware_blackboard_name != nullptr) {
    
  } else {
    
  }
  _impl_.cleared_cause_hardware_blackboard_name_.SetAllocated(cleared_cause_hardware_blackboard_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cleared_cause_hardware_blackboard_name_.IsDefault()) {
    _impl_.cleared_cause_hardware_blackboard_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.ClearBehaviorFaults.cleared_cause_hardware_blackboard_name)
}

// string cleared_cause_lease_timeout_blackboard_name = 6;
inline void ClearBehaviorFaults::clear_cleared_cause_lease_timeout_blackboard_name() {
  _impl_.cleared_cause_lease_timeout_blackboard_name_.ClearToEmpty();
}
inline const std::string& ClearBehaviorFaults::cleared_cause_lease_timeout_blackboard_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.ClearBehaviorFaults.cleared_cause_lease_timeout_blackboard_name)
  return _internal_cleared_cause_lease_timeout_blackboard_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClearBehaviorFaults::set_cleared_cause_lease_timeout_blackboard_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cleared_cause_lease_timeout_blackboard_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.ClearBehaviorFaults.cleared_cause_lease_timeout_blackboard_name)
}
inline std::string* ClearBehaviorFaults::mutable_cleared_cause_lease_timeout_blackboard_name() {
  std::string* _s = _internal_mutable_cleared_cause_lease_timeout_blackboard_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.ClearBehaviorFaults.cleared_cause_lease_timeout_blackboard_name)
  return _s;
}
inline const std::string& ClearBehaviorFaults::_internal_cleared_cause_lease_timeout_blackboard_name() const {
  return _impl_.cleared_cause_lease_timeout_blackboard_name_.Get();
}
inline void ClearBehaviorFaults::_internal_set_cleared_cause_lease_timeout_blackboard_name(const std::string& value) {
  
  _impl_.cleared_cause_lease_timeout_blackboard_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ClearBehaviorFaults::_internal_mutable_cleared_cause_lease_timeout_blackboard_name() {
  
  return _impl_.cleared_cause_lease_timeout_blackboard_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ClearBehaviorFaults::release_cleared_cause_lease_timeout_blackboard_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.ClearBehaviorFaults.cleared_cause_lease_timeout_blackboard_name)
  return _impl_.cleared_cause_lease_timeout_blackboard_name_.Release();
}
inline void ClearBehaviorFaults::set_allocated_cleared_cause_lease_timeout_blackboard_name(std::string* cleared_cause_lease_timeout_blackboard_name) {
  if (cleared_cause_lease_timeout_blackboard_name != nullptr) {
    
  } else {
    
  }
  _impl_.cleared_cause_lease_timeout_blackboard_name_.SetAllocated(cleared_cause_lease_timeout_blackboard_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cleared_cause_lease_timeout_blackboard_name_.IsDefault()) {
    _impl_.cleared_cause_lease_timeout_blackboard_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.ClearBehaviorFaults.cleared_cause_lease_timeout_blackboard_name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mission
}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::mission::Condition_Compare> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::mission::Condition_Compare>() {
  return ::bosdyn::api::mission::Condition_Compare_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::mission::Condition_HandleStaleness> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::mission::Condition_HandleStaleness>() {
  return ::bosdyn::api::mission::Condition_HandleStaleness_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::mission::DataAcquisition_CompletionBehavior> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::mission::DataAcquisition_CompletionBehavior>() {
  return ::bosdyn::api::mission::DataAcquisition_CompletionBehavior_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fmission_2fnodes_2eproto
