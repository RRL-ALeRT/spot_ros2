// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/payload.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fpayload_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fpayload_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/geometry.pb.h"
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/robot_id.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fpayload_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fpayload_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fpayload_2eproto;
namespace bosdyn {
namespace api {
class JointLimits;
struct JointLimitsDefaultTypeInternal;
extern JointLimitsDefaultTypeInternal _JointLimits_default_instance_;
class ListPayloadsRequest;
struct ListPayloadsRequestDefaultTypeInternal;
extern ListPayloadsRequestDefaultTypeInternal _ListPayloadsRequest_default_instance_;
class ListPayloadsResponse;
struct ListPayloadsResponseDefaultTypeInternal;
extern ListPayloadsResponseDefaultTypeInternal _ListPayloadsResponse_default_instance_;
class MomentOfIntertia;
struct MomentOfIntertiaDefaultTypeInternal;
extern MomentOfIntertiaDefaultTypeInternal _MomentOfIntertia_default_instance_;
class Payload;
struct PayloadDefaultTypeInternal;
extern PayloadDefaultTypeInternal _Payload_default_instance_;
class PayloadMassVolumeProperties;
struct PayloadMassVolumePropertiesDefaultTypeInternal;
extern PayloadMassVolumePropertiesDefaultTypeInternal _PayloadMassVolumeProperties_default_instance_;
class PayloadPreset;
struct PayloadPresetDefaultTypeInternal;
extern PayloadPresetDefaultTypeInternal _PayloadPreset_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::JointLimits* Arena::CreateMaybeMessage<::bosdyn::api::JointLimits>(Arena*);
template<> ::bosdyn::api::ListPayloadsRequest* Arena::CreateMaybeMessage<::bosdyn::api::ListPayloadsRequest>(Arena*);
template<> ::bosdyn::api::ListPayloadsResponse* Arena::CreateMaybeMessage<::bosdyn::api::ListPayloadsResponse>(Arena*);
template<> ::bosdyn::api::MomentOfIntertia* Arena::CreateMaybeMessage<::bosdyn::api::MomentOfIntertia>(Arena*);
template<> ::bosdyn::api::Payload* Arena::CreateMaybeMessage<::bosdyn::api::Payload>(Arena*);
template<> ::bosdyn::api::PayloadMassVolumeProperties* Arena::CreateMaybeMessage<::bosdyn::api::PayloadMassVolumeProperties>(Arena*);
template<> ::bosdyn::api::PayloadPreset* Arena::CreateMaybeMessage<::bosdyn::api::PayloadPreset>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum MountFrameName : int {
  MOUNT_FRAME_UNKNOWN = 0,
  MOUNT_FRAME_BODY_PAYLOAD = 1,
  MOUNT_FRAME_GRIPPER_PAYLOAD = 2,
  MOUNT_FRAME_WR1 = 3,
  MountFrameName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MountFrameName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MountFrameName_IsValid(int value);
constexpr MountFrameName MountFrameName_MIN = MOUNT_FRAME_UNKNOWN;
constexpr MountFrameName MountFrameName_MAX = MOUNT_FRAME_WR1;
constexpr int MountFrameName_ARRAYSIZE = MountFrameName_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MountFrameName_descriptor();
template<typename T>
inline const std::string& MountFrameName_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MountFrameName>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MountFrameName_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MountFrameName_descriptor(), enum_t_value);
}
inline bool MountFrameName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MountFrameName* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MountFrameName>(
    MountFrameName_descriptor(), name, value);
}
// ===================================================================

class Payload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Payload) */ {
 public:
  inline Payload() : Payload(nullptr) {}
  ~Payload() override;
  explicit PROTOBUF_CONSTEXPR Payload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Payload(const Payload& from);
  Payload(Payload&& from) noexcept
    : Payload() {
    *this = ::std::move(from);
  }

  inline Payload& operator=(const Payload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Payload& operator=(Payload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Payload& default_instance() {
    return *internal_default_instance();
  }
  static inline const Payload* internal_default_instance() {
    return reinterpret_cast<const Payload*>(
               &_Payload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Payload& a, Payload& b) {
    a.Swap(&b);
  }
  inline void Swap(Payload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Payload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Payload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Payload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Payload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Payload& from) {
    Payload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Payload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Payload";
  }
  protected:
  explicit Payload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelPrefixFieldNumber = 9,
    kPresetConfigurationsFieldNumber = 11,
    kGUIDFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kBodyTformPayloadFieldNumber = 7,
    kMountTformPayloadFieldNumber = 8,
    kMassVolumePropertiesFieldNumber = 10,
    kVersionFieldNumber = 12,
    kIsAuthorizedFieldNumber = 4,
    kIsEnabledFieldNumber = 5,
    kIsNoncomputePayloadFieldNumber = 6,
    kMountFrameNameFieldNumber = 13,
  };
  // repeated string label_prefix = 9;
  int label_prefix_size() const;
  private:
  int _internal_label_prefix_size() const;
  public:
  void clear_label_prefix();
  const std::string& label_prefix(int index) const;
  std::string* mutable_label_prefix(int index);
  void set_label_prefix(int index, const std::string& value);
  void set_label_prefix(int index, std::string&& value);
  void set_label_prefix(int index, const char* value);
  void set_label_prefix(int index, const char* value, size_t size);
  std::string* add_label_prefix();
  void add_label_prefix(const std::string& value);
  void add_label_prefix(std::string&& value);
  void add_label_prefix(const char* value);
  void add_label_prefix(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& label_prefix() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_label_prefix();
  private:
  const std::string& _internal_label_prefix(int index) const;
  std::string* _internal_add_label_prefix();
  public:

  // repeated .bosdyn.api.PayloadPreset preset_configurations = 11;
  int preset_configurations_size() const;
  private:
  int _internal_preset_configurations_size() const;
  public:
  void clear_preset_configurations();
  ::bosdyn::api::PayloadPreset* mutable_preset_configurations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PayloadPreset >*
      mutable_preset_configurations();
  private:
  const ::bosdyn::api::PayloadPreset& _internal_preset_configurations(int index) const;
  ::bosdyn::api::PayloadPreset* _internal_add_preset_configurations();
  public:
  const ::bosdyn::api::PayloadPreset& preset_configurations(int index) const;
  ::bosdyn::api::PayloadPreset* add_preset_configurations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PayloadPreset >&
      preset_configurations() const;

  // string GUID = 1;
  void clear_guid();
  const std::string& guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_guid();
  PROTOBUF_NODISCARD std::string* release_guid();
  void set_allocated_guid(std::string* guid);
  private:
  const std::string& _internal_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guid(const std::string& value);
  std::string* _internal_mutable_guid();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .bosdyn.api.SE3Pose body_tform_payload = 7;
  bool has_body_tform_payload() const;
  private:
  bool _internal_has_body_tform_payload() const;
  public:
  void clear_body_tform_payload();
  const ::bosdyn::api::SE3Pose& body_tform_payload() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Pose* release_body_tform_payload();
  ::bosdyn::api::SE3Pose* mutable_body_tform_payload();
  void set_allocated_body_tform_payload(::bosdyn::api::SE3Pose* body_tform_payload);
  private:
  const ::bosdyn::api::SE3Pose& _internal_body_tform_payload() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_body_tform_payload();
  public:
  void unsafe_arena_set_allocated_body_tform_payload(
      ::bosdyn::api::SE3Pose* body_tform_payload);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_body_tform_payload();

  // .bosdyn.api.SE3Pose mount_tform_payload = 8;
  bool has_mount_tform_payload() const;
  private:
  bool _internal_has_mount_tform_payload() const;
  public:
  void clear_mount_tform_payload();
  const ::bosdyn::api::SE3Pose& mount_tform_payload() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Pose* release_mount_tform_payload();
  ::bosdyn::api::SE3Pose* mutable_mount_tform_payload();
  void set_allocated_mount_tform_payload(::bosdyn::api::SE3Pose* mount_tform_payload);
  private:
  const ::bosdyn::api::SE3Pose& _internal_mount_tform_payload() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_mount_tform_payload();
  public:
  void unsafe_arena_set_allocated_mount_tform_payload(
      ::bosdyn::api::SE3Pose* mount_tform_payload);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_mount_tform_payload();

  // .bosdyn.api.PayloadMassVolumeProperties mass_volume_properties = 10;
  bool has_mass_volume_properties() const;
  private:
  bool _internal_has_mass_volume_properties() const;
  public:
  void clear_mass_volume_properties();
  const ::bosdyn::api::PayloadMassVolumeProperties& mass_volume_properties() const;
  PROTOBUF_NODISCARD ::bosdyn::api::PayloadMassVolumeProperties* release_mass_volume_properties();
  ::bosdyn::api::PayloadMassVolumeProperties* mutable_mass_volume_properties();
  void set_allocated_mass_volume_properties(::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties);
  private:
  const ::bosdyn::api::PayloadMassVolumeProperties& _internal_mass_volume_properties() const;
  ::bosdyn::api::PayloadMassVolumeProperties* _internal_mutable_mass_volume_properties();
  public:
  void unsafe_arena_set_allocated_mass_volume_properties(
      ::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties);
  ::bosdyn::api::PayloadMassVolumeProperties* unsafe_arena_release_mass_volume_properties();

  // .bosdyn.api.SoftwareVersion version = 12;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::bosdyn::api::SoftwareVersion& version() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SoftwareVersion* release_version();
  ::bosdyn::api::SoftwareVersion* mutable_version();
  void set_allocated_version(::bosdyn::api::SoftwareVersion* version);
  private:
  const ::bosdyn::api::SoftwareVersion& _internal_version() const;
  ::bosdyn::api::SoftwareVersion* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::bosdyn::api::SoftwareVersion* version);
  ::bosdyn::api::SoftwareVersion* unsafe_arena_release_version();

  // bool is_authorized = 4;
  void clear_is_authorized();
  bool is_authorized() const;
  void set_is_authorized(bool value);
  private:
  bool _internal_is_authorized() const;
  void _internal_set_is_authorized(bool value);
  public:

  // bool is_enabled = 5;
  void clear_is_enabled();
  bool is_enabled() const;
  void set_is_enabled(bool value);
  private:
  bool _internal_is_enabled() const;
  void _internal_set_is_enabled(bool value);
  public:

  // bool is_noncompute_payload = 6;
  void clear_is_noncompute_payload();
  bool is_noncompute_payload() const;
  void set_is_noncompute_payload(bool value);
  private:
  bool _internal_is_noncompute_payload() const;
  void _internal_set_is_noncompute_payload(bool value);
  public:

  // .bosdyn.api.MountFrameName mount_frame_name = 13;
  void clear_mount_frame_name();
  ::bosdyn::api::MountFrameName mount_frame_name() const;
  void set_mount_frame_name(::bosdyn::api::MountFrameName value);
  private:
  ::bosdyn::api::MountFrameName _internal_mount_frame_name() const;
  void _internal_set_mount_frame_name(::bosdyn::api::MountFrameName value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Payload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> label_prefix_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PayloadPreset > preset_configurations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::bosdyn::api::SE3Pose* body_tform_payload_;
    ::bosdyn::api::SE3Pose* mount_tform_payload_;
    ::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties_;
    ::bosdyn::api::SoftwareVersion* version_;
    bool is_authorized_;
    bool is_enabled_;
    bool is_noncompute_payload_;
    int mount_frame_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fpayload_2eproto;
};
// -------------------------------------------------------------------

class PayloadPreset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PayloadPreset) */ {
 public:
  inline PayloadPreset() : PayloadPreset(nullptr) {}
  ~PayloadPreset() override;
  explicit PROTOBUF_CONSTEXPR PayloadPreset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PayloadPreset(const PayloadPreset& from);
  PayloadPreset(PayloadPreset&& from) noexcept
    : PayloadPreset() {
    *this = ::std::move(from);
  }

  inline PayloadPreset& operator=(const PayloadPreset& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadPreset& operator=(PayloadPreset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PayloadPreset& default_instance() {
    return *internal_default_instance();
  }
  static inline const PayloadPreset* internal_default_instance() {
    return reinterpret_cast<const PayloadPreset*>(
               &_PayloadPreset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PayloadPreset& a, PayloadPreset& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadPreset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadPreset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadPreset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PayloadPreset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PayloadPreset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PayloadPreset& from) {
    PayloadPreset::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PayloadPreset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PayloadPreset";
  }
  protected:
  explicit PayloadPreset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelPrefixFieldNumber = 5,
    kPresetNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kMountTformPayloadFieldNumber = 3,
    kMassVolumePropertiesFieldNumber = 4,
    kMountFrameNameFieldNumber = 6,
  };
  // repeated string label_prefix = 5;
  int label_prefix_size() const;
  private:
  int _internal_label_prefix_size() const;
  public:
  void clear_label_prefix();
  const std::string& label_prefix(int index) const;
  std::string* mutable_label_prefix(int index);
  void set_label_prefix(int index, const std::string& value);
  void set_label_prefix(int index, std::string&& value);
  void set_label_prefix(int index, const char* value);
  void set_label_prefix(int index, const char* value, size_t size);
  std::string* add_label_prefix();
  void add_label_prefix(const std::string& value);
  void add_label_prefix(std::string&& value);
  void add_label_prefix(const char* value);
  void add_label_prefix(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& label_prefix() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_label_prefix();
  private:
  const std::string& _internal_label_prefix(int index) const;
  std::string* _internal_add_label_prefix();
  public:

  // string preset_name = 1;
  void clear_preset_name();
  const std::string& preset_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_preset_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_preset_name();
  PROTOBUF_NODISCARD std::string* release_preset_name();
  void set_allocated_preset_name(std::string* preset_name);
  private:
  const std::string& _internal_preset_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preset_name(const std::string& value);
  std::string* _internal_mutable_preset_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .bosdyn.api.SE3Pose mount_tform_payload = 3;
  bool has_mount_tform_payload() const;
  private:
  bool _internal_has_mount_tform_payload() const;
  public:
  void clear_mount_tform_payload();
  const ::bosdyn::api::SE3Pose& mount_tform_payload() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Pose* release_mount_tform_payload();
  ::bosdyn::api::SE3Pose* mutable_mount_tform_payload();
  void set_allocated_mount_tform_payload(::bosdyn::api::SE3Pose* mount_tform_payload);
  private:
  const ::bosdyn::api::SE3Pose& _internal_mount_tform_payload() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_mount_tform_payload();
  public:
  void unsafe_arena_set_allocated_mount_tform_payload(
      ::bosdyn::api::SE3Pose* mount_tform_payload);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_mount_tform_payload();

  // .bosdyn.api.PayloadMassVolumeProperties mass_volume_properties = 4;
  bool has_mass_volume_properties() const;
  private:
  bool _internal_has_mass_volume_properties() const;
  public:
  void clear_mass_volume_properties();
  const ::bosdyn::api::PayloadMassVolumeProperties& mass_volume_properties() const;
  PROTOBUF_NODISCARD ::bosdyn::api::PayloadMassVolumeProperties* release_mass_volume_properties();
  ::bosdyn::api::PayloadMassVolumeProperties* mutable_mass_volume_properties();
  void set_allocated_mass_volume_properties(::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties);
  private:
  const ::bosdyn::api::PayloadMassVolumeProperties& _internal_mass_volume_properties() const;
  ::bosdyn::api::PayloadMassVolumeProperties* _internal_mutable_mass_volume_properties();
  public:
  void unsafe_arena_set_allocated_mass_volume_properties(
      ::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties);
  ::bosdyn::api::PayloadMassVolumeProperties* unsafe_arena_release_mass_volume_properties();

  // .bosdyn.api.MountFrameName mount_frame_name = 6;
  void clear_mount_frame_name();
  ::bosdyn::api::MountFrameName mount_frame_name() const;
  void set_mount_frame_name(::bosdyn::api::MountFrameName value);
  private:
  ::bosdyn::api::MountFrameName _internal_mount_frame_name() const;
  void _internal_set_mount_frame_name(::bosdyn::api::MountFrameName value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.PayloadPreset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> label_prefix_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preset_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::bosdyn::api::SE3Pose* mount_tform_payload_;
    ::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties_;
    int mount_frame_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fpayload_2eproto;
};
// -------------------------------------------------------------------

class PayloadMassVolumeProperties final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PayloadMassVolumeProperties) */ {
 public:
  inline PayloadMassVolumeProperties() : PayloadMassVolumeProperties(nullptr) {}
  ~PayloadMassVolumeProperties() override;
  explicit PROTOBUF_CONSTEXPR PayloadMassVolumeProperties(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PayloadMassVolumeProperties(const PayloadMassVolumeProperties& from);
  PayloadMassVolumeProperties(PayloadMassVolumeProperties&& from) noexcept
    : PayloadMassVolumeProperties() {
    *this = ::std::move(from);
  }

  inline PayloadMassVolumeProperties& operator=(const PayloadMassVolumeProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadMassVolumeProperties& operator=(PayloadMassVolumeProperties&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PayloadMassVolumeProperties& default_instance() {
    return *internal_default_instance();
  }
  static inline const PayloadMassVolumeProperties* internal_default_instance() {
    return reinterpret_cast<const PayloadMassVolumeProperties*>(
               &_PayloadMassVolumeProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PayloadMassVolumeProperties& a, PayloadMassVolumeProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadMassVolumeProperties* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadMassVolumeProperties* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadMassVolumeProperties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PayloadMassVolumeProperties>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PayloadMassVolumeProperties& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PayloadMassVolumeProperties& from) {
    PayloadMassVolumeProperties::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PayloadMassVolumeProperties* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PayloadMassVolumeProperties";
  }
  protected:
  explicit PayloadMassVolumeProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoundingBoxFieldNumber = 5,
    kJointLimitsFieldNumber = 6,
    kComPosRtPayloadFieldNumber = 3,
    kMoiTensorFieldNumber = 4,
    kTotalMassFieldNumber = 2,
  };
  // repeated .bosdyn.api.Box3WithFrame bounding_box = 5;
  int bounding_box_size() const;
  private:
  int _internal_bounding_box_size() const;
  public:
  void clear_bounding_box();
  ::bosdyn::api::Box3WithFrame* mutable_bounding_box(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Box3WithFrame >*
      mutable_bounding_box();
  private:
  const ::bosdyn::api::Box3WithFrame& _internal_bounding_box(int index) const;
  ::bosdyn::api::Box3WithFrame* _internal_add_bounding_box();
  public:
  const ::bosdyn::api::Box3WithFrame& bounding_box(int index) const;
  ::bosdyn::api::Box3WithFrame* add_bounding_box();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Box3WithFrame >&
      bounding_box() const;

  // repeated .bosdyn.api.JointLimits joint_limits = 6;
  int joint_limits_size() const;
  private:
  int _internal_joint_limits_size() const;
  public:
  void clear_joint_limits();
  ::bosdyn::api::JointLimits* mutable_joint_limits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointLimits >*
      mutable_joint_limits();
  private:
  const ::bosdyn::api::JointLimits& _internal_joint_limits(int index) const;
  ::bosdyn::api::JointLimits* _internal_add_joint_limits();
  public:
  const ::bosdyn::api::JointLimits& joint_limits(int index) const;
  ::bosdyn::api::JointLimits* add_joint_limits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointLimits >&
      joint_limits() const;

  // .bosdyn.api.Vec3 com_pos_rt_payload = 3;
  bool has_com_pos_rt_payload() const;
  private:
  bool _internal_has_com_pos_rt_payload() const;
  public:
  void clear_com_pos_rt_payload();
  const ::bosdyn::api::Vec3& com_pos_rt_payload() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_com_pos_rt_payload();
  ::bosdyn::api::Vec3* mutable_com_pos_rt_payload();
  void set_allocated_com_pos_rt_payload(::bosdyn::api::Vec3* com_pos_rt_payload);
  private:
  const ::bosdyn::api::Vec3& _internal_com_pos_rt_payload() const;
  ::bosdyn::api::Vec3* _internal_mutable_com_pos_rt_payload();
  public:
  void unsafe_arena_set_allocated_com_pos_rt_payload(
      ::bosdyn::api::Vec3* com_pos_rt_payload);
  ::bosdyn::api::Vec3* unsafe_arena_release_com_pos_rt_payload();

  // .bosdyn.api.MomentOfIntertia moi_tensor = 4;
  bool has_moi_tensor() const;
  private:
  bool _internal_has_moi_tensor() const;
  public:
  void clear_moi_tensor();
  const ::bosdyn::api::MomentOfIntertia& moi_tensor() const;
  PROTOBUF_NODISCARD ::bosdyn::api::MomentOfIntertia* release_moi_tensor();
  ::bosdyn::api::MomentOfIntertia* mutable_moi_tensor();
  void set_allocated_moi_tensor(::bosdyn::api::MomentOfIntertia* moi_tensor);
  private:
  const ::bosdyn::api::MomentOfIntertia& _internal_moi_tensor() const;
  ::bosdyn::api::MomentOfIntertia* _internal_mutable_moi_tensor();
  public:
  void unsafe_arena_set_allocated_moi_tensor(
      ::bosdyn::api::MomentOfIntertia* moi_tensor);
  ::bosdyn::api::MomentOfIntertia* unsafe_arena_release_moi_tensor();

  // float total_mass = 2;
  void clear_total_mass();
  float total_mass() const;
  void set_total_mass(float value);
  private:
  float _internal_total_mass() const;
  void _internal_set_total_mass(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.PayloadMassVolumeProperties)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Box3WithFrame > bounding_box_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointLimits > joint_limits_;
    ::bosdyn::api::Vec3* com_pos_rt_payload_;
    ::bosdyn::api::MomentOfIntertia* moi_tensor_;
    float total_mass_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fpayload_2eproto;
};
// -------------------------------------------------------------------

class MomentOfIntertia final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.MomentOfIntertia) */ {
 public:
  inline MomentOfIntertia() : MomentOfIntertia(nullptr) {}
  ~MomentOfIntertia() override;
  explicit PROTOBUF_CONSTEXPR MomentOfIntertia(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MomentOfIntertia(const MomentOfIntertia& from);
  MomentOfIntertia(MomentOfIntertia&& from) noexcept
    : MomentOfIntertia() {
    *this = ::std::move(from);
  }

  inline MomentOfIntertia& operator=(const MomentOfIntertia& from) {
    CopyFrom(from);
    return *this;
  }
  inline MomentOfIntertia& operator=(MomentOfIntertia&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MomentOfIntertia& default_instance() {
    return *internal_default_instance();
  }
  static inline const MomentOfIntertia* internal_default_instance() {
    return reinterpret_cast<const MomentOfIntertia*>(
               &_MomentOfIntertia_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MomentOfIntertia& a, MomentOfIntertia& b) {
    a.Swap(&b);
  }
  inline void Swap(MomentOfIntertia* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MomentOfIntertia* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MomentOfIntertia* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MomentOfIntertia>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MomentOfIntertia& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MomentOfIntertia& from) {
    MomentOfIntertia::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MomentOfIntertia* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.MomentOfIntertia";
  }
  protected:
  explicit MomentOfIntertia(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXxFieldNumber = 2,
    kYyFieldNumber = 3,
    kZzFieldNumber = 4,
    kXyFieldNumber = 5,
    kXzFieldNumber = 6,
    kYzFieldNumber = 7,
  };
  // float xx = 2;
  void clear_xx();
  float xx() const;
  void set_xx(float value);
  private:
  float _internal_xx() const;
  void _internal_set_xx(float value);
  public:

  // float yy = 3;
  void clear_yy();
  float yy() const;
  void set_yy(float value);
  private:
  float _internal_yy() const;
  void _internal_set_yy(float value);
  public:

  // float zz = 4;
  void clear_zz();
  float zz() const;
  void set_zz(float value);
  private:
  float _internal_zz() const;
  void _internal_set_zz(float value);
  public:

  // float xy = 5;
  void clear_xy();
  float xy() const;
  void set_xy(float value);
  private:
  float _internal_xy() const;
  void _internal_set_xy(float value);
  public:

  // float xz = 6;
  void clear_xz();
  float xz() const;
  void set_xz(float value);
  private:
  float _internal_xz() const;
  void _internal_set_xz(float value);
  public:

  // float yz = 7;
  void clear_yz();
  float yz() const;
  void set_yz(float value);
  private:
  float _internal_yz() const;
  void _internal_set_yz(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.MomentOfIntertia)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float xx_;
    float yy_;
    float zz_;
    float xy_;
    float xz_;
    float yz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fpayload_2eproto;
};
// -------------------------------------------------------------------

class JointLimits final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.JointLimits) */ {
 public:
  inline JointLimits() : JointLimits(nullptr) {}
  ~JointLimits() override;
  explicit PROTOBUF_CONSTEXPR JointLimits(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JointLimits(const JointLimits& from);
  JointLimits(JointLimits&& from) noexcept
    : JointLimits() {
    *this = ::std::move(from);
  }

  inline JointLimits& operator=(const JointLimits& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointLimits& operator=(JointLimits&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JointLimits& default_instance() {
    return *internal_default_instance();
  }
  static inline const JointLimits* internal_default_instance() {
    return reinterpret_cast<const JointLimits*>(
               &_JointLimits_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(JointLimits& a, JointLimits& b) {
    a.Swap(&b);
  }
  inline void Swap(JointLimits* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointLimits* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JointLimits* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JointLimits>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JointLimits& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JointLimits& from) {
    JointLimits::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointLimits* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.JointLimits";
  }
  protected:
  explicit JointLimits(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHyFieldNumber = 3,
    kHxFieldNumber = 4,
    kLabelFieldNumber = 2,
  };
  // repeated float hy = 3;
  int hy_size() const;
  private:
  int _internal_hy_size() const;
  public:
  void clear_hy();
  private:
  float _internal_hy(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_hy() const;
  void _internal_add_hy(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_hy();
  public:
  float hy(int index) const;
  void set_hy(int index, float value);
  void add_hy(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      hy() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_hy();

  // repeated float hx = 4;
  int hx_size() const;
  private:
  int _internal_hx_size() const;
  public:
  void clear_hx();
  private:
  float _internal_hx(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_hx() const;
  void _internal_add_hx(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_hx();
  public:
  float hx(int index) const;
  void set_hx(int index, float value);
  void add_hx(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      hx() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_hx();

  // string label = 2;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.JointLimits)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > hy_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > hx_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fpayload_2eproto;
};
// -------------------------------------------------------------------

class ListPayloadsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListPayloadsRequest) */ {
 public:
  inline ListPayloadsRequest() : ListPayloadsRequest(nullptr) {}
  ~ListPayloadsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListPayloadsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPayloadsRequest(const ListPayloadsRequest& from);
  ListPayloadsRequest(ListPayloadsRequest&& from) noexcept
    : ListPayloadsRequest() {
    *this = ::std::move(from);
  }

  inline ListPayloadsRequest& operator=(const ListPayloadsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPayloadsRequest& operator=(ListPayloadsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPayloadsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPayloadsRequest* internal_default_instance() {
    return reinterpret_cast<const ListPayloadsRequest*>(
               &_ListPayloadsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListPayloadsRequest& a, ListPayloadsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPayloadsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPayloadsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPayloadsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPayloadsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPayloadsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListPayloadsRequest& from) {
    ListPayloadsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPayloadsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListPayloadsRequest";
  }
  protected:
  explicit ListPayloadsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListPayloadsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fpayload_2eproto;
};
// -------------------------------------------------------------------

class ListPayloadsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListPayloadsResponse) */ {
 public:
  inline ListPayloadsResponse() : ListPayloadsResponse(nullptr) {}
  ~ListPayloadsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListPayloadsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPayloadsResponse(const ListPayloadsResponse& from);
  ListPayloadsResponse(ListPayloadsResponse&& from) noexcept
    : ListPayloadsResponse() {
    *this = ::std::move(from);
  }

  inline ListPayloadsResponse& operator=(const ListPayloadsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPayloadsResponse& operator=(ListPayloadsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPayloadsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPayloadsResponse* internal_default_instance() {
    return reinterpret_cast<const ListPayloadsResponse*>(
               &_ListPayloadsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListPayloadsResponse& a, ListPayloadsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPayloadsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPayloadsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPayloadsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPayloadsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPayloadsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListPayloadsResponse& from) {
    ListPayloadsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPayloadsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListPayloadsResponse";
  }
  protected:
  explicit ListPayloadsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.Payload payloads = 2;
  int payloads_size() const;
  private:
  int _internal_payloads_size() const;
  public:
  void clear_payloads();
  ::bosdyn::api::Payload* mutable_payloads(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Payload >*
      mutable_payloads();
  private:
  const ::bosdyn::api::Payload& _internal_payloads(int index) const;
  ::bosdyn::api::Payload* _internal_add_payloads();
  public:
  const ::bosdyn::api::Payload& payloads(int index) const;
  ::bosdyn::api::Payload* add_payloads();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Payload >&
      payloads() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListPayloadsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Payload > payloads_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fpayload_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Payload

// string GUID = 1;
inline void Payload::clear_guid() {
  _impl_.guid_.ClearToEmpty();
}
inline const std::string& Payload::guid() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.GUID)
  return _internal_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Payload::set_guid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.guid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.GUID)
}
inline std::string* Payload::mutable_guid() {
  std::string* _s = _internal_mutable_guid();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.GUID)
  return _s;
}
inline const std::string& Payload::_internal_guid() const {
  return _impl_.guid_.Get();
}
inline void Payload::_internal_set_guid(const std::string& value) {
  
  _impl_.guid_.Set(value, GetArenaForAllocation());
}
inline std::string* Payload::_internal_mutable_guid() {
  
  return _impl_.guid_.Mutable(GetArenaForAllocation());
}
inline std::string* Payload::release_guid() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Payload.GUID)
  return _impl_.guid_.Release();
}
inline void Payload::set_allocated_guid(std::string* guid) {
  if (guid != nullptr) {
    
  } else {
    
  }
  _impl_.guid_.SetAllocated(guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.guid_.IsDefault()) {
    _impl_.guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Payload.GUID)
}

// string name = 2;
inline void Payload::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Payload::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Payload::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.name)
}
inline std::string* Payload::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.name)
  return _s;
}
inline const std::string& Payload::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Payload::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Payload::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Payload::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Payload.name)
  return _impl_.name_.Release();
}
inline void Payload::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Payload.name)
}

// string description = 3;
inline void Payload::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Payload::description() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Payload::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.description)
}
inline std::string* Payload::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.description)
  return _s;
}
inline const std::string& Payload::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Payload::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Payload::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Payload::release_description() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Payload.description)
  return _impl_.description_.Release();
}
inline void Payload::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Payload.description)
}

// repeated string label_prefix = 9;
inline int Payload::_internal_label_prefix_size() const {
  return _impl_.label_prefix_.size();
}
inline int Payload::label_prefix_size() const {
  return _internal_label_prefix_size();
}
inline void Payload::clear_label_prefix() {
  _impl_.label_prefix_.Clear();
}
inline std::string* Payload::add_label_prefix() {
  std::string* _s = _internal_add_label_prefix();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.Payload.label_prefix)
  return _s;
}
inline const std::string& Payload::_internal_label_prefix(int index) const {
  return _impl_.label_prefix_.Get(index);
}
inline const std::string& Payload::label_prefix(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.label_prefix)
  return _internal_label_prefix(index);
}
inline std::string* Payload::mutable_label_prefix(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.label_prefix)
  return _impl_.label_prefix_.Mutable(index);
}
inline void Payload::set_label_prefix(int index, const std::string& value) {
  _impl_.label_prefix_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.label_prefix)
}
inline void Payload::set_label_prefix(int index, std::string&& value) {
  _impl_.label_prefix_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.label_prefix)
}
inline void Payload::set_label_prefix(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.label_prefix_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.Payload.label_prefix)
}
inline void Payload::set_label_prefix(int index, const char* value, size_t size) {
  _impl_.label_prefix_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.Payload.label_prefix)
}
inline std::string* Payload::_internal_add_label_prefix() {
  return _impl_.label_prefix_.Add();
}
inline void Payload::add_label_prefix(const std::string& value) {
  _impl_.label_prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.Payload.label_prefix)
}
inline void Payload::add_label_prefix(std::string&& value) {
  _impl_.label_prefix_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.Payload.label_prefix)
}
inline void Payload::add_label_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.label_prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.Payload.label_prefix)
}
inline void Payload::add_label_prefix(const char* value, size_t size) {
  _impl_.label_prefix_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.Payload.label_prefix)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Payload::label_prefix() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.Payload.label_prefix)
  return _impl_.label_prefix_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Payload::mutable_label_prefix() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.Payload.label_prefix)
  return &_impl_.label_prefix_;
}

// bool is_authorized = 4;
inline void Payload::clear_is_authorized() {
  _impl_.is_authorized_ = false;
}
inline bool Payload::_internal_is_authorized() const {
  return _impl_.is_authorized_;
}
inline bool Payload::is_authorized() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.is_authorized)
  return _internal_is_authorized();
}
inline void Payload::_internal_set_is_authorized(bool value) {
  
  _impl_.is_authorized_ = value;
}
inline void Payload::set_is_authorized(bool value) {
  _internal_set_is_authorized(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.is_authorized)
}

// bool is_enabled = 5;
inline void Payload::clear_is_enabled() {
  _impl_.is_enabled_ = false;
}
inline bool Payload::_internal_is_enabled() const {
  return _impl_.is_enabled_;
}
inline bool Payload::is_enabled() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.is_enabled)
  return _internal_is_enabled();
}
inline void Payload::_internal_set_is_enabled(bool value) {
  
  _impl_.is_enabled_ = value;
}
inline void Payload::set_is_enabled(bool value) {
  _internal_set_is_enabled(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.is_enabled)
}

// bool is_noncompute_payload = 6;
inline void Payload::clear_is_noncompute_payload() {
  _impl_.is_noncompute_payload_ = false;
}
inline bool Payload::_internal_is_noncompute_payload() const {
  return _impl_.is_noncompute_payload_;
}
inline bool Payload::is_noncompute_payload() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.is_noncompute_payload)
  return _internal_is_noncompute_payload();
}
inline void Payload::_internal_set_is_noncompute_payload(bool value) {
  
  _impl_.is_noncompute_payload_ = value;
}
inline void Payload::set_is_noncompute_payload(bool value) {
  _internal_set_is_noncompute_payload(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.is_noncompute_payload)
}

// .bosdyn.api.SoftwareVersion version = 12;
inline bool Payload::_internal_has_version() const {
  return this != internal_default_instance() && _impl_.version_ != nullptr;
}
inline bool Payload::has_version() const {
  return _internal_has_version();
}
inline const ::bosdyn::api::SoftwareVersion& Payload::_internal_version() const {
  const ::bosdyn::api::SoftwareVersion* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SoftwareVersion&>(
      ::bosdyn::api::_SoftwareVersion_default_instance_);
}
inline const ::bosdyn::api::SoftwareVersion& Payload::version() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.version)
  return _internal_version();
}
inline void Payload::unsafe_arena_set_allocated_version(
    ::bosdyn::api::SoftwareVersion* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Payload.version)
}
inline ::bosdyn::api::SoftwareVersion* Payload::release_version() {
  
  ::bosdyn::api::SoftwareVersion* temp = _impl_.version_;
  _impl_.version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SoftwareVersion* Payload::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Payload.version)
  
  ::bosdyn::api::SoftwareVersion* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SoftwareVersion* Payload::_internal_mutable_version() {
  
  if (_impl_.version_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SoftwareVersion>(GetArenaForAllocation());
    _impl_.version_ = p;
  }
  return _impl_.version_;
}
inline ::bosdyn::api::SoftwareVersion* Payload::mutable_version() {
  ::bosdyn::api::SoftwareVersion* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.version)
  return _msg;
}
inline void Payload::set_allocated_version(::bosdyn::api::SoftwareVersion* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_);
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version));
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.version_ = version;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Payload.version)
}

// .bosdyn.api.SE3Pose body_tform_payload = 7;
inline bool Payload::_internal_has_body_tform_payload() const {
  return this != internal_default_instance() && _impl_.body_tform_payload_ != nullptr;
}
inline bool Payload::has_body_tform_payload() const {
  return _internal_has_body_tform_payload();
}
inline const ::bosdyn::api::SE3Pose& Payload::_internal_body_tform_payload() const {
  const ::bosdyn::api::SE3Pose* p = _impl_.body_tform_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Pose&>(
      ::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& Payload::body_tform_payload() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.body_tform_payload)
  return _internal_body_tform_payload();
}
inline void Payload::unsafe_arena_set_allocated_body_tform_payload(
    ::bosdyn::api::SE3Pose* body_tform_payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_tform_payload_);
  }
  _impl_.body_tform_payload_ = body_tform_payload;
  if (body_tform_payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Payload.body_tform_payload)
}
inline ::bosdyn::api::SE3Pose* Payload::release_body_tform_payload() {
  
  ::bosdyn::api::SE3Pose* temp = _impl_.body_tform_payload_;
  _impl_.body_tform_payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Pose* Payload::unsafe_arena_release_body_tform_payload() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Payload.body_tform_payload)
  
  ::bosdyn::api::SE3Pose* temp = _impl_.body_tform_payload_;
  _impl_.body_tform_payload_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* Payload::_internal_mutable_body_tform_payload() {
  
  if (_impl_.body_tform_payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArenaForAllocation());
    _impl_.body_tform_payload_ = p;
  }
  return _impl_.body_tform_payload_;
}
inline ::bosdyn::api::SE3Pose* Payload::mutable_body_tform_payload() {
  ::bosdyn::api::SE3Pose* _msg = _internal_mutable_body_tform_payload();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.body_tform_payload)
  return _msg;
}
inline void Payload::set_allocated_body_tform_payload(::bosdyn::api::SE3Pose* body_tform_payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_tform_payload_);
  }
  if (body_tform_payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(body_tform_payload));
    if (message_arena != submessage_arena) {
      body_tform_payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_tform_payload, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.body_tform_payload_ = body_tform_payload;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Payload.body_tform_payload)
}

// .bosdyn.api.SE3Pose mount_tform_payload = 8;
inline bool Payload::_internal_has_mount_tform_payload() const {
  return this != internal_default_instance() && _impl_.mount_tform_payload_ != nullptr;
}
inline bool Payload::has_mount_tform_payload() const {
  return _internal_has_mount_tform_payload();
}
inline const ::bosdyn::api::SE3Pose& Payload::_internal_mount_tform_payload() const {
  const ::bosdyn::api::SE3Pose* p = _impl_.mount_tform_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Pose&>(
      ::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& Payload::mount_tform_payload() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.mount_tform_payload)
  return _internal_mount_tform_payload();
}
inline void Payload::unsafe_arena_set_allocated_mount_tform_payload(
    ::bosdyn::api::SE3Pose* mount_tform_payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mount_tform_payload_);
  }
  _impl_.mount_tform_payload_ = mount_tform_payload;
  if (mount_tform_payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Payload.mount_tform_payload)
}
inline ::bosdyn::api::SE3Pose* Payload::release_mount_tform_payload() {
  
  ::bosdyn::api::SE3Pose* temp = _impl_.mount_tform_payload_;
  _impl_.mount_tform_payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Pose* Payload::unsafe_arena_release_mount_tform_payload() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Payload.mount_tform_payload)
  
  ::bosdyn::api::SE3Pose* temp = _impl_.mount_tform_payload_;
  _impl_.mount_tform_payload_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* Payload::_internal_mutable_mount_tform_payload() {
  
  if (_impl_.mount_tform_payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArenaForAllocation());
    _impl_.mount_tform_payload_ = p;
  }
  return _impl_.mount_tform_payload_;
}
inline ::bosdyn::api::SE3Pose* Payload::mutable_mount_tform_payload() {
  ::bosdyn::api::SE3Pose* _msg = _internal_mutable_mount_tform_payload();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.mount_tform_payload)
  return _msg;
}
inline void Payload::set_allocated_mount_tform_payload(::bosdyn::api::SE3Pose* mount_tform_payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mount_tform_payload_);
  }
  if (mount_tform_payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mount_tform_payload));
    if (message_arena != submessage_arena) {
      mount_tform_payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mount_tform_payload, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mount_tform_payload_ = mount_tform_payload;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Payload.mount_tform_payload)
}

// .bosdyn.api.MountFrameName mount_frame_name = 13;
inline void Payload::clear_mount_frame_name() {
  _impl_.mount_frame_name_ = 0;
}
inline ::bosdyn::api::MountFrameName Payload::_internal_mount_frame_name() const {
  return static_cast< ::bosdyn::api::MountFrameName >(_impl_.mount_frame_name_);
}
inline ::bosdyn::api::MountFrameName Payload::mount_frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.mount_frame_name)
  return _internal_mount_frame_name();
}
inline void Payload::_internal_set_mount_frame_name(::bosdyn::api::MountFrameName value) {
  
  _impl_.mount_frame_name_ = value;
}
inline void Payload::set_mount_frame_name(::bosdyn::api::MountFrameName value) {
  _internal_set_mount_frame_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.mount_frame_name)
}

// .bosdyn.api.PayloadMassVolumeProperties mass_volume_properties = 10;
inline bool Payload::_internal_has_mass_volume_properties() const {
  return this != internal_default_instance() && _impl_.mass_volume_properties_ != nullptr;
}
inline bool Payload::has_mass_volume_properties() const {
  return _internal_has_mass_volume_properties();
}
inline void Payload::clear_mass_volume_properties() {
  if (GetArenaForAllocation() == nullptr && _impl_.mass_volume_properties_ != nullptr) {
    delete _impl_.mass_volume_properties_;
  }
  _impl_.mass_volume_properties_ = nullptr;
}
inline const ::bosdyn::api::PayloadMassVolumeProperties& Payload::_internal_mass_volume_properties() const {
  const ::bosdyn::api::PayloadMassVolumeProperties* p = _impl_.mass_volume_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::PayloadMassVolumeProperties&>(
      ::bosdyn::api::_PayloadMassVolumeProperties_default_instance_);
}
inline const ::bosdyn::api::PayloadMassVolumeProperties& Payload::mass_volume_properties() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.mass_volume_properties)
  return _internal_mass_volume_properties();
}
inline void Payload::unsafe_arena_set_allocated_mass_volume_properties(
    ::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mass_volume_properties_);
  }
  _impl_.mass_volume_properties_ = mass_volume_properties;
  if (mass_volume_properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Payload.mass_volume_properties)
}
inline ::bosdyn::api::PayloadMassVolumeProperties* Payload::release_mass_volume_properties() {
  
  ::bosdyn::api::PayloadMassVolumeProperties* temp = _impl_.mass_volume_properties_;
  _impl_.mass_volume_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::PayloadMassVolumeProperties* Payload::unsafe_arena_release_mass_volume_properties() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Payload.mass_volume_properties)
  
  ::bosdyn::api::PayloadMassVolumeProperties* temp = _impl_.mass_volume_properties_;
  _impl_.mass_volume_properties_ = nullptr;
  return temp;
}
inline ::bosdyn::api::PayloadMassVolumeProperties* Payload::_internal_mutable_mass_volume_properties() {
  
  if (_impl_.mass_volume_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::PayloadMassVolumeProperties>(GetArenaForAllocation());
    _impl_.mass_volume_properties_ = p;
  }
  return _impl_.mass_volume_properties_;
}
inline ::bosdyn::api::PayloadMassVolumeProperties* Payload::mutable_mass_volume_properties() {
  ::bosdyn::api::PayloadMassVolumeProperties* _msg = _internal_mutable_mass_volume_properties();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.mass_volume_properties)
  return _msg;
}
inline void Payload::set_allocated_mass_volume_properties(::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mass_volume_properties_;
  }
  if (mass_volume_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mass_volume_properties);
    if (message_arena != submessage_arena) {
      mass_volume_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mass_volume_properties, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mass_volume_properties_ = mass_volume_properties;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Payload.mass_volume_properties)
}

// repeated .bosdyn.api.PayloadPreset preset_configurations = 11;
inline int Payload::_internal_preset_configurations_size() const {
  return _impl_.preset_configurations_.size();
}
inline int Payload::preset_configurations_size() const {
  return _internal_preset_configurations_size();
}
inline void Payload::clear_preset_configurations() {
  _impl_.preset_configurations_.Clear();
}
inline ::bosdyn::api::PayloadPreset* Payload::mutable_preset_configurations(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.preset_configurations)
  return _impl_.preset_configurations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PayloadPreset >*
Payload::mutable_preset_configurations() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.Payload.preset_configurations)
  return &_impl_.preset_configurations_;
}
inline const ::bosdyn::api::PayloadPreset& Payload::_internal_preset_configurations(int index) const {
  return _impl_.preset_configurations_.Get(index);
}
inline const ::bosdyn::api::PayloadPreset& Payload::preset_configurations(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.preset_configurations)
  return _internal_preset_configurations(index);
}
inline ::bosdyn::api::PayloadPreset* Payload::_internal_add_preset_configurations() {
  return _impl_.preset_configurations_.Add();
}
inline ::bosdyn::api::PayloadPreset* Payload::add_preset_configurations() {
  ::bosdyn::api::PayloadPreset* _add = _internal_add_preset_configurations();
  // @@protoc_insertion_point(field_add:bosdyn.api.Payload.preset_configurations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PayloadPreset >&
Payload::preset_configurations() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.Payload.preset_configurations)
  return _impl_.preset_configurations_;
}

// -------------------------------------------------------------------

// PayloadPreset

// string preset_name = 1;
inline void PayloadPreset::clear_preset_name() {
  _impl_.preset_name_.ClearToEmpty();
}
inline const std::string& PayloadPreset::preset_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadPreset.preset_name)
  return _internal_preset_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PayloadPreset::set_preset_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.preset_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.PayloadPreset.preset_name)
}
inline std::string* PayloadPreset::mutable_preset_name() {
  std::string* _s = _internal_mutable_preset_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadPreset.preset_name)
  return _s;
}
inline const std::string& PayloadPreset::_internal_preset_name() const {
  return _impl_.preset_name_.Get();
}
inline void PayloadPreset::_internal_set_preset_name(const std::string& value) {
  
  _impl_.preset_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PayloadPreset::_internal_mutable_preset_name() {
  
  return _impl_.preset_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PayloadPreset::release_preset_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PayloadPreset.preset_name)
  return _impl_.preset_name_.Release();
}
inline void PayloadPreset::set_allocated_preset_name(std::string* preset_name) {
  if (preset_name != nullptr) {
    
  } else {
    
  }
  _impl_.preset_name_.SetAllocated(preset_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.preset_name_.IsDefault()) {
    _impl_.preset_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PayloadPreset.preset_name)
}

// string description = 2;
inline void PayloadPreset::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& PayloadPreset::description() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadPreset.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PayloadPreset::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.PayloadPreset.description)
}
inline std::string* PayloadPreset::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadPreset.description)
  return _s;
}
inline const std::string& PayloadPreset::_internal_description() const {
  return _impl_.description_.Get();
}
inline void PayloadPreset::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* PayloadPreset::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* PayloadPreset::release_description() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PayloadPreset.description)
  return _impl_.description_.Release();
}
inline void PayloadPreset::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PayloadPreset.description)
}

// .bosdyn.api.SE3Pose mount_tform_payload = 3;
inline bool PayloadPreset::_internal_has_mount_tform_payload() const {
  return this != internal_default_instance() && _impl_.mount_tform_payload_ != nullptr;
}
inline bool PayloadPreset::has_mount_tform_payload() const {
  return _internal_has_mount_tform_payload();
}
inline const ::bosdyn::api::SE3Pose& PayloadPreset::_internal_mount_tform_payload() const {
  const ::bosdyn::api::SE3Pose* p = _impl_.mount_tform_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Pose&>(
      ::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& PayloadPreset::mount_tform_payload() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadPreset.mount_tform_payload)
  return _internal_mount_tform_payload();
}
inline void PayloadPreset::unsafe_arena_set_allocated_mount_tform_payload(
    ::bosdyn::api::SE3Pose* mount_tform_payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mount_tform_payload_);
  }
  _impl_.mount_tform_payload_ = mount_tform_payload;
  if (mount_tform_payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PayloadPreset.mount_tform_payload)
}
inline ::bosdyn::api::SE3Pose* PayloadPreset::release_mount_tform_payload() {
  
  ::bosdyn::api::SE3Pose* temp = _impl_.mount_tform_payload_;
  _impl_.mount_tform_payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Pose* PayloadPreset::unsafe_arena_release_mount_tform_payload() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PayloadPreset.mount_tform_payload)
  
  ::bosdyn::api::SE3Pose* temp = _impl_.mount_tform_payload_;
  _impl_.mount_tform_payload_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* PayloadPreset::_internal_mutable_mount_tform_payload() {
  
  if (_impl_.mount_tform_payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArenaForAllocation());
    _impl_.mount_tform_payload_ = p;
  }
  return _impl_.mount_tform_payload_;
}
inline ::bosdyn::api::SE3Pose* PayloadPreset::mutable_mount_tform_payload() {
  ::bosdyn::api::SE3Pose* _msg = _internal_mutable_mount_tform_payload();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadPreset.mount_tform_payload)
  return _msg;
}
inline void PayloadPreset::set_allocated_mount_tform_payload(::bosdyn::api::SE3Pose* mount_tform_payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mount_tform_payload_);
  }
  if (mount_tform_payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mount_tform_payload));
    if (message_arena != submessage_arena) {
      mount_tform_payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mount_tform_payload, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mount_tform_payload_ = mount_tform_payload;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PayloadPreset.mount_tform_payload)
}

// .bosdyn.api.MountFrameName mount_frame_name = 6;
inline void PayloadPreset::clear_mount_frame_name() {
  _impl_.mount_frame_name_ = 0;
}
inline ::bosdyn::api::MountFrameName PayloadPreset::_internal_mount_frame_name() const {
  return static_cast< ::bosdyn::api::MountFrameName >(_impl_.mount_frame_name_);
}
inline ::bosdyn::api::MountFrameName PayloadPreset::mount_frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadPreset.mount_frame_name)
  return _internal_mount_frame_name();
}
inline void PayloadPreset::_internal_set_mount_frame_name(::bosdyn::api::MountFrameName value) {
  
  _impl_.mount_frame_name_ = value;
}
inline void PayloadPreset::set_mount_frame_name(::bosdyn::api::MountFrameName value) {
  _internal_set_mount_frame_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PayloadPreset.mount_frame_name)
}

// .bosdyn.api.PayloadMassVolumeProperties mass_volume_properties = 4;
inline bool PayloadPreset::_internal_has_mass_volume_properties() const {
  return this != internal_default_instance() && _impl_.mass_volume_properties_ != nullptr;
}
inline bool PayloadPreset::has_mass_volume_properties() const {
  return _internal_has_mass_volume_properties();
}
inline void PayloadPreset::clear_mass_volume_properties() {
  if (GetArenaForAllocation() == nullptr && _impl_.mass_volume_properties_ != nullptr) {
    delete _impl_.mass_volume_properties_;
  }
  _impl_.mass_volume_properties_ = nullptr;
}
inline const ::bosdyn::api::PayloadMassVolumeProperties& PayloadPreset::_internal_mass_volume_properties() const {
  const ::bosdyn::api::PayloadMassVolumeProperties* p = _impl_.mass_volume_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::PayloadMassVolumeProperties&>(
      ::bosdyn::api::_PayloadMassVolumeProperties_default_instance_);
}
inline const ::bosdyn::api::PayloadMassVolumeProperties& PayloadPreset::mass_volume_properties() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadPreset.mass_volume_properties)
  return _internal_mass_volume_properties();
}
inline void PayloadPreset::unsafe_arena_set_allocated_mass_volume_properties(
    ::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mass_volume_properties_);
  }
  _impl_.mass_volume_properties_ = mass_volume_properties;
  if (mass_volume_properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PayloadPreset.mass_volume_properties)
}
inline ::bosdyn::api::PayloadMassVolumeProperties* PayloadPreset::release_mass_volume_properties() {
  
  ::bosdyn::api::PayloadMassVolumeProperties* temp = _impl_.mass_volume_properties_;
  _impl_.mass_volume_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::PayloadMassVolumeProperties* PayloadPreset::unsafe_arena_release_mass_volume_properties() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PayloadPreset.mass_volume_properties)
  
  ::bosdyn::api::PayloadMassVolumeProperties* temp = _impl_.mass_volume_properties_;
  _impl_.mass_volume_properties_ = nullptr;
  return temp;
}
inline ::bosdyn::api::PayloadMassVolumeProperties* PayloadPreset::_internal_mutable_mass_volume_properties() {
  
  if (_impl_.mass_volume_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::PayloadMassVolumeProperties>(GetArenaForAllocation());
    _impl_.mass_volume_properties_ = p;
  }
  return _impl_.mass_volume_properties_;
}
inline ::bosdyn::api::PayloadMassVolumeProperties* PayloadPreset::mutable_mass_volume_properties() {
  ::bosdyn::api::PayloadMassVolumeProperties* _msg = _internal_mutable_mass_volume_properties();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadPreset.mass_volume_properties)
  return _msg;
}
inline void PayloadPreset::set_allocated_mass_volume_properties(::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mass_volume_properties_;
  }
  if (mass_volume_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mass_volume_properties);
    if (message_arena != submessage_arena) {
      mass_volume_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mass_volume_properties, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mass_volume_properties_ = mass_volume_properties;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PayloadPreset.mass_volume_properties)
}

// repeated string label_prefix = 5;
inline int PayloadPreset::_internal_label_prefix_size() const {
  return _impl_.label_prefix_.size();
}
inline int PayloadPreset::label_prefix_size() const {
  return _internal_label_prefix_size();
}
inline void PayloadPreset::clear_label_prefix() {
  _impl_.label_prefix_.Clear();
}
inline std::string* PayloadPreset::add_label_prefix() {
  std::string* _s = _internal_add_label_prefix();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.PayloadPreset.label_prefix)
  return _s;
}
inline const std::string& PayloadPreset::_internal_label_prefix(int index) const {
  return _impl_.label_prefix_.Get(index);
}
inline const std::string& PayloadPreset::label_prefix(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadPreset.label_prefix)
  return _internal_label_prefix(index);
}
inline std::string* PayloadPreset::mutable_label_prefix(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadPreset.label_prefix)
  return _impl_.label_prefix_.Mutable(index);
}
inline void PayloadPreset::set_label_prefix(int index, const std::string& value) {
  _impl_.label_prefix_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PayloadPreset.label_prefix)
}
inline void PayloadPreset::set_label_prefix(int index, std::string&& value) {
  _impl_.label_prefix_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.PayloadPreset.label_prefix)
}
inline void PayloadPreset::set_label_prefix(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.label_prefix_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.PayloadPreset.label_prefix)
}
inline void PayloadPreset::set_label_prefix(int index, const char* value, size_t size) {
  _impl_.label_prefix_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.PayloadPreset.label_prefix)
}
inline std::string* PayloadPreset::_internal_add_label_prefix() {
  return _impl_.label_prefix_.Add();
}
inline void PayloadPreset::add_label_prefix(const std::string& value) {
  _impl_.label_prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.PayloadPreset.label_prefix)
}
inline void PayloadPreset::add_label_prefix(std::string&& value) {
  _impl_.label_prefix_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.PayloadPreset.label_prefix)
}
inline void PayloadPreset::add_label_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.label_prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.PayloadPreset.label_prefix)
}
inline void PayloadPreset::add_label_prefix(const char* value, size_t size) {
  _impl_.label_prefix_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.PayloadPreset.label_prefix)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PayloadPreset::label_prefix() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.PayloadPreset.label_prefix)
  return _impl_.label_prefix_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PayloadPreset::mutable_label_prefix() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.PayloadPreset.label_prefix)
  return &_impl_.label_prefix_;
}

// -------------------------------------------------------------------

// PayloadMassVolumeProperties

// float total_mass = 2;
inline void PayloadMassVolumeProperties::clear_total_mass() {
  _impl_.total_mass_ = 0;
}
inline float PayloadMassVolumeProperties::_internal_total_mass() const {
  return _impl_.total_mass_;
}
inline float PayloadMassVolumeProperties::total_mass() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadMassVolumeProperties.total_mass)
  return _internal_total_mass();
}
inline void PayloadMassVolumeProperties::_internal_set_total_mass(float value) {
  
  _impl_.total_mass_ = value;
}
inline void PayloadMassVolumeProperties::set_total_mass(float value) {
  _internal_set_total_mass(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PayloadMassVolumeProperties.total_mass)
}

// .bosdyn.api.Vec3 com_pos_rt_payload = 3;
inline bool PayloadMassVolumeProperties::_internal_has_com_pos_rt_payload() const {
  return this != internal_default_instance() && _impl_.com_pos_rt_payload_ != nullptr;
}
inline bool PayloadMassVolumeProperties::has_com_pos_rt_payload() const {
  return _internal_has_com_pos_rt_payload();
}
inline const ::bosdyn::api::Vec3& PayloadMassVolumeProperties::_internal_com_pos_rt_payload() const {
  const ::bosdyn::api::Vec3* p = _impl_.com_pos_rt_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& PayloadMassVolumeProperties::com_pos_rt_payload() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadMassVolumeProperties.com_pos_rt_payload)
  return _internal_com_pos_rt_payload();
}
inline void PayloadMassVolumeProperties::unsafe_arena_set_allocated_com_pos_rt_payload(
    ::bosdyn::api::Vec3* com_pos_rt_payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.com_pos_rt_payload_);
  }
  _impl_.com_pos_rt_payload_ = com_pos_rt_payload;
  if (com_pos_rt_payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PayloadMassVolumeProperties.com_pos_rt_payload)
}
inline ::bosdyn::api::Vec3* PayloadMassVolumeProperties::release_com_pos_rt_payload() {
  
  ::bosdyn::api::Vec3* temp = _impl_.com_pos_rt_payload_;
  _impl_.com_pos_rt_payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* PayloadMassVolumeProperties::unsafe_arena_release_com_pos_rt_payload() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PayloadMassVolumeProperties.com_pos_rt_payload)
  
  ::bosdyn::api::Vec3* temp = _impl_.com_pos_rt_payload_;
  _impl_.com_pos_rt_payload_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* PayloadMassVolumeProperties::_internal_mutable_com_pos_rt_payload() {
  
  if (_impl_.com_pos_rt_payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.com_pos_rt_payload_ = p;
  }
  return _impl_.com_pos_rt_payload_;
}
inline ::bosdyn::api::Vec3* PayloadMassVolumeProperties::mutable_com_pos_rt_payload() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_com_pos_rt_payload();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadMassVolumeProperties.com_pos_rt_payload)
  return _msg;
}
inline void PayloadMassVolumeProperties::set_allocated_com_pos_rt_payload(::bosdyn::api::Vec3* com_pos_rt_payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.com_pos_rt_payload_);
  }
  if (com_pos_rt_payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(com_pos_rt_payload));
    if (message_arena != submessage_arena) {
      com_pos_rt_payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, com_pos_rt_payload, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.com_pos_rt_payload_ = com_pos_rt_payload;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PayloadMassVolumeProperties.com_pos_rt_payload)
}

// .bosdyn.api.MomentOfIntertia moi_tensor = 4;
inline bool PayloadMassVolumeProperties::_internal_has_moi_tensor() const {
  return this != internal_default_instance() && _impl_.moi_tensor_ != nullptr;
}
inline bool PayloadMassVolumeProperties::has_moi_tensor() const {
  return _internal_has_moi_tensor();
}
inline void PayloadMassVolumeProperties::clear_moi_tensor() {
  if (GetArenaForAllocation() == nullptr && _impl_.moi_tensor_ != nullptr) {
    delete _impl_.moi_tensor_;
  }
  _impl_.moi_tensor_ = nullptr;
}
inline const ::bosdyn::api::MomentOfIntertia& PayloadMassVolumeProperties::_internal_moi_tensor() const {
  const ::bosdyn::api::MomentOfIntertia* p = _impl_.moi_tensor_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::MomentOfIntertia&>(
      ::bosdyn::api::_MomentOfIntertia_default_instance_);
}
inline const ::bosdyn::api::MomentOfIntertia& PayloadMassVolumeProperties::moi_tensor() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadMassVolumeProperties.moi_tensor)
  return _internal_moi_tensor();
}
inline void PayloadMassVolumeProperties::unsafe_arena_set_allocated_moi_tensor(
    ::bosdyn::api::MomentOfIntertia* moi_tensor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.moi_tensor_);
  }
  _impl_.moi_tensor_ = moi_tensor;
  if (moi_tensor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PayloadMassVolumeProperties.moi_tensor)
}
inline ::bosdyn::api::MomentOfIntertia* PayloadMassVolumeProperties::release_moi_tensor() {
  
  ::bosdyn::api::MomentOfIntertia* temp = _impl_.moi_tensor_;
  _impl_.moi_tensor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::MomentOfIntertia* PayloadMassVolumeProperties::unsafe_arena_release_moi_tensor() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PayloadMassVolumeProperties.moi_tensor)
  
  ::bosdyn::api::MomentOfIntertia* temp = _impl_.moi_tensor_;
  _impl_.moi_tensor_ = nullptr;
  return temp;
}
inline ::bosdyn::api::MomentOfIntertia* PayloadMassVolumeProperties::_internal_mutable_moi_tensor() {
  
  if (_impl_.moi_tensor_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::MomentOfIntertia>(GetArenaForAllocation());
    _impl_.moi_tensor_ = p;
  }
  return _impl_.moi_tensor_;
}
inline ::bosdyn::api::MomentOfIntertia* PayloadMassVolumeProperties::mutable_moi_tensor() {
  ::bosdyn::api::MomentOfIntertia* _msg = _internal_mutable_moi_tensor();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadMassVolumeProperties.moi_tensor)
  return _msg;
}
inline void PayloadMassVolumeProperties::set_allocated_moi_tensor(::bosdyn::api::MomentOfIntertia* moi_tensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.moi_tensor_;
  }
  if (moi_tensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(moi_tensor);
    if (message_arena != submessage_arena) {
      moi_tensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, moi_tensor, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.moi_tensor_ = moi_tensor;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PayloadMassVolumeProperties.moi_tensor)
}

// repeated .bosdyn.api.Box3WithFrame bounding_box = 5;
inline int PayloadMassVolumeProperties::_internal_bounding_box_size() const {
  return _impl_.bounding_box_.size();
}
inline int PayloadMassVolumeProperties::bounding_box_size() const {
  return _internal_bounding_box_size();
}
inline ::bosdyn::api::Box3WithFrame* PayloadMassVolumeProperties::mutable_bounding_box(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadMassVolumeProperties.bounding_box)
  return _impl_.bounding_box_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Box3WithFrame >*
PayloadMassVolumeProperties::mutable_bounding_box() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.PayloadMassVolumeProperties.bounding_box)
  return &_impl_.bounding_box_;
}
inline const ::bosdyn::api::Box3WithFrame& PayloadMassVolumeProperties::_internal_bounding_box(int index) const {
  return _impl_.bounding_box_.Get(index);
}
inline const ::bosdyn::api::Box3WithFrame& PayloadMassVolumeProperties::bounding_box(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadMassVolumeProperties.bounding_box)
  return _internal_bounding_box(index);
}
inline ::bosdyn::api::Box3WithFrame* PayloadMassVolumeProperties::_internal_add_bounding_box() {
  return _impl_.bounding_box_.Add();
}
inline ::bosdyn::api::Box3WithFrame* PayloadMassVolumeProperties::add_bounding_box() {
  ::bosdyn::api::Box3WithFrame* _add = _internal_add_bounding_box();
  // @@protoc_insertion_point(field_add:bosdyn.api.PayloadMassVolumeProperties.bounding_box)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Box3WithFrame >&
PayloadMassVolumeProperties::bounding_box() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.PayloadMassVolumeProperties.bounding_box)
  return _impl_.bounding_box_;
}

// repeated .bosdyn.api.JointLimits joint_limits = 6;
inline int PayloadMassVolumeProperties::_internal_joint_limits_size() const {
  return _impl_.joint_limits_.size();
}
inline int PayloadMassVolumeProperties::joint_limits_size() const {
  return _internal_joint_limits_size();
}
inline void PayloadMassVolumeProperties::clear_joint_limits() {
  _impl_.joint_limits_.Clear();
}
inline ::bosdyn::api::JointLimits* PayloadMassVolumeProperties::mutable_joint_limits(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadMassVolumeProperties.joint_limits)
  return _impl_.joint_limits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointLimits >*
PayloadMassVolumeProperties::mutable_joint_limits() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.PayloadMassVolumeProperties.joint_limits)
  return &_impl_.joint_limits_;
}
inline const ::bosdyn::api::JointLimits& PayloadMassVolumeProperties::_internal_joint_limits(int index) const {
  return _impl_.joint_limits_.Get(index);
}
inline const ::bosdyn::api::JointLimits& PayloadMassVolumeProperties::joint_limits(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadMassVolumeProperties.joint_limits)
  return _internal_joint_limits(index);
}
inline ::bosdyn::api::JointLimits* PayloadMassVolumeProperties::_internal_add_joint_limits() {
  return _impl_.joint_limits_.Add();
}
inline ::bosdyn::api::JointLimits* PayloadMassVolumeProperties::add_joint_limits() {
  ::bosdyn::api::JointLimits* _add = _internal_add_joint_limits();
  // @@protoc_insertion_point(field_add:bosdyn.api.PayloadMassVolumeProperties.joint_limits)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointLimits >&
PayloadMassVolumeProperties::joint_limits() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.PayloadMassVolumeProperties.joint_limits)
  return _impl_.joint_limits_;
}

// -------------------------------------------------------------------

// MomentOfIntertia

// float xx = 2;
inline void MomentOfIntertia::clear_xx() {
  _impl_.xx_ = 0;
}
inline float MomentOfIntertia::_internal_xx() const {
  return _impl_.xx_;
}
inline float MomentOfIntertia::xx() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MomentOfIntertia.xx)
  return _internal_xx();
}
inline void MomentOfIntertia::_internal_set_xx(float value) {
  
  _impl_.xx_ = value;
}
inline void MomentOfIntertia::set_xx(float value) {
  _internal_set_xx(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MomentOfIntertia.xx)
}

// float yy = 3;
inline void MomentOfIntertia::clear_yy() {
  _impl_.yy_ = 0;
}
inline float MomentOfIntertia::_internal_yy() const {
  return _impl_.yy_;
}
inline float MomentOfIntertia::yy() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MomentOfIntertia.yy)
  return _internal_yy();
}
inline void MomentOfIntertia::_internal_set_yy(float value) {
  
  _impl_.yy_ = value;
}
inline void MomentOfIntertia::set_yy(float value) {
  _internal_set_yy(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MomentOfIntertia.yy)
}

// float zz = 4;
inline void MomentOfIntertia::clear_zz() {
  _impl_.zz_ = 0;
}
inline float MomentOfIntertia::_internal_zz() const {
  return _impl_.zz_;
}
inline float MomentOfIntertia::zz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MomentOfIntertia.zz)
  return _internal_zz();
}
inline void MomentOfIntertia::_internal_set_zz(float value) {
  
  _impl_.zz_ = value;
}
inline void MomentOfIntertia::set_zz(float value) {
  _internal_set_zz(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MomentOfIntertia.zz)
}

// float xy = 5;
inline void MomentOfIntertia::clear_xy() {
  _impl_.xy_ = 0;
}
inline float MomentOfIntertia::_internal_xy() const {
  return _impl_.xy_;
}
inline float MomentOfIntertia::xy() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MomentOfIntertia.xy)
  return _internal_xy();
}
inline void MomentOfIntertia::_internal_set_xy(float value) {
  
  _impl_.xy_ = value;
}
inline void MomentOfIntertia::set_xy(float value) {
  _internal_set_xy(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MomentOfIntertia.xy)
}

// float xz = 6;
inline void MomentOfIntertia::clear_xz() {
  _impl_.xz_ = 0;
}
inline float MomentOfIntertia::_internal_xz() const {
  return _impl_.xz_;
}
inline float MomentOfIntertia::xz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MomentOfIntertia.xz)
  return _internal_xz();
}
inline void MomentOfIntertia::_internal_set_xz(float value) {
  
  _impl_.xz_ = value;
}
inline void MomentOfIntertia::set_xz(float value) {
  _internal_set_xz(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MomentOfIntertia.xz)
}

// float yz = 7;
inline void MomentOfIntertia::clear_yz() {
  _impl_.yz_ = 0;
}
inline float MomentOfIntertia::_internal_yz() const {
  return _impl_.yz_;
}
inline float MomentOfIntertia::yz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MomentOfIntertia.yz)
  return _internal_yz();
}
inline void MomentOfIntertia::_internal_set_yz(float value) {
  
  _impl_.yz_ = value;
}
inline void MomentOfIntertia::set_yz(float value) {
  _internal_set_yz(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MomentOfIntertia.yz)
}

// -------------------------------------------------------------------

// JointLimits

// string label = 2;
inline void JointLimits::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& JointLimits::label() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.JointLimits.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JointLimits::set_label(ArgT0&& arg0, ArgT... args) {
 
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.JointLimits.label)
}
inline std::string* JointLimits::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.JointLimits.label)
  return _s;
}
inline const std::string& JointLimits::_internal_label() const {
  return _impl_.label_.Get();
}
inline void JointLimits::_internal_set_label(const std::string& value) {
  
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* JointLimits::_internal_mutable_label() {
  
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* JointLimits::release_label() {
  // @@protoc_insertion_point(field_release:bosdyn.api.JointLimits.label)
  return _impl_.label_.Release();
}
inline void JointLimits::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.JointLimits.label)
}

// repeated float hy = 3;
inline int JointLimits::_internal_hy_size() const {
  return _impl_.hy_.size();
}
inline int JointLimits::hy_size() const {
  return _internal_hy_size();
}
inline void JointLimits::clear_hy() {
  _impl_.hy_.Clear();
}
inline float JointLimits::_internal_hy(int index) const {
  return _impl_.hy_.Get(index);
}
inline float JointLimits::hy(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.JointLimits.hy)
  return _internal_hy(index);
}
inline void JointLimits::set_hy(int index, float value) {
  _impl_.hy_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.JointLimits.hy)
}
inline void JointLimits::_internal_add_hy(float value) {
  _impl_.hy_.Add(value);
}
inline void JointLimits::add_hy(float value) {
  _internal_add_hy(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.JointLimits.hy)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointLimits::_internal_hy() const {
  return _impl_.hy_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointLimits::hy() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.JointLimits.hy)
  return _internal_hy();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointLimits::_internal_mutable_hy() {
  return &_impl_.hy_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointLimits::mutable_hy() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.JointLimits.hy)
  return _internal_mutable_hy();
}

// repeated float hx = 4;
inline int JointLimits::_internal_hx_size() const {
  return _impl_.hx_.size();
}
inline int JointLimits::hx_size() const {
  return _internal_hx_size();
}
inline void JointLimits::clear_hx() {
  _impl_.hx_.Clear();
}
inline float JointLimits::_internal_hx(int index) const {
  return _impl_.hx_.Get(index);
}
inline float JointLimits::hx(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.JointLimits.hx)
  return _internal_hx(index);
}
inline void JointLimits::set_hx(int index, float value) {
  _impl_.hx_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.JointLimits.hx)
}
inline void JointLimits::_internal_add_hx(float value) {
  _impl_.hx_.Add(value);
}
inline void JointLimits::add_hx(float value) {
  _internal_add_hx(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.JointLimits.hx)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointLimits::_internal_hx() const {
  return _impl_.hx_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointLimits::hx() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.JointLimits.hx)
  return _internal_hx();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointLimits::_internal_mutable_hx() {
  return &_impl_.hx_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointLimits::mutable_hx() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.JointLimits.hx)
  return _internal_mutable_hx();
}

// -------------------------------------------------------------------

// ListPayloadsRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListPayloadsRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListPayloadsRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListPayloadsRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListPayloadsRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListPayloadsRequest.header)
  return _internal_header();
}
inline void ListPayloadsRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListPayloadsRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListPayloadsRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListPayloadsRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListPayloadsRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListPayloadsRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ListPayloadsRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListPayloadsRequest.header)
  return _msg;
}
inline void ListPayloadsRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListPayloadsRequest.header)
}

// -------------------------------------------------------------------

// ListPayloadsResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListPayloadsResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListPayloadsResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListPayloadsResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListPayloadsResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListPayloadsResponse.header)
  return _internal_header();
}
inline void ListPayloadsResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListPayloadsResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListPayloadsResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListPayloadsResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListPayloadsResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListPayloadsResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ListPayloadsResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListPayloadsResponse.header)
  return _msg;
}
inline void ListPayloadsResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListPayloadsResponse.header)
}

// repeated .bosdyn.api.Payload payloads = 2;
inline int ListPayloadsResponse::_internal_payloads_size() const {
  return _impl_.payloads_.size();
}
inline int ListPayloadsResponse::payloads_size() const {
  return _internal_payloads_size();
}
inline void ListPayloadsResponse::clear_payloads() {
  _impl_.payloads_.Clear();
}
inline ::bosdyn::api::Payload* ListPayloadsResponse::mutable_payloads(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListPayloadsResponse.payloads)
  return _impl_.payloads_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Payload >*
ListPayloadsResponse::mutable_payloads() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ListPayloadsResponse.payloads)
  return &_impl_.payloads_;
}
inline const ::bosdyn::api::Payload& ListPayloadsResponse::_internal_payloads(int index) const {
  return _impl_.payloads_.Get(index);
}
inline const ::bosdyn::api::Payload& ListPayloadsResponse::payloads(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListPayloadsResponse.payloads)
  return _internal_payloads(index);
}
inline ::bosdyn::api::Payload* ListPayloadsResponse::_internal_add_payloads() {
  return _impl_.payloads_.Add();
}
inline ::bosdyn::api::Payload* ListPayloadsResponse::add_payloads() {
  ::bosdyn::api::Payload* _add = _internal_add_payloads();
  // @@protoc_insertion_point(field_add:bosdyn.api.ListPayloadsResponse.payloads)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Payload >&
ListPayloadsResponse::payloads() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ListPayloadsResponse.payloads)
  return _impl_.payloads_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::MountFrameName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::MountFrameName>() {
  return ::bosdyn::api::MountFrameName_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fpayload_2eproto
