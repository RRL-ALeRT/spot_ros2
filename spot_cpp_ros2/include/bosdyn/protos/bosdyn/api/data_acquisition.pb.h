// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/data_acquisition.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fdata_5facquisition_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fdata_5facquisition_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/alerts.pb.h"
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/image.pb.h"
#include "bosdyn/api/network_compute_bridge.pb.h"
#include <google/protobuf/any.pb.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fdata_5facquisition_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fdata_5facquisition_2eproto;
namespace bosdyn {
namespace api {
class AcquireDataRequest;
struct AcquireDataRequestDefaultTypeInternal;
extern AcquireDataRequestDefaultTypeInternal _AcquireDataRequest_default_instance_;
class AcquireDataResponse;
struct AcquireDataResponseDefaultTypeInternal;
extern AcquireDataResponseDefaultTypeInternal _AcquireDataResponse_default_instance_;
class AcquirePluginDataRequest;
struct AcquirePluginDataRequestDefaultTypeInternal;
extern AcquirePluginDataRequestDefaultTypeInternal _AcquirePluginDataRequest_default_instance_;
class AcquirePluginDataResponse;
struct AcquirePluginDataResponseDefaultTypeInternal;
extern AcquirePluginDataResponseDefaultTypeInternal _AcquirePluginDataResponse_default_instance_;
class AcquisitionCapabilityList;
struct AcquisitionCapabilityListDefaultTypeInternal;
extern AcquisitionCapabilityListDefaultTypeInternal _AcquisitionCapabilityList_default_instance_;
class AcquisitionRequestList;
struct AcquisitionRequestListDefaultTypeInternal;
extern AcquisitionRequestListDefaultTypeInternal _AcquisitionRequestList_default_instance_;
class AssociatedAlertData;
struct AssociatedAlertDataDefaultTypeInternal;
extern AssociatedAlertDataDefaultTypeInternal _AssociatedAlertData_default_instance_;
class AssociatedMetadata;
struct AssociatedMetadataDefaultTypeInternal;
extern AssociatedMetadataDefaultTypeInternal _AssociatedMetadata_default_instance_;
class CancelAcquisitionRequest;
struct CancelAcquisitionRequestDefaultTypeInternal;
extern CancelAcquisitionRequestDefaultTypeInternal _CancelAcquisitionRequest_default_instance_;
class CancelAcquisitionResponse;
struct CancelAcquisitionResponseDefaultTypeInternal;
extern CancelAcquisitionResponseDefaultTypeInternal _CancelAcquisitionResponse_default_instance_;
class CaptureActionId;
struct CaptureActionIdDefaultTypeInternal;
extern CaptureActionIdDefaultTypeInternal _CaptureActionId_default_instance_;
class DataAcquisitionCapability;
struct DataAcquisitionCapabilityDefaultTypeInternal;
extern DataAcquisitionCapabilityDefaultTypeInternal _DataAcquisitionCapability_default_instance_;
class DataCapture;
struct DataCaptureDefaultTypeInternal;
extern DataCaptureDefaultTypeInternal _DataCapture_default_instance_;
class DataError;
struct DataErrorDefaultTypeInternal;
extern DataErrorDefaultTypeInternal _DataError_default_instance_;
class DataIdentifier;
struct DataIdentifierDefaultTypeInternal;
extern DataIdentifierDefaultTypeInternal _DataIdentifier_default_instance_;
class GetServiceInfoRequest;
struct GetServiceInfoRequestDefaultTypeInternal;
extern GetServiceInfoRequestDefaultTypeInternal _GetServiceInfoRequest_default_instance_;
class GetServiceInfoResponse;
struct GetServiceInfoResponseDefaultTypeInternal;
extern GetServiceInfoResponseDefaultTypeInternal _GetServiceInfoResponse_default_instance_;
class GetStatusRequest;
struct GetStatusRequestDefaultTypeInternal;
extern GetStatusRequestDefaultTypeInternal _GetStatusRequest_default_instance_;
class GetStatusResponse;
struct GetStatusResponseDefaultTypeInternal;
extern GetStatusResponseDefaultTypeInternal _GetStatusResponse_default_instance_;
class ImageAcquisitionCapability;
struct ImageAcquisitionCapabilityDefaultTypeInternal;
extern ImageAcquisitionCapabilityDefaultTypeInternal _ImageAcquisitionCapability_default_instance_;
class ImageSourceCapture;
struct ImageSourceCaptureDefaultTypeInternal;
extern ImageSourceCaptureDefaultTypeInternal _ImageSourceCapture_default_instance_;
class Metadata;
struct MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class NetworkComputeCapability;
struct NetworkComputeCapabilityDefaultTypeInternal;
extern NetworkComputeCapabilityDefaultTypeInternal _NetworkComputeCapability_default_instance_;
class NetworkComputeCapture;
struct NetworkComputeCaptureDefaultTypeInternal;
extern NetworkComputeCaptureDefaultTypeInternal _NetworkComputeCapture_default_instance_;
class NetworkComputeError;
struct NetworkComputeErrorDefaultTypeInternal;
extern NetworkComputeErrorDefaultTypeInternal _NetworkComputeError_default_instance_;
class PluginServiceError;
struct PluginServiceErrorDefaultTypeInternal;
extern PluginServiceErrorDefaultTypeInternal _PluginServiceError_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::AcquireDataRequest* Arena::CreateMaybeMessage<::bosdyn::api::AcquireDataRequest>(Arena*);
template<> ::bosdyn::api::AcquireDataResponse* Arena::CreateMaybeMessage<::bosdyn::api::AcquireDataResponse>(Arena*);
template<> ::bosdyn::api::AcquirePluginDataRequest* Arena::CreateMaybeMessage<::bosdyn::api::AcquirePluginDataRequest>(Arena*);
template<> ::bosdyn::api::AcquirePluginDataResponse* Arena::CreateMaybeMessage<::bosdyn::api::AcquirePluginDataResponse>(Arena*);
template<> ::bosdyn::api::AcquisitionCapabilityList* Arena::CreateMaybeMessage<::bosdyn::api::AcquisitionCapabilityList>(Arena*);
template<> ::bosdyn::api::AcquisitionRequestList* Arena::CreateMaybeMessage<::bosdyn::api::AcquisitionRequestList>(Arena*);
template<> ::bosdyn::api::AssociatedAlertData* Arena::CreateMaybeMessage<::bosdyn::api::AssociatedAlertData>(Arena*);
template<> ::bosdyn::api::AssociatedMetadata* Arena::CreateMaybeMessage<::bosdyn::api::AssociatedMetadata>(Arena*);
template<> ::bosdyn::api::CancelAcquisitionRequest* Arena::CreateMaybeMessage<::bosdyn::api::CancelAcquisitionRequest>(Arena*);
template<> ::bosdyn::api::CancelAcquisitionResponse* Arena::CreateMaybeMessage<::bosdyn::api::CancelAcquisitionResponse>(Arena*);
template<> ::bosdyn::api::CaptureActionId* Arena::CreateMaybeMessage<::bosdyn::api::CaptureActionId>(Arena*);
template<> ::bosdyn::api::DataAcquisitionCapability* Arena::CreateMaybeMessage<::bosdyn::api::DataAcquisitionCapability>(Arena*);
template<> ::bosdyn::api::DataCapture* Arena::CreateMaybeMessage<::bosdyn::api::DataCapture>(Arena*);
template<> ::bosdyn::api::DataError* Arena::CreateMaybeMessage<::bosdyn::api::DataError>(Arena*);
template<> ::bosdyn::api::DataIdentifier* Arena::CreateMaybeMessage<::bosdyn::api::DataIdentifier>(Arena*);
template<> ::bosdyn::api::GetServiceInfoRequest* Arena::CreateMaybeMessage<::bosdyn::api::GetServiceInfoRequest>(Arena*);
template<> ::bosdyn::api::GetServiceInfoResponse* Arena::CreateMaybeMessage<::bosdyn::api::GetServiceInfoResponse>(Arena*);
template<> ::bosdyn::api::GetStatusRequest* Arena::CreateMaybeMessage<::bosdyn::api::GetStatusRequest>(Arena*);
template<> ::bosdyn::api::GetStatusResponse* Arena::CreateMaybeMessage<::bosdyn::api::GetStatusResponse>(Arena*);
template<> ::bosdyn::api::ImageAcquisitionCapability* Arena::CreateMaybeMessage<::bosdyn::api::ImageAcquisitionCapability>(Arena*);
template<> ::bosdyn::api::ImageSourceCapture* Arena::CreateMaybeMessage<::bosdyn::api::ImageSourceCapture>(Arena*);
template<> ::bosdyn::api::Metadata* Arena::CreateMaybeMessage<::bosdyn::api::Metadata>(Arena*);
template<> ::bosdyn::api::NetworkComputeCapability* Arena::CreateMaybeMessage<::bosdyn::api::NetworkComputeCapability>(Arena*);
template<> ::bosdyn::api::NetworkComputeCapture* Arena::CreateMaybeMessage<::bosdyn::api::NetworkComputeCapture>(Arena*);
template<> ::bosdyn::api::NetworkComputeError* Arena::CreateMaybeMessage<::bosdyn::api::NetworkComputeError>(Arena*);
template<> ::bosdyn::api::PluginServiceError* Arena::CreateMaybeMessage<::bosdyn::api::PluginServiceError>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum PluginServiceError_ErrorCode : int {
  PluginServiceError_ErrorCode_STATUS_UNKNOWN = 0,
  PluginServiceError_ErrorCode_STATUS_REQUEST_ERROR = 1,
  PluginServiceError_ErrorCode_STATUS_GETSTATUS_ERROR = 2,
  PluginServiceError_ErrorCode_STATUS_INTERNAL_ERROR = 3,
  PluginServiceError_ErrorCode_PluginServiceError_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PluginServiceError_ErrorCode_PluginServiceError_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PluginServiceError_ErrorCode_IsValid(int value);
constexpr PluginServiceError_ErrorCode PluginServiceError_ErrorCode_ErrorCode_MIN = PluginServiceError_ErrorCode_STATUS_UNKNOWN;
constexpr PluginServiceError_ErrorCode PluginServiceError_ErrorCode_ErrorCode_MAX = PluginServiceError_ErrorCode_STATUS_INTERNAL_ERROR;
constexpr int PluginServiceError_ErrorCode_ErrorCode_ARRAYSIZE = PluginServiceError_ErrorCode_ErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PluginServiceError_ErrorCode_descriptor();
template<typename T>
inline const std::string& PluginServiceError_ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PluginServiceError_ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PluginServiceError_ErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PluginServiceError_ErrorCode_descriptor(), enum_t_value);
}
inline bool PluginServiceError_ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PluginServiceError_ErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PluginServiceError_ErrorCode>(
    PluginServiceError_ErrorCode_descriptor(), name, value);
}
enum NetworkComputeError_ErrorCode : int {
  NetworkComputeError_ErrorCode_STATUS_UNKNOWN = 0,
  NetworkComputeError_ErrorCode_STATUS_REQUEST_ERROR = 1,
  NetworkComputeError_ErrorCode_STATUS_NETWORK_ERROR = 2,
  NetworkComputeError_ErrorCode_STATUS_INTERNAL_ERROR = 3,
  NetworkComputeError_ErrorCode_NetworkComputeError_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NetworkComputeError_ErrorCode_NetworkComputeError_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NetworkComputeError_ErrorCode_IsValid(int value);
constexpr NetworkComputeError_ErrorCode NetworkComputeError_ErrorCode_ErrorCode_MIN = NetworkComputeError_ErrorCode_STATUS_UNKNOWN;
constexpr NetworkComputeError_ErrorCode NetworkComputeError_ErrorCode_ErrorCode_MAX = NetworkComputeError_ErrorCode_STATUS_INTERNAL_ERROR;
constexpr int NetworkComputeError_ErrorCode_ErrorCode_ARRAYSIZE = NetworkComputeError_ErrorCode_ErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NetworkComputeError_ErrorCode_descriptor();
template<typename T>
inline const std::string& NetworkComputeError_ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetworkComputeError_ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetworkComputeError_ErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NetworkComputeError_ErrorCode_descriptor(), enum_t_value);
}
inline bool NetworkComputeError_ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetworkComputeError_ErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NetworkComputeError_ErrorCode>(
    NetworkComputeError_ErrorCode_descriptor(), name, value);
}
enum AcquireDataResponse_Status : int {
  AcquireDataResponse_Status_STATUS_UNKNOWN = 0,
  AcquireDataResponse_Status_STATUS_OK = 1,
  AcquireDataResponse_Status_STATUS_UNKNOWN_CAPTURE_TYPE = 2,
  AcquireDataResponse_Status_AcquireDataResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AcquireDataResponse_Status_AcquireDataResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AcquireDataResponse_Status_IsValid(int value);
constexpr AcquireDataResponse_Status AcquireDataResponse_Status_Status_MIN = AcquireDataResponse_Status_STATUS_UNKNOWN;
constexpr AcquireDataResponse_Status AcquireDataResponse_Status_Status_MAX = AcquireDataResponse_Status_STATUS_UNKNOWN_CAPTURE_TYPE;
constexpr int AcquireDataResponse_Status_Status_ARRAYSIZE = AcquireDataResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AcquireDataResponse_Status_descriptor();
template<typename T>
inline const std::string& AcquireDataResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AcquireDataResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AcquireDataResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AcquireDataResponse_Status_descriptor(), enum_t_value);
}
inline bool AcquireDataResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AcquireDataResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AcquireDataResponse_Status>(
    AcquireDataResponse_Status_descriptor(), name, value);
}
enum AcquirePluginDataResponse_Status : int {
  AcquirePluginDataResponse_Status_STATUS_UNKNOWN = 0,
  AcquirePluginDataResponse_Status_STATUS_OK = 1,
  AcquirePluginDataResponse_Status_STATUS_UNKNOWN_CAPTURE_TYPE = 2,
  AcquirePluginDataResponse_Status_AcquirePluginDataResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AcquirePluginDataResponse_Status_AcquirePluginDataResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AcquirePluginDataResponse_Status_IsValid(int value);
constexpr AcquirePluginDataResponse_Status AcquirePluginDataResponse_Status_Status_MIN = AcquirePluginDataResponse_Status_STATUS_UNKNOWN;
constexpr AcquirePluginDataResponse_Status AcquirePluginDataResponse_Status_Status_MAX = AcquirePluginDataResponse_Status_STATUS_UNKNOWN_CAPTURE_TYPE;
constexpr int AcquirePluginDataResponse_Status_Status_ARRAYSIZE = AcquirePluginDataResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AcquirePluginDataResponse_Status_descriptor();
template<typename T>
inline const std::string& AcquirePluginDataResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AcquirePluginDataResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AcquirePluginDataResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AcquirePluginDataResponse_Status_descriptor(), enum_t_value);
}
inline bool AcquirePluginDataResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AcquirePluginDataResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AcquirePluginDataResponse_Status>(
    AcquirePluginDataResponse_Status_descriptor(), name, value);
}
enum GetStatusResponse_Status : int {
  GetStatusResponse_Status_STATUS_UNKNOWN = 0,
  GetStatusResponse_Status_STATUS_ACQUIRING = 1,
  GetStatusResponse_Status_STATUS_SAVING = 2,
  GetStatusResponse_Status_STATUS_COMPLETE = 3,
  GetStatusResponse_Status_STATUS_CANCEL_IN_PROGRESS = 4,
  GetStatusResponse_Status_STATUS_ACQUISITION_CANCELLED = 5,
  GetStatusResponse_Status_STATUS_DATA_ERROR = 10,
  GetStatusResponse_Status_STATUS_TIMEDOUT = 11,
  GetStatusResponse_Status_STATUS_INTERNAL_ERROR = 12,
  GetStatusResponse_Status_STATUS_CANCEL_ACQUISITION_FAILED = 30,
  GetStatusResponse_Status_STATUS_REQUEST_ID_DOES_NOT_EXIST = 20,
  GetStatusResponse_Status_GetStatusResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GetStatusResponse_Status_GetStatusResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GetStatusResponse_Status_IsValid(int value);
constexpr GetStatusResponse_Status GetStatusResponse_Status_Status_MIN = GetStatusResponse_Status_STATUS_UNKNOWN;
constexpr GetStatusResponse_Status GetStatusResponse_Status_Status_MAX = GetStatusResponse_Status_STATUS_CANCEL_ACQUISITION_FAILED;
constexpr int GetStatusResponse_Status_Status_ARRAYSIZE = GetStatusResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GetStatusResponse_Status_descriptor();
template<typename T>
inline const std::string& GetStatusResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GetStatusResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GetStatusResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GetStatusResponse_Status_descriptor(), enum_t_value);
}
inline bool GetStatusResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GetStatusResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GetStatusResponse_Status>(
    GetStatusResponse_Status_descriptor(), name, value);
}
enum CancelAcquisitionResponse_Status : int {
  CancelAcquisitionResponse_Status_STATUS_UNKNOWN = 0,
  CancelAcquisitionResponse_Status_STATUS_OK = 1,
  CancelAcquisitionResponse_Status_STATUS_FAILED_TO_CANCEL = 2,
  CancelAcquisitionResponse_Status_STATUS_REQUEST_ID_DOES_NOT_EXIST = 3,
  CancelAcquisitionResponse_Status_CancelAcquisitionResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CancelAcquisitionResponse_Status_CancelAcquisitionResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CancelAcquisitionResponse_Status_IsValid(int value);
constexpr CancelAcquisitionResponse_Status CancelAcquisitionResponse_Status_Status_MIN = CancelAcquisitionResponse_Status_STATUS_UNKNOWN;
constexpr CancelAcquisitionResponse_Status CancelAcquisitionResponse_Status_Status_MAX = CancelAcquisitionResponse_Status_STATUS_REQUEST_ID_DOES_NOT_EXIST;
constexpr int CancelAcquisitionResponse_Status_Status_ARRAYSIZE = CancelAcquisitionResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CancelAcquisitionResponse_Status_descriptor();
template<typename T>
inline const std::string& CancelAcquisitionResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CancelAcquisitionResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CancelAcquisitionResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CancelAcquisitionResponse_Status_descriptor(), enum_t_value);
}
inline bool CancelAcquisitionResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CancelAcquisitionResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CancelAcquisitionResponse_Status>(
    CancelAcquisitionResponse_Status_descriptor(), name, value);
}
// ===================================================================

class DataAcquisitionCapability final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DataAcquisitionCapability) */ {
 public:
  inline DataAcquisitionCapability() : DataAcquisitionCapability(nullptr) {}
  ~DataAcquisitionCapability() override;
  explicit PROTOBUF_CONSTEXPR DataAcquisitionCapability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataAcquisitionCapability(const DataAcquisitionCapability& from);
  DataAcquisitionCapability(DataAcquisitionCapability&& from) noexcept
    : DataAcquisitionCapability() {
    *this = ::std::move(from);
  }

  inline DataAcquisitionCapability& operator=(const DataAcquisitionCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataAcquisitionCapability& operator=(DataAcquisitionCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataAcquisitionCapability& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataAcquisitionCapability* internal_default_instance() {
    return reinterpret_cast<const DataAcquisitionCapability*>(
               &_DataAcquisitionCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DataAcquisitionCapability& a, DataAcquisitionCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(DataAcquisitionCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataAcquisitionCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataAcquisitionCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataAcquisitionCapability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataAcquisitionCapability& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataAcquisitionCapability& from) {
    DataAcquisitionCapability::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataAcquisitionCapability* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DataAcquisitionCapability";
  }
  protected:
  explicit DataAcquisitionCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kChannelNameFieldNumber = 3,
    kServiceNameFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string channel_name = 3;
  void clear_channel_name();
  const std::string& channel_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_channel_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_channel_name();
  PROTOBUF_NODISCARD std::string* release_channel_name();
  void set_allocated_channel_name(std::string* channel_name);
  private:
  const std::string& _internal_channel_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_name(const std::string& value);
  std::string* _internal_mutable_channel_name();
  public:

  // string service_name = 4;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.DataAcquisitionCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class ImageAcquisitionCapability final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ImageAcquisitionCapability) */ {
 public:
  inline ImageAcquisitionCapability() : ImageAcquisitionCapability(nullptr) {}
  ~ImageAcquisitionCapability() override;
  explicit PROTOBUF_CONSTEXPR ImageAcquisitionCapability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageAcquisitionCapability(const ImageAcquisitionCapability& from);
  ImageAcquisitionCapability(ImageAcquisitionCapability&& from) noexcept
    : ImageAcquisitionCapability() {
    *this = ::std::move(from);
  }

  inline ImageAcquisitionCapability& operator=(const ImageAcquisitionCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageAcquisitionCapability& operator=(ImageAcquisitionCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageAcquisitionCapability& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageAcquisitionCapability* internal_default_instance() {
    return reinterpret_cast<const ImageAcquisitionCapability*>(
               &_ImageAcquisitionCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ImageAcquisitionCapability& a, ImageAcquisitionCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageAcquisitionCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageAcquisitionCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageAcquisitionCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageAcquisitionCapability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageAcquisitionCapability& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageAcquisitionCapability& from) {
    ImageAcquisitionCapability::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageAcquisitionCapability* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ImageAcquisitionCapability";
  }
  protected:
  explicit ImageAcquisitionCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageSourceNamesFieldNumber = 2,
    kImageSourcesFieldNumber = 3,
    kServiceNameFieldNumber = 1,
  };
  // repeated string image_source_names = 2;
  int image_source_names_size() const;
  private:
  int _internal_image_source_names_size() const;
  public:
  void clear_image_source_names();
  const std::string& image_source_names(int index) const;
  std::string* mutable_image_source_names(int index);
  void set_image_source_names(int index, const std::string& value);
  void set_image_source_names(int index, std::string&& value);
  void set_image_source_names(int index, const char* value);
  void set_image_source_names(int index, const char* value, size_t size);
  std::string* add_image_source_names();
  void add_image_source_names(const std::string& value);
  void add_image_source_names(std::string&& value);
  void add_image_source_names(const char* value);
  void add_image_source_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& image_source_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_image_source_names();
  private:
  const std::string& _internal_image_source_names(int index) const;
  std::string* _internal_add_image_source_names();
  public:

  // repeated .bosdyn.api.ImageSource image_sources = 3;
  int image_sources_size() const;
  private:
  int _internal_image_sources_size() const;
  public:
  void clear_image_sources();
  ::bosdyn::api::ImageSource* mutable_image_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSource >*
      mutable_image_sources();
  private:
  const ::bosdyn::api::ImageSource& _internal_image_sources(int index) const;
  ::bosdyn::api::ImageSource* _internal_add_image_sources();
  public:
  const ::bosdyn::api::ImageSource& image_sources(int index) const;
  ::bosdyn::api::ImageSource* add_image_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSource >&
      image_sources() const;

  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ImageAcquisitionCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> image_source_names_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSource > image_sources_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class NetworkComputeCapability final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.NetworkComputeCapability) */ {
 public:
  inline NetworkComputeCapability() : NetworkComputeCapability(nullptr) {}
  ~NetworkComputeCapability() override;
  explicit PROTOBUF_CONSTEXPR NetworkComputeCapability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkComputeCapability(const NetworkComputeCapability& from);
  NetworkComputeCapability(NetworkComputeCapability&& from) noexcept
    : NetworkComputeCapability() {
    *this = ::std::move(from);
  }

  inline NetworkComputeCapability& operator=(const NetworkComputeCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkComputeCapability& operator=(NetworkComputeCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkComputeCapability& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkComputeCapability* internal_default_instance() {
    return reinterpret_cast<const NetworkComputeCapability*>(
               &_NetworkComputeCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NetworkComputeCapability& a, NetworkComputeCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkComputeCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkComputeCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkComputeCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkComputeCapability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkComputeCapability& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkComputeCapability& from) {
    NetworkComputeCapability::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkComputeCapability* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.NetworkComputeCapability";
  }
  protected:
  explicit NetworkComputeCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableModelsFieldNumber = 2,
    kLabelsFieldNumber = 6,
    kServerConfigFieldNumber = 1,
  };
  // repeated string available_models = 2;
  int available_models_size() const;
  private:
  int _internal_available_models_size() const;
  public:
  void clear_available_models();
  const std::string& available_models(int index) const;
  std::string* mutable_available_models(int index);
  void set_available_models(int index, const std::string& value);
  void set_available_models(int index, std::string&& value);
  void set_available_models(int index, const char* value);
  void set_available_models(int index, const char* value, size_t size);
  std::string* add_available_models();
  void add_available_models(const std::string& value);
  void add_available_models(std::string&& value);
  void add_available_models(const char* value);
  void add_available_models(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& available_models() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_available_models();
  private:
  const std::string& _internal_available_models(int index) const;
  std::string* _internal_add_available_models();
  public:

  // repeated .bosdyn.api.ModelLabels labels = 6;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  ::bosdyn::api::ModelLabels* mutable_labels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ModelLabels >*
      mutable_labels();
  private:
  const ::bosdyn::api::ModelLabels& _internal_labels(int index) const;
  ::bosdyn::api::ModelLabels* _internal_add_labels();
  public:
  const ::bosdyn::api::ModelLabels& labels(int index) const;
  ::bosdyn::api::ModelLabels* add_labels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ModelLabels >&
      labels() const;

  // .bosdyn.api.NetworkComputeServerConfiguration server_config = 1;
  bool has_server_config() const;
  private:
  bool _internal_has_server_config() const;
  public:
  void clear_server_config();
  const ::bosdyn::api::NetworkComputeServerConfiguration& server_config() const;
  PROTOBUF_NODISCARD ::bosdyn::api::NetworkComputeServerConfiguration* release_server_config();
  ::bosdyn::api::NetworkComputeServerConfiguration* mutable_server_config();
  void set_allocated_server_config(::bosdyn::api::NetworkComputeServerConfiguration* server_config);
  private:
  const ::bosdyn::api::NetworkComputeServerConfiguration& _internal_server_config() const;
  ::bosdyn::api::NetworkComputeServerConfiguration* _internal_mutable_server_config();
  public:
  void unsafe_arena_set_allocated_server_config(
      ::bosdyn::api::NetworkComputeServerConfiguration* server_config);
  ::bosdyn::api::NetworkComputeServerConfiguration* unsafe_arena_release_server_config();

  // @@protoc_insertion_point(class_scope:bosdyn.api.NetworkComputeCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> available_models_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ModelLabels > labels_;
    ::bosdyn::api::NetworkComputeServerConfiguration* server_config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class AcquisitionCapabilityList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.AcquisitionCapabilityList) */ {
 public:
  inline AcquisitionCapabilityList() : AcquisitionCapabilityList(nullptr) {}
  ~AcquisitionCapabilityList() override;
  explicit PROTOBUF_CONSTEXPR AcquisitionCapabilityList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcquisitionCapabilityList(const AcquisitionCapabilityList& from);
  AcquisitionCapabilityList(AcquisitionCapabilityList&& from) noexcept
    : AcquisitionCapabilityList() {
    *this = ::std::move(from);
  }

  inline AcquisitionCapabilityList& operator=(const AcquisitionCapabilityList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcquisitionCapabilityList& operator=(AcquisitionCapabilityList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcquisitionCapabilityList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcquisitionCapabilityList* internal_default_instance() {
    return reinterpret_cast<const AcquisitionCapabilityList*>(
               &_AcquisitionCapabilityList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AcquisitionCapabilityList& a, AcquisitionCapabilityList& b) {
    a.Swap(&b);
  }
  inline void Swap(AcquisitionCapabilityList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcquisitionCapabilityList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcquisitionCapabilityList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcquisitionCapabilityList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcquisitionCapabilityList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AcquisitionCapabilityList& from) {
    AcquisitionCapabilityList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcquisitionCapabilityList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.AcquisitionCapabilityList";
  }
  protected:
  explicit AcquisitionCapabilityList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataSourcesFieldNumber = 1,
    kImageSourcesFieldNumber = 3,
    kNetworkComputeSourcesFieldNumber = 5,
  };
  // repeated .bosdyn.api.DataAcquisitionCapability data_sources = 1;
  int data_sources_size() const;
  private:
  int _internal_data_sources_size() const;
  public:
  void clear_data_sources();
  ::bosdyn::api::DataAcquisitionCapability* mutable_data_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataAcquisitionCapability >*
      mutable_data_sources();
  private:
  const ::bosdyn::api::DataAcquisitionCapability& _internal_data_sources(int index) const;
  ::bosdyn::api::DataAcquisitionCapability* _internal_add_data_sources();
  public:
  const ::bosdyn::api::DataAcquisitionCapability& data_sources(int index) const;
  ::bosdyn::api::DataAcquisitionCapability* add_data_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataAcquisitionCapability >&
      data_sources() const;

  // repeated .bosdyn.api.ImageAcquisitionCapability image_sources = 3;
  int image_sources_size() const;
  private:
  int _internal_image_sources_size() const;
  public:
  void clear_image_sources();
  ::bosdyn::api::ImageAcquisitionCapability* mutable_image_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageAcquisitionCapability >*
      mutable_image_sources();
  private:
  const ::bosdyn::api::ImageAcquisitionCapability& _internal_image_sources(int index) const;
  ::bosdyn::api::ImageAcquisitionCapability* _internal_add_image_sources();
  public:
  const ::bosdyn::api::ImageAcquisitionCapability& image_sources(int index) const;
  ::bosdyn::api::ImageAcquisitionCapability* add_image_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageAcquisitionCapability >&
      image_sources() const;

  // repeated .bosdyn.api.NetworkComputeCapability network_compute_sources = 5;
  int network_compute_sources_size() const;
  private:
  int _internal_network_compute_sources_size() const;
  public:
  void clear_network_compute_sources();
  ::bosdyn::api::NetworkComputeCapability* mutable_network_compute_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::NetworkComputeCapability >*
      mutable_network_compute_sources();
  private:
  const ::bosdyn::api::NetworkComputeCapability& _internal_network_compute_sources(int index) const;
  ::bosdyn::api::NetworkComputeCapability* _internal_add_network_compute_sources();
  public:
  const ::bosdyn::api::NetworkComputeCapability& network_compute_sources(int index) const;
  ::bosdyn::api::NetworkComputeCapability* add_network_compute_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::NetworkComputeCapability >&
      network_compute_sources() const;

  // @@protoc_insertion_point(class_scope:bosdyn.api.AcquisitionCapabilityList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataAcquisitionCapability > data_sources_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageAcquisitionCapability > image_sources_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::NetworkComputeCapability > network_compute_sources_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class CaptureActionId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.CaptureActionId) */ {
 public:
  inline CaptureActionId() : CaptureActionId(nullptr) {}
  ~CaptureActionId() override;
  explicit PROTOBUF_CONSTEXPR CaptureActionId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaptureActionId(const CaptureActionId& from);
  CaptureActionId(CaptureActionId&& from) noexcept
    : CaptureActionId() {
    *this = ::std::move(from);
  }

  inline CaptureActionId& operator=(const CaptureActionId& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptureActionId& operator=(CaptureActionId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaptureActionId& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptureActionId* internal_default_instance() {
    return reinterpret_cast<const CaptureActionId*>(
               &_CaptureActionId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CaptureActionId& a, CaptureActionId& b) {
    a.Swap(&b);
  }
  inline void Swap(CaptureActionId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptureActionId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptureActionId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaptureActionId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaptureActionId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaptureActionId& from) {
    CaptureActionId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaptureActionId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.CaptureActionId";
  }
  protected:
  explicit CaptureActionId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionNameFieldNumber = 1,
    kGroupNameFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // string action_name = 1;
  void clear_action_name();
  const std::string& action_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action_name();
  PROTOBUF_NODISCARD std::string* release_action_name();
  void set_allocated_action_name(std::string* action_name);
  private:
  const std::string& _internal_action_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_name(const std::string& value);
  std::string* _internal_mutable_action_name();
  public:

  // string group_name = 2;
  void clear_group_name();
  const std::string& group_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_name();
  PROTOBUF_NODISCARD std::string* release_group_name();
  void set_allocated_group_name(std::string* group_name);
  private:
  const std::string& _internal_group_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_name(const std::string& value);
  std::string* _internal_mutable_group_name();
  public:

  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:bosdyn.api.CaptureActionId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class DataIdentifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DataIdentifier) */ {
 public:
  inline DataIdentifier() : DataIdentifier(nullptr) {}
  ~DataIdentifier() override;
  explicit PROTOBUF_CONSTEXPR DataIdentifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataIdentifier(const DataIdentifier& from);
  DataIdentifier(DataIdentifier&& from) noexcept
    : DataIdentifier() {
    *this = ::std::move(from);
  }

  inline DataIdentifier& operator=(const DataIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataIdentifier& operator=(DataIdentifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataIdentifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataIdentifier* internal_default_instance() {
    return reinterpret_cast<const DataIdentifier*>(
               &_DataIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DataIdentifier& a, DataIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(DataIdentifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataIdentifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataIdentifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataIdentifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataIdentifier& from) {
    DataIdentifier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataIdentifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DataIdentifier";
  }
  protected:
  explicit DataIdentifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelFieldNumber = 2,
    kDataNameFieldNumber = 3,
    kActionIdFieldNumber = 1,
  };
  // string channel = 2;
  void clear_channel();
  const std::string& channel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_channel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_channel();
  PROTOBUF_NODISCARD std::string* release_channel();
  void set_allocated_channel(std::string* channel);
  private:
  const std::string& _internal_channel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel(const std::string& value);
  std::string* _internal_mutable_channel();
  public:

  // string data_name = 3;
  void clear_data_name();
  const std::string& data_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_name();
  PROTOBUF_NODISCARD std::string* release_data_name();
  void set_allocated_data_name(std::string* data_name);
  private:
  const std::string& _internal_data_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_name(const std::string& value);
  std::string* _internal_mutable_data_name();
  public:

  // .bosdyn.api.CaptureActionId action_id = 1;
  bool has_action_id() const;
  private:
  bool _internal_has_action_id() const;
  public:
  void clear_action_id();
  const ::bosdyn::api::CaptureActionId& action_id() const;
  PROTOBUF_NODISCARD ::bosdyn::api::CaptureActionId* release_action_id();
  ::bosdyn::api::CaptureActionId* mutable_action_id();
  void set_allocated_action_id(::bosdyn::api::CaptureActionId* action_id);
  private:
  const ::bosdyn::api::CaptureActionId& _internal_action_id() const;
  ::bosdyn::api::CaptureActionId* _internal_mutable_action_id();
  public:
  void unsafe_arena_set_allocated_action_id(
      ::bosdyn::api::CaptureActionId* action_id);
  ::bosdyn::api::CaptureActionId* unsafe_arena_release_action_id();

  // @@protoc_insertion_point(class_scope:bosdyn.api.DataIdentifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_name_;
    ::bosdyn::api::CaptureActionId* action_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class Metadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Metadata) */ {
 public:
  inline Metadata() : Metadata(nullptr) {}
  ~Metadata() override;
  explicit PROTOBUF_CONSTEXPR Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metadata(const Metadata& from);
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata& operator=(Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Metadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Metadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Metadata& from) {
    Metadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Metadata";
  }
  protected:
  explicit Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .google.protobuf.Struct data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PROTOBUF_NAMESPACE_ID::Struct& data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_data();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_data();
  void set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PROTOBUF_NAMESPACE_ID::Struct* data);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Metadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Struct* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class AssociatedMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.AssociatedMetadata) */ {
 public:
  inline AssociatedMetadata() : AssociatedMetadata(nullptr) {}
  ~AssociatedMetadata() override;
  explicit PROTOBUF_CONSTEXPR AssociatedMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssociatedMetadata(const AssociatedMetadata& from);
  AssociatedMetadata(AssociatedMetadata&& from) noexcept
    : AssociatedMetadata() {
    *this = ::std::move(from);
  }

  inline AssociatedMetadata& operator=(const AssociatedMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssociatedMetadata& operator=(AssociatedMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssociatedMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssociatedMetadata* internal_default_instance() {
    return reinterpret_cast<const AssociatedMetadata*>(
               &_AssociatedMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AssociatedMetadata& a, AssociatedMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(AssociatedMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssociatedMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssociatedMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssociatedMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssociatedMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssociatedMetadata& from) {
    AssociatedMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssociatedMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.AssociatedMetadata";
  }
  protected:
  explicit AssociatedMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReferenceIdFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // .bosdyn.api.DataIdentifier reference_id = 1;
  bool has_reference_id() const;
  private:
  bool _internal_has_reference_id() const;
  public:
  void clear_reference_id();
  const ::bosdyn::api::DataIdentifier& reference_id() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataIdentifier* release_reference_id();
  ::bosdyn::api::DataIdentifier* mutable_reference_id();
  void set_allocated_reference_id(::bosdyn::api::DataIdentifier* reference_id);
  private:
  const ::bosdyn::api::DataIdentifier& _internal_reference_id() const;
  ::bosdyn::api::DataIdentifier* _internal_mutable_reference_id();
  public:
  void unsafe_arena_set_allocated_reference_id(
      ::bosdyn::api::DataIdentifier* reference_id);
  ::bosdyn::api::DataIdentifier* unsafe_arena_release_reference_id();

  // .bosdyn.api.Metadata metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::bosdyn::api::Metadata& metadata() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Metadata* release_metadata();
  ::bosdyn::api::Metadata* mutable_metadata();
  void set_allocated_metadata(::bosdyn::api::Metadata* metadata);
  private:
  const ::bosdyn::api::Metadata& _internal_metadata() const;
  ::bosdyn::api::Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::bosdyn::api::Metadata* metadata);
  ::bosdyn::api::Metadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:bosdyn.api.AssociatedMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::DataIdentifier* reference_id_;
    ::bosdyn::api::Metadata* metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class AssociatedAlertData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.AssociatedAlertData) */ {
 public:
  inline AssociatedAlertData() : AssociatedAlertData(nullptr) {}
  ~AssociatedAlertData() override;
  explicit PROTOBUF_CONSTEXPR AssociatedAlertData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssociatedAlertData(const AssociatedAlertData& from);
  AssociatedAlertData(AssociatedAlertData&& from) noexcept
    : AssociatedAlertData() {
    *this = ::std::move(from);
  }

  inline AssociatedAlertData& operator=(const AssociatedAlertData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssociatedAlertData& operator=(AssociatedAlertData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssociatedAlertData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssociatedAlertData* internal_default_instance() {
    return reinterpret_cast<const AssociatedAlertData*>(
               &_AssociatedAlertData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AssociatedAlertData& a, AssociatedAlertData& b) {
    a.Swap(&b);
  }
  inline void Swap(AssociatedAlertData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssociatedAlertData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssociatedAlertData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssociatedAlertData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssociatedAlertData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssociatedAlertData& from) {
    AssociatedAlertData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssociatedAlertData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.AssociatedAlertData";
  }
  protected:
  explicit AssociatedAlertData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReferenceIdFieldNumber = 1,
    kAlertDataFieldNumber = 2,
  };
  // .bosdyn.api.DataIdentifier reference_id = 1;
  bool has_reference_id() const;
  private:
  bool _internal_has_reference_id() const;
  public:
  void clear_reference_id();
  const ::bosdyn::api::DataIdentifier& reference_id() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataIdentifier* release_reference_id();
  ::bosdyn::api::DataIdentifier* mutable_reference_id();
  void set_allocated_reference_id(::bosdyn::api::DataIdentifier* reference_id);
  private:
  const ::bosdyn::api::DataIdentifier& _internal_reference_id() const;
  ::bosdyn::api::DataIdentifier* _internal_mutable_reference_id();
  public:
  void unsafe_arena_set_allocated_reference_id(
      ::bosdyn::api::DataIdentifier* reference_id);
  ::bosdyn::api::DataIdentifier* unsafe_arena_release_reference_id();

  // .bosdyn.api.AlertData alert_data = 2;
  bool has_alert_data() const;
  private:
  bool _internal_has_alert_data() const;
  public:
  void clear_alert_data();
  const ::bosdyn::api::AlertData& alert_data() const;
  PROTOBUF_NODISCARD ::bosdyn::api::AlertData* release_alert_data();
  ::bosdyn::api::AlertData* mutable_alert_data();
  void set_allocated_alert_data(::bosdyn::api::AlertData* alert_data);
  private:
  const ::bosdyn::api::AlertData& _internal_alert_data() const;
  ::bosdyn::api::AlertData* _internal_mutable_alert_data();
  public:
  void unsafe_arena_set_allocated_alert_data(
      ::bosdyn::api::AlertData* alert_data);
  ::bosdyn::api::AlertData* unsafe_arena_release_alert_data();

  // @@protoc_insertion_point(class_scope:bosdyn.api.AssociatedAlertData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::DataIdentifier* reference_id_;
    ::bosdyn::api::AlertData* alert_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class ImageSourceCapture final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ImageSourceCapture) */ {
 public:
  inline ImageSourceCapture() : ImageSourceCapture(nullptr) {}
  ~ImageSourceCapture() override;
  explicit PROTOBUF_CONSTEXPR ImageSourceCapture(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageSourceCapture(const ImageSourceCapture& from);
  ImageSourceCapture(ImageSourceCapture&& from) noexcept
    : ImageSourceCapture() {
    *this = ::std::move(from);
  }

  inline ImageSourceCapture& operator=(const ImageSourceCapture& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageSourceCapture& operator=(ImageSourceCapture&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageSourceCapture& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageSourceCapture* internal_default_instance() {
    return reinterpret_cast<const ImageSourceCapture*>(
               &_ImageSourceCapture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ImageSourceCapture& a, ImageSourceCapture& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageSourceCapture* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageSourceCapture* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageSourceCapture* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageSourceCapture>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageSourceCapture& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageSourceCapture& from) {
    ImageSourceCapture::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageSourceCapture* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ImageSourceCapture";
  }
  protected:
  explicit ImageSourceCapture(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageServiceFieldNumber = 1,
    kImageSourceFieldNumber = 2,
    kImageRequestFieldNumber = 4,
    kPixelFormatFieldNumber = 3,
  };
  // string image_service = 1;
  void clear_image_service();
  const std::string& image_service() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_service(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_service();
  PROTOBUF_NODISCARD std::string* release_image_service();
  void set_allocated_image_service(std::string* image_service);
  private:
  const std::string& _internal_image_service() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_service(const std::string& value);
  std::string* _internal_mutable_image_service();
  public:

  // string image_source = 2 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_image_source();
  PROTOBUF_DEPRECATED const std::string& image_source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_image_source(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_image_source();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_image_source();
  PROTOBUF_DEPRECATED void set_allocated_image_source(std::string* image_source);
  private:
  const std::string& _internal_image_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_source(const std::string& value);
  std::string* _internal_mutable_image_source();
  public:

  // .bosdyn.api.ImageRequest image_request = 4;
  bool has_image_request() const;
  private:
  bool _internal_has_image_request() const;
  public:
  void clear_image_request();
  const ::bosdyn::api::ImageRequest& image_request() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ImageRequest* release_image_request();
  ::bosdyn::api::ImageRequest* mutable_image_request();
  void set_allocated_image_request(::bosdyn::api::ImageRequest* image_request);
  private:
  const ::bosdyn::api::ImageRequest& _internal_image_request() const;
  ::bosdyn::api::ImageRequest* _internal_mutable_image_request();
  public:
  void unsafe_arena_set_allocated_image_request(
      ::bosdyn::api::ImageRequest* image_request);
  ::bosdyn::api::ImageRequest* unsafe_arena_release_image_request();

  // .bosdyn.api.Image.PixelFormat pixel_format = 3 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_pixel_format();
  PROTOBUF_DEPRECATED ::bosdyn::api::Image_PixelFormat pixel_format() const;
  PROTOBUF_DEPRECATED void set_pixel_format(::bosdyn::api::Image_PixelFormat value);
  private:
  ::bosdyn::api::Image_PixelFormat _internal_pixel_format() const;
  void _internal_set_pixel_format(::bosdyn::api::Image_PixelFormat value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ImageSourceCapture)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_service_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_source_;
    ::bosdyn::api::ImageRequest* image_request_;
    int pixel_format_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class DataCapture final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DataCapture) */ {
 public:
  inline DataCapture() : DataCapture(nullptr) {}
  ~DataCapture() override;
  explicit PROTOBUF_CONSTEXPR DataCapture(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataCapture(const DataCapture& from);
  DataCapture(DataCapture&& from) noexcept
    : DataCapture() {
    *this = ::std::move(from);
  }

  inline DataCapture& operator=(const DataCapture& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataCapture& operator=(DataCapture&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataCapture& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataCapture* internal_default_instance() {
    return reinterpret_cast<const DataCapture*>(
               &_DataCapture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DataCapture& a, DataCapture& b) {
    a.Swap(&b);
  }
  inline void Swap(DataCapture* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataCapture* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataCapture* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataCapture>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataCapture& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataCapture& from) {
    DataCapture::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataCapture* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DataCapture";
  }
  protected:
  explicit DataCapture(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.DataCapture)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class NetworkComputeCapture final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.NetworkComputeCapture) */ {
 public:
  inline NetworkComputeCapture() : NetworkComputeCapture(nullptr) {}
  ~NetworkComputeCapture() override;
  explicit PROTOBUF_CONSTEXPR NetworkComputeCapture(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkComputeCapture(const NetworkComputeCapture& from);
  NetworkComputeCapture(NetworkComputeCapture&& from) noexcept
    : NetworkComputeCapture() {
    *this = ::std::move(from);
  }

  inline NetworkComputeCapture& operator=(const NetworkComputeCapture& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkComputeCapture& operator=(NetworkComputeCapture&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkComputeCapture& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkComputeCapture* internal_default_instance() {
    return reinterpret_cast<const NetworkComputeCapture*>(
               &_NetworkComputeCapture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NetworkComputeCapture& a, NetworkComputeCapture& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkComputeCapture* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkComputeCapture* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkComputeCapture* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkComputeCapture>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkComputeCapture& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkComputeCapture& from) {
    NetworkComputeCapture::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkComputeCapture* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.NetworkComputeCapture";
  }
  protected:
  explicit NetworkComputeCapture(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputDataFieldNumber = 1,
    kServerConfigFieldNumber = 2,
  };
  // .bosdyn.api.NetworkComputeInputData input_data = 1;
  bool has_input_data() const;
  private:
  bool _internal_has_input_data() const;
  public:
  void clear_input_data();
  const ::bosdyn::api::NetworkComputeInputData& input_data() const;
  PROTOBUF_NODISCARD ::bosdyn::api::NetworkComputeInputData* release_input_data();
  ::bosdyn::api::NetworkComputeInputData* mutable_input_data();
  void set_allocated_input_data(::bosdyn::api::NetworkComputeInputData* input_data);
  private:
  const ::bosdyn::api::NetworkComputeInputData& _internal_input_data() const;
  ::bosdyn::api::NetworkComputeInputData* _internal_mutable_input_data();
  public:
  void unsafe_arena_set_allocated_input_data(
      ::bosdyn::api::NetworkComputeInputData* input_data);
  ::bosdyn::api::NetworkComputeInputData* unsafe_arena_release_input_data();

  // .bosdyn.api.NetworkComputeServerConfiguration server_config = 2;
  bool has_server_config() const;
  private:
  bool _internal_has_server_config() const;
  public:
  void clear_server_config();
  const ::bosdyn::api::NetworkComputeServerConfiguration& server_config() const;
  PROTOBUF_NODISCARD ::bosdyn::api::NetworkComputeServerConfiguration* release_server_config();
  ::bosdyn::api::NetworkComputeServerConfiguration* mutable_server_config();
  void set_allocated_server_config(::bosdyn::api::NetworkComputeServerConfiguration* server_config);
  private:
  const ::bosdyn::api::NetworkComputeServerConfiguration& _internal_server_config() const;
  ::bosdyn::api::NetworkComputeServerConfiguration* _internal_mutable_server_config();
  public:
  void unsafe_arena_set_allocated_server_config(
      ::bosdyn::api::NetworkComputeServerConfiguration* server_config);
  ::bosdyn::api::NetworkComputeServerConfiguration* unsafe_arena_release_server_config();

  // @@protoc_insertion_point(class_scope:bosdyn.api.NetworkComputeCapture)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::NetworkComputeInputData* input_data_;
    ::bosdyn::api::NetworkComputeServerConfiguration* server_config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class AcquisitionRequestList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.AcquisitionRequestList) */ {
 public:
  inline AcquisitionRequestList() : AcquisitionRequestList(nullptr) {}
  ~AcquisitionRequestList() override;
  explicit PROTOBUF_CONSTEXPR AcquisitionRequestList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcquisitionRequestList(const AcquisitionRequestList& from);
  AcquisitionRequestList(AcquisitionRequestList&& from) noexcept
    : AcquisitionRequestList() {
    *this = ::std::move(from);
  }

  inline AcquisitionRequestList& operator=(const AcquisitionRequestList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcquisitionRequestList& operator=(AcquisitionRequestList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcquisitionRequestList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcquisitionRequestList* internal_default_instance() {
    return reinterpret_cast<const AcquisitionRequestList*>(
               &_AcquisitionRequestList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AcquisitionRequestList& a, AcquisitionRequestList& b) {
    a.Swap(&b);
  }
  inline void Swap(AcquisitionRequestList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcquisitionRequestList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcquisitionRequestList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcquisitionRequestList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcquisitionRequestList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AcquisitionRequestList& from) {
    AcquisitionRequestList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcquisitionRequestList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.AcquisitionRequestList";
  }
  protected:
  explicit AcquisitionRequestList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageCapturesFieldNumber = 1,
    kDataCapturesFieldNumber = 2,
    kNetworkComputeCapturesFieldNumber = 4,
  };
  // repeated .bosdyn.api.ImageSourceCapture image_captures = 1;
  int image_captures_size() const;
  private:
  int _internal_image_captures_size() const;
  public:
  void clear_image_captures();
  ::bosdyn::api::ImageSourceCapture* mutable_image_captures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSourceCapture >*
      mutable_image_captures();
  private:
  const ::bosdyn::api::ImageSourceCapture& _internal_image_captures(int index) const;
  ::bosdyn::api::ImageSourceCapture* _internal_add_image_captures();
  public:
  const ::bosdyn::api::ImageSourceCapture& image_captures(int index) const;
  ::bosdyn::api::ImageSourceCapture* add_image_captures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSourceCapture >&
      image_captures() const;

  // repeated .bosdyn.api.DataCapture data_captures = 2;
  int data_captures_size() const;
  private:
  int _internal_data_captures_size() const;
  public:
  void clear_data_captures();
  ::bosdyn::api::DataCapture* mutable_data_captures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataCapture >*
      mutable_data_captures();
  private:
  const ::bosdyn::api::DataCapture& _internal_data_captures(int index) const;
  ::bosdyn::api::DataCapture* _internal_add_data_captures();
  public:
  const ::bosdyn::api::DataCapture& data_captures(int index) const;
  ::bosdyn::api::DataCapture* add_data_captures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataCapture >&
      data_captures() const;

  // repeated .bosdyn.api.NetworkComputeCapture network_compute_captures = 4;
  int network_compute_captures_size() const;
  private:
  int _internal_network_compute_captures_size() const;
  public:
  void clear_network_compute_captures();
  ::bosdyn::api::NetworkComputeCapture* mutable_network_compute_captures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::NetworkComputeCapture >*
      mutable_network_compute_captures();
  private:
  const ::bosdyn::api::NetworkComputeCapture& _internal_network_compute_captures(int index) const;
  ::bosdyn::api::NetworkComputeCapture* _internal_add_network_compute_captures();
  public:
  const ::bosdyn::api::NetworkComputeCapture& network_compute_captures(int index) const;
  ::bosdyn::api::NetworkComputeCapture* add_network_compute_captures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::NetworkComputeCapture >&
      network_compute_captures() const;

  // @@protoc_insertion_point(class_scope:bosdyn.api.AcquisitionRequestList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSourceCapture > image_captures_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataCapture > data_captures_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::NetworkComputeCapture > network_compute_captures_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class DataError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DataError) */ {
 public:
  inline DataError() : DataError(nullptr) {}
  ~DataError() override;
  explicit PROTOBUF_CONSTEXPR DataError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataError(const DataError& from);
  DataError(DataError&& from) noexcept
    : DataError() {
    *this = ::std::move(from);
  }

  inline DataError& operator=(const DataError& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataError& operator=(DataError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataError& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataError* internal_default_instance() {
    return reinterpret_cast<const DataError*>(
               &_DataError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DataError& a, DataError& b) {
    a.Swap(&b);
  }
  inline void Swap(DataError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataError& from) {
    DataError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DataError";
  }
  protected:
  explicit DataError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kDataIdFieldNumber = 1,
    kErrorDataFieldNumber = 3,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .bosdyn.api.DataIdentifier data_id = 1;
  bool has_data_id() const;
  private:
  bool _internal_has_data_id() const;
  public:
  void clear_data_id();
  const ::bosdyn::api::DataIdentifier& data_id() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataIdentifier* release_data_id();
  ::bosdyn::api::DataIdentifier* mutable_data_id();
  void set_allocated_data_id(::bosdyn::api::DataIdentifier* data_id);
  private:
  const ::bosdyn::api::DataIdentifier& _internal_data_id() const;
  ::bosdyn::api::DataIdentifier* _internal_mutable_data_id();
  public:
  void unsafe_arena_set_allocated_data_id(
      ::bosdyn::api::DataIdentifier* data_id);
  ::bosdyn::api::DataIdentifier* unsafe_arena_release_data_id();

  // .google.protobuf.Any error_data = 3;
  bool has_error_data() const;
  private:
  bool _internal_has_error_data() const;
  public:
  void clear_error_data();
  const ::PROTOBUF_NAMESPACE_ID::Any& error_data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_error_data();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_error_data();
  void set_allocated_error_data(::PROTOBUF_NAMESPACE_ID::Any* error_data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_error_data() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_error_data();
  public:
  void unsafe_arena_set_allocated_error_data(
      ::PROTOBUF_NAMESPACE_ID::Any* error_data);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_error_data();

  // @@protoc_insertion_point(class_scope:bosdyn.api.DataError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::bosdyn::api::DataIdentifier* data_id_;
    ::PROTOBUF_NAMESPACE_ID::Any* error_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class PluginServiceError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PluginServiceError) */ {
 public:
  inline PluginServiceError() : PluginServiceError(nullptr) {}
  ~PluginServiceError() override;
  explicit PROTOBUF_CONSTEXPR PluginServiceError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PluginServiceError(const PluginServiceError& from);
  PluginServiceError(PluginServiceError&& from) noexcept
    : PluginServiceError() {
    *this = ::std::move(from);
  }

  inline PluginServiceError& operator=(const PluginServiceError& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginServiceError& operator=(PluginServiceError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginServiceError& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginServiceError* internal_default_instance() {
    return reinterpret_cast<const PluginServiceError*>(
               &_PluginServiceError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PluginServiceError& a, PluginServiceError& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginServiceError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginServiceError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginServiceError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginServiceError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PluginServiceError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PluginServiceError& from) {
    PluginServiceError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginServiceError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PluginServiceError";
  }
  protected:
  explicit PluginServiceError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PluginServiceError_ErrorCode ErrorCode;
  static constexpr ErrorCode STATUS_UNKNOWN =
    PluginServiceError_ErrorCode_STATUS_UNKNOWN;
  static constexpr ErrorCode STATUS_REQUEST_ERROR =
    PluginServiceError_ErrorCode_STATUS_REQUEST_ERROR;
  static constexpr ErrorCode STATUS_GETSTATUS_ERROR =
    PluginServiceError_ErrorCode_STATUS_GETSTATUS_ERROR;
  static constexpr ErrorCode STATUS_INTERNAL_ERROR =
    PluginServiceError_ErrorCode_STATUS_INTERNAL_ERROR;
  static inline bool ErrorCode_IsValid(int value) {
    return PluginServiceError_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN =
    PluginServiceError_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX =
    PluginServiceError_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE =
    PluginServiceError_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ErrorCode_descriptor() {
    return PluginServiceError_ErrorCode_descriptor();
  }
  template<typename T>
  static inline const std::string& ErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorCode_Name.");
    return PluginServiceError_ErrorCode_Name(enum_t_value);
  }
  static inline bool ErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorCode* value) {
    return PluginServiceError_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kMessageFieldNumber = 3,
    kErrorFieldNumber = 2,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .bosdyn.api.PluginServiceError.ErrorCode error = 2;
  void clear_error();
  ::bosdyn::api::PluginServiceError_ErrorCode error() const;
  void set_error(::bosdyn::api::PluginServiceError_ErrorCode value);
  private:
  ::bosdyn::api::PluginServiceError_ErrorCode _internal_error() const;
  void _internal_set_error(::bosdyn::api::PluginServiceError_ErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.PluginServiceError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class NetworkComputeError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.NetworkComputeError) */ {
 public:
  inline NetworkComputeError() : NetworkComputeError(nullptr) {}
  ~NetworkComputeError() override;
  explicit PROTOBUF_CONSTEXPR NetworkComputeError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkComputeError(const NetworkComputeError& from);
  NetworkComputeError(NetworkComputeError&& from) noexcept
    : NetworkComputeError() {
    *this = ::std::move(from);
  }

  inline NetworkComputeError& operator=(const NetworkComputeError& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkComputeError& operator=(NetworkComputeError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkComputeError& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkComputeError* internal_default_instance() {
    return reinterpret_cast<const NetworkComputeError*>(
               &_NetworkComputeError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(NetworkComputeError& a, NetworkComputeError& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkComputeError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkComputeError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkComputeError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkComputeError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkComputeError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkComputeError& from) {
    NetworkComputeError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkComputeError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.NetworkComputeError";
  }
  protected:
  explicit NetworkComputeError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NetworkComputeError_ErrorCode ErrorCode;
  static constexpr ErrorCode STATUS_UNKNOWN =
    NetworkComputeError_ErrorCode_STATUS_UNKNOWN;
  static constexpr ErrorCode STATUS_REQUEST_ERROR =
    NetworkComputeError_ErrorCode_STATUS_REQUEST_ERROR;
  static constexpr ErrorCode STATUS_NETWORK_ERROR =
    NetworkComputeError_ErrorCode_STATUS_NETWORK_ERROR;
  static constexpr ErrorCode STATUS_INTERNAL_ERROR =
    NetworkComputeError_ErrorCode_STATUS_INTERNAL_ERROR;
  static inline bool ErrorCode_IsValid(int value) {
    return NetworkComputeError_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN =
    NetworkComputeError_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX =
    NetworkComputeError_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE =
    NetworkComputeError_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ErrorCode_descriptor() {
    return NetworkComputeError_ErrorCode_descriptor();
  }
  template<typename T>
  static inline const std::string& ErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorCode_Name.");
    return NetworkComputeError_ErrorCode_Name(enum_t_value);
  }
  static inline bool ErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorCode* value) {
    return NetworkComputeError_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kMessageFieldNumber = 4,
    kErrorFieldNumber = 2,
    kNetworkComputeStatusFieldNumber = 3,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string message = 4;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .bosdyn.api.NetworkComputeError.ErrorCode error = 2;
  void clear_error();
  ::bosdyn::api::NetworkComputeError_ErrorCode error() const;
  void set_error(::bosdyn::api::NetworkComputeError_ErrorCode value);
  private:
  ::bosdyn::api::NetworkComputeError_ErrorCode _internal_error() const;
  void _internal_set_error(::bosdyn::api::NetworkComputeError_ErrorCode value);
  public:

  // .bosdyn.api.NetworkComputeStatus network_compute_status = 3;
  void clear_network_compute_status();
  ::bosdyn::api::NetworkComputeStatus network_compute_status() const;
  void set_network_compute_status(::bosdyn::api::NetworkComputeStatus value);
  private:
  ::bosdyn::api::NetworkComputeStatus _internal_network_compute_status() const;
  void _internal_set_network_compute_status(::bosdyn::api::NetworkComputeStatus value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.NetworkComputeError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int error_;
    int network_compute_status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class AcquireDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.AcquireDataRequest) */ {
 public:
  inline AcquireDataRequest() : AcquireDataRequest(nullptr) {}
  ~AcquireDataRequest() override;
  explicit PROTOBUF_CONSTEXPR AcquireDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcquireDataRequest(const AcquireDataRequest& from);
  AcquireDataRequest(AcquireDataRequest&& from) noexcept
    : AcquireDataRequest() {
    *this = ::std::move(from);
  }

  inline AcquireDataRequest& operator=(const AcquireDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcquireDataRequest& operator=(AcquireDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcquireDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcquireDataRequest* internal_default_instance() {
    return reinterpret_cast<const AcquireDataRequest*>(
               &_AcquireDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AcquireDataRequest& a, AcquireDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AcquireDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcquireDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcquireDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcquireDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcquireDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AcquireDataRequest& from) {
    AcquireDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcquireDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.AcquireDataRequest";
  }
  protected:
  explicit AcquireDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kActionIdFieldNumber = 2,
    kMetadataFieldNumber = 3,
    kAcquisitionRequestsFieldNumber = 4,
    kMinTimeoutFieldNumber = 5,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.CaptureActionId action_id = 2;
  bool has_action_id() const;
  private:
  bool _internal_has_action_id() const;
  public:
  void clear_action_id();
  const ::bosdyn::api::CaptureActionId& action_id() const;
  PROTOBUF_NODISCARD ::bosdyn::api::CaptureActionId* release_action_id();
  ::bosdyn::api::CaptureActionId* mutable_action_id();
  void set_allocated_action_id(::bosdyn::api::CaptureActionId* action_id);
  private:
  const ::bosdyn::api::CaptureActionId& _internal_action_id() const;
  ::bosdyn::api::CaptureActionId* _internal_mutable_action_id();
  public:
  void unsafe_arena_set_allocated_action_id(
      ::bosdyn::api::CaptureActionId* action_id);
  ::bosdyn::api::CaptureActionId* unsafe_arena_release_action_id();

  // .bosdyn.api.Metadata metadata = 3;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::bosdyn::api::Metadata& metadata() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Metadata* release_metadata();
  ::bosdyn::api::Metadata* mutable_metadata();
  void set_allocated_metadata(::bosdyn::api::Metadata* metadata);
  private:
  const ::bosdyn::api::Metadata& _internal_metadata() const;
  ::bosdyn::api::Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::bosdyn::api::Metadata* metadata);
  ::bosdyn::api::Metadata* unsafe_arena_release_metadata();

  // .bosdyn.api.AcquisitionRequestList acquisition_requests = 4;
  bool has_acquisition_requests() const;
  private:
  bool _internal_has_acquisition_requests() const;
  public:
  void clear_acquisition_requests();
  const ::bosdyn::api::AcquisitionRequestList& acquisition_requests() const;
  PROTOBUF_NODISCARD ::bosdyn::api::AcquisitionRequestList* release_acquisition_requests();
  ::bosdyn::api::AcquisitionRequestList* mutable_acquisition_requests();
  void set_allocated_acquisition_requests(::bosdyn::api::AcquisitionRequestList* acquisition_requests);
  private:
  const ::bosdyn::api::AcquisitionRequestList& _internal_acquisition_requests() const;
  ::bosdyn::api::AcquisitionRequestList* _internal_mutable_acquisition_requests();
  public:
  void unsafe_arena_set_allocated_acquisition_requests(
      ::bosdyn::api::AcquisitionRequestList* acquisition_requests);
  ::bosdyn::api::AcquisitionRequestList* unsafe_arena_release_acquisition_requests();

  // .google.protobuf.Duration min_timeout = 5;
  bool has_min_timeout() const;
  private:
  bool _internal_has_min_timeout() const;
  public:
  void clear_min_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& min_timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_min_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_min_timeout();
  void set_allocated_min_timeout(::PROTOBUF_NAMESPACE_ID::Duration* min_timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_min_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_min_timeout();
  public:
  void unsafe_arena_set_allocated_min_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* min_timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_min_timeout();

  // @@protoc_insertion_point(class_scope:bosdyn.api.AcquireDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::CaptureActionId* action_id_;
    ::bosdyn::api::Metadata* metadata_;
    ::bosdyn::api::AcquisitionRequestList* acquisition_requests_;
    ::PROTOBUF_NAMESPACE_ID::Duration* min_timeout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class AcquireDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.AcquireDataResponse) */ {
 public:
  inline AcquireDataResponse() : AcquireDataResponse(nullptr) {}
  ~AcquireDataResponse() override;
  explicit PROTOBUF_CONSTEXPR AcquireDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcquireDataResponse(const AcquireDataResponse& from);
  AcquireDataResponse(AcquireDataResponse&& from) noexcept
    : AcquireDataResponse() {
    *this = ::std::move(from);
  }

  inline AcquireDataResponse& operator=(const AcquireDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcquireDataResponse& operator=(AcquireDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcquireDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcquireDataResponse* internal_default_instance() {
    return reinterpret_cast<const AcquireDataResponse*>(
               &_AcquireDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AcquireDataResponse& a, AcquireDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AcquireDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcquireDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcquireDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcquireDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcquireDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AcquireDataResponse& from) {
    AcquireDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcquireDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.AcquireDataResponse";
  }
  protected:
  explicit AcquireDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AcquireDataResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    AcquireDataResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    AcquireDataResponse_Status_STATUS_OK;
  static constexpr Status STATUS_UNKNOWN_CAPTURE_TYPE =
    AcquireDataResponse_Status_STATUS_UNKNOWN_CAPTURE_TYPE;
  static inline bool Status_IsValid(int value) {
    return AcquireDataResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    AcquireDataResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    AcquireDataResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    AcquireDataResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return AcquireDataResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return AcquireDataResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return AcquireDataResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
    kRequestIdFieldNumber = 3,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.AcquireDataResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::AcquireDataResponse_Status status() const;
  void set_status(::bosdyn::api::AcquireDataResponse_Status value);
  private:
  ::bosdyn::api::AcquireDataResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::AcquireDataResponse_Status value);
  public:

  // uint32 request_id = 3;
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.AcquireDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    uint32_t request_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class AcquirePluginDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.AcquirePluginDataRequest) */ {
 public:
  inline AcquirePluginDataRequest() : AcquirePluginDataRequest(nullptr) {}
  ~AcquirePluginDataRequest() override;
  explicit PROTOBUF_CONSTEXPR AcquirePluginDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcquirePluginDataRequest(const AcquirePluginDataRequest& from);
  AcquirePluginDataRequest(AcquirePluginDataRequest&& from) noexcept
    : AcquirePluginDataRequest() {
    *this = ::std::move(from);
  }

  inline AcquirePluginDataRequest& operator=(const AcquirePluginDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcquirePluginDataRequest& operator=(AcquirePluginDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcquirePluginDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcquirePluginDataRequest* internal_default_instance() {
    return reinterpret_cast<const AcquirePluginDataRequest*>(
               &_AcquirePluginDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AcquirePluginDataRequest& a, AcquirePluginDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AcquirePluginDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcquirePluginDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcquirePluginDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcquirePluginDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcquirePluginDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AcquirePluginDataRequest& from) {
    AcquirePluginDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcquirePluginDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.AcquirePluginDataRequest";
  }
  protected:
  explicit AcquirePluginDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataIdFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kMetadataFieldNumber = 3,
    kActionIdFieldNumber = 4,
    kAcquisitionRequestsFieldNumber = 5,
  };
  // repeated .bosdyn.api.DataIdentifier data_id = 2;
  int data_id_size() const;
  private:
  int _internal_data_id_size() const;
  public:
  void clear_data_id();
  ::bosdyn::api::DataIdentifier* mutable_data_id(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >*
      mutable_data_id();
  private:
  const ::bosdyn::api::DataIdentifier& _internal_data_id(int index) const;
  ::bosdyn::api::DataIdentifier* _internal_add_data_id();
  public:
  const ::bosdyn::api::DataIdentifier& data_id(int index) const;
  ::bosdyn::api::DataIdentifier* add_data_id();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >&
      data_id() const;

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Metadata metadata = 3;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::bosdyn::api::Metadata& metadata() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Metadata* release_metadata();
  ::bosdyn::api::Metadata* mutable_metadata();
  void set_allocated_metadata(::bosdyn::api::Metadata* metadata);
  private:
  const ::bosdyn::api::Metadata& _internal_metadata() const;
  ::bosdyn::api::Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::bosdyn::api::Metadata* metadata);
  ::bosdyn::api::Metadata* unsafe_arena_release_metadata();

  // .bosdyn.api.CaptureActionId action_id = 4;
  bool has_action_id() const;
  private:
  bool _internal_has_action_id() const;
  public:
  void clear_action_id();
  const ::bosdyn::api::CaptureActionId& action_id() const;
  PROTOBUF_NODISCARD ::bosdyn::api::CaptureActionId* release_action_id();
  ::bosdyn::api::CaptureActionId* mutable_action_id();
  void set_allocated_action_id(::bosdyn::api::CaptureActionId* action_id);
  private:
  const ::bosdyn::api::CaptureActionId& _internal_action_id() const;
  ::bosdyn::api::CaptureActionId* _internal_mutable_action_id();
  public:
  void unsafe_arena_set_allocated_action_id(
      ::bosdyn::api::CaptureActionId* action_id);
  ::bosdyn::api::CaptureActionId* unsafe_arena_release_action_id();

  // .bosdyn.api.AcquisitionRequestList acquisition_requests = 5;
  bool has_acquisition_requests() const;
  private:
  bool _internal_has_acquisition_requests() const;
  public:
  void clear_acquisition_requests();
  const ::bosdyn::api::AcquisitionRequestList& acquisition_requests() const;
  PROTOBUF_NODISCARD ::bosdyn::api::AcquisitionRequestList* release_acquisition_requests();
  ::bosdyn::api::AcquisitionRequestList* mutable_acquisition_requests();
  void set_allocated_acquisition_requests(::bosdyn::api::AcquisitionRequestList* acquisition_requests);
  private:
  const ::bosdyn::api::AcquisitionRequestList& _internal_acquisition_requests() const;
  ::bosdyn::api::AcquisitionRequestList* _internal_mutable_acquisition_requests();
  public:
  void unsafe_arena_set_allocated_acquisition_requests(
      ::bosdyn::api::AcquisitionRequestList* acquisition_requests);
  ::bosdyn::api::AcquisitionRequestList* unsafe_arena_release_acquisition_requests();

  // @@protoc_insertion_point(class_scope:bosdyn.api.AcquirePluginDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier > data_id_;
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::Metadata* metadata_;
    ::bosdyn::api::CaptureActionId* action_id_;
    ::bosdyn::api::AcquisitionRequestList* acquisition_requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class AcquirePluginDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.AcquirePluginDataResponse) */ {
 public:
  inline AcquirePluginDataResponse() : AcquirePluginDataResponse(nullptr) {}
  ~AcquirePluginDataResponse() override;
  explicit PROTOBUF_CONSTEXPR AcquirePluginDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcquirePluginDataResponse(const AcquirePluginDataResponse& from);
  AcquirePluginDataResponse(AcquirePluginDataResponse&& from) noexcept
    : AcquirePluginDataResponse() {
    *this = ::std::move(from);
  }

  inline AcquirePluginDataResponse& operator=(const AcquirePluginDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcquirePluginDataResponse& operator=(AcquirePluginDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcquirePluginDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcquirePluginDataResponse* internal_default_instance() {
    return reinterpret_cast<const AcquirePluginDataResponse*>(
               &_AcquirePluginDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AcquirePluginDataResponse& a, AcquirePluginDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AcquirePluginDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcquirePluginDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcquirePluginDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcquirePluginDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcquirePluginDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AcquirePluginDataResponse& from) {
    AcquirePluginDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcquirePluginDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.AcquirePluginDataResponse";
  }
  protected:
  explicit AcquirePluginDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AcquirePluginDataResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    AcquirePluginDataResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    AcquirePluginDataResponse_Status_STATUS_OK;
  static constexpr Status STATUS_UNKNOWN_CAPTURE_TYPE =
    AcquirePluginDataResponse_Status_STATUS_UNKNOWN_CAPTURE_TYPE;
  static inline bool Status_IsValid(int value) {
    return AcquirePluginDataResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    AcquirePluginDataResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    AcquirePluginDataResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    AcquirePluginDataResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return AcquirePluginDataResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return AcquirePluginDataResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return AcquirePluginDataResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kTimeoutDeadlineFieldNumber = 5,
    kStatusFieldNumber = 2,
    kRequestIdFieldNumber = 3,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .google.protobuf.Timestamp timeout_deadline = 5;
  bool has_timeout_deadline() const;
  private:
  bool _internal_has_timeout_deadline() const;
  public:
  void clear_timeout_deadline();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timeout_deadline() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timeout_deadline();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timeout_deadline();
  void set_allocated_timeout_deadline(::PROTOBUF_NAMESPACE_ID::Timestamp* timeout_deadline);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timeout_deadline() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timeout_deadline();
  public:
  void unsafe_arena_set_allocated_timeout_deadline(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timeout_deadline);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timeout_deadline();

  // .bosdyn.api.AcquirePluginDataResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::AcquirePluginDataResponse_Status status() const;
  void set_status(::bosdyn::api::AcquirePluginDataResponse_Status value);
  private:
  ::bosdyn::api::AcquirePluginDataResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::AcquirePluginDataResponse_Status value);
  public:

  // uint32 request_id = 3;
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.AcquirePluginDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timeout_deadline_;
    int status_;
    uint32_t request_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class GetStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetStatusRequest) */ {
 public:
  inline GetStatusRequest() : GetStatusRequest(nullptr) {}
  ~GetStatusRequest() override;
  explicit PROTOBUF_CONSTEXPR GetStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStatusRequest(const GetStatusRequest& from);
  GetStatusRequest(GetStatusRequest&& from) noexcept
    : GetStatusRequest() {
    *this = ::std::move(from);
  }

  inline GetStatusRequest& operator=(const GetStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatusRequest& operator=(GetStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GetStatusRequest*>(
               &_GetStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetStatusRequest& a, GetStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStatusRequest& from) {
    GetStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetStatusRequest";
  }
  protected:
  explicit GetStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRequestIdFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // uint32 request_id = 2;
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    uint32_t request_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class GetStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetStatusResponse) */ {
 public:
  inline GetStatusResponse() : GetStatusResponse(nullptr) {}
  ~GetStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR GetStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStatusResponse(const GetStatusResponse& from);
  GetStatusResponse(GetStatusResponse&& from) noexcept
    : GetStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetStatusResponse& operator=(const GetStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatusResponse& operator=(GetStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetStatusResponse*>(
               &_GetStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetStatusResponse& a, GetStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStatusResponse& from) {
    GetStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetStatusResponse";
  }
  protected:
  explicit GetStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetStatusResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    GetStatusResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_ACQUIRING =
    GetStatusResponse_Status_STATUS_ACQUIRING;
  static constexpr Status STATUS_SAVING =
    GetStatusResponse_Status_STATUS_SAVING;
  static constexpr Status STATUS_COMPLETE =
    GetStatusResponse_Status_STATUS_COMPLETE;
  static constexpr Status STATUS_CANCEL_IN_PROGRESS =
    GetStatusResponse_Status_STATUS_CANCEL_IN_PROGRESS;
  static constexpr Status STATUS_ACQUISITION_CANCELLED =
    GetStatusResponse_Status_STATUS_ACQUISITION_CANCELLED;
  static constexpr Status STATUS_DATA_ERROR =
    GetStatusResponse_Status_STATUS_DATA_ERROR;
  static constexpr Status STATUS_TIMEDOUT =
    GetStatusResponse_Status_STATUS_TIMEDOUT;
  static constexpr Status STATUS_INTERNAL_ERROR =
    GetStatusResponse_Status_STATUS_INTERNAL_ERROR;
  static constexpr Status STATUS_CANCEL_ACQUISITION_FAILED =
    GetStatusResponse_Status_STATUS_CANCEL_ACQUISITION_FAILED;
  static constexpr Status STATUS_REQUEST_ID_DOES_NOT_EXIST =
    GetStatusResponse_Status_STATUS_REQUEST_ID_DOES_NOT_EXIST;
  static inline bool Status_IsValid(int value) {
    return GetStatusResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    GetStatusResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    GetStatusResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    GetStatusResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return GetStatusResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return GetStatusResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return GetStatusResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataSavedFieldNumber = 3,
    kDataErrorsFieldNumber = 9,
    kServiceErrorsFieldNumber = 10,
    kNetworkComputeErrorsFieldNumber = 11,
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated .bosdyn.api.DataIdentifier data_saved = 3;
  int data_saved_size() const;
  private:
  int _internal_data_saved_size() const;
  public:
  void clear_data_saved();
  ::bosdyn::api::DataIdentifier* mutable_data_saved(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >*
      mutable_data_saved();
  private:
  const ::bosdyn::api::DataIdentifier& _internal_data_saved(int index) const;
  ::bosdyn::api::DataIdentifier* _internal_add_data_saved();
  public:
  const ::bosdyn::api::DataIdentifier& data_saved(int index) const;
  ::bosdyn::api::DataIdentifier* add_data_saved();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >&
      data_saved() const;

  // repeated .bosdyn.api.DataError data_errors = 9;
  int data_errors_size() const;
  private:
  int _internal_data_errors_size() const;
  public:
  void clear_data_errors();
  ::bosdyn::api::DataError* mutable_data_errors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataError >*
      mutable_data_errors();
  private:
  const ::bosdyn::api::DataError& _internal_data_errors(int index) const;
  ::bosdyn::api::DataError* _internal_add_data_errors();
  public:
  const ::bosdyn::api::DataError& data_errors(int index) const;
  ::bosdyn::api::DataError* add_data_errors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataError >&
      data_errors() const;

  // repeated .bosdyn.api.PluginServiceError service_errors = 10;
  int service_errors_size() const;
  private:
  int _internal_service_errors_size() const;
  public:
  void clear_service_errors();
  ::bosdyn::api::PluginServiceError* mutable_service_errors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PluginServiceError >*
      mutable_service_errors();
  private:
  const ::bosdyn::api::PluginServiceError& _internal_service_errors(int index) const;
  ::bosdyn::api::PluginServiceError* _internal_add_service_errors();
  public:
  const ::bosdyn::api::PluginServiceError& service_errors(int index) const;
  ::bosdyn::api::PluginServiceError* add_service_errors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PluginServiceError >&
      service_errors() const;

  // repeated .bosdyn.api.NetworkComputeError network_compute_errors = 11;
  int network_compute_errors_size() const;
  private:
  int _internal_network_compute_errors_size() const;
  public:
  void clear_network_compute_errors();
  ::bosdyn::api::NetworkComputeError* mutable_network_compute_errors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::NetworkComputeError >*
      mutable_network_compute_errors();
  private:
  const ::bosdyn::api::NetworkComputeError& _internal_network_compute_errors(int index) const;
  ::bosdyn::api::NetworkComputeError* _internal_add_network_compute_errors();
  public:
  const ::bosdyn::api::NetworkComputeError& network_compute_errors(int index) const;
  ::bosdyn::api::NetworkComputeError* add_network_compute_errors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::NetworkComputeError >&
      network_compute_errors() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.GetStatusResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::GetStatusResponse_Status status() const;
  void set_status(::bosdyn::api::GetStatusResponse_Status value);
  private:
  ::bosdyn::api::GetStatusResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::GetStatusResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier > data_saved_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataError > data_errors_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PluginServiceError > service_errors_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::NetworkComputeError > network_compute_errors_;
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class GetServiceInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetServiceInfoRequest) */ {
 public:
  inline GetServiceInfoRequest() : GetServiceInfoRequest(nullptr) {}
  ~GetServiceInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR GetServiceInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServiceInfoRequest(const GetServiceInfoRequest& from);
  GetServiceInfoRequest(GetServiceInfoRequest&& from) noexcept
    : GetServiceInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetServiceInfoRequest& operator=(const GetServiceInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServiceInfoRequest& operator=(GetServiceInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServiceInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServiceInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetServiceInfoRequest*>(
               &_GetServiceInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetServiceInfoRequest& a, GetServiceInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServiceInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServiceInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServiceInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServiceInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServiceInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetServiceInfoRequest& from) {
    GetServiceInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServiceInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetServiceInfoRequest";
  }
  protected:
  explicit GetServiceInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetServiceInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class GetServiceInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetServiceInfoResponse) */ {
 public:
  inline GetServiceInfoResponse() : GetServiceInfoResponse(nullptr) {}
  ~GetServiceInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR GetServiceInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServiceInfoResponse(const GetServiceInfoResponse& from);
  GetServiceInfoResponse(GetServiceInfoResponse&& from) noexcept
    : GetServiceInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetServiceInfoResponse& operator=(const GetServiceInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServiceInfoResponse& operator=(GetServiceInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServiceInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServiceInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetServiceInfoResponse*>(
               &_GetServiceInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetServiceInfoResponse& a, GetServiceInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServiceInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServiceInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServiceInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServiceInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServiceInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetServiceInfoResponse& from) {
    GetServiceInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServiceInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetServiceInfoResponse";
  }
  protected:
  explicit GetServiceInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kCapabilitiesFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.AcquisitionCapabilityList capabilities = 2;
  bool has_capabilities() const;
  private:
  bool _internal_has_capabilities() const;
  public:
  void clear_capabilities();
  const ::bosdyn::api::AcquisitionCapabilityList& capabilities() const;
  PROTOBUF_NODISCARD ::bosdyn::api::AcquisitionCapabilityList* release_capabilities();
  ::bosdyn::api::AcquisitionCapabilityList* mutable_capabilities();
  void set_allocated_capabilities(::bosdyn::api::AcquisitionCapabilityList* capabilities);
  private:
  const ::bosdyn::api::AcquisitionCapabilityList& _internal_capabilities() const;
  ::bosdyn::api::AcquisitionCapabilityList* _internal_mutable_capabilities();
  public:
  void unsafe_arena_set_allocated_capabilities(
      ::bosdyn::api::AcquisitionCapabilityList* capabilities);
  ::bosdyn::api::AcquisitionCapabilityList* unsafe_arena_release_capabilities();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetServiceInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::AcquisitionCapabilityList* capabilities_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class CancelAcquisitionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.CancelAcquisitionRequest) */ {
 public:
  inline CancelAcquisitionRequest() : CancelAcquisitionRequest(nullptr) {}
  ~CancelAcquisitionRequest() override;
  explicit PROTOBUF_CONSTEXPR CancelAcquisitionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelAcquisitionRequest(const CancelAcquisitionRequest& from);
  CancelAcquisitionRequest(CancelAcquisitionRequest&& from) noexcept
    : CancelAcquisitionRequest() {
    *this = ::std::move(from);
  }

  inline CancelAcquisitionRequest& operator=(const CancelAcquisitionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelAcquisitionRequest& operator=(CancelAcquisitionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelAcquisitionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelAcquisitionRequest* internal_default_instance() {
    return reinterpret_cast<const CancelAcquisitionRequest*>(
               &_CancelAcquisitionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CancelAcquisitionRequest& a, CancelAcquisitionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelAcquisitionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelAcquisitionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelAcquisitionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelAcquisitionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelAcquisitionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelAcquisitionRequest& from) {
    CancelAcquisitionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelAcquisitionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.CancelAcquisitionRequest";
  }
  protected:
  explicit CancelAcquisitionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRequestIdFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // uint32 request_id = 2;
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.CancelAcquisitionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    uint32_t request_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// -------------------------------------------------------------------

class CancelAcquisitionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.CancelAcquisitionResponse) */ {
 public:
  inline CancelAcquisitionResponse() : CancelAcquisitionResponse(nullptr) {}
  ~CancelAcquisitionResponse() override;
  explicit PROTOBUF_CONSTEXPR CancelAcquisitionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelAcquisitionResponse(const CancelAcquisitionResponse& from);
  CancelAcquisitionResponse(CancelAcquisitionResponse&& from) noexcept
    : CancelAcquisitionResponse() {
    *this = ::std::move(from);
  }

  inline CancelAcquisitionResponse& operator=(const CancelAcquisitionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelAcquisitionResponse& operator=(CancelAcquisitionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelAcquisitionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelAcquisitionResponse* internal_default_instance() {
    return reinterpret_cast<const CancelAcquisitionResponse*>(
               &_CancelAcquisitionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CancelAcquisitionResponse& a, CancelAcquisitionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelAcquisitionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelAcquisitionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelAcquisitionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelAcquisitionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelAcquisitionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelAcquisitionResponse& from) {
    CancelAcquisitionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelAcquisitionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.CancelAcquisitionResponse";
  }
  protected:
  explicit CancelAcquisitionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CancelAcquisitionResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    CancelAcquisitionResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    CancelAcquisitionResponse_Status_STATUS_OK;
  static constexpr Status STATUS_FAILED_TO_CANCEL =
    CancelAcquisitionResponse_Status_STATUS_FAILED_TO_CANCEL;
  static constexpr Status STATUS_REQUEST_ID_DOES_NOT_EXIST =
    CancelAcquisitionResponse_Status_STATUS_REQUEST_ID_DOES_NOT_EXIST;
  static inline bool Status_IsValid(int value) {
    return CancelAcquisitionResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    CancelAcquisitionResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    CancelAcquisitionResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    CancelAcquisitionResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return CancelAcquisitionResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return CancelAcquisitionResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return CancelAcquisitionResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.CancelAcquisitionResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::CancelAcquisitionResponse_Status status() const;
  void set_status(::bosdyn::api::CancelAcquisitionResponse_Status value);
  private:
  ::bosdyn::api::CancelAcquisitionResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::CancelAcquisitionResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.CancelAcquisitionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DataAcquisitionCapability

// string name = 1;
inline void DataAcquisitionCapability::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DataAcquisitionCapability::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataAcquisitionCapability.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataAcquisitionCapability::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.DataAcquisitionCapability.name)
}
inline std::string* DataAcquisitionCapability::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataAcquisitionCapability.name)
  return _s;
}
inline const std::string& DataAcquisitionCapability::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DataAcquisitionCapability::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataAcquisitionCapability::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataAcquisitionCapability::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataAcquisitionCapability.name)
  return _impl_.name_.Release();
}
inline void DataAcquisitionCapability::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataAcquisitionCapability.name)
}

// string description = 2;
inline void DataAcquisitionCapability::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& DataAcquisitionCapability::description() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataAcquisitionCapability.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataAcquisitionCapability::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.DataAcquisitionCapability.description)
}
inline std::string* DataAcquisitionCapability::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataAcquisitionCapability.description)
  return _s;
}
inline const std::string& DataAcquisitionCapability::_internal_description() const {
  return _impl_.description_.Get();
}
inline void DataAcquisitionCapability::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* DataAcquisitionCapability::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* DataAcquisitionCapability::release_description() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataAcquisitionCapability.description)
  return _impl_.description_.Release();
}
inline void DataAcquisitionCapability::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataAcquisitionCapability.description)
}

// string channel_name = 3;
inline void DataAcquisitionCapability::clear_channel_name() {
  _impl_.channel_name_.ClearToEmpty();
}
inline const std::string& DataAcquisitionCapability::channel_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataAcquisitionCapability.channel_name)
  return _internal_channel_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataAcquisitionCapability::set_channel_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.channel_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.DataAcquisitionCapability.channel_name)
}
inline std::string* DataAcquisitionCapability::mutable_channel_name() {
  std::string* _s = _internal_mutable_channel_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataAcquisitionCapability.channel_name)
  return _s;
}
inline const std::string& DataAcquisitionCapability::_internal_channel_name() const {
  return _impl_.channel_name_.Get();
}
inline void DataAcquisitionCapability::_internal_set_channel_name(const std::string& value) {
  
  _impl_.channel_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataAcquisitionCapability::_internal_mutable_channel_name() {
  
  return _impl_.channel_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataAcquisitionCapability::release_channel_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataAcquisitionCapability.channel_name)
  return _impl_.channel_name_.Release();
}
inline void DataAcquisitionCapability::set_allocated_channel_name(std::string* channel_name) {
  if (channel_name != nullptr) {
    
  } else {
    
  }
  _impl_.channel_name_.SetAllocated(channel_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.channel_name_.IsDefault()) {
    _impl_.channel_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataAcquisitionCapability.channel_name)
}

// string service_name = 4;
inline void DataAcquisitionCapability::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& DataAcquisitionCapability::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataAcquisitionCapability.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataAcquisitionCapability::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.DataAcquisitionCapability.service_name)
}
inline std::string* DataAcquisitionCapability::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataAcquisitionCapability.service_name)
  return _s;
}
inline const std::string& DataAcquisitionCapability::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void DataAcquisitionCapability::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataAcquisitionCapability::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataAcquisitionCapability::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataAcquisitionCapability.service_name)
  return _impl_.service_name_.Release();
}
inline void DataAcquisitionCapability::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataAcquisitionCapability.service_name)
}

// -------------------------------------------------------------------

// ImageAcquisitionCapability

// string service_name = 1;
inline void ImageAcquisitionCapability::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& ImageAcquisitionCapability::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageAcquisitionCapability.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageAcquisitionCapability::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageAcquisitionCapability.service_name)
}
inline std::string* ImageAcquisitionCapability::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageAcquisitionCapability.service_name)
  return _s;
}
inline const std::string& ImageAcquisitionCapability::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void ImageAcquisitionCapability::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageAcquisitionCapability::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageAcquisitionCapability::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageAcquisitionCapability.service_name)
  return _impl_.service_name_.Release();
}
inline void ImageAcquisitionCapability::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageAcquisitionCapability.service_name)
}

// repeated string image_source_names = 2;
inline int ImageAcquisitionCapability::_internal_image_source_names_size() const {
  return _impl_.image_source_names_.size();
}
inline int ImageAcquisitionCapability::image_source_names_size() const {
  return _internal_image_source_names_size();
}
inline void ImageAcquisitionCapability::clear_image_source_names() {
  _impl_.image_source_names_.Clear();
}
inline std::string* ImageAcquisitionCapability::add_image_source_names() {
  std::string* _s = _internal_add_image_source_names();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.ImageAcquisitionCapability.image_source_names)
  return _s;
}
inline const std::string& ImageAcquisitionCapability::_internal_image_source_names(int index) const {
  return _impl_.image_source_names_.Get(index);
}
inline const std::string& ImageAcquisitionCapability::image_source_names(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageAcquisitionCapability.image_source_names)
  return _internal_image_source_names(index);
}
inline std::string* ImageAcquisitionCapability::mutable_image_source_names(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageAcquisitionCapability.image_source_names)
  return _impl_.image_source_names_.Mutable(index);
}
inline void ImageAcquisitionCapability::set_image_source_names(int index, const std::string& value) {
  _impl_.image_source_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageAcquisitionCapability.image_source_names)
}
inline void ImageAcquisitionCapability::set_image_source_names(int index, std::string&& value) {
  _impl_.image_source_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageAcquisitionCapability.image_source_names)
}
inline void ImageAcquisitionCapability::set_image_source_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.image_source_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.ImageAcquisitionCapability.image_source_names)
}
inline void ImageAcquisitionCapability::set_image_source_names(int index, const char* value, size_t size) {
  _impl_.image_source_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.ImageAcquisitionCapability.image_source_names)
}
inline std::string* ImageAcquisitionCapability::_internal_add_image_source_names() {
  return _impl_.image_source_names_.Add();
}
inline void ImageAcquisitionCapability::add_image_source_names(const std::string& value) {
  _impl_.image_source_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.ImageAcquisitionCapability.image_source_names)
}
inline void ImageAcquisitionCapability::add_image_source_names(std::string&& value) {
  _impl_.image_source_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.ImageAcquisitionCapability.image_source_names)
}
inline void ImageAcquisitionCapability::add_image_source_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.image_source_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.ImageAcquisitionCapability.image_source_names)
}
inline void ImageAcquisitionCapability::add_image_source_names(const char* value, size_t size) {
  _impl_.image_source_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.ImageAcquisitionCapability.image_source_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ImageAcquisitionCapability::image_source_names() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ImageAcquisitionCapability.image_source_names)
  return _impl_.image_source_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ImageAcquisitionCapability::mutable_image_source_names() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ImageAcquisitionCapability.image_source_names)
  return &_impl_.image_source_names_;
}

// repeated .bosdyn.api.ImageSource image_sources = 3;
inline int ImageAcquisitionCapability::_internal_image_sources_size() const {
  return _impl_.image_sources_.size();
}
inline int ImageAcquisitionCapability::image_sources_size() const {
  return _internal_image_sources_size();
}
inline ::bosdyn::api::ImageSource* ImageAcquisitionCapability::mutable_image_sources(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageAcquisitionCapability.image_sources)
  return _impl_.image_sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSource >*
ImageAcquisitionCapability::mutable_image_sources() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ImageAcquisitionCapability.image_sources)
  return &_impl_.image_sources_;
}
inline const ::bosdyn::api::ImageSource& ImageAcquisitionCapability::_internal_image_sources(int index) const {
  return _impl_.image_sources_.Get(index);
}
inline const ::bosdyn::api::ImageSource& ImageAcquisitionCapability::image_sources(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageAcquisitionCapability.image_sources)
  return _internal_image_sources(index);
}
inline ::bosdyn::api::ImageSource* ImageAcquisitionCapability::_internal_add_image_sources() {
  return _impl_.image_sources_.Add();
}
inline ::bosdyn::api::ImageSource* ImageAcquisitionCapability::add_image_sources() {
  ::bosdyn::api::ImageSource* _add = _internal_add_image_sources();
  // @@protoc_insertion_point(field_add:bosdyn.api.ImageAcquisitionCapability.image_sources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSource >&
ImageAcquisitionCapability::image_sources() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ImageAcquisitionCapability.image_sources)
  return _impl_.image_sources_;
}

// -------------------------------------------------------------------

// NetworkComputeCapability

// .bosdyn.api.NetworkComputeServerConfiguration server_config = 1;
inline bool NetworkComputeCapability::_internal_has_server_config() const {
  return this != internal_default_instance() && _impl_.server_config_ != nullptr;
}
inline bool NetworkComputeCapability::has_server_config() const {
  return _internal_has_server_config();
}
inline const ::bosdyn::api::NetworkComputeServerConfiguration& NetworkComputeCapability::_internal_server_config() const {
  const ::bosdyn::api::NetworkComputeServerConfiguration* p = _impl_.server_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::NetworkComputeServerConfiguration&>(
      ::bosdyn::api::_NetworkComputeServerConfiguration_default_instance_);
}
inline const ::bosdyn::api::NetworkComputeServerConfiguration& NetworkComputeCapability::server_config() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeCapability.server_config)
  return _internal_server_config();
}
inline void NetworkComputeCapability::unsafe_arena_set_allocated_server_config(
    ::bosdyn::api::NetworkComputeServerConfiguration* server_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_config_);
  }
  _impl_.server_config_ = server_config;
  if (server_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.NetworkComputeCapability.server_config)
}
inline ::bosdyn::api::NetworkComputeServerConfiguration* NetworkComputeCapability::release_server_config() {
  
  ::bosdyn::api::NetworkComputeServerConfiguration* temp = _impl_.server_config_;
  _impl_.server_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::NetworkComputeServerConfiguration* NetworkComputeCapability::unsafe_arena_release_server_config() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeCapability.server_config)
  
  ::bosdyn::api::NetworkComputeServerConfiguration* temp = _impl_.server_config_;
  _impl_.server_config_ = nullptr;
  return temp;
}
inline ::bosdyn::api::NetworkComputeServerConfiguration* NetworkComputeCapability::_internal_mutable_server_config() {
  
  if (_impl_.server_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::NetworkComputeServerConfiguration>(GetArenaForAllocation());
    _impl_.server_config_ = p;
  }
  return _impl_.server_config_;
}
inline ::bosdyn::api::NetworkComputeServerConfiguration* NetworkComputeCapability::mutable_server_config() {
  ::bosdyn::api::NetworkComputeServerConfiguration* _msg = _internal_mutable_server_config();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeCapability.server_config)
  return _msg;
}
inline void NetworkComputeCapability::set_allocated_server_config(::bosdyn::api::NetworkComputeServerConfiguration* server_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_config_);
  }
  if (server_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_config));
    if (message_arena != submessage_arena) {
      server_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.server_config_ = server_config;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.NetworkComputeCapability.server_config)
}

// repeated string available_models = 2;
inline int NetworkComputeCapability::_internal_available_models_size() const {
  return _impl_.available_models_.size();
}
inline int NetworkComputeCapability::available_models_size() const {
  return _internal_available_models_size();
}
inline void NetworkComputeCapability::clear_available_models() {
  _impl_.available_models_.Clear();
}
inline std::string* NetworkComputeCapability::add_available_models() {
  std::string* _s = _internal_add_available_models();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.NetworkComputeCapability.available_models)
  return _s;
}
inline const std::string& NetworkComputeCapability::_internal_available_models(int index) const {
  return _impl_.available_models_.Get(index);
}
inline const std::string& NetworkComputeCapability::available_models(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeCapability.available_models)
  return _internal_available_models(index);
}
inline std::string* NetworkComputeCapability::mutable_available_models(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeCapability.available_models)
  return _impl_.available_models_.Mutable(index);
}
inline void NetworkComputeCapability::set_available_models(int index, const std::string& value) {
  _impl_.available_models_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.NetworkComputeCapability.available_models)
}
inline void NetworkComputeCapability::set_available_models(int index, std::string&& value) {
  _impl_.available_models_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.NetworkComputeCapability.available_models)
}
inline void NetworkComputeCapability::set_available_models(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.available_models_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.NetworkComputeCapability.available_models)
}
inline void NetworkComputeCapability::set_available_models(int index, const char* value, size_t size) {
  _impl_.available_models_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.NetworkComputeCapability.available_models)
}
inline std::string* NetworkComputeCapability::_internal_add_available_models() {
  return _impl_.available_models_.Add();
}
inline void NetworkComputeCapability::add_available_models(const std::string& value) {
  _impl_.available_models_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.NetworkComputeCapability.available_models)
}
inline void NetworkComputeCapability::add_available_models(std::string&& value) {
  _impl_.available_models_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.NetworkComputeCapability.available_models)
}
inline void NetworkComputeCapability::add_available_models(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.available_models_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.NetworkComputeCapability.available_models)
}
inline void NetworkComputeCapability::add_available_models(const char* value, size_t size) {
  _impl_.available_models_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.NetworkComputeCapability.available_models)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NetworkComputeCapability::available_models() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.NetworkComputeCapability.available_models)
  return _impl_.available_models_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NetworkComputeCapability::mutable_available_models() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.NetworkComputeCapability.available_models)
  return &_impl_.available_models_;
}

// repeated .bosdyn.api.ModelLabels labels = 6;
inline int NetworkComputeCapability::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int NetworkComputeCapability::labels_size() const {
  return _internal_labels_size();
}
inline ::bosdyn::api::ModelLabels* NetworkComputeCapability::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeCapability.labels)
  return _impl_.labels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ModelLabels >*
NetworkComputeCapability::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.NetworkComputeCapability.labels)
  return &_impl_.labels_;
}
inline const ::bosdyn::api::ModelLabels& NetworkComputeCapability::_internal_labels(int index) const {
  return _impl_.labels_.Get(index);
}
inline const ::bosdyn::api::ModelLabels& NetworkComputeCapability::labels(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeCapability.labels)
  return _internal_labels(index);
}
inline ::bosdyn::api::ModelLabels* NetworkComputeCapability::_internal_add_labels() {
  return _impl_.labels_.Add();
}
inline ::bosdyn::api::ModelLabels* NetworkComputeCapability::add_labels() {
  ::bosdyn::api::ModelLabels* _add = _internal_add_labels();
  // @@protoc_insertion_point(field_add:bosdyn.api.NetworkComputeCapability.labels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ModelLabels >&
NetworkComputeCapability::labels() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.NetworkComputeCapability.labels)
  return _impl_.labels_;
}

// -------------------------------------------------------------------

// AcquisitionCapabilityList

// repeated .bosdyn.api.DataAcquisitionCapability data_sources = 1;
inline int AcquisitionCapabilityList::_internal_data_sources_size() const {
  return _impl_.data_sources_.size();
}
inline int AcquisitionCapabilityList::data_sources_size() const {
  return _internal_data_sources_size();
}
inline void AcquisitionCapabilityList::clear_data_sources() {
  _impl_.data_sources_.Clear();
}
inline ::bosdyn::api::DataAcquisitionCapability* AcquisitionCapabilityList::mutable_data_sources(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquisitionCapabilityList.data_sources)
  return _impl_.data_sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataAcquisitionCapability >*
AcquisitionCapabilityList::mutable_data_sources() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.AcquisitionCapabilityList.data_sources)
  return &_impl_.data_sources_;
}
inline const ::bosdyn::api::DataAcquisitionCapability& AcquisitionCapabilityList::_internal_data_sources(int index) const {
  return _impl_.data_sources_.Get(index);
}
inline const ::bosdyn::api::DataAcquisitionCapability& AcquisitionCapabilityList::data_sources(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquisitionCapabilityList.data_sources)
  return _internal_data_sources(index);
}
inline ::bosdyn::api::DataAcquisitionCapability* AcquisitionCapabilityList::_internal_add_data_sources() {
  return _impl_.data_sources_.Add();
}
inline ::bosdyn::api::DataAcquisitionCapability* AcquisitionCapabilityList::add_data_sources() {
  ::bosdyn::api::DataAcquisitionCapability* _add = _internal_add_data_sources();
  // @@protoc_insertion_point(field_add:bosdyn.api.AcquisitionCapabilityList.data_sources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataAcquisitionCapability >&
AcquisitionCapabilityList::data_sources() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.AcquisitionCapabilityList.data_sources)
  return _impl_.data_sources_;
}

// repeated .bosdyn.api.ImageAcquisitionCapability image_sources = 3;
inline int AcquisitionCapabilityList::_internal_image_sources_size() const {
  return _impl_.image_sources_.size();
}
inline int AcquisitionCapabilityList::image_sources_size() const {
  return _internal_image_sources_size();
}
inline void AcquisitionCapabilityList::clear_image_sources() {
  _impl_.image_sources_.Clear();
}
inline ::bosdyn::api::ImageAcquisitionCapability* AcquisitionCapabilityList::mutable_image_sources(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquisitionCapabilityList.image_sources)
  return _impl_.image_sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageAcquisitionCapability >*
AcquisitionCapabilityList::mutable_image_sources() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.AcquisitionCapabilityList.image_sources)
  return &_impl_.image_sources_;
}
inline const ::bosdyn::api::ImageAcquisitionCapability& AcquisitionCapabilityList::_internal_image_sources(int index) const {
  return _impl_.image_sources_.Get(index);
}
inline const ::bosdyn::api::ImageAcquisitionCapability& AcquisitionCapabilityList::image_sources(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquisitionCapabilityList.image_sources)
  return _internal_image_sources(index);
}
inline ::bosdyn::api::ImageAcquisitionCapability* AcquisitionCapabilityList::_internal_add_image_sources() {
  return _impl_.image_sources_.Add();
}
inline ::bosdyn::api::ImageAcquisitionCapability* AcquisitionCapabilityList::add_image_sources() {
  ::bosdyn::api::ImageAcquisitionCapability* _add = _internal_add_image_sources();
  // @@protoc_insertion_point(field_add:bosdyn.api.AcquisitionCapabilityList.image_sources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageAcquisitionCapability >&
AcquisitionCapabilityList::image_sources() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.AcquisitionCapabilityList.image_sources)
  return _impl_.image_sources_;
}

// repeated .bosdyn.api.NetworkComputeCapability network_compute_sources = 5;
inline int AcquisitionCapabilityList::_internal_network_compute_sources_size() const {
  return _impl_.network_compute_sources_.size();
}
inline int AcquisitionCapabilityList::network_compute_sources_size() const {
  return _internal_network_compute_sources_size();
}
inline void AcquisitionCapabilityList::clear_network_compute_sources() {
  _impl_.network_compute_sources_.Clear();
}
inline ::bosdyn::api::NetworkComputeCapability* AcquisitionCapabilityList::mutable_network_compute_sources(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquisitionCapabilityList.network_compute_sources)
  return _impl_.network_compute_sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::NetworkComputeCapability >*
AcquisitionCapabilityList::mutable_network_compute_sources() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.AcquisitionCapabilityList.network_compute_sources)
  return &_impl_.network_compute_sources_;
}
inline const ::bosdyn::api::NetworkComputeCapability& AcquisitionCapabilityList::_internal_network_compute_sources(int index) const {
  return _impl_.network_compute_sources_.Get(index);
}
inline const ::bosdyn::api::NetworkComputeCapability& AcquisitionCapabilityList::network_compute_sources(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquisitionCapabilityList.network_compute_sources)
  return _internal_network_compute_sources(index);
}
inline ::bosdyn::api::NetworkComputeCapability* AcquisitionCapabilityList::_internal_add_network_compute_sources() {
  return _impl_.network_compute_sources_.Add();
}
inline ::bosdyn::api::NetworkComputeCapability* AcquisitionCapabilityList::add_network_compute_sources() {
  ::bosdyn::api::NetworkComputeCapability* _add = _internal_add_network_compute_sources();
  // @@protoc_insertion_point(field_add:bosdyn.api.AcquisitionCapabilityList.network_compute_sources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::NetworkComputeCapability >&
AcquisitionCapabilityList::network_compute_sources() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.AcquisitionCapabilityList.network_compute_sources)
  return _impl_.network_compute_sources_;
}

// -------------------------------------------------------------------

// CaptureActionId

// string action_name = 1;
inline void CaptureActionId::clear_action_name() {
  _impl_.action_name_.ClearToEmpty();
}
inline const std::string& CaptureActionId::action_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CaptureActionId.action_name)
  return _internal_action_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CaptureActionId::set_action_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.action_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.CaptureActionId.action_name)
}
inline std::string* CaptureActionId::mutable_action_name() {
  std::string* _s = _internal_mutable_action_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.CaptureActionId.action_name)
  return _s;
}
inline const std::string& CaptureActionId::_internal_action_name() const {
  return _impl_.action_name_.Get();
}
inline void CaptureActionId::_internal_set_action_name(const std::string& value) {
  
  _impl_.action_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CaptureActionId::_internal_mutable_action_name() {
  
  return _impl_.action_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CaptureActionId::release_action_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.CaptureActionId.action_name)
  return _impl_.action_name_.Release();
}
inline void CaptureActionId::set_allocated_action_name(std::string* action_name) {
  if (action_name != nullptr) {
    
  } else {
    
  }
  _impl_.action_name_.SetAllocated(action_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.action_name_.IsDefault()) {
    _impl_.action_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.CaptureActionId.action_name)
}

// string group_name = 2;
inline void CaptureActionId::clear_group_name() {
  _impl_.group_name_.ClearToEmpty();
}
inline const std::string& CaptureActionId::group_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CaptureActionId.group_name)
  return _internal_group_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CaptureActionId::set_group_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.group_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.CaptureActionId.group_name)
}
inline std::string* CaptureActionId::mutable_group_name() {
  std::string* _s = _internal_mutable_group_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.CaptureActionId.group_name)
  return _s;
}
inline const std::string& CaptureActionId::_internal_group_name() const {
  return _impl_.group_name_.Get();
}
inline void CaptureActionId::_internal_set_group_name(const std::string& value) {
  
  _impl_.group_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CaptureActionId::_internal_mutable_group_name() {
  
  return _impl_.group_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CaptureActionId::release_group_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.CaptureActionId.group_name)
  return _impl_.group_name_.Release();
}
inline void CaptureActionId::set_allocated_group_name(std::string* group_name) {
  if (group_name != nullptr) {
    
  } else {
    
  }
  _impl_.group_name_.SetAllocated(group_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_name_.IsDefault()) {
    _impl_.group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.CaptureActionId.group_name)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool CaptureActionId::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool CaptureActionId::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CaptureActionId::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CaptureActionId::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CaptureActionId.timestamp)
  return _internal_timestamp();
}
inline void CaptureActionId::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.CaptureActionId.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureActionId::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureActionId::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.CaptureActionId.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureActionId::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureActionId::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.CaptureActionId.timestamp)
  return _msg;
}
inline void CaptureActionId::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.CaptureActionId.timestamp)
}

// -------------------------------------------------------------------

// DataIdentifier

// .bosdyn.api.CaptureActionId action_id = 1;
inline bool DataIdentifier::_internal_has_action_id() const {
  return this != internal_default_instance() && _impl_.action_id_ != nullptr;
}
inline bool DataIdentifier::has_action_id() const {
  return _internal_has_action_id();
}
inline void DataIdentifier::clear_action_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.action_id_ != nullptr) {
    delete _impl_.action_id_;
  }
  _impl_.action_id_ = nullptr;
}
inline const ::bosdyn::api::CaptureActionId& DataIdentifier::_internal_action_id() const {
  const ::bosdyn::api::CaptureActionId* p = _impl_.action_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::CaptureActionId&>(
      ::bosdyn::api::_CaptureActionId_default_instance_);
}
inline const ::bosdyn::api::CaptureActionId& DataIdentifier::action_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataIdentifier.action_id)
  return _internal_action_id();
}
inline void DataIdentifier::unsafe_arena_set_allocated_action_id(
    ::bosdyn::api::CaptureActionId* action_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.action_id_);
  }
  _impl_.action_id_ = action_id;
  if (action_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DataIdentifier.action_id)
}
inline ::bosdyn::api::CaptureActionId* DataIdentifier::release_action_id() {
  
  ::bosdyn::api::CaptureActionId* temp = _impl_.action_id_;
  _impl_.action_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::CaptureActionId* DataIdentifier::unsafe_arena_release_action_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataIdentifier.action_id)
  
  ::bosdyn::api::CaptureActionId* temp = _impl_.action_id_;
  _impl_.action_id_ = nullptr;
  return temp;
}
inline ::bosdyn::api::CaptureActionId* DataIdentifier::_internal_mutable_action_id() {
  
  if (_impl_.action_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::CaptureActionId>(GetArenaForAllocation());
    _impl_.action_id_ = p;
  }
  return _impl_.action_id_;
}
inline ::bosdyn::api::CaptureActionId* DataIdentifier::mutable_action_id() {
  ::bosdyn::api::CaptureActionId* _msg = _internal_mutable_action_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataIdentifier.action_id)
  return _msg;
}
inline void DataIdentifier::set_allocated_action_id(::bosdyn::api::CaptureActionId* action_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.action_id_;
  }
  if (action_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(action_id);
    if (message_arena != submessage_arena) {
      action_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.action_id_ = action_id;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataIdentifier.action_id)
}

// string channel = 2;
inline void DataIdentifier::clear_channel() {
  _impl_.channel_.ClearToEmpty();
}
inline const std::string& DataIdentifier::channel() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataIdentifier.channel)
  return _internal_channel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataIdentifier::set_channel(ArgT0&& arg0, ArgT... args) {
 
 _impl_.channel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.DataIdentifier.channel)
}
inline std::string* DataIdentifier::mutable_channel() {
  std::string* _s = _internal_mutable_channel();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataIdentifier.channel)
  return _s;
}
inline const std::string& DataIdentifier::_internal_channel() const {
  return _impl_.channel_.Get();
}
inline void DataIdentifier::_internal_set_channel(const std::string& value) {
  
  _impl_.channel_.Set(value, GetArenaForAllocation());
}
inline std::string* DataIdentifier::_internal_mutable_channel() {
  
  return _impl_.channel_.Mutable(GetArenaForAllocation());
}
inline std::string* DataIdentifier::release_channel() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataIdentifier.channel)
  return _impl_.channel_.Release();
}
inline void DataIdentifier::set_allocated_channel(std::string* channel) {
  if (channel != nullptr) {
    
  } else {
    
  }
  _impl_.channel_.SetAllocated(channel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.channel_.IsDefault()) {
    _impl_.channel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataIdentifier.channel)
}

// string data_name = 3;
inline void DataIdentifier::clear_data_name() {
  _impl_.data_name_.ClearToEmpty();
}
inline const std::string& DataIdentifier::data_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataIdentifier.data_name)
  return _internal_data_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataIdentifier::set_data_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.DataIdentifier.data_name)
}
inline std::string* DataIdentifier::mutable_data_name() {
  std::string* _s = _internal_mutable_data_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataIdentifier.data_name)
  return _s;
}
inline const std::string& DataIdentifier::_internal_data_name() const {
  return _impl_.data_name_.Get();
}
inline void DataIdentifier::_internal_set_data_name(const std::string& value) {
  
  _impl_.data_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataIdentifier::_internal_mutable_data_name() {
  
  return _impl_.data_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataIdentifier::release_data_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataIdentifier.data_name)
  return _impl_.data_name_.Release();
}
inline void DataIdentifier::set_allocated_data_name(std::string* data_name) {
  if (data_name != nullptr) {
    
  } else {
    
  }
  _impl_.data_name_.SetAllocated(data_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_name_.IsDefault()) {
    _impl_.data_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataIdentifier.data_name)
}

// -------------------------------------------------------------------

// Metadata

// .google.protobuf.Struct data = 1;
inline bool Metadata::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool Metadata::has_data() const {
  return _internal_has_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Metadata::_internal_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Metadata::data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Metadata.data)
  return _internal_data();
}
inline void Metadata::unsafe_arena_set_allocated_data(
    ::PROTOBUF_NAMESPACE_ID::Struct* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Metadata.data)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Metadata::release_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Metadata::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Metadata.data)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Metadata::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Metadata::mutable_data() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Metadata.data)
  return _msg;
}
inline void Metadata::set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Metadata.data)
}

// -------------------------------------------------------------------

// AssociatedMetadata

// .bosdyn.api.DataIdentifier reference_id = 1;
inline bool AssociatedMetadata::_internal_has_reference_id() const {
  return this != internal_default_instance() && _impl_.reference_id_ != nullptr;
}
inline bool AssociatedMetadata::has_reference_id() const {
  return _internal_has_reference_id();
}
inline void AssociatedMetadata::clear_reference_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.reference_id_ != nullptr) {
    delete _impl_.reference_id_;
  }
  _impl_.reference_id_ = nullptr;
}
inline const ::bosdyn::api::DataIdentifier& AssociatedMetadata::_internal_reference_id() const {
  const ::bosdyn::api::DataIdentifier* p = _impl_.reference_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataIdentifier&>(
      ::bosdyn::api::_DataIdentifier_default_instance_);
}
inline const ::bosdyn::api::DataIdentifier& AssociatedMetadata::reference_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AssociatedMetadata.reference_id)
  return _internal_reference_id();
}
inline void AssociatedMetadata::unsafe_arena_set_allocated_reference_id(
    ::bosdyn::api::DataIdentifier* reference_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reference_id_);
  }
  _impl_.reference_id_ = reference_id;
  if (reference_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AssociatedMetadata.reference_id)
}
inline ::bosdyn::api::DataIdentifier* AssociatedMetadata::release_reference_id() {
  
  ::bosdyn::api::DataIdentifier* temp = _impl_.reference_id_;
  _impl_.reference_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataIdentifier* AssociatedMetadata::unsafe_arena_release_reference_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AssociatedMetadata.reference_id)
  
  ::bosdyn::api::DataIdentifier* temp = _impl_.reference_id_;
  _impl_.reference_id_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataIdentifier* AssociatedMetadata::_internal_mutable_reference_id() {
  
  if (_impl_.reference_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataIdentifier>(GetArenaForAllocation());
    _impl_.reference_id_ = p;
  }
  return _impl_.reference_id_;
}
inline ::bosdyn::api::DataIdentifier* AssociatedMetadata::mutable_reference_id() {
  ::bosdyn::api::DataIdentifier* _msg = _internal_mutable_reference_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AssociatedMetadata.reference_id)
  return _msg;
}
inline void AssociatedMetadata::set_allocated_reference_id(::bosdyn::api::DataIdentifier* reference_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reference_id_;
  }
  if (reference_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reference_id);
    if (message_arena != submessage_arena) {
      reference_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.reference_id_ = reference_id;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AssociatedMetadata.reference_id)
}

// .bosdyn.api.Metadata metadata = 2;
inline bool AssociatedMetadata::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool AssociatedMetadata::has_metadata() const {
  return _internal_has_metadata();
}
inline void AssociatedMetadata::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
inline const ::bosdyn::api::Metadata& AssociatedMetadata::_internal_metadata() const {
  const ::bosdyn::api::Metadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Metadata&>(
      ::bosdyn::api::_Metadata_default_instance_);
}
inline const ::bosdyn::api::Metadata& AssociatedMetadata::metadata() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AssociatedMetadata.metadata)
  return _internal_metadata();
}
inline void AssociatedMetadata::unsafe_arena_set_allocated_metadata(
    ::bosdyn::api::Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AssociatedMetadata.metadata)
}
inline ::bosdyn::api::Metadata* AssociatedMetadata::release_metadata() {
  
  ::bosdyn::api::Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Metadata* AssociatedMetadata::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AssociatedMetadata.metadata)
  
  ::bosdyn::api::Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Metadata* AssociatedMetadata::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Metadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::bosdyn::api::Metadata* AssociatedMetadata::mutable_metadata() {
  ::bosdyn::api::Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AssociatedMetadata.metadata)
  return _msg;
}
inline void AssociatedMetadata::set_allocated_metadata(::bosdyn::api::Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AssociatedMetadata.metadata)
}

// -------------------------------------------------------------------

// AssociatedAlertData

// .bosdyn.api.DataIdentifier reference_id = 1;
inline bool AssociatedAlertData::_internal_has_reference_id() const {
  return this != internal_default_instance() && _impl_.reference_id_ != nullptr;
}
inline bool AssociatedAlertData::has_reference_id() const {
  return _internal_has_reference_id();
}
inline void AssociatedAlertData::clear_reference_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.reference_id_ != nullptr) {
    delete _impl_.reference_id_;
  }
  _impl_.reference_id_ = nullptr;
}
inline const ::bosdyn::api::DataIdentifier& AssociatedAlertData::_internal_reference_id() const {
  const ::bosdyn::api::DataIdentifier* p = _impl_.reference_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataIdentifier&>(
      ::bosdyn::api::_DataIdentifier_default_instance_);
}
inline const ::bosdyn::api::DataIdentifier& AssociatedAlertData::reference_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AssociatedAlertData.reference_id)
  return _internal_reference_id();
}
inline void AssociatedAlertData::unsafe_arena_set_allocated_reference_id(
    ::bosdyn::api::DataIdentifier* reference_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reference_id_);
  }
  _impl_.reference_id_ = reference_id;
  if (reference_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AssociatedAlertData.reference_id)
}
inline ::bosdyn::api::DataIdentifier* AssociatedAlertData::release_reference_id() {
  
  ::bosdyn::api::DataIdentifier* temp = _impl_.reference_id_;
  _impl_.reference_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataIdentifier* AssociatedAlertData::unsafe_arena_release_reference_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AssociatedAlertData.reference_id)
  
  ::bosdyn::api::DataIdentifier* temp = _impl_.reference_id_;
  _impl_.reference_id_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataIdentifier* AssociatedAlertData::_internal_mutable_reference_id() {
  
  if (_impl_.reference_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataIdentifier>(GetArenaForAllocation());
    _impl_.reference_id_ = p;
  }
  return _impl_.reference_id_;
}
inline ::bosdyn::api::DataIdentifier* AssociatedAlertData::mutable_reference_id() {
  ::bosdyn::api::DataIdentifier* _msg = _internal_mutable_reference_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AssociatedAlertData.reference_id)
  return _msg;
}
inline void AssociatedAlertData::set_allocated_reference_id(::bosdyn::api::DataIdentifier* reference_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reference_id_;
  }
  if (reference_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reference_id);
    if (message_arena != submessage_arena) {
      reference_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.reference_id_ = reference_id;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AssociatedAlertData.reference_id)
}

// .bosdyn.api.AlertData alert_data = 2;
inline bool AssociatedAlertData::_internal_has_alert_data() const {
  return this != internal_default_instance() && _impl_.alert_data_ != nullptr;
}
inline bool AssociatedAlertData::has_alert_data() const {
  return _internal_has_alert_data();
}
inline const ::bosdyn::api::AlertData& AssociatedAlertData::_internal_alert_data() const {
  const ::bosdyn::api::AlertData* p = _impl_.alert_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::AlertData&>(
      ::bosdyn::api::_AlertData_default_instance_);
}
inline const ::bosdyn::api::AlertData& AssociatedAlertData::alert_data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AssociatedAlertData.alert_data)
  return _internal_alert_data();
}
inline void AssociatedAlertData::unsafe_arena_set_allocated_alert_data(
    ::bosdyn::api::AlertData* alert_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alert_data_);
  }
  _impl_.alert_data_ = alert_data;
  if (alert_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AssociatedAlertData.alert_data)
}
inline ::bosdyn::api::AlertData* AssociatedAlertData::release_alert_data() {
  
  ::bosdyn::api::AlertData* temp = _impl_.alert_data_;
  _impl_.alert_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::AlertData* AssociatedAlertData::unsafe_arena_release_alert_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AssociatedAlertData.alert_data)
  
  ::bosdyn::api::AlertData* temp = _impl_.alert_data_;
  _impl_.alert_data_ = nullptr;
  return temp;
}
inline ::bosdyn::api::AlertData* AssociatedAlertData::_internal_mutable_alert_data() {
  
  if (_impl_.alert_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::AlertData>(GetArenaForAllocation());
    _impl_.alert_data_ = p;
  }
  return _impl_.alert_data_;
}
inline ::bosdyn::api::AlertData* AssociatedAlertData::mutable_alert_data() {
  ::bosdyn::api::AlertData* _msg = _internal_mutable_alert_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AssociatedAlertData.alert_data)
  return _msg;
}
inline void AssociatedAlertData::set_allocated_alert_data(::bosdyn::api::AlertData* alert_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alert_data_);
  }
  if (alert_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alert_data));
    if (message_arena != submessage_arena) {
      alert_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alert_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.alert_data_ = alert_data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AssociatedAlertData.alert_data)
}

// -------------------------------------------------------------------

// ImageSourceCapture

// string image_service = 1;
inline void ImageSourceCapture::clear_image_service() {
  _impl_.image_service_.ClearToEmpty();
}
inline const std::string& ImageSourceCapture::image_service() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSourceCapture.image_service)
  return _internal_image_service();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageSourceCapture::set_image_service(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_service_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSourceCapture.image_service)
}
inline std::string* ImageSourceCapture::mutable_image_service() {
  std::string* _s = _internal_mutable_image_service();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSourceCapture.image_service)
  return _s;
}
inline const std::string& ImageSourceCapture::_internal_image_service() const {
  return _impl_.image_service_.Get();
}
inline void ImageSourceCapture::_internal_set_image_service(const std::string& value) {
  
  _impl_.image_service_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageSourceCapture::_internal_mutable_image_service() {
  
  return _impl_.image_service_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageSourceCapture::release_image_service() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSourceCapture.image_service)
  return _impl_.image_service_.Release();
}
inline void ImageSourceCapture::set_allocated_image_service(std::string* image_service) {
  if (image_service != nullptr) {
    
  } else {
    
  }
  _impl_.image_service_.SetAllocated(image_service, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_service_.IsDefault()) {
    _impl_.image_service_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageSourceCapture.image_service)
}

// .bosdyn.api.ImageRequest image_request = 4;
inline bool ImageSourceCapture::_internal_has_image_request() const {
  return this != internal_default_instance() && _impl_.image_request_ != nullptr;
}
inline bool ImageSourceCapture::has_image_request() const {
  return _internal_has_image_request();
}
inline const ::bosdyn::api::ImageRequest& ImageSourceCapture::_internal_image_request() const {
  const ::bosdyn::api::ImageRequest* p = _impl_.image_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ImageRequest&>(
      ::bosdyn::api::_ImageRequest_default_instance_);
}
inline const ::bosdyn::api::ImageRequest& ImageSourceCapture::image_request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSourceCapture.image_request)
  return _internal_image_request();
}
inline void ImageSourceCapture::unsafe_arena_set_allocated_image_request(
    ::bosdyn::api::ImageRequest* image_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_request_);
  }
  _impl_.image_request_ = image_request;
  if (image_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageSourceCapture.image_request)
}
inline ::bosdyn::api::ImageRequest* ImageSourceCapture::release_image_request() {
  
  ::bosdyn::api::ImageRequest* temp = _impl_.image_request_;
  _impl_.image_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ImageRequest* ImageSourceCapture::unsafe_arena_release_image_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSourceCapture.image_request)
  
  ::bosdyn::api::ImageRequest* temp = _impl_.image_request_;
  _impl_.image_request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ImageRequest* ImageSourceCapture::_internal_mutable_image_request() {
  
  if (_impl_.image_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ImageRequest>(GetArenaForAllocation());
    _impl_.image_request_ = p;
  }
  return _impl_.image_request_;
}
inline ::bosdyn::api::ImageRequest* ImageSourceCapture::mutable_image_request() {
  ::bosdyn::api::ImageRequest* _msg = _internal_mutable_image_request();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSourceCapture.image_request)
  return _msg;
}
inline void ImageSourceCapture::set_allocated_image_request(::bosdyn::api::ImageRequest* image_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_request_);
  }
  if (image_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_request));
    if (message_arena != submessage_arena) {
      image_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_request_ = image_request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageSourceCapture.image_request)
}

// string image_source = 2 [deprecated = true];
inline void ImageSourceCapture::clear_image_source() {
  _impl_.image_source_.ClearToEmpty();
}
inline const std::string& ImageSourceCapture::image_source() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSourceCapture.image_source)
  return _internal_image_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageSourceCapture::set_image_source(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSourceCapture.image_source)
}
inline std::string* ImageSourceCapture::mutable_image_source() {
  std::string* _s = _internal_mutable_image_source();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSourceCapture.image_source)
  return _s;
}
inline const std::string& ImageSourceCapture::_internal_image_source() const {
  return _impl_.image_source_.Get();
}
inline void ImageSourceCapture::_internal_set_image_source(const std::string& value) {
  
  _impl_.image_source_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageSourceCapture::_internal_mutable_image_source() {
  
  return _impl_.image_source_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageSourceCapture::release_image_source() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSourceCapture.image_source)
  return _impl_.image_source_.Release();
}
inline void ImageSourceCapture::set_allocated_image_source(std::string* image_source) {
  if (image_source != nullptr) {
    
  } else {
    
  }
  _impl_.image_source_.SetAllocated(image_source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_source_.IsDefault()) {
    _impl_.image_source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageSourceCapture.image_source)
}

// .bosdyn.api.Image.PixelFormat pixel_format = 3 [deprecated = true];
inline void ImageSourceCapture::clear_pixel_format() {
  _impl_.pixel_format_ = 0;
}
inline ::bosdyn::api::Image_PixelFormat ImageSourceCapture::_internal_pixel_format() const {
  return static_cast< ::bosdyn::api::Image_PixelFormat >(_impl_.pixel_format_);
}
inline ::bosdyn::api::Image_PixelFormat ImageSourceCapture::pixel_format() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSourceCapture.pixel_format)
  return _internal_pixel_format();
}
inline void ImageSourceCapture::_internal_set_pixel_format(::bosdyn::api::Image_PixelFormat value) {
  
  _impl_.pixel_format_ = value;
}
inline void ImageSourceCapture::set_pixel_format(::bosdyn::api::Image_PixelFormat value) {
  _internal_set_pixel_format(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSourceCapture.pixel_format)
}

// -------------------------------------------------------------------

// DataCapture

// string name = 1;
inline void DataCapture::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DataCapture::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataCapture.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataCapture::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.DataCapture.name)
}
inline std::string* DataCapture::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataCapture.name)
  return _s;
}
inline const std::string& DataCapture::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DataCapture::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataCapture::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataCapture::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataCapture.name)
  return _impl_.name_.Release();
}
inline void DataCapture::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataCapture.name)
}

// -------------------------------------------------------------------

// NetworkComputeCapture

// .bosdyn.api.NetworkComputeInputData input_data = 1;
inline bool NetworkComputeCapture::_internal_has_input_data() const {
  return this != internal_default_instance() && _impl_.input_data_ != nullptr;
}
inline bool NetworkComputeCapture::has_input_data() const {
  return _internal_has_input_data();
}
inline const ::bosdyn::api::NetworkComputeInputData& NetworkComputeCapture::_internal_input_data() const {
  const ::bosdyn::api::NetworkComputeInputData* p = _impl_.input_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::NetworkComputeInputData&>(
      ::bosdyn::api::_NetworkComputeInputData_default_instance_);
}
inline const ::bosdyn::api::NetworkComputeInputData& NetworkComputeCapture::input_data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeCapture.input_data)
  return _internal_input_data();
}
inline void NetworkComputeCapture::unsafe_arena_set_allocated_input_data(
    ::bosdyn::api::NetworkComputeInputData* input_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_data_);
  }
  _impl_.input_data_ = input_data;
  if (input_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.NetworkComputeCapture.input_data)
}
inline ::bosdyn::api::NetworkComputeInputData* NetworkComputeCapture::release_input_data() {
  
  ::bosdyn::api::NetworkComputeInputData* temp = _impl_.input_data_;
  _impl_.input_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::NetworkComputeInputData* NetworkComputeCapture::unsafe_arena_release_input_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeCapture.input_data)
  
  ::bosdyn::api::NetworkComputeInputData* temp = _impl_.input_data_;
  _impl_.input_data_ = nullptr;
  return temp;
}
inline ::bosdyn::api::NetworkComputeInputData* NetworkComputeCapture::_internal_mutable_input_data() {
  
  if (_impl_.input_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::NetworkComputeInputData>(GetArenaForAllocation());
    _impl_.input_data_ = p;
  }
  return _impl_.input_data_;
}
inline ::bosdyn::api::NetworkComputeInputData* NetworkComputeCapture::mutable_input_data() {
  ::bosdyn::api::NetworkComputeInputData* _msg = _internal_mutable_input_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeCapture.input_data)
  return _msg;
}
inline void NetworkComputeCapture::set_allocated_input_data(::bosdyn::api::NetworkComputeInputData* input_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_data_);
  }
  if (input_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(input_data));
    if (message_arena != submessage_arena) {
      input_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_data_ = input_data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.NetworkComputeCapture.input_data)
}

// .bosdyn.api.NetworkComputeServerConfiguration server_config = 2;
inline bool NetworkComputeCapture::_internal_has_server_config() const {
  return this != internal_default_instance() && _impl_.server_config_ != nullptr;
}
inline bool NetworkComputeCapture::has_server_config() const {
  return _internal_has_server_config();
}
inline const ::bosdyn::api::NetworkComputeServerConfiguration& NetworkComputeCapture::_internal_server_config() const {
  const ::bosdyn::api::NetworkComputeServerConfiguration* p = _impl_.server_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::NetworkComputeServerConfiguration&>(
      ::bosdyn::api::_NetworkComputeServerConfiguration_default_instance_);
}
inline const ::bosdyn::api::NetworkComputeServerConfiguration& NetworkComputeCapture::server_config() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeCapture.server_config)
  return _internal_server_config();
}
inline void NetworkComputeCapture::unsafe_arena_set_allocated_server_config(
    ::bosdyn::api::NetworkComputeServerConfiguration* server_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_config_);
  }
  _impl_.server_config_ = server_config;
  if (server_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.NetworkComputeCapture.server_config)
}
inline ::bosdyn::api::NetworkComputeServerConfiguration* NetworkComputeCapture::release_server_config() {
  
  ::bosdyn::api::NetworkComputeServerConfiguration* temp = _impl_.server_config_;
  _impl_.server_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::NetworkComputeServerConfiguration* NetworkComputeCapture::unsafe_arena_release_server_config() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeCapture.server_config)
  
  ::bosdyn::api::NetworkComputeServerConfiguration* temp = _impl_.server_config_;
  _impl_.server_config_ = nullptr;
  return temp;
}
inline ::bosdyn::api::NetworkComputeServerConfiguration* NetworkComputeCapture::_internal_mutable_server_config() {
  
  if (_impl_.server_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::NetworkComputeServerConfiguration>(GetArenaForAllocation());
    _impl_.server_config_ = p;
  }
  return _impl_.server_config_;
}
inline ::bosdyn::api::NetworkComputeServerConfiguration* NetworkComputeCapture::mutable_server_config() {
  ::bosdyn::api::NetworkComputeServerConfiguration* _msg = _internal_mutable_server_config();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeCapture.server_config)
  return _msg;
}
inline void NetworkComputeCapture::set_allocated_server_config(::bosdyn::api::NetworkComputeServerConfiguration* server_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_config_);
  }
  if (server_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_config));
    if (message_arena != submessage_arena) {
      server_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.server_config_ = server_config;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.NetworkComputeCapture.server_config)
}

// -------------------------------------------------------------------

// AcquisitionRequestList

// repeated .bosdyn.api.ImageSourceCapture image_captures = 1;
inline int AcquisitionRequestList::_internal_image_captures_size() const {
  return _impl_.image_captures_.size();
}
inline int AcquisitionRequestList::image_captures_size() const {
  return _internal_image_captures_size();
}
inline void AcquisitionRequestList::clear_image_captures() {
  _impl_.image_captures_.Clear();
}
inline ::bosdyn::api::ImageSourceCapture* AcquisitionRequestList::mutable_image_captures(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquisitionRequestList.image_captures)
  return _impl_.image_captures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSourceCapture >*
AcquisitionRequestList::mutable_image_captures() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.AcquisitionRequestList.image_captures)
  return &_impl_.image_captures_;
}
inline const ::bosdyn::api::ImageSourceCapture& AcquisitionRequestList::_internal_image_captures(int index) const {
  return _impl_.image_captures_.Get(index);
}
inline const ::bosdyn::api::ImageSourceCapture& AcquisitionRequestList::image_captures(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquisitionRequestList.image_captures)
  return _internal_image_captures(index);
}
inline ::bosdyn::api::ImageSourceCapture* AcquisitionRequestList::_internal_add_image_captures() {
  return _impl_.image_captures_.Add();
}
inline ::bosdyn::api::ImageSourceCapture* AcquisitionRequestList::add_image_captures() {
  ::bosdyn::api::ImageSourceCapture* _add = _internal_add_image_captures();
  // @@protoc_insertion_point(field_add:bosdyn.api.AcquisitionRequestList.image_captures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSourceCapture >&
AcquisitionRequestList::image_captures() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.AcquisitionRequestList.image_captures)
  return _impl_.image_captures_;
}

// repeated .bosdyn.api.DataCapture data_captures = 2;
inline int AcquisitionRequestList::_internal_data_captures_size() const {
  return _impl_.data_captures_.size();
}
inline int AcquisitionRequestList::data_captures_size() const {
  return _internal_data_captures_size();
}
inline void AcquisitionRequestList::clear_data_captures() {
  _impl_.data_captures_.Clear();
}
inline ::bosdyn::api::DataCapture* AcquisitionRequestList::mutable_data_captures(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquisitionRequestList.data_captures)
  return _impl_.data_captures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataCapture >*
AcquisitionRequestList::mutable_data_captures() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.AcquisitionRequestList.data_captures)
  return &_impl_.data_captures_;
}
inline const ::bosdyn::api::DataCapture& AcquisitionRequestList::_internal_data_captures(int index) const {
  return _impl_.data_captures_.Get(index);
}
inline const ::bosdyn::api::DataCapture& AcquisitionRequestList::data_captures(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquisitionRequestList.data_captures)
  return _internal_data_captures(index);
}
inline ::bosdyn::api::DataCapture* AcquisitionRequestList::_internal_add_data_captures() {
  return _impl_.data_captures_.Add();
}
inline ::bosdyn::api::DataCapture* AcquisitionRequestList::add_data_captures() {
  ::bosdyn::api::DataCapture* _add = _internal_add_data_captures();
  // @@protoc_insertion_point(field_add:bosdyn.api.AcquisitionRequestList.data_captures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataCapture >&
AcquisitionRequestList::data_captures() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.AcquisitionRequestList.data_captures)
  return _impl_.data_captures_;
}

// repeated .bosdyn.api.NetworkComputeCapture network_compute_captures = 4;
inline int AcquisitionRequestList::_internal_network_compute_captures_size() const {
  return _impl_.network_compute_captures_.size();
}
inline int AcquisitionRequestList::network_compute_captures_size() const {
  return _internal_network_compute_captures_size();
}
inline void AcquisitionRequestList::clear_network_compute_captures() {
  _impl_.network_compute_captures_.Clear();
}
inline ::bosdyn::api::NetworkComputeCapture* AcquisitionRequestList::mutable_network_compute_captures(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquisitionRequestList.network_compute_captures)
  return _impl_.network_compute_captures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::NetworkComputeCapture >*
AcquisitionRequestList::mutable_network_compute_captures() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.AcquisitionRequestList.network_compute_captures)
  return &_impl_.network_compute_captures_;
}
inline const ::bosdyn::api::NetworkComputeCapture& AcquisitionRequestList::_internal_network_compute_captures(int index) const {
  return _impl_.network_compute_captures_.Get(index);
}
inline const ::bosdyn::api::NetworkComputeCapture& AcquisitionRequestList::network_compute_captures(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquisitionRequestList.network_compute_captures)
  return _internal_network_compute_captures(index);
}
inline ::bosdyn::api::NetworkComputeCapture* AcquisitionRequestList::_internal_add_network_compute_captures() {
  return _impl_.network_compute_captures_.Add();
}
inline ::bosdyn::api::NetworkComputeCapture* AcquisitionRequestList::add_network_compute_captures() {
  ::bosdyn::api::NetworkComputeCapture* _add = _internal_add_network_compute_captures();
  // @@protoc_insertion_point(field_add:bosdyn.api.AcquisitionRequestList.network_compute_captures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::NetworkComputeCapture >&
AcquisitionRequestList::network_compute_captures() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.AcquisitionRequestList.network_compute_captures)
  return _impl_.network_compute_captures_;
}

// -------------------------------------------------------------------

// DataError

// .bosdyn.api.DataIdentifier data_id = 1;
inline bool DataError::_internal_has_data_id() const {
  return this != internal_default_instance() && _impl_.data_id_ != nullptr;
}
inline bool DataError::has_data_id() const {
  return _internal_has_data_id();
}
inline void DataError::clear_data_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_id_ != nullptr) {
    delete _impl_.data_id_;
  }
  _impl_.data_id_ = nullptr;
}
inline const ::bosdyn::api::DataIdentifier& DataError::_internal_data_id() const {
  const ::bosdyn::api::DataIdentifier* p = _impl_.data_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataIdentifier&>(
      ::bosdyn::api::_DataIdentifier_default_instance_);
}
inline const ::bosdyn::api::DataIdentifier& DataError::data_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataError.data_id)
  return _internal_data_id();
}
inline void DataError::unsafe_arena_set_allocated_data_id(
    ::bosdyn::api::DataIdentifier* data_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_id_);
  }
  _impl_.data_id_ = data_id;
  if (data_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DataError.data_id)
}
inline ::bosdyn::api::DataIdentifier* DataError::release_data_id() {
  
  ::bosdyn::api::DataIdentifier* temp = _impl_.data_id_;
  _impl_.data_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataIdentifier* DataError::unsafe_arena_release_data_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataError.data_id)
  
  ::bosdyn::api::DataIdentifier* temp = _impl_.data_id_;
  _impl_.data_id_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataIdentifier* DataError::_internal_mutable_data_id() {
  
  if (_impl_.data_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataIdentifier>(GetArenaForAllocation());
    _impl_.data_id_ = p;
  }
  return _impl_.data_id_;
}
inline ::bosdyn::api::DataIdentifier* DataError::mutable_data_id() {
  ::bosdyn::api::DataIdentifier* _msg = _internal_mutable_data_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataError.data_id)
  return _msg;
}
inline void DataError::set_allocated_data_id(::bosdyn::api::DataIdentifier* data_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_id_;
  }
  if (data_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data_id);
    if (message_arena != submessage_arena) {
      data_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_id_ = data_id;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataError.data_id)
}

// string error_message = 2;
inline void DataError::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& DataError::error_message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataError.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataError::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.DataError.error_message)
}
inline std::string* DataError::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataError.error_message)
  return _s;
}
inline const std::string& DataError::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void DataError::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* DataError::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* DataError::release_error_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataError.error_message)
  return _impl_.error_message_.Release();
}
inline void DataError::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataError.error_message)
}

// .google.protobuf.Any error_data = 3;
inline bool DataError::_internal_has_error_data() const {
  return this != internal_default_instance() && _impl_.error_data_ != nullptr;
}
inline bool DataError::has_error_data() const {
  return _internal_has_error_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& DataError::_internal_error_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.error_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& DataError::error_data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataError.error_data)
  return _internal_error_data();
}
inline void DataError::unsafe_arena_set_allocated_error_data(
    ::PROTOBUF_NAMESPACE_ID::Any* error_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_data_);
  }
  _impl_.error_data_ = error_data;
  if (error_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DataError.error_data)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* DataError::release_error_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.error_data_;
  _impl_.error_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* DataError::unsafe_arena_release_error_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataError.error_data)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.error_data_;
  _impl_.error_data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* DataError::_internal_mutable_error_data() {
  
  if (_impl_.error_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.error_data_ = p;
  }
  return _impl_.error_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* DataError::mutable_error_data() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_error_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataError.error_data)
  return _msg;
}
inline void DataError::set_allocated_error_data(::PROTOBUF_NAMESPACE_ID::Any* error_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_data_);
  }
  if (error_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_data));
    if (message_arena != submessage_arena) {
      error_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_data_ = error_data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataError.error_data)
}

// -------------------------------------------------------------------

// PluginServiceError

// string service_name = 1;
inline void PluginServiceError::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& PluginServiceError::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PluginServiceError.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginServiceError::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.PluginServiceError.service_name)
}
inline std::string* PluginServiceError::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PluginServiceError.service_name)
  return _s;
}
inline const std::string& PluginServiceError::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void PluginServiceError::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PluginServiceError::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PluginServiceError::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PluginServiceError.service_name)
  return _impl_.service_name_.Release();
}
inline void PluginServiceError::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PluginServiceError.service_name)
}

// .bosdyn.api.PluginServiceError.ErrorCode error = 2;
inline void PluginServiceError::clear_error() {
  _impl_.error_ = 0;
}
inline ::bosdyn::api::PluginServiceError_ErrorCode PluginServiceError::_internal_error() const {
  return static_cast< ::bosdyn::api::PluginServiceError_ErrorCode >(_impl_.error_);
}
inline ::bosdyn::api::PluginServiceError_ErrorCode PluginServiceError::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PluginServiceError.error)
  return _internal_error();
}
inline void PluginServiceError::_internal_set_error(::bosdyn::api::PluginServiceError_ErrorCode value) {
  
  _impl_.error_ = value;
}
inline void PluginServiceError::set_error(::bosdyn::api::PluginServiceError_ErrorCode value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PluginServiceError.error)
}

// string message = 3;
inline void PluginServiceError::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& PluginServiceError::message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PluginServiceError.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginServiceError::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.PluginServiceError.message)
}
inline std::string* PluginServiceError::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PluginServiceError.message)
  return _s;
}
inline const std::string& PluginServiceError::_internal_message() const {
  return _impl_.message_.Get();
}
inline void PluginServiceError::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* PluginServiceError::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* PluginServiceError::release_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PluginServiceError.message)
  return _impl_.message_.Release();
}
inline void PluginServiceError::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PluginServiceError.message)
}

// -------------------------------------------------------------------

// NetworkComputeError

// string service_name = 1;
inline void NetworkComputeError::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& NetworkComputeError::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeError.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkComputeError::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.NetworkComputeError.service_name)
}
inline std::string* NetworkComputeError::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeError.service_name)
  return _s;
}
inline const std::string& NetworkComputeError::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void NetworkComputeError::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkComputeError::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkComputeError::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeError.service_name)
  return _impl_.service_name_.Release();
}
inline void NetworkComputeError::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.NetworkComputeError.service_name)
}

// .bosdyn.api.NetworkComputeError.ErrorCode error = 2;
inline void NetworkComputeError::clear_error() {
  _impl_.error_ = 0;
}
inline ::bosdyn::api::NetworkComputeError_ErrorCode NetworkComputeError::_internal_error() const {
  return static_cast< ::bosdyn::api::NetworkComputeError_ErrorCode >(_impl_.error_);
}
inline ::bosdyn::api::NetworkComputeError_ErrorCode NetworkComputeError::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeError.error)
  return _internal_error();
}
inline void NetworkComputeError::_internal_set_error(::bosdyn::api::NetworkComputeError_ErrorCode value) {
  
  _impl_.error_ = value;
}
inline void NetworkComputeError::set_error(::bosdyn::api::NetworkComputeError_ErrorCode value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.NetworkComputeError.error)
}

// .bosdyn.api.NetworkComputeStatus network_compute_status = 3;
inline void NetworkComputeError::clear_network_compute_status() {
  _impl_.network_compute_status_ = 0;
}
inline ::bosdyn::api::NetworkComputeStatus NetworkComputeError::_internal_network_compute_status() const {
  return static_cast< ::bosdyn::api::NetworkComputeStatus >(_impl_.network_compute_status_);
}
inline ::bosdyn::api::NetworkComputeStatus NetworkComputeError::network_compute_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeError.network_compute_status)
  return _internal_network_compute_status();
}
inline void NetworkComputeError::_internal_set_network_compute_status(::bosdyn::api::NetworkComputeStatus value) {
  
  _impl_.network_compute_status_ = value;
}
inline void NetworkComputeError::set_network_compute_status(::bosdyn::api::NetworkComputeStatus value) {
  _internal_set_network_compute_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.NetworkComputeError.network_compute_status)
}

// string message = 4;
inline void NetworkComputeError::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& NetworkComputeError::message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeError.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkComputeError::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.NetworkComputeError.message)
}
inline std::string* NetworkComputeError::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeError.message)
  return _s;
}
inline const std::string& NetworkComputeError::_internal_message() const {
  return _impl_.message_.Get();
}
inline void NetworkComputeError::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkComputeError::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkComputeError::release_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeError.message)
  return _impl_.message_.Release();
}
inline void NetworkComputeError::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.NetworkComputeError.message)
}

// -------------------------------------------------------------------

// AcquireDataRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool AcquireDataRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool AcquireDataRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& AcquireDataRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& AcquireDataRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquireDataRequest.header)
  return _internal_header();
}
inline void AcquireDataRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AcquireDataRequest.header)
}
inline ::bosdyn::api::RequestHeader* AcquireDataRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* AcquireDataRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquireDataRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* AcquireDataRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* AcquireDataRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquireDataRequest.header)
  return _msg;
}
inline void AcquireDataRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquireDataRequest.header)
}

// .bosdyn.api.CaptureActionId action_id = 2;
inline bool AcquireDataRequest::_internal_has_action_id() const {
  return this != internal_default_instance() && _impl_.action_id_ != nullptr;
}
inline bool AcquireDataRequest::has_action_id() const {
  return _internal_has_action_id();
}
inline void AcquireDataRequest::clear_action_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.action_id_ != nullptr) {
    delete _impl_.action_id_;
  }
  _impl_.action_id_ = nullptr;
}
inline const ::bosdyn::api::CaptureActionId& AcquireDataRequest::_internal_action_id() const {
  const ::bosdyn::api::CaptureActionId* p = _impl_.action_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::CaptureActionId&>(
      ::bosdyn::api::_CaptureActionId_default_instance_);
}
inline const ::bosdyn::api::CaptureActionId& AcquireDataRequest::action_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquireDataRequest.action_id)
  return _internal_action_id();
}
inline void AcquireDataRequest::unsafe_arena_set_allocated_action_id(
    ::bosdyn::api::CaptureActionId* action_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.action_id_);
  }
  _impl_.action_id_ = action_id;
  if (action_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AcquireDataRequest.action_id)
}
inline ::bosdyn::api::CaptureActionId* AcquireDataRequest::release_action_id() {
  
  ::bosdyn::api::CaptureActionId* temp = _impl_.action_id_;
  _impl_.action_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::CaptureActionId* AcquireDataRequest::unsafe_arena_release_action_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquireDataRequest.action_id)
  
  ::bosdyn::api::CaptureActionId* temp = _impl_.action_id_;
  _impl_.action_id_ = nullptr;
  return temp;
}
inline ::bosdyn::api::CaptureActionId* AcquireDataRequest::_internal_mutable_action_id() {
  
  if (_impl_.action_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::CaptureActionId>(GetArenaForAllocation());
    _impl_.action_id_ = p;
  }
  return _impl_.action_id_;
}
inline ::bosdyn::api::CaptureActionId* AcquireDataRequest::mutable_action_id() {
  ::bosdyn::api::CaptureActionId* _msg = _internal_mutable_action_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquireDataRequest.action_id)
  return _msg;
}
inline void AcquireDataRequest::set_allocated_action_id(::bosdyn::api::CaptureActionId* action_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.action_id_;
  }
  if (action_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(action_id);
    if (message_arena != submessage_arena) {
      action_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.action_id_ = action_id;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquireDataRequest.action_id)
}

// .bosdyn.api.Metadata metadata = 3;
inline bool AcquireDataRequest::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool AcquireDataRequest::has_metadata() const {
  return _internal_has_metadata();
}
inline void AcquireDataRequest::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
inline const ::bosdyn::api::Metadata& AcquireDataRequest::_internal_metadata() const {
  const ::bosdyn::api::Metadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Metadata&>(
      ::bosdyn::api::_Metadata_default_instance_);
}
inline const ::bosdyn::api::Metadata& AcquireDataRequest::metadata() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquireDataRequest.metadata)
  return _internal_metadata();
}
inline void AcquireDataRequest::unsafe_arena_set_allocated_metadata(
    ::bosdyn::api::Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AcquireDataRequest.metadata)
}
inline ::bosdyn::api::Metadata* AcquireDataRequest::release_metadata() {
  
  ::bosdyn::api::Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Metadata* AcquireDataRequest::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquireDataRequest.metadata)
  
  ::bosdyn::api::Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Metadata* AcquireDataRequest::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Metadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::bosdyn::api::Metadata* AcquireDataRequest::mutable_metadata() {
  ::bosdyn::api::Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquireDataRequest.metadata)
  return _msg;
}
inline void AcquireDataRequest::set_allocated_metadata(::bosdyn::api::Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquireDataRequest.metadata)
}

// .bosdyn.api.AcquisitionRequestList acquisition_requests = 4;
inline bool AcquireDataRequest::_internal_has_acquisition_requests() const {
  return this != internal_default_instance() && _impl_.acquisition_requests_ != nullptr;
}
inline bool AcquireDataRequest::has_acquisition_requests() const {
  return _internal_has_acquisition_requests();
}
inline void AcquireDataRequest::clear_acquisition_requests() {
  if (GetArenaForAllocation() == nullptr && _impl_.acquisition_requests_ != nullptr) {
    delete _impl_.acquisition_requests_;
  }
  _impl_.acquisition_requests_ = nullptr;
}
inline const ::bosdyn::api::AcquisitionRequestList& AcquireDataRequest::_internal_acquisition_requests() const {
  const ::bosdyn::api::AcquisitionRequestList* p = _impl_.acquisition_requests_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::AcquisitionRequestList&>(
      ::bosdyn::api::_AcquisitionRequestList_default_instance_);
}
inline const ::bosdyn::api::AcquisitionRequestList& AcquireDataRequest::acquisition_requests() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquireDataRequest.acquisition_requests)
  return _internal_acquisition_requests();
}
inline void AcquireDataRequest::unsafe_arena_set_allocated_acquisition_requests(
    ::bosdyn::api::AcquisitionRequestList* acquisition_requests) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acquisition_requests_);
  }
  _impl_.acquisition_requests_ = acquisition_requests;
  if (acquisition_requests) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AcquireDataRequest.acquisition_requests)
}
inline ::bosdyn::api::AcquisitionRequestList* AcquireDataRequest::release_acquisition_requests() {
  
  ::bosdyn::api::AcquisitionRequestList* temp = _impl_.acquisition_requests_;
  _impl_.acquisition_requests_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::AcquisitionRequestList* AcquireDataRequest::unsafe_arena_release_acquisition_requests() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquireDataRequest.acquisition_requests)
  
  ::bosdyn::api::AcquisitionRequestList* temp = _impl_.acquisition_requests_;
  _impl_.acquisition_requests_ = nullptr;
  return temp;
}
inline ::bosdyn::api::AcquisitionRequestList* AcquireDataRequest::_internal_mutable_acquisition_requests() {
  
  if (_impl_.acquisition_requests_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::AcquisitionRequestList>(GetArenaForAllocation());
    _impl_.acquisition_requests_ = p;
  }
  return _impl_.acquisition_requests_;
}
inline ::bosdyn::api::AcquisitionRequestList* AcquireDataRequest::mutable_acquisition_requests() {
  ::bosdyn::api::AcquisitionRequestList* _msg = _internal_mutable_acquisition_requests();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquireDataRequest.acquisition_requests)
  return _msg;
}
inline void AcquireDataRequest::set_allocated_acquisition_requests(::bosdyn::api::AcquisitionRequestList* acquisition_requests) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.acquisition_requests_;
  }
  if (acquisition_requests) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(acquisition_requests);
    if (message_arena != submessage_arena) {
      acquisition_requests = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acquisition_requests, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.acquisition_requests_ = acquisition_requests;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquireDataRequest.acquisition_requests)
}

// .google.protobuf.Duration min_timeout = 5;
inline bool AcquireDataRequest::_internal_has_min_timeout() const {
  return this != internal_default_instance() && _impl_.min_timeout_ != nullptr;
}
inline bool AcquireDataRequest::has_min_timeout() const {
  return _internal_has_min_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& AcquireDataRequest::_internal_min_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.min_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& AcquireDataRequest::min_timeout() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquireDataRequest.min_timeout)
  return _internal_min_timeout();
}
inline void AcquireDataRequest::unsafe_arena_set_allocated_min_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* min_timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_timeout_);
  }
  _impl_.min_timeout_ = min_timeout;
  if (min_timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AcquireDataRequest.min_timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* AcquireDataRequest::release_min_timeout() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.min_timeout_;
  _impl_.min_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* AcquireDataRequest::unsafe_arena_release_min_timeout() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquireDataRequest.min_timeout)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.min_timeout_;
  _impl_.min_timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* AcquireDataRequest::_internal_mutable_min_timeout() {
  
  if (_impl_.min_timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.min_timeout_ = p;
  }
  return _impl_.min_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* AcquireDataRequest::mutable_min_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_min_timeout();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquireDataRequest.min_timeout)
  return _msg;
}
inline void AcquireDataRequest::set_allocated_min_timeout(::PROTOBUF_NAMESPACE_ID::Duration* min_timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_timeout_);
  }
  if (min_timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_timeout));
    if (message_arena != submessage_arena) {
      min_timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min_timeout, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.min_timeout_ = min_timeout;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquireDataRequest.min_timeout)
}

// -------------------------------------------------------------------

// AcquireDataResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool AcquireDataResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool AcquireDataResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& AcquireDataResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& AcquireDataResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquireDataResponse.header)
  return _internal_header();
}
inline void AcquireDataResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AcquireDataResponse.header)
}
inline ::bosdyn::api::ResponseHeader* AcquireDataResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* AcquireDataResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquireDataResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* AcquireDataResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* AcquireDataResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquireDataResponse.header)
  return _msg;
}
inline void AcquireDataResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquireDataResponse.header)
}

// .bosdyn.api.AcquireDataResponse.Status status = 2;
inline void AcquireDataResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::AcquireDataResponse_Status AcquireDataResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::AcquireDataResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::AcquireDataResponse_Status AcquireDataResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquireDataResponse.status)
  return _internal_status();
}
inline void AcquireDataResponse::_internal_set_status(::bosdyn::api::AcquireDataResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void AcquireDataResponse::set_status(::bosdyn::api::AcquireDataResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.AcquireDataResponse.status)
}

// uint32 request_id = 3;
inline void AcquireDataResponse::clear_request_id() {
  _impl_.request_id_ = 0u;
}
inline uint32_t AcquireDataResponse::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint32_t AcquireDataResponse::request_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquireDataResponse.request_id)
  return _internal_request_id();
}
inline void AcquireDataResponse::_internal_set_request_id(uint32_t value) {
  
  _impl_.request_id_ = value;
}
inline void AcquireDataResponse::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.AcquireDataResponse.request_id)
}

// -------------------------------------------------------------------

// AcquirePluginDataRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool AcquirePluginDataRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool AcquirePluginDataRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& AcquirePluginDataRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& AcquirePluginDataRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquirePluginDataRequest.header)
  return _internal_header();
}
inline void AcquirePluginDataRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AcquirePluginDataRequest.header)
}
inline ::bosdyn::api::RequestHeader* AcquirePluginDataRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* AcquirePluginDataRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquirePluginDataRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* AcquirePluginDataRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* AcquirePluginDataRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquirePluginDataRequest.header)
  return _msg;
}
inline void AcquirePluginDataRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquirePluginDataRequest.header)
}

// repeated .bosdyn.api.DataIdentifier data_id = 2;
inline int AcquirePluginDataRequest::_internal_data_id_size() const {
  return _impl_.data_id_.size();
}
inline int AcquirePluginDataRequest::data_id_size() const {
  return _internal_data_id_size();
}
inline void AcquirePluginDataRequest::clear_data_id() {
  _impl_.data_id_.Clear();
}
inline ::bosdyn::api::DataIdentifier* AcquirePluginDataRequest::mutable_data_id(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquirePluginDataRequest.data_id)
  return _impl_.data_id_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >*
AcquirePluginDataRequest::mutable_data_id() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.AcquirePluginDataRequest.data_id)
  return &_impl_.data_id_;
}
inline const ::bosdyn::api::DataIdentifier& AcquirePluginDataRequest::_internal_data_id(int index) const {
  return _impl_.data_id_.Get(index);
}
inline const ::bosdyn::api::DataIdentifier& AcquirePluginDataRequest::data_id(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquirePluginDataRequest.data_id)
  return _internal_data_id(index);
}
inline ::bosdyn::api::DataIdentifier* AcquirePluginDataRequest::_internal_add_data_id() {
  return _impl_.data_id_.Add();
}
inline ::bosdyn::api::DataIdentifier* AcquirePluginDataRequest::add_data_id() {
  ::bosdyn::api::DataIdentifier* _add = _internal_add_data_id();
  // @@protoc_insertion_point(field_add:bosdyn.api.AcquirePluginDataRequest.data_id)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >&
AcquirePluginDataRequest::data_id() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.AcquirePluginDataRequest.data_id)
  return _impl_.data_id_;
}

// .bosdyn.api.Metadata metadata = 3;
inline bool AcquirePluginDataRequest::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool AcquirePluginDataRequest::has_metadata() const {
  return _internal_has_metadata();
}
inline void AcquirePluginDataRequest::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
inline const ::bosdyn::api::Metadata& AcquirePluginDataRequest::_internal_metadata() const {
  const ::bosdyn::api::Metadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Metadata&>(
      ::bosdyn::api::_Metadata_default_instance_);
}
inline const ::bosdyn::api::Metadata& AcquirePluginDataRequest::metadata() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquirePluginDataRequest.metadata)
  return _internal_metadata();
}
inline void AcquirePluginDataRequest::unsafe_arena_set_allocated_metadata(
    ::bosdyn::api::Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AcquirePluginDataRequest.metadata)
}
inline ::bosdyn::api::Metadata* AcquirePluginDataRequest::release_metadata() {
  
  ::bosdyn::api::Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Metadata* AcquirePluginDataRequest::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquirePluginDataRequest.metadata)
  
  ::bosdyn::api::Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Metadata* AcquirePluginDataRequest::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Metadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::bosdyn::api::Metadata* AcquirePluginDataRequest::mutable_metadata() {
  ::bosdyn::api::Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquirePluginDataRequest.metadata)
  return _msg;
}
inline void AcquirePluginDataRequest::set_allocated_metadata(::bosdyn::api::Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquirePluginDataRequest.metadata)
}

// .bosdyn.api.CaptureActionId action_id = 4;
inline bool AcquirePluginDataRequest::_internal_has_action_id() const {
  return this != internal_default_instance() && _impl_.action_id_ != nullptr;
}
inline bool AcquirePluginDataRequest::has_action_id() const {
  return _internal_has_action_id();
}
inline void AcquirePluginDataRequest::clear_action_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.action_id_ != nullptr) {
    delete _impl_.action_id_;
  }
  _impl_.action_id_ = nullptr;
}
inline const ::bosdyn::api::CaptureActionId& AcquirePluginDataRequest::_internal_action_id() const {
  const ::bosdyn::api::CaptureActionId* p = _impl_.action_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::CaptureActionId&>(
      ::bosdyn::api::_CaptureActionId_default_instance_);
}
inline const ::bosdyn::api::CaptureActionId& AcquirePluginDataRequest::action_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquirePluginDataRequest.action_id)
  return _internal_action_id();
}
inline void AcquirePluginDataRequest::unsafe_arena_set_allocated_action_id(
    ::bosdyn::api::CaptureActionId* action_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.action_id_);
  }
  _impl_.action_id_ = action_id;
  if (action_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AcquirePluginDataRequest.action_id)
}
inline ::bosdyn::api::CaptureActionId* AcquirePluginDataRequest::release_action_id() {
  
  ::bosdyn::api::CaptureActionId* temp = _impl_.action_id_;
  _impl_.action_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::CaptureActionId* AcquirePluginDataRequest::unsafe_arena_release_action_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquirePluginDataRequest.action_id)
  
  ::bosdyn::api::CaptureActionId* temp = _impl_.action_id_;
  _impl_.action_id_ = nullptr;
  return temp;
}
inline ::bosdyn::api::CaptureActionId* AcquirePluginDataRequest::_internal_mutable_action_id() {
  
  if (_impl_.action_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::CaptureActionId>(GetArenaForAllocation());
    _impl_.action_id_ = p;
  }
  return _impl_.action_id_;
}
inline ::bosdyn::api::CaptureActionId* AcquirePluginDataRequest::mutable_action_id() {
  ::bosdyn::api::CaptureActionId* _msg = _internal_mutable_action_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquirePluginDataRequest.action_id)
  return _msg;
}
inline void AcquirePluginDataRequest::set_allocated_action_id(::bosdyn::api::CaptureActionId* action_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.action_id_;
  }
  if (action_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(action_id);
    if (message_arena != submessage_arena) {
      action_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.action_id_ = action_id;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquirePluginDataRequest.action_id)
}

// .bosdyn.api.AcquisitionRequestList acquisition_requests = 5;
inline bool AcquirePluginDataRequest::_internal_has_acquisition_requests() const {
  return this != internal_default_instance() && _impl_.acquisition_requests_ != nullptr;
}
inline bool AcquirePluginDataRequest::has_acquisition_requests() const {
  return _internal_has_acquisition_requests();
}
inline void AcquirePluginDataRequest::clear_acquisition_requests() {
  if (GetArenaForAllocation() == nullptr && _impl_.acquisition_requests_ != nullptr) {
    delete _impl_.acquisition_requests_;
  }
  _impl_.acquisition_requests_ = nullptr;
}
inline const ::bosdyn::api::AcquisitionRequestList& AcquirePluginDataRequest::_internal_acquisition_requests() const {
  const ::bosdyn::api::AcquisitionRequestList* p = _impl_.acquisition_requests_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::AcquisitionRequestList&>(
      ::bosdyn::api::_AcquisitionRequestList_default_instance_);
}
inline const ::bosdyn::api::AcquisitionRequestList& AcquirePluginDataRequest::acquisition_requests() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquirePluginDataRequest.acquisition_requests)
  return _internal_acquisition_requests();
}
inline void AcquirePluginDataRequest::unsafe_arena_set_allocated_acquisition_requests(
    ::bosdyn::api::AcquisitionRequestList* acquisition_requests) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acquisition_requests_);
  }
  _impl_.acquisition_requests_ = acquisition_requests;
  if (acquisition_requests) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AcquirePluginDataRequest.acquisition_requests)
}
inline ::bosdyn::api::AcquisitionRequestList* AcquirePluginDataRequest::release_acquisition_requests() {
  
  ::bosdyn::api::AcquisitionRequestList* temp = _impl_.acquisition_requests_;
  _impl_.acquisition_requests_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::AcquisitionRequestList* AcquirePluginDataRequest::unsafe_arena_release_acquisition_requests() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquirePluginDataRequest.acquisition_requests)
  
  ::bosdyn::api::AcquisitionRequestList* temp = _impl_.acquisition_requests_;
  _impl_.acquisition_requests_ = nullptr;
  return temp;
}
inline ::bosdyn::api::AcquisitionRequestList* AcquirePluginDataRequest::_internal_mutable_acquisition_requests() {
  
  if (_impl_.acquisition_requests_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::AcquisitionRequestList>(GetArenaForAllocation());
    _impl_.acquisition_requests_ = p;
  }
  return _impl_.acquisition_requests_;
}
inline ::bosdyn::api::AcquisitionRequestList* AcquirePluginDataRequest::mutable_acquisition_requests() {
  ::bosdyn::api::AcquisitionRequestList* _msg = _internal_mutable_acquisition_requests();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquirePluginDataRequest.acquisition_requests)
  return _msg;
}
inline void AcquirePluginDataRequest::set_allocated_acquisition_requests(::bosdyn::api::AcquisitionRequestList* acquisition_requests) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.acquisition_requests_;
  }
  if (acquisition_requests) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(acquisition_requests);
    if (message_arena != submessage_arena) {
      acquisition_requests = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acquisition_requests, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.acquisition_requests_ = acquisition_requests;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquirePluginDataRequest.acquisition_requests)
}

// -------------------------------------------------------------------

// AcquirePluginDataResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool AcquirePluginDataResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool AcquirePluginDataResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& AcquirePluginDataResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& AcquirePluginDataResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquirePluginDataResponse.header)
  return _internal_header();
}
inline void AcquirePluginDataResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AcquirePluginDataResponse.header)
}
inline ::bosdyn::api::ResponseHeader* AcquirePluginDataResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* AcquirePluginDataResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquirePluginDataResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* AcquirePluginDataResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* AcquirePluginDataResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquirePluginDataResponse.header)
  return _msg;
}
inline void AcquirePluginDataResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquirePluginDataResponse.header)
}

// .bosdyn.api.AcquirePluginDataResponse.Status status = 2;
inline void AcquirePluginDataResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::AcquirePluginDataResponse_Status AcquirePluginDataResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::AcquirePluginDataResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::AcquirePluginDataResponse_Status AcquirePluginDataResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquirePluginDataResponse.status)
  return _internal_status();
}
inline void AcquirePluginDataResponse::_internal_set_status(::bosdyn::api::AcquirePluginDataResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void AcquirePluginDataResponse::set_status(::bosdyn::api::AcquirePluginDataResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.AcquirePluginDataResponse.status)
}

// uint32 request_id = 3;
inline void AcquirePluginDataResponse::clear_request_id() {
  _impl_.request_id_ = 0u;
}
inline uint32_t AcquirePluginDataResponse::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint32_t AcquirePluginDataResponse::request_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquirePluginDataResponse.request_id)
  return _internal_request_id();
}
inline void AcquirePluginDataResponse::_internal_set_request_id(uint32_t value) {
  
  _impl_.request_id_ = value;
}
inline void AcquirePluginDataResponse::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.AcquirePluginDataResponse.request_id)
}

// .google.protobuf.Timestamp timeout_deadline = 5;
inline bool AcquirePluginDataResponse::_internal_has_timeout_deadline() const {
  return this != internal_default_instance() && _impl_.timeout_deadline_ != nullptr;
}
inline bool AcquirePluginDataResponse::has_timeout_deadline() const {
  return _internal_has_timeout_deadline();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AcquirePluginDataResponse::_internal_timeout_deadline() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timeout_deadline_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AcquirePluginDataResponse::timeout_deadline() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquirePluginDataResponse.timeout_deadline)
  return _internal_timeout_deadline();
}
inline void AcquirePluginDataResponse::unsafe_arena_set_allocated_timeout_deadline(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timeout_deadline) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timeout_deadline_);
  }
  _impl_.timeout_deadline_ = timeout_deadline;
  if (timeout_deadline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AcquirePluginDataResponse.timeout_deadline)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AcquirePluginDataResponse::release_timeout_deadline() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timeout_deadline_;
  _impl_.timeout_deadline_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AcquirePluginDataResponse::unsafe_arena_release_timeout_deadline() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquirePluginDataResponse.timeout_deadline)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timeout_deadline_;
  _impl_.timeout_deadline_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AcquirePluginDataResponse::_internal_mutable_timeout_deadline() {
  
  if (_impl_.timeout_deadline_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timeout_deadline_ = p;
  }
  return _impl_.timeout_deadline_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AcquirePluginDataResponse::mutable_timeout_deadline() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timeout_deadline();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquirePluginDataResponse.timeout_deadline)
  return _msg;
}
inline void AcquirePluginDataResponse::set_allocated_timeout_deadline(::PROTOBUF_NAMESPACE_ID::Timestamp* timeout_deadline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timeout_deadline_);
  }
  if (timeout_deadline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout_deadline));
    if (message_arena != submessage_arena) {
      timeout_deadline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timeout_deadline, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timeout_deadline_ = timeout_deadline;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquirePluginDataResponse.timeout_deadline)
}

// -------------------------------------------------------------------

// GetStatusRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetStatusRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetStatusRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetStatusRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetStatusRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetStatusRequest.header)
  return _internal_header();
}
inline void GetStatusRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetStatusRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetStatusRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetStatusRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetStatusRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetStatusRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* GetStatusRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetStatusRequest.header)
  return _msg;
}
inline void GetStatusRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetStatusRequest.header)
}

// uint32 request_id = 2;
inline void GetStatusRequest::clear_request_id() {
  _impl_.request_id_ = 0u;
}
inline uint32_t GetStatusRequest::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint32_t GetStatusRequest::request_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetStatusRequest.request_id)
  return _internal_request_id();
}
inline void GetStatusRequest::_internal_set_request_id(uint32_t value) {
  
  _impl_.request_id_ = value;
}
inline void GetStatusRequest::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.GetStatusRequest.request_id)
}

// -------------------------------------------------------------------

// GetStatusResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetStatusResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetStatusResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetStatusResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetStatusResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetStatusResponse.header)
  return _internal_header();
}
inline void GetStatusResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetStatusResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetStatusResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetStatusResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetStatusResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetStatusResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* GetStatusResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetStatusResponse.header)
  return _msg;
}
inline void GetStatusResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetStatusResponse.header)
}

// .bosdyn.api.GetStatusResponse.Status status = 2;
inline void GetStatusResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::GetStatusResponse_Status GetStatusResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::GetStatusResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::GetStatusResponse_Status GetStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetStatusResponse.status)
  return _internal_status();
}
inline void GetStatusResponse::_internal_set_status(::bosdyn::api::GetStatusResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void GetStatusResponse::set_status(::bosdyn::api::GetStatusResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.GetStatusResponse.status)
}

// repeated .bosdyn.api.DataIdentifier data_saved = 3;
inline int GetStatusResponse::_internal_data_saved_size() const {
  return _impl_.data_saved_.size();
}
inline int GetStatusResponse::data_saved_size() const {
  return _internal_data_saved_size();
}
inline void GetStatusResponse::clear_data_saved() {
  _impl_.data_saved_.Clear();
}
inline ::bosdyn::api::DataIdentifier* GetStatusResponse::mutable_data_saved(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetStatusResponse.data_saved)
  return _impl_.data_saved_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >*
GetStatusResponse::mutable_data_saved() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.GetStatusResponse.data_saved)
  return &_impl_.data_saved_;
}
inline const ::bosdyn::api::DataIdentifier& GetStatusResponse::_internal_data_saved(int index) const {
  return _impl_.data_saved_.Get(index);
}
inline const ::bosdyn::api::DataIdentifier& GetStatusResponse::data_saved(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetStatusResponse.data_saved)
  return _internal_data_saved(index);
}
inline ::bosdyn::api::DataIdentifier* GetStatusResponse::_internal_add_data_saved() {
  return _impl_.data_saved_.Add();
}
inline ::bosdyn::api::DataIdentifier* GetStatusResponse::add_data_saved() {
  ::bosdyn::api::DataIdentifier* _add = _internal_add_data_saved();
  // @@protoc_insertion_point(field_add:bosdyn.api.GetStatusResponse.data_saved)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >&
GetStatusResponse::data_saved() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.GetStatusResponse.data_saved)
  return _impl_.data_saved_;
}

// repeated .bosdyn.api.DataError data_errors = 9;
inline int GetStatusResponse::_internal_data_errors_size() const {
  return _impl_.data_errors_.size();
}
inline int GetStatusResponse::data_errors_size() const {
  return _internal_data_errors_size();
}
inline void GetStatusResponse::clear_data_errors() {
  _impl_.data_errors_.Clear();
}
inline ::bosdyn::api::DataError* GetStatusResponse::mutable_data_errors(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetStatusResponse.data_errors)
  return _impl_.data_errors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataError >*
GetStatusResponse::mutable_data_errors() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.GetStatusResponse.data_errors)
  return &_impl_.data_errors_;
}
inline const ::bosdyn::api::DataError& GetStatusResponse::_internal_data_errors(int index) const {
  return _impl_.data_errors_.Get(index);
}
inline const ::bosdyn::api::DataError& GetStatusResponse::data_errors(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetStatusResponse.data_errors)
  return _internal_data_errors(index);
}
inline ::bosdyn::api::DataError* GetStatusResponse::_internal_add_data_errors() {
  return _impl_.data_errors_.Add();
}
inline ::bosdyn::api::DataError* GetStatusResponse::add_data_errors() {
  ::bosdyn::api::DataError* _add = _internal_add_data_errors();
  // @@protoc_insertion_point(field_add:bosdyn.api.GetStatusResponse.data_errors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataError >&
GetStatusResponse::data_errors() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.GetStatusResponse.data_errors)
  return _impl_.data_errors_;
}

// repeated .bosdyn.api.PluginServiceError service_errors = 10;
inline int GetStatusResponse::_internal_service_errors_size() const {
  return _impl_.service_errors_.size();
}
inline int GetStatusResponse::service_errors_size() const {
  return _internal_service_errors_size();
}
inline void GetStatusResponse::clear_service_errors() {
  _impl_.service_errors_.Clear();
}
inline ::bosdyn::api::PluginServiceError* GetStatusResponse::mutable_service_errors(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetStatusResponse.service_errors)
  return _impl_.service_errors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PluginServiceError >*
GetStatusResponse::mutable_service_errors() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.GetStatusResponse.service_errors)
  return &_impl_.service_errors_;
}
inline const ::bosdyn::api::PluginServiceError& GetStatusResponse::_internal_service_errors(int index) const {
  return _impl_.service_errors_.Get(index);
}
inline const ::bosdyn::api::PluginServiceError& GetStatusResponse::service_errors(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetStatusResponse.service_errors)
  return _internal_service_errors(index);
}
inline ::bosdyn::api::PluginServiceError* GetStatusResponse::_internal_add_service_errors() {
  return _impl_.service_errors_.Add();
}
inline ::bosdyn::api::PluginServiceError* GetStatusResponse::add_service_errors() {
  ::bosdyn::api::PluginServiceError* _add = _internal_add_service_errors();
  // @@protoc_insertion_point(field_add:bosdyn.api.GetStatusResponse.service_errors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PluginServiceError >&
GetStatusResponse::service_errors() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.GetStatusResponse.service_errors)
  return _impl_.service_errors_;
}

// repeated .bosdyn.api.NetworkComputeError network_compute_errors = 11;
inline int GetStatusResponse::_internal_network_compute_errors_size() const {
  return _impl_.network_compute_errors_.size();
}
inline int GetStatusResponse::network_compute_errors_size() const {
  return _internal_network_compute_errors_size();
}
inline void GetStatusResponse::clear_network_compute_errors() {
  _impl_.network_compute_errors_.Clear();
}
inline ::bosdyn::api::NetworkComputeError* GetStatusResponse::mutable_network_compute_errors(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetStatusResponse.network_compute_errors)
  return _impl_.network_compute_errors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::NetworkComputeError >*
GetStatusResponse::mutable_network_compute_errors() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.GetStatusResponse.network_compute_errors)
  return &_impl_.network_compute_errors_;
}
inline const ::bosdyn::api::NetworkComputeError& GetStatusResponse::_internal_network_compute_errors(int index) const {
  return _impl_.network_compute_errors_.Get(index);
}
inline const ::bosdyn::api::NetworkComputeError& GetStatusResponse::network_compute_errors(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetStatusResponse.network_compute_errors)
  return _internal_network_compute_errors(index);
}
inline ::bosdyn::api::NetworkComputeError* GetStatusResponse::_internal_add_network_compute_errors() {
  return _impl_.network_compute_errors_.Add();
}
inline ::bosdyn::api::NetworkComputeError* GetStatusResponse::add_network_compute_errors() {
  ::bosdyn::api::NetworkComputeError* _add = _internal_add_network_compute_errors();
  // @@protoc_insertion_point(field_add:bosdyn.api.GetStatusResponse.network_compute_errors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::NetworkComputeError >&
GetStatusResponse::network_compute_errors() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.GetStatusResponse.network_compute_errors)
  return _impl_.network_compute_errors_;
}

// -------------------------------------------------------------------

// GetServiceInfoRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetServiceInfoRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetServiceInfoRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetServiceInfoRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetServiceInfoRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetServiceInfoRequest.header)
  return _internal_header();
}
inline void GetServiceInfoRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetServiceInfoRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetServiceInfoRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetServiceInfoRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetServiceInfoRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetServiceInfoRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* GetServiceInfoRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetServiceInfoRequest.header)
  return _msg;
}
inline void GetServiceInfoRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetServiceInfoRequest.header)
}

// -------------------------------------------------------------------

// GetServiceInfoResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetServiceInfoResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetServiceInfoResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetServiceInfoResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetServiceInfoResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetServiceInfoResponse.header)
  return _internal_header();
}
inline void GetServiceInfoResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetServiceInfoResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetServiceInfoResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetServiceInfoResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetServiceInfoResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetServiceInfoResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* GetServiceInfoResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetServiceInfoResponse.header)
  return _msg;
}
inline void GetServiceInfoResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetServiceInfoResponse.header)
}

// .bosdyn.api.AcquisitionCapabilityList capabilities = 2;
inline bool GetServiceInfoResponse::_internal_has_capabilities() const {
  return this != internal_default_instance() && _impl_.capabilities_ != nullptr;
}
inline bool GetServiceInfoResponse::has_capabilities() const {
  return _internal_has_capabilities();
}
inline void GetServiceInfoResponse::clear_capabilities() {
  if (GetArenaForAllocation() == nullptr && _impl_.capabilities_ != nullptr) {
    delete _impl_.capabilities_;
  }
  _impl_.capabilities_ = nullptr;
}
inline const ::bosdyn::api::AcquisitionCapabilityList& GetServiceInfoResponse::_internal_capabilities() const {
  const ::bosdyn::api::AcquisitionCapabilityList* p = _impl_.capabilities_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::AcquisitionCapabilityList&>(
      ::bosdyn::api::_AcquisitionCapabilityList_default_instance_);
}
inline const ::bosdyn::api::AcquisitionCapabilityList& GetServiceInfoResponse::capabilities() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetServiceInfoResponse.capabilities)
  return _internal_capabilities();
}
inline void GetServiceInfoResponse::unsafe_arena_set_allocated_capabilities(
    ::bosdyn::api::AcquisitionCapabilityList* capabilities) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilities_);
  }
  _impl_.capabilities_ = capabilities;
  if (capabilities) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetServiceInfoResponse.capabilities)
}
inline ::bosdyn::api::AcquisitionCapabilityList* GetServiceInfoResponse::release_capabilities() {
  
  ::bosdyn::api::AcquisitionCapabilityList* temp = _impl_.capabilities_;
  _impl_.capabilities_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::AcquisitionCapabilityList* GetServiceInfoResponse::unsafe_arena_release_capabilities() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetServiceInfoResponse.capabilities)
  
  ::bosdyn::api::AcquisitionCapabilityList* temp = _impl_.capabilities_;
  _impl_.capabilities_ = nullptr;
  return temp;
}
inline ::bosdyn::api::AcquisitionCapabilityList* GetServiceInfoResponse::_internal_mutable_capabilities() {
  
  if (_impl_.capabilities_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::AcquisitionCapabilityList>(GetArenaForAllocation());
    _impl_.capabilities_ = p;
  }
  return _impl_.capabilities_;
}
inline ::bosdyn::api::AcquisitionCapabilityList* GetServiceInfoResponse::mutable_capabilities() {
  ::bosdyn::api::AcquisitionCapabilityList* _msg = _internal_mutable_capabilities();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetServiceInfoResponse.capabilities)
  return _msg;
}
inline void GetServiceInfoResponse::set_allocated_capabilities(::bosdyn::api::AcquisitionCapabilityList* capabilities) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.capabilities_;
  }
  if (capabilities) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(capabilities);
    if (message_arena != submessage_arena) {
      capabilities = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capabilities, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.capabilities_ = capabilities;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetServiceInfoResponse.capabilities)
}

// -------------------------------------------------------------------

// CancelAcquisitionRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool CancelAcquisitionRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool CancelAcquisitionRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& CancelAcquisitionRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& CancelAcquisitionRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CancelAcquisitionRequest.header)
  return _internal_header();
}
inline void CancelAcquisitionRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.CancelAcquisitionRequest.header)
}
inline ::bosdyn::api::RequestHeader* CancelAcquisitionRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* CancelAcquisitionRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.CancelAcquisitionRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* CancelAcquisitionRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* CancelAcquisitionRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.CancelAcquisitionRequest.header)
  return _msg;
}
inline void CancelAcquisitionRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.CancelAcquisitionRequest.header)
}

// uint32 request_id = 2;
inline void CancelAcquisitionRequest::clear_request_id() {
  _impl_.request_id_ = 0u;
}
inline uint32_t CancelAcquisitionRequest::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint32_t CancelAcquisitionRequest::request_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CancelAcquisitionRequest.request_id)
  return _internal_request_id();
}
inline void CancelAcquisitionRequest::_internal_set_request_id(uint32_t value) {
  
  _impl_.request_id_ = value;
}
inline void CancelAcquisitionRequest::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.CancelAcquisitionRequest.request_id)
}

// -------------------------------------------------------------------

// CancelAcquisitionResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool CancelAcquisitionResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool CancelAcquisitionResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& CancelAcquisitionResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& CancelAcquisitionResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CancelAcquisitionResponse.header)
  return _internal_header();
}
inline void CancelAcquisitionResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.CancelAcquisitionResponse.header)
}
inline ::bosdyn::api::ResponseHeader* CancelAcquisitionResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* CancelAcquisitionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.CancelAcquisitionResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* CancelAcquisitionResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* CancelAcquisitionResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.CancelAcquisitionResponse.header)
  return _msg;
}
inline void CancelAcquisitionResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.CancelAcquisitionResponse.header)
}

// .bosdyn.api.CancelAcquisitionResponse.Status status = 2;
inline void CancelAcquisitionResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::CancelAcquisitionResponse_Status CancelAcquisitionResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::CancelAcquisitionResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::CancelAcquisitionResponse_Status CancelAcquisitionResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CancelAcquisitionResponse.status)
  return _internal_status();
}
inline void CancelAcquisitionResponse::_internal_set_status(::bosdyn::api::CancelAcquisitionResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void CancelAcquisitionResponse::set_status(::bosdyn::api::CancelAcquisitionResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.CancelAcquisitionResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::PluginServiceError_ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::PluginServiceError_ErrorCode>() {
  return ::bosdyn::api::PluginServiceError_ErrorCode_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::NetworkComputeError_ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::NetworkComputeError_ErrorCode>() {
  return ::bosdyn::api::NetworkComputeError_ErrorCode_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::AcquireDataResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::AcquireDataResponse_Status>() {
  return ::bosdyn::api::AcquireDataResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::AcquirePluginDataResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::AcquirePluginDataResponse_Status>() {
  return ::bosdyn::api::AcquirePluginDataResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::GetStatusResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::GetStatusResponse_Status>() {
  return ::bosdyn::api::GetStatusResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::CancelAcquisitionResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::CancelAcquisitionResponse_Status>() {
  return ::bosdyn::api::CancelAcquisitionResponse_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fdata_5facquisition_2eproto
