// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/mission/remote.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fmission_2fremote_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fmission_2fremote_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/lease.pb.h"
#include "bosdyn/api/mission/util.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fmission_2fremote_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fmission_2fremote_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fmission_2fremote_2eproto;
namespace bosdyn {
namespace api {
namespace mission {
class EstablishSessionRequest;
struct EstablishSessionRequestDefaultTypeInternal;
extern EstablishSessionRequestDefaultTypeInternal _EstablishSessionRequest_default_instance_;
class EstablishSessionResponse;
struct EstablishSessionResponseDefaultTypeInternal;
extern EstablishSessionResponseDefaultTypeInternal _EstablishSessionResponse_default_instance_;
class StopRequest;
struct StopRequestDefaultTypeInternal;
extern StopRequestDefaultTypeInternal _StopRequest_default_instance_;
class StopResponse;
struct StopResponseDefaultTypeInternal;
extern StopResponseDefaultTypeInternal _StopResponse_default_instance_;
class TeardownSessionRequest;
struct TeardownSessionRequestDefaultTypeInternal;
extern TeardownSessionRequestDefaultTypeInternal _TeardownSessionRequest_default_instance_;
class TeardownSessionResponse;
struct TeardownSessionResponseDefaultTypeInternal;
extern TeardownSessionResponseDefaultTypeInternal _TeardownSessionResponse_default_instance_;
class TickRequest;
struct TickRequestDefaultTypeInternal;
extern TickRequestDefaultTypeInternal _TickRequest_default_instance_;
class TickResponse;
struct TickResponseDefaultTypeInternal;
extern TickResponseDefaultTypeInternal _TickResponse_default_instance_;
}  // namespace mission
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::mission::EstablishSessionRequest* Arena::CreateMaybeMessage<::bosdyn::api::mission::EstablishSessionRequest>(Arena*);
template<> ::bosdyn::api::mission::EstablishSessionResponse* Arena::CreateMaybeMessage<::bosdyn::api::mission::EstablishSessionResponse>(Arena*);
template<> ::bosdyn::api::mission::StopRequest* Arena::CreateMaybeMessage<::bosdyn::api::mission::StopRequest>(Arena*);
template<> ::bosdyn::api::mission::StopResponse* Arena::CreateMaybeMessage<::bosdyn::api::mission::StopResponse>(Arena*);
template<> ::bosdyn::api::mission::TeardownSessionRequest* Arena::CreateMaybeMessage<::bosdyn::api::mission::TeardownSessionRequest>(Arena*);
template<> ::bosdyn::api::mission::TeardownSessionResponse* Arena::CreateMaybeMessage<::bosdyn::api::mission::TeardownSessionResponse>(Arena*);
template<> ::bosdyn::api::mission::TickRequest* Arena::CreateMaybeMessage<::bosdyn::api::mission::TickRequest>(Arena*);
template<> ::bosdyn::api::mission::TickResponse* Arena::CreateMaybeMessage<::bosdyn::api::mission::TickResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {
namespace mission {

enum EstablishSessionResponse_Status : int {
  EstablishSessionResponse_Status_STATUS_UNKNOWN = 0,
  EstablishSessionResponse_Status_STATUS_OK = 1,
  EstablishSessionResponse_Status_STATUS_MISSING_LEASES = 2,
  EstablishSessionResponse_Status_STATUS_MISSING_INPUTS = 3,
  EstablishSessionResponse_Status_EstablishSessionResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EstablishSessionResponse_Status_EstablishSessionResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EstablishSessionResponse_Status_IsValid(int value);
constexpr EstablishSessionResponse_Status EstablishSessionResponse_Status_Status_MIN = EstablishSessionResponse_Status_STATUS_UNKNOWN;
constexpr EstablishSessionResponse_Status EstablishSessionResponse_Status_Status_MAX = EstablishSessionResponse_Status_STATUS_MISSING_INPUTS;
constexpr int EstablishSessionResponse_Status_Status_ARRAYSIZE = EstablishSessionResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EstablishSessionResponse_Status_descriptor();
template<typename T>
inline const std::string& EstablishSessionResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EstablishSessionResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EstablishSessionResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EstablishSessionResponse_Status_descriptor(), enum_t_value);
}
inline bool EstablishSessionResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EstablishSessionResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EstablishSessionResponse_Status>(
    EstablishSessionResponse_Status_descriptor(), name, value);
}
enum TickResponse_Status : int {
  TickResponse_Status_STATUS_UNKNOWN = 0,
  TickResponse_Status_STATUS_FAILURE = 1,
  TickResponse_Status_STATUS_RUNNING = 2,
  TickResponse_Status_STATUS_SUCCESS = 3,
  TickResponse_Status_STATUS_INVALID_SESSION_ID = 4,
  TickResponse_Status_STATUS_MISSING_LEASES = 5,
  TickResponse_Status_STATUS_MISSING_INPUTS = 6,
  TickResponse_Status_TickResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TickResponse_Status_TickResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TickResponse_Status_IsValid(int value);
constexpr TickResponse_Status TickResponse_Status_Status_MIN = TickResponse_Status_STATUS_UNKNOWN;
constexpr TickResponse_Status TickResponse_Status_Status_MAX = TickResponse_Status_STATUS_MISSING_INPUTS;
constexpr int TickResponse_Status_Status_ARRAYSIZE = TickResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TickResponse_Status_descriptor();
template<typename T>
inline const std::string& TickResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TickResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TickResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TickResponse_Status_descriptor(), enum_t_value);
}
inline bool TickResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TickResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TickResponse_Status>(
    TickResponse_Status_descriptor(), name, value);
}
enum StopResponse_Status : int {
  StopResponse_Status_STATUS_UNKNOWN = 0,
  StopResponse_Status_STATUS_OK = 1,
  StopResponse_Status_STATUS_INVALID_SESSION_ID = 2,
  StopResponse_Status_StopResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StopResponse_Status_StopResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StopResponse_Status_IsValid(int value);
constexpr StopResponse_Status StopResponse_Status_Status_MIN = StopResponse_Status_STATUS_UNKNOWN;
constexpr StopResponse_Status StopResponse_Status_Status_MAX = StopResponse_Status_STATUS_INVALID_SESSION_ID;
constexpr int StopResponse_Status_Status_ARRAYSIZE = StopResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StopResponse_Status_descriptor();
template<typename T>
inline const std::string& StopResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StopResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StopResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StopResponse_Status_descriptor(), enum_t_value);
}
inline bool StopResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StopResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StopResponse_Status>(
    StopResponse_Status_descriptor(), name, value);
}
enum TeardownSessionResponse_Status : int {
  TeardownSessionResponse_Status_STATUS_UNKNOWN = 0,
  TeardownSessionResponse_Status_STATUS_OK = 1,
  TeardownSessionResponse_Status_STATUS_INVALID_SESSION_ID = 2,
  TeardownSessionResponse_Status_TeardownSessionResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TeardownSessionResponse_Status_TeardownSessionResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TeardownSessionResponse_Status_IsValid(int value);
constexpr TeardownSessionResponse_Status TeardownSessionResponse_Status_Status_MIN = TeardownSessionResponse_Status_STATUS_UNKNOWN;
constexpr TeardownSessionResponse_Status TeardownSessionResponse_Status_Status_MAX = TeardownSessionResponse_Status_STATUS_INVALID_SESSION_ID;
constexpr int TeardownSessionResponse_Status_Status_ARRAYSIZE = TeardownSessionResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TeardownSessionResponse_Status_descriptor();
template<typename T>
inline const std::string& TeardownSessionResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TeardownSessionResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TeardownSessionResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TeardownSessionResponse_Status_descriptor(), enum_t_value);
}
inline bool TeardownSessionResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TeardownSessionResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TeardownSessionResponse_Status>(
    TeardownSessionResponse_Status_descriptor(), name, value);
}
// ===================================================================

class EstablishSessionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.EstablishSessionRequest) */ {
 public:
  inline EstablishSessionRequest() : EstablishSessionRequest(nullptr) {}
  ~EstablishSessionRequest() override;
  explicit PROTOBUF_CONSTEXPR EstablishSessionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EstablishSessionRequest(const EstablishSessionRequest& from);
  EstablishSessionRequest(EstablishSessionRequest&& from) noexcept
    : EstablishSessionRequest() {
    *this = ::std::move(from);
  }

  inline EstablishSessionRequest& operator=(const EstablishSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EstablishSessionRequest& operator=(EstablishSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EstablishSessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EstablishSessionRequest* internal_default_instance() {
    return reinterpret_cast<const EstablishSessionRequest*>(
               &_EstablishSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EstablishSessionRequest& a, EstablishSessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EstablishSessionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EstablishSessionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EstablishSessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EstablishSessionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EstablishSessionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EstablishSessionRequest& from) {
    EstablishSessionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EstablishSessionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.EstablishSessionRequest";
  }
  protected:
  explicit EstablishSessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeasesFieldNumber = 2,
    kInputsFieldNumber = 3,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.Lease leases = 2;
  int leases_size() const;
  private:
  int _internal_leases_size() const;
  public:
  void clear_leases();
  ::bosdyn::api::Lease* mutable_leases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
      mutable_leases();
  private:
  const ::bosdyn::api::Lease& _internal_leases(int index) const;
  ::bosdyn::api::Lease* _internal_add_leases();
  public:
  const ::bosdyn::api::Lease& leases(int index) const;
  ::bosdyn::api::Lease* add_leases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
      leases() const;

  // repeated .bosdyn.api.mission.VariableDeclaration inputs = 3;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::bosdyn::api::mission::VariableDeclaration* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >*
      mutable_inputs();
  private:
  const ::bosdyn::api::mission::VariableDeclaration& _internal_inputs(int index) const;
  ::bosdyn::api::mission::VariableDeclaration* _internal_add_inputs();
  public:
  const ::bosdyn::api::mission::VariableDeclaration& inputs(int index) const;
  ::bosdyn::api::mission::VariableDeclaration* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >&
      inputs() const;

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.EstablishSessionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease > leases_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration > inputs_;
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fremote_2eproto;
};
// -------------------------------------------------------------------

class EstablishSessionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.EstablishSessionResponse) */ {
 public:
  inline EstablishSessionResponse() : EstablishSessionResponse(nullptr) {}
  ~EstablishSessionResponse() override;
  explicit PROTOBUF_CONSTEXPR EstablishSessionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EstablishSessionResponse(const EstablishSessionResponse& from);
  EstablishSessionResponse(EstablishSessionResponse&& from) noexcept
    : EstablishSessionResponse() {
    *this = ::std::move(from);
  }

  inline EstablishSessionResponse& operator=(const EstablishSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EstablishSessionResponse& operator=(EstablishSessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EstablishSessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EstablishSessionResponse* internal_default_instance() {
    return reinterpret_cast<const EstablishSessionResponse*>(
               &_EstablishSessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EstablishSessionResponse& a, EstablishSessionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EstablishSessionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EstablishSessionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EstablishSessionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EstablishSessionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EstablishSessionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EstablishSessionResponse& from) {
    EstablishSessionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EstablishSessionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.EstablishSessionResponse";
  }
  protected:
  explicit EstablishSessionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EstablishSessionResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    EstablishSessionResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    EstablishSessionResponse_Status_STATUS_OK;
  static constexpr Status STATUS_MISSING_LEASES =
    EstablishSessionResponse_Status_STATUS_MISSING_LEASES;
  static constexpr Status STATUS_MISSING_INPUTS =
    EstablishSessionResponse_Status_STATUS_MISSING_INPUTS;
  static inline bool Status_IsValid(int value) {
    return EstablishSessionResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    EstablishSessionResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    EstablishSessionResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    EstablishSessionResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return EstablishSessionResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return EstablishSessionResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return EstablishSessionResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMissingLeaseResourcesFieldNumber = 4,
    kLeaseUseResultsFieldNumber = 5,
    kMissingInputsFieldNumber = 6,
    kSessionIdFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated string missing_lease_resources = 4;
  int missing_lease_resources_size() const;
  private:
  int _internal_missing_lease_resources_size() const;
  public:
  void clear_missing_lease_resources();
  const std::string& missing_lease_resources(int index) const;
  std::string* mutable_missing_lease_resources(int index);
  void set_missing_lease_resources(int index, const std::string& value);
  void set_missing_lease_resources(int index, std::string&& value);
  void set_missing_lease_resources(int index, const char* value);
  void set_missing_lease_resources(int index, const char* value, size_t size);
  std::string* add_missing_lease_resources();
  void add_missing_lease_resources(const std::string& value);
  void add_missing_lease_resources(std::string&& value);
  void add_missing_lease_resources(const char* value);
  void add_missing_lease_resources(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& missing_lease_resources() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_missing_lease_resources();
  private:
  const std::string& _internal_missing_lease_resources(int index) const;
  std::string* _internal_add_missing_lease_resources();
  public:

  // repeated .bosdyn.api.LeaseUseResult lease_use_results = 5;
  int lease_use_results_size() const;
  private:
  int _internal_lease_use_results_size() const;
  public:
  void clear_lease_use_results();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
      mutable_lease_use_results();
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* _internal_add_lease_use_results();
  public:
  const ::bosdyn::api::LeaseUseResult& lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* add_lease_use_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
      lease_use_results() const;

  // repeated .bosdyn.api.mission.VariableDeclaration missing_inputs = 6;
  int missing_inputs_size() const;
  private:
  int _internal_missing_inputs_size() const;
  public:
  void clear_missing_inputs();
  ::bosdyn::api::mission::VariableDeclaration* mutable_missing_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >*
      mutable_missing_inputs();
  private:
  const ::bosdyn::api::mission::VariableDeclaration& _internal_missing_inputs(int index) const;
  ::bosdyn::api::mission::VariableDeclaration* _internal_add_missing_inputs();
  public:
  const ::bosdyn::api::mission::VariableDeclaration& missing_inputs(int index) const;
  ::bosdyn::api::mission::VariableDeclaration* add_missing_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >&
      missing_inputs() const;

  // string session_id = 3;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.mission.EstablishSessionResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::mission::EstablishSessionResponse_Status status() const;
  void set_status(::bosdyn::api::mission::EstablishSessionResponse_Status value);
  private:
  ::bosdyn::api::mission::EstablishSessionResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::mission::EstablishSessionResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.EstablishSessionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> missing_lease_resources_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult > lease_use_results_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration > missing_inputs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fremote_2eproto;
};
// -------------------------------------------------------------------

class TickRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.TickRequest) */ {
 public:
  inline TickRequest() : TickRequest(nullptr) {}
  ~TickRequest() override;
  explicit PROTOBUF_CONSTEXPR TickRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TickRequest(const TickRequest& from);
  TickRequest(TickRequest&& from) noexcept
    : TickRequest() {
    *this = ::std::move(from);
  }

  inline TickRequest& operator=(const TickRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TickRequest& operator=(TickRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TickRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TickRequest* internal_default_instance() {
    return reinterpret_cast<const TickRequest*>(
               &_TickRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TickRequest& a, TickRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TickRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TickRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TickRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TickRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TickRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TickRequest& from) {
    TickRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TickRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.TickRequest";
  }
  protected:
  explicit TickRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeasesFieldNumber = 3,
    kInputsFieldNumber = 4,
    kSessionIdFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.Lease leases = 3;
  int leases_size() const;
  private:
  int _internal_leases_size() const;
  public:
  void clear_leases();
  ::bosdyn::api::Lease* mutable_leases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
      mutable_leases();
  private:
  const ::bosdyn::api::Lease& _internal_leases(int index) const;
  ::bosdyn::api::Lease* _internal_add_leases();
  public:
  const ::bosdyn::api::Lease& leases(int index) const;
  ::bosdyn::api::Lease* add_leases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
      leases() const;

  // repeated .bosdyn.api.mission.KeyValue inputs = 4;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::bosdyn::api::mission::KeyValue* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
      mutable_inputs();
  private:
  const ::bosdyn::api::mission::KeyValue& _internal_inputs(int index) const;
  ::bosdyn::api::mission::KeyValue* _internal_add_inputs();
  public:
  const ::bosdyn::api::mission::KeyValue& inputs(int index) const;
  ::bosdyn::api::mission::KeyValue* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
      inputs() const;

  // string session_id = 2;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.TickRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease > leases_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue > inputs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fremote_2eproto;
};
// -------------------------------------------------------------------

class TickResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.TickResponse) */ {
 public:
  inline TickResponse() : TickResponse(nullptr) {}
  ~TickResponse() override;
  explicit PROTOBUF_CONSTEXPR TickResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TickResponse(const TickResponse& from);
  TickResponse(TickResponse&& from) noexcept
    : TickResponse() {
    *this = ::std::move(from);
  }

  inline TickResponse& operator=(const TickResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TickResponse& operator=(TickResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TickResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TickResponse* internal_default_instance() {
    return reinterpret_cast<const TickResponse*>(
               &_TickResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TickResponse& a, TickResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TickResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TickResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TickResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TickResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TickResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TickResponse& from) {
    TickResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TickResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.TickResponse";
  }
  protected:
  explicit TickResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TickResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    TickResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_FAILURE =
    TickResponse_Status_STATUS_FAILURE;
  static constexpr Status STATUS_RUNNING =
    TickResponse_Status_STATUS_RUNNING;
  static constexpr Status STATUS_SUCCESS =
    TickResponse_Status_STATUS_SUCCESS;
  static constexpr Status STATUS_INVALID_SESSION_ID =
    TickResponse_Status_STATUS_INVALID_SESSION_ID;
  static constexpr Status STATUS_MISSING_LEASES =
    TickResponse_Status_STATUS_MISSING_LEASES;
  static constexpr Status STATUS_MISSING_INPUTS =
    TickResponse_Status_STATUS_MISSING_INPUTS;
  static inline bool Status_IsValid(int value) {
    return TickResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    TickResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    TickResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    TickResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return TickResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return TickResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return TickResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMissingLeaseResourcesFieldNumber = 4,
    kLeaseUseResultsFieldNumber = 5,
    kMissingInputsFieldNumber = 7,
    kErrorMessageFieldNumber = 8,
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 3,
  };
  // repeated string missing_lease_resources = 4;
  int missing_lease_resources_size() const;
  private:
  int _internal_missing_lease_resources_size() const;
  public:
  void clear_missing_lease_resources();
  const std::string& missing_lease_resources(int index) const;
  std::string* mutable_missing_lease_resources(int index);
  void set_missing_lease_resources(int index, const std::string& value);
  void set_missing_lease_resources(int index, std::string&& value);
  void set_missing_lease_resources(int index, const char* value);
  void set_missing_lease_resources(int index, const char* value, size_t size);
  std::string* add_missing_lease_resources();
  void add_missing_lease_resources(const std::string& value);
  void add_missing_lease_resources(std::string&& value);
  void add_missing_lease_resources(const char* value);
  void add_missing_lease_resources(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& missing_lease_resources() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_missing_lease_resources();
  private:
  const std::string& _internal_missing_lease_resources(int index) const;
  std::string* _internal_add_missing_lease_resources();
  public:

  // repeated .bosdyn.api.LeaseUseResult lease_use_results = 5;
  int lease_use_results_size() const;
  private:
  int _internal_lease_use_results_size() const;
  public:
  void clear_lease_use_results();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
      mutable_lease_use_results();
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* _internal_add_lease_use_results();
  public:
  const ::bosdyn::api::LeaseUseResult& lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* add_lease_use_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
      lease_use_results() const;

  // repeated .bosdyn.api.mission.VariableDeclaration missing_inputs = 7;
  int missing_inputs_size() const;
  private:
  int _internal_missing_inputs_size() const;
  public:
  void clear_missing_inputs();
  ::bosdyn::api::mission::VariableDeclaration* mutable_missing_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >*
      mutable_missing_inputs();
  private:
  const ::bosdyn::api::mission::VariableDeclaration& _internal_missing_inputs(int index) const;
  ::bosdyn::api::mission::VariableDeclaration* _internal_add_missing_inputs();
  public:
  const ::bosdyn::api::mission::VariableDeclaration& missing_inputs(int index) const;
  ::bosdyn::api::mission::VariableDeclaration* add_missing_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >&
      missing_inputs() const;

  // string error_message = 8;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.mission.TickResponse.Status status = 3;
  void clear_status();
  ::bosdyn::api::mission::TickResponse_Status status() const;
  void set_status(::bosdyn::api::mission::TickResponse_Status value);
  private:
  ::bosdyn::api::mission::TickResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::mission::TickResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.TickResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> missing_lease_resources_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult > lease_use_results_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration > missing_inputs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fremote_2eproto;
};
// -------------------------------------------------------------------

class StopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.StopRequest) */ {
 public:
  inline StopRequest() : StopRequest(nullptr) {}
  ~StopRequest() override;
  explicit PROTOBUF_CONSTEXPR StopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopRequest(const StopRequest& from);
  StopRequest(StopRequest&& from) noexcept
    : StopRequest() {
    *this = ::std::move(from);
  }

  inline StopRequest& operator=(const StopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopRequest& operator=(StopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopRequest* internal_default_instance() {
    return reinterpret_cast<const StopRequest*>(
               &_StopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StopRequest& a, StopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopRequest& from) {
    StopRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.StopRequest";
  }
  protected:
  explicit StopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // string session_id = 2;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.StopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fremote_2eproto;
};
// -------------------------------------------------------------------

class StopResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.StopResponse) */ {
 public:
  inline StopResponse() : StopResponse(nullptr) {}
  ~StopResponse() override;
  explicit PROTOBUF_CONSTEXPR StopResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopResponse(const StopResponse& from);
  StopResponse(StopResponse&& from) noexcept
    : StopResponse() {
    *this = ::std::move(from);
  }

  inline StopResponse& operator=(const StopResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopResponse& operator=(StopResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopResponse* internal_default_instance() {
    return reinterpret_cast<const StopResponse*>(
               &_StopResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StopResponse& a, StopResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StopResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopResponse& from) {
    StopResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.StopResponse";
  }
  protected:
  explicit StopResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StopResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    StopResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    StopResponse_Status_STATUS_OK;
  static constexpr Status STATUS_INVALID_SESSION_ID =
    StopResponse_Status_STATUS_INVALID_SESSION_ID;
  static inline bool Status_IsValid(int value) {
    return StopResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    StopResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    StopResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    StopResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return StopResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return StopResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return StopResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.mission.StopResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::mission::StopResponse_Status status() const;
  void set_status(::bosdyn::api::mission::StopResponse_Status value);
  private:
  ::bosdyn::api::mission::StopResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::mission::StopResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.StopResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fremote_2eproto;
};
// -------------------------------------------------------------------

class TeardownSessionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.TeardownSessionRequest) */ {
 public:
  inline TeardownSessionRequest() : TeardownSessionRequest(nullptr) {}
  ~TeardownSessionRequest() override;
  explicit PROTOBUF_CONSTEXPR TeardownSessionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TeardownSessionRequest(const TeardownSessionRequest& from);
  TeardownSessionRequest(TeardownSessionRequest&& from) noexcept
    : TeardownSessionRequest() {
    *this = ::std::move(from);
  }

  inline TeardownSessionRequest& operator=(const TeardownSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeardownSessionRequest& operator=(TeardownSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TeardownSessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TeardownSessionRequest* internal_default_instance() {
    return reinterpret_cast<const TeardownSessionRequest*>(
               &_TeardownSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TeardownSessionRequest& a, TeardownSessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TeardownSessionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TeardownSessionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TeardownSessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TeardownSessionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TeardownSessionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TeardownSessionRequest& from) {
    TeardownSessionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeardownSessionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.TeardownSessionRequest";
  }
  protected:
  explicit TeardownSessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // string session_id = 2;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.TeardownSessionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fremote_2eproto;
};
// -------------------------------------------------------------------

class TeardownSessionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.TeardownSessionResponse) */ {
 public:
  inline TeardownSessionResponse() : TeardownSessionResponse(nullptr) {}
  ~TeardownSessionResponse() override;
  explicit PROTOBUF_CONSTEXPR TeardownSessionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TeardownSessionResponse(const TeardownSessionResponse& from);
  TeardownSessionResponse(TeardownSessionResponse&& from) noexcept
    : TeardownSessionResponse() {
    *this = ::std::move(from);
  }

  inline TeardownSessionResponse& operator=(const TeardownSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeardownSessionResponse& operator=(TeardownSessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TeardownSessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TeardownSessionResponse* internal_default_instance() {
    return reinterpret_cast<const TeardownSessionResponse*>(
               &_TeardownSessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TeardownSessionResponse& a, TeardownSessionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TeardownSessionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TeardownSessionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TeardownSessionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TeardownSessionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TeardownSessionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TeardownSessionResponse& from) {
    TeardownSessionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeardownSessionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.TeardownSessionResponse";
  }
  protected:
  explicit TeardownSessionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TeardownSessionResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    TeardownSessionResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    TeardownSessionResponse_Status_STATUS_OK;
  static constexpr Status STATUS_INVALID_SESSION_ID =
    TeardownSessionResponse_Status_STATUS_INVALID_SESSION_ID;
  static inline bool Status_IsValid(int value) {
    return TeardownSessionResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    TeardownSessionResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    TeardownSessionResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    TeardownSessionResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return TeardownSessionResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return TeardownSessionResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return TeardownSessionResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.mission.TeardownSessionResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::mission::TeardownSessionResponse_Status status() const;
  void set_status(::bosdyn::api::mission::TeardownSessionResponse_Status value);
  private:
  ::bosdyn::api::mission::TeardownSessionResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::mission::TeardownSessionResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.TeardownSessionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fremote_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EstablishSessionRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool EstablishSessionRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool EstablishSessionRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& EstablishSessionRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& EstablishSessionRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.EstablishSessionRequest.header)
  return _internal_header();
}
inline void EstablishSessionRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.EstablishSessionRequest.header)
}
inline ::bosdyn::api::RequestHeader* EstablishSessionRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* EstablishSessionRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.EstablishSessionRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* EstablishSessionRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* EstablishSessionRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.EstablishSessionRequest.header)
  return _msg;
}
inline void EstablishSessionRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.EstablishSessionRequest.header)
}

// repeated .bosdyn.api.Lease leases = 2;
inline int EstablishSessionRequest::_internal_leases_size() const {
  return _impl_.leases_.size();
}
inline int EstablishSessionRequest::leases_size() const {
  return _internal_leases_size();
}
inline ::bosdyn::api::Lease* EstablishSessionRequest::mutable_leases(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.EstablishSessionRequest.leases)
  return _impl_.leases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
EstablishSessionRequest::mutable_leases() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.EstablishSessionRequest.leases)
  return &_impl_.leases_;
}
inline const ::bosdyn::api::Lease& EstablishSessionRequest::_internal_leases(int index) const {
  return _impl_.leases_.Get(index);
}
inline const ::bosdyn::api::Lease& EstablishSessionRequest::leases(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.EstablishSessionRequest.leases)
  return _internal_leases(index);
}
inline ::bosdyn::api::Lease* EstablishSessionRequest::_internal_add_leases() {
  return _impl_.leases_.Add();
}
inline ::bosdyn::api::Lease* EstablishSessionRequest::add_leases() {
  ::bosdyn::api::Lease* _add = _internal_add_leases();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.EstablishSessionRequest.leases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
EstablishSessionRequest::leases() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.EstablishSessionRequest.leases)
  return _impl_.leases_;
}

// repeated .bosdyn.api.mission.VariableDeclaration inputs = 3;
inline int EstablishSessionRequest::_internal_inputs_size() const {
  return _impl_.inputs_.size();
}
inline int EstablishSessionRequest::inputs_size() const {
  return _internal_inputs_size();
}
inline ::bosdyn::api::mission::VariableDeclaration* EstablishSessionRequest::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.EstablishSessionRequest.inputs)
  return _impl_.inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >*
EstablishSessionRequest::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.EstablishSessionRequest.inputs)
  return &_impl_.inputs_;
}
inline const ::bosdyn::api::mission::VariableDeclaration& EstablishSessionRequest::_internal_inputs(int index) const {
  return _impl_.inputs_.Get(index);
}
inline const ::bosdyn::api::mission::VariableDeclaration& EstablishSessionRequest::inputs(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.EstablishSessionRequest.inputs)
  return _internal_inputs(index);
}
inline ::bosdyn::api::mission::VariableDeclaration* EstablishSessionRequest::_internal_add_inputs() {
  return _impl_.inputs_.Add();
}
inline ::bosdyn::api::mission::VariableDeclaration* EstablishSessionRequest::add_inputs() {
  ::bosdyn::api::mission::VariableDeclaration* _add = _internal_add_inputs();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.EstablishSessionRequest.inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >&
EstablishSessionRequest::inputs() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.EstablishSessionRequest.inputs)
  return _impl_.inputs_;
}

// -------------------------------------------------------------------

// EstablishSessionResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool EstablishSessionResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool EstablishSessionResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& EstablishSessionResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& EstablishSessionResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.EstablishSessionResponse.header)
  return _internal_header();
}
inline void EstablishSessionResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.EstablishSessionResponse.header)
}
inline ::bosdyn::api::ResponseHeader* EstablishSessionResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* EstablishSessionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.EstablishSessionResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* EstablishSessionResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* EstablishSessionResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.EstablishSessionResponse.header)
  return _msg;
}
inline void EstablishSessionResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.EstablishSessionResponse.header)
}

// .bosdyn.api.mission.EstablishSessionResponse.Status status = 2;
inline void EstablishSessionResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::mission::EstablishSessionResponse_Status EstablishSessionResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::mission::EstablishSessionResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::mission::EstablishSessionResponse_Status EstablishSessionResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.EstablishSessionResponse.status)
  return _internal_status();
}
inline void EstablishSessionResponse::_internal_set_status(::bosdyn::api::mission::EstablishSessionResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void EstablishSessionResponse::set_status(::bosdyn::api::mission::EstablishSessionResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.EstablishSessionResponse.status)
}

// string session_id = 3;
inline void EstablishSessionResponse::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& EstablishSessionResponse::session_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.EstablishSessionResponse.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EstablishSessionResponse::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.EstablishSessionResponse.session_id)
}
inline std::string* EstablishSessionResponse::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.EstablishSessionResponse.session_id)
  return _s;
}
inline const std::string& EstablishSessionResponse::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void EstablishSessionResponse::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EstablishSessionResponse::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EstablishSessionResponse::release_session_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.EstablishSessionResponse.session_id)
  return _impl_.session_id_.Release();
}
inline void EstablishSessionResponse::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.EstablishSessionResponse.session_id)
}

// repeated string missing_lease_resources = 4;
inline int EstablishSessionResponse::_internal_missing_lease_resources_size() const {
  return _impl_.missing_lease_resources_.size();
}
inline int EstablishSessionResponse::missing_lease_resources_size() const {
  return _internal_missing_lease_resources_size();
}
inline void EstablishSessionResponse::clear_missing_lease_resources() {
  _impl_.missing_lease_resources_.Clear();
}
inline std::string* EstablishSessionResponse::add_missing_lease_resources() {
  std::string* _s = _internal_add_missing_lease_resources();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.mission.EstablishSessionResponse.missing_lease_resources)
  return _s;
}
inline const std::string& EstablishSessionResponse::_internal_missing_lease_resources(int index) const {
  return _impl_.missing_lease_resources_.Get(index);
}
inline const std::string& EstablishSessionResponse::missing_lease_resources(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.EstablishSessionResponse.missing_lease_resources)
  return _internal_missing_lease_resources(index);
}
inline std::string* EstablishSessionResponse::mutable_missing_lease_resources(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.EstablishSessionResponse.missing_lease_resources)
  return _impl_.missing_lease_resources_.Mutable(index);
}
inline void EstablishSessionResponse::set_missing_lease_resources(int index, const std::string& value) {
  _impl_.missing_lease_resources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.EstablishSessionResponse.missing_lease_resources)
}
inline void EstablishSessionResponse::set_missing_lease_resources(int index, std::string&& value) {
  _impl_.missing_lease_resources_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.EstablishSessionResponse.missing_lease_resources)
}
inline void EstablishSessionResponse::set_missing_lease_resources(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.missing_lease_resources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.EstablishSessionResponse.missing_lease_resources)
}
inline void EstablishSessionResponse::set_missing_lease_resources(int index, const char* value, size_t size) {
  _impl_.missing_lease_resources_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.EstablishSessionResponse.missing_lease_resources)
}
inline std::string* EstablishSessionResponse::_internal_add_missing_lease_resources() {
  return _impl_.missing_lease_resources_.Add();
}
inline void EstablishSessionResponse::add_missing_lease_resources(const std::string& value) {
  _impl_.missing_lease_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.EstablishSessionResponse.missing_lease_resources)
}
inline void EstablishSessionResponse::add_missing_lease_resources(std::string&& value) {
  _impl_.missing_lease_resources_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.EstablishSessionResponse.missing_lease_resources)
}
inline void EstablishSessionResponse::add_missing_lease_resources(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.missing_lease_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.mission.EstablishSessionResponse.missing_lease_resources)
}
inline void EstablishSessionResponse::add_missing_lease_resources(const char* value, size_t size) {
  _impl_.missing_lease_resources_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.mission.EstablishSessionResponse.missing_lease_resources)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EstablishSessionResponse::missing_lease_resources() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.EstablishSessionResponse.missing_lease_resources)
  return _impl_.missing_lease_resources_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EstablishSessionResponse::mutable_missing_lease_resources() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.EstablishSessionResponse.missing_lease_resources)
  return &_impl_.missing_lease_resources_;
}

// repeated .bosdyn.api.LeaseUseResult lease_use_results = 5;
inline int EstablishSessionResponse::_internal_lease_use_results_size() const {
  return _impl_.lease_use_results_.size();
}
inline int EstablishSessionResponse::lease_use_results_size() const {
  return _internal_lease_use_results_size();
}
inline ::bosdyn::api::LeaseUseResult* EstablishSessionResponse::mutable_lease_use_results(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.EstablishSessionResponse.lease_use_results)
  return _impl_.lease_use_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
EstablishSessionResponse::mutable_lease_use_results() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.EstablishSessionResponse.lease_use_results)
  return &_impl_.lease_use_results_;
}
inline const ::bosdyn::api::LeaseUseResult& EstablishSessionResponse::_internal_lease_use_results(int index) const {
  return _impl_.lease_use_results_.Get(index);
}
inline const ::bosdyn::api::LeaseUseResult& EstablishSessionResponse::lease_use_results(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.EstablishSessionResponse.lease_use_results)
  return _internal_lease_use_results(index);
}
inline ::bosdyn::api::LeaseUseResult* EstablishSessionResponse::_internal_add_lease_use_results() {
  return _impl_.lease_use_results_.Add();
}
inline ::bosdyn::api::LeaseUseResult* EstablishSessionResponse::add_lease_use_results() {
  ::bosdyn::api::LeaseUseResult* _add = _internal_add_lease_use_results();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.EstablishSessionResponse.lease_use_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
EstablishSessionResponse::lease_use_results() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.EstablishSessionResponse.lease_use_results)
  return _impl_.lease_use_results_;
}

// repeated .bosdyn.api.mission.VariableDeclaration missing_inputs = 6;
inline int EstablishSessionResponse::_internal_missing_inputs_size() const {
  return _impl_.missing_inputs_.size();
}
inline int EstablishSessionResponse::missing_inputs_size() const {
  return _internal_missing_inputs_size();
}
inline ::bosdyn::api::mission::VariableDeclaration* EstablishSessionResponse::mutable_missing_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.EstablishSessionResponse.missing_inputs)
  return _impl_.missing_inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >*
EstablishSessionResponse::mutable_missing_inputs() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.EstablishSessionResponse.missing_inputs)
  return &_impl_.missing_inputs_;
}
inline const ::bosdyn::api::mission::VariableDeclaration& EstablishSessionResponse::_internal_missing_inputs(int index) const {
  return _impl_.missing_inputs_.Get(index);
}
inline const ::bosdyn::api::mission::VariableDeclaration& EstablishSessionResponse::missing_inputs(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.EstablishSessionResponse.missing_inputs)
  return _internal_missing_inputs(index);
}
inline ::bosdyn::api::mission::VariableDeclaration* EstablishSessionResponse::_internal_add_missing_inputs() {
  return _impl_.missing_inputs_.Add();
}
inline ::bosdyn::api::mission::VariableDeclaration* EstablishSessionResponse::add_missing_inputs() {
  ::bosdyn::api::mission::VariableDeclaration* _add = _internal_add_missing_inputs();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.EstablishSessionResponse.missing_inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >&
EstablishSessionResponse::missing_inputs() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.EstablishSessionResponse.missing_inputs)
  return _impl_.missing_inputs_;
}

// -------------------------------------------------------------------

// TickRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool TickRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool TickRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& TickRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& TickRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.TickRequest.header)
  return _internal_header();
}
inline void TickRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.TickRequest.header)
}
inline ::bosdyn::api::RequestHeader* TickRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* TickRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.TickRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* TickRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* TickRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.TickRequest.header)
  return _msg;
}
inline void TickRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.TickRequest.header)
}

// string session_id = 2;
inline void TickRequest::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& TickRequest::session_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.TickRequest.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TickRequest::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.TickRequest.session_id)
}
inline std::string* TickRequest::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.TickRequest.session_id)
  return _s;
}
inline const std::string& TickRequest::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void TickRequest::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TickRequest::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TickRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.TickRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void TickRequest::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.TickRequest.session_id)
}

// repeated .bosdyn.api.Lease leases = 3;
inline int TickRequest::_internal_leases_size() const {
  return _impl_.leases_.size();
}
inline int TickRequest::leases_size() const {
  return _internal_leases_size();
}
inline ::bosdyn::api::Lease* TickRequest::mutable_leases(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.TickRequest.leases)
  return _impl_.leases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
TickRequest::mutable_leases() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.TickRequest.leases)
  return &_impl_.leases_;
}
inline const ::bosdyn::api::Lease& TickRequest::_internal_leases(int index) const {
  return _impl_.leases_.Get(index);
}
inline const ::bosdyn::api::Lease& TickRequest::leases(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.TickRequest.leases)
  return _internal_leases(index);
}
inline ::bosdyn::api::Lease* TickRequest::_internal_add_leases() {
  return _impl_.leases_.Add();
}
inline ::bosdyn::api::Lease* TickRequest::add_leases() {
  ::bosdyn::api::Lease* _add = _internal_add_leases();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.TickRequest.leases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
TickRequest::leases() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.TickRequest.leases)
  return _impl_.leases_;
}

// repeated .bosdyn.api.mission.KeyValue inputs = 4;
inline int TickRequest::_internal_inputs_size() const {
  return _impl_.inputs_.size();
}
inline int TickRequest::inputs_size() const {
  return _internal_inputs_size();
}
inline ::bosdyn::api::mission::KeyValue* TickRequest::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.TickRequest.inputs)
  return _impl_.inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
TickRequest::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.TickRequest.inputs)
  return &_impl_.inputs_;
}
inline const ::bosdyn::api::mission::KeyValue& TickRequest::_internal_inputs(int index) const {
  return _impl_.inputs_.Get(index);
}
inline const ::bosdyn::api::mission::KeyValue& TickRequest::inputs(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.TickRequest.inputs)
  return _internal_inputs(index);
}
inline ::bosdyn::api::mission::KeyValue* TickRequest::_internal_add_inputs() {
  return _impl_.inputs_.Add();
}
inline ::bosdyn::api::mission::KeyValue* TickRequest::add_inputs() {
  ::bosdyn::api::mission::KeyValue* _add = _internal_add_inputs();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.TickRequest.inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
TickRequest::inputs() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.TickRequest.inputs)
  return _impl_.inputs_;
}

// -------------------------------------------------------------------

// TickResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool TickResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool TickResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& TickResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& TickResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.TickResponse.header)
  return _internal_header();
}
inline void TickResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.TickResponse.header)
}
inline ::bosdyn::api::ResponseHeader* TickResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* TickResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.TickResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* TickResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* TickResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.TickResponse.header)
  return _msg;
}
inline void TickResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.TickResponse.header)
}

// .bosdyn.api.mission.TickResponse.Status status = 3;
inline void TickResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::mission::TickResponse_Status TickResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::mission::TickResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::mission::TickResponse_Status TickResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.TickResponse.status)
  return _internal_status();
}
inline void TickResponse::_internal_set_status(::bosdyn::api::mission::TickResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void TickResponse::set_status(::bosdyn::api::mission::TickResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.TickResponse.status)
}

// repeated string missing_lease_resources = 4;
inline int TickResponse::_internal_missing_lease_resources_size() const {
  return _impl_.missing_lease_resources_.size();
}
inline int TickResponse::missing_lease_resources_size() const {
  return _internal_missing_lease_resources_size();
}
inline void TickResponse::clear_missing_lease_resources() {
  _impl_.missing_lease_resources_.Clear();
}
inline std::string* TickResponse::add_missing_lease_resources() {
  std::string* _s = _internal_add_missing_lease_resources();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.mission.TickResponse.missing_lease_resources)
  return _s;
}
inline const std::string& TickResponse::_internal_missing_lease_resources(int index) const {
  return _impl_.missing_lease_resources_.Get(index);
}
inline const std::string& TickResponse::missing_lease_resources(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.TickResponse.missing_lease_resources)
  return _internal_missing_lease_resources(index);
}
inline std::string* TickResponse::mutable_missing_lease_resources(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.TickResponse.missing_lease_resources)
  return _impl_.missing_lease_resources_.Mutable(index);
}
inline void TickResponse::set_missing_lease_resources(int index, const std::string& value) {
  _impl_.missing_lease_resources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.TickResponse.missing_lease_resources)
}
inline void TickResponse::set_missing_lease_resources(int index, std::string&& value) {
  _impl_.missing_lease_resources_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.TickResponse.missing_lease_resources)
}
inline void TickResponse::set_missing_lease_resources(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.missing_lease_resources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.TickResponse.missing_lease_resources)
}
inline void TickResponse::set_missing_lease_resources(int index, const char* value, size_t size) {
  _impl_.missing_lease_resources_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.TickResponse.missing_lease_resources)
}
inline std::string* TickResponse::_internal_add_missing_lease_resources() {
  return _impl_.missing_lease_resources_.Add();
}
inline void TickResponse::add_missing_lease_resources(const std::string& value) {
  _impl_.missing_lease_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.TickResponse.missing_lease_resources)
}
inline void TickResponse::add_missing_lease_resources(std::string&& value) {
  _impl_.missing_lease_resources_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.TickResponse.missing_lease_resources)
}
inline void TickResponse::add_missing_lease_resources(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.missing_lease_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.mission.TickResponse.missing_lease_resources)
}
inline void TickResponse::add_missing_lease_resources(const char* value, size_t size) {
  _impl_.missing_lease_resources_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.mission.TickResponse.missing_lease_resources)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TickResponse::missing_lease_resources() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.TickResponse.missing_lease_resources)
  return _impl_.missing_lease_resources_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TickResponse::mutable_missing_lease_resources() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.TickResponse.missing_lease_resources)
  return &_impl_.missing_lease_resources_;
}

// repeated .bosdyn.api.LeaseUseResult lease_use_results = 5;
inline int TickResponse::_internal_lease_use_results_size() const {
  return _impl_.lease_use_results_.size();
}
inline int TickResponse::lease_use_results_size() const {
  return _internal_lease_use_results_size();
}
inline ::bosdyn::api::LeaseUseResult* TickResponse::mutable_lease_use_results(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.TickResponse.lease_use_results)
  return _impl_.lease_use_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
TickResponse::mutable_lease_use_results() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.TickResponse.lease_use_results)
  return &_impl_.lease_use_results_;
}
inline const ::bosdyn::api::LeaseUseResult& TickResponse::_internal_lease_use_results(int index) const {
  return _impl_.lease_use_results_.Get(index);
}
inline const ::bosdyn::api::LeaseUseResult& TickResponse::lease_use_results(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.TickResponse.lease_use_results)
  return _internal_lease_use_results(index);
}
inline ::bosdyn::api::LeaseUseResult* TickResponse::_internal_add_lease_use_results() {
  return _impl_.lease_use_results_.Add();
}
inline ::bosdyn::api::LeaseUseResult* TickResponse::add_lease_use_results() {
  ::bosdyn::api::LeaseUseResult* _add = _internal_add_lease_use_results();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.TickResponse.lease_use_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
TickResponse::lease_use_results() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.TickResponse.lease_use_results)
  return _impl_.lease_use_results_;
}

// repeated .bosdyn.api.mission.VariableDeclaration missing_inputs = 7;
inline int TickResponse::_internal_missing_inputs_size() const {
  return _impl_.missing_inputs_.size();
}
inline int TickResponse::missing_inputs_size() const {
  return _internal_missing_inputs_size();
}
inline ::bosdyn::api::mission::VariableDeclaration* TickResponse::mutable_missing_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.TickResponse.missing_inputs)
  return _impl_.missing_inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >*
TickResponse::mutable_missing_inputs() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.TickResponse.missing_inputs)
  return &_impl_.missing_inputs_;
}
inline const ::bosdyn::api::mission::VariableDeclaration& TickResponse::_internal_missing_inputs(int index) const {
  return _impl_.missing_inputs_.Get(index);
}
inline const ::bosdyn::api::mission::VariableDeclaration& TickResponse::missing_inputs(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.TickResponse.missing_inputs)
  return _internal_missing_inputs(index);
}
inline ::bosdyn::api::mission::VariableDeclaration* TickResponse::_internal_add_missing_inputs() {
  return _impl_.missing_inputs_.Add();
}
inline ::bosdyn::api::mission::VariableDeclaration* TickResponse::add_missing_inputs() {
  ::bosdyn::api::mission::VariableDeclaration* _add = _internal_add_missing_inputs();
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.TickResponse.missing_inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >&
TickResponse::missing_inputs() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.TickResponse.missing_inputs)
  return _impl_.missing_inputs_;
}

// string error_message = 8;
inline void TickResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& TickResponse::error_message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.TickResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TickResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.TickResponse.error_message)
}
inline std::string* TickResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.TickResponse.error_message)
  return _s;
}
inline const std::string& TickResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void TickResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* TickResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* TickResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.TickResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void TickResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.TickResponse.error_message)
}

// -------------------------------------------------------------------

// StopRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool StopRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool StopRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& StopRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& StopRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.StopRequest.header)
  return _internal_header();
}
inline void StopRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.StopRequest.header)
}
inline ::bosdyn::api::RequestHeader* StopRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* StopRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.StopRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* StopRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* StopRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.StopRequest.header)
  return _msg;
}
inline void StopRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.StopRequest.header)
}

// string session_id = 2;
inline void StopRequest::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& StopRequest::session_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.StopRequest.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopRequest::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.StopRequest.session_id)
}
inline std::string* StopRequest::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.StopRequest.session_id)
  return _s;
}
inline const std::string& StopRequest::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void StopRequest::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StopRequest::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StopRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.StopRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void StopRequest::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.StopRequest.session_id)
}

// -------------------------------------------------------------------

// StopResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool StopResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool StopResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& StopResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& StopResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.StopResponse.header)
  return _internal_header();
}
inline void StopResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.StopResponse.header)
}
inline ::bosdyn::api::ResponseHeader* StopResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StopResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.StopResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StopResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* StopResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.StopResponse.header)
  return _msg;
}
inline void StopResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.StopResponse.header)
}

// .bosdyn.api.mission.StopResponse.Status status = 2;
inline void StopResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::mission::StopResponse_Status StopResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::mission::StopResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::mission::StopResponse_Status StopResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.StopResponse.status)
  return _internal_status();
}
inline void StopResponse::_internal_set_status(::bosdyn::api::mission::StopResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void StopResponse::set_status(::bosdyn::api::mission::StopResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.StopResponse.status)
}

// -------------------------------------------------------------------

// TeardownSessionRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool TeardownSessionRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool TeardownSessionRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& TeardownSessionRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& TeardownSessionRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.TeardownSessionRequest.header)
  return _internal_header();
}
inline void TeardownSessionRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.TeardownSessionRequest.header)
}
inline ::bosdyn::api::RequestHeader* TeardownSessionRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* TeardownSessionRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.TeardownSessionRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* TeardownSessionRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* TeardownSessionRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.TeardownSessionRequest.header)
  return _msg;
}
inline void TeardownSessionRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.TeardownSessionRequest.header)
}

// string session_id = 2;
inline void TeardownSessionRequest::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& TeardownSessionRequest::session_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.TeardownSessionRequest.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeardownSessionRequest::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.TeardownSessionRequest.session_id)
}
inline std::string* TeardownSessionRequest::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.TeardownSessionRequest.session_id)
  return _s;
}
inline const std::string& TeardownSessionRequest::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void TeardownSessionRequest::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TeardownSessionRequest::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TeardownSessionRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.TeardownSessionRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void TeardownSessionRequest::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.TeardownSessionRequest.session_id)
}

// -------------------------------------------------------------------

// TeardownSessionResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool TeardownSessionResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool TeardownSessionResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& TeardownSessionResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& TeardownSessionResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.TeardownSessionResponse.header)
  return _internal_header();
}
inline void TeardownSessionResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.TeardownSessionResponse.header)
}
inline ::bosdyn::api::ResponseHeader* TeardownSessionResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* TeardownSessionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.TeardownSessionResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* TeardownSessionResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* TeardownSessionResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.TeardownSessionResponse.header)
  return _msg;
}
inline void TeardownSessionResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.TeardownSessionResponse.header)
}

// .bosdyn.api.mission.TeardownSessionResponse.Status status = 2;
inline void TeardownSessionResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::mission::TeardownSessionResponse_Status TeardownSessionResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::mission::TeardownSessionResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::mission::TeardownSessionResponse_Status TeardownSessionResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.TeardownSessionResponse.status)
  return _internal_status();
}
inline void TeardownSessionResponse::_internal_set_status(::bosdyn::api::mission::TeardownSessionResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void TeardownSessionResponse::set_status(::bosdyn::api::mission::TeardownSessionResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.TeardownSessionResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mission
}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::mission::EstablishSessionResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::mission::EstablishSessionResponse_Status>() {
  return ::bosdyn::api::mission::EstablishSessionResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::mission::TickResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::mission::TickResponse_Status>() {
  return ::bosdyn::api::mission::TickResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::mission::StopResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::mission::StopResponse_Status>() {
  return ::bosdyn::api::mission::StopResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::mission::TeardownSessionResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::mission::TeardownSessionResponse_Status>() {
  return ::bosdyn::api::mission::TeardownSessionResponse_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fmission_2fremote_2eproto
