// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/data_buffer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fdata_5fbuffer_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fdata_5fbuffer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/parameter.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fdata_5fbuffer_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
namespace bosdyn {
namespace api {
class DataBlob;
struct DataBlobDefaultTypeInternal;
extern DataBlobDefaultTypeInternal _DataBlob_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class OperatorComment;
struct OperatorCommentDefaultTypeInternal;
extern OperatorCommentDefaultTypeInternal _OperatorComment_default_instance_;
class RecordDataBlobsRequest;
struct RecordDataBlobsRequestDefaultTypeInternal;
extern RecordDataBlobsRequestDefaultTypeInternal _RecordDataBlobsRequest_default_instance_;
class RecordDataBlobsResponse;
struct RecordDataBlobsResponseDefaultTypeInternal;
extern RecordDataBlobsResponseDefaultTypeInternal _RecordDataBlobsResponse_default_instance_;
class RecordDataBlobsResponse_Error;
struct RecordDataBlobsResponse_ErrorDefaultTypeInternal;
extern RecordDataBlobsResponse_ErrorDefaultTypeInternal _RecordDataBlobsResponse_Error_default_instance_;
class RecordEventsRequest;
struct RecordEventsRequestDefaultTypeInternal;
extern RecordEventsRequestDefaultTypeInternal _RecordEventsRequest_default_instance_;
class RecordEventsResponse;
struct RecordEventsResponseDefaultTypeInternal;
extern RecordEventsResponseDefaultTypeInternal _RecordEventsResponse_default_instance_;
class RecordEventsResponse_Error;
struct RecordEventsResponse_ErrorDefaultTypeInternal;
extern RecordEventsResponse_ErrorDefaultTypeInternal _RecordEventsResponse_Error_default_instance_;
class RecordOperatorCommentsRequest;
struct RecordOperatorCommentsRequestDefaultTypeInternal;
extern RecordOperatorCommentsRequestDefaultTypeInternal _RecordOperatorCommentsRequest_default_instance_;
class RecordOperatorCommentsResponse;
struct RecordOperatorCommentsResponseDefaultTypeInternal;
extern RecordOperatorCommentsResponseDefaultTypeInternal _RecordOperatorCommentsResponse_default_instance_;
class RecordOperatorCommentsResponse_Error;
struct RecordOperatorCommentsResponse_ErrorDefaultTypeInternal;
extern RecordOperatorCommentsResponse_ErrorDefaultTypeInternal _RecordOperatorCommentsResponse_Error_default_instance_;
class RecordSignalTicksRequest;
struct RecordSignalTicksRequestDefaultTypeInternal;
extern RecordSignalTicksRequestDefaultTypeInternal _RecordSignalTicksRequest_default_instance_;
class RecordSignalTicksResponse;
struct RecordSignalTicksResponseDefaultTypeInternal;
extern RecordSignalTicksResponseDefaultTypeInternal _RecordSignalTicksResponse_default_instance_;
class RecordSignalTicksResponse_Error;
struct RecordSignalTicksResponse_ErrorDefaultTypeInternal;
extern RecordSignalTicksResponse_ErrorDefaultTypeInternal _RecordSignalTicksResponse_Error_default_instance_;
class RecordTextMessagesRequest;
struct RecordTextMessagesRequestDefaultTypeInternal;
extern RecordTextMessagesRequestDefaultTypeInternal _RecordTextMessagesRequest_default_instance_;
class RecordTextMessagesResponse;
struct RecordTextMessagesResponseDefaultTypeInternal;
extern RecordTextMessagesResponseDefaultTypeInternal _RecordTextMessagesResponse_default_instance_;
class RecordTextMessagesResponse_Error;
struct RecordTextMessagesResponse_ErrorDefaultTypeInternal;
extern RecordTextMessagesResponse_ErrorDefaultTypeInternal _RecordTextMessagesResponse_Error_default_instance_;
class RegisterSignalSchemaRequest;
struct RegisterSignalSchemaRequestDefaultTypeInternal;
extern RegisterSignalSchemaRequestDefaultTypeInternal _RegisterSignalSchemaRequest_default_instance_;
class RegisterSignalSchemaResponse;
struct RegisterSignalSchemaResponseDefaultTypeInternal;
extern RegisterSignalSchemaResponseDefaultTypeInternal _RegisterSignalSchemaResponse_default_instance_;
class SignalSchema;
struct SignalSchemaDefaultTypeInternal;
extern SignalSchemaDefaultTypeInternal _SignalSchema_default_instance_;
class SignalSchemaId;
struct SignalSchemaIdDefaultTypeInternal;
extern SignalSchemaIdDefaultTypeInternal _SignalSchemaId_default_instance_;
class SignalSchema_Variable;
struct SignalSchema_VariableDefaultTypeInternal;
extern SignalSchema_VariableDefaultTypeInternal _SignalSchema_Variable_default_instance_;
class SignalTick;
struct SignalTickDefaultTypeInternal;
extern SignalTickDefaultTypeInternal _SignalTick_default_instance_;
class TextMessage;
struct TextMessageDefaultTypeInternal;
extern TextMessageDefaultTypeInternal _TextMessage_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::DataBlob* Arena::CreateMaybeMessage<::bosdyn::api::DataBlob>(Arena*);
template<> ::bosdyn::api::Event* Arena::CreateMaybeMessage<::bosdyn::api::Event>(Arena*);
template<> ::bosdyn::api::OperatorComment* Arena::CreateMaybeMessage<::bosdyn::api::OperatorComment>(Arena*);
template<> ::bosdyn::api::RecordDataBlobsRequest* Arena::CreateMaybeMessage<::bosdyn::api::RecordDataBlobsRequest>(Arena*);
template<> ::bosdyn::api::RecordDataBlobsResponse* Arena::CreateMaybeMessage<::bosdyn::api::RecordDataBlobsResponse>(Arena*);
template<> ::bosdyn::api::RecordDataBlobsResponse_Error* Arena::CreateMaybeMessage<::bosdyn::api::RecordDataBlobsResponse_Error>(Arena*);
template<> ::bosdyn::api::RecordEventsRequest* Arena::CreateMaybeMessage<::bosdyn::api::RecordEventsRequest>(Arena*);
template<> ::bosdyn::api::RecordEventsResponse* Arena::CreateMaybeMessage<::bosdyn::api::RecordEventsResponse>(Arena*);
template<> ::bosdyn::api::RecordEventsResponse_Error* Arena::CreateMaybeMessage<::bosdyn::api::RecordEventsResponse_Error>(Arena*);
template<> ::bosdyn::api::RecordOperatorCommentsRequest* Arena::CreateMaybeMessage<::bosdyn::api::RecordOperatorCommentsRequest>(Arena*);
template<> ::bosdyn::api::RecordOperatorCommentsResponse* Arena::CreateMaybeMessage<::bosdyn::api::RecordOperatorCommentsResponse>(Arena*);
template<> ::bosdyn::api::RecordOperatorCommentsResponse_Error* Arena::CreateMaybeMessage<::bosdyn::api::RecordOperatorCommentsResponse_Error>(Arena*);
template<> ::bosdyn::api::RecordSignalTicksRequest* Arena::CreateMaybeMessage<::bosdyn::api::RecordSignalTicksRequest>(Arena*);
template<> ::bosdyn::api::RecordSignalTicksResponse* Arena::CreateMaybeMessage<::bosdyn::api::RecordSignalTicksResponse>(Arena*);
template<> ::bosdyn::api::RecordSignalTicksResponse_Error* Arena::CreateMaybeMessage<::bosdyn::api::RecordSignalTicksResponse_Error>(Arena*);
template<> ::bosdyn::api::RecordTextMessagesRequest* Arena::CreateMaybeMessage<::bosdyn::api::RecordTextMessagesRequest>(Arena*);
template<> ::bosdyn::api::RecordTextMessagesResponse* Arena::CreateMaybeMessage<::bosdyn::api::RecordTextMessagesResponse>(Arena*);
template<> ::bosdyn::api::RecordTextMessagesResponse_Error* Arena::CreateMaybeMessage<::bosdyn::api::RecordTextMessagesResponse_Error>(Arena*);
template<> ::bosdyn::api::RegisterSignalSchemaRequest* Arena::CreateMaybeMessage<::bosdyn::api::RegisterSignalSchemaRequest>(Arena*);
template<> ::bosdyn::api::RegisterSignalSchemaResponse* Arena::CreateMaybeMessage<::bosdyn::api::RegisterSignalSchemaResponse>(Arena*);
template<> ::bosdyn::api::SignalSchema* Arena::CreateMaybeMessage<::bosdyn::api::SignalSchema>(Arena*);
template<> ::bosdyn::api::SignalSchemaId* Arena::CreateMaybeMessage<::bosdyn::api::SignalSchemaId>(Arena*);
template<> ::bosdyn::api::SignalSchema_Variable* Arena::CreateMaybeMessage<::bosdyn::api::SignalSchema_Variable>(Arena*);
template<> ::bosdyn::api::SignalTick* Arena::CreateMaybeMessage<::bosdyn::api::SignalTick>(Arena*);
template<> ::bosdyn::api::TextMessage* Arena::CreateMaybeMessage<::bosdyn::api::TextMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum TextMessage_Level : int {
  TextMessage_Level_LEVEL_UNKNOWN = 0,
  TextMessage_Level_LEVEL_DEBUG = 1,
  TextMessage_Level_LEVEL_INFO = 2,
  TextMessage_Level_LEVEL_WARN = 3,
  TextMessage_Level_LEVEL_ERROR = 4,
  TextMessage_Level_TextMessage_Level_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TextMessage_Level_TextMessage_Level_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TextMessage_Level_IsValid(int value);
constexpr TextMessage_Level TextMessage_Level_Level_MIN = TextMessage_Level_LEVEL_UNKNOWN;
constexpr TextMessage_Level TextMessage_Level_Level_MAX = TextMessage_Level_LEVEL_ERROR;
constexpr int TextMessage_Level_Level_ARRAYSIZE = TextMessage_Level_Level_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TextMessage_Level_descriptor();
template<typename T>
inline const std::string& TextMessage_Level_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TextMessage_Level>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TextMessage_Level_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TextMessage_Level_descriptor(), enum_t_value);
}
inline bool TextMessage_Level_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TextMessage_Level* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TextMessage_Level>(
    TextMessage_Level_descriptor(), name, value);
}
enum SignalSchema_Variable_Type : int {
  SignalSchema_Variable_Type_TYPE_UNKNOWN = 0,
  SignalSchema_Variable_Type_TYPE_INT8 = 1,
  SignalSchema_Variable_Type_TYPE_INT16 = 2,
  SignalSchema_Variable_Type_TYPE_INT32 = 3,
  SignalSchema_Variable_Type_TYPE_INT64 = 4,
  SignalSchema_Variable_Type_TYPE_UINT8 = 5,
  SignalSchema_Variable_Type_TYPE_UINT16 = 6,
  SignalSchema_Variable_Type_TYPE_UINT32 = 7,
  SignalSchema_Variable_Type_TYPE_UINT64 = 8,
  SignalSchema_Variable_Type_TYPE_FLOAT32 = 9,
  SignalSchema_Variable_Type_TYPE_FLOAT64 = 10,
  SignalSchema_Variable_Type_SignalSchema_Variable_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SignalSchema_Variable_Type_SignalSchema_Variable_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SignalSchema_Variable_Type_IsValid(int value);
constexpr SignalSchema_Variable_Type SignalSchema_Variable_Type_Type_MIN = SignalSchema_Variable_Type_TYPE_UNKNOWN;
constexpr SignalSchema_Variable_Type SignalSchema_Variable_Type_Type_MAX = SignalSchema_Variable_Type_TYPE_FLOAT64;
constexpr int SignalSchema_Variable_Type_Type_ARRAYSIZE = SignalSchema_Variable_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SignalSchema_Variable_Type_descriptor();
template<typename T>
inline const std::string& SignalSchema_Variable_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SignalSchema_Variable_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SignalSchema_Variable_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SignalSchema_Variable_Type_descriptor(), enum_t_value);
}
inline bool SignalSchema_Variable_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SignalSchema_Variable_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SignalSchema_Variable_Type>(
    SignalSchema_Variable_Type_descriptor(), name, value);
}
enum SignalTick_Encoding : int {
  SignalTick_Encoding_ENCODING_UNKNOWN = 0,
  SignalTick_Encoding_ENCODING_RAW = 1,
  SignalTick_Encoding_SignalTick_Encoding_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SignalTick_Encoding_SignalTick_Encoding_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SignalTick_Encoding_IsValid(int value);
constexpr SignalTick_Encoding SignalTick_Encoding_Encoding_MIN = SignalTick_Encoding_ENCODING_UNKNOWN;
constexpr SignalTick_Encoding SignalTick_Encoding_Encoding_MAX = SignalTick_Encoding_ENCODING_RAW;
constexpr int SignalTick_Encoding_Encoding_ARRAYSIZE = SignalTick_Encoding_Encoding_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SignalTick_Encoding_descriptor();
template<typename T>
inline const std::string& SignalTick_Encoding_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SignalTick_Encoding>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SignalTick_Encoding_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SignalTick_Encoding_descriptor(), enum_t_value);
}
inline bool SignalTick_Encoding_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SignalTick_Encoding* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SignalTick_Encoding>(
    SignalTick_Encoding_descriptor(), name, value);
}
enum Event_Level : int {
  Event_Level_LEVEL_UNSET = 0,
  Event_Level_LEVEL_LOW = 1,
  Event_Level_LEVEL_MEDIUM = 2,
  Event_Level_LEVEL_HIGH = 3,
  Event_Level_LEVEL_MISSION_CRITICAL = 4,
  Event_Level_LEVEL_SYSTEM_CRITICAL = 5,
  Event_Level_Event_Level_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Event_Level_Event_Level_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Event_Level_IsValid(int value);
constexpr Event_Level Event_Level_Level_MIN = Event_Level_LEVEL_UNSET;
constexpr Event_Level Event_Level_Level_MAX = Event_Level_LEVEL_SYSTEM_CRITICAL;
constexpr int Event_Level_Level_ARRAYSIZE = Event_Level_Level_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Event_Level_descriptor();
template<typename T>
inline const std::string& Event_Level_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Event_Level>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Event_Level_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Event_Level_descriptor(), enum_t_value);
}
inline bool Event_Level_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Event_Level* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Event_Level>(
    Event_Level_descriptor(), name, value);
}
enum Event_LogPreserveHint : int {
  Event_LogPreserveHint_LOG_PRESERVE_HINT_UNSET = 0,
  Event_LogPreserveHint_LOG_PRESERVE_HINT_NORMAL = 1,
  Event_LogPreserveHint_LOG_PRESERVE_HINT_PRESERVE = 2,
  Event_LogPreserveHint_Event_LogPreserveHint_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Event_LogPreserveHint_Event_LogPreserveHint_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Event_LogPreserveHint_IsValid(int value);
constexpr Event_LogPreserveHint Event_LogPreserveHint_LogPreserveHint_MIN = Event_LogPreserveHint_LOG_PRESERVE_HINT_UNSET;
constexpr Event_LogPreserveHint Event_LogPreserveHint_LogPreserveHint_MAX = Event_LogPreserveHint_LOG_PRESERVE_HINT_PRESERVE;
constexpr int Event_LogPreserveHint_LogPreserveHint_ARRAYSIZE = Event_LogPreserveHint_LogPreserveHint_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Event_LogPreserveHint_descriptor();
template<typename T>
inline const std::string& Event_LogPreserveHint_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Event_LogPreserveHint>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Event_LogPreserveHint_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Event_LogPreserveHint_descriptor(), enum_t_value);
}
inline bool Event_LogPreserveHint_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Event_LogPreserveHint* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Event_LogPreserveHint>(
    Event_LogPreserveHint_descriptor(), name, value);
}
enum RecordTextMessagesResponse_Error_Type : int {
  RecordTextMessagesResponse_Error_Type_NONE = 0,
  RecordTextMessagesResponse_Error_Type_CLIENT_ERROR = 1,
  RecordTextMessagesResponse_Error_Type_SERVER_ERROR = 2,
  RecordTextMessagesResponse_Error_Type_RecordTextMessagesResponse_Error_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RecordTextMessagesResponse_Error_Type_RecordTextMessagesResponse_Error_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RecordTextMessagesResponse_Error_Type_IsValid(int value);
constexpr RecordTextMessagesResponse_Error_Type RecordTextMessagesResponse_Error_Type_Type_MIN = RecordTextMessagesResponse_Error_Type_NONE;
constexpr RecordTextMessagesResponse_Error_Type RecordTextMessagesResponse_Error_Type_Type_MAX = RecordTextMessagesResponse_Error_Type_SERVER_ERROR;
constexpr int RecordTextMessagesResponse_Error_Type_Type_ARRAYSIZE = RecordTextMessagesResponse_Error_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecordTextMessagesResponse_Error_Type_descriptor();
template<typename T>
inline const std::string& RecordTextMessagesResponse_Error_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RecordTextMessagesResponse_Error_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RecordTextMessagesResponse_Error_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RecordTextMessagesResponse_Error_Type_descriptor(), enum_t_value);
}
inline bool RecordTextMessagesResponse_Error_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RecordTextMessagesResponse_Error_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecordTextMessagesResponse_Error_Type>(
    RecordTextMessagesResponse_Error_Type_descriptor(), name, value);
}
enum RecordOperatorCommentsResponse_Error_Type : int {
  RecordOperatorCommentsResponse_Error_Type_NONE = 0,
  RecordOperatorCommentsResponse_Error_Type_CLIENT_ERROR = 1,
  RecordOperatorCommentsResponse_Error_Type_SERVER_ERROR = 2,
  RecordOperatorCommentsResponse_Error_Type_RecordOperatorCommentsResponse_Error_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RecordOperatorCommentsResponse_Error_Type_RecordOperatorCommentsResponse_Error_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RecordOperatorCommentsResponse_Error_Type_IsValid(int value);
constexpr RecordOperatorCommentsResponse_Error_Type RecordOperatorCommentsResponse_Error_Type_Type_MIN = RecordOperatorCommentsResponse_Error_Type_NONE;
constexpr RecordOperatorCommentsResponse_Error_Type RecordOperatorCommentsResponse_Error_Type_Type_MAX = RecordOperatorCommentsResponse_Error_Type_SERVER_ERROR;
constexpr int RecordOperatorCommentsResponse_Error_Type_Type_ARRAYSIZE = RecordOperatorCommentsResponse_Error_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecordOperatorCommentsResponse_Error_Type_descriptor();
template<typename T>
inline const std::string& RecordOperatorCommentsResponse_Error_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RecordOperatorCommentsResponse_Error_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RecordOperatorCommentsResponse_Error_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RecordOperatorCommentsResponse_Error_Type_descriptor(), enum_t_value);
}
inline bool RecordOperatorCommentsResponse_Error_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RecordOperatorCommentsResponse_Error_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecordOperatorCommentsResponse_Error_Type>(
    RecordOperatorCommentsResponse_Error_Type_descriptor(), name, value);
}
enum RecordDataBlobsResponse_Error_Type : int {
  RecordDataBlobsResponse_Error_Type_NONE = 0,
  RecordDataBlobsResponse_Error_Type_CLIENT_ERROR = 1,
  RecordDataBlobsResponse_Error_Type_SERVER_ERROR = 2,
  RecordDataBlobsResponse_Error_Type_RecordDataBlobsResponse_Error_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RecordDataBlobsResponse_Error_Type_RecordDataBlobsResponse_Error_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RecordDataBlobsResponse_Error_Type_IsValid(int value);
constexpr RecordDataBlobsResponse_Error_Type RecordDataBlobsResponse_Error_Type_Type_MIN = RecordDataBlobsResponse_Error_Type_NONE;
constexpr RecordDataBlobsResponse_Error_Type RecordDataBlobsResponse_Error_Type_Type_MAX = RecordDataBlobsResponse_Error_Type_SERVER_ERROR;
constexpr int RecordDataBlobsResponse_Error_Type_Type_ARRAYSIZE = RecordDataBlobsResponse_Error_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecordDataBlobsResponse_Error_Type_descriptor();
template<typename T>
inline const std::string& RecordDataBlobsResponse_Error_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RecordDataBlobsResponse_Error_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RecordDataBlobsResponse_Error_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RecordDataBlobsResponse_Error_Type_descriptor(), enum_t_value);
}
inline bool RecordDataBlobsResponse_Error_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RecordDataBlobsResponse_Error_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecordDataBlobsResponse_Error_Type>(
    RecordDataBlobsResponse_Error_Type_descriptor(), name, value);
}
enum RecordSignalTicksResponse_Error_Type : int {
  RecordSignalTicksResponse_Error_Type_NONE = 0,
  RecordSignalTicksResponse_Error_Type_CLIENT_ERROR = 1,
  RecordSignalTicksResponse_Error_Type_SERVER_ERROR = 2,
  RecordSignalTicksResponse_Error_Type_INVALID_SCHEMA_ID = 3,
  RecordSignalTicksResponse_Error_Type_RecordSignalTicksResponse_Error_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RecordSignalTicksResponse_Error_Type_RecordSignalTicksResponse_Error_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RecordSignalTicksResponse_Error_Type_IsValid(int value);
constexpr RecordSignalTicksResponse_Error_Type RecordSignalTicksResponse_Error_Type_Type_MIN = RecordSignalTicksResponse_Error_Type_NONE;
constexpr RecordSignalTicksResponse_Error_Type RecordSignalTicksResponse_Error_Type_Type_MAX = RecordSignalTicksResponse_Error_Type_INVALID_SCHEMA_ID;
constexpr int RecordSignalTicksResponse_Error_Type_Type_ARRAYSIZE = RecordSignalTicksResponse_Error_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecordSignalTicksResponse_Error_Type_descriptor();
template<typename T>
inline const std::string& RecordSignalTicksResponse_Error_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RecordSignalTicksResponse_Error_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RecordSignalTicksResponse_Error_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RecordSignalTicksResponse_Error_Type_descriptor(), enum_t_value);
}
inline bool RecordSignalTicksResponse_Error_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RecordSignalTicksResponse_Error_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecordSignalTicksResponse_Error_Type>(
    RecordSignalTicksResponse_Error_Type_descriptor(), name, value);
}
enum RecordEventsResponse_Error_Type : int {
  RecordEventsResponse_Error_Type_NONE = 0,
  RecordEventsResponse_Error_Type_CLIENT_ERROR = 1,
  RecordEventsResponse_Error_Type_SERVER_ERROR = 2,
  RecordEventsResponse_Error_Type_RecordEventsResponse_Error_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RecordEventsResponse_Error_Type_RecordEventsResponse_Error_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RecordEventsResponse_Error_Type_IsValid(int value);
constexpr RecordEventsResponse_Error_Type RecordEventsResponse_Error_Type_Type_MIN = RecordEventsResponse_Error_Type_NONE;
constexpr RecordEventsResponse_Error_Type RecordEventsResponse_Error_Type_Type_MAX = RecordEventsResponse_Error_Type_SERVER_ERROR;
constexpr int RecordEventsResponse_Error_Type_Type_ARRAYSIZE = RecordEventsResponse_Error_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecordEventsResponse_Error_Type_descriptor();
template<typename T>
inline const std::string& RecordEventsResponse_Error_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RecordEventsResponse_Error_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RecordEventsResponse_Error_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RecordEventsResponse_Error_Type_descriptor(), enum_t_value);
}
inline bool RecordEventsResponse_Error_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RecordEventsResponse_Error_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecordEventsResponse_Error_Type>(
    RecordEventsResponse_Error_Type_descriptor(), name, value);
}
// ===================================================================

class RecordTextMessagesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RecordTextMessagesRequest) */ {
 public:
  inline RecordTextMessagesRequest() : RecordTextMessagesRequest(nullptr) {}
  ~RecordTextMessagesRequest() override;
  explicit PROTOBUF_CONSTEXPR RecordTextMessagesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordTextMessagesRequest(const RecordTextMessagesRequest& from);
  RecordTextMessagesRequest(RecordTextMessagesRequest&& from) noexcept
    : RecordTextMessagesRequest() {
    *this = ::std::move(from);
  }

  inline RecordTextMessagesRequest& operator=(const RecordTextMessagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordTextMessagesRequest& operator=(RecordTextMessagesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordTextMessagesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordTextMessagesRequest* internal_default_instance() {
    return reinterpret_cast<const RecordTextMessagesRequest*>(
               &_RecordTextMessagesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RecordTextMessagesRequest& a, RecordTextMessagesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordTextMessagesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordTextMessagesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordTextMessagesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordTextMessagesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordTextMessagesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordTextMessagesRequest& from) {
    RecordTextMessagesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordTextMessagesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RecordTextMessagesRequest";
  }
  protected:
  explicit RecordTextMessagesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextMessagesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.TextMessage text_messages = 2;
  int text_messages_size() const;
  private:
  int _internal_text_messages_size() const;
  public:
  void clear_text_messages();
  ::bosdyn::api::TextMessage* mutable_text_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::TextMessage >*
      mutable_text_messages();
  private:
  const ::bosdyn::api::TextMessage& _internal_text_messages(int index) const;
  ::bosdyn::api::TextMessage* _internal_add_text_messages();
  public:
  const ::bosdyn::api::TextMessage& text_messages(int index) const;
  ::bosdyn::api::TextMessage* add_text_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::TextMessage >&
      text_messages() const;

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RecordTextMessagesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::TextMessage > text_messages_;
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class RecordOperatorCommentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RecordOperatorCommentsRequest) */ {
 public:
  inline RecordOperatorCommentsRequest() : RecordOperatorCommentsRequest(nullptr) {}
  ~RecordOperatorCommentsRequest() override;
  explicit PROTOBUF_CONSTEXPR RecordOperatorCommentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordOperatorCommentsRequest(const RecordOperatorCommentsRequest& from);
  RecordOperatorCommentsRequest(RecordOperatorCommentsRequest&& from) noexcept
    : RecordOperatorCommentsRequest() {
    *this = ::std::move(from);
  }

  inline RecordOperatorCommentsRequest& operator=(const RecordOperatorCommentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordOperatorCommentsRequest& operator=(RecordOperatorCommentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordOperatorCommentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordOperatorCommentsRequest* internal_default_instance() {
    return reinterpret_cast<const RecordOperatorCommentsRequest*>(
               &_RecordOperatorCommentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RecordOperatorCommentsRequest& a, RecordOperatorCommentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordOperatorCommentsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordOperatorCommentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordOperatorCommentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordOperatorCommentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordOperatorCommentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordOperatorCommentsRequest& from) {
    RecordOperatorCommentsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordOperatorCommentsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RecordOperatorCommentsRequest";
  }
  protected:
  explicit RecordOperatorCommentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperatorCommentsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.OperatorComment operator_comments = 2;
  int operator_comments_size() const;
  private:
  int _internal_operator_comments_size() const;
  public:
  void clear_operator_comments();
  ::bosdyn::api::OperatorComment* mutable_operator_comments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::OperatorComment >*
      mutable_operator_comments();
  private:
  const ::bosdyn::api::OperatorComment& _internal_operator_comments(int index) const;
  ::bosdyn::api::OperatorComment* _internal_add_operator_comments();
  public:
  const ::bosdyn::api::OperatorComment& operator_comments(int index) const;
  ::bosdyn::api::OperatorComment* add_operator_comments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::OperatorComment >&
      operator_comments() const;

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RecordOperatorCommentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::OperatorComment > operator_comments_;
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class RecordDataBlobsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RecordDataBlobsRequest) */ {
 public:
  inline RecordDataBlobsRequest() : RecordDataBlobsRequest(nullptr) {}
  ~RecordDataBlobsRequest() override;
  explicit PROTOBUF_CONSTEXPR RecordDataBlobsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordDataBlobsRequest(const RecordDataBlobsRequest& from);
  RecordDataBlobsRequest(RecordDataBlobsRequest&& from) noexcept
    : RecordDataBlobsRequest() {
    *this = ::std::move(from);
  }

  inline RecordDataBlobsRequest& operator=(const RecordDataBlobsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordDataBlobsRequest& operator=(RecordDataBlobsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordDataBlobsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordDataBlobsRequest* internal_default_instance() {
    return reinterpret_cast<const RecordDataBlobsRequest*>(
               &_RecordDataBlobsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RecordDataBlobsRequest& a, RecordDataBlobsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordDataBlobsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordDataBlobsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordDataBlobsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordDataBlobsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordDataBlobsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordDataBlobsRequest& from) {
    RecordDataBlobsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordDataBlobsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RecordDataBlobsRequest";
  }
  protected:
  explicit RecordDataBlobsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobDataFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kSyncFieldNumber = 3,
  };
  // repeated .bosdyn.api.DataBlob blob_data = 2;
  int blob_data_size() const;
  private:
  int _internal_blob_data_size() const;
  public:
  void clear_blob_data();
  ::bosdyn::api::DataBlob* mutable_blob_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataBlob >*
      mutable_blob_data();
  private:
  const ::bosdyn::api::DataBlob& _internal_blob_data(int index) const;
  ::bosdyn::api::DataBlob* _internal_add_blob_data();
  public:
  const ::bosdyn::api::DataBlob& blob_data(int index) const;
  ::bosdyn::api::DataBlob* add_blob_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataBlob >&
      blob_data() const;

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // bool sync = 3;
  void clear_sync();
  bool sync() const;
  void set_sync(bool value);
  private:
  bool _internal_sync() const;
  void _internal_set_sync(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.RecordDataBlobsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataBlob > blob_data_;
    ::bosdyn::api::RequestHeader* header_;
    bool sync_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class RecordSignalTicksRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RecordSignalTicksRequest) */ {
 public:
  inline RecordSignalTicksRequest() : RecordSignalTicksRequest(nullptr) {}
  ~RecordSignalTicksRequest() override;
  explicit PROTOBUF_CONSTEXPR RecordSignalTicksRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordSignalTicksRequest(const RecordSignalTicksRequest& from);
  RecordSignalTicksRequest(RecordSignalTicksRequest&& from) noexcept
    : RecordSignalTicksRequest() {
    *this = ::std::move(from);
  }

  inline RecordSignalTicksRequest& operator=(const RecordSignalTicksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordSignalTicksRequest& operator=(RecordSignalTicksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordSignalTicksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordSignalTicksRequest* internal_default_instance() {
    return reinterpret_cast<const RecordSignalTicksRequest*>(
               &_RecordSignalTicksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RecordSignalTicksRequest& a, RecordSignalTicksRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordSignalTicksRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordSignalTicksRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordSignalTicksRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordSignalTicksRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordSignalTicksRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordSignalTicksRequest& from) {
    RecordSignalTicksRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordSignalTicksRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RecordSignalTicksRequest";
  }
  protected:
  explicit RecordSignalTicksRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTickDataFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.SignalTick tick_data = 2;
  int tick_data_size() const;
  private:
  int _internal_tick_data_size() const;
  public:
  void clear_tick_data();
  ::bosdyn::api::SignalTick* mutable_tick_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SignalTick >*
      mutable_tick_data();
  private:
  const ::bosdyn::api::SignalTick& _internal_tick_data(int index) const;
  ::bosdyn::api::SignalTick* _internal_add_tick_data();
  public:
  const ::bosdyn::api::SignalTick& tick_data(int index) const;
  ::bosdyn::api::SignalTick* add_tick_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SignalTick >&
      tick_data() const;

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RecordSignalTicksRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SignalTick > tick_data_;
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class RecordEventsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RecordEventsRequest) */ {
 public:
  inline RecordEventsRequest() : RecordEventsRequest(nullptr) {}
  ~RecordEventsRequest() override;
  explicit PROTOBUF_CONSTEXPR RecordEventsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordEventsRequest(const RecordEventsRequest& from);
  RecordEventsRequest(RecordEventsRequest&& from) noexcept
    : RecordEventsRequest() {
    *this = ::std::move(from);
  }

  inline RecordEventsRequest& operator=(const RecordEventsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordEventsRequest& operator=(RecordEventsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordEventsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordEventsRequest* internal_default_instance() {
    return reinterpret_cast<const RecordEventsRequest*>(
               &_RecordEventsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RecordEventsRequest& a, RecordEventsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordEventsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordEventsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordEventsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordEventsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordEventsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordEventsRequest& from) {
    RecordEventsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordEventsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RecordEventsRequest";
  }
  protected:
  explicit RecordEventsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.Event events = 2;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::bosdyn::api::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Event >*
      mutable_events();
  private:
  const ::bosdyn::api::Event& _internal_events(int index) const;
  ::bosdyn::api::Event* _internal_add_events();
  public:
  const ::bosdyn::api::Event& events(int index) const;
  ::bosdyn::api::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Event >&
      events() const;

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RecordEventsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Event > events_;
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class TextMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.TextMessage) */ {
 public:
  inline TextMessage() : TextMessage(nullptr) {}
  ~TextMessage() override;
  explicit PROTOBUF_CONSTEXPR TextMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextMessage(const TextMessage& from);
  TextMessage(TextMessage&& from) noexcept
    : TextMessage() {
    *this = ::std::move(from);
  }

  inline TextMessage& operator=(const TextMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextMessage& operator=(TextMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextMessage* internal_default_instance() {
    return reinterpret_cast<const TextMessage*>(
               &_TextMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TextMessage& a, TextMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TextMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TextMessage& from) {
    TextMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.TextMessage";
  }
  protected:
  explicit TextMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TextMessage_Level Level;
  static constexpr Level LEVEL_UNKNOWN =
    TextMessage_Level_LEVEL_UNKNOWN;
  static constexpr Level LEVEL_DEBUG =
    TextMessage_Level_LEVEL_DEBUG;
  static constexpr Level LEVEL_INFO =
    TextMessage_Level_LEVEL_INFO;
  static constexpr Level LEVEL_WARN =
    TextMessage_Level_LEVEL_WARN;
  static constexpr Level LEVEL_ERROR =
    TextMessage_Level_LEVEL_ERROR;
  static inline bool Level_IsValid(int value) {
    return TextMessage_Level_IsValid(value);
  }
  static constexpr Level Level_MIN =
    TextMessage_Level_Level_MIN;
  static constexpr Level Level_MAX =
    TextMessage_Level_Level_MAX;
  static constexpr int Level_ARRAYSIZE =
    TextMessage_Level_Level_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Level_descriptor() {
    return TextMessage_Level_descriptor();
  }
  template<typename T>
  static inline const std::string& Level_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Level>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Level_Name.");
    return TextMessage_Level_Name(enum_t_value);
  }
  static inline bool Level_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Level* value) {
    return TextMessage_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kSourceFieldNumber = 3,
    kTagFieldNumber = 5,
    kFilenameFieldNumber = 6,
    kTimestampFieldNumber = 2,
    kLevelFieldNumber = 4,
    kLineNumberFieldNumber = 7,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string source = 3;
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // string tag = 5;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // string filename = 6;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .bosdyn.api.TextMessage.Level level = 4;
  void clear_level();
  ::bosdyn::api::TextMessage_Level level() const;
  void set_level(::bosdyn::api::TextMessage_Level value);
  private:
  ::bosdyn::api::TextMessage_Level _internal_level() const;
  void _internal_set_level(::bosdyn::api::TextMessage_Level value);
  public:

  // int32 line_number = 7;
  void clear_line_number();
  int32_t line_number() const;
  void set_line_number(int32_t value);
  private:
  int32_t _internal_line_number() const;
  void _internal_set_line_number(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.TextMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    int level_;
    int32_t line_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class OperatorComment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.OperatorComment) */ {
 public:
  inline OperatorComment() : OperatorComment(nullptr) {}
  ~OperatorComment() override;
  explicit PROTOBUF_CONSTEXPR OperatorComment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperatorComment(const OperatorComment& from);
  OperatorComment(OperatorComment&& from) noexcept
    : OperatorComment() {
    *this = ::std::move(from);
  }

  inline OperatorComment& operator=(const OperatorComment& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperatorComment& operator=(OperatorComment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperatorComment& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperatorComment* internal_default_instance() {
    return reinterpret_cast<const OperatorComment*>(
               &_OperatorComment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OperatorComment& a, OperatorComment& b) {
    a.Swap(&b);
  }
  inline void Swap(OperatorComment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperatorComment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperatorComment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperatorComment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperatorComment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperatorComment& from) {
    OperatorComment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperatorComment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.OperatorComment";
  }
  protected:
  explicit OperatorComment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:bosdyn.api.OperatorComment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class DataBlob final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DataBlob) */ {
 public:
  inline DataBlob() : DataBlob(nullptr) {}
  ~DataBlob() override;
  explicit PROTOBUF_CONSTEXPR DataBlob(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataBlob(const DataBlob& from);
  DataBlob(DataBlob&& from) noexcept
    : DataBlob() {
    *this = ::std::move(from);
  }

  inline DataBlob& operator=(const DataBlob& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataBlob& operator=(DataBlob&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataBlob& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataBlob* internal_default_instance() {
    return reinterpret_cast<const DataBlob*>(
               &_DataBlob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DataBlob& a, DataBlob& b) {
    a.Swap(&b);
  }
  inline void Swap(DataBlob* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataBlob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataBlob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataBlob>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataBlob& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataBlob& from) {
    DataBlob::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataBlob* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DataBlob";
  }
  protected:
  explicit DataBlob(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelFieldNumber = 2,
    kTypeIdFieldNumber = 3,
    kDataFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // string channel = 2;
  void clear_channel();
  const std::string& channel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_channel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_channel();
  PROTOBUF_NODISCARD std::string* release_channel();
  void set_allocated_channel(std::string* channel);
  private:
  const std::string& _internal_channel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel(const std::string& value);
  std::string* _internal_mutable_channel();
  public:

  // string type_id = 3;
  void clear_type_id();
  const std::string& type_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type_id();
  PROTOBUF_NODISCARD std::string* release_type_id();
  void set_allocated_type_id(std::string* type_id);
  private:
  const std::string& _internal_type_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type_id(const std::string& value);
  std::string* _internal_mutable_type_id();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:bosdyn.api.DataBlob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class SignalSchema_Variable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SignalSchema.Variable) */ {
 public:
  inline SignalSchema_Variable() : SignalSchema_Variable(nullptr) {}
  ~SignalSchema_Variable() override;
  explicit PROTOBUF_CONSTEXPR SignalSchema_Variable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalSchema_Variable(const SignalSchema_Variable& from);
  SignalSchema_Variable(SignalSchema_Variable&& from) noexcept
    : SignalSchema_Variable() {
    *this = ::std::move(from);
  }

  inline SignalSchema_Variable& operator=(const SignalSchema_Variable& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalSchema_Variable& operator=(SignalSchema_Variable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalSchema_Variable& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalSchema_Variable* internal_default_instance() {
    return reinterpret_cast<const SignalSchema_Variable*>(
               &_SignalSchema_Variable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SignalSchema_Variable& a, SignalSchema_Variable& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalSchema_Variable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalSchema_Variable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalSchema_Variable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalSchema_Variable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalSchema_Variable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignalSchema_Variable& from) {
    SignalSchema_Variable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalSchema_Variable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SignalSchema.Variable";
  }
  protected:
  explicit SignalSchema_Variable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SignalSchema_Variable_Type Type;
  static constexpr Type TYPE_UNKNOWN =
    SignalSchema_Variable_Type_TYPE_UNKNOWN;
  static constexpr Type TYPE_INT8 =
    SignalSchema_Variable_Type_TYPE_INT8;
  static constexpr Type TYPE_INT16 =
    SignalSchema_Variable_Type_TYPE_INT16;
  static constexpr Type TYPE_INT32 =
    SignalSchema_Variable_Type_TYPE_INT32;
  static constexpr Type TYPE_INT64 =
    SignalSchema_Variable_Type_TYPE_INT64;
  static constexpr Type TYPE_UINT8 =
    SignalSchema_Variable_Type_TYPE_UINT8;
  static constexpr Type TYPE_UINT16 =
    SignalSchema_Variable_Type_TYPE_UINT16;
  static constexpr Type TYPE_UINT32 =
    SignalSchema_Variable_Type_TYPE_UINT32;
  static constexpr Type TYPE_UINT64 =
    SignalSchema_Variable_Type_TYPE_UINT64;
  static constexpr Type TYPE_FLOAT32 =
    SignalSchema_Variable_Type_TYPE_FLOAT32;
  static constexpr Type TYPE_FLOAT64 =
    SignalSchema_Variable_Type_TYPE_FLOAT64;
  static inline bool Type_IsValid(int value) {
    return SignalSchema_Variable_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    SignalSchema_Variable_Type_Type_MIN;
  static constexpr Type Type_MAX =
    SignalSchema_Variable_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    SignalSchema_Variable_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return SignalSchema_Variable_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return SignalSchema_Variable_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return SignalSchema_Variable_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kIsTimeFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .bosdyn.api.SignalSchema.Variable.Type type = 2;
  void clear_type();
  ::bosdyn::api::SignalSchema_Variable_Type type() const;
  void set_type(::bosdyn::api::SignalSchema_Variable_Type value);
  private:
  ::bosdyn::api::SignalSchema_Variable_Type _internal_type() const;
  void _internal_set_type(::bosdyn::api::SignalSchema_Variable_Type value);
  public:

  // bool is_time = 3;
  void clear_is_time();
  bool is_time() const;
  void set_is_time(bool value);
  private:
  bool _internal_is_time() const;
  void _internal_set_is_time(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SignalSchema.Variable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int type_;
    bool is_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class SignalSchema final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SignalSchema) */ {
 public:
  inline SignalSchema() : SignalSchema(nullptr) {}
  ~SignalSchema() override;
  explicit PROTOBUF_CONSTEXPR SignalSchema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalSchema(const SignalSchema& from);
  SignalSchema(SignalSchema&& from) noexcept
    : SignalSchema() {
    *this = ::std::move(from);
  }

  inline SignalSchema& operator=(const SignalSchema& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalSchema& operator=(SignalSchema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalSchema& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalSchema* internal_default_instance() {
    return reinterpret_cast<const SignalSchema*>(
               &_SignalSchema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SignalSchema& a, SignalSchema& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalSchema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalSchema* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalSchema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalSchema>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalSchema& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignalSchema& from) {
    SignalSchema::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalSchema* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SignalSchema";
  }
  protected:
  explicit SignalSchema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SignalSchema_Variable Variable;

  // accessors -------------------------------------------------------

  enum : int {
    kVarsFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
  };
  // repeated .bosdyn.api.SignalSchema.Variable vars = 1;
  int vars_size() const;
  private:
  int _internal_vars_size() const;
  public:
  void clear_vars();
  ::bosdyn::api::SignalSchema_Variable* mutable_vars(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SignalSchema_Variable >*
      mutable_vars();
  private:
  const ::bosdyn::api::SignalSchema_Variable& _internal_vars(int index) const;
  ::bosdyn::api::SignalSchema_Variable* _internal_add_vars();
  public:
  const ::bosdyn::api::SignalSchema_Variable& vars(int index) const;
  ::bosdyn::api::SignalSchema_Variable* add_vars();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SignalSchema_Variable >&
      vars() const;

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SignalSchema)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SignalSchema_Variable > vars_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class SignalSchemaId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SignalSchemaId) */ {
 public:
  inline SignalSchemaId() : SignalSchemaId(nullptr) {}
  ~SignalSchemaId() override;
  explicit PROTOBUF_CONSTEXPR SignalSchemaId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalSchemaId(const SignalSchemaId& from);
  SignalSchemaId(SignalSchemaId&& from) noexcept
    : SignalSchemaId() {
    *this = ::std::move(from);
  }

  inline SignalSchemaId& operator=(const SignalSchemaId& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalSchemaId& operator=(SignalSchemaId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalSchemaId& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalSchemaId* internal_default_instance() {
    return reinterpret_cast<const SignalSchemaId*>(
               &_SignalSchemaId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SignalSchemaId& a, SignalSchemaId& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalSchemaId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalSchemaId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalSchemaId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalSchemaId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalSchemaId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignalSchemaId& from) {
    SignalSchemaId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalSchemaId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SignalSchemaId";
  }
  protected:
  explicit SignalSchemaId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaFieldNumber = 2,
    kSchemaIdFieldNumber = 1,
  };
  // .bosdyn.api.SignalSchema schema = 2;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::bosdyn::api::SignalSchema& schema() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SignalSchema* release_schema();
  ::bosdyn::api::SignalSchema* mutable_schema();
  void set_allocated_schema(::bosdyn::api::SignalSchema* schema);
  private:
  const ::bosdyn::api::SignalSchema& _internal_schema() const;
  ::bosdyn::api::SignalSchema* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::bosdyn::api::SignalSchema* schema);
  ::bosdyn::api::SignalSchema* unsafe_arena_release_schema();

  // uint64 schema_id = 1;
  void clear_schema_id();
  uint64_t schema_id() const;
  void set_schema_id(uint64_t value);
  private:
  uint64_t _internal_schema_id() const;
  void _internal_set_schema_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SignalSchemaId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::SignalSchema* schema_;
    uint64_t schema_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class SignalTick final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SignalTick) */ {
 public:
  inline SignalTick() : SignalTick(nullptr) {}
  ~SignalTick() override;
  explicit PROTOBUF_CONSTEXPR SignalTick(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalTick(const SignalTick& from);
  SignalTick(SignalTick&& from) noexcept
    : SignalTick() {
    *this = ::std::move(from);
  }

  inline SignalTick& operator=(const SignalTick& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalTick& operator=(SignalTick&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalTick& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalTick* internal_default_instance() {
    return reinterpret_cast<const SignalTick*>(
               &_SignalTick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SignalTick& a, SignalTick& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalTick* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalTick* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalTick* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalTick>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalTick& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignalTick& from) {
    SignalTick::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalTick* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SignalTick";
  }
  protected:
  explicit SignalTick(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SignalTick_Encoding Encoding;
  static constexpr Encoding ENCODING_UNKNOWN =
    SignalTick_Encoding_ENCODING_UNKNOWN;
  static constexpr Encoding ENCODING_RAW =
    SignalTick_Encoding_ENCODING_RAW;
  static inline bool Encoding_IsValid(int value) {
    return SignalTick_Encoding_IsValid(value);
  }
  static constexpr Encoding Encoding_MIN =
    SignalTick_Encoding_Encoding_MIN;
  static constexpr Encoding Encoding_MAX =
    SignalTick_Encoding_Encoding_MAX;
  static constexpr int Encoding_ARRAYSIZE =
    SignalTick_Encoding_Encoding_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Encoding_descriptor() {
    return SignalTick_Encoding_descriptor();
  }
  template<typename T>
  static inline const std::string& Encoding_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Encoding>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Encoding_Name.");
    return SignalTick_Encoding_Name(enum_t_value);
  }
  static inline bool Encoding_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Encoding* value) {
    return SignalTick_Encoding_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 3,
    kDataFieldNumber = 6,
    kTimestampFieldNumber = 2,
    kSequenceIdFieldNumber = 1,
    kSchemaIdFieldNumber = 4,
    kEncodingFieldNumber = 5,
  };
  // string source = 3;
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // bytes data = 6;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // int64 sequence_id = 1;
  void clear_sequence_id();
  int64_t sequence_id() const;
  void set_sequence_id(int64_t value);
  private:
  int64_t _internal_sequence_id() const;
  void _internal_set_sequence_id(int64_t value);
  public:

  // uint64 schema_id = 4;
  void clear_schema_id();
  uint64_t schema_id() const;
  void set_schema_id(uint64_t value);
  private:
  uint64_t _internal_schema_id() const;
  void _internal_set_schema_id(uint64_t value);
  public:

  // .bosdyn.api.SignalTick.Encoding encoding = 5;
  void clear_encoding();
  ::bosdyn::api::SignalTick_Encoding encoding() const;
  void set_encoding(::bosdyn::api::SignalTick_Encoding value);
  private:
  ::bosdyn::api::SignalTick_Encoding _internal_encoding() const;
  void _internal_set_encoding(::bosdyn::api::SignalTick_Encoding value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SignalTick)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    int64_t sequence_id_;
    uint64_t schema_id_;
    int encoding_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit PROTOBUF_CONSTEXPR Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Event& from) {
    Event::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Event_Level Level;
  static constexpr Level LEVEL_UNSET =
    Event_Level_LEVEL_UNSET;
  static constexpr Level LEVEL_LOW =
    Event_Level_LEVEL_LOW;
  static constexpr Level LEVEL_MEDIUM =
    Event_Level_LEVEL_MEDIUM;
  static constexpr Level LEVEL_HIGH =
    Event_Level_LEVEL_HIGH;
  static constexpr Level LEVEL_MISSION_CRITICAL =
    Event_Level_LEVEL_MISSION_CRITICAL;
  static constexpr Level LEVEL_SYSTEM_CRITICAL =
    Event_Level_LEVEL_SYSTEM_CRITICAL;
  static inline bool Level_IsValid(int value) {
    return Event_Level_IsValid(value);
  }
  static constexpr Level Level_MIN =
    Event_Level_Level_MIN;
  static constexpr Level Level_MAX =
    Event_Level_Level_MAX;
  static constexpr int Level_ARRAYSIZE =
    Event_Level_Level_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Level_descriptor() {
    return Event_Level_descriptor();
  }
  template<typename T>
  static inline const std::string& Level_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Level>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Level_Name.");
    return Event_Level_Name(enum_t_value);
  }
  static inline bool Level_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Level* value) {
    return Event_Level_Parse(name, value);
  }

  typedef Event_LogPreserveHint LogPreserveHint;
  static constexpr LogPreserveHint LOG_PRESERVE_HINT_UNSET =
    Event_LogPreserveHint_LOG_PRESERVE_HINT_UNSET;
  static constexpr LogPreserveHint LOG_PRESERVE_HINT_NORMAL =
    Event_LogPreserveHint_LOG_PRESERVE_HINT_NORMAL;
  static constexpr LogPreserveHint LOG_PRESERVE_HINT_PRESERVE =
    Event_LogPreserveHint_LOG_PRESERVE_HINT_PRESERVE;
  static inline bool LogPreserveHint_IsValid(int value) {
    return Event_LogPreserveHint_IsValid(value);
  }
  static constexpr LogPreserveHint LogPreserveHint_MIN =
    Event_LogPreserveHint_LogPreserveHint_MIN;
  static constexpr LogPreserveHint LogPreserveHint_MAX =
    Event_LogPreserveHint_LogPreserveHint_MAX;
  static constexpr int LogPreserveHint_ARRAYSIZE =
    Event_LogPreserveHint_LogPreserveHint_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LogPreserveHint_descriptor() {
    return Event_LogPreserveHint_descriptor();
  }
  template<typename T>
  static inline const std::string& LogPreserveHint_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LogPreserveHint>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LogPreserveHint_Name.");
    return Event_LogPreserveHint_Name(enum_t_value);
  }
  static inline bool LogPreserveHint_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LogPreserveHint* value) {
    return Event_LogPreserveHint_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 8,
    kTypeFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kSourceFieldNumber = 3,
    kIdFieldNumber = 4,
    kStartTimeFieldNumber = 5,
    kEndTimeFieldNumber = 6,
    kLevelFieldNumber = 7,
    kLogPreserveHintFieldNumber = 9,
  };
  // repeated .bosdyn.api.Parameter parameters = 8;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::bosdyn::api::Parameter* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Parameter >*
      mutable_parameters();
  private:
  const ::bosdyn::api::Parameter& _internal_parameters(int index) const;
  ::bosdyn::api::Parameter* _internal_add_parameters();
  public:
  const ::bosdyn::api::Parameter& parameters(int index) const;
  ::bosdyn::api::Parameter* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Parameter >&
      parameters() const;

  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string source = 3;
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // string id = 4;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .google.protobuf.Timestamp start_time = 5;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 6;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // .bosdyn.api.Event.Level level = 7;
  void clear_level();
  ::bosdyn::api::Event_Level level() const;
  void set_level(::bosdyn::api::Event_Level value);
  private:
  ::bosdyn::api::Event_Level _internal_level() const;
  void _internal_set_level(::bosdyn::api::Event_Level value);
  public:

  // .bosdyn.api.Event.LogPreserveHint log_preserve_hint = 9;
  void clear_log_preserve_hint();
  ::bosdyn::api::Event_LogPreserveHint log_preserve_hint() const;
  void set_log_preserve_hint(::bosdyn::api::Event_LogPreserveHint value);
  private:
  ::bosdyn::api::Event_LogPreserveHint _internal_log_preserve_hint() const;
  void _internal_set_log_preserve_hint(::bosdyn::api::Event_LogPreserveHint value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Parameter > parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    int level_;
    int log_preserve_hint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class RecordTextMessagesResponse_Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RecordTextMessagesResponse.Error) */ {
 public:
  inline RecordTextMessagesResponse_Error() : RecordTextMessagesResponse_Error(nullptr) {}
  ~RecordTextMessagesResponse_Error() override;
  explicit PROTOBUF_CONSTEXPR RecordTextMessagesResponse_Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordTextMessagesResponse_Error(const RecordTextMessagesResponse_Error& from);
  RecordTextMessagesResponse_Error(RecordTextMessagesResponse_Error&& from) noexcept
    : RecordTextMessagesResponse_Error() {
    *this = ::std::move(from);
  }

  inline RecordTextMessagesResponse_Error& operator=(const RecordTextMessagesResponse_Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordTextMessagesResponse_Error& operator=(RecordTextMessagesResponse_Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordTextMessagesResponse_Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordTextMessagesResponse_Error* internal_default_instance() {
    return reinterpret_cast<const RecordTextMessagesResponse_Error*>(
               &_RecordTextMessagesResponse_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RecordTextMessagesResponse_Error& a, RecordTextMessagesResponse_Error& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordTextMessagesResponse_Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordTextMessagesResponse_Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordTextMessagesResponse_Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordTextMessagesResponse_Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordTextMessagesResponse_Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordTextMessagesResponse_Error& from) {
    RecordTextMessagesResponse_Error::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordTextMessagesResponse_Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RecordTextMessagesResponse.Error";
  }
  protected:
  explicit RecordTextMessagesResponse_Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RecordTextMessagesResponse_Error_Type Type;
  static constexpr Type NONE =
    RecordTextMessagesResponse_Error_Type_NONE;
  static constexpr Type CLIENT_ERROR =
    RecordTextMessagesResponse_Error_Type_CLIENT_ERROR;
  static constexpr Type SERVER_ERROR =
    RecordTextMessagesResponse_Error_Type_SERVER_ERROR;
  static inline bool Type_IsValid(int value) {
    return RecordTextMessagesResponse_Error_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    RecordTextMessagesResponse_Error_Type_Type_MIN;
  static constexpr Type Type_MAX =
    RecordTextMessagesResponse_Error_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    RecordTextMessagesResponse_Error_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return RecordTextMessagesResponse_Error_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return RecordTextMessagesResponse_Error_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return RecordTextMessagesResponse_Error_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kTypeFieldNumber = 1,
    kIndexFieldNumber = 3,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .bosdyn.api.RecordTextMessagesResponse.Error.Type type = 1;
  void clear_type();
  ::bosdyn::api::RecordTextMessagesResponse_Error_Type type() const;
  void set_type(::bosdyn::api::RecordTextMessagesResponse_Error_Type value);
  private:
  ::bosdyn::api::RecordTextMessagesResponse_Error_Type _internal_type() const;
  void _internal_set_type(::bosdyn::api::RecordTextMessagesResponse_Error_Type value);
  public:

  // uint32 index = 3;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.RecordTextMessagesResponse.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int type_;
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class RecordTextMessagesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RecordTextMessagesResponse) */ {
 public:
  inline RecordTextMessagesResponse() : RecordTextMessagesResponse(nullptr) {}
  ~RecordTextMessagesResponse() override;
  explicit PROTOBUF_CONSTEXPR RecordTextMessagesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordTextMessagesResponse(const RecordTextMessagesResponse& from);
  RecordTextMessagesResponse(RecordTextMessagesResponse&& from) noexcept
    : RecordTextMessagesResponse() {
    *this = ::std::move(from);
  }

  inline RecordTextMessagesResponse& operator=(const RecordTextMessagesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordTextMessagesResponse& operator=(RecordTextMessagesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordTextMessagesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordTextMessagesResponse* internal_default_instance() {
    return reinterpret_cast<const RecordTextMessagesResponse*>(
               &_RecordTextMessagesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RecordTextMessagesResponse& a, RecordTextMessagesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordTextMessagesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordTextMessagesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordTextMessagesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordTextMessagesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordTextMessagesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordTextMessagesResponse& from) {
    RecordTextMessagesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordTextMessagesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RecordTextMessagesResponse";
  }
  protected:
  explicit RecordTextMessagesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RecordTextMessagesResponse_Error Error;

  // accessors -------------------------------------------------------

  enum : int {
    kErrorsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.RecordTextMessagesResponse.Error errors = 2;
  int errors_size() const;
  private:
  int _internal_errors_size() const;
  public:
  void clear_errors();
  ::bosdyn::api::RecordTextMessagesResponse_Error* mutable_errors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordTextMessagesResponse_Error >*
      mutable_errors();
  private:
  const ::bosdyn::api::RecordTextMessagesResponse_Error& _internal_errors(int index) const;
  ::bosdyn::api::RecordTextMessagesResponse_Error* _internal_add_errors();
  public:
  const ::bosdyn::api::RecordTextMessagesResponse_Error& errors(int index) const;
  ::bosdyn::api::RecordTextMessagesResponse_Error* add_errors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordTextMessagesResponse_Error >&
      errors() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RecordTextMessagesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordTextMessagesResponse_Error > errors_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class RecordOperatorCommentsResponse_Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RecordOperatorCommentsResponse.Error) */ {
 public:
  inline RecordOperatorCommentsResponse_Error() : RecordOperatorCommentsResponse_Error(nullptr) {}
  ~RecordOperatorCommentsResponse_Error() override;
  explicit PROTOBUF_CONSTEXPR RecordOperatorCommentsResponse_Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordOperatorCommentsResponse_Error(const RecordOperatorCommentsResponse_Error& from);
  RecordOperatorCommentsResponse_Error(RecordOperatorCommentsResponse_Error&& from) noexcept
    : RecordOperatorCommentsResponse_Error() {
    *this = ::std::move(from);
  }

  inline RecordOperatorCommentsResponse_Error& operator=(const RecordOperatorCommentsResponse_Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordOperatorCommentsResponse_Error& operator=(RecordOperatorCommentsResponse_Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordOperatorCommentsResponse_Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordOperatorCommentsResponse_Error* internal_default_instance() {
    return reinterpret_cast<const RecordOperatorCommentsResponse_Error*>(
               &_RecordOperatorCommentsResponse_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RecordOperatorCommentsResponse_Error& a, RecordOperatorCommentsResponse_Error& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordOperatorCommentsResponse_Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordOperatorCommentsResponse_Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordOperatorCommentsResponse_Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordOperatorCommentsResponse_Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordOperatorCommentsResponse_Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordOperatorCommentsResponse_Error& from) {
    RecordOperatorCommentsResponse_Error::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordOperatorCommentsResponse_Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RecordOperatorCommentsResponse.Error";
  }
  protected:
  explicit RecordOperatorCommentsResponse_Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RecordOperatorCommentsResponse_Error_Type Type;
  static constexpr Type NONE =
    RecordOperatorCommentsResponse_Error_Type_NONE;
  static constexpr Type CLIENT_ERROR =
    RecordOperatorCommentsResponse_Error_Type_CLIENT_ERROR;
  static constexpr Type SERVER_ERROR =
    RecordOperatorCommentsResponse_Error_Type_SERVER_ERROR;
  static inline bool Type_IsValid(int value) {
    return RecordOperatorCommentsResponse_Error_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    RecordOperatorCommentsResponse_Error_Type_Type_MIN;
  static constexpr Type Type_MAX =
    RecordOperatorCommentsResponse_Error_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    RecordOperatorCommentsResponse_Error_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return RecordOperatorCommentsResponse_Error_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return RecordOperatorCommentsResponse_Error_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return RecordOperatorCommentsResponse_Error_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kTypeFieldNumber = 1,
    kIndexFieldNumber = 3,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .bosdyn.api.RecordOperatorCommentsResponse.Error.Type type = 1;
  void clear_type();
  ::bosdyn::api::RecordOperatorCommentsResponse_Error_Type type() const;
  void set_type(::bosdyn::api::RecordOperatorCommentsResponse_Error_Type value);
  private:
  ::bosdyn::api::RecordOperatorCommentsResponse_Error_Type _internal_type() const;
  void _internal_set_type(::bosdyn::api::RecordOperatorCommentsResponse_Error_Type value);
  public:

  // uint32 index = 3;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.RecordOperatorCommentsResponse.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int type_;
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class RecordOperatorCommentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RecordOperatorCommentsResponse) */ {
 public:
  inline RecordOperatorCommentsResponse() : RecordOperatorCommentsResponse(nullptr) {}
  ~RecordOperatorCommentsResponse() override;
  explicit PROTOBUF_CONSTEXPR RecordOperatorCommentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordOperatorCommentsResponse(const RecordOperatorCommentsResponse& from);
  RecordOperatorCommentsResponse(RecordOperatorCommentsResponse&& from) noexcept
    : RecordOperatorCommentsResponse() {
    *this = ::std::move(from);
  }

  inline RecordOperatorCommentsResponse& operator=(const RecordOperatorCommentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordOperatorCommentsResponse& operator=(RecordOperatorCommentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordOperatorCommentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordOperatorCommentsResponse* internal_default_instance() {
    return reinterpret_cast<const RecordOperatorCommentsResponse*>(
               &_RecordOperatorCommentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RecordOperatorCommentsResponse& a, RecordOperatorCommentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordOperatorCommentsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordOperatorCommentsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordOperatorCommentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordOperatorCommentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordOperatorCommentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordOperatorCommentsResponse& from) {
    RecordOperatorCommentsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordOperatorCommentsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RecordOperatorCommentsResponse";
  }
  protected:
  explicit RecordOperatorCommentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RecordOperatorCommentsResponse_Error Error;

  // accessors -------------------------------------------------------

  enum : int {
    kErrorsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.RecordOperatorCommentsResponse.Error errors = 2;
  int errors_size() const;
  private:
  int _internal_errors_size() const;
  public:
  void clear_errors();
  ::bosdyn::api::RecordOperatorCommentsResponse_Error* mutable_errors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordOperatorCommentsResponse_Error >*
      mutable_errors();
  private:
  const ::bosdyn::api::RecordOperatorCommentsResponse_Error& _internal_errors(int index) const;
  ::bosdyn::api::RecordOperatorCommentsResponse_Error* _internal_add_errors();
  public:
  const ::bosdyn::api::RecordOperatorCommentsResponse_Error& errors(int index) const;
  ::bosdyn::api::RecordOperatorCommentsResponse_Error* add_errors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordOperatorCommentsResponse_Error >&
      errors() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RecordOperatorCommentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordOperatorCommentsResponse_Error > errors_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class RecordDataBlobsResponse_Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RecordDataBlobsResponse.Error) */ {
 public:
  inline RecordDataBlobsResponse_Error() : RecordDataBlobsResponse_Error(nullptr) {}
  ~RecordDataBlobsResponse_Error() override;
  explicit PROTOBUF_CONSTEXPR RecordDataBlobsResponse_Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordDataBlobsResponse_Error(const RecordDataBlobsResponse_Error& from);
  RecordDataBlobsResponse_Error(RecordDataBlobsResponse_Error&& from) noexcept
    : RecordDataBlobsResponse_Error() {
    *this = ::std::move(from);
  }

  inline RecordDataBlobsResponse_Error& operator=(const RecordDataBlobsResponse_Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordDataBlobsResponse_Error& operator=(RecordDataBlobsResponse_Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordDataBlobsResponse_Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordDataBlobsResponse_Error* internal_default_instance() {
    return reinterpret_cast<const RecordDataBlobsResponse_Error*>(
               &_RecordDataBlobsResponse_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RecordDataBlobsResponse_Error& a, RecordDataBlobsResponse_Error& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordDataBlobsResponse_Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordDataBlobsResponse_Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordDataBlobsResponse_Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordDataBlobsResponse_Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordDataBlobsResponse_Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordDataBlobsResponse_Error& from) {
    RecordDataBlobsResponse_Error::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordDataBlobsResponse_Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RecordDataBlobsResponse.Error";
  }
  protected:
  explicit RecordDataBlobsResponse_Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RecordDataBlobsResponse_Error_Type Type;
  static constexpr Type NONE =
    RecordDataBlobsResponse_Error_Type_NONE;
  static constexpr Type CLIENT_ERROR =
    RecordDataBlobsResponse_Error_Type_CLIENT_ERROR;
  static constexpr Type SERVER_ERROR =
    RecordDataBlobsResponse_Error_Type_SERVER_ERROR;
  static inline bool Type_IsValid(int value) {
    return RecordDataBlobsResponse_Error_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    RecordDataBlobsResponse_Error_Type_Type_MIN;
  static constexpr Type Type_MAX =
    RecordDataBlobsResponse_Error_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    RecordDataBlobsResponse_Error_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return RecordDataBlobsResponse_Error_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return RecordDataBlobsResponse_Error_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return RecordDataBlobsResponse_Error_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kTypeFieldNumber = 1,
    kIndexFieldNumber = 3,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .bosdyn.api.RecordDataBlobsResponse.Error.Type type = 1;
  void clear_type();
  ::bosdyn::api::RecordDataBlobsResponse_Error_Type type() const;
  void set_type(::bosdyn::api::RecordDataBlobsResponse_Error_Type value);
  private:
  ::bosdyn::api::RecordDataBlobsResponse_Error_Type _internal_type() const;
  void _internal_set_type(::bosdyn::api::RecordDataBlobsResponse_Error_Type value);
  public:

  // uint32 index = 3;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.RecordDataBlobsResponse.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int type_;
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class RecordDataBlobsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RecordDataBlobsResponse) */ {
 public:
  inline RecordDataBlobsResponse() : RecordDataBlobsResponse(nullptr) {}
  ~RecordDataBlobsResponse() override;
  explicit PROTOBUF_CONSTEXPR RecordDataBlobsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordDataBlobsResponse(const RecordDataBlobsResponse& from);
  RecordDataBlobsResponse(RecordDataBlobsResponse&& from) noexcept
    : RecordDataBlobsResponse() {
    *this = ::std::move(from);
  }

  inline RecordDataBlobsResponse& operator=(const RecordDataBlobsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordDataBlobsResponse& operator=(RecordDataBlobsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordDataBlobsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordDataBlobsResponse* internal_default_instance() {
    return reinterpret_cast<const RecordDataBlobsResponse*>(
               &_RecordDataBlobsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RecordDataBlobsResponse& a, RecordDataBlobsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordDataBlobsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordDataBlobsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordDataBlobsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordDataBlobsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordDataBlobsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordDataBlobsResponse& from) {
    RecordDataBlobsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordDataBlobsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RecordDataBlobsResponse";
  }
  protected:
  explicit RecordDataBlobsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RecordDataBlobsResponse_Error Error;

  // accessors -------------------------------------------------------

  enum : int {
    kErrorsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.RecordDataBlobsResponse.Error errors = 2;
  int errors_size() const;
  private:
  int _internal_errors_size() const;
  public:
  void clear_errors();
  ::bosdyn::api::RecordDataBlobsResponse_Error* mutable_errors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordDataBlobsResponse_Error >*
      mutable_errors();
  private:
  const ::bosdyn::api::RecordDataBlobsResponse_Error& _internal_errors(int index) const;
  ::bosdyn::api::RecordDataBlobsResponse_Error* _internal_add_errors();
  public:
  const ::bosdyn::api::RecordDataBlobsResponse_Error& errors(int index) const;
  ::bosdyn::api::RecordDataBlobsResponse_Error* add_errors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordDataBlobsResponse_Error >&
      errors() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RecordDataBlobsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordDataBlobsResponse_Error > errors_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class RecordSignalTicksResponse_Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RecordSignalTicksResponse.Error) */ {
 public:
  inline RecordSignalTicksResponse_Error() : RecordSignalTicksResponse_Error(nullptr) {}
  ~RecordSignalTicksResponse_Error() override;
  explicit PROTOBUF_CONSTEXPR RecordSignalTicksResponse_Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordSignalTicksResponse_Error(const RecordSignalTicksResponse_Error& from);
  RecordSignalTicksResponse_Error(RecordSignalTicksResponse_Error&& from) noexcept
    : RecordSignalTicksResponse_Error() {
    *this = ::std::move(from);
  }

  inline RecordSignalTicksResponse_Error& operator=(const RecordSignalTicksResponse_Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordSignalTicksResponse_Error& operator=(RecordSignalTicksResponse_Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordSignalTicksResponse_Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordSignalTicksResponse_Error* internal_default_instance() {
    return reinterpret_cast<const RecordSignalTicksResponse_Error*>(
               &_RecordSignalTicksResponse_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RecordSignalTicksResponse_Error& a, RecordSignalTicksResponse_Error& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordSignalTicksResponse_Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordSignalTicksResponse_Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordSignalTicksResponse_Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordSignalTicksResponse_Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordSignalTicksResponse_Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordSignalTicksResponse_Error& from) {
    RecordSignalTicksResponse_Error::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordSignalTicksResponse_Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RecordSignalTicksResponse.Error";
  }
  protected:
  explicit RecordSignalTicksResponse_Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RecordSignalTicksResponse_Error_Type Type;
  static constexpr Type NONE =
    RecordSignalTicksResponse_Error_Type_NONE;
  static constexpr Type CLIENT_ERROR =
    RecordSignalTicksResponse_Error_Type_CLIENT_ERROR;
  static constexpr Type SERVER_ERROR =
    RecordSignalTicksResponse_Error_Type_SERVER_ERROR;
  static constexpr Type INVALID_SCHEMA_ID =
    RecordSignalTicksResponse_Error_Type_INVALID_SCHEMA_ID;
  static inline bool Type_IsValid(int value) {
    return RecordSignalTicksResponse_Error_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    RecordSignalTicksResponse_Error_Type_Type_MIN;
  static constexpr Type Type_MAX =
    RecordSignalTicksResponse_Error_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    RecordSignalTicksResponse_Error_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return RecordSignalTicksResponse_Error_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return RecordSignalTicksResponse_Error_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return RecordSignalTicksResponse_Error_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kTypeFieldNumber = 1,
    kIndexFieldNumber = 3,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .bosdyn.api.RecordSignalTicksResponse.Error.Type type = 1;
  void clear_type();
  ::bosdyn::api::RecordSignalTicksResponse_Error_Type type() const;
  void set_type(::bosdyn::api::RecordSignalTicksResponse_Error_Type value);
  private:
  ::bosdyn::api::RecordSignalTicksResponse_Error_Type _internal_type() const;
  void _internal_set_type(::bosdyn::api::RecordSignalTicksResponse_Error_Type value);
  public:

  // uint32 index = 3;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.RecordSignalTicksResponse.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int type_;
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class RecordSignalTicksResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RecordSignalTicksResponse) */ {
 public:
  inline RecordSignalTicksResponse() : RecordSignalTicksResponse(nullptr) {}
  ~RecordSignalTicksResponse() override;
  explicit PROTOBUF_CONSTEXPR RecordSignalTicksResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordSignalTicksResponse(const RecordSignalTicksResponse& from);
  RecordSignalTicksResponse(RecordSignalTicksResponse&& from) noexcept
    : RecordSignalTicksResponse() {
    *this = ::std::move(from);
  }

  inline RecordSignalTicksResponse& operator=(const RecordSignalTicksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordSignalTicksResponse& operator=(RecordSignalTicksResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordSignalTicksResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordSignalTicksResponse* internal_default_instance() {
    return reinterpret_cast<const RecordSignalTicksResponse*>(
               &_RecordSignalTicksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RecordSignalTicksResponse& a, RecordSignalTicksResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordSignalTicksResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordSignalTicksResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordSignalTicksResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordSignalTicksResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordSignalTicksResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordSignalTicksResponse& from) {
    RecordSignalTicksResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordSignalTicksResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RecordSignalTicksResponse";
  }
  protected:
  explicit RecordSignalTicksResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RecordSignalTicksResponse_Error Error;

  // accessors -------------------------------------------------------

  enum : int {
    kErrorsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.RecordSignalTicksResponse.Error errors = 2;
  int errors_size() const;
  private:
  int _internal_errors_size() const;
  public:
  void clear_errors();
  ::bosdyn::api::RecordSignalTicksResponse_Error* mutable_errors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordSignalTicksResponse_Error >*
      mutable_errors();
  private:
  const ::bosdyn::api::RecordSignalTicksResponse_Error& _internal_errors(int index) const;
  ::bosdyn::api::RecordSignalTicksResponse_Error* _internal_add_errors();
  public:
  const ::bosdyn::api::RecordSignalTicksResponse_Error& errors(int index) const;
  ::bosdyn::api::RecordSignalTicksResponse_Error* add_errors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordSignalTicksResponse_Error >&
      errors() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RecordSignalTicksResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordSignalTicksResponse_Error > errors_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class RecordEventsResponse_Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RecordEventsResponse.Error) */ {
 public:
  inline RecordEventsResponse_Error() : RecordEventsResponse_Error(nullptr) {}
  ~RecordEventsResponse_Error() override;
  explicit PROTOBUF_CONSTEXPR RecordEventsResponse_Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordEventsResponse_Error(const RecordEventsResponse_Error& from);
  RecordEventsResponse_Error(RecordEventsResponse_Error&& from) noexcept
    : RecordEventsResponse_Error() {
    *this = ::std::move(from);
  }

  inline RecordEventsResponse_Error& operator=(const RecordEventsResponse_Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordEventsResponse_Error& operator=(RecordEventsResponse_Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordEventsResponse_Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordEventsResponse_Error* internal_default_instance() {
    return reinterpret_cast<const RecordEventsResponse_Error*>(
               &_RecordEventsResponse_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RecordEventsResponse_Error& a, RecordEventsResponse_Error& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordEventsResponse_Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordEventsResponse_Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordEventsResponse_Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordEventsResponse_Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordEventsResponse_Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordEventsResponse_Error& from) {
    RecordEventsResponse_Error::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordEventsResponse_Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RecordEventsResponse.Error";
  }
  protected:
  explicit RecordEventsResponse_Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RecordEventsResponse_Error_Type Type;
  static constexpr Type NONE =
    RecordEventsResponse_Error_Type_NONE;
  static constexpr Type CLIENT_ERROR =
    RecordEventsResponse_Error_Type_CLIENT_ERROR;
  static constexpr Type SERVER_ERROR =
    RecordEventsResponse_Error_Type_SERVER_ERROR;
  static inline bool Type_IsValid(int value) {
    return RecordEventsResponse_Error_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    RecordEventsResponse_Error_Type_Type_MIN;
  static constexpr Type Type_MAX =
    RecordEventsResponse_Error_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    RecordEventsResponse_Error_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return RecordEventsResponse_Error_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return RecordEventsResponse_Error_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return RecordEventsResponse_Error_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kTypeFieldNumber = 1,
    kIndexFieldNumber = 3,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .bosdyn.api.RecordEventsResponse.Error.Type type = 1;
  void clear_type();
  ::bosdyn::api::RecordEventsResponse_Error_Type type() const;
  void set_type(::bosdyn::api::RecordEventsResponse_Error_Type value);
  private:
  ::bosdyn::api::RecordEventsResponse_Error_Type _internal_type() const;
  void _internal_set_type(::bosdyn::api::RecordEventsResponse_Error_Type value);
  public:

  // uint32 index = 3;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.RecordEventsResponse.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int type_;
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class RecordEventsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RecordEventsResponse) */ {
 public:
  inline RecordEventsResponse() : RecordEventsResponse(nullptr) {}
  ~RecordEventsResponse() override;
  explicit PROTOBUF_CONSTEXPR RecordEventsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordEventsResponse(const RecordEventsResponse& from);
  RecordEventsResponse(RecordEventsResponse&& from) noexcept
    : RecordEventsResponse() {
    *this = ::std::move(from);
  }

  inline RecordEventsResponse& operator=(const RecordEventsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordEventsResponse& operator=(RecordEventsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordEventsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordEventsResponse* internal_default_instance() {
    return reinterpret_cast<const RecordEventsResponse*>(
               &_RecordEventsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RecordEventsResponse& a, RecordEventsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordEventsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordEventsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordEventsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordEventsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordEventsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordEventsResponse& from) {
    RecordEventsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordEventsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RecordEventsResponse";
  }
  protected:
  explicit RecordEventsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RecordEventsResponse_Error Error;

  // accessors -------------------------------------------------------

  enum : int {
    kErrorsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.RecordEventsResponse.Error errors = 2;
  int errors_size() const;
  private:
  int _internal_errors_size() const;
  public:
  void clear_errors();
  ::bosdyn::api::RecordEventsResponse_Error* mutable_errors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordEventsResponse_Error >*
      mutable_errors();
  private:
  const ::bosdyn::api::RecordEventsResponse_Error& _internal_errors(int index) const;
  ::bosdyn::api::RecordEventsResponse_Error* _internal_add_errors();
  public:
  const ::bosdyn::api::RecordEventsResponse_Error& errors(int index) const;
  ::bosdyn::api::RecordEventsResponse_Error* add_errors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordEventsResponse_Error >&
      errors() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RecordEventsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordEventsResponse_Error > errors_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class RegisterSignalSchemaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RegisterSignalSchemaRequest) */ {
 public:
  inline RegisterSignalSchemaRequest() : RegisterSignalSchemaRequest(nullptr) {}
  ~RegisterSignalSchemaRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterSignalSchemaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterSignalSchemaRequest(const RegisterSignalSchemaRequest& from);
  RegisterSignalSchemaRequest(RegisterSignalSchemaRequest&& from) noexcept
    : RegisterSignalSchemaRequest() {
    *this = ::std::move(from);
  }

  inline RegisterSignalSchemaRequest& operator=(const RegisterSignalSchemaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterSignalSchemaRequest& operator=(RegisterSignalSchemaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterSignalSchemaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterSignalSchemaRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterSignalSchemaRequest*>(
               &_RegisterSignalSchemaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RegisterSignalSchemaRequest& a, RegisterSignalSchemaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterSignalSchemaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterSignalSchemaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterSignalSchemaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterSignalSchemaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterSignalSchemaRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterSignalSchemaRequest& from) {
    RegisterSignalSchemaRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterSignalSchemaRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RegisterSignalSchemaRequest";
  }
  protected:
  explicit RegisterSignalSchemaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kSchemaFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.SignalSchema schema = 2;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::bosdyn::api::SignalSchema& schema() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SignalSchema* release_schema();
  ::bosdyn::api::SignalSchema* mutable_schema();
  void set_allocated_schema(::bosdyn::api::SignalSchema* schema);
  private:
  const ::bosdyn::api::SignalSchema& _internal_schema() const;
  ::bosdyn::api::SignalSchema* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::bosdyn::api::SignalSchema* schema);
  ::bosdyn::api::SignalSchema* unsafe_arena_release_schema();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RegisterSignalSchemaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::SignalSchema* schema_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// -------------------------------------------------------------------

class RegisterSignalSchemaResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RegisterSignalSchemaResponse) */ {
 public:
  inline RegisterSignalSchemaResponse() : RegisterSignalSchemaResponse(nullptr) {}
  ~RegisterSignalSchemaResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterSignalSchemaResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterSignalSchemaResponse(const RegisterSignalSchemaResponse& from);
  RegisterSignalSchemaResponse(RegisterSignalSchemaResponse&& from) noexcept
    : RegisterSignalSchemaResponse() {
    *this = ::std::move(from);
  }

  inline RegisterSignalSchemaResponse& operator=(const RegisterSignalSchemaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterSignalSchemaResponse& operator=(RegisterSignalSchemaResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterSignalSchemaResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterSignalSchemaResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterSignalSchemaResponse*>(
               &_RegisterSignalSchemaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(RegisterSignalSchemaResponse& a, RegisterSignalSchemaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterSignalSchemaResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterSignalSchemaResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterSignalSchemaResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterSignalSchemaResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterSignalSchemaResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterSignalSchemaResponse& from) {
    RegisterSignalSchemaResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterSignalSchemaResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RegisterSignalSchemaResponse";
  }
  protected:
  explicit RegisterSignalSchemaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kSchemaIdFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // uint64 schema_id = 2;
  void clear_schema_id();
  uint64_t schema_id() const;
  void set_schema_id(uint64_t value);
  private:
  uint64_t _internal_schema_id() const;
  void _internal_set_schema_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.RegisterSignalSchemaResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    uint64_t schema_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5fbuffer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RecordTextMessagesRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RecordTextMessagesRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RecordTextMessagesRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RecordTextMessagesRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RecordTextMessagesRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordTextMessagesRequest.header)
  return _internal_header();
}
inline void RecordTextMessagesRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RecordTextMessagesRequest.header)
}
inline ::bosdyn::api::RequestHeader* RecordTextMessagesRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* RecordTextMessagesRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RecordTextMessagesRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RecordTextMessagesRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* RecordTextMessagesRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordTextMessagesRequest.header)
  return _msg;
}
inline void RecordTextMessagesRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RecordTextMessagesRequest.header)
}

// repeated .bosdyn.api.TextMessage text_messages = 2;
inline int RecordTextMessagesRequest::_internal_text_messages_size() const {
  return _impl_.text_messages_.size();
}
inline int RecordTextMessagesRequest::text_messages_size() const {
  return _internal_text_messages_size();
}
inline void RecordTextMessagesRequest::clear_text_messages() {
  _impl_.text_messages_.Clear();
}
inline ::bosdyn::api::TextMessage* RecordTextMessagesRequest::mutable_text_messages(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordTextMessagesRequest.text_messages)
  return _impl_.text_messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::TextMessage >*
RecordTextMessagesRequest::mutable_text_messages() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RecordTextMessagesRequest.text_messages)
  return &_impl_.text_messages_;
}
inline const ::bosdyn::api::TextMessage& RecordTextMessagesRequest::_internal_text_messages(int index) const {
  return _impl_.text_messages_.Get(index);
}
inline const ::bosdyn::api::TextMessage& RecordTextMessagesRequest::text_messages(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordTextMessagesRequest.text_messages)
  return _internal_text_messages(index);
}
inline ::bosdyn::api::TextMessage* RecordTextMessagesRequest::_internal_add_text_messages() {
  return _impl_.text_messages_.Add();
}
inline ::bosdyn::api::TextMessage* RecordTextMessagesRequest::add_text_messages() {
  ::bosdyn::api::TextMessage* _add = _internal_add_text_messages();
  // @@protoc_insertion_point(field_add:bosdyn.api.RecordTextMessagesRequest.text_messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::TextMessage >&
RecordTextMessagesRequest::text_messages() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RecordTextMessagesRequest.text_messages)
  return _impl_.text_messages_;
}

// -------------------------------------------------------------------

// RecordOperatorCommentsRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RecordOperatorCommentsRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RecordOperatorCommentsRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RecordOperatorCommentsRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RecordOperatorCommentsRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordOperatorCommentsRequest.header)
  return _internal_header();
}
inline void RecordOperatorCommentsRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RecordOperatorCommentsRequest.header)
}
inline ::bosdyn::api::RequestHeader* RecordOperatorCommentsRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* RecordOperatorCommentsRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RecordOperatorCommentsRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RecordOperatorCommentsRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* RecordOperatorCommentsRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordOperatorCommentsRequest.header)
  return _msg;
}
inline void RecordOperatorCommentsRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RecordOperatorCommentsRequest.header)
}

// repeated .bosdyn.api.OperatorComment operator_comments = 2;
inline int RecordOperatorCommentsRequest::_internal_operator_comments_size() const {
  return _impl_.operator_comments_.size();
}
inline int RecordOperatorCommentsRequest::operator_comments_size() const {
  return _internal_operator_comments_size();
}
inline void RecordOperatorCommentsRequest::clear_operator_comments() {
  _impl_.operator_comments_.Clear();
}
inline ::bosdyn::api::OperatorComment* RecordOperatorCommentsRequest::mutable_operator_comments(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordOperatorCommentsRequest.operator_comments)
  return _impl_.operator_comments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::OperatorComment >*
RecordOperatorCommentsRequest::mutable_operator_comments() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RecordOperatorCommentsRequest.operator_comments)
  return &_impl_.operator_comments_;
}
inline const ::bosdyn::api::OperatorComment& RecordOperatorCommentsRequest::_internal_operator_comments(int index) const {
  return _impl_.operator_comments_.Get(index);
}
inline const ::bosdyn::api::OperatorComment& RecordOperatorCommentsRequest::operator_comments(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordOperatorCommentsRequest.operator_comments)
  return _internal_operator_comments(index);
}
inline ::bosdyn::api::OperatorComment* RecordOperatorCommentsRequest::_internal_add_operator_comments() {
  return _impl_.operator_comments_.Add();
}
inline ::bosdyn::api::OperatorComment* RecordOperatorCommentsRequest::add_operator_comments() {
  ::bosdyn::api::OperatorComment* _add = _internal_add_operator_comments();
  // @@protoc_insertion_point(field_add:bosdyn.api.RecordOperatorCommentsRequest.operator_comments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::OperatorComment >&
RecordOperatorCommentsRequest::operator_comments() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RecordOperatorCommentsRequest.operator_comments)
  return _impl_.operator_comments_;
}

// -------------------------------------------------------------------

// RecordDataBlobsRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RecordDataBlobsRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RecordDataBlobsRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RecordDataBlobsRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RecordDataBlobsRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordDataBlobsRequest.header)
  return _internal_header();
}
inline void RecordDataBlobsRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RecordDataBlobsRequest.header)
}
inline ::bosdyn::api::RequestHeader* RecordDataBlobsRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* RecordDataBlobsRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RecordDataBlobsRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RecordDataBlobsRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* RecordDataBlobsRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordDataBlobsRequest.header)
  return _msg;
}
inline void RecordDataBlobsRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RecordDataBlobsRequest.header)
}

// repeated .bosdyn.api.DataBlob blob_data = 2;
inline int RecordDataBlobsRequest::_internal_blob_data_size() const {
  return _impl_.blob_data_.size();
}
inline int RecordDataBlobsRequest::blob_data_size() const {
  return _internal_blob_data_size();
}
inline void RecordDataBlobsRequest::clear_blob_data() {
  _impl_.blob_data_.Clear();
}
inline ::bosdyn::api::DataBlob* RecordDataBlobsRequest::mutable_blob_data(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordDataBlobsRequest.blob_data)
  return _impl_.blob_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataBlob >*
RecordDataBlobsRequest::mutable_blob_data() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RecordDataBlobsRequest.blob_data)
  return &_impl_.blob_data_;
}
inline const ::bosdyn::api::DataBlob& RecordDataBlobsRequest::_internal_blob_data(int index) const {
  return _impl_.blob_data_.Get(index);
}
inline const ::bosdyn::api::DataBlob& RecordDataBlobsRequest::blob_data(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordDataBlobsRequest.blob_data)
  return _internal_blob_data(index);
}
inline ::bosdyn::api::DataBlob* RecordDataBlobsRequest::_internal_add_blob_data() {
  return _impl_.blob_data_.Add();
}
inline ::bosdyn::api::DataBlob* RecordDataBlobsRequest::add_blob_data() {
  ::bosdyn::api::DataBlob* _add = _internal_add_blob_data();
  // @@protoc_insertion_point(field_add:bosdyn.api.RecordDataBlobsRequest.blob_data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataBlob >&
RecordDataBlobsRequest::blob_data() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RecordDataBlobsRequest.blob_data)
  return _impl_.blob_data_;
}

// bool sync = 3;
inline void RecordDataBlobsRequest::clear_sync() {
  _impl_.sync_ = false;
}
inline bool RecordDataBlobsRequest::_internal_sync() const {
  return _impl_.sync_;
}
inline bool RecordDataBlobsRequest::sync() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordDataBlobsRequest.sync)
  return _internal_sync();
}
inline void RecordDataBlobsRequest::_internal_set_sync(bool value) {
  
  _impl_.sync_ = value;
}
inline void RecordDataBlobsRequest::set_sync(bool value) {
  _internal_set_sync(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RecordDataBlobsRequest.sync)
}

// -------------------------------------------------------------------

// RecordSignalTicksRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RecordSignalTicksRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RecordSignalTicksRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RecordSignalTicksRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RecordSignalTicksRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordSignalTicksRequest.header)
  return _internal_header();
}
inline void RecordSignalTicksRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RecordSignalTicksRequest.header)
}
inline ::bosdyn::api::RequestHeader* RecordSignalTicksRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* RecordSignalTicksRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RecordSignalTicksRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RecordSignalTicksRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* RecordSignalTicksRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordSignalTicksRequest.header)
  return _msg;
}
inline void RecordSignalTicksRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RecordSignalTicksRequest.header)
}

// repeated .bosdyn.api.SignalTick tick_data = 2;
inline int RecordSignalTicksRequest::_internal_tick_data_size() const {
  return _impl_.tick_data_.size();
}
inline int RecordSignalTicksRequest::tick_data_size() const {
  return _internal_tick_data_size();
}
inline void RecordSignalTicksRequest::clear_tick_data() {
  _impl_.tick_data_.Clear();
}
inline ::bosdyn::api::SignalTick* RecordSignalTicksRequest::mutable_tick_data(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordSignalTicksRequest.tick_data)
  return _impl_.tick_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SignalTick >*
RecordSignalTicksRequest::mutable_tick_data() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RecordSignalTicksRequest.tick_data)
  return &_impl_.tick_data_;
}
inline const ::bosdyn::api::SignalTick& RecordSignalTicksRequest::_internal_tick_data(int index) const {
  return _impl_.tick_data_.Get(index);
}
inline const ::bosdyn::api::SignalTick& RecordSignalTicksRequest::tick_data(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordSignalTicksRequest.tick_data)
  return _internal_tick_data(index);
}
inline ::bosdyn::api::SignalTick* RecordSignalTicksRequest::_internal_add_tick_data() {
  return _impl_.tick_data_.Add();
}
inline ::bosdyn::api::SignalTick* RecordSignalTicksRequest::add_tick_data() {
  ::bosdyn::api::SignalTick* _add = _internal_add_tick_data();
  // @@protoc_insertion_point(field_add:bosdyn.api.RecordSignalTicksRequest.tick_data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SignalTick >&
RecordSignalTicksRequest::tick_data() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RecordSignalTicksRequest.tick_data)
  return _impl_.tick_data_;
}

// -------------------------------------------------------------------

// RecordEventsRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RecordEventsRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RecordEventsRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RecordEventsRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RecordEventsRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordEventsRequest.header)
  return _internal_header();
}
inline void RecordEventsRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RecordEventsRequest.header)
}
inline ::bosdyn::api::RequestHeader* RecordEventsRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* RecordEventsRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RecordEventsRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RecordEventsRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* RecordEventsRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordEventsRequest.header)
  return _msg;
}
inline void RecordEventsRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RecordEventsRequest.header)
}

// repeated .bosdyn.api.Event events = 2;
inline int RecordEventsRequest::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int RecordEventsRequest::events_size() const {
  return _internal_events_size();
}
inline void RecordEventsRequest::clear_events() {
  _impl_.events_.Clear();
}
inline ::bosdyn::api::Event* RecordEventsRequest::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordEventsRequest.events)
  return _impl_.events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Event >*
RecordEventsRequest::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RecordEventsRequest.events)
  return &_impl_.events_;
}
inline const ::bosdyn::api::Event& RecordEventsRequest::_internal_events(int index) const {
  return _impl_.events_.Get(index);
}
inline const ::bosdyn::api::Event& RecordEventsRequest::events(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordEventsRequest.events)
  return _internal_events(index);
}
inline ::bosdyn::api::Event* RecordEventsRequest::_internal_add_events() {
  return _impl_.events_.Add();
}
inline ::bosdyn::api::Event* RecordEventsRequest::add_events() {
  ::bosdyn::api::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:bosdyn.api.RecordEventsRequest.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Event >&
RecordEventsRequest::events() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RecordEventsRequest.events)
  return _impl_.events_;
}

// -------------------------------------------------------------------

// TextMessage

// string message = 1;
inline void TextMessage::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& TextMessage::message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TextMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextMessage::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.TextMessage.message)
}
inline std::string* TextMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.TextMessage.message)
  return _s;
}
inline const std::string& TextMessage::_internal_message() const {
  return _impl_.message_.Get();
}
inline void TextMessage::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* TextMessage::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* TextMessage::release_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.TextMessage.message)
  return _impl_.message_.Release();
}
inline void TextMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.TextMessage.message)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool TextMessage::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool TextMessage::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TextMessage::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TextMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TextMessage.timestamp)
  return _internal_timestamp();
}
inline void TextMessage::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.TextMessage.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TextMessage::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TextMessage::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.TextMessage.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TextMessage::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TextMessage::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.TextMessage.timestamp)
  return _msg;
}
inline void TextMessage::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.TextMessage.timestamp)
}

// string source = 3;
inline void TextMessage::clear_source() {
  _impl_.source_.ClearToEmpty();
}
inline const std::string& TextMessage::source() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TextMessage.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextMessage::set_source(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.TextMessage.source)
}
inline std::string* TextMessage::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.TextMessage.source)
  return _s;
}
inline const std::string& TextMessage::_internal_source() const {
  return _impl_.source_.Get();
}
inline void TextMessage::_internal_set_source(const std::string& value) {
  
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* TextMessage::_internal_mutable_source() {
  
  return _impl_.source_.Mutable(GetArenaForAllocation());
}
inline std::string* TextMessage::release_source() {
  // @@protoc_insertion_point(field_release:bosdyn.api.TextMessage.source)
  return _impl_.source_.Release();
}
inline void TextMessage::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  _impl_.source_.SetAllocated(source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.TextMessage.source)
}

// .bosdyn.api.TextMessage.Level level = 4;
inline void TextMessage::clear_level() {
  _impl_.level_ = 0;
}
inline ::bosdyn::api::TextMessage_Level TextMessage::_internal_level() const {
  return static_cast< ::bosdyn::api::TextMessage_Level >(_impl_.level_);
}
inline ::bosdyn::api::TextMessage_Level TextMessage::level() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TextMessage.level)
  return _internal_level();
}
inline void TextMessage::_internal_set_level(::bosdyn::api::TextMessage_Level value) {
  
  _impl_.level_ = value;
}
inline void TextMessage::set_level(::bosdyn::api::TextMessage_Level value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.TextMessage.level)
}

// string tag = 5;
inline void TextMessage::clear_tag() {
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& TextMessage::tag() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TextMessage.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextMessage::set_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.TextMessage.tag)
}
inline std::string* TextMessage::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.TextMessage.tag)
  return _s;
}
inline const std::string& TextMessage::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void TextMessage::_internal_set_tag(const std::string& value) {
  
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* TextMessage::_internal_mutable_tag() {
  
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* TextMessage::release_tag() {
  // @@protoc_insertion_point(field_release:bosdyn.api.TextMessage.tag)
  return _impl_.tag_.Release();
}
inline void TextMessage::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.TextMessage.tag)
}

// string filename = 6;
inline void TextMessage::clear_filename() {
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& TextMessage::filename() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TextMessage.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextMessage::set_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.TextMessage.filename)
}
inline std::string* TextMessage::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.TextMessage.filename)
  return _s;
}
inline const std::string& TextMessage::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void TextMessage::_internal_set_filename(const std::string& value) {
  
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* TextMessage::_internal_mutable_filename() {
  
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* TextMessage::release_filename() {
  // @@protoc_insertion_point(field_release:bosdyn.api.TextMessage.filename)
  return _impl_.filename_.Release();
}
inline void TextMessage::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.TextMessage.filename)
}

// int32 line_number = 7;
inline void TextMessage::clear_line_number() {
  _impl_.line_number_ = 0;
}
inline int32_t TextMessage::_internal_line_number() const {
  return _impl_.line_number_;
}
inline int32_t TextMessage::line_number() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TextMessage.line_number)
  return _internal_line_number();
}
inline void TextMessage::_internal_set_line_number(int32_t value) {
  
  _impl_.line_number_ = value;
}
inline void TextMessage::set_line_number(int32_t value) {
  _internal_set_line_number(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.TextMessage.line_number)
}

// -------------------------------------------------------------------

// OperatorComment

// string message = 1;
inline void OperatorComment::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& OperatorComment::message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.OperatorComment.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperatorComment::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.OperatorComment.message)
}
inline std::string* OperatorComment::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.OperatorComment.message)
  return _s;
}
inline const std::string& OperatorComment::_internal_message() const {
  return _impl_.message_.Get();
}
inline void OperatorComment::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* OperatorComment::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* OperatorComment::release_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.OperatorComment.message)
  return _impl_.message_.Release();
}
inline void OperatorComment::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.OperatorComment.message)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool OperatorComment::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool OperatorComment::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OperatorComment::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OperatorComment::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.OperatorComment.timestamp)
  return _internal_timestamp();
}
inline void OperatorComment::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.OperatorComment.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperatorComment::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperatorComment::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.OperatorComment.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperatorComment::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperatorComment::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.OperatorComment.timestamp)
  return _msg;
}
inline void OperatorComment::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.OperatorComment.timestamp)
}

// -------------------------------------------------------------------

// DataBlob

// .google.protobuf.Timestamp timestamp = 1;
inline bool DataBlob::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool DataBlob::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DataBlob::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DataBlob::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataBlob.timestamp)
  return _internal_timestamp();
}
inline void DataBlob::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DataBlob.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DataBlob::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DataBlob::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataBlob.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DataBlob::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DataBlob::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataBlob.timestamp)
  return _msg;
}
inline void DataBlob::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataBlob.timestamp)
}

// string channel = 2;
inline void DataBlob::clear_channel() {
  _impl_.channel_.ClearToEmpty();
}
inline const std::string& DataBlob::channel() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataBlob.channel)
  return _internal_channel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataBlob::set_channel(ArgT0&& arg0, ArgT... args) {
 
 _impl_.channel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.DataBlob.channel)
}
inline std::string* DataBlob::mutable_channel() {
  std::string* _s = _internal_mutable_channel();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataBlob.channel)
  return _s;
}
inline const std::string& DataBlob::_internal_channel() const {
  return _impl_.channel_.Get();
}
inline void DataBlob::_internal_set_channel(const std::string& value) {
  
  _impl_.channel_.Set(value, GetArenaForAllocation());
}
inline std::string* DataBlob::_internal_mutable_channel() {
  
  return _impl_.channel_.Mutable(GetArenaForAllocation());
}
inline std::string* DataBlob::release_channel() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataBlob.channel)
  return _impl_.channel_.Release();
}
inline void DataBlob::set_allocated_channel(std::string* channel) {
  if (channel != nullptr) {
    
  } else {
    
  }
  _impl_.channel_.SetAllocated(channel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.channel_.IsDefault()) {
    _impl_.channel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataBlob.channel)
}

// string type_id = 3;
inline void DataBlob::clear_type_id() {
  _impl_.type_id_.ClearToEmpty();
}
inline const std::string& DataBlob::type_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataBlob.type_id)
  return _internal_type_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataBlob::set_type_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.DataBlob.type_id)
}
inline std::string* DataBlob::mutable_type_id() {
  std::string* _s = _internal_mutable_type_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataBlob.type_id)
  return _s;
}
inline const std::string& DataBlob::_internal_type_id() const {
  return _impl_.type_id_.Get();
}
inline void DataBlob::_internal_set_type_id(const std::string& value) {
  
  _impl_.type_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DataBlob::_internal_mutable_type_id() {
  
  return _impl_.type_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DataBlob::release_type_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataBlob.type_id)
  return _impl_.type_id_.Release();
}
inline void DataBlob::set_allocated_type_id(std::string* type_id) {
  if (type_id != nullptr) {
    
  } else {
    
  }
  _impl_.type_id_.SetAllocated(type_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_id_.IsDefault()) {
    _impl_.type_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataBlob.type_id)
}

// bytes data = 4;
inline void DataBlob::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& DataBlob::data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataBlob.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataBlob::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.DataBlob.data)
}
inline std::string* DataBlob::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataBlob.data)
  return _s;
}
inline const std::string& DataBlob::_internal_data() const {
  return _impl_.data_.Get();
}
inline void DataBlob::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* DataBlob::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* DataBlob::release_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataBlob.data)
  return _impl_.data_.Release();
}
inline void DataBlob::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataBlob.data)
}

// -------------------------------------------------------------------

// SignalSchema_Variable

// string name = 1;
inline void SignalSchema_Variable::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SignalSchema_Variable::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SignalSchema.Variable.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignalSchema_Variable::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.SignalSchema.Variable.name)
}
inline std::string* SignalSchema_Variable::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SignalSchema.Variable.name)
  return _s;
}
inline const std::string& SignalSchema_Variable::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SignalSchema_Variable::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SignalSchema_Variable::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SignalSchema_Variable::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SignalSchema.Variable.name)
  return _impl_.name_.Release();
}
inline void SignalSchema_Variable::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SignalSchema.Variable.name)
}

// .bosdyn.api.SignalSchema.Variable.Type type = 2;
inline void SignalSchema_Variable::clear_type() {
  _impl_.type_ = 0;
}
inline ::bosdyn::api::SignalSchema_Variable_Type SignalSchema_Variable::_internal_type() const {
  return static_cast< ::bosdyn::api::SignalSchema_Variable_Type >(_impl_.type_);
}
inline ::bosdyn::api::SignalSchema_Variable_Type SignalSchema_Variable::type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SignalSchema.Variable.type)
  return _internal_type();
}
inline void SignalSchema_Variable::_internal_set_type(::bosdyn::api::SignalSchema_Variable_Type value) {
  
  _impl_.type_ = value;
}
inline void SignalSchema_Variable::set_type(::bosdyn::api::SignalSchema_Variable_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SignalSchema.Variable.type)
}

// bool is_time = 3;
inline void SignalSchema_Variable::clear_is_time() {
  _impl_.is_time_ = false;
}
inline bool SignalSchema_Variable::_internal_is_time() const {
  return _impl_.is_time_;
}
inline bool SignalSchema_Variable::is_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SignalSchema.Variable.is_time)
  return _internal_is_time();
}
inline void SignalSchema_Variable::_internal_set_is_time(bool value) {
  
  _impl_.is_time_ = value;
}
inline void SignalSchema_Variable::set_is_time(bool value) {
  _internal_set_is_time(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SignalSchema.Variable.is_time)
}

// -------------------------------------------------------------------

// SignalSchema

// repeated .bosdyn.api.SignalSchema.Variable vars = 1;
inline int SignalSchema::_internal_vars_size() const {
  return _impl_.vars_.size();
}
inline int SignalSchema::vars_size() const {
  return _internal_vars_size();
}
inline void SignalSchema::clear_vars() {
  _impl_.vars_.Clear();
}
inline ::bosdyn::api::SignalSchema_Variable* SignalSchema::mutable_vars(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SignalSchema.vars)
  return _impl_.vars_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SignalSchema_Variable >*
SignalSchema::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.SignalSchema.vars)
  return &_impl_.vars_;
}
inline const ::bosdyn::api::SignalSchema_Variable& SignalSchema::_internal_vars(int index) const {
  return _impl_.vars_.Get(index);
}
inline const ::bosdyn::api::SignalSchema_Variable& SignalSchema::vars(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SignalSchema.vars)
  return _internal_vars(index);
}
inline ::bosdyn::api::SignalSchema_Variable* SignalSchema::_internal_add_vars() {
  return _impl_.vars_.Add();
}
inline ::bosdyn::api::SignalSchema_Variable* SignalSchema::add_vars() {
  ::bosdyn::api::SignalSchema_Variable* _add = _internal_add_vars();
  // @@protoc_insertion_point(field_add:bosdyn.api.SignalSchema.vars)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SignalSchema_Variable >&
SignalSchema::vars() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.SignalSchema.vars)
  return _impl_.vars_;
}

// string schema_name = 2;
inline void SignalSchema::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& SignalSchema::schema_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SignalSchema.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignalSchema::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.SignalSchema.schema_name)
}
inline std::string* SignalSchema::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SignalSchema.schema_name)
  return _s;
}
inline const std::string& SignalSchema::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void SignalSchema::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SignalSchema::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SignalSchema::release_schema_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SignalSchema.schema_name)
  return _impl_.schema_name_.Release();
}
inline void SignalSchema::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SignalSchema.schema_name)
}

// -------------------------------------------------------------------

// SignalSchemaId

// uint64 schema_id = 1;
inline void SignalSchemaId::clear_schema_id() {
  _impl_.schema_id_ = uint64_t{0u};
}
inline uint64_t SignalSchemaId::_internal_schema_id() const {
  return _impl_.schema_id_;
}
inline uint64_t SignalSchemaId::schema_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SignalSchemaId.schema_id)
  return _internal_schema_id();
}
inline void SignalSchemaId::_internal_set_schema_id(uint64_t value) {
  
  _impl_.schema_id_ = value;
}
inline void SignalSchemaId::set_schema_id(uint64_t value) {
  _internal_set_schema_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SignalSchemaId.schema_id)
}

// .bosdyn.api.SignalSchema schema = 2;
inline bool SignalSchemaId::_internal_has_schema() const {
  return this != internal_default_instance() && _impl_.schema_ != nullptr;
}
inline bool SignalSchemaId::has_schema() const {
  return _internal_has_schema();
}
inline void SignalSchemaId::clear_schema() {
  if (GetArenaForAllocation() == nullptr && _impl_.schema_ != nullptr) {
    delete _impl_.schema_;
  }
  _impl_.schema_ = nullptr;
}
inline const ::bosdyn::api::SignalSchema& SignalSchemaId::_internal_schema() const {
  const ::bosdyn::api::SignalSchema* p = _impl_.schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SignalSchema&>(
      ::bosdyn::api::_SignalSchema_default_instance_);
}
inline const ::bosdyn::api::SignalSchema& SignalSchemaId::schema() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SignalSchemaId.schema)
  return _internal_schema();
}
inline void SignalSchemaId::unsafe_arena_set_allocated_schema(
    ::bosdyn::api::SignalSchema* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_);
  }
  _impl_.schema_ = schema;
  if (schema) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SignalSchemaId.schema)
}
inline ::bosdyn::api::SignalSchema* SignalSchemaId::release_schema() {
  
  ::bosdyn::api::SignalSchema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SignalSchema* SignalSchemaId::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SignalSchemaId.schema)
  
  ::bosdyn::api::SignalSchema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SignalSchema* SignalSchemaId::_internal_mutable_schema() {
  
  if (_impl_.schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SignalSchema>(GetArenaForAllocation());
    _impl_.schema_ = p;
  }
  return _impl_.schema_;
}
inline ::bosdyn::api::SignalSchema* SignalSchemaId::mutable_schema() {
  ::bosdyn::api::SignalSchema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SignalSchemaId.schema)
  return _msg;
}
inline void SignalSchemaId::set_allocated_schema(::bosdyn::api::SignalSchema* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SignalSchemaId.schema)
}

// -------------------------------------------------------------------

// SignalTick

// int64 sequence_id = 1;
inline void SignalTick::clear_sequence_id() {
  _impl_.sequence_id_ = int64_t{0};
}
inline int64_t SignalTick::_internal_sequence_id() const {
  return _impl_.sequence_id_;
}
inline int64_t SignalTick::sequence_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SignalTick.sequence_id)
  return _internal_sequence_id();
}
inline void SignalTick::_internal_set_sequence_id(int64_t value) {
  
  _impl_.sequence_id_ = value;
}
inline void SignalTick::set_sequence_id(int64_t value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SignalTick.sequence_id)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool SignalTick::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool SignalTick::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SignalTick::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SignalTick::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SignalTick.timestamp)
  return _internal_timestamp();
}
inline void SignalTick::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SignalTick.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SignalTick::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SignalTick::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SignalTick.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SignalTick::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SignalTick::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SignalTick.timestamp)
  return _msg;
}
inline void SignalTick::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SignalTick.timestamp)
}

// string source = 3;
inline void SignalTick::clear_source() {
  _impl_.source_.ClearToEmpty();
}
inline const std::string& SignalTick::source() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SignalTick.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignalTick::set_source(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.SignalTick.source)
}
inline std::string* SignalTick::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SignalTick.source)
  return _s;
}
inline const std::string& SignalTick::_internal_source() const {
  return _impl_.source_.Get();
}
inline void SignalTick::_internal_set_source(const std::string& value) {
  
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* SignalTick::_internal_mutable_source() {
  
  return _impl_.source_.Mutable(GetArenaForAllocation());
}
inline std::string* SignalTick::release_source() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SignalTick.source)
  return _impl_.source_.Release();
}
inline void SignalTick::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  _impl_.source_.SetAllocated(source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SignalTick.source)
}

// uint64 schema_id = 4;
inline void SignalTick::clear_schema_id() {
  _impl_.schema_id_ = uint64_t{0u};
}
inline uint64_t SignalTick::_internal_schema_id() const {
  return _impl_.schema_id_;
}
inline uint64_t SignalTick::schema_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SignalTick.schema_id)
  return _internal_schema_id();
}
inline void SignalTick::_internal_set_schema_id(uint64_t value) {
  
  _impl_.schema_id_ = value;
}
inline void SignalTick::set_schema_id(uint64_t value) {
  _internal_set_schema_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SignalTick.schema_id)
}

// .bosdyn.api.SignalTick.Encoding encoding = 5;
inline void SignalTick::clear_encoding() {
  _impl_.encoding_ = 0;
}
inline ::bosdyn::api::SignalTick_Encoding SignalTick::_internal_encoding() const {
  return static_cast< ::bosdyn::api::SignalTick_Encoding >(_impl_.encoding_);
}
inline ::bosdyn::api::SignalTick_Encoding SignalTick::encoding() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SignalTick.encoding)
  return _internal_encoding();
}
inline void SignalTick::_internal_set_encoding(::bosdyn::api::SignalTick_Encoding value) {
  
  _impl_.encoding_ = value;
}
inline void SignalTick::set_encoding(::bosdyn::api::SignalTick_Encoding value) {
  _internal_set_encoding(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SignalTick.encoding)
}

// bytes data = 6;
inline void SignalTick::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& SignalTick::data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SignalTick.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignalTick::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.SignalTick.data)
}
inline std::string* SignalTick::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SignalTick.data)
  return _s;
}
inline const std::string& SignalTick::_internal_data() const {
  return _impl_.data_.Get();
}
inline void SignalTick::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* SignalTick::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* SignalTick::release_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SignalTick.data)
  return _impl_.data_.Release();
}
inline void SignalTick::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SignalTick.data)
}

// -------------------------------------------------------------------

// Event

// string type = 1;
inline void Event::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Event::type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Event.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.Event.type)
}
inline std::string* Event::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Event.type)
  return _s;
}
inline const std::string& Event::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Event::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Event::release_type() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Event.type)
  return _impl_.type_.Release();
}
inline void Event::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Event.type)
}

// string description = 2;
inline void Event::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Event::description() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Event.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.Event.description)
}
inline std::string* Event::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Event.description)
  return _s;
}
inline const std::string& Event::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Event::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Event::release_description() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Event.description)
  return _impl_.description_.Release();
}
inline void Event::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Event.description)
}

// string source = 3;
inline void Event::clear_source() {
  _impl_.source_.ClearToEmpty();
}
inline const std::string& Event::source() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Event.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_source(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.Event.source)
}
inline std::string* Event::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Event.source)
  return _s;
}
inline const std::string& Event::_internal_source() const {
  return _impl_.source_.Get();
}
inline void Event::_internal_set_source(const std::string& value) {
  
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_source() {
  
  return _impl_.source_.Mutable(GetArenaForAllocation());
}
inline std::string* Event::release_source() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Event.source)
  return _impl_.source_.Release();
}
inline void Event::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  _impl_.source_.SetAllocated(source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Event.source)
}

// string id = 4;
inline void Event::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Event::id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Event.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.Event.id)
}
inline std::string* Event::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Event.id)
  return _s;
}
inline const std::string& Event::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Event::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Event::release_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Event.id)
  return _impl_.id_.Release();
}
inline void Event::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Event.id)
}

// .google.protobuf.Timestamp start_time = 5;
inline bool Event::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool Event::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Event::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Event::start_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Event.start_time)
  return _internal_start_time();
}
inline void Event::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Event.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Event::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Event::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Event.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Event::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Event::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Event.start_time)
  return _msg;
}
inline void Event::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Event.start_time)
}

// .google.protobuf.Timestamp end_time = 6;
inline bool Event::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool Event::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Event::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Event::end_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Event.end_time)
  return _internal_end_time();
}
inline void Event::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Event.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Event::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Event::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Event.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Event::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Event::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Event.end_time)
  return _msg;
}
inline void Event::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Event.end_time)
}

// .bosdyn.api.Event.Level level = 7;
inline void Event::clear_level() {
  _impl_.level_ = 0;
}
inline ::bosdyn::api::Event_Level Event::_internal_level() const {
  return static_cast< ::bosdyn::api::Event_Level >(_impl_.level_);
}
inline ::bosdyn::api::Event_Level Event::level() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Event.level)
  return _internal_level();
}
inline void Event::_internal_set_level(::bosdyn::api::Event_Level value) {
  
  _impl_.level_ = value;
}
inline void Event::set_level(::bosdyn::api::Event_Level value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Event.level)
}

// repeated .bosdyn.api.Parameter parameters = 8;
inline int Event::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int Event::parameters_size() const {
  return _internal_parameters_size();
}
inline ::bosdyn::api::Parameter* Event::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Event.parameters)
  return _impl_.parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Parameter >*
Event::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.Event.parameters)
  return &_impl_.parameters_;
}
inline const ::bosdyn::api::Parameter& Event::_internal_parameters(int index) const {
  return _impl_.parameters_.Get(index);
}
inline const ::bosdyn::api::Parameter& Event::parameters(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Event.parameters)
  return _internal_parameters(index);
}
inline ::bosdyn::api::Parameter* Event::_internal_add_parameters() {
  return _impl_.parameters_.Add();
}
inline ::bosdyn::api::Parameter* Event::add_parameters() {
  ::bosdyn::api::Parameter* _add = _internal_add_parameters();
  // @@protoc_insertion_point(field_add:bosdyn.api.Event.parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Parameter >&
Event::parameters() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.Event.parameters)
  return _impl_.parameters_;
}

// .bosdyn.api.Event.LogPreserveHint log_preserve_hint = 9;
inline void Event::clear_log_preserve_hint() {
  _impl_.log_preserve_hint_ = 0;
}
inline ::bosdyn::api::Event_LogPreserveHint Event::_internal_log_preserve_hint() const {
  return static_cast< ::bosdyn::api::Event_LogPreserveHint >(_impl_.log_preserve_hint_);
}
inline ::bosdyn::api::Event_LogPreserveHint Event::log_preserve_hint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Event.log_preserve_hint)
  return _internal_log_preserve_hint();
}
inline void Event::_internal_set_log_preserve_hint(::bosdyn::api::Event_LogPreserveHint value) {
  
  _impl_.log_preserve_hint_ = value;
}
inline void Event::set_log_preserve_hint(::bosdyn::api::Event_LogPreserveHint value) {
  _internal_set_log_preserve_hint(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Event.log_preserve_hint)
}

// -------------------------------------------------------------------

// RecordTextMessagesResponse_Error

// .bosdyn.api.RecordTextMessagesResponse.Error.Type type = 1;
inline void RecordTextMessagesResponse_Error::clear_type() {
  _impl_.type_ = 0;
}
inline ::bosdyn::api::RecordTextMessagesResponse_Error_Type RecordTextMessagesResponse_Error::_internal_type() const {
  return static_cast< ::bosdyn::api::RecordTextMessagesResponse_Error_Type >(_impl_.type_);
}
inline ::bosdyn::api::RecordTextMessagesResponse_Error_Type RecordTextMessagesResponse_Error::type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordTextMessagesResponse.Error.type)
  return _internal_type();
}
inline void RecordTextMessagesResponse_Error::_internal_set_type(::bosdyn::api::RecordTextMessagesResponse_Error_Type value) {
  
  _impl_.type_ = value;
}
inline void RecordTextMessagesResponse_Error::set_type(::bosdyn::api::RecordTextMessagesResponse_Error_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RecordTextMessagesResponse.Error.type)
}

// string message = 2;
inline void RecordTextMessagesResponse_Error::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RecordTextMessagesResponse_Error::message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordTextMessagesResponse.Error.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecordTextMessagesResponse_Error::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.RecordTextMessagesResponse.Error.message)
}
inline std::string* RecordTextMessagesResponse_Error::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordTextMessagesResponse.Error.message)
  return _s;
}
inline const std::string& RecordTextMessagesResponse_Error::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RecordTextMessagesResponse_Error::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RecordTextMessagesResponse_Error::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* RecordTextMessagesResponse_Error::release_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RecordTextMessagesResponse.Error.message)
  return _impl_.message_.Release();
}
inline void RecordTextMessagesResponse_Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RecordTextMessagesResponse.Error.message)
}

// uint32 index = 3;
inline void RecordTextMessagesResponse_Error::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t RecordTextMessagesResponse_Error::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t RecordTextMessagesResponse_Error::index() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordTextMessagesResponse.Error.index)
  return _internal_index();
}
inline void RecordTextMessagesResponse_Error::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void RecordTextMessagesResponse_Error::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RecordTextMessagesResponse.Error.index)
}

// -------------------------------------------------------------------

// RecordTextMessagesResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RecordTextMessagesResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RecordTextMessagesResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RecordTextMessagesResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RecordTextMessagesResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordTextMessagesResponse.header)
  return _internal_header();
}
inline void RecordTextMessagesResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RecordTextMessagesResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RecordTextMessagesResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RecordTextMessagesResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RecordTextMessagesResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RecordTextMessagesResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* RecordTextMessagesResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordTextMessagesResponse.header)
  return _msg;
}
inline void RecordTextMessagesResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RecordTextMessagesResponse.header)
}

// repeated .bosdyn.api.RecordTextMessagesResponse.Error errors = 2;
inline int RecordTextMessagesResponse::_internal_errors_size() const {
  return _impl_.errors_.size();
}
inline int RecordTextMessagesResponse::errors_size() const {
  return _internal_errors_size();
}
inline void RecordTextMessagesResponse::clear_errors() {
  _impl_.errors_.Clear();
}
inline ::bosdyn::api::RecordTextMessagesResponse_Error* RecordTextMessagesResponse::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordTextMessagesResponse.errors)
  return _impl_.errors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordTextMessagesResponse_Error >*
RecordTextMessagesResponse::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RecordTextMessagesResponse.errors)
  return &_impl_.errors_;
}
inline const ::bosdyn::api::RecordTextMessagesResponse_Error& RecordTextMessagesResponse::_internal_errors(int index) const {
  return _impl_.errors_.Get(index);
}
inline const ::bosdyn::api::RecordTextMessagesResponse_Error& RecordTextMessagesResponse::errors(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordTextMessagesResponse.errors)
  return _internal_errors(index);
}
inline ::bosdyn::api::RecordTextMessagesResponse_Error* RecordTextMessagesResponse::_internal_add_errors() {
  return _impl_.errors_.Add();
}
inline ::bosdyn::api::RecordTextMessagesResponse_Error* RecordTextMessagesResponse::add_errors() {
  ::bosdyn::api::RecordTextMessagesResponse_Error* _add = _internal_add_errors();
  // @@protoc_insertion_point(field_add:bosdyn.api.RecordTextMessagesResponse.errors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordTextMessagesResponse_Error >&
RecordTextMessagesResponse::errors() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RecordTextMessagesResponse.errors)
  return _impl_.errors_;
}

// -------------------------------------------------------------------

// RecordOperatorCommentsResponse_Error

// .bosdyn.api.RecordOperatorCommentsResponse.Error.Type type = 1;
inline void RecordOperatorCommentsResponse_Error::clear_type() {
  _impl_.type_ = 0;
}
inline ::bosdyn::api::RecordOperatorCommentsResponse_Error_Type RecordOperatorCommentsResponse_Error::_internal_type() const {
  return static_cast< ::bosdyn::api::RecordOperatorCommentsResponse_Error_Type >(_impl_.type_);
}
inline ::bosdyn::api::RecordOperatorCommentsResponse_Error_Type RecordOperatorCommentsResponse_Error::type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordOperatorCommentsResponse.Error.type)
  return _internal_type();
}
inline void RecordOperatorCommentsResponse_Error::_internal_set_type(::bosdyn::api::RecordOperatorCommentsResponse_Error_Type value) {
  
  _impl_.type_ = value;
}
inline void RecordOperatorCommentsResponse_Error::set_type(::bosdyn::api::RecordOperatorCommentsResponse_Error_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RecordOperatorCommentsResponse.Error.type)
}

// string message = 2;
inline void RecordOperatorCommentsResponse_Error::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RecordOperatorCommentsResponse_Error::message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordOperatorCommentsResponse.Error.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecordOperatorCommentsResponse_Error::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.RecordOperatorCommentsResponse.Error.message)
}
inline std::string* RecordOperatorCommentsResponse_Error::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordOperatorCommentsResponse.Error.message)
  return _s;
}
inline const std::string& RecordOperatorCommentsResponse_Error::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RecordOperatorCommentsResponse_Error::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RecordOperatorCommentsResponse_Error::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* RecordOperatorCommentsResponse_Error::release_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RecordOperatorCommentsResponse.Error.message)
  return _impl_.message_.Release();
}
inline void RecordOperatorCommentsResponse_Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RecordOperatorCommentsResponse.Error.message)
}

// uint32 index = 3;
inline void RecordOperatorCommentsResponse_Error::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t RecordOperatorCommentsResponse_Error::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t RecordOperatorCommentsResponse_Error::index() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordOperatorCommentsResponse.Error.index)
  return _internal_index();
}
inline void RecordOperatorCommentsResponse_Error::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void RecordOperatorCommentsResponse_Error::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RecordOperatorCommentsResponse.Error.index)
}

// -------------------------------------------------------------------

// RecordOperatorCommentsResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RecordOperatorCommentsResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RecordOperatorCommentsResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RecordOperatorCommentsResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RecordOperatorCommentsResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordOperatorCommentsResponse.header)
  return _internal_header();
}
inline void RecordOperatorCommentsResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RecordOperatorCommentsResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RecordOperatorCommentsResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RecordOperatorCommentsResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RecordOperatorCommentsResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RecordOperatorCommentsResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* RecordOperatorCommentsResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordOperatorCommentsResponse.header)
  return _msg;
}
inline void RecordOperatorCommentsResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RecordOperatorCommentsResponse.header)
}

// repeated .bosdyn.api.RecordOperatorCommentsResponse.Error errors = 2;
inline int RecordOperatorCommentsResponse::_internal_errors_size() const {
  return _impl_.errors_.size();
}
inline int RecordOperatorCommentsResponse::errors_size() const {
  return _internal_errors_size();
}
inline void RecordOperatorCommentsResponse::clear_errors() {
  _impl_.errors_.Clear();
}
inline ::bosdyn::api::RecordOperatorCommentsResponse_Error* RecordOperatorCommentsResponse::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordOperatorCommentsResponse.errors)
  return _impl_.errors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordOperatorCommentsResponse_Error >*
RecordOperatorCommentsResponse::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RecordOperatorCommentsResponse.errors)
  return &_impl_.errors_;
}
inline const ::bosdyn::api::RecordOperatorCommentsResponse_Error& RecordOperatorCommentsResponse::_internal_errors(int index) const {
  return _impl_.errors_.Get(index);
}
inline const ::bosdyn::api::RecordOperatorCommentsResponse_Error& RecordOperatorCommentsResponse::errors(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordOperatorCommentsResponse.errors)
  return _internal_errors(index);
}
inline ::bosdyn::api::RecordOperatorCommentsResponse_Error* RecordOperatorCommentsResponse::_internal_add_errors() {
  return _impl_.errors_.Add();
}
inline ::bosdyn::api::RecordOperatorCommentsResponse_Error* RecordOperatorCommentsResponse::add_errors() {
  ::bosdyn::api::RecordOperatorCommentsResponse_Error* _add = _internal_add_errors();
  // @@protoc_insertion_point(field_add:bosdyn.api.RecordOperatorCommentsResponse.errors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordOperatorCommentsResponse_Error >&
RecordOperatorCommentsResponse::errors() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RecordOperatorCommentsResponse.errors)
  return _impl_.errors_;
}

// -------------------------------------------------------------------

// RecordDataBlobsResponse_Error

// .bosdyn.api.RecordDataBlobsResponse.Error.Type type = 1;
inline void RecordDataBlobsResponse_Error::clear_type() {
  _impl_.type_ = 0;
}
inline ::bosdyn::api::RecordDataBlobsResponse_Error_Type RecordDataBlobsResponse_Error::_internal_type() const {
  return static_cast< ::bosdyn::api::RecordDataBlobsResponse_Error_Type >(_impl_.type_);
}
inline ::bosdyn::api::RecordDataBlobsResponse_Error_Type RecordDataBlobsResponse_Error::type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordDataBlobsResponse.Error.type)
  return _internal_type();
}
inline void RecordDataBlobsResponse_Error::_internal_set_type(::bosdyn::api::RecordDataBlobsResponse_Error_Type value) {
  
  _impl_.type_ = value;
}
inline void RecordDataBlobsResponse_Error::set_type(::bosdyn::api::RecordDataBlobsResponse_Error_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RecordDataBlobsResponse.Error.type)
}

// string message = 2;
inline void RecordDataBlobsResponse_Error::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RecordDataBlobsResponse_Error::message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordDataBlobsResponse.Error.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecordDataBlobsResponse_Error::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.RecordDataBlobsResponse.Error.message)
}
inline std::string* RecordDataBlobsResponse_Error::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordDataBlobsResponse.Error.message)
  return _s;
}
inline const std::string& RecordDataBlobsResponse_Error::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RecordDataBlobsResponse_Error::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RecordDataBlobsResponse_Error::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* RecordDataBlobsResponse_Error::release_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RecordDataBlobsResponse.Error.message)
  return _impl_.message_.Release();
}
inline void RecordDataBlobsResponse_Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RecordDataBlobsResponse.Error.message)
}

// uint32 index = 3;
inline void RecordDataBlobsResponse_Error::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t RecordDataBlobsResponse_Error::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t RecordDataBlobsResponse_Error::index() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordDataBlobsResponse.Error.index)
  return _internal_index();
}
inline void RecordDataBlobsResponse_Error::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void RecordDataBlobsResponse_Error::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RecordDataBlobsResponse.Error.index)
}

// -------------------------------------------------------------------

// RecordDataBlobsResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RecordDataBlobsResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RecordDataBlobsResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RecordDataBlobsResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RecordDataBlobsResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordDataBlobsResponse.header)
  return _internal_header();
}
inline void RecordDataBlobsResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RecordDataBlobsResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RecordDataBlobsResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RecordDataBlobsResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RecordDataBlobsResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RecordDataBlobsResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* RecordDataBlobsResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordDataBlobsResponse.header)
  return _msg;
}
inline void RecordDataBlobsResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RecordDataBlobsResponse.header)
}

// repeated .bosdyn.api.RecordDataBlobsResponse.Error errors = 2;
inline int RecordDataBlobsResponse::_internal_errors_size() const {
  return _impl_.errors_.size();
}
inline int RecordDataBlobsResponse::errors_size() const {
  return _internal_errors_size();
}
inline void RecordDataBlobsResponse::clear_errors() {
  _impl_.errors_.Clear();
}
inline ::bosdyn::api::RecordDataBlobsResponse_Error* RecordDataBlobsResponse::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordDataBlobsResponse.errors)
  return _impl_.errors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordDataBlobsResponse_Error >*
RecordDataBlobsResponse::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RecordDataBlobsResponse.errors)
  return &_impl_.errors_;
}
inline const ::bosdyn::api::RecordDataBlobsResponse_Error& RecordDataBlobsResponse::_internal_errors(int index) const {
  return _impl_.errors_.Get(index);
}
inline const ::bosdyn::api::RecordDataBlobsResponse_Error& RecordDataBlobsResponse::errors(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordDataBlobsResponse.errors)
  return _internal_errors(index);
}
inline ::bosdyn::api::RecordDataBlobsResponse_Error* RecordDataBlobsResponse::_internal_add_errors() {
  return _impl_.errors_.Add();
}
inline ::bosdyn::api::RecordDataBlobsResponse_Error* RecordDataBlobsResponse::add_errors() {
  ::bosdyn::api::RecordDataBlobsResponse_Error* _add = _internal_add_errors();
  // @@protoc_insertion_point(field_add:bosdyn.api.RecordDataBlobsResponse.errors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordDataBlobsResponse_Error >&
RecordDataBlobsResponse::errors() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RecordDataBlobsResponse.errors)
  return _impl_.errors_;
}

// -------------------------------------------------------------------

// RecordSignalTicksResponse_Error

// .bosdyn.api.RecordSignalTicksResponse.Error.Type type = 1;
inline void RecordSignalTicksResponse_Error::clear_type() {
  _impl_.type_ = 0;
}
inline ::bosdyn::api::RecordSignalTicksResponse_Error_Type RecordSignalTicksResponse_Error::_internal_type() const {
  return static_cast< ::bosdyn::api::RecordSignalTicksResponse_Error_Type >(_impl_.type_);
}
inline ::bosdyn::api::RecordSignalTicksResponse_Error_Type RecordSignalTicksResponse_Error::type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordSignalTicksResponse.Error.type)
  return _internal_type();
}
inline void RecordSignalTicksResponse_Error::_internal_set_type(::bosdyn::api::RecordSignalTicksResponse_Error_Type value) {
  
  _impl_.type_ = value;
}
inline void RecordSignalTicksResponse_Error::set_type(::bosdyn::api::RecordSignalTicksResponse_Error_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RecordSignalTicksResponse.Error.type)
}

// string message = 2;
inline void RecordSignalTicksResponse_Error::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RecordSignalTicksResponse_Error::message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordSignalTicksResponse.Error.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecordSignalTicksResponse_Error::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.RecordSignalTicksResponse.Error.message)
}
inline std::string* RecordSignalTicksResponse_Error::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordSignalTicksResponse.Error.message)
  return _s;
}
inline const std::string& RecordSignalTicksResponse_Error::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RecordSignalTicksResponse_Error::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RecordSignalTicksResponse_Error::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* RecordSignalTicksResponse_Error::release_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RecordSignalTicksResponse.Error.message)
  return _impl_.message_.Release();
}
inline void RecordSignalTicksResponse_Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RecordSignalTicksResponse.Error.message)
}

// uint32 index = 3;
inline void RecordSignalTicksResponse_Error::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t RecordSignalTicksResponse_Error::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t RecordSignalTicksResponse_Error::index() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordSignalTicksResponse.Error.index)
  return _internal_index();
}
inline void RecordSignalTicksResponse_Error::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void RecordSignalTicksResponse_Error::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RecordSignalTicksResponse.Error.index)
}

// -------------------------------------------------------------------

// RecordSignalTicksResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RecordSignalTicksResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RecordSignalTicksResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RecordSignalTicksResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RecordSignalTicksResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordSignalTicksResponse.header)
  return _internal_header();
}
inline void RecordSignalTicksResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RecordSignalTicksResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RecordSignalTicksResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RecordSignalTicksResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RecordSignalTicksResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RecordSignalTicksResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* RecordSignalTicksResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordSignalTicksResponse.header)
  return _msg;
}
inline void RecordSignalTicksResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RecordSignalTicksResponse.header)
}

// repeated .bosdyn.api.RecordSignalTicksResponse.Error errors = 2;
inline int RecordSignalTicksResponse::_internal_errors_size() const {
  return _impl_.errors_.size();
}
inline int RecordSignalTicksResponse::errors_size() const {
  return _internal_errors_size();
}
inline void RecordSignalTicksResponse::clear_errors() {
  _impl_.errors_.Clear();
}
inline ::bosdyn::api::RecordSignalTicksResponse_Error* RecordSignalTicksResponse::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordSignalTicksResponse.errors)
  return _impl_.errors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordSignalTicksResponse_Error >*
RecordSignalTicksResponse::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RecordSignalTicksResponse.errors)
  return &_impl_.errors_;
}
inline const ::bosdyn::api::RecordSignalTicksResponse_Error& RecordSignalTicksResponse::_internal_errors(int index) const {
  return _impl_.errors_.Get(index);
}
inline const ::bosdyn::api::RecordSignalTicksResponse_Error& RecordSignalTicksResponse::errors(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordSignalTicksResponse.errors)
  return _internal_errors(index);
}
inline ::bosdyn::api::RecordSignalTicksResponse_Error* RecordSignalTicksResponse::_internal_add_errors() {
  return _impl_.errors_.Add();
}
inline ::bosdyn::api::RecordSignalTicksResponse_Error* RecordSignalTicksResponse::add_errors() {
  ::bosdyn::api::RecordSignalTicksResponse_Error* _add = _internal_add_errors();
  // @@protoc_insertion_point(field_add:bosdyn.api.RecordSignalTicksResponse.errors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordSignalTicksResponse_Error >&
RecordSignalTicksResponse::errors() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RecordSignalTicksResponse.errors)
  return _impl_.errors_;
}

// -------------------------------------------------------------------

// RecordEventsResponse_Error

// .bosdyn.api.RecordEventsResponse.Error.Type type = 1;
inline void RecordEventsResponse_Error::clear_type() {
  _impl_.type_ = 0;
}
inline ::bosdyn::api::RecordEventsResponse_Error_Type RecordEventsResponse_Error::_internal_type() const {
  return static_cast< ::bosdyn::api::RecordEventsResponse_Error_Type >(_impl_.type_);
}
inline ::bosdyn::api::RecordEventsResponse_Error_Type RecordEventsResponse_Error::type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordEventsResponse.Error.type)
  return _internal_type();
}
inline void RecordEventsResponse_Error::_internal_set_type(::bosdyn::api::RecordEventsResponse_Error_Type value) {
  
  _impl_.type_ = value;
}
inline void RecordEventsResponse_Error::set_type(::bosdyn::api::RecordEventsResponse_Error_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RecordEventsResponse.Error.type)
}

// string message = 2;
inline void RecordEventsResponse_Error::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RecordEventsResponse_Error::message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordEventsResponse.Error.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecordEventsResponse_Error::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.RecordEventsResponse.Error.message)
}
inline std::string* RecordEventsResponse_Error::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordEventsResponse.Error.message)
  return _s;
}
inline const std::string& RecordEventsResponse_Error::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RecordEventsResponse_Error::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RecordEventsResponse_Error::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* RecordEventsResponse_Error::release_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RecordEventsResponse.Error.message)
  return _impl_.message_.Release();
}
inline void RecordEventsResponse_Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RecordEventsResponse.Error.message)
}

// uint32 index = 3;
inline void RecordEventsResponse_Error::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t RecordEventsResponse_Error::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t RecordEventsResponse_Error::index() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordEventsResponse.Error.index)
  return _internal_index();
}
inline void RecordEventsResponse_Error::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void RecordEventsResponse_Error::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RecordEventsResponse.Error.index)
}

// -------------------------------------------------------------------

// RecordEventsResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RecordEventsResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RecordEventsResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RecordEventsResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RecordEventsResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordEventsResponse.header)
  return _internal_header();
}
inline void RecordEventsResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RecordEventsResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RecordEventsResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RecordEventsResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RecordEventsResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RecordEventsResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* RecordEventsResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordEventsResponse.header)
  return _msg;
}
inline void RecordEventsResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RecordEventsResponse.header)
}

// repeated .bosdyn.api.RecordEventsResponse.Error errors = 2;
inline int RecordEventsResponse::_internal_errors_size() const {
  return _impl_.errors_.size();
}
inline int RecordEventsResponse::errors_size() const {
  return _internal_errors_size();
}
inline void RecordEventsResponse::clear_errors() {
  _impl_.errors_.Clear();
}
inline ::bosdyn::api::RecordEventsResponse_Error* RecordEventsResponse::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RecordEventsResponse.errors)
  return _impl_.errors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordEventsResponse_Error >*
RecordEventsResponse::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RecordEventsResponse.errors)
  return &_impl_.errors_;
}
inline const ::bosdyn::api::RecordEventsResponse_Error& RecordEventsResponse::_internal_errors(int index) const {
  return _impl_.errors_.Get(index);
}
inline const ::bosdyn::api::RecordEventsResponse_Error& RecordEventsResponse::errors(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RecordEventsResponse.errors)
  return _internal_errors(index);
}
inline ::bosdyn::api::RecordEventsResponse_Error* RecordEventsResponse::_internal_add_errors() {
  return _impl_.errors_.Add();
}
inline ::bosdyn::api::RecordEventsResponse_Error* RecordEventsResponse::add_errors() {
  ::bosdyn::api::RecordEventsResponse_Error* _add = _internal_add_errors();
  // @@protoc_insertion_point(field_add:bosdyn.api.RecordEventsResponse.errors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::RecordEventsResponse_Error >&
RecordEventsResponse::errors() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RecordEventsResponse.errors)
  return _impl_.errors_;
}

// -------------------------------------------------------------------

// RegisterSignalSchemaRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RegisterSignalSchemaRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RegisterSignalSchemaRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RegisterSignalSchemaRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RegisterSignalSchemaRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterSignalSchemaRequest.header)
  return _internal_header();
}
inline void RegisterSignalSchemaRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RegisterSignalSchemaRequest.header)
}
inline ::bosdyn::api::RequestHeader* RegisterSignalSchemaRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* RegisterSignalSchemaRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterSignalSchemaRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RegisterSignalSchemaRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* RegisterSignalSchemaRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterSignalSchemaRequest.header)
  return _msg;
}
inline void RegisterSignalSchemaRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterSignalSchemaRequest.header)
}

// .bosdyn.api.SignalSchema schema = 2;
inline bool RegisterSignalSchemaRequest::_internal_has_schema() const {
  return this != internal_default_instance() && _impl_.schema_ != nullptr;
}
inline bool RegisterSignalSchemaRequest::has_schema() const {
  return _internal_has_schema();
}
inline void RegisterSignalSchemaRequest::clear_schema() {
  if (GetArenaForAllocation() == nullptr && _impl_.schema_ != nullptr) {
    delete _impl_.schema_;
  }
  _impl_.schema_ = nullptr;
}
inline const ::bosdyn::api::SignalSchema& RegisterSignalSchemaRequest::_internal_schema() const {
  const ::bosdyn::api::SignalSchema* p = _impl_.schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SignalSchema&>(
      ::bosdyn::api::_SignalSchema_default_instance_);
}
inline const ::bosdyn::api::SignalSchema& RegisterSignalSchemaRequest::schema() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterSignalSchemaRequest.schema)
  return _internal_schema();
}
inline void RegisterSignalSchemaRequest::unsafe_arena_set_allocated_schema(
    ::bosdyn::api::SignalSchema* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_);
  }
  _impl_.schema_ = schema;
  if (schema) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RegisterSignalSchemaRequest.schema)
}
inline ::bosdyn::api::SignalSchema* RegisterSignalSchemaRequest::release_schema() {
  
  ::bosdyn::api::SignalSchema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SignalSchema* RegisterSignalSchemaRequest::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterSignalSchemaRequest.schema)
  
  ::bosdyn::api::SignalSchema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SignalSchema* RegisterSignalSchemaRequest::_internal_mutable_schema() {
  
  if (_impl_.schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SignalSchema>(GetArenaForAllocation());
    _impl_.schema_ = p;
  }
  return _impl_.schema_;
}
inline ::bosdyn::api::SignalSchema* RegisterSignalSchemaRequest::mutable_schema() {
  ::bosdyn::api::SignalSchema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterSignalSchemaRequest.schema)
  return _msg;
}
inline void RegisterSignalSchemaRequest::set_allocated_schema(::bosdyn::api::SignalSchema* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterSignalSchemaRequest.schema)
}

// -------------------------------------------------------------------

// RegisterSignalSchemaResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RegisterSignalSchemaResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RegisterSignalSchemaResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RegisterSignalSchemaResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RegisterSignalSchemaResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterSignalSchemaResponse.header)
  return _internal_header();
}
inline void RegisterSignalSchemaResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RegisterSignalSchemaResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RegisterSignalSchemaResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RegisterSignalSchemaResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterSignalSchemaResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RegisterSignalSchemaResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* RegisterSignalSchemaResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterSignalSchemaResponse.header)
  return _msg;
}
inline void RegisterSignalSchemaResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterSignalSchemaResponse.header)
}

// uint64 schema_id = 2;
inline void RegisterSignalSchemaResponse::clear_schema_id() {
  _impl_.schema_id_ = uint64_t{0u};
}
inline uint64_t RegisterSignalSchemaResponse::_internal_schema_id() const {
  return _impl_.schema_id_;
}
inline uint64_t RegisterSignalSchemaResponse::schema_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterSignalSchemaResponse.schema_id)
  return _internal_schema_id();
}
inline void RegisterSignalSchemaResponse::_internal_set_schema_id(uint64_t value) {
  
  _impl_.schema_id_ = value;
}
inline void RegisterSignalSchemaResponse::set_schema_id(uint64_t value) {
  _internal_set_schema_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RegisterSignalSchemaResponse.schema_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::TextMessage_Level> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::TextMessage_Level>() {
  return ::bosdyn::api::TextMessage_Level_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::SignalSchema_Variable_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::SignalSchema_Variable_Type>() {
  return ::bosdyn::api::SignalSchema_Variable_Type_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::SignalTick_Encoding> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::SignalTick_Encoding>() {
  return ::bosdyn::api::SignalTick_Encoding_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::Event_Level> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::Event_Level>() {
  return ::bosdyn::api::Event_Level_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::Event_LogPreserveHint> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::Event_LogPreserveHint>() {
  return ::bosdyn::api::Event_LogPreserveHint_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::RecordTextMessagesResponse_Error_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::RecordTextMessagesResponse_Error_Type>() {
  return ::bosdyn::api::RecordTextMessagesResponse_Error_Type_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::RecordOperatorCommentsResponse_Error_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::RecordOperatorCommentsResponse_Error_Type>() {
  return ::bosdyn::api::RecordOperatorCommentsResponse_Error_Type_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::RecordDataBlobsResponse_Error_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::RecordDataBlobsResponse_Error_Type>() {
  return ::bosdyn::api::RecordDataBlobsResponse_Error_Type_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::RecordSignalTicksResponse_Error_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::RecordSignalTicksResponse_Error_Type>() {
  return ::bosdyn::api::RecordSignalTicksResponse_Error_Type_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::RecordEventsResponse_Error_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::RecordEventsResponse_Error_Type>() {
  return ::bosdyn::api::RecordEventsResponse_Error_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fdata_5fbuffer_2eproto
