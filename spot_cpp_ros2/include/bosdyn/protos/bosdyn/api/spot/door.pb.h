// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/spot/door.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_2fdoor_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_2fdoor_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/basic_command.pb.h"
#include "bosdyn/api/geometry.pb.h"
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/lease.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fspot_2fdoor_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fspot_2fdoor_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fspot_2fdoor_2eproto;
namespace bosdyn {
namespace api {
namespace spot {
class DoorCommand;
struct DoorCommandDefaultTypeInternal;
extern DoorCommandDefaultTypeInternal _DoorCommand_default_instance_;
class DoorCommand_AutoGraspCommand;
struct DoorCommand_AutoGraspCommandDefaultTypeInternal;
extern DoorCommand_AutoGraspCommandDefaultTypeInternal _DoorCommand_AutoGraspCommand_default_instance_;
class DoorCommand_AutoPushCommand;
struct DoorCommand_AutoPushCommandDefaultTypeInternal;
extern DoorCommand_AutoPushCommandDefaultTypeInternal _DoorCommand_AutoPushCommand_default_instance_;
class DoorCommand_Feedback;
struct DoorCommand_FeedbackDefaultTypeInternal;
extern DoorCommand_FeedbackDefaultTypeInternal _DoorCommand_Feedback_default_instance_;
class DoorCommand_Request;
struct DoorCommand_RequestDefaultTypeInternal;
extern DoorCommand_RequestDefaultTypeInternal _DoorCommand_Request_default_instance_;
class DoorCommand_WarmstartCommand;
struct DoorCommand_WarmstartCommandDefaultTypeInternal;
extern DoorCommand_WarmstartCommandDefaultTypeInternal _DoorCommand_WarmstartCommand_default_instance_;
class OpenDoorCommandRequest;
struct OpenDoorCommandRequestDefaultTypeInternal;
extern OpenDoorCommandRequestDefaultTypeInternal _OpenDoorCommandRequest_default_instance_;
class OpenDoorCommandResponse;
struct OpenDoorCommandResponseDefaultTypeInternal;
extern OpenDoorCommandResponseDefaultTypeInternal _OpenDoorCommandResponse_default_instance_;
class OpenDoorFeedbackRequest;
struct OpenDoorFeedbackRequestDefaultTypeInternal;
extern OpenDoorFeedbackRequestDefaultTypeInternal _OpenDoorFeedbackRequest_default_instance_;
class OpenDoorFeedbackResponse;
struct OpenDoorFeedbackResponseDefaultTypeInternal;
extern OpenDoorFeedbackResponseDefaultTypeInternal _OpenDoorFeedbackResponse_default_instance_;
}  // namespace spot
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::spot::DoorCommand* Arena::CreateMaybeMessage<::bosdyn::api::spot::DoorCommand>(Arena*);
template<> ::bosdyn::api::spot::DoorCommand_AutoGraspCommand* Arena::CreateMaybeMessage<::bosdyn::api::spot::DoorCommand_AutoGraspCommand>(Arena*);
template<> ::bosdyn::api::spot::DoorCommand_AutoPushCommand* Arena::CreateMaybeMessage<::bosdyn::api::spot::DoorCommand_AutoPushCommand>(Arena*);
template<> ::bosdyn::api::spot::DoorCommand_Feedback* Arena::CreateMaybeMessage<::bosdyn::api::spot::DoorCommand_Feedback>(Arena*);
template<> ::bosdyn::api::spot::DoorCommand_Request* Arena::CreateMaybeMessage<::bosdyn::api::spot::DoorCommand_Request>(Arena*);
template<> ::bosdyn::api::spot::DoorCommand_WarmstartCommand* Arena::CreateMaybeMessage<::bosdyn::api::spot::DoorCommand_WarmstartCommand>(Arena*);
template<> ::bosdyn::api::spot::OpenDoorCommandRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::OpenDoorCommandRequest>(Arena*);
template<> ::bosdyn::api::spot::OpenDoorCommandResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::OpenDoorCommandResponse>(Arena*);
template<> ::bosdyn::api::spot::OpenDoorFeedbackRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::OpenDoorFeedbackRequest>(Arena*);
template<> ::bosdyn::api::spot::OpenDoorFeedbackResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::OpenDoorFeedbackResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {
namespace spot {

enum OpenDoorCommandResponse_Status : int {
  OpenDoorCommandResponse_Status_STATUS_UNKNOWN = 0,
  OpenDoorCommandResponse_Status_STATUS_OK = 1,
  OpenDoorCommandResponse_Status_STATUS_ROBOT_COMMAND_ERROR = 2,
  OpenDoorCommandResponse_Status_OpenDoorCommandResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OpenDoorCommandResponse_Status_OpenDoorCommandResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OpenDoorCommandResponse_Status_IsValid(int value);
constexpr OpenDoorCommandResponse_Status OpenDoorCommandResponse_Status_Status_MIN = OpenDoorCommandResponse_Status_STATUS_UNKNOWN;
constexpr OpenDoorCommandResponse_Status OpenDoorCommandResponse_Status_Status_MAX = OpenDoorCommandResponse_Status_STATUS_ROBOT_COMMAND_ERROR;
constexpr int OpenDoorCommandResponse_Status_Status_ARRAYSIZE = OpenDoorCommandResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OpenDoorCommandResponse_Status_descriptor();
template<typename T>
inline const std::string& OpenDoorCommandResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OpenDoorCommandResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OpenDoorCommandResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OpenDoorCommandResponse_Status_descriptor(), enum_t_value);
}
inline bool OpenDoorCommandResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OpenDoorCommandResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OpenDoorCommandResponse_Status>(
    OpenDoorCommandResponse_Status_descriptor(), name, value);
}
enum DoorCommand_Feedback_Status : int {
  DoorCommand_Feedback_Status_STATUS_UNKNOWN = 0,
  DoorCommand_Feedback_Status_STATUS_COMPLETED = 1,
  DoorCommand_Feedback_Status_STATUS_IN_PROGRESS = 2,
  DoorCommand_Feedback_Status_DoorCommand_Feedback_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DoorCommand_Feedback_Status_DoorCommand_Feedback_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DoorCommand_Feedback_Status_IsValid(int value);
constexpr DoorCommand_Feedback_Status DoorCommand_Feedback_Status_Status_MIN = DoorCommand_Feedback_Status_STATUS_UNKNOWN;
constexpr DoorCommand_Feedback_Status DoorCommand_Feedback_Status_Status_MAX = DoorCommand_Feedback_Status_STATUS_IN_PROGRESS;
constexpr int DoorCommand_Feedback_Status_Status_ARRAYSIZE = DoorCommand_Feedback_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DoorCommand_Feedback_Status_descriptor();
template<typename T>
inline const std::string& DoorCommand_Feedback_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DoorCommand_Feedback_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DoorCommand_Feedback_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DoorCommand_Feedback_Status_descriptor(), enum_t_value);
}
inline bool DoorCommand_Feedback_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DoorCommand_Feedback_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DoorCommand_Feedback_Status>(
    DoorCommand_Feedback_Status_descriptor(), name, value);
}
enum DoorCommand_HingeSide : int {
  DoorCommand_HingeSide_HINGE_SIDE_UNKNOWN = 0,
  DoorCommand_HingeSide_HINGE_SIDE_LEFT = 1,
  DoorCommand_HingeSide_HINGE_SIDE_RIGHT = 2,
  DoorCommand_HingeSide_DoorCommand_HingeSide_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DoorCommand_HingeSide_DoorCommand_HingeSide_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DoorCommand_HingeSide_IsValid(int value);
constexpr DoorCommand_HingeSide DoorCommand_HingeSide_HingeSide_MIN = DoorCommand_HingeSide_HINGE_SIDE_UNKNOWN;
constexpr DoorCommand_HingeSide DoorCommand_HingeSide_HingeSide_MAX = DoorCommand_HingeSide_HINGE_SIDE_RIGHT;
constexpr int DoorCommand_HingeSide_HingeSide_ARRAYSIZE = DoorCommand_HingeSide_HingeSide_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DoorCommand_HingeSide_descriptor();
template<typename T>
inline const std::string& DoorCommand_HingeSide_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DoorCommand_HingeSide>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DoorCommand_HingeSide_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DoorCommand_HingeSide_descriptor(), enum_t_value);
}
inline bool DoorCommand_HingeSide_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DoorCommand_HingeSide* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DoorCommand_HingeSide>(
    DoorCommand_HingeSide_descriptor(), name, value);
}
enum DoorCommand_SwingDirection : int {
  DoorCommand_SwingDirection_SWING_DIRECTION_UNKNOWN = 0,
  DoorCommand_SwingDirection_SWING_DIRECTION_INSWING PROTOBUF_DEPRECATED_ENUM = 1,
  DoorCommand_SwingDirection_SWING_DIRECTION_PULL = 1,
  DoorCommand_SwingDirection_SWING_DIRECTION_OUTSWING PROTOBUF_DEPRECATED_ENUM = 2,
  DoorCommand_SwingDirection_SWING_DIRECTION_PUSH = 2,
  DoorCommand_SwingDirection_DoorCommand_SwingDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DoorCommand_SwingDirection_DoorCommand_SwingDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DoorCommand_SwingDirection_IsValid(int value);
constexpr DoorCommand_SwingDirection DoorCommand_SwingDirection_SwingDirection_MIN = DoorCommand_SwingDirection_SWING_DIRECTION_UNKNOWN;
constexpr DoorCommand_SwingDirection DoorCommand_SwingDirection_SwingDirection_MAX = DoorCommand_SwingDirection_SWING_DIRECTION_OUTSWING;
constexpr int DoorCommand_SwingDirection_SwingDirection_ARRAYSIZE = DoorCommand_SwingDirection_SwingDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DoorCommand_SwingDirection_descriptor();
template<typename T>
inline const std::string& DoorCommand_SwingDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DoorCommand_SwingDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DoorCommand_SwingDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DoorCommand_SwingDirection_descriptor(), enum_t_value);
}
inline bool DoorCommand_SwingDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DoorCommand_SwingDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DoorCommand_SwingDirection>(
    DoorCommand_SwingDirection_descriptor(), name, value);
}
enum DoorCommand_HandleType : int {
  DoorCommand_HandleType_HANDLE_TYPE_UNKNOWN = 0,
  DoorCommand_HandleType_HANDLE_TYPE_LEVER = 1,
  DoorCommand_HandleType_HANDLE_TYPE_KNOB = 2,
  DoorCommand_HandleType_HANDLE_TYPE_FIXED_GRASP = 3,
  DoorCommand_HandleType_DoorCommand_HandleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DoorCommand_HandleType_DoorCommand_HandleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DoorCommand_HandleType_IsValid(int value);
constexpr DoorCommand_HandleType DoorCommand_HandleType_HandleType_MIN = DoorCommand_HandleType_HANDLE_TYPE_UNKNOWN;
constexpr DoorCommand_HandleType DoorCommand_HandleType_HandleType_MAX = DoorCommand_HandleType_HANDLE_TYPE_FIXED_GRASP;
constexpr int DoorCommand_HandleType_HandleType_ARRAYSIZE = DoorCommand_HandleType_HandleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DoorCommand_HandleType_descriptor();
template<typename T>
inline const std::string& DoorCommand_HandleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DoorCommand_HandleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DoorCommand_HandleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DoorCommand_HandleType_descriptor(), enum_t_value);
}
inline bool DoorCommand_HandleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DoorCommand_HandleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DoorCommand_HandleType>(
    DoorCommand_HandleType_descriptor(), name, value);
}
// ===================================================================

class OpenDoorCommandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.OpenDoorCommandRequest) */ {
 public:
  inline OpenDoorCommandRequest() : OpenDoorCommandRequest(nullptr) {}
  ~OpenDoorCommandRequest() override;
  explicit PROTOBUF_CONSTEXPR OpenDoorCommandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenDoorCommandRequest(const OpenDoorCommandRequest& from);
  OpenDoorCommandRequest(OpenDoorCommandRequest&& from) noexcept
    : OpenDoorCommandRequest() {
    *this = ::std::move(from);
  }

  inline OpenDoorCommandRequest& operator=(const OpenDoorCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenDoorCommandRequest& operator=(OpenDoorCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenDoorCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenDoorCommandRequest* internal_default_instance() {
    return reinterpret_cast<const OpenDoorCommandRequest*>(
               &_OpenDoorCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OpenDoorCommandRequest& a, OpenDoorCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenDoorCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenDoorCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenDoorCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenDoorCommandRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenDoorCommandRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenDoorCommandRequest& from) {
    OpenDoorCommandRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenDoorCommandRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.OpenDoorCommandRequest";
  }
  protected:
  explicit OpenDoorCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 2,
    kDoorCommandFieldNumber = 4,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // .bosdyn.api.spot.DoorCommand.Request door_command = 4;
  bool has_door_command() const;
  private:
  bool _internal_has_door_command() const;
  public:
  void clear_door_command();
  const ::bosdyn::api::spot::DoorCommand_Request& door_command() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::DoorCommand_Request* release_door_command();
  ::bosdyn::api::spot::DoorCommand_Request* mutable_door_command();
  void set_allocated_door_command(::bosdyn::api::spot::DoorCommand_Request* door_command);
  private:
  const ::bosdyn::api::spot::DoorCommand_Request& _internal_door_command() const;
  ::bosdyn::api::spot::DoorCommand_Request* _internal_mutable_door_command();
  public:
  void unsafe_arena_set_allocated_door_command(
      ::bosdyn::api::spot::DoorCommand_Request* door_command);
  ::bosdyn::api::spot::DoorCommand_Request* unsafe_arena_release_door_command();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.OpenDoorCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::Lease* lease_;
    ::bosdyn::api::spot::DoorCommand_Request* door_command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fdoor_2eproto;
};
// -------------------------------------------------------------------

class OpenDoorCommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.OpenDoorCommandResponse) */ {
 public:
  inline OpenDoorCommandResponse() : OpenDoorCommandResponse(nullptr) {}
  ~OpenDoorCommandResponse() override;
  explicit PROTOBUF_CONSTEXPR OpenDoorCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenDoorCommandResponse(const OpenDoorCommandResponse& from);
  OpenDoorCommandResponse(OpenDoorCommandResponse&& from) noexcept
    : OpenDoorCommandResponse() {
    *this = ::std::move(from);
  }

  inline OpenDoorCommandResponse& operator=(const OpenDoorCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenDoorCommandResponse& operator=(OpenDoorCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenDoorCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenDoorCommandResponse* internal_default_instance() {
    return reinterpret_cast<const OpenDoorCommandResponse*>(
               &_OpenDoorCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OpenDoorCommandResponse& a, OpenDoorCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenDoorCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenDoorCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenDoorCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenDoorCommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenDoorCommandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenDoorCommandResponse& from) {
    OpenDoorCommandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenDoorCommandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.OpenDoorCommandResponse";
  }
  protected:
  explicit OpenDoorCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpenDoorCommandResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    OpenDoorCommandResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    OpenDoorCommandResponse_Status_STATUS_OK;
  static constexpr Status STATUS_ROBOT_COMMAND_ERROR =
    OpenDoorCommandResponse_Status_STATUS_ROBOT_COMMAND_ERROR;
  static inline bool Status_IsValid(int value) {
    return OpenDoorCommandResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    OpenDoorCommandResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    OpenDoorCommandResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    OpenDoorCommandResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return OpenDoorCommandResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return OpenDoorCommandResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return OpenDoorCommandResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
    kStatusFieldNumber = 3,
    kDoorCommandIdFieldNumber = 5,
  };
  // string message = 4;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  PROTOBUF_NODISCARD ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // .bosdyn.api.spot.OpenDoorCommandResponse.Status status = 3;
  void clear_status();
  ::bosdyn::api::spot::OpenDoorCommandResponse_Status status() const;
  void set_status(::bosdyn::api::spot::OpenDoorCommandResponse_Status value);
  private:
  ::bosdyn::api::spot::OpenDoorCommandResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::OpenDoorCommandResponse_Status value);
  public:

  // uint32 door_command_id = 5;
  void clear_door_command_id();
  uint32_t door_command_id() const;
  void set_door_command_id(uint32_t value);
  private:
  uint32_t _internal_door_command_id() const;
  void _internal_set_door_command_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.OpenDoorCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::LeaseUseResult* lease_use_result_;
    int status_;
    uint32_t door_command_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fdoor_2eproto;
};
// -------------------------------------------------------------------

class OpenDoorFeedbackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.OpenDoorFeedbackRequest) */ {
 public:
  inline OpenDoorFeedbackRequest() : OpenDoorFeedbackRequest(nullptr) {}
  ~OpenDoorFeedbackRequest() override;
  explicit PROTOBUF_CONSTEXPR OpenDoorFeedbackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenDoorFeedbackRequest(const OpenDoorFeedbackRequest& from);
  OpenDoorFeedbackRequest(OpenDoorFeedbackRequest&& from) noexcept
    : OpenDoorFeedbackRequest() {
    *this = ::std::move(from);
  }

  inline OpenDoorFeedbackRequest& operator=(const OpenDoorFeedbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenDoorFeedbackRequest& operator=(OpenDoorFeedbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenDoorFeedbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenDoorFeedbackRequest* internal_default_instance() {
    return reinterpret_cast<const OpenDoorFeedbackRequest*>(
               &_OpenDoorFeedbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OpenDoorFeedbackRequest& a, OpenDoorFeedbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenDoorFeedbackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenDoorFeedbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenDoorFeedbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenDoorFeedbackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenDoorFeedbackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenDoorFeedbackRequest& from) {
    OpenDoorFeedbackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenDoorFeedbackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.OpenDoorFeedbackRequest";
  }
  protected:
  explicit OpenDoorFeedbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kDoorCommandIdFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // uint32 door_command_id = 2;
  void clear_door_command_id();
  uint32_t door_command_id() const;
  void set_door_command_id(uint32_t value);
  private:
  uint32_t _internal_door_command_id() const;
  void _internal_set_door_command_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.OpenDoorFeedbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    uint32_t door_command_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fdoor_2eproto;
};
// -------------------------------------------------------------------

class OpenDoorFeedbackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.OpenDoorFeedbackResponse) */ {
 public:
  inline OpenDoorFeedbackResponse() : OpenDoorFeedbackResponse(nullptr) {}
  ~OpenDoorFeedbackResponse() override;
  explicit PROTOBUF_CONSTEXPR OpenDoorFeedbackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenDoorFeedbackResponse(const OpenDoorFeedbackResponse& from);
  OpenDoorFeedbackResponse(OpenDoorFeedbackResponse&& from) noexcept
    : OpenDoorFeedbackResponse() {
    *this = ::std::move(from);
  }

  inline OpenDoorFeedbackResponse& operator=(const OpenDoorFeedbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenDoorFeedbackResponse& operator=(OpenDoorFeedbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenDoorFeedbackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenDoorFeedbackResponse* internal_default_instance() {
    return reinterpret_cast<const OpenDoorFeedbackResponse*>(
               &_OpenDoorFeedbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OpenDoorFeedbackResponse& a, OpenDoorFeedbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenDoorFeedbackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenDoorFeedbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenDoorFeedbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenDoorFeedbackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenDoorFeedbackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenDoorFeedbackResponse& from) {
    OpenDoorFeedbackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenDoorFeedbackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.OpenDoorFeedbackResponse";
  }
  protected:
  explicit OpenDoorFeedbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kFeedbackFieldNumber = 2,
    kStatusFieldNumber = 100,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot.DoorCommand.Feedback feedback = 2;
  bool has_feedback() const;
  private:
  bool _internal_has_feedback() const;
  public:
  void clear_feedback();
  const ::bosdyn::api::spot::DoorCommand_Feedback& feedback() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::DoorCommand_Feedback* release_feedback();
  ::bosdyn::api::spot::DoorCommand_Feedback* mutable_feedback();
  void set_allocated_feedback(::bosdyn::api::spot::DoorCommand_Feedback* feedback);
  private:
  const ::bosdyn::api::spot::DoorCommand_Feedback& _internal_feedback() const;
  ::bosdyn::api::spot::DoorCommand_Feedback* _internal_mutable_feedback();
  public:
  void unsafe_arena_set_allocated_feedback(
      ::bosdyn::api::spot::DoorCommand_Feedback* feedback);
  ::bosdyn::api::spot::DoorCommand_Feedback* unsafe_arena_release_feedback();

  // .bosdyn.api.RobotCommandFeedbackStatus.Status status = 100;
  void clear_status();
  ::bosdyn::api::RobotCommandFeedbackStatus_Status status() const;
  void set_status(::bosdyn::api::RobotCommandFeedbackStatus_Status value);
  private:
  ::bosdyn::api::RobotCommandFeedbackStatus_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::RobotCommandFeedbackStatus_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.OpenDoorFeedbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::spot::DoorCommand_Feedback* feedback_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fdoor_2eproto;
};
// -------------------------------------------------------------------

class DoorCommand_AutoGraspCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.DoorCommand.AutoGraspCommand) */ {
 public:
  inline DoorCommand_AutoGraspCommand() : DoorCommand_AutoGraspCommand(nullptr) {}
  ~DoorCommand_AutoGraspCommand() override;
  explicit PROTOBUF_CONSTEXPR DoorCommand_AutoGraspCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoorCommand_AutoGraspCommand(const DoorCommand_AutoGraspCommand& from);
  DoorCommand_AutoGraspCommand(DoorCommand_AutoGraspCommand&& from) noexcept
    : DoorCommand_AutoGraspCommand() {
    *this = ::std::move(from);
  }

  inline DoorCommand_AutoGraspCommand& operator=(const DoorCommand_AutoGraspCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoorCommand_AutoGraspCommand& operator=(DoorCommand_AutoGraspCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoorCommand_AutoGraspCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoorCommand_AutoGraspCommand* internal_default_instance() {
    return reinterpret_cast<const DoorCommand_AutoGraspCommand*>(
               &_DoorCommand_AutoGraspCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DoorCommand_AutoGraspCommand& a, DoorCommand_AutoGraspCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(DoorCommand_AutoGraspCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoorCommand_AutoGraspCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoorCommand_AutoGraspCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoorCommand_AutoGraspCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoorCommand_AutoGraspCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoorCommand_AutoGraspCommand& from) {
    DoorCommand_AutoGraspCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoorCommand_AutoGraspCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.DoorCommand.AutoGraspCommand";
  }
  protected:
  explicit DoorCommand_AutoGraspCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFieldNumber = 1,
    kSearchRayStartInFrameFieldNumber = 2,
    kSearchRayEndInFrameFieldNumber = 3,
    kHingeSideFieldNumber = 4,
    kSwingDirectionFieldNumber = 5,
  };
  // string frame_name = 1;
  void clear_frame_name();
  const std::string& frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name();
  PROTOBUF_NODISCARD std::string* release_frame_name();
  void set_allocated_frame_name(std::string* frame_name);
  private:
  const std::string& _internal_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name(const std::string& value);
  std::string* _internal_mutable_frame_name();
  public:

  // .bosdyn.api.Vec3 search_ray_start_in_frame = 2;
  bool has_search_ray_start_in_frame() const;
  private:
  bool _internal_has_search_ray_start_in_frame() const;
  public:
  void clear_search_ray_start_in_frame();
  const ::bosdyn::api::Vec3& search_ray_start_in_frame() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_search_ray_start_in_frame();
  ::bosdyn::api::Vec3* mutable_search_ray_start_in_frame();
  void set_allocated_search_ray_start_in_frame(::bosdyn::api::Vec3* search_ray_start_in_frame);
  private:
  const ::bosdyn::api::Vec3& _internal_search_ray_start_in_frame() const;
  ::bosdyn::api::Vec3* _internal_mutable_search_ray_start_in_frame();
  public:
  void unsafe_arena_set_allocated_search_ray_start_in_frame(
      ::bosdyn::api::Vec3* search_ray_start_in_frame);
  ::bosdyn::api::Vec3* unsafe_arena_release_search_ray_start_in_frame();

  // .bosdyn.api.Vec3 search_ray_end_in_frame = 3;
  bool has_search_ray_end_in_frame() const;
  private:
  bool _internal_has_search_ray_end_in_frame() const;
  public:
  void clear_search_ray_end_in_frame();
  const ::bosdyn::api::Vec3& search_ray_end_in_frame() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_search_ray_end_in_frame();
  ::bosdyn::api::Vec3* mutable_search_ray_end_in_frame();
  void set_allocated_search_ray_end_in_frame(::bosdyn::api::Vec3* search_ray_end_in_frame);
  private:
  const ::bosdyn::api::Vec3& _internal_search_ray_end_in_frame() const;
  ::bosdyn::api::Vec3* _internal_mutable_search_ray_end_in_frame();
  public:
  void unsafe_arena_set_allocated_search_ray_end_in_frame(
      ::bosdyn::api::Vec3* search_ray_end_in_frame);
  ::bosdyn::api::Vec3* unsafe_arena_release_search_ray_end_in_frame();

  // .bosdyn.api.spot.DoorCommand.HingeSide hinge_side = 4;
  void clear_hinge_side();
  ::bosdyn::api::spot::DoorCommand_HingeSide hinge_side() const;
  void set_hinge_side(::bosdyn::api::spot::DoorCommand_HingeSide value);
  private:
  ::bosdyn::api::spot::DoorCommand_HingeSide _internal_hinge_side() const;
  void _internal_set_hinge_side(::bosdyn::api::spot::DoorCommand_HingeSide value);
  public:

  // .bosdyn.api.spot.DoorCommand.SwingDirection swing_direction = 5;
  void clear_swing_direction();
  ::bosdyn::api::spot::DoorCommand_SwingDirection swing_direction() const;
  void set_swing_direction(::bosdyn::api::spot::DoorCommand_SwingDirection value);
  private:
  ::bosdyn::api::spot::DoorCommand_SwingDirection _internal_swing_direction() const;
  void _internal_set_swing_direction(::bosdyn::api::spot::DoorCommand_SwingDirection value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.DoorCommand.AutoGraspCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_;
    ::bosdyn::api::Vec3* search_ray_start_in_frame_;
    ::bosdyn::api::Vec3* search_ray_end_in_frame_;
    int hinge_side_;
    int swing_direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fdoor_2eproto;
};
// -------------------------------------------------------------------

class DoorCommand_WarmstartCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.DoorCommand.WarmstartCommand) */ {
 public:
  inline DoorCommand_WarmstartCommand() : DoorCommand_WarmstartCommand(nullptr) {}
  ~DoorCommand_WarmstartCommand() override;
  explicit PROTOBUF_CONSTEXPR DoorCommand_WarmstartCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoorCommand_WarmstartCommand(const DoorCommand_WarmstartCommand& from);
  DoorCommand_WarmstartCommand(DoorCommand_WarmstartCommand&& from) noexcept
    : DoorCommand_WarmstartCommand() {
    *this = ::std::move(from);
  }

  inline DoorCommand_WarmstartCommand& operator=(const DoorCommand_WarmstartCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoorCommand_WarmstartCommand& operator=(DoorCommand_WarmstartCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoorCommand_WarmstartCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoorCommand_WarmstartCommand* internal_default_instance() {
    return reinterpret_cast<const DoorCommand_WarmstartCommand*>(
               &_DoorCommand_WarmstartCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DoorCommand_WarmstartCommand& a, DoorCommand_WarmstartCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(DoorCommand_WarmstartCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoorCommand_WarmstartCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoorCommand_WarmstartCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoorCommand_WarmstartCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoorCommand_WarmstartCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoorCommand_WarmstartCommand& from) {
    DoorCommand_WarmstartCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoorCommand_WarmstartCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.DoorCommand.WarmstartCommand";
  }
  protected:
  explicit DoorCommand_WarmstartCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHingeSideFieldNumber = 1,
    kSwingDirectionFieldNumber = 2,
    kHandleTypeFieldNumber = 3,
  };
  // .bosdyn.api.spot.DoorCommand.HingeSide hinge_side = 1;
  void clear_hinge_side();
  ::bosdyn::api::spot::DoorCommand_HingeSide hinge_side() const;
  void set_hinge_side(::bosdyn::api::spot::DoorCommand_HingeSide value);
  private:
  ::bosdyn::api::spot::DoorCommand_HingeSide _internal_hinge_side() const;
  void _internal_set_hinge_side(::bosdyn::api::spot::DoorCommand_HingeSide value);
  public:

  // .bosdyn.api.spot.DoorCommand.SwingDirection swing_direction = 2;
  void clear_swing_direction();
  ::bosdyn::api::spot::DoorCommand_SwingDirection swing_direction() const;
  void set_swing_direction(::bosdyn::api::spot::DoorCommand_SwingDirection value);
  private:
  ::bosdyn::api::spot::DoorCommand_SwingDirection _internal_swing_direction() const;
  void _internal_set_swing_direction(::bosdyn::api::spot::DoorCommand_SwingDirection value);
  public:

  // .bosdyn.api.spot.DoorCommand.HandleType handle_type = 3;
  void clear_handle_type();
  ::bosdyn::api::spot::DoorCommand_HandleType handle_type() const;
  void set_handle_type(::bosdyn::api::spot::DoorCommand_HandleType value);
  private:
  ::bosdyn::api::spot::DoorCommand_HandleType _internal_handle_type() const;
  void _internal_set_handle_type(::bosdyn::api::spot::DoorCommand_HandleType value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.DoorCommand.WarmstartCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int hinge_side_;
    int swing_direction_;
    int handle_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fdoor_2eproto;
};
// -------------------------------------------------------------------

class DoorCommand_AutoPushCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.DoorCommand.AutoPushCommand) */ {
 public:
  inline DoorCommand_AutoPushCommand() : DoorCommand_AutoPushCommand(nullptr) {}
  ~DoorCommand_AutoPushCommand() override;
  explicit PROTOBUF_CONSTEXPR DoorCommand_AutoPushCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoorCommand_AutoPushCommand(const DoorCommand_AutoPushCommand& from);
  DoorCommand_AutoPushCommand(DoorCommand_AutoPushCommand&& from) noexcept
    : DoorCommand_AutoPushCommand() {
    *this = ::std::move(from);
  }

  inline DoorCommand_AutoPushCommand& operator=(const DoorCommand_AutoPushCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoorCommand_AutoPushCommand& operator=(DoorCommand_AutoPushCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoorCommand_AutoPushCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoorCommand_AutoPushCommand* internal_default_instance() {
    return reinterpret_cast<const DoorCommand_AutoPushCommand*>(
               &_DoorCommand_AutoPushCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DoorCommand_AutoPushCommand& a, DoorCommand_AutoPushCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(DoorCommand_AutoPushCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoorCommand_AutoPushCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoorCommand_AutoPushCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoorCommand_AutoPushCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoorCommand_AutoPushCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoorCommand_AutoPushCommand& from) {
    DoorCommand_AutoPushCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoorCommand_AutoPushCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.DoorCommand.AutoPushCommand";
  }
  protected:
  explicit DoorCommand_AutoPushCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFieldNumber = 1,
    kPushPointInFrameFieldNumber = 2,
    kHingeSideFieldNumber = 3,
  };
  // string frame_name = 1;
  void clear_frame_name();
  const std::string& frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name();
  PROTOBUF_NODISCARD std::string* release_frame_name();
  void set_allocated_frame_name(std::string* frame_name);
  private:
  const std::string& _internal_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name(const std::string& value);
  std::string* _internal_mutable_frame_name();
  public:

  // .bosdyn.api.Vec3 push_point_in_frame = 2;
  bool has_push_point_in_frame() const;
  private:
  bool _internal_has_push_point_in_frame() const;
  public:
  void clear_push_point_in_frame();
  const ::bosdyn::api::Vec3& push_point_in_frame() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_push_point_in_frame();
  ::bosdyn::api::Vec3* mutable_push_point_in_frame();
  void set_allocated_push_point_in_frame(::bosdyn::api::Vec3* push_point_in_frame);
  private:
  const ::bosdyn::api::Vec3& _internal_push_point_in_frame() const;
  ::bosdyn::api::Vec3* _internal_mutable_push_point_in_frame();
  public:
  void unsafe_arena_set_allocated_push_point_in_frame(
      ::bosdyn::api::Vec3* push_point_in_frame);
  ::bosdyn::api::Vec3* unsafe_arena_release_push_point_in_frame();

  // .bosdyn.api.spot.DoorCommand.HingeSide hinge_side = 3;
  void clear_hinge_side();
  ::bosdyn::api::spot::DoorCommand_HingeSide hinge_side() const;
  void set_hinge_side(::bosdyn::api::spot::DoorCommand_HingeSide value);
  private:
  ::bosdyn::api::spot::DoorCommand_HingeSide _internal_hinge_side() const;
  void _internal_set_hinge_side(::bosdyn::api::spot::DoorCommand_HingeSide value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.DoorCommand.AutoPushCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_;
    ::bosdyn::api::Vec3* push_point_in_frame_;
    int hinge_side_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fdoor_2eproto;
};
// -------------------------------------------------------------------

class DoorCommand_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.DoorCommand.Request) */ {
 public:
  inline DoorCommand_Request() : DoorCommand_Request(nullptr) {}
  ~DoorCommand_Request() override;
  explicit PROTOBUF_CONSTEXPR DoorCommand_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoorCommand_Request(const DoorCommand_Request& from);
  DoorCommand_Request(DoorCommand_Request&& from) noexcept
    : DoorCommand_Request() {
    *this = ::std::move(from);
  }

  inline DoorCommand_Request& operator=(const DoorCommand_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoorCommand_Request& operator=(DoorCommand_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoorCommand_Request& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kAutoGraspCommand = 10,
    kWarmstartCommand = 11,
    kAutoPushCommand = 12,
    COMMAND_NOT_SET = 0,
  };

  static inline const DoorCommand_Request* internal_default_instance() {
    return reinterpret_cast<const DoorCommand_Request*>(
               &_DoorCommand_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DoorCommand_Request& a, DoorCommand_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(DoorCommand_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoorCommand_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoorCommand_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoorCommand_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoorCommand_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoorCommand_Request& from) {
    DoorCommand_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoorCommand_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.DoorCommand.Request";
  }
  protected:
  explicit DoorCommand_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAutoGraspCommandFieldNumber = 10,
    kWarmstartCommandFieldNumber = 11,
    kAutoPushCommandFieldNumber = 12,
  };
  // .bosdyn.api.spot.DoorCommand.AutoGraspCommand auto_grasp_command = 10;
  bool has_auto_grasp_command() const;
  private:
  bool _internal_has_auto_grasp_command() const;
  public:
  void clear_auto_grasp_command();
  const ::bosdyn::api::spot::DoorCommand_AutoGraspCommand& auto_grasp_command() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::DoorCommand_AutoGraspCommand* release_auto_grasp_command();
  ::bosdyn::api::spot::DoorCommand_AutoGraspCommand* mutable_auto_grasp_command();
  void set_allocated_auto_grasp_command(::bosdyn::api::spot::DoorCommand_AutoGraspCommand* auto_grasp_command);
  private:
  const ::bosdyn::api::spot::DoorCommand_AutoGraspCommand& _internal_auto_grasp_command() const;
  ::bosdyn::api::spot::DoorCommand_AutoGraspCommand* _internal_mutable_auto_grasp_command();
  public:
  void unsafe_arena_set_allocated_auto_grasp_command(
      ::bosdyn::api::spot::DoorCommand_AutoGraspCommand* auto_grasp_command);
  ::bosdyn::api::spot::DoorCommand_AutoGraspCommand* unsafe_arena_release_auto_grasp_command();

  // .bosdyn.api.spot.DoorCommand.WarmstartCommand warmstart_command = 11;
  bool has_warmstart_command() const;
  private:
  bool _internal_has_warmstart_command() const;
  public:
  void clear_warmstart_command();
  const ::bosdyn::api::spot::DoorCommand_WarmstartCommand& warmstart_command() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::DoorCommand_WarmstartCommand* release_warmstart_command();
  ::bosdyn::api::spot::DoorCommand_WarmstartCommand* mutable_warmstart_command();
  void set_allocated_warmstart_command(::bosdyn::api::spot::DoorCommand_WarmstartCommand* warmstart_command);
  private:
  const ::bosdyn::api::spot::DoorCommand_WarmstartCommand& _internal_warmstart_command() const;
  ::bosdyn::api::spot::DoorCommand_WarmstartCommand* _internal_mutable_warmstart_command();
  public:
  void unsafe_arena_set_allocated_warmstart_command(
      ::bosdyn::api::spot::DoorCommand_WarmstartCommand* warmstart_command);
  ::bosdyn::api::spot::DoorCommand_WarmstartCommand* unsafe_arena_release_warmstart_command();

  // .bosdyn.api.spot.DoorCommand.AutoPushCommand auto_push_command = 12;
  bool has_auto_push_command() const;
  private:
  bool _internal_has_auto_push_command() const;
  public:
  void clear_auto_push_command();
  const ::bosdyn::api::spot::DoorCommand_AutoPushCommand& auto_push_command() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::DoorCommand_AutoPushCommand* release_auto_push_command();
  ::bosdyn::api::spot::DoorCommand_AutoPushCommand* mutable_auto_push_command();
  void set_allocated_auto_push_command(::bosdyn::api::spot::DoorCommand_AutoPushCommand* auto_push_command);
  private:
  const ::bosdyn::api::spot::DoorCommand_AutoPushCommand& _internal_auto_push_command() const;
  ::bosdyn::api::spot::DoorCommand_AutoPushCommand* _internal_mutable_auto_push_command();
  public:
  void unsafe_arena_set_allocated_auto_push_command(
      ::bosdyn::api::spot::DoorCommand_AutoPushCommand* auto_push_command);
  ::bosdyn::api::spot::DoorCommand_AutoPushCommand* unsafe_arena_release_auto_push_command();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.DoorCommand.Request)
 private:
  class _Internal;
  void set_has_auto_grasp_command();
  void set_has_warmstart_command();
  void set_has_auto_push_command();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union CommandUnion {
      constexpr CommandUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::spot::DoorCommand_AutoGraspCommand* auto_grasp_command_;
      ::bosdyn::api::spot::DoorCommand_WarmstartCommand* warmstart_command_;
      ::bosdyn::api::spot::DoorCommand_AutoPushCommand* auto_push_command_;
    } command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fdoor_2eproto;
};
// -------------------------------------------------------------------

class DoorCommand_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.DoorCommand.Feedback) */ {
 public:
  inline DoorCommand_Feedback() : DoorCommand_Feedback(nullptr) {}
  ~DoorCommand_Feedback() override;
  explicit PROTOBUF_CONSTEXPR DoorCommand_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoorCommand_Feedback(const DoorCommand_Feedback& from);
  DoorCommand_Feedback(DoorCommand_Feedback&& from) noexcept
    : DoorCommand_Feedback() {
    *this = ::std::move(from);
  }

  inline DoorCommand_Feedback& operator=(const DoorCommand_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoorCommand_Feedback& operator=(DoorCommand_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoorCommand_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoorCommand_Feedback* internal_default_instance() {
    return reinterpret_cast<const DoorCommand_Feedback*>(
               &_DoorCommand_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DoorCommand_Feedback& a, DoorCommand_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(DoorCommand_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoorCommand_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoorCommand_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoorCommand_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoorCommand_Feedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoorCommand_Feedback& from) {
    DoorCommand_Feedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoorCommand_Feedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.DoorCommand.Feedback";
  }
  protected:
  explicit DoorCommand_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DoorCommand_Feedback_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    DoorCommand_Feedback_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_COMPLETED =
    DoorCommand_Feedback_Status_STATUS_COMPLETED;
  static constexpr Status STATUS_IN_PROGRESS =
    DoorCommand_Feedback_Status_STATUS_IN_PROGRESS;
  static inline bool Status_IsValid(int value) {
    return DoorCommand_Feedback_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    DoorCommand_Feedback_Status_Status_MIN;
  static constexpr Status Status_MAX =
    DoorCommand_Feedback_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    DoorCommand_Feedback_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return DoorCommand_Feedback_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return DoorCommand_Feedback_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return DoorCommand_Feedback_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .bosdyn.api.spot.DoorCommand.Feedback.Status status = 1;
  void clear_status();
  ::bosdyn::api::spot::DoorCommand_Feedback_Status status() const;
  void set_status(::bosdyn::api::spot::DoorCommand_Feedback_Status value);
  private:
  ::bosdyn::api::spot::DoorCommand_Feedback_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::DoorCommand_Feedback_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.DoorCommand.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fdoor_2eproto;
};
// -------------------------------------------------------------------

class DoorCommand final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.DoorCommand) */ {
 public:
  inline DoorCommand() : DoorCommand(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DoorCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoorCommand(const DoorCommand& from);
  DoorCommand(DoorCommand&& from) noexcept
    : DoorCommand() {
    *this = ::std::move(from);
  }

  inline DoorCommand& operator=(const DoorCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoorCommand& operator=(DoorCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoorCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoorCommand* internal_default_instance() {
    return reinterpret_cast<const DoorCommand*>(
               &_DoorCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DoorCommand& a, DoorCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(DoorCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoorCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoorCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoorCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DoorCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DoorCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.DoorCommand";
  }
  protected:
  explicit DoorCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DoorCommand_AutoGraspCommand AutoGraspCommand;
  typedef DoorCommand_WarmstartCommand WarmstartCommand;
  typedef DoorCommand_AutoPushCommand AutoPushCommand;
  typedef DoorCommand_Request Request;
  typedef DoorCommand_Feedback Feedback;

  typedef DoorCommand_HingeSide HingeSide;
  static constexpr HingeSide HINGE_SIDE_UNKNOWN =
    DoorCommand_HingeSide_HINGE_SIDE_UNKNOWN;
  static constexpr HingeSide HINGE_SIDE_LEFT =
    DoorCommand_HingeSide_HINGE_SIDE_LEFT;
  static constexpr HingeSide HINGE_SIDE_RIGHT =
    DoorCommand_HingeSide_HINGE_SIDE_RIGHT;
  static inline bool HingeSide_IsValid(int value) {
    return DoorCommand_HingeSide_IsValid(value);
  }
  static constexpr HingeSide HingeSide_MIN =
    DoorCommand_HingeSide_HingeSide_MIN;
  static constexpr HingeSide HingeSide_MAX =
    DoorCommand_HingeSide_HingeSide_MAX;
  static constexpr int HingeSide_ARRAYSIZE =
    DoorCommand_HingeSide_HingeSide_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HingeSide_descriptor() {
    return DoorCommand_HingeSide_descriptor();
  }
  template<typename T>
  static inline const std::string& HingeSide_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HingeSide>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HingeSide_Name.");
    return DoorCommand_HingeSide_Name(enum_t_value);
  }
  static inline bool HingeSide_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      HingeSide* value) {
    return DoorCommand_HingeSide_Parse(name, value);
  }

  typedef DoorCommand_SwingDirection SwingDirection;
  static constexpr SwingDirection SWING_DIRECTION_UNKNOWN =
    DoorCommand_SwingDirection_SWING_DIRECTION_UNKNOWN;
  PROTOBUF_DEPRECATED_ENUM static constexpr SwingDirection SWING_DIRECTION_INSWING =
    DoorCommand_SwingDirection_SWING_DIRECTION_INSWING;
  static constexpr SwingDirection SWING_DIRECTION_PULL =
    DoorCommand_SwingDirection_SWING_DIRECTION_PULL;
  PROTOBUF_DEPRECATED_ENUM static constexpr SwingDirection SWING_DIRECTION_OUTSWING =
    DoorCommand_SwingDirection_SWING_DIRECTION_OUTSWING;
  static constexpr SwingDirection SWING_DIRECTION_PUSH =
    DoorCommand_SwingDirection_SWING_DIRECTION_PUSH;
  static inline bool SwingDirection_IsValid(int value) {
    return DoorCommand_SwingDirection_IsValid(value);
  }
  static constexpr SwingDirection SwingDirection_MIN =
    DoorCommand_SwingDirection_SwingDirection_MIN;
  static constexpr SwingDirection SwingDirection_MAX =
    DoorCommand_SwingDirection_SwingDirection_MAX;
  static constexpr int SwingDirection_ARRAYSIZE =
    DoorCommand_SwingDirection_SwingDirection_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SwingDirection_descriptor() {
    return DoorCommand_SwingDirection_descriptor();
  }
  template<typename T>
  static inline const std::string& SwingDirection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SwingDirection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SwingDirection_Name.");
    return DoorCommand_SwingDirection_Name(enum_t_value);
  }
  static inline bool SwingDirection_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SwingDirection* value) {
    return DoorCommand_SwingDirection_Parse(name, value);
  }

  typedef DoorCommand_HandleType HandleType;
  static constexpr HandleType HANDLE_TYPE_UNKNOWN =
    DoorCommand_HandleType_HANDLE_TYPE_UNKNOWN;
  static constexpr HandleType HANDLE_TYPE_LEVER =
    DoorCommand_HandleType_HANDLE_TYPE_LEVER;
  static constexpr HandleType HANDLE_TYPE_KNOB =
    DoorCommand_HandleType_HANDLE_TYPE_KNOB;
  static constexpr HandleType HANDLE_TYPE_FIXED_GRASP =
    DoorCommand_HandleType_HANDLE_TYPE_FIXED_GRASP;
  static inline bool HandleType_IsValid(int value) {
    return DoorCommand_HandleType_IsValid(value);
  }
  static constexpr HandleType HandleType_MIN =
    DoorCommand_HandleType_HandleType_MIN;
  static constexpr HandleType HandleType_MAX =
    DoorCommand_HandleType_HandleType_MAX;
  static constexpr int HandleType_ARRAYSIZE =
    DoorCommand_HandleType_HandleType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HandleType_descriptor() {
    return DoorCommand_HandleType_descriptor();
  }
  template<typename T>
  static inline const std::string& HandleType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HandleType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HandleType_Name.");
    return DoorCommand_HandleType_Name(enum_t_value);
  }
  static inline bool HandleType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      HandleType* value) {
    return DoorCommand_HandleType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.DoorCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fdoor_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OpenDoorCommandRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool OpenDoorCommandRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool OpenDoorCommandRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& OpenDoorCommandRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& OpenDoorCommandRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.OpenDoorCommandRequest.header)
  return _internal_header();
}
inline void OpenDoorCommandRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.OpenDoorCommandRequest.header)
}
inline ::bosdyn::api::RequestHeader* OpenDoorCommandRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* OpenDoorCommandRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.OpenDoorCommandRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* OpenDoorCommandRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* OpenDoorCommandRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.OpenDoorCommandRequest.header)
  return _msg;
}
inline void OpenDoorCommandRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.OpenDoorCommandRequest.header)
}

// .bosdyn.api.Lease lease = 2;
inline bool OpenDoorCommandRequest::_internal_has_lease() const {
  return this != internal_default_instance() && _impl_.lease_ != nullptr;
}
inline bool OpenDoorCommandRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& OpenDoorCommandRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = _impl_.lease_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Lease&>(
      ::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& OpenDoorCommandRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.OpenDoorCommandRequest.lease)
  return _internal_lease();
}
inline void OpenDoorCommandRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  _impl_.lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.OpenDoorCommandRequest.lease)
}
inline ::bosdyn::api::Lease* OpenDoorCommandRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Lease* OpenDoorCommandRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.OpenDoorCommandRequest.lease)
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* OpenDoorCommandRequest::_internal_mutable_lease() {
  
  if (_impl_.lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArenaForAllocation());
    _impl_.lease_ = p;
  }
  return _impl_.lease_;
}
inline ::bosdyn::api::Lease* OpenDoorCommandRequest::mutable_lease() {
  ::bosdyn::api::Lease* _msg = _internal_mutable_lease();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.OpenDoorCommandRequest.lease)
  return _msg;
}
inline void OpenDoorCommandRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease));
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.OpenDoorCommandRequest.lease)
}

// .bosdyn.api.spot.DoorCommand.Request door_command = 4;
inline bool OpenDoorCommandRequest::_internal_has_door_command() const {
  return this != internal_default_instance() && _impl_.door_command_ != nullptr;
}
inline bool OpenDoorCommandRequest::has_door_command() const {
  return _internal_has_door_command();
}
inline void OpenDoorCommandRequest::clear_door_command() {
  if (GetArenaForAllocation() == nullptr && _impl_.door_command_ != nullptr) {
    delete _impl_.door_command_;
  }
  _impl_.door_command_ = nullptr;
}
inline const ::bosdyn::api::spot::DoorCommand_Request& OpenDoorCommandRequest::_internal_door_command() const {
  const ::bosdyn::api::spot::DoorCommand_Request* p = _impl_.door_command_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::DoorCommand_Request&>(
      ::bosdyn::api::spot::_DoorCommand_Request_default_instance_);
}
inline const ::bosdyn::api::spot::DoorCommand_Request& OpenDoorCommandRequest::door_command() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.OpenDoorCommandRequest.door_command)
  return _internal_door_command();
}
inline void OpenDoorCommandRequest::unsafe_arena_set_allocated_door_command(
    ::bosdyn::api::spot::DoorCommand_Request* door_command) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.door_command_);
  }
  _impl_.door_command_ = door_command;
  if (door_command) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.OpenDoorCommandRequest.door_command)
}
inline ::bosdyn::api::spot::DoorCommand_Request* OpenDoorCommandRequest::release_door_command() {
  
  ::bosdyn::api::spot::DoorCommand_Request* temp = _impl_.door_command_;
  _impl_.door_command_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::DoorCommand_Request* OpenDoorCommandRequest::unsafe_arena_release_door_command() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.OpenDoorCommandRequest.door_command)
  
  ::bosdyn::api::spot::DoorCommand_Request* temp = _impl_.door_command_;
  _impl_.door_command_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::DoorCommand_Request* OpenDoorCommandRequest::_internal_mutable_door_command() {
  
  if (_impl_.door_command_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::DoorCommand_Request>(GetArenaForAllocation());
    _impl_.door_command_ = p;
  }
  return _impl_.door_command_;
}
inline ::bosdyn::api::spot::DoorCommand_Request* OpenDoorCommandRequest::mutable_door_command() {
  ::bosdyn::api::spot::DoorCommand_Request* _msg = _internal_mutable_door_command();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.OpenDoorCommandRequest.door_command)
  return _msg;
}
inline void OpenDoorCommandRequest::set_allocated_door_command(::bosdyn::api::spot::DoorCommand_Request* door_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.door_command_;
  }
  if (door_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(door_command);
    if (message_arena != submessage_arena) {
      door_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, door_command, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.door_command_ = door_command;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.OpenDoorCommandRequest.door_command)
}

// -------------------------------------------------------------------

// OpenDoorCommandResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool OpenDoorCommandResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool OpenDoorCommandResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& OpenDoorCommandResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& OpenDoorCommandResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.OpenDoorCommandResponse.header)
  return _internal_header();
}
inline void OpenDoorCommandResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.OpenDoorCommandResponse.header)
}
inline ::bosdyn::api::ResponseHeader* OpenDoorCommandResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* OpenDoorCommandResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.OpenDoorCommandResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* OpenDoorCommandResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* OpenDoorCommandResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.OpenDoorCommandResponse.header)
  return _msg;
}
inline void OpenDoorCommandResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.OpenDoorCommandResponse.header)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool OpenDoorCommandResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && _impl_.lease_use_result_ != nullptr;
}
inline bool OpenDoorCommandResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& OpenDoorCommandResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = _impl_.lease_use_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::LeaseUseResult&>(
      ::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& OpenDoorCommandResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.OpenDoorCommandResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void OpenDoorCommandResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  _impl_.lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.OpenDoorCommandResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* OpenDoorCommandResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* OpenDoorCommandResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.OpenDoorCommandResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* OpenDoorCommandResponse::_internal_mutable_lease_use_result() {
  
  if (_impl_.lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArenaForAllocation());
    _impl_.lease_use_result_ = p;
  }
  return _impl_.lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* OpenDoorCommandResponse::mutable_lease_use_result() {
  ::bosdyn::api::LeaseUseResult* _msg = _internal_mutable_lease_use_result();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.OpenDoorCommandResponse.lease_use_result)
  return _msg;
}
inline void OpenDoorCommandResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result));
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.OpenDoorCommandResponse.lease_use_result)
}

// .bosdyn.api.spot.OpenDoorCommandResponse.Status status = 3;
inline void OpenDoorCommandResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::spot::OpenDoorCommandResponse_Status OpenDoorCommandResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::OpenDoorCommandResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::spot::OpenDoorCommandResponse_Status OpenDoorCommandResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.OpenDoorCommandResponse.status)
  return _internal_status();
}
inline void OpenDoorCommandResponse::_internal_set_status(::bosdyn::api::spot::OpenDoorCommandResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void OpenDoorCommandResponse::set_status(::bosdyn::api::spot::OpenDoorCommandResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.OpenDoorCommandResponse.status)
}

// string message = 4;
inline void OpenDoorCommandResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& OpenDoorCommandResponse::message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.OpenDoorCommandResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpenDoorCommandResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.OpenDoorCommandResponse.message)
}
inline std::string* OpenDoorCommandResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.OpenDoorCommandResponse.message)
  return _s;
}
inline const std::string& OpenDoorCommandResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void OpenDoorCommandResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* OpenDoorCommandResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* OpenDoorCommandResponse::release_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.OpenDoorCommandResponse.message)
  return _impl_.message_.Release();
}
inline void OpenDoorCommandResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.OpenDoorCommandResponse.message)
}

// uint32 door_command_id = 5;
inline void OpenDoorCommandResponse::clear_door_command_id() {
  _impl_.door_command_id_ = 0u;
}
inline uint32_t OpenDoorCommandResponse::_internal_door_command_id() const {
  return _impl_.door_command_id_;
}
inline uint32_t OpenDoorCommandResponse::door_command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.OpenDoorCommandResponse.door_command_id)
  return _internal_door_command_id();
}
inline void OpenDoorCommandResponse::_internal_set_door_command_id(uint32_t value) {
  
  _impl_.door_command_id_ = value;
}
inline void OpenDoorCommandResponse::set_door_command_id(uint32_t value) {
  _internal_set_door_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.OpenDoorCommandResponse.door_command_id)
}

// -------------------------------------------------------------------

// OpenDoorFeedbackRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool OpenDoorFeedbackRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool OpenDoorFeedbackRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& OpenDoorFeedbackRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& OpenDoorFeedbackRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.OpenDoorFeedbackRequest.header)
  return _internal_header();
}
inline void OpenDoorFeedbackRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.OpenDoorFeedbackRequest.header)
}
inline ::bosdyn::api::RequestHeader* OpenDoorFeedbackRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* OpenDoorFeedbackRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.OpenDoorFeedbackRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* OpenDoorFeedbackRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* OpenDoorFeedbackRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.OpenDoorFeedbackRequest.header)
  return _msg;
}
inline void OpenDoorFeedbackRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.OpenDoorFeedbackRequest.header)
}

// uint32 door_command_id = 2;
inline void OpenDoorFeedbackRequest::clear_door_command_id() {
  _impl_.door_command_id_ = 0u;
}
inline uint32_t OpenDoorFeedbackRequest::_internal_door_command_id() const {
  return _impl_.door_command_id_;
}
inline uint32_t OpenDoorFeedbackRequest::door_command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.OpenDoorFeedbackRequest.door_command_id)
  return _internal_door_command_id();
}
inline void OpenDoorFeedbackRequest::_internal_set_door_command_id(uint32_t value) {
  
  _impl_.door_command_id_ = value;
}
inline void OpenDoorFeedbackRequest::set_door_command_id(uint32_t value) {
  _internal_set_door_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.OpenDoorFeedbackRequest.door_command_id)
}

// -------------------------------------------------------------------

// OpenDoorFeedbackResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool OpenDoorFeedbackResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool OpenDoorFeedbackResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& OpenDoorFeedbackResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& OpenDoorFeedbackResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.OpenDoorFeedbackResponse.header)
  return _internal_header();
}
inline void OpenDoorFeedbackResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.OpenDoorFeedbackResponse.header)
}
inline ::bosdyn::api::ResponseHeader* OpenDoorFeedbackResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* OpenDoorFeedbackResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.OpenDoorFeedbackResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* OpenDoorFeedbackResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* OpenDoorFeedbackResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.OpenDoorFeedbackResponse.header)
  return _msg;
}
inline void OpenDoorFeedbackResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.OpenDoorFeedbackResponse.header)
}

// .bosdyn.api.RobotCommandFeedbackStatus.Status status = 100;
inline void OpenDoorFeedbackResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::RobotCommandFeedbackStatus_Status OpenDoorFeedbackResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::RobotCommandFeedbackStatus_Status >(_impl_.status_);
}
inline ::bosdyn::api::RobotCommandFeedbackStatus_Status OpenDoorFeedbackResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.OpenDoorFeedbackResponse.status)
  return _internal_status();
}
inline void OpenDoorFeedbackResponse::_internal_set_status(::bosdyn::api::RobotCommandFeedbackStatus_Status value) {
  
  _impl_.status_ = value;
}
inline void OpenDoorFeedbackResponse::set_status(::bosdyn::api::RobotCommandFeedbackStatus_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.OpenDoorFeedbackResponse.status)
}

// .bosdyn.api.spot.DoorCommand.Feedback feedback = 2;
inline bool OpenDoorFeedbackResponse::_internal_has_feedback() const {
  return this != internal_default_instance() && _impl_.feedback_ != nullptr;
}
inline bool OpenDoorFeedbackResponse::has_feedback() const {
  return _internal_has_feedback();
}
inline void OpenDoorFeedbackResponse::clear_feedback() {
  if (GetArenaForAllocation() == nullptr && _impl_.feedback_ != nullptr) {
    delete _impl_.feedback_;
  }
  _impl_.feedback_ = nullptr;
}
inline const ::bosdyn::api::spot::DoorCommand_Feedback& OpenDoorFeedbackResponse::_internal_feedback() const {
  const ::bosdyn::api::spot::DoorCommand_Feedback* p = _impl_.feedback_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::DoorCommand_Feedback&>(
      ::bosdyn::api::spot::_DoorCommand_Feedback_default_instance_);
}
inline const ::bosdyn::api::spot::DoorCommand_Feedback& OpenDoorFeedbackResponse::feedback() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.OpenDoorFeedbackResponse.feedback)
  return _internal_feedback();
}
inline void OpenDoorFeedbackResponse::unsafe_arena_set_allocated_feedback(
    ::bosdyn::api::spot::DoorCommand_Feedback* feedback) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.feedback_);
  }
  _impl_.feedback_ = feedback;
  if (feedback) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.OpenDoorFeedbackResponse.feedback)
}
inline ::bosdyn::api::spot::DoorCommand_Feedback* OpenDoorFeedbackResponse::release_feedback() {
  
  ::bosdyn::api::spot::DoorCommand_Feedback* temp = _impl_.feedback_;
  _impl_.feedback_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::DoorCommand_Feedback* OpenDoorFeedbackResponse::unsafe_arena_release_feedback() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.OpenDoorFeedbackResponse.feedback)
  
  ::bosdyn::api::spot::DoorCommand_Feedback* temp = _impl_.feedback_;
  _impl_.feedback_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::DoorCommand_Feedback* OpenDoorFeedbackResponse::_internal_mutable_feedback() {
  
  if (_impl_.feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::DoorCommand_Feedback>(GetArenaForAllocation());
    _impl_.feedback_ = p;
  }
  return _impl_.feedback_;
}
inline ::bosdyn::api::spot::DoorCommand_Feedback* OpenDoorFeedbackResponse::mutable_feedback() {
  ::bosdyn::api::spot::DoorCommand_Feedback* _msg = _internal_mutable_feedback();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.OpenDoorFeedbackResponse.feedback)
  return _msg;
}
inline void OpenDoorFeedbackResponse::set_allocated_feedback(::bosdyn::api::spot::DoorCommand_Feedback* feedback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.feedback_;
  }
  if (feedback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(feedback);
    if (message_arena != submessage_arena) {
      feedback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feedback, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.feedback_ = feedback;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.OpenDoorFeedbackResponse.feedback)
}

// -------------------------------------------------------------------

// DoorCommand_AutoGraspCommand

// string frame_name = 1;
inline void DoorCommand_AutoGraspCommand::clear_frame_name() {
  _impl_.frame_name_.ClearToEmpty();
}
inline const std::string& DoorCommand_AutoGraspCommand::frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DoorCommand.AutoGraspCommand.frame_name)
  return _internal_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DoorCommand_AutoGraspCommand::set_frame_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DoorCommand.AutoGraspCommand.frame_name)
}
inline std::string* DoorCommand_AutoGraspCommand::mutable_frame_name() {
  std::string* _s = _internal_mutable_frame_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.DoorCommand.AutoGraspCommand.frame_name)
  return _s;
}
inline const std::string& DoorCommand_AutoGraspCommand::_internal_frame_name() const {
  return _impl_.frame_name_.Get();
}
inline void DoorCommand_AutoGraspCommand::_internal_set_frame_name(const std::string& value) {
  
  _impl_.frame_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DoorCommand_AutoGraspCommand::_internal_mutable_frame_name() {
  
  return _impl_.frame_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DoorCommand_AutoGraspCommand::release_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.DoorCommand.AutoGraspCommand.frame_name)
  return _impl_.frame_name_.Release();
}
inline void DoorCommand_AutoGraspCommand::set_allocated_frame_name(std::string* frame_name) {
  if (frame_name != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_.SetAllocated(frame_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_.IsDefault()) {
    _impl_.frame_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.DoorCommand.AutoGraspCommand.frame_name)
}

// .bosdyn.api.Vec3 search_ray_start_in_frame = 2;
inline bool DoorCommand_AutoGraspCommand::_internal_has_search_ray_start_in_frame() const {
  return this != internal_default_instance() && _impl_.search_ray_start_in_frame_ != nullptr;
}
inline bool DoorCommand_AutoGraspCommand::has_search_ray_start_in_frame() const {
  return _internal_has_search_ray_start_in_frame();
}
inline const ::bosdyn::api::Vec3& DoorCommand_AutoGraspCommand::_internal_search_ray_start_in_frame() const {
  const ::bosdyn::api::Vec3* p = _impl_.search_ray_start_in_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& DoorCommand_AutoGraspCommand::search_ray_start_in_frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DoorCommand.AutoGraspCommand.search_ray_start_in_frame)
  return _internal_search_ray_start_in_frame();
}
inline void DoorCommand_AutoGraspCommand::unsafe_arena_set_allocated_search_ray_start_in_frame(
    ::bosdyn::api::Vec3* search_ray_start_in_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.search_ray_start_in_frame_);
  }
  _impl_.search_ray_start_in_frame_ = search_ray_start_in_frame;
  if (search_ray_start_in_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.DoorCommand.AutoGraspCommand.search_ray_start_in_frame)
}
inline ::bosdyn::api::Vec3* DoorCommand_AutoGraspCommand::release_search_ray_start_in_frame() {
  
  ::bosdyn::api::Vec3* temp = _impl_.search_ray_start_in_frame_;
  _impl_.search_ray_start_in_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* DoorCommand_AutoGraspCommand::unsafe_arena_release_search_ray_start_in_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.DoorCommand.AutoGraspCommand.search_ray_start_in_frame)
  
  ::bosdyn::api::Vec3* temp = _impl_.search_ray_start_in_frame_;
  _impl_.search_ray_start_in_frame_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* DoorCommand_AutoGraspCommand::_internal_mutable_search_ray_start_in_frame() {
  
  if (_impl_.search_ray_start_in_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.search_ray_start_in_frame_ = p;
  }
  return _impl_.search_ray_start_in_frame_;
}
inline ::bosdyn::api::Vec3* DoorCommand_AutoGraspCommand::mutable_search_ray_start_in_frame() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_search_ray_start_in_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.DoorCommand.AutoGraspCommand.search_ray_start_in_frame)
  return _msg;
}
inline void DoorCommand_AutoGraspCommand::set_allocated_search_ray_start_in_frame(::bosdyn::api::Vec3* search_ray_start_in_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.search_ray_start_in_frame_);
  }
  if (search_ray_start_in_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(search_ray_start_in_frame));
    if (message_arena != submessage_arena) {
      search_ray_start_in_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, search_ray_start_in_frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.search_ray_start_in_frame_ = search_ray_start_in_frame;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.DoorCommand.AutoGraspCommand.search_ray_start_in_frame)
}

// .bosdyn.api.Vec3 search_ray_end_in_frame = 3;
inline bool DoorCommand_AutoGraspCommand::_internal_has_search_ray_end_in_frame() const {
  return this != internal_default_instance() && _impl_.search_ray_end_in_frame_ != nullptr;
}
inline bool DoorCommand_AutoGraspCommand::has_search_ray_end_in_frame() const {
  return _internal_has_search_ray_end_in_frame();
}
inline const ::bosdyn::api::Vec3& DoorCommand_AutoGraspCommand::_internal_search_ray_end_in_frame() const {
  const ::bosdyn::api::Vec3* p = _impl_.search_ray_end_in_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& DoorCommand_AutoGraspCommand::search_ray_end_in_frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DoorCommand.AutoGraspCommand.search_ray_end_in_frame)
  return _internal_search_ray_end_in_frame();
}
inline void DoorCommand_AutoGraspCommand::unsafe_arena_set_allocated_search_ray_end_in_frame(
    ::bosdyn::api::Vec3* search_ray_end_in_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.search_ray_end_in_frame_);
  }
  _impl_.search_ray_end_in_frame_ = search_ray_end_in_frame;
  if (search_ray_end_in_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.DoorCommand.AutoGraspCommand.search_ray_end_in_frame)
}
inline ::bosdyn::api::Vec3* DoorCommand_AutoGraspCommand::release_search_ray_end_in_frame() {
  
  ::bosdyn::api::Vec3* temp = _impl_.search_ray_end_in_frame_;
  _impl_.search_ray_end_in_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* DoorCommand_AutoGraspCommand::unsafe_arena_release_search_ray_end_in_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.DoorCommand.AutoGraspCommand.search_ray_end_in_frame)
  
  ::bosdyn::api::Vec3* temp = _impl_.search_ray_end_in_frame_;
  _impl_.search_ray_end_in_frame_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* DoorCommand_AutoGraspCommand::_internal_mutable_search_ray_end_in_frame() {
  
  if (_impl_.search_ray_end_in_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.search_ray_end_in_frame_ = p;
  }
  return _impl_.search_ray_end_in_frame_;
}
inline ::bosdyn::api::Vec3* DoorCommand_AutoGraspCommand::mutable_search_ray_end_in_frame() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_search_ray_end_in_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.DoorCommand.AutoGraspCommand.search_ray_end_in_frame)
  return _msg;
}
inline void DoorCommand_AutoGraspCommand::set_allocated_search_ray_end_in_frame(::bosdyn::api::Vec3* search_ray_end_in_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.search_ray_end_in_frame_);
  }
  if (search_ray_end_in_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(search_ray_end_in_frame));
    if (message_arena != submessage_arena) {
      search_ray_end_in_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, search_ray_end_in_frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.search_ray_end_in_frame_ = search_ray_end_in_frame;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.DoorCommand.AutoGraspCommand.search_ray_end_in_frame)
}

// .bosdyn.api.spot.DoorCommand.HingeSide hinge_side = 4;
inline void DoorCommand_AutoGraspCommand::clear_hinge_side() {
  _impl_.hinge_side_ = 0;
}
inline ::bosdyn::api::spot::DoorCommand_HingeSide DoorCommand_AutoGraspCommand::_internal_hinge_side() const {
  return static_cast< ::bosdyn::api::spot::DoorCommand_HingeSide >(_impl_.hinge_side_);
}
inline ::bosdyn::api::spot::DoorCommand_HingeSide DoorCommand_AutoGraspCommand::hinge_side() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DoorCommand.AutoGraspCommand.hinge_side)
  return _internal_hinge_side();
}
inline void DoorCommand_AutoGraspCommand::_internal_set_hinge_side(::bosdyn::api::spot::DoorCommand_HingeSide value) {
  
  _impl_.hinge_side_ = value;
}
inline void DoorCommand_AutoGraspCommand::set_hinge_side(::bosdyn::api::spot::DoorCommand_HingeSide value) {
  _internal_set_hinge_side(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DoorCommand.AutoGraspCommand.hinge_side)
}

// .bosdyn.api.spot.DoorCommand.SwingDirection swing_direction = 5;
inline void DoorCommand_AutoGraspCommand::clear_swing_direction() {
  _impl_.swing_direction_ = 0;
}
inline ::bosdyn::api::spot::DoorCommand_SwingDirection DoorCommand_AutoGraspCommand::_internal_swing_direction() const {
  return static_cast< ::bosdyn::api::spot::DoorCommand_SwingDirection >(_impl_.swing_direction_);
}
inline ::bosdyn::api::spot::DoorCommand_SwingDirection DoorCommand_AutoGraspCommand::swing_direction() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DoorCommand.AutoGraspCommand.swing_direction)
  return _internal_swing_direction();
}
inline void DoorCommand_AutoGraspCommand::_internal_set_swing_direction(::bosdyn::api::spot::DoorCommand_SwingDirection value) {
  
  _impl_.swing_direction_ = value;
}
inline void DoorCommand_AutoGraspCommand::set_swing_direction(::bosdyn::api::spot::DoorCommand_SwingDirection value) {
  _internal_set_swing_direction(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DoorCommand.AutoGraspCommand.swing_direction)
}

// -------------------------------------------------------------------

// DoorCommand_WarmstartCommand

// .bosdyn.api.spot.DoorCommand.HingeSide hinge_side = 1;
inline void DoorCommand_WarmstartCommand::clear_hinge_side() {
  _impl_.hinge_side_ = 0;
}
inline ::bosdyn::api::spot::DoorCommand_HingeSide DoorCommand_WarmstartCommand::_internal_hinge_side() const {
  return static_cast< ::bosdyn::api::spot::DoorCommand_HingeSide >(_impl_.hinge_side_);
}
inline ::bosdyn::api::spot::DoorCommand_HingeSide DoorCommand_WarmstartCommand::hinge_side() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DoorCommand.WarmstartCommand.hinge_side)
  return _internal_hinge_side();
}
inline void DoorCommand_WarmstartCommand::_internal_set_hinge_side(::bosdyn::api::spot::DoorCommand_HingeSide value) {
  
  _impl_.hinge_side_ = value;
}
inline void DoorCommand_WarmstartCommand::set_hinge_side(::bosdyn::api::spot::DoorCommand_HingeSide value) {
  _internal_set_hinge_side(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DoorCommand.WarmstartCommand.hinge_side)
}

// .bosdyn.api.spot.DoorCommand.SwingDirection swing_direction = 2;
inline void DoorCommand_WarmstartCommand::clear_swing_direction() {
  _impl_.swing_direction_ = 0;
}
inline ::bosdyn::api::spot::DoorCommand_SwingDirection DoorCommand_WarmstartCommand::_internal_swing_direction() const {
  return static_cast< ::bosdyn::api::spot::DoorCommand_SwingDirection >(_impl_.swing_direction_);
}
inline ::bosdyn::api::spot::DoorCommand_SwingDirection DoorCommand_WarmstartCommand::swing_direction() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DoorCommand.WarmstartCommand.swing_direction)
  return _internal_swing_direction();
}
inline void DoorCommand_WarmstartCommand::_internal_set_swing_direction(::bosdyn::api::spot::DoorCommand_SwingDirection value) {
  
  _impl_.swing_direction_ = value;
}
inline void DoorCommand_WarmstartCommand::set_swing_direction(::bosdyn::api::spot::DoorCommand_SwingDirection value) {
  _internal_set_swing_direction(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DoorCommand.WarmstartCommand.swing_direction)
}

// .bosdyn.api.spot.DoorCommand.HandleType handle_type = 3;
inline void DoorCommand_WarmstartCommand::clear_handle_type() {
  _impl_.handle_type_ = 0;
}
inline ::bosdyn::api::spot::DoorCommand_HandleType DoorCommand_WarmstartCommand::_internal_handle_type() const {
  return static_cast< ::bosdyn::api::spot::DoorCommand_HandleType >(_impl_.handle_type_);
}
inline ::bosdyn::api::spot::DoorCommand_HandleType DoorCommand_WarmstartCommand::handle_type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DoorCommand.WarmstartCommand.handle_type)
  return _internal_handle_type();
}
inline void DoorCommand_WarmstartCommand::_internal_set_handle_type(::bosdyn::api::spot::DoorCommand_HandleType value) {
  
  _impl_.handle_type_ = value;
}
inline void DoorCommand_WarmstartCommand::set_handle_type(::bosdyn::api::spot::DoorCommand_HandleType value) {
  _internal_set_handle_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DoorCommand.WarmstartCommand.handle_type)
}

// -------------------------------------------------------------------

// DoorCommand_AutoPushCommand

// string frame_name = 1;
inline void DoorCommand_AutoPushCommand::clear_frame_name() {
  _impl_.frame_name_.ClearToEmpty();
}
inline const std::string& DoorCommand_AutoPushCommand::frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DoorCommand.AutoPushCommand.frame_name)
  return _internal_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DoorCommand_AutoPushCommand::set_frame_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DoorCommand.AutoPushCommand.frame_name)
}
inline std::string* DoorCommand_AutoPushCommand::mutable_frame_name() {
  std::string* _s = _internal_mutable_frame_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.DoorCommand.AutoPushCommand.frame_name)
  return _s;
}
inline const std::string& DoorCommand_AutoPushCommand::_internal_frame_name() const {
  return _impl_.frame_name_.Get();
}
inline void DoorCommand_AutoPushCommand::_internal_set_frame_name(const std::string& value) {
  
  _impl_.frame_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DoorCommand_AutoPushCommand::_internal_mutable_frame_name() {
  
  return _impl_.frame_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DoorCommand_AutoPushCommand::release_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.DoorCommand.AutoPushCommand.frame_name)
  return _impl_.frame_name_.Release();
}
inline void DoorCommand_AutoPushCommand::set_allocated_frame_name(std::string* frame_name) {
  if (frame_name != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_.SetAllocated(frame_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_.IsDefault()) {
    _impl_.frame_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.DoorCommand.AutoPushCommand.frame_name)
}

// .bosdyn.api.Vec3 push_point_in_frame = 2;
inline bool DoorCommand_AutoPushCommand::_internal_has_push_point_in_frame() const {
  return this != internal_default_instance() && _impl_.push_point_in_frame_ != nullptr;
}
inline bool DoorCommand_AutoPushCommand::has_push_point_in_frame() const {
  return _internal_has_push_point_in_frame();
}
inline const ::bosdyn::api::Vec3& DoorCommand_AutoPushCommand::_internal_push_point_in_frame() const {
  const ::bosdyn::api::Vec3* p = _impl_.push_point_in_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& DoorCommand_AutoPushCommand::push_point_in_frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DoorCommand.AutoPushCommand.push_point_in_frame)
  return _internal_push_point_in_frame();
}
inline void DoorCommand_AutoPushCommand::unsafe_arena_set_allocated_push_point_in_frame(
    ::bosdyn::api::Vec3* push_point_in_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.push_point_in_frame_);
  }
  _impl_.push_point_in_frame_ = push_point_in_frame;
  if (push_point_in_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.DoorCommand.AutoPushCommand.push_point_in_frame)
}
inline ::bosdyn::api::Vec3* DoorCommand_AutoPushCommand::release_push_point_in_frame() {
  
  ::bosdyn::api::Vec3* temp = _impl_.push_point_in_frame_;
  _impl_.push_point_in_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* DoorCommand_AutoPushCommand::unsafe_arena_release_push_point_in_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.DoorCommand.AutoPushCommand.push_point_in_frame)
  
  ::bosdyn::api::Vec3* temp = _impl_.push_point_in_frame_;
  _impl_.push_point_in_frame_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* DoorCommand_AutoPushCommand::_internal_mutable_push_point_in_frame() {
  
  if (_impl_.push_point_in_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.push_point_in_frame_ = p;
  }
  return _impl_.push_point_in_frame_;
}
inline ::bosdyn::api::Vec3* DoorCommand_AutoPushCommand::mutable_push_point_in_frame() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_push_point_in_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.DoorCommand.AutoPushCommand.push_point_in_frame)
  return _msg;
}
inline void DoorCommand_AutoPushCommand::set_allocated_push_point_in_frame(::bosdyn::api::Vec3* push_point_in_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.push_point_in_frame_);
  }
  if (push_point_in_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(push_point_in_frame));
    if (message_arena != submessage_arena) {
      push_point_in_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, push_point_in_frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.push_point_in_frame_ = push_point_in_frame;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.DoorCommand.AutoPushCommand.push_point_in_frame)
}

// .bosdyn.api.spot.DoorCommand.HingeSide hinge_side = 3;
inline void DoorCommand_AutoPushCommand::clear_hinge_side() {
  _impl_.hinge_side_ = 0;
}
inline ::bosdyn::api::spot::DoorCommand_HingeSide DoorCommand_AutoPushCommand::_internal_hinge_side() const {
  return static_cast< ::bosdyn::api::spot::DoorCommand_HingeSide >(_impl_.hinge_side_);
}
inline ::bosdyn::api::spot::DoorCommand_HingeSide DoorCommand_AutoPushCommand::hinge_side() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DoorCommand.AutoPushCommand.hinge_side)
  return _internal_hinge_side();
}
inline void DoorCommand_AutoPushCommand::_internal_set_hinge_side(::bosdyn::api::spot::DoorCommand_HingeSide value) {
  
  _impl_.hinge_side_ = value;
}
inline void DoorCommand_AutoPushCommand::set_hinge_side(::bosdyn::api::spot::DoorCommand_HingeSide value) {
  _internal_set_hinge_side(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DoorCommand.AutoPushCommand.hinge_side)
}

// -------------------------------------------------------------------

// DoorCommand_Request

// .bosdyn.api.spot.DoorCommand.AutoGraspCommand auto_grasp_command = 10;
inline bool DoorCommand_Request::_internal_has_auto_grasp_command() const {
  return command_case() == kAutoGraspCommand;
}
inline bool DoorCommand_Request::has_auto_grasp_command() const {
  return _internal_has_auto_grasp_command();
}
inline void DoorCommand_Request::set_has_auto_grasp_command() {
  _impl_._oneof_case_[0] = kAutoGraspCommand;
}
inline void DoorCommand_Request::clear_auto_grasp_command() {
  if (_internal_has_auto_grasp_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.auto_grasp_command_;
    }
    clear_has_command();
  }
}
inline ::bosdyn::api::spot::DoorCommand_AutoGraspCommand* DoorCommand_Request::release_auto_grasp_command() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.DoorCommand.Request.auto_grasp_command)
  if (_internal_has_auto_grasp_command()) {
    clear_has_command();
    ::bosdyn::api::spot::DoorCommand_AutoGraspCommand* temp = _impl_.command_.auto_grasp_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.auto_grasp_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::DoorCommand_AutoGraspCommand& DoorCommand_Request::_internal_auto_grasp_command() const {
  return _internal_has_auto_grasp_command()
      ? *_impl_.command_.auto_grasp_command_
      : reinterpret_cast< ::bosdyn::api::spot::DoorCommand_AutoGraspCommand&>(::bosdyn::api::spot::_DoorCommand_AutoGraspCommand_default_instance_);
}
inline const ::bosdyn::api::spot::DoorCommand_AutoGraspCommand& DoorCommand_Request::auto_grasp_command() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DoorCommand.Request.auto_grasp_command)
  return _internal_auto_grasp_command();
}
inline ::bosdyn::api::spot::DoorCommand_AutoGraspCommand* DoorCommand_Request::unsafe_arena_release_auto_grasp_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.DoorCommand.Request.auto_grasp_command)
  if (_internal_has_auto_grasp_command()) {
    clear_has_command();
    ::bosdyn::api::spot::DoorCommand_AutoGraspCommand* temp = _impl_.command_.auto_grasp_command_;
    _impl_.command_.auto_grasp_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DoorCommand_Request::unsafe_arena_set_allocated_auto_grasp_command(::bosdyn::api::spot::DoorCommand_AutoGraspCommand* auto_grasp_command) {
  clear_command();
  if (auto_grasp_command) {
    set_has_auto_grasp_command();
    _impl_.command_.auto_grasp_command_ = auto_grasp_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.DoorCommand.Request.auto_grasp_command)
}
inline ::bosdyn::api::spot::DoorCommand_AutoGraspCommand* DoorCommand_Request::_internal_mutable_auto_grasp_command() {
  if (!_internal_has_auto_grasp_command()) {
    clear_command();
    set_has_auto_grasp_command();
    _impl_.command_.auto_grasp_command_ = CreateMaybeMessage< ::bosdyn::api::spot::DoorCommand_AutoGraspCommand >(GetArenaForAllocation());
  }
  return _impl_.command_.auto_grasp_command_;
}
inline ::bosdyn::api::spot::DoorCommand_AutoGraspCommand* DoorCommand_Request::mutable_auto_grasp_command() {
  ::bosdyn::api::spot::DoorCommand_AutoGraspCommand* _msg = _internal_mutable_auto_grasp_command();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.DoorCommand.Request.auto_grasp_command)
  return _msg;
}

// .bosdyn.api.spot.DoorCommand.WarmstartCommand warmstart_command = 11;
inline bool DoorCommand_Request::_internal_has_warmstart_command() const {
  return command_case() == kWarmstartCommand;
}
inline bool DoorCommand_Request::has_warmstart_command() const {
  return _internal_has_warmstart_command();
}
inline void DoorCommand_Request::set_has_warmstart_command() {
  _impl_._oneof_case_[0] = kWarmstartCommand;
}
inline void DoorCommand_Request::clear_warmstart_command() {
  if (_internal_has_warmstart_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.warmstart_command_;
    }
    clear_has_command();
  }
}
inline ::bosdyn::api::spot::DoorCommand_WarmstartCommand* DoorCommand_Request::release_warmstart_command() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.DoorCommand.Request.warmstart_command)
  if (_internal_has_warmstart_command()) {
    clear_has_command();
    ::bosdyn::api::spot::DoorCommand_WarmstartCommand* temp = _impl_.command_.warmstart_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.warmstart_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::DoorCommand_WarmstartCommand& DoorCommand_Request::_internal_warmstart_command() const {
  return _internal_has_warmstart_command()
      ? *_impl_.command_.warmstart_command_
      : reinterpret_cast< ::bosdyn::api::spot::DoorCommand_WarmstartCommand&>(::bosdyn::api::spot::_DoorCommand_WarmstartCommand_default_instance_);
}
inline const ::bosdyn::api::spot::DoorCommand_WarmstartCommand& DoorCommand_Request::warmstart_command() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DoorCommand.Request.warmstart_command)
  return _internal_warmstart_command();
}
inline ::bosdyn::api::spot::DoorCommand_WarmstartCommand* DoorCommand_Request::unsafe_arena_release_warmstart_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.DoorCommand.Request.warmstart_command)
  if (_internal_has_warmstart_command()) {
    clear_has_command();
    ::bosdyn::api::spot::DoorCommand_WarmstartCommand* temp = _impl_.command_.warmstart_command_;
    _impl_.command_.warmstart_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DoorCommand_Request::unsafe_arena_set_allocated_warmstart_command(::bosdyn::api::spot::DoorCommand_WarmstartCommand* warmstart_command) {
  clear_command();
  if (warmstart_command) {
    set_has_warmstart_command();
    _impl_.command_.warmstart_command_ = warmstart_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.DoorCommand.Request.warmstart_command)
}
inline ::bosdyn::api::spot::DoorCommand_WarmstartCommand* DoorCommand_Request::_internal_mutable_warmstart_command() {
  if (!_internal_has_warmstart_command()) {
    clear_command();
    set_has_warmstart_command();
    _impl_.command_.warmstart_command_ = CreateMaybeMessage< ::bosdyn::api::spot::DoorCommand_WarmstartCommand >(GetArenaForAllocation());
  }
  return _impl_.command_.warmstart_command_;
}
inline ::bosdyn::api::spot::DoorCommand_WarmstartCommand* DoorCommand_Request::mutable_warmstart_command() {
  ::bosdyn::api::spot::DoorCommand_WarmstartCommand* _msg = _internal_mutable_warmstart_command();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.DoorCommand.Request.warmstart_command)
  return _msg;
}

// .bosdyn.api.spot.DoorCommand.AutoPushCommand auto_push_command = 12;
inline bool DoorCommand_Request::_internal_has_auto_push_command() const {
  return command_case() == kAutoPushCommand;
}
inline bool DoorCommand_Request::has_auto_push_command() const {
  return _internal_has_auto_push_command();
}
inline void DoorCommand_Request::set_has_auto_push_command() {
  _impl_._oneof_case_[0] = kAutoPushCommand;
}
inline void DoorCommand_Request::clear_auto_push_command() {
  if (_internal_has_auto_push_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.auto_push_command_;
    }
    clear_has_command();
  }
}
inline ::bosdyn::api::spot::DoorCommand_AutoPushCommand* DoorCommand_Request::release_auto_push_command() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.DoorCommand.Request.auto_push_command)
  if (_internal_has_auto_push_command()) {
    clear_has_command();
    ::bosdyn::api::spot::DoorCommand_AutoPushCommand* temp = _impl_.command_.auto_push_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.auto_push_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::DoorCommand_AutoPushCommand& DoorCommand_Request::_internal_auto_push_command() const {
  return _internal_has_auto_push_command()
      ? *_impl_.command_.auto_push_command_
      : reinterpret_cast< ::bosdyn::api::spot::DoorCommand_AutoPushCommand&>(::bosdyn::api::spot::_DoorCommand_AutoPushCommand_default_instance_);
}
inline const ::bosdyn::api::spot::DoorCommand_AutoPushCommand& DoorCommand_Request::auto_push_command() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DoorCommand.Request.auto_push_command)
  return _internal_auto_push_command();
}
inline ::bosdyn::api::spot::DoorCommand_AutoPushCommand* DoorCommand_Request::unsafe_arena_release_auto_push_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.DoorCommand.Request.auto_push_command)
  if (_internal_has_auto_push_command()) {
    clear_has_command();
    ::bosdyn::api::spot::DoorCommand_AutoPushCommand* temp = _impl_.command_.auto_push_command_;
    _impl_.command_.auto_push_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DoorCommand_Request::unsafe_arena_set_allocated_auto_push_command(::bosdyn::api::spot::DoorCommand_AutoPushCommand* auto_push_command) {
  clear_command();
  if (auto_push_command) {
    set_has_auto_push_command();
    _impl_.command_.auto_push_command_ = auto_push_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.DoorCommand.Request.auto_push_command)
}
inline ::bosdyn::api::spot::DoorCommand_AutoPushCommand* DoorCommand_Request::_internal_mutable_auto_push_command() {
  if (!_internal_has_auto_push_command()) {
    clear_command();
    set_has_auto_push_command();
    _impl_.command_.auto_push_command_ = CreateMaybeMessage< ::bosdyn::api::spot::DoorCommand_AutoPushCommand >(GetArenaForAllocation());
  }
  return _impl_.command_.auto_push_command_;
}
inline ::bosdyn::api::spot::DoorCommand_AutoPushCommand* DoorCommand_Request::mutable_auto_push_command() {
  ::bosdyn::api::spot::DoorCommand_AutoPushCommand* _msg = _internal_mutable_auto_push_command();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.DoorCommand.Request.auto_push_command)
  return _msg;
}

inline bool DoorCommand_Request::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void DoorCommand_Request::clear_has_command() {
  _impl_._oneof_case_[0] = COMMAND_NOT_SET;
}
inline DoorCommand_Request::CommandCase DoorCommand_Request::command_case() const {
  return DoorCommand_Request::CommandCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DoorCommand_Feedback

// .bosdyn.api.spot.DoorCommand.Feedback.Status status = 1;
inline void DoorCommand_Feedback::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::spot::DoorCommand_Feedback_Status DoorCommand_Feedback::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::DoorCommand_Feedback_Status >(_impl_.status_);
}
inline ::bosdyn::api::spot::DoorCommand_Feedback_Status DoorCommand_Feedback::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DoorCommand.Feedback.status)
  return _internal_status();
}
inline void DoorCommand_Feedback::_internal_set_status(::bosdyn::api::spot::DoorCommand_Feedback_Status value) {
  
  _impl_.status_ = value;
}
inline void DoorCommand_Feedback::set_status(::bosdyn::api::spot::DoorCommand_Feedback_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DoorCommand.Feedback.status)
}

// -------------------------------------------------------------------

// DoorCommand

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace spot
}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::spot::OpenDoorCommandResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::OpenDoorCommandResponse_Status>() {
  return ::bosdyn::api::spot::OpenDoorCommandResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::DoorCommand_Feedback_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::DoorCommand_Feedback_Status>() {
  return ::bosdyn::api::spot::DoorCommand_Feedback_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::DoorCommand_HingeSide> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::DoorCommand_HingeSide>() {
  return ::bosdyn::api::spot::DoorCommand_HingeSide_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::DoorCommand_SwingDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::DoorCommand_SwingDirection>() {
  return ::bosdyn::api::spot::DoorCommand_SwingDirection_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::DoorCommand_HandleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::DoorCommand_HandleType>() {
  return ::bosdyn::api::spot::DoorCommand_HandleType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_2fdoor_2eproto
