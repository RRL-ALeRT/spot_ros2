// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/network_compute_bridge.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fnetwork_5fcompute_5fbridge_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fnetwork_5fcompute_5fbridge_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/alerts.pb.h"
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/image.pb.h"
#include "bosdyn/api/world_object.pb.h"
#include <google/protobuf/any.pb.h>
#include <google/protobuf/struct.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fnetwork_5fcompute_5fbridge_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fnetwork_5fcompute_5fbridge_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fnetwork_5fcompute_5fbridge_2eproto;
namespace bosdyn {
namespace api {
class ImageSourceAndService;
struct ImageSourceAndServiceDefaultTypeInternal;
extern ImageSourceAndServiceDefaultTypeInternal _ImageSourceAndService_default_instance_;
class ListAvailableModelsRequest;
struct ListAvailableModelsRequestDefaultTypeInternal;
extern ListAvailableModelsRequestDefaultTypeInternal _ListAvailableModelsRequest_default_instance_;
class ListAvailableModelsResponse;
struct ListAvailableModelsResponseDefaultTypeInternal;
extern ListAvailableModelsResponseDefaultTypeInternal _ListAvailableModelsResponse_default_instance_;
class ModelLabels;
struct ModelLabelsDefaultTypeInternal;
extern ModelLabelsDefaultTypeInternal _ModelLabels_default_instance_;
class NetworkComputeInputData;
struct NetworkComputeInputDataDefaultTypeInternal;
extern NetworkComputeInputDataDefaultTypeInternal _NetworkComputeInputData_default_instance_;
class NetworkComputeRequest;
struct NetworkComputeRequestDefaultTypeInternal;
extern NetworkComputeRequestDefaultTypeInternal _NetworkComputeRequest_default_instance_;
class NetworkComputeResponse;
struct NetworkComputeResponseDefaultTypeInternal;
extern NetworkComputeResponseDefaultTypeInternal _NetworkComputeResponse_default_instance_;
class NetworkComputeResponse_OutputImagesEntry_DoNotUse;
struct NetworkComputeResponse_OutputImagesEntry_DoNotUseDefaultTypeInternal;
extern NetworkComputeResponse_OutputImagesEntry_DoNotUseDefaultTypeInternal _NetworkComputeResponse_OutputImagesEntry_DoNotUse_default_instance_;
class NetworkComputeServerConfiguration;
struct NetworkComputeServerConfigurationDefaultTypeInternal;
extern NetworkComputeServerConfigurationDefaultTypeInternal _NetworkComputeServerConfiguration_default_instance_;
class OutputImage;
struct OutputImageDefaultTypeInternal;
extern OutputImageDefaultTypeInternal _OutputImage_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::ImageSourceAndService* Arena::CreateMaybeMessage<::bosdyn::api::ImageSourceAndService>(Arena*);
template<> ::bosdyn::api::ListAvailableModelsRequest* Arena::CreateMaybeMessage<::bosdyn::api::ListAvailableModelsRequest>(Arena*);
template<> ::bosdyn::api::ListAvailableModelsResponse* Arena::CreateMaybeMessage<::bosdyn::api::ListAvailableModelsResponse>(Arena*);
template<> ::bosdyn::api::ModelLabels* Arena::CreateMaybeMessage<::bosdyn::api::ModelLabels>(Arena*);
template<> ::bosdyn::api::NetworkComputeInputData* Arena::CreateMaybeMessage<::bosdyn::api::NetworkComputeInputData>(Arena*);
template<> ::bosdyn::api::NetworkComputeRequest* Arena::CreateMaybeMessage<::bosdyn::api::NetworkComputeRequest>(Arena*);
template<> ::bosdyn::api::NetworkComputeResponse* Arena::CreateMaybeMessage<::bosdyn::api::NetworkComputeResponse>(Arena*);
template<> ::bosdyn::api::NetworkComputeResponse_OutputImagesEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::NetworkComputeResponse_OutputImagesEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::NetworkComputeServerConfiguration* Arena::CreateMaybeMessage<::bosdyn::api::NetworkComputeServerConfiguration>(Arena*);
template<> ::bosdyn::api::OutputImage* Arena::CreateMaybeMessage<::bosdyn::api::OutputImage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum NetworkComputeInputData_RotateImage : int {
  NetworkComputeInputData_RotateImage_ROTATE_IMAGE_UNKNOWN = 0,
  NetworkComputeInputData_RotateImage_ROTATE_IMAGE_NO_ROTATION = 3,
  NetworkComputeInputData_RotateImage_ROTATE_IMAGE_ALIGN_HORIZONTAL = 1,
  NetworkComputeInputData_RotateImage_ROTATE_IMAGE_ALIGN_WITH_BODY = 2,
  NetworkComputeInputData_RotateImage_NetworkComputeInputData_RotateImage_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NetworkComputeInputData_RotateImage_NetworkComputeInputData_RotateImage_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NetworkComputeInputData_RotateImage_IsValid(int value);
constexpr NetworkComputeInputData_RotateImage NetworkComputeInputData_RotateImage_RotateImage_MIN = NetworkComputeInputData_RotateImage_ROTATE_IMAGE_UNKNOWN;
constexpr NetworkComputeInputData_RotateImage NetworkComputeInputData_RotateImage_RotateImage_MAX = NetworkComputeInputData_RotateImage_ROTATE_IMAGE_NO_ROTATION;
constexpr int NetworkComputeInputData_RotateImage_RotateImage_ARRAYSIZE = NetworkComputeInputData_RotateImage_RotateImage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NetworkComputeInputData_RotateImage_descriptor();
template<typename T>
inline const std::string& NetworkComputeInputData_RotateImage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetworkComputeInputData_RotateImage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetworkComputeInputData_RotateImage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NetworkComputeInputData_RotateImage_descriptor(), enum_t_value);
}
inline bool NetworkComputeInputData_RotateImage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetworkComputeInputData_RotateImage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NetworkComputeInputData_RotateImage>(
    NetworkComputeInputData_RotateImage_descriptor(), name, value);
}
enum NetworkComputeStatus : int {
  NETWORK_COMPUTE_STATUS_UNKNOWN = 0,
  NETWORK_COMPUTE_STATUS_SUCCESS = 1,
  NETWORK_COMPUTE_STATUS_EXTERNAL_SERVICE_NOT_FOUND = 2,
  NETWORK_COMPUTE_STATUS_EXTERNAL_SERVER_ERROR = 3,
  NETWORK_COMPUTE_STATUS_ROTATION_ERROR = 4,
  NetworkComputeStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NetworkComputeStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NetworkComputeStatus_IsValid(int value);
constexpr NetworkComputeStatus NetworkComputeStatus_MIN = NETWORK_COMPUTE_STATUS_UNKNOWN;
constexpr NetworkComputeStatus NetworkComputeStatus_MAX = NETWORK_COMPUTE_STATUS_ROTATION_ERROR;
constexpr int NetworkComputeStatus_ARRAYSIZE = NetworkComputeStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NetworkComputeStatus_descriptor();
template<typename T>
inline const std::string& NetworkComputeStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetworkComputeStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetworkComputeStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NetworkComputeStatus_descriptor(), enum_t_value);
}
inline bool NetworkComputeStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetworkComputeStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NetworkComputeStatus>(
    NetworkComputeStatus_descriptor(), name, value);
}
enum ListAvailableModelsStatus : int {
  LIST_AVAILABLE_MODELS_STATUS_UNKNOWN = 0,
  LIST_AVAILABLE_MODELS_STATUS_SUCCESS = 1,
  LIST_AVAILABLE_MODELS_STATUS_EXTERNAL_SERVICE_NOT_FOUND = 2,
  LIST_AVAILABLE_MODELS_STATUS_EXTERNAL_SERVER_ERROR = 3,
  ListAvailableModelsStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ListAvailableModelsStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ListAvailableModelsStatus_IsValid(int value);
constexpr ListAvailableModelsStatus ListAvailableModelsStatus_MIN = LIST_AVAILABLE_MODELS_STATUS_UNKNOWN;
constexpr ListAvailableModelsStatus ListAvailableModelsStatus_MAX = LIST_AVAILABLE_MODELS_STATUS_EXTERNAL_SERVER_ERROR;
constexpr int ListAvailableModelsStatus_ARRAYSIZE = ListAvailableModelsStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ListAvailableModelsStatus_descriptor();
template<typename T>
inline const std::string& ListAvailableModelsStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ListAvailableModelsStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ListAvailableModelsStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ListAvailableModelsStatus_descriptor(), enum_t_value);
}
inline bool ListAvailableModelsStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ListAvailableModelsStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ListAvailableModelsStatus>(
    ListAvailableModelsStatus_descriptor(), name, value);
}
// ===================================================================

class ListAvailableModelsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListAvailableModelsRequest) */ {
 public:
  inline ListAvailableModelsRequest() : ListAvailableModelsRequest(nullptr) {}
  ~ListAvailableModelsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListAvailableModelsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListAvailableModelsRequest(const ListAvailableModelsRequest& from);
  ListAvailableModelsRequest(ListAvailableModelsRequest&& from) noexcept
    : ListAvailableModelsRequest() {
    *this = ::std::move(from);
  }

  inline ListAvailableModelsRequest& operator=(const ListAvailableModelsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAvailableModelsRequest& operator=(ListAvailableModelsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAvailableModelsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAvailableModelsRequest* internal_default_instance() {
    return reinterpret_cast<const ListAvailableModelsRequest*>(
               &_ListAvailableModelsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ListAvailableModelsRequest& a, ListAvailableModelsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAvailableModelsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAvailableModelsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAvailableModelsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAvailableModelsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListAvailableModelsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListAvailableModelsRequest& from) {
    ListAvailableModelsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAvailableModelsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListAvailableModelsRequest";
  }
  protected:
  explicit ListAvailableModelsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kServerConfigFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.NetworkComputeServerConfiguration server_config = 2;
  bool has_server_config() const;
  private:
  bool _internal_has_server_config() const;
  public:
  void clear_server_config();
  const ::bosdyn::api::NetworkComputeServerConfiguration& server_config() const;
  PROTOBUF_NODISCARD ::bosdyn::api::NetworkComputeServerConfiguration* release_server_config();
  ::bosdyn::api::NetworkComputeServerConfiguration* mutable_server_config();
  void set_allocated_server_config(::bosdyn::api::NetworkComputeServerConfiguration* server_config);
  private:
  const ::bosdyn::api::NetworkComputeServerConfiguration& _internal_server_config() const;
  ::bosdyn::api::NetworkComputeServerConfiguration* _internal_mutable_server_config();
  public:
  void unsafe_arena_set_allocated_server_config(
      ::bosdyn::api::NetworkComputeServerConfiguration* server_config);
  ::bosdyn::api::NetworkComputeServerConfiguration* unsafe_arena_release_server_config();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListAvailableModelsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::NetworkComputeServerConfiguration* server_config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fnetwork_5fcompute_5fbridge_2eproto;
};
// -------------------------------------------------------------------

class ListAvailableModelsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListAvailableModelsResponse) */ {
 public:
  inline ListAvailableModelsResponse() : ListAvailableModelsResponse(nullptr) {}
  ~ListAvailableModelsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListAvailableModelsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListAvailableModelsResponse(const ListAvailableModelsResponse& from);
  ListAvailableModelsResponse(ListAvailableModelsResponse&& from) noexcept
    : ListAvailableModelsResponse() {
    *this = ::std::move(from);
  }

  inline ListAvailableModelsResponse& operator=(const ListAvailableModelsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAvailableModelsResponse& operator=(ListAvailableModelsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAvailableModelsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAvailableModelsResponse* internal_default_instance() {
    return reinterpret_cast<const ListAvailableModelsResponse*>(
               &_ListAvailableModelsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ListAvailableModelsResponse& a, ListAvailableModelsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAvailableModelsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAvailableModelsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAvailableModelsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAvailableModelsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListAvailableModelsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListAvailableModelsResponse& from) {
    ListAvailableModelsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAvailableModelsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListAvailableModelsResponse";
  }
  protected:
  explicit ListAvailableModelsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableModelsFieldNumber = 2,
    kLabelsFieldNumber = 6,
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 5,
  };
  // repeated string available_models = 2;
  int available_models_size() const;
  private:
  int _internal_available_models_size() const;
  public:
  void clear_available_models();
  const std::string& available_models(int index) const;
  std::string* mutable_available_models(int index);
  void set_available_models(int index, const std::string& value);
  void set_available_models(int index, std::string&& value);
  void set_available_models(int index, const char* value);
  void set_available_models(int index, const char* value, size_t size);
  std::string* add_available_models();
  void add_available_models(const std::string& value);
  void add_available_models(std::string&& value);
  void add_available_models(const char* value);
  void add_available_models(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& available_models() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_available_models();
  private:
  const std::string& _internal_available_models(int index) const;
  std::string* _internal_add_available_models();
  public:

  // repeated .bosdyn.api.ModelLabels labels = 6;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  ::bosdyn::api::ModelLabels* mutable_labels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ModelLabels >*
      mutable_labels();
  private:
  const ::bosdyn::api::ModelLabels& _internal_labels(int index) const;
  ::bosdyn::api::ModelLabels* _internal_add_labels();
  public:
  const ::bosdyn::api::ModelLabels& labels(int index) const;
  ::bosdyn::api::ModelLabels* add_labels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ModelLabels >&
      labels() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.ListAvailableModelsStatus status = 5;
  void clear_status();
  ::bosdyn::api::ListAvailableModelsStatus status() const;
  void set_status(::bosdyn::api::ListAvailableModelsStatus value);
  private:
  ::bosdyn::api::ListAvailableModelsStatus _internal_status() const;
  void _internal_set_status(::bosdyn::api::ListAvailableModelsStatus value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListAvailableModelsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> available_models_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ModelLabels > labels_;
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fnetwork_5fcompute_5fbridge_2eproto;
};
// -------------------------------------------------------------------

class ModelLabels final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ModelLabels) */ {
 public:
  inline ModelLabels() : ModelLabels(nullptr) {}
  ~ModelLabels() override;
  explicit PROTOBUF_CONSTEXPR ModelLabels(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelLabels(const ModelLabels& from);
  ModelLabels(ModelLabels&& from) noexcept
    : ModelLabels() {
    *this = ::std::move(from);
  }

  inline ModelLabels& operator=(const ModelLabels& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelLabels& operator=(ModelLabels&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelLabels& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelLabels* internal_default_instance() {
    return reinterpret_cast<const ModelLabels*>(
               &_ModelLabels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ModelLabels& a, ModelLabels& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelLabels* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelLabels* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelLabels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelLabels>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelLabels& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelLabels& from) {
    ModelLabels::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelLabels* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ModelLabels";
  }
  protected:
  explicit ModelLabels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableLabelsFieldNumber = 2,
    kModelNameFieldNumber = 1,
  };
  // repeated string available_labels = 2;
  int available_labels_size() const;
  private:
  int _internal_available_labels_size() const;
  public:
  void clear_available_labels();
  const std::string& available_labels(int index) const;
  std::string* mutable_available_labels(int index);
  void set_available_labels(int index, const std::string& value);
  void set_available_labels(int index, std::string&& value);
  void set_available_labels(int index, const char* value);
  void set_available_labels(int index, const char* value, size_t size);
  std::string* add_available_labels();
  void add_available_labels(const std::string& value);
  void add_available_labels(std::string&& value);
  void add_available_labels(const char* value);
  void add_available_labels(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& available_labels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_available_labels();
  private:
  const std::string& _internal_available_labels(int index) const;
  std::string* _internal_add_available_labels();
  public:

  // string model_name = 1;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ModelLabels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> available_labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fnetwork_5fcompute_5fbridge_2eproto;
};
// -------------------------------------------------------------------

class NetworkComputeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.NetworkComputeRequest) */ {
 public:
  inline NetworkComputeRequest() : NetworkComputeRequest(nullptr) {}
  ~NetworkComputeRequest() override;
  explicit PROTOBUF_CONSTEXPR NetworkComputeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkComputeRequest(const NetworkComputeRequest& from);
  NetworkComputeRequest(NetworkComputeRequest&& from) noexcept
    : NetworkComputeRequest() {
    *this = ::std::move(from);
  }

  inline NetworkComputeRequest& operator=(const NetworkComputeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkComputeRequest& operator=(NetworkComputeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkComputeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkComputeRequest* internal_default_instance() {
    return reinterpret_cast<const NetworkComputeRequest*>(
               &_NetworkComputeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NetworkComputeRequest& a, NetworkComputeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkComputeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkComputeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkComputeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkComputeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkComputeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkComputeRequest& from) {
    NetworkComputeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkComputeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.NetworkComputeRequest";
  }
  protected:
  explicit NetworkComputeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kInputDataFieldNumber = 2,
    kServerConfigFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.NetworkComputeInputData input_data = 2;
  bool has_input_data() const;
  private:
  bool _internal_has_input_data() const;
  public:
  void clear_input_data();
  const ::bosdyn::api::NetworkComputeInputData& input_data() const;
  PROTOBUF_NODISCARD ::bosdyn::api::NetworkComputeInputData* release_input_data();
  ::bosdyn::api::NetworkComputeInputData* mutable_input_data();
  void set_allocated_input_data(::bosdyn::api::NetworkComputeInputData* input_data);
  private:
  const ::bosdyn::api::NetworkComputeInputData& _internal_input_data() const;
  ::bosdyn::api::NetworkComputeInputData* _internal_mutable_input_data();
  public:
  void unsafe_arena_set_allocated_input_data(
      ::bosdyn::api::NetworkComputeInputData* input_data);
  ::bosdyn::api::NetworkComputeInputData* unsafe_arena_release_input_data();

  // .bosdyn.api.NetworkComputeServerConfiguration server_config = 3;
  bool has_server_config() const;
  private:
  bool _internal_has_server_config() const;
  public:
  void clear_server_config();
  const ::bosdyn::api::NetworkComputeServerConfiguration& server_config() const;
  PROTOBUF_NODISCARD ::bosdyn::api::NetworkComputeServerConfiguration* release_server_config();
  ::bosdyn::api::NetworkComputeServerConfiguration* mutable_server_config();
  void set_allocated_server_config(::bosdyn::api::NetworkComputeServerConfiguration* server_config);
  private:
  const ::bosdyn::api::NetworkComputeServerConfiguration& _internal_server_config() const;
  ::bosdyn::api::NetworkComputeServerConfiguration* _internal_mutable_server_config();
  public:
  void unsafe_arena_set_allocated_server_config(
      ::bosdyn::api::NetworkComputeServerConfiguration* server_config);
  ::bosdyn::api::NetworkComputeServerConfiguration* unsafe_arena_release_server_config();

  // @@protoc_insertion_point(class_scope:bosdyn.api.NetworkComputeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::NetworkComputeInputData* input_data_;
    ::bosdyn::api::NetworkComputeServerConfiguration* server_config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fnetwork_5fcompute_5fbridge_2eproto;
};
// -------------------------------------------------------------------

class ImageSourceAndService final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ImageSourceAndService) */ {
 public:
  inline ImageSourceAndService() : ImageSourceAndService(nullptr) {}
  ~ImageSourceAndService() override;
  explicit PROTOBUF_CONSTEXPR ImageSourceAndService(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageSourceAndService(const ImageSourceAndService& from);
  ImageSourceAndService(ImageSourceAndService&& from) noexcept
    : ImageSourceAndService() {
    *this = ::std::move(from);
  }

  inline ImageSourceAndService& operator=(const ImageSourceAndService& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageSourceAndService& operator=(ImageSourceAndService&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageSourceAndService& default_instance() {
    return *internal_default_instance();
  }
  enum RequestDataCase {
    kImageSource = 1,
    kImageRequest = 3,
    REQUEST_DATA_NOT_SET = 0,
  };

  static inline const ImageSourceAndService* internal_default_instance() {
    return reinterpret_cast<const ImageSourceAndService*>(
               &_ImageSourceAndService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ImageSourceAndService& a, ImageSourceAndService& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageSourceAndService* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageSourceAndService* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageSourceAndService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageSourceAndService>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageSourceAndService& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageSourceAndService& from) {
    ImageSourceAndService::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageSourceAndService* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ImageSourceAndService";
  }
  protected:
  explicit ImageSourceAndService(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageServiceFieldNumber = 2,
    kImageSourceFieldNumber = 1,
    kImageRequestFieldNumber = 3,
  };
  // string image_service = 2;
  void clear_image_service();
  const std::string& image_service() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_service(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_service();
  PROTOBUF_NODISCARD std::string* release_image_service();
  void set_allocated_image_service(std::string* image_service);
  private:
  const std::string& _internal_image_service() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_service(const std::string& value);
  std::string* _internal_mutable_image_service();
  public:

  // string image_source = 1;
  bool has_image_source() const;
  private:
  bool _internal_has_image_source() const;
  public:
  void clear_image_source();
  const std::string& image_source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_source();
  PROTOBUF_NODISCARD std::string* release_image_source();
  void set_allocated_image_source(std::string* image_source);
  private:
  const std::string& _internal_image_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_source(const std::string& value);
  std::string* _internal_mutable_image_source();
  public:

  // .bosdyn.api.ImageRequest image_request = 3;
  bool has_image_request() const;
  private:
  bool _internal_has_image_request() const;
  public:
  void clear_image_request();
  const ::bosdyn::api::ImageRequest& image_request() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ImageRequest* release_image_request();
  ::bosdyn::api::ImageRequest* mutable_image_request();
  void set_allocated_image_request(::bosdyn::api::ImageRequest* image_request);
  private:
  const ::bosdyn::api::ImageRequest& _internal_image_request() const;
  ::bosdyn::api::ImageRequest* _internal_mutable_image_request();
  public:
  void unsafe_arena_set_allocated_image_request(
      ::bosdyn::api::ImageRequest* image_request);
  ::bosdyn::api::ImageRequest* unsafe_arena_release_image_request();

  void clear_request_data();
  RequestDataCase request_data_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.ImageSourceAndService)
 private:
  class _Internal;
  void set_has_image_source();
  void set_has_image_request();

  inline bool has_request_data() const;
  inline void clear_has_request_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_service_;
    union RequestDataUnion {
      constexpr RequestDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_source_;
      ::bosdyn::api::ImageRequest* image_request_;
    } request_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fnetwork_5fcompute_5fbridge_2eproto;
};
// -------------------------------------------------------------------

class NetworkComputeInputData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.NetworkComputeInputData) */ {
 public:
  inline NetworkComputeInputData() : NetworkComputeInputData(nullptr) {}
  ~NetworkComputeInputData() override;
  explicit PROTOBUF_CONSTEXPR NetworkComputeInputData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkComputeInputData(const NetworkComputeInputData& from);
  NetworkComputeInputData(NetworkComputeInputData&& from) noexcept
    : NetworkComputeInputData() {
    *this = ::std::move(from);
  }

  inline NetworkComputeInputData& operator=(const NetworkComputeInputData& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkComputeInputData& operator=(NetworkComputeInputData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkComputeInputData& default_instance() {
    return *internal_default_instance();
  }
  enum InputCase {
    kImageSourceAndService = 7,
    kImage = 2,
    INPUT_NOT_SET = 0,
  };

  static inline const NetworkComputeInputData* internal_default_instance() {
    return reinterpret_cast<const NetworkComputeInputData*>(
               &_NetworkComputeInputData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NetworkComputeInputData& a, NetworkComputeInputData& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkComputeInputData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkComputeInputData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkComputeInputData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkComputeInputData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkComputeInputData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkComputeInputData& from) {
    NetworkComputeInputData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkComputeInputData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.NetworkComputeInputData";
  }
  protected:
  explicit NetworkComputeInputData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NetworkComputeInputData_RotateImage RotateImage;
  static constexpr RotateImage ROTATE_IMAGE_UNKNOWN =
    NetworkComputeInputData_RotateImage_ROTATE_IMAGE_UNKNOWN;
  static constexpr RotateImage ROTATE_IMAGE_NO_ROTATION =
    NetworkComputeInputData_RotateImage_ROTATE_IMAGE_NO_ROTATION;
  static constexpr RotateImage ROTATE_IMAGE_ALIGN_HORIZONTAL =
    NetworkComputeInputData_RotateImage_ROTATE_IMAGE_ALIGN_HORIZONTAL;
  static constexpr RotateImage ROTATE_IMAGE_ALIGN_WITH_BODY =
    NetworkComputeInputData_RotateImage_ROTATE_IMAGE_ALIGN_WITH_BODY;
  static inline bool RotateImage_IsValid(int value) {
    return NetworkComputeInputData_RotateImage_IsValid(value);
  }
  static constexpr RotateImage RotateImage_MIN =
    NetworkComputeInputData_RotateImage_RotateImage_MIN;
  static constexpr RotateImage RotateImage_MAX =
    NetworkComputeInputData_RotateImage_RotateImage_MAX;
  static constexpr int RotateImage_ARRAYSIZE =
    NetworkComputeInputData_RotateImage_RotateImage_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RotateImage_descriptor() {
    return NetworkComputeInputData_RotateImage_descriptor();
  }
  template<typename T>
  static inline const std::string& RotateImage_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RotateImage>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RotateImage_Name.");
    return NetworkComputeInputData_RotateImage_Name(enum_t_value);
  }
  static inline bool RotateImage_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RotateImage* value) {
    return NetworkComputeInputData_RotateImage_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 4,
    kOtherDataFieldNumber = 3,
    kMinConfidenceFieldNumber = 5,
    kRotateImageFieldNumber = 6,
    kImageSourceAndServiceFieldNumber = 7,
    kImageFieldNumber = 2,
  };
  // string model_name = 4;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // .google.protobuf.Any other_data = 3;
  bool has_other_data() const;
  private:
  bool _internal_has_other_data() const;
  public:
  void clear_other_data();
  const ::PROTOBUF_NAMESPACE_ID::Any& other_data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_other_data();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_other_data();
  void set_allocated_other_data(::PROTOBUF_NAMESPACE_ID::Any* other_data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_other_data() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_other_data();
  public:
  void unsafe_arena_set_allocated_other_data(
      ::PROTOBUF_NAMESPACE_ID::Any* other_data);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_other_data();

  // float min_confidence = 5;
  void clear_min_confidence();
  float min_confidence() const;
  void set_min_confidence(float value);
  private:
  float _internal_min_confidence() const;
  void _internal_set_min_confidence(float value);
  public:

  // .bosdyn.api.NetworkComputeInputData.RotateImage rotate_image = 6;
  void clear_rotate_image();
  ::bosdyn::api::NetworkComputeInputData_RotateImage rotate_image() const;
  void set_rotate_image(::bosdyn::api::NetworkComputeInputData_RotateImage value);
  private:
  ::bosdyn::api::NetworkComputeInputData_RotateImage _internal_rotate_image() const;
  void _internal_set_rotate_image(::bosdyn::api::NetworkComputeInputData_RotateImage value);
  public:

  // .bosdyn.api.ImageSourceAndService image_source_and_service = 7;
  bool has_image_source_and_service() const;
  private:
  bool _internal_has_image_source_and_service() const;
  public:
  void clear_image_source_and_service();
  const ::bosdyn::api::ImageSourceAndService& image_source_and_service() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ImageSourceAndService* release_image_source_and_service();
  ::bosdyn::api::ImageSourceAndService* mutable_image_source_and_service();
  void set_allocated_image_source_and_service(::bosdyn::api::ImageSourceAndService* image_source_and_service);
  private:
  const ::bosdyn::api::ImageSourceAndService& _internal_image_source_and_service() const;
  ::bosdyn::api::ImageSourceAndService* _internal_mutable_image_source_and_service();
  public:
  void unsafe_arena_set_allocated_image_source_and_service(
      ::bosdyn::api::ImageSourceAndService* image_source_and_service);
  ::bosdyn::api::ImageSourceAndService* unsafe_arena_release_image_source_and_service();

  // .bosdyn.api.Image image = 2;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::bosdyn::api::Image& image() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Image* release_image();
  ::bosdyn::api::Image* mutable_image();
  void set_allocated_image(::bosdyn::api::Image* image);
  private:
  const ::bosdyn::api::Image& _internal_image() const;
  ::bosdyn::api::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::bosdyn::api::Image* image);
  ::bosdyn::api::Image* unsafe_arena_release_image();

  void clear_input();
  InputCase input_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.NetworkComputeInputData)
 private:
  class _Internal;
  void set_has_image_source_and_service();
  void set_has_image();

  inline bool has_input() const;
  inline void clear_has_input();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    ::PROTOBUF_NAMESPACE_ID::Any* other_data_;
    float min_confidence_;
    int rotate_image_;
    union InputUnion {
      constexpr InputUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::ImageSourceAndService* image_source_and_service_;
      ::bosdyn::api::Image* image_;
    } input_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fnetwork_5fcompute_5fbridge_2eproto;
};
// -------------------------------------------------------------------

class NetworkComputeServerConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.NetworkComputeServerConfiguration) */ {
 public:
  inline NetworkComputeServerConfiguration() : NetworkComputeServerConfiguration(nullptr) {}
  ~NetworkComputeServerConfiguration() override;
  explicit PROTOBUF_CONSTEXPR NetworkComputeServerConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkComputeServerConfiguration(const NetworkComputeServerConfiguration& from);
  NetworkComputeServerConfiguration(NetworkComputeServerConfiguration&& from) noexcept
    : NetworkComputeServerConfiguration() {
    *this = ::std::move(from);
  }

  inline NetworkComputeServerConfiguration& operator=(const NetworkComputeServerConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkComputeServerConfiguration& operator=(NetworkComputeServerConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkComputeServerConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkComputeServerConfiguration* internal_default_instance() {
    return reinterpret_cast<const NetworkComputeServerConfiguration*>(
               &_NetworkComputeServerConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NetworkComputeServerConfiguration& a, NetworkComputeServerConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkComputeServerConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkComputeServerConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkComputeServerConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkComputeServerConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkComputeServerConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkComputeServerConfiguration& from) {
    NetworkComputeServerConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkComputeServerConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.NetworkComputeServerConfiguration";
  }
  protected:
  explicit NetworkComputeServerConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 3,
  };
  // string service_name = 3;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.NetworkComputeServerConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fnetwork_5fcompute_5fbridge_2eproto;
};
// -------------------------------------------------------------------

class OutputImage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.OutputImage) */ {
 public:
  inline OutputImage() : OutputImage(nullptr) {}
  ~OutputImage() override;
  explicit PROTOBUF_CONSTEXPR OutputImage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OutputImage(const OutputImage& from);
  OutputImage(OutputImage&& from) noexcept
    : OutputImage() {
    *this = ::std::move(from);
  }

  inline OutputImage& operator=(const OutputImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutputImage& operator=(OutputImage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutputImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutputImage* internal_default_instance() {
    return reinterpret_cast<const OutputImage*>(
               &_OutputImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OutputImage& a, OutputImage& b) {
    a.Swap(&b);
  }
  inline void Swap(OutputImage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutputImage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutputImage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutputImage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OutputImage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OutputImage& from) {
    OutputImage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputImage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.OutputImage";
  }
  protected:
  explicit OutputImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectInImageFieldNumber = 3,
    kImageResponseFieldNumber = 1,
    kMetadataFieldNumber = 2,
    kAlertDataFieldNumber = 4,
  };
  // repeated .bosdyn.api.WorldObject object_in_image = 3;
  int object_in_image_size() const;
  private:
  int _internal_object_in_image_size() const;
  public:
  void clear_object_in_image();
  ::bosdyn::api::WorldObject* mutable_object_in_image(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::WorldObject >*
      mutable_object_in_image();
  private:
  const ::bosdyn::api::WorldObject& _internal_object_in_image(int index) const;
  ::bosdyn::api::WorldObject* _internal_add_object_in_image();
  public:
  const ::bosdyn::api::WorldObject& object_in_image(int index) const;
  ::bosdyn::api::WorldObject* add_object_in_image();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::WorldObject >&
      object_in_image() const;

  // .bosdyn.api.ImageResponse image_response = 1;
  bool has_image_response() const;
  private:
  bool _internal_has_image_response() const;
  public:
  void clear_image_response();
  const ::bosdyn::api::ImageResponse& image_response() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ImageResponse* release_image_response();
  ::bosdyn::api::ImageResponse* mutable_image_response();
  void set_allocated_image_response(::bosdyn::api::ImageResponse* image_response);
  private:
  const ::bosdyn::api::ImageResponse& _internal_image_response() const;
  ::bosdyn::api::ImageResponse* _internal_mutable_image_response();
  public:
  void unsafe_arena_set_allocated_image_response(
      ::bosdyn::api::ImageResponse* image_response);
  ::bosdyn::api::ImageResponse* unsafe_arena_release_image_response();

  // .google.protobuf.Struct metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .bosdyn.api.AlertData alert_data = 4;
  bool has_alert_data() const;
  private:
  bool _internal_has_alert_data() const;
  public:
  void clear_alert_data();
  const ::bosdyn::api::AlertData& alert_data() const;
  PROTOBUF_NODISCARD ::bosdyn::api::AlertData* release_alert_data();
  ::bosdyn::api::AlertData* mutable_alert_data();
  void set_allocated_alert_data(::bosdyn::api::AlertData* alert_data);
  private:
  const ::bosdyn::api::AlertData& _internal_alert_data() const;
  ::bosdyn::api::AlertData* _internal_mutable_alert_data();
  public:
  void unsafe_arena_set_allocated_alert_data(
      ::bosdyn::api::AlertData* alert_data);
  ::bosdyn::api::AlertData* unsafe_arena_release_alert_data();

  // @@protoc_insertion_point(class_scope:bosdyn.api.OutputImage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::WorldObject > object_in_image_;
    ::bosdyn::api::ImageResponse* image_response_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::bosdyn::api::AlertData* alert_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fnetwork_5fcompute_5fbridge_2eproto;
};
// -------------------------------------------------------------------

class NetworkComputeResponse_OutputImagesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NetworkComputeResponse_OutputImagesEntry_DoNotUse, 
    std::string, ::bosdyn::api::OutputImage,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NetworkComputeResponse_OutputImagesEntry_DoNotUse, 
    std::string, ::bosdyn::api::OutputImage,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  NetworkComputeResponse_OutputImagesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR NetworkComputeResponse_OutputImagesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit NetworkComputeResponse_OutputImagesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NetworkComputeResponse_OutputImagesEntry_DoNotUse& other);
  static const NetworkComputeResponse_OutputImagesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NetworkComputeResponse_OutputImagesEntry_DoNotUse*>(&_NetworkComputeResponse_OutputImagesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.NetworkComputeResponse.OutputImagesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fnetwork_5fcompute_5fbridge_2eproto;
};

// -------------------------------------------------------------------

class NetworkComputeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.NetworkComputeResponse) */ {
 public:
  inline NetworkComputeResponse() : NetworkComputeResponse(nullptr) {}
  ~NetworkComputeResponse() override;
  explicit PROTOBUF_CONSTEXPR NetworkComputeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkComputeResponse(const NetworkComputeResponse& from);
  NetworkComputeResponse(NetworkComputeResponse&& from) noexcept
    : NetworkComputeResponse() {
    *this = ::std::move(from);
  }

  inline NetworkComputeResponse& operator=(const NetworkComputeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkComputeResponse& operator=(NetworkComputeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkComputeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkComputeResponse* internal_default_instance() {
    return reinterpret_cast<const NetworkComputeResponse*>(
               &_NetworkComputeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(NetworkComputeResponse& a, NetworkComputeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkComputeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkComputeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkComputeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkComputeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkComputeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkComputeResponse& from) {
    NetworkComputeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkComputeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.NetworkComputeResponse";
  }
  protected:
  explicit NetworkComputeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kObjectInImageFieldNumber = 2,
    kOutputImagesFieldNumber = 8,
    kHeaderFieldNumber = 1,
    kImageResponseFieldNumber = 3,
    kOtherDataFieldNumber = 4,
    kAlertDataFieldNumber = 7,
    kImageRotationAngleFieldNumber = 6,
    kStatusFieldNumber = 5,
  };
  // repeated .bosdyn.api.WorldObject object_in_image = 2;
  int object_in_image_size() const;
  private:
  int _internal_object_in_image_size() const;
  public:
  void clear_object_in_image();
  ::bosdyn::api::WorldObject* mutable_object_in_image(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::WorldObject >*
      mutable_object_in_image();
  private:
  const ::bosdyn::api::WorldObject& _internal_object_in_image(int index) const;
  ::bosdyn::api::WorldObject* _internal_add_object_in_image();
  public:
  const ::bosdyn::api::WorldObject& object_in_image(int index) const;
  ::bosdyn::api::WorldObject* add_object_in_image();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::WorldObject >&
      object_in_image() const;

  // map<string, .bosdyn.api.OutputImage> output_images = 8;
  int output_images_size() const;
  private:
  int _internal_output_images_size() const;
  public:
  void clear_output_images();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::OutputImage >&
      _internal_output_images() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::OutputImage >*
      _internal_mutable_output_images();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::OutputImage >&
      output_images() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::OutputImage >*
      mutable_output_images();

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.ImageResponse image_response = 3;
  bool has_image_response() const;
  private:
  bool _internal_has_image_response() const;
  public:
  void clear_image_response();
  const ::bosdyn::api::ImageResponse& image_response() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ImageResponse* release_image_response();
  ::bosdyn::api::ImageResponse* mutable_image_response();
  void set_allocated_image_response(::bosdyn::api::ImageResponse* image_response);
  private:
  const ::bosdyn::api::ImageResponse& _internal_image_response() const;
  ::bosdyn::api::ImageResponse* _internal_mutable_image_response();
  public:
  void unsafe_arena_set_allocated_image_response(
      ::bosdyn::api::ImageResponse* image_response);
  ::bosdyn::api::ImageResponse* unsafe_arena_release_image_response();

  // .google.protobuf.Any other_data = 4;
  bool has_other_data() const;
  private:
  bool _internal_has_other_data() const;
  public:
  void clear_other_data();
  const ::PROTOBUF_NAMESPACE_ID::Any& other_data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_other_data();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_other_data();
  void set_allocated_other_data(::PROTOBUF_NAMESPACE_ID::Any* other_data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_other_data() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_other_data();
  public:
  void unsafe_arena_set_allocated_other_data(
      ::PROTOBUF_NAMESPACE_ID::Any* other_data);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_other_data();

  // .bosdyn.api.AlertData alert_data = 7;
  bool has_alert_data() const;
  private:
  bool _internal_has_alert_data() const;
  public:
  void clear_alert_data();
  const ::bosdyn::api::AlertData& alert_data() const;
  PROTOBUF_NODISCARD ::bosdyn::api::AlertData* release_alert_data();
  ::bosdyn::api::AlertData* mutable_alert_data();
  void set_allocated_alert_data(::bosdyn::api::AlertData* alert_data);
  private:
  const ::bosdyn::api::AlertData& _internal_alert_data() const;
  ::bosdyn::api::AlertData* _internal_mutable_alert_data();
  public:
  void unsafe_arena_set_allocated_alert_data(
      ::bosdyn::api::AlertData* alert_data);
  ::bosdyn::api::AlertData* unsafe_arena_release_alert_data();

  // double image_rotation_angle = 6;
  void clear_image_rotation_angle();
  double image_rotation_angle() const;
  void set_image_rotation_angle(double value);
  private:
  double _internal_image_rotation_angle() const;
  void _internal_set_image_rotation_angle(double value);
  public:

  // .bosdyn.api.NetworkComputeStatus status = 5;
  void clear_status();
  ::bosdyn::api::NetworkComputeStatus status() const;
  void set_status(::bosdyn::api::NetworkComputeStatus value);
  private:
  ::bosdyn::api::NetworkComputeStatus _internal_status() const;
  void _internal_set_status(::bosdyn::api::NetworkComputeStatus value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.NetworkComputeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::WorldObject > object_in_image_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        NetworkComputeResponse_OutputImagesEntry_DoNotUse,
        std::string, ::bosdyn::api::OutputImage,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> output_images_;
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::ImageResponse* image_response_;
    ::PROTOBUF_NAMESPACE_ID::Any* other_data_;
    ::bosdyn::api::AlertData* alert_data_;
    double image_rotation_angle_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fnetwork_5fcompute_5fbridge_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ListAvailableModelsRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListAvailableModelsRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListAvailableModelsRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListAvailableModelsRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListAvailableModelsRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListAvailableModelsRequest.header)
  return _internal_header();
}
inline void ListAvailableModelsRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListAvailableModelsRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListAvailableModelsRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListAvailableModelsRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListAvailableModelsRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListAvailableModelsRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ListAvailableModelsRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListAvailableModelsRequest.header)
  return _msg;
}
inline void ListAvailableModelsRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListAvailableModelsRequest.header)
}

// .bosdyn.api.NetworkComputeServerConfiguration server_config = 2;
inline bool ListAvailableModelsRequest::_internal_has_server_config() const {
  return this != internal_default_instance() && _impl_.server_config_ != nullptr;
}
inline bool ListAvailableModelsRequest::has_server_config() const {
  return _internal_has_server_config();
}
inline void ListAvailableModelsRequest::clear_server_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.server_config_ != nullptr) {
    delete _impl_.server_config_;
  }
  _impl_.server_config_ = nullptr;
}
inline const ::bosdyn::api::NetworkComputeServerConfiguration& ListAvailableModelsRequest::_internal_server_config() const {
  const ::bosdyn::api::NetworkComputeServerConfiguration* p = _impl_.server_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::NetworkComputeServerConfiguration&>(
      ::bosdyn::api::_NetworkComputeServerConfiguration_default_instance_);
}
inline const ::bosdyn::api::NetworkComputeServerConfiguration& ListAvailableModelsRequest::server_config() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListAvailableModelsRequest.server_config)
  return _internal_server_config();
}
inline void ListAvailableModelsRequest::unsafe_arena_set_allocated_server_config(
    ::bosdyn::api::NetworkComputeServerConfiguration* server_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_config_);
  }
  _impl_.server_config_ = server_config;
  if (server_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListAvailableModelsRequest.server_config)
}
inline ::bosdyn::api::NetworkComputeServerConfiguration* ListAvailableModelsRequest::release_server_config() {
  
  ::bosdyn::api::NetworkComputeServerConfiguration* temp = _impl_.server_config_;
  _impl_.server_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::NetworkComputeServerConfiguration* ListAvailableModelsRequest::unsafe_arena_release_server_config() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListAvailableModelsRequest.server_config)
  
  ::bosdyn::api::NetworkComputeServerConfiguration* temp = _impl_.server_config_;
  _impl_.server_config_ = nullptr;
  return temp;
}
inline ::bosdyn::api::NetworkComputeServerConfiguration* ListAvailableModelsRequest::_internal_mutable_server_config() {
  
  if (_impl_.server_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::NetworkComputeServerConfiguration>(GetArenaForAllocation());
    _impl_.server_config_ = p;
  }
  return _impl_.server_config_;
}
inline ::bosdyn::api::NetworkComputeServerConfiguration* ListAvailableModelsRequest::mutable_server_config() {
  ::bosdyn::api::NetworkComputeServerConfiguration* _msg = _internal_mutable_server_config();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListAvailableModelsRequest.server_config)
  return _msg;
}
inline void ListAvailableModelsRequest::set_allocated_server_config(::bosdyn::api::NetworkComputeServerConfiguration* server_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.server_config_;
  }
  if (server_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(server_config);
    if (message_arena != submessage_arena) {
      server_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.server_config_ = server_config;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListAvailableModelsRequest.server_config)
}

// -------------------------------------------------------------------

// ListAvailableModelsResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListAvailableModelsResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListAvailableModelsResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListAvailableModelsResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListAvailableModelsResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListAvailableModelsResponse.header)
  return _internal_header();
}
inline void ListAvailableModelsResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListAvailableModelsResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListAvailableModelsResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListAvailableModelsResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListAvailableModelsResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListAvailableModelsResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ListAvailableModelsResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListAvailableModelsResponse.header)
  return _msg;
}
inline void ListAvailableModelsResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListAvailableModelsResponse.header)
}

// repeated string available_models = 2;
inline int ListAvailableModelsResponse::_internal_available_models_size() const {
  return _impl_.available_models_.size();
}
inline int ListAvailableModelsResponse::available_models_size() const {
  return _internal_available_models_size();
}
inline void ListAvailableModelsResponse::clear_available_models() {
  _impl_.available_models_.Clear();
}
inline std::string* ListAvailableModelsResponse::add_available_models() {
  std::string* _s = _internal_add_available_models();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.ListAvailableModelsResponse.available_models)
  return _s;
}
inline const std::string& ListAvailableModelsResponse::_internal_available_models(int index) const {
  return _impl_.available_models_.Get(index);
}
inline const std::string& ListAvailableModelsResponse::available_models(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListAvailableModelsResponse.available_models)
  return _internal_available_models(index);
}
inline std::string* ListAvailableModelsResponse::mutable_available_models(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListAvailableModelsResponse.available_models)
  return _impl_.available_models_.Mutable(index);
}
inline void ListAvailableModelsResponse::set_available_models(int index, const std::string& value) {
  _impl_.available_models_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ListAvailableModelsResponse.available_models)
}
inline void ListAvailableModelsResponse::set_available_models(int index, std::string&& value) {
  _impl_.available_models_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.ListAvailableModelsResponse.available_models)
}
inline void ListAvailableModelsResponse::set_available_models(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.available_models_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.ListAvailableModelsResponse.available_models)
}
inline void ListAvailableModelsResponse::set_available_models(int index, const char* value, size_t size) {
  _impl_.available_models_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.ListAvailableModelsResponse.available_models)
}
inline std::string* ListAvailableModelsResponse::_internal_add_available_models() {
  return _impl_.available_models_.Add();
}
inline void ListAvailableModelsResponse::add_available_models(const std::string& value) {
  _impl_.available_models_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.ListAvailableModelsResponse.available_models)
}
inline void ListAvailableModelsResponse::add_available_models(std::string&& value) {
  _impl_.available_models_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.ListAvailableModelsResponse.available_models)
}
inline void ListAvailableModelsResponse::add_available_models(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.available_models_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.ListAvailableModelsResponse.available_models)
}
inline void ListAvailableModelsResponse::add_available_models(const char* value, size_t size) {
  _impl_.available_models_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.ListAvailableModelsResponse.available_models)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListAvailableModelsResponse::available_models() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ListAvailableModelsResponse.available_models)
  return _impl_.available_models_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListAvailableModelsResponse::mutable_available_models() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ListAvailableModelsResponse.available_models)
  return &_impl_.available_models_;
}

// repeated .bosdyn.api.ModelLabels labels = 6;
inline int ListAvailableModelsResponse::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int ListAvailableModelsResponse::labels_size() const {
  return _internal_labels_size();
}
inline void ListAvailableModelsResponse::clear_labels() {
  _impl_.labels_.Clear();
}
inline ::bosdyn::api::ModelLabels* ListAvailableModelsResponse::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListAvailableModelsResponse.labels)
  return _impl_.labels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ModelLabels >*
ListAvailableModelsResponse::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ListAvailableModelsResponse.labels)
  return &_impl_.labels_;
}
inline const ::bosdyn::api::ModelLabels& ListAvailableModelsResponse::_internal_labels(int index) const {
  return _impl_.labels_.Get(index);
}
inline const ::bosdyn::api::ModelLabels& ListAvailableModelsResponse::labels(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListAvailableModelsResponse.labels)
  return _internal_labels(index);
}
inline ::bosdyn::api::ModelLabels* ListAvailableModelsResponse::_internal_add_labels() {
  return _impl_.labels_.Add();
}
inline ::bosdyn::api::ModelLabels* ListAvailableModelsResponse::add_labels() {
  ::bosdyn::api::ModelLabels* _add = _internal_add_labels();
  // @@protoc_insertion_point(field_add:bosdyn.api.ListAvailableModelsResponse.labels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ModelLabels >&
ListAvailableModelsResponse::labels() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ListAvailableModelsResponse.labels)
  return _impl_.labels_;
}

// .bosdyn.api.ListAvailableModelsStatus status = 5;
inline void ListAvailableModelsResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::ListAvailableModelsStatus ListAvailableModelsResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::ListAvailableModelsStatus >(_impl_.status_);
}
inline ::bosdyn::api::ListAvailableModelsStatus ListAvailableModelsResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListAvailableModelsResponse.status)
  return _internal_status();
}
inline void ListAvailableModelsResponse::_internal_set_status(::bosdyn::api::ListAvailableModelsStatus value) {
  
  _impl_.status_ = value;
}
inline void ListAvailableModelsResponse::set_status(::bosdyn::api::ListAvailableModelsStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ListAvailableModelsResponse.status)
}

// -------------------------------------------------------------------

// ModelLabels

// string model_name = 1;
inline void ModelLabels::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& ModelLabels::model_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ModelLabels.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelLabels::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.ModelLabels.model_name)
}
inline std::string* ModelLabels::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ModelLabels.model_name)
  return _s;
}
inline const std::string& ModelLabels::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void ModelLabels::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelLabels::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelLabels::release_model_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ModelLabels.model_name)
  return _impl_.model_name_.Release();
}
inline void ModelLabels::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ModelLabels.model_name)
}

// repeated string available_labels = 2;
inline int ModelLabels::_internal_available_labels_size() const {
  return _impl_.available_labels_.size();
}
inline int ModelLabels::available_labels_size() const {
  return _internal_available_labels_size();
}
inline void ModelLabels::clear_available_labels() {
  _impl_.available_labels_.Clear();
}
inline std::string* ModelLabels::add_available_labels() {
  std::string* _s = _internal_add_available_labels();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.ModelLabels.available_labels)
  return _s;
}
inline const std::string& ModelLabels::_internal_available_labels(int index) const {
  return _impl_.available_labels_.Get(index);
}
inline const std::string& ModelLabels::available_labels(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ModelLabels.available_labels)
  return _internal_available_labels(index);
}
inline std::string* ModelLabels::mutable_available_labels(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ModelLabels.available_labels)
  return _impl_.available_labels_.Mutable(index);
}
inline void ModelLabels::set_available_labels(int index, const std::string& value) {
  _impl_.available_labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ModelLabels.available_labels)
}
inline void ModelLabels::set_available_labels(int index, std::string&& value) {
  _impl_.available_labels_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.ModelLabels.available_labels)
}
inline void ModelLabels::set_available_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.available_labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.ModelLabels.available_labels)
}
inline void ModelLabels::set_available_labels(int index, const char* value, size_t size) {
  _impl_.available_labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.ModelLabels.available_labels)
}
inline std::string* ModelLabels::_internal_add_available_labels() {
  return _impl_.available_labels_.Add();
}
inline void ModelLabels::add_available_labels(const std::string& value) {
  _impl_.available_labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.ModelLabels.available_labels)
}
inline void ModelLabels::add_available_labels(std::string&& value) {
  _impl_.available_labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.ModelLabels.available_labels)
}
inline void ModelLabels::add_available_labels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.available_labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.ModelLabels.available_labels)
}
inline void ModelLabels::add_available_labels(const char* value, size_t size) {
  _impl_.available_labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.ModelLabels.available_labels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelLabels::available_labels() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ModelLabels.available_labels)
  return _impl_.available_labels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelLabels::mutable_available_labels() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ModelLabels.available_labels)
  return &_impl_.available_labels_;
}

// -------------------------------------------------------------------

// NetworkComputeRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool NetworkComputeRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool NetworkComputeRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& NetworkComputeRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& NetworkComputeRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeRequest.header)
  return _internal_header();
}
inline void NetworkComputeRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.NetworkComputeRequest.header)
}
inline ::bosdyn::api::RequestHeader* NetworkComputeRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* NetworkComputeRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* NetworkComputeRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* NetworkComputeRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeRequest.header)
  return _msg;
}
inline void NetworkComputeRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.NetworkComputeRequest.header)
}

// .bosdyn.api.NetworkComputeInputData input_data = 2;
inline bool NetworkComputeRequest::_internal_has_input_data() const {
  return this != internal_default_instance() && _impl_.input_data_ != nullptr;
}
inline bool NetworkComputeRequest::has_input_data() const {
  return _internal_has_input_data();
}
inline void NetworkComputeRequest::clear_input_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_data_ != nullptr) {
    delete _impl_.input_data_;
  }
  _impl_.input_data_ = nullptr;
}
inline const ::bosdyn::api::NetworkComputeInputData& NetworkComputeRequest::_internal_input_data() const {
  const ::bosdyn::api::NetworkComputeInputData* p = _impl_.input_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::NetworkComputeInputData&>(
      ::bosdyn::api::_NetworkComputeInputData_default_instance_);
}
inline const ::bosdyn::api::NetworkComputeInputData& NetworkComputeRequest::input_data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeRequest.input_data)
  return _internal_input_data();
}
inline void NetworkComputeRequest::unsafe_arena_set_allocated_input_data(
    ::bosdyn::api::NetworkComputeInputData* input_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_data_);
  }
  _impl_.input_data_ = input_data;
  if (input_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.NetworkComputeRequest.input_data)
}
inline ::bosdyn::api::NetworkComputeInputData* NetworkComputeRequest::release_input_data() {
  
  ::bosdyn::api::NetworkComputeInputData* temp = _impl_.input_data_;
  _impl_.input_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::NetworkComputeInputData* NetworkComputeRequest::unsafe_arena_release_input_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeRequest.input_data)
  
  ::bosdyn::api::NetworkComputeInputData* temp = _impl_.input_data_;
  _impl_.input_data_ = nullptr;
  return temp;
}
inline ::bosdyn::api::NetworkComputeInputData* NetworkComputeRequest::_internal_mutable_input_data() {
  
  if (_impl_.input_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::NetworkComputeInputData>(GetArenaForAllocation());
    _impl_.input_data_ = p;
  }
  return _impl_.input_data_;
}
inline ::bosdyn::api::NetworkComputeInputData* NetworkComputeRequest::mutable_input_data() {
  ::bosdyn::api::NetworkComputeInputData* _msg = _internal_mutable_input_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeRequest.input_data)
  return _msg;
}
inline void NetworkComputeRequest::set_allocated_input_data(::bosdyn::api::NetworkComputeInputData* input_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_data_;
  }
  if (input_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input_data);
    if (message_arena != submessage_arena) {
      input_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_data_ = input_data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.NetworkComputeRequest.input_data)
}

// .bosdyn.api.NetworkComputeServerConfiguration server_config = 3;
inline bool NetworkComputeRequest::_internal_has_server_config() const {
  return this != internal_default_instance() && _impl_.server_config_ != nullptr;
}
inline bool NetworkComputeRequest::has_server_config() const {
  return _internal_has_server_config();
}
inline void NetworkComputeRequest::clear_server_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.server_config_ != nullptr) {
    delete _impl_.server_config_;
  }
  _impl_.server_config_ = nullptr;
}
inline const ::bosdyn::api::NetworkComputeServerConfiguration& NetworkComputeRequest::_internal_server_config() const {
  const ::bosdyn::api::NetworkComputeServerConfiguration* p = _impl_.server_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::NetworkComputeServerConfiguration&>(
      ::bosdyn::api::_NetworkComputeServerConfiguration_default_instance_);
}
inline const ::bosdyn::api::NetworkComputeServerConfiguration& NetworkComputeRequest::server_config() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeRequest.server_config)
  return _internal_server_config();
}
inline void NetworkComputeRequest::unsafe_arena_set_allocated_server_config(
    ::bosdyn::api::NetworkComputeServerConfiguration* server_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_config_);
  }
  _impl_.server_config_ = server_config;
  if (server_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.NetworkComputeRequest.server_config)
}
inline ::bosdyn::api::NetworkComputeServerConfiguration* NetworkComputeRequest::release_server_config() {
  
  ::bosdyn::api::NetworkComputeServerConfiguration* temp = _impl_.server_config_;
  _impl_.server_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::NetworkComputeServerConfiguration* NetworkComputeRequest::unsafe_arena_release_server_config() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeRequest.server_config)
  
  ::bosdyn::api::NetworkComputeServerConfiguration* temp = _impl_.server_config_;
  _impl_.server_config_ = nullptr;
  return temp;
}
inline ::bosdyn::api::NetworkComputeServerConfiguration* NetworkComputeRequest::_internal_mutable_server_config() {
  
  if (_impl_.server_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::NetworkComputeServerConfiguration>(GetArenaForAllocation());
    _impl_.server_config_ = p;
  }
  return _impl_.server_config_;
}
inline ::bosdyn::api::NetworkComputeServerConfiguration* NetworkComputeRequest::mutable_server_config() {
  ::bosdyn::api::NetworkComputeServerConfiguration* _msg = _internal_mutable_server_config();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeRequest.server_config)
  return _msg;
}
inline void NetworkComputeRequest::set_allocated_server_config(::bosdyn::api::NetworkComputeServerConfiguration* server_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.server_config_;
  }
  if (server_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(server_config);
    if (message_arena != submessage_arena) {
      server_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.server_config_ = server_config;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.NetworkComputeRequest.server_config)
}

// -------------------------------------------------------------------

// ImageSourceAndService

// string image_source = 1;
inline bool ImageSourceAndService::_internal_has_image_source() const {
  return request_data_case() == kImageSource;
}
inline bool ImageSourceAndService::has_image_source() const {
  return _internal_has_image_source();
}
inline void ImageSourceAndService::set_has_image_source() {
  _impl_._oneof_case_[0] = kImageSource;
}
inline void ImageSourceAndService::clear_image_source() {
  if (_internal_has_image_source()) {
    _impl_.request_data_.image_source_.Destroy();
    clear_has_request_data();
  }
}
inline const std::string& ImageSourceAndService::image_source() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSourceAndService.image_source)
  return _internal_image_source();
}
template <typename ArgT0, typename... ArgT>
inline void ImageSourceAndService::set_image_source(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_image_source()) {
    clear_request_data();
    set_has_image_source();
    _impl_.request_data_.image_source_.InitDefault();
  }
  _impl_.request_data_.image_source_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSourceAndService.image_source)
}
inline std::string* ImageSourceAndService::mutable_image_source() {
  std::string* _s = _internal_mutable_image_source();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSourceAndService.image_source)
  return _s;
}
inline const std::string& ImageSourceAndService::_internal_image_source() const {
  if (_internal_has_image_source()) {
    return _impl_.request_data_.image_source_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ImageSourceAndService::_internal_set_image_source(const std::string& value) {
  if (!_internal_has_image_source()) {
    clear_request_data();
    set_has_image_source();
    _impl_.request_data_.image_source_.InitDefault();
  }
  _impl_.request_data_.image_source_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageSourceAndService::_internal_mutable_image_source() {
  if (!_internal_has_image_source()) {
    clear_request_data();
    set_has_image_source();
    _impl_.request_data_.image_source_.InitDefault();
  }
  return _impl_.request_data_.image_source_.Mutable(      GetArenaForAllocation());
}
inline std::string* ImageSourceAndService::release_image_source() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSourceAndService.image_source)
  if (_internal_has_image_source()) {
    clear_has_request_data();
    return _impl_.request_data_.image_source_.Release();
  } else {
    return nullptr;
  }
}
inline void ImageSourceAndService::set_allocated_image_source(std::string* image_source) {
  if (has_request_data()) {
    clear_request_data();
  }
  if (image_source != nullptr) {
    set_has_image_source();
    _impl_.request_data_.image_source_.InitAllocated(image_source, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageSourceAndService.image_source)
}

// .bosdyn.api.ImageRequest image_request = 3;
inline bool ImageSourceAndService::_internal_has_image_request() const {
  return request_data_case() == kImageRequest;
}
inline bool ImageSourceAndService::has_image_request() const {
  return _internal_has_image_request();
}
inline void ImageSourceAndService::set_has_image_request() {
  _impl_._oneof_case_[0] = kImageRequest;
}
inline ::bosdyn::api::ImageRequest* ImageSourceAndService::release_image_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSourceAndService.image_request)
  if (_internal_has_image_request()) {
    clear_has_request_data();
    ::bosdyn::api::ImageRequest* temp = _impl_.request_data_.image_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_data_.image_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::ImageRequest& ImageSourceAndService::_internal_image_request() const {
  return _internal_has_image_request()
      ? *_impl_.request_data_.image_request_
      : reinterpret_cast< ::bosdyn::api::ImageRequest&>(::bosdyn::api::_ImageRequest_default_instance_);
}
inline const ::bosdyn::api::ImageRequest& ImageSourceAndService::image_request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSourceAndService.image_request)
  return _internal_image_request();
}
inline ::bosdyn::api::ImageRequest* ImageSourceAndService::unsafe_arena_release_image_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.ImageSourceAndService.image_request)
  if (_internal_has_image_request()) {
    clear_has_request_data();
    ::bosdyn::api::ImageRequest* temp = _impl_.request_data_.image_request_;
    _impl_.request_data_.image_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ImageSourceAndService::unsafe_arena_set_allocated_image_request(::bosdyn::api::ImageRequest* image_request) {
  clear_request_data();
  if (image_request) {
    set_has_image_request();
    _impl_.request_data_.image_request_ = image_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageSourceAndService.image_request)
}
inline ::bosdyn::api::ImageRequest* ImageSourceAndService::_internal_mutable_image_request() {
  if (!_internal_has_image_request()) {
    clear_request_data();
    set_has_image_request();
    _impl_.request_data_.image_request_ = CreateMaybeMessage< ::bosdyn::api::ImageRequest >(GetArenaForAllocation());
  }
  return _impl_.request_data_.image_request_;
}
inline ::bosdyn::api::ImageRequest* ImageSourceAndService::mutable_image_request() {
  ::bosdyn::api::ImageRequest* _msg = _internal_mutable_image_request();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSourceAndService.image_request)
  return _msg;
}

// string image_service = 2;
inline void ImageSourceAndService::clear_image_service() {
  _impl_.image_service_.ClearToEmpty();
}
inline const std::string& ImageSourceAndService::image_service() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSourceAndService.image_service)
  return _internal_image_service();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageSourceAndService::set_image_service(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_service_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSourceAndService.image_service)
}
inline std::string* ImageSourceAndService::mutable_image_service() {
  std::string* _s = _internal_mutable_image_service();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSourceAndService.image_service)
  return _s;
}
inline const std::string& ImageSourceAndService::_internal_image_service() const {
  return _impl_.image_service_.Get();
}
inline void ImageSourceAndService::_internal_set_image_service(const std::string& value) {
  
  _impl_.image_service_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageSourceAndService::_internal_mutable_image_service() {
  
  return _impl_.image_service_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageSourceAndService::release_image_service() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSourceAndService.image_service)
  return _impl_.image_service_.Release();
}
inline void ImageSourceAndService::set_allocated_image_service(std::string* image_service) {
  if (image_service != nullptr) {
    
  } else {
    
  }
  _impl_.image_service_.SetAllocated(image_service, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_service_.IsDefault()) {
    _impl_.image_service_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageSourceAndService.image_service)
}

inline bool ImageSourceAndService::has_request_data() const {
  return request_data_case() != REQUEST_DATA_NOT_SET;
}
inline void ImageSourceAndService::clear_has_request_data() {
  _impl_._oneof_case_[0] = REQUEST_DATA_NOT_SET;
}
inline ImageSourceAndService::RequestDataCase ImageSourceAndService::request_data_case() const {
  return ImageSourceAndService::RequestDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NetworkComputeInputData

// .bosdyn.api.ImageSourceAndService image_source_and_service = 7;
inline bool NetworkComputeInputData::_internal_has_image_source_and_service() const {
  return input_case() == kImageSourceAndService;
}
inline bool NetworkComputeInputData::has_image_source_and_service() const {
  return _internal_has_image_source_and_service();
}
inline void NetworkComputeInputData::set_has_image_source_and_service() {
  _impl_._oneof_case_[0] = kImageSourceAndService;
}
inline void NetworkComputeInputData::clear_image_source_and_service() {
  if (_internal_has_image_source_and_service()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.input_.image_source_and_service_;
    }
    clear_has_input();
  }
}
inline ::bosdyn::api::ImageSourceAndService* NetworkComputeInputData::release_image_source_and_service() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeInputData.image_source_and_service)
  if (_internal_has_image_source_and_service()) {
    clear_has_input();
    ::bosdyn::api::ImageSourceAndService* temp = _impl_.input_.image_source_and_service_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.input_.image_source_and_service_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::ImageSourceAndService& NetworkComputeInputData::_internal_image_source_and_service() const {
  return _internal_has_image_source_and_service()
      ? *_impl_.input_.image_source_and_service_
      : reinterpret_cast< ::bosdyn::api::ImageSourceAndService&>(::bosdyn::api::_ImageSourceAndService_default_instance_);
}
inline const ::bosdyn::api::ImageSourceAndService& NetworkComputeInputData::image_source_and_service() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeInputData.image_source_and_service)
  return _internal_image_source_and_service();
}
inline ::bosdyn::api::ImageSourceAndService* NetworkComputeInputData::unsafe_arena_release_image_source_and_service() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.NetworkComputeInputData.image_source_and_service)
  if (_internal_has_image_source_and_service()) {
    clear_has_input();
    ::bosdyn::api::ImageSourceAndService* temp = _impl_.input_.image_source_and_service_;
    _impl_.input_.image_source_and_service_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NetworkComputeInputData::unsafe_arena_set_allocated_image_source_and_service(::bosdyn::api::ImageSourceAndService* image_source_and_service) {
  clear_input();
  if (image_source_and_service) {
    set_has_image_source_and_service();
    _impl_.input_.image_source_and_service_ = image_source_and_service;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.NetworkComputeInputData.image_source_and_service)
}
inline ::bosdyn::api::ImageSourceAndService* NetworkComputeInputData::_internal_mutable_image_source_and_service() {
  if (!_internal_has_image_source_and_service()) {
    clear_input();
    set_has_image_source_and_service();
    _impl_.input_.image_source_and_service_ = CreateMaybeMessage< ::bosdyn::api::ImageSourceAndService >(GetArenaForAllocation());
  }
  return _impl_.input_.image_source_and_service_;
}
inline ::bosdyn::api::ImageSourceAndService* NetworkComputeInputData::mutable_image_source_and_service() {
  ::bosdyn::api::ImageSourceAndService* _msg = _internal_mutable_image_source_and_service();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeInputData.image_source_and_service)
  return _msg;
}

// .bosdyn.api.Image image = 2;
inline bool NetworkComputeInputData::_internal_has_image() const {
  return input_case() == kImage;
}
inline bool NetworkComputeInputData::has_image() const {
  return _internal_has_image();
}
inline void NetworkComputeInputData::set_has_image() {
  _impl_._oneof_case_[0] = kImage;
}
inline ::bosdyn::api::Image* NetworkComputeInputData::release_image() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeInputData.image)
  if (_internal_has_image()) {
    clear_has_input();
    ::bosdyn::api::Image* temp = _impl_.input_.image_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.input_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::Image& NetworkComputeInputData::_internal_image() const {
  return _internal_has_image()
      ? *_impl_.input_.image_
      : reinterpret_cast< ::bosdyn::api::Image&>(::bosdyn::api::_Image_default_instance_);
}
inline const ::bosdyn::api::Image& NetworkComputeInputData::image() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeInputData.image)
  return _internal_image();
}
inline ::bosdyn::api::Image* NetworkComputeInputData::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.NetworkComputeInputData.image)
  if (_internal_has_image()) {
    clear_has_input();
    ::bosdyn::api::Image* temp = _impl_.input_.image_;
    _impl_.input_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NetworkComputeInputData::unsafe_arena_set_allocated_image(::bosdyn::api::Image* image) {
  clear_input();
  if (image) {
    set_has_image();
    _impl_.input_.image_ = image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.NetworkComputeInputData.image)
}
inline ::bosdyn::api::Image* NetworkComputeInputData::_internal_mutable_image() {
  if (!_internal_has_image()) {
    clear_input();
    set_has_image();
    _impl_.input_.image_ = CreateMaybeMessage< ::bosdyn::api::Image >(GetArenaForAllocation());
  }
  return _impl_.input_.image_;
}
inline ::bosdyn::api::Image* NetworkComputeInputData::mutable_image() {
  ::bosdyn::api::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeInputData.image)
  return _msg;
}

// .google.protobuf.Any other_data = 3;
inline bool NetworkComputeInputData::_internal_has_other_data() const {
  return this != internal_default_instance() && _impl_.other_data_ != nullptr;
}
inline bool NetworkComputeInputData::has_other_data() const {
  return _internal_has_other_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& NetworkComputeInputData::_internal_other_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.other_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& NetworkComputeInputData::other_data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeInputData.other_data)
  return _internal_other_data();
}
inline void NetworkComputeInputData::unsafe_arena_set_allocated_other_data(
    ::PROTOBUF_NAMESPACE_ID::Any* other_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.other_data_);
  }
  _impl_.other_data_ = other_data;
  if (other_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.NetworkComputeInputData.other_data)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* NetworkComputeInputData::release_other_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.other_data_;
  _impl_.other_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* NetworkComputeInputData::unsafe_arena_release_other_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeInputData.other_data)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.other_data_;
  _impl_.other_data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* NetworkComputeInputData::_internal_mutable_other_data() {
  
  if (_impl_.other_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.other_data_ = p;
  }
  return _impl_.other_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* NetworkComputeInputData::mutable_other_data() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_other_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeInputData.other_data)
  return _msg;
}
inline void NetworkComputeInputData::set_allocated_other_data(::PROTOBUF_NAMESPACE_ID::Any* other_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.other_data_);
  }
  if (other_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(other_data));
    if (message_arena != submessage_arena) {
      other_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, other_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.other_data_ = other_data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.NetworkComputeInputData.other_data)
}

// string model_name = 4;
inline void NetworkComputeInputData::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& NetworkComputeInputData::model_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeInputData.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkComputeInputData::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.NetworkComputeInputData.model_name)
}
inline std::string* NetworkComputeInputData::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeInputData.model_name)
  return _s;
}
inline const std::string& NetworkComputeInputData::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void NetworkComputeInputData::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkComputeInputData::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkComputeInputData::release_model_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeInputData.model_name)
  return _impl_.model_name_.Release();
}
inline void NetworkComputeInputData::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.NetworkComputeInputData.model_name)
}

// float min_confidence = 5;
inline void NetworkComputeInputData::clear_min_confidence() {
  _impl_.min_confidence_ = 0;
}
inline float NetworkComputeInputData::_internal_min_confidence() const {
  return _impl_.min_confidence_;
}
inline float NetworkComputeInputData::min_confidence() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeInputData.min_confidence)
  return _internal_min_confidence();
}
inline void NetworkComputeInputData::_internal_set_min_confidence(float value) {
  
  _impl_.min_confidence_ = value;
}
inline void NetworkComputeInputData::set_min_confidence(float value) {
  _internal_set_min_confidence(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.NetworkComputeInputData.min_confidence)
}

// .bosdyn.api.NetworkComputeInputData.RotateImage rotate_image = 6;
inline void NetworkComputeInputData::clear_rotate_image() {
  _impl_.rotate_image_ = 0;
}
inline ::bosdyn::api::NetworkComputeInputData_RotateImage NetworkComputeInputData::_internal_rotate_image() const {
  return static_cast< ::bosdyn::api::NetworkComputeInputData_RotateImage >(_impl_.rotate_image_);
}
inline ::bosdyn::api::NetworkComputeInputData_RotateImage NetworkComputeInputData::rotate_image() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeInputData.rotate_image)
  return _internal_rotate_image();
}
inline void NetworkComputeInputData::_internal_set_rotate_image(::bosdyn::api::NetworkComputeInputData_RotateImage value) {
  
  _impl_.rotate_image_ = value;
}
inline void NetworkComputeInputData::set_rotate_image(::bosdyn::api::NetworkComputeInputData_RotateImage value) {
  _internal_set_rotate_image(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.NetworkComputeInputData.rotate_image)
}

inline bool NetworkComputeInputData::has_input() const {
  return input_case() != INPUT_NOT_SET;
}
inline void NetworkComputeInputData::clear_has_input() {
  _impl_._oneof_case_[0] = INPUT_NOT_SET;
}
inline NetworkComputeInputData::InputCase NetworkComputeInputData::input_case() const {
  return NetworkComputeInputData::InputCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NetworkComputeServerConfiguration

// string service_name = 3;
inline void NetworkComputeServerConfiguration::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& NetworkComputeServerConfiguration::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeServerConfiguration.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkComputeServerConfiguration::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.NetworkComputeServerConfiguration.service_name)
}
inline std::string* NetworkComputeServerConfiguration::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeServerConfiguration.service_name)
  return _s;
}
inline const std::string& NetworkComputeServerConfiguration::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void NetworkComputeServerConfiguration::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkComputeServerConfiguration::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkComputeServerConfiguration::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeServerConfiguration.service_name)
  return _impl_.service_name_.Release();
}
inline void NetworkComputeServerConfiguration::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.NetworkComputeServerConfiguration.service_name)
}

// -------------------------------------------------------------------

// OutputImage

// .bosdyn.api.ImageResponse image_response = 1;
inline bool OutputImage::_internal_has_image_response() const {
  return this != internal_default_instance() && _impl_.image_response_ != nullptr;
}
inline bool OutputImage::has_image_response() const {
  return _internal_has_image_response();
}
inline const ::bosdyn::api::ImageResponse& OutputImage::_internal_image_response() const {
  const ::bosdyn::api::ImageResponse* p = _impl_.image_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ImageResponse&>(
      ::bosdyn::api::_ImageResponse_default_instance_);
}
inline const ::bosdyn::api::ImageResponse& OutputImage::image_response() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.OutputImage.image_response)
  return _internal_image_response();
}
inline void OutputImage::unsafe_arena_set_allocated_image_response(
    ::bosdyn::api::ImageResponse* image_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_response_);
  }
  _impl_.image_response_ = image_response;
  if (image_response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.OutputImage.image_response)
}
inline ::bosdyn::api::ImageResponse* OutputImage::release_image_response() {
  
  ::bosdyn::api::ImageResponse* temp = _impl_.image_response_;
  _impl_.image_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ImageResponse* OutputImage::unsafe_arena_release_image_response() {
  // @@protoc_insertion_point(field_release:bosdyn.api.OutputImage.image_response)
  
  ::bosdyn::api::ImageResponse* temp = _impl_.image_response_;
  _impl_.image_response_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ImageResponse* OutputImage::_internal_mutable_image_response() {
  
  if (_impl_.image_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ImageResponse>(GetArenaForAllocation());
    _impl_.image_response_ = p;
  }
  return _impl_.image_response_;
}
inline ::bosdyn::api::ImageResponse* OutputImage::mutable_image_response() {
  ::bosdyn::api::ImageResponse* _msg = _internal_mutable_image_response();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.OutputImage.image_response)
  return _msg;
}
inline void OutputImage::set_allocated_image_response(::bosdyn::api::ImageResponse* image_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_response_);
  }
  if (image_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_response));
    if (message_arena != submessage_arena) {
      image_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_response_ = image_response;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.OutputImage.image_response)
}

// .google.protobuf.Struct metadata = 2;
inline bool OutputImage::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool OutputImage::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& OutputImage::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& OutputImage::metadata() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.OutputImage.metadata)
  return _internal_metadata();
}
inline void OutputImage::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.OutputImage.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputImage::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputImage::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:bosdyn.api.OutputImage.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputImage::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputImage::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.OutputImage.metadata)
  return _msg;
}
inline void OutputImage::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.OutputImage.metadata)
}

// repeated .bosdyn.api.WorldObject object_in_image = 3;
inline int OutputImage::_internal_object_in_image_size() const {
  return _impl_.object_in_image_.size();
}
inline int OutputImage::object_in_image_size() const {
  return _internal_object_in_image_size();
}
inline ::bosdyn::api::WorldObject* OutputImage::mutable_object_in_image(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.OutputImage.object_in_image)
  return _impl_.object_in_image_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::WorldObject >*
OutputImage::mutable_object_in_image() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.OutputImage.object_in_image)
  return &_impl_.object_in_image_;
}
inline const ::bosdyn::api::WorldObject& OutputImage::_internal_object_in_image(int index) const {
  return _impl_.object_in_image_.Get(index);
}
inline const ::bosdyn::api::WorldObject& OutputImage::object_in_image(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.OutputImage.object_in_image)
  return _internal_object_in_image(index);
}
inline ::bosdyn::api::WorldObject* OutputImage::_internal_add_object_in_image() {
  return _impl_.object_in_image_.Add();
}
inline ::bosdyn::api::WorldObject* OutputImage::add_object_in_image() {
  ::bosdyn::api::WorldObject* _add = _internal_add_object_in_image();
  // @@protoc_insertion_point(field_add:bosdyn.api.OutputImage.object_in_image)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::WorldObject >&
OutputImage::object_in_image() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.OutputImage.object_in_image)
  return _impl_.object_in_image_;
}

// .bosdyn.api.AlertData alert_data = 4;
inline bool OutputImage::_internal_has_alert_data() const {
  return this != internal_default_instance() && _impl_.alert_data_ != nullptr;
}
inline bool OutputImage::has_alert_data() const {
  return _internal_has_alert_data();
}
inline const ::bosdyn::api::AlertData& OutputImage::_internal_alert_data() const {
  const ::bosdyn::api::AlertData* p = _impl_.alert_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::AlertData&>(
      ::bosdyn::api::_AlertData_default_instance_);
}
inline const ::bosdyn::api::AlertData& OutputImage::alert_data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.OutputImage.alert_data)
  return _internal_alert_data();
}
inline void OutputImage::unsafe_arena_set_allocated_alert_data(
    ::bosdyn::api::AlertData* alert_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alert_data_);
  }
  _impl_.alert_data_ = alert_data;
  if (alert_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.OutputImage.alert_data)
}
inline ::bosdyn::api::AlertData* OutputImage::release_alert_data() {
  
  ::bosdyn::api::AlertData* temp = _impl_.alert_data_;
  _impl_.alert_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::AlertData* OutputImage::unsafe_arena_release_alert_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.OutputImage.alert_data)
  
  ::bosdyn::api::AlertData* temp = _impl_.alert_data_;
  _impl_.alert_data_ = nullptr;
  return temp;
}
inline ::bosdyn::api::AlertData* OutputImage::_internal_mutable_alert_data() {
  
  if (_impl_.alert_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::AlertData>(GetArenaForAllocation());
    _impl_.alert_data_ = p;
  }
  return _impl_.alert_data_;
}
inline ::bosdyn::api::AlertData* OutputImage::mutable_alert_data() {
  ::bosdyn::api::AlertData* _msg = _internal_mutable_alert_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.OutputImage.alert_data)
  return _msg;
}
inline void OutputImage::set_allocated_alert_data(::bosdyn::api::AlertData* alert_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alert_data_);
  }
  if (alert_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alert_data));
    if (message_arena != submessage_arena) {
      alert_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alert_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.alert_data_ = alert_data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.OutputImage.alert_data)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NetworkComputeResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool NetworkComputeResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool NetworkComputeResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& NetworkComputeResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& NetworkComputeResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeResponse.header)
  return _internal_header();
}
inline void NetworkComputeResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.NetworkComputeResponse.header)
}
inline ::bosdyn::api::ResponseHeader* NetworkComputeResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* NetworkComputeResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* NetworkComputeResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* NetworkComputeResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeResponse.header)
  return _msg;
}
inline void NetworkComputeResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.NetworkComputeResponse.header)
}

// repeated .bosdyn.api.WorldObject object_in_image = 2;
inline int NetworkComputeResponse::_internal_object_in_image_size() const {
  return _impl_.object_in_image_.size();
}
inline int NetworkComputeResponse::object_in_image_size() const {
  return _internal_object_in_image_size();
}
inline ::bosdyn::api::WorldObject* NetworkComputeResponse::mutable_object_in_image(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeResponse.object_in_image)
  return _impl_.object_in_image_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::WorldObject >*
NetworkComputeResponse::mutable_object_in_image() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.NetworkComputeResponse.object_in_image)
  return &_impl_.object_in_image_;
}
inline const ::bosdyn::api::WorldObject& NetworkComputeResponse::_internal_object_in_image(int index) const {
  return _impl_.object_in_image_.Get(index);
}
inline const ::bosdyn::api::WorldObject& NetworkComputeResponse::object_in_image(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeResponse.object_in_image)
  return _internal_object_in_image(index);
}
inline ::bosdyn::api::WorldObject* NetworkComputeResponse::_internal_add_object_in_image() {
  return _impl_.object_in_image_.Add();
}
inline ::bosdyn::api::WorldObject* NetworkComputeResponse::add_object_in_image() {
  ::bosdyn::api::WorldObject* _add = _internal_add_object_in_image();
  // @@protoc_insertion_point(field_add:bosdyn.api.NetworkComputeResponse.object_in_image)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::WorldObject >&
NetworkComputeResponse::object_in_image() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.NetworkComputeResponse.object_in_image)
  return _impl_.object_in_image_;
}

// .bosdyn.api.ImageResponse image_response = 3;
inline bool NetworkComputeResponse::_internal_has_image_response() const {
  return this != internal_default_instance() && _impl_.image_response_ != nullptr;
}
inline bool NetworkComputeResponse::has_image_response() const {
  return _internal_has_image_response();
}
inline const ::bosdyn::api::ImageResponse& NetworkComputeResponse::_internal_image_response() const {
  const ::bosdyn::api::ImageResponse* p = _impl_.image_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ImageResponse&>(
      ::bosdyn::api::_ImageResponse_default_instance_);
}
inline const ::bosdyn::api::ImageResponse& NetworkComputeResponse::image_response() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeResponse.image_response)
  return _internal_image_response();
}
inline void NetworkComputeResponse::unsafe_arena_set_allocated_image_response(
    ::bosdyn::api::ImageResponse* image_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_response_);
  }
  _impl_.image_response_ = image_response;
  if (image_response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.NetworkComputeResponse.image_response)
}
inline ::bosdyn::api::ImageResponse* NetworkComputeResponse::release_image_response() {
  
  ::bosdyn::api::ImageResponse* temp = _impl_.image_response_;
  _impl_.image_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ImageResponse* NetworkComputeResponse::unsafe_arena_release_image_response() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeResponse.image_response)
  
  ::bosdyn::api::ImageResponse* temp = _impl_.image_response_;
  _impl_.image_response_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ImageResponse* NetworkComputeResponse::_internal_mutable_image_response() {
  
  if (_impl_.image_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ImageResponse>(GetArenaForAllocation());
    _impl_.image_response_ = p;
  }
  return _impl_.image_response_;
}
inline ::bosdyn::api::ImageResponse* NetworkComputeResponse::mutable_image_response() {
  ::bosdyn::api::ImageResponse* _msg = _internal_mutable_image_response();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeResponse.image_response)
  return _msg;
}
inline void NetworkComputeResponse::set_allocated_image_response(::bosdyn::api::ImageResponse* image_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_response_);
  }
  if (image_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_response));
    if (message_arena != submessage_arena) {
      image_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_response_ = image_response;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.NetworkComputeResponse.image_response)
}

// double image_rotation_angle = 6;
inline void NetworkComputeResponse::clear_image_rotation_angle() {
  _impl_.image_rotation_angle_ = 0;
}
inline double NetworkComputeResponse::_internal_image_rotation_angle() const {
  return _impl_.image_rotation_angle_;
}
inline double NetworkComputeResponse::image_rotation_angle() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeResponse.image_rotation_angle)
  return _internal_image_rotation_angle();
}
inline void NetworkComputeResponse::_internal_set_image_rotation_angle(double value) {
  
  _impl_.image_rotation_angle_ = value;
}
inline void NetworkComputeResponse::set_image_rotation_angle(double value) {
  _internal_set_image_rotation_angle(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.NetworkComputeResponse.image_rotation_angle)
}

// .google.protobuf.Any other_data = 4;
inline bool NetworkComputeResponse::_internal_has_other_data() const {
  return this != internal_default_instance() && _impl_.other_data_ != nullptr;
}
inline bool NetworkComputeResponse::has_other_data() const {
  return _internal_has_other_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& NetworkComputeResponse::_internal_other_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.other_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& NetworkComputeResponse::other_data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeResponse.other_data)
  return _internal_other_data();
}
inline void NetworkComputeResponse::unsafe_arena_set_allocated_other_data(
    ::PROTOBUF_NAMESPACE_ID::Any* other_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.other_data_);
  }
  _impl_.other_data_ = other_data;
  if (other_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.NetworkComputeResponse.other_data)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* NetworkComputeResponse::release_other_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.other_data_;
  _impl_.other_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* NetworkComputeResponse::unsafe_arena_release_other_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeResponse.other_data)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.other_data_;
  _impl_.other_data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* NetworkComputeResponse::_internal_mutable_other_data() {
  
  if (_impl_.other_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.other_data_ = p;
  }
  return _impl_.other_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* NetworkComputeResponse::mutable_other_data() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_other_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeResponse.other_data)
  return _msg;
}
inline void NetworkComputeResponse::set_allocated_other_data(::PROTOBUF_NAMESPACE_ID::Any* other_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.other_data_);
  }
  if (other_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(other_data));
    if (message_arena != submessage_arena) {
      other_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, other_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.other_data_ = other_data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.NetworkComputeResponse.other_data)
}

// .bosdyn.api.NetworkComputeStatus status = 5;
inline void NetworkComputeResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::NetworkComputeStatus NetworkComputeResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::NetworkComputeStatus >(_impl_.status_);
}
inline ::bosdyn::api::NetworkComputeStatus NetworkComputeResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeResponse.status)
  return _internal_status();
}
inline void NetworkComputeResponse::_internal_set_status(::bosdyn::api::NetworkComputeStatus value) {
  
  _impl_.status_ = value;
}
inline void NetworkComputeResponse::set_status(::bosdyn::api::NetworkComputeStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.NetworkComputeResponse.status)
}

// .bosdyn.api.AlertData alert_data = 7;
inline bool NetworkComputeResponse::_internal_has_alert_data() const {
  return this != internal_default_instance() && _impl_.alert_data_ != nullptr;
}
inline bool NetworkComputeResponse::has_alert_data() const {
  return _internal_has_alert_data();
}
inline const ::bosdyn::api::AlertData& NetworkComputeResponse::_internal_alert_data() const {
  const ::bosdyn::api::AlertData* p = _impl_.alert_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::AlertData&>(
      ::bosdyn::api::_AlertData_default_instance_);
}
inline const ::bosdyn::api::AlertData& NetworkComputeResponse::alert_data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.NetworkComputeResponse.alert_data)
  return _internal_alert_data();
}
inline void NetworkComputeResponse::unsafe_arena_set_allocated_alert_data(
    ::bosdyn::api::AlertData* alert_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alert_data_);
  }
  _impl_.alert_data_ = alert_data;
  if (alert_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.NetworkComputeResponse.alert_data)
}
inline ::bosdyn::api::AlertData* NetworkComputeResponse::release_alert_data() {
  
  ::bosdyn::api::AlertData* temp = _impl_.alert_data_;
  _impl_.alert_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::AlertData* NetworkComputeResponse::unsafe_arena_release_alert_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.NetworkComputeResponse.alert_data)
  
  ::bosdyn::api::AlertData* temp = _impl_.alert_data_;
  _impl_.alert_data_ = nullptr;
  return temp;
}
inline ::bosdyn::api::AlertData* NetworkComputeResponse::_internal_mutable_alert_data() {
  
  if (_impl_.alert_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::AlertData>(GetArenaForAllocation());
    _impl_.alert_data_ = p;
  }
  return _impl_.alert_data_;
}
inline ::bosdyn::api::AlertData* NetworkComputeResponse::mutable_alert_data() {
  ::bosdyn::api::AlertData* _msg = _internal_mutable_alert_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.NetworkComputeResponse.alert_data)
  return _msg;
}
inline void NetworkComputeResponse::set_allocated_alert_data(::bosdyn::api::AlertData* alert_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alert_data_);
  }
  if (alert_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alert_data));
    if (message_arena != submessage_arena) {
      alert_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alert_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.alert_data_ = alert_data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.NetworkComputeResponse.alert_data)
}

// map<string, .bosdyn.api.OutputImage> output_images = 8;
inline int NetworkComputeResponse::_internal_output_images_size() const {
  return _impl_.output_images_.size();
}
inline int NetworkComputeResponse::output_images_size() const {
  return _internal_output_images_size();
}
inline void NetworkComputeResponse::clear_output_images() {
  _impl_.output_images_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::OutputImage >&
NetworkComputeResponse::_internal_output_images() const {
  return _impl_.output_images_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::OutputImage >&
NetworkComputeResponse::output_images() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.NetworkComputeResponse.output_images)
  return _internal_output_images();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::OutputImage >*
NetworkComputeResponse::_internal_mutable_output_images() {
  return _impl_.output_images_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::OutputImage >*
NetworkComputeResponse::mutable_output_images() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.NetworkComputeResponse.output_images)
  return _internal_mutable_output_images();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::NetworkComputeInputData_RotateImage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::NetworkComputeInputData_RotateImage>() {
  return ::bosdyn::api::NetworkComputeInputData_RotateImage_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::NetworkComputeStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::NetworkComputeStatus>() {
  return ::bosdyn::api::NetworkComputeStatus_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::ListAvailableModelsStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ListAvailableModelsStatus>() {
  return ::bosdyn::api::ListAvailableModelsStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fnetwork_5fcompute_5fbridge_2eproto
