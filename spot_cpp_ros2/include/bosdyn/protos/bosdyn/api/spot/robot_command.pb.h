// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/spot/robot_command.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_2frobot_5fcommand_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_2frobot_5fcommand_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/geometry.pb.h"
#include "bosdyn/api/trajectory.pb.h"
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fspot_2frobot_5fcommand_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fspot_2frobot_5fcommand_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fspot_2frobot_5fcommand_2eproto;
namespace bosdyn {
namespace api {
namespace spot {
class BodyControlParams;
struct BodyControlParamsDefaultTypeInternal;
extern BodyControlParamsDefaultTypeInternal _BodyControlParams_default_instance_;
class BodyControlParams_BodyAssistForManipulation;
struct BodyControlParams_BodyAssistForManipulationDefaultTypeInternal;
extern BodyControlParams_BodyAssistForManipulationDefaultTypeInternal _BodyControlParams_BodyAssistForManipulation_default_instance_;
class BodyExternalForceParams;
struct BodyExternalForceParamsDefaultTypeInternal;
extern BodyExternalForceParamsDefaultTypeInternal _BodyExternalForceParams_default_instance_;
class MobilityParams;
struct MobilityParamsDefaultTypeInternal;
extern MobilityParamsDefaultTypeInternal _MobilityParams_default_instance_;
class ObstacleParams;
struct ObstacleParamsDefaultTypeInternal;
extern ObstacleParamsDefaultTypeInternal _ObstacleParams_default_instance_;
class TerrainParams;
struct TerrainParamsDefaultTypeInternal;
extern TerrainParamsDefaultTypeInternal _TerrainParams_default_instance_;
}  // namespace spot
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::spot::BodyControlParams* Arena::CreateMaybeMessage<::bosdyn::api::spot::BodyControlParams>(Arena*);
template<> ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* Arena::CreateMaybeMessage<::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation>(Arena*);
template<> ::bosdyn::api::spot::BodyExternalForceParams* Arena::CreateMaybeMessage<::bosdyn::api::spot::BodyExternalForceParams>(Arena*);
template<> ::bosdyn::api::spot::MobilityParams* Arena::CreateMaybeMessage<::bosdyn::api::spot::MobilityParams>(Arena*);
template<> ::bosdyn::api::spot::ObstacleParams* Arena::CreateMaybeMessage<::bosdyn::api::spot::ObstacleParams>(Arena*);
template<> ::bosdyn::api::spot::TerrainParams* Arena::CreateMaybeMessage<::bosdyn::api::spot::TerrainParams>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {
namespace spot {

enum MobilityParams_StairsMode : int {
  MobilityParams_StairsMode_STAIRS_MODE_UNKNOWN = 0,
  MobilityParams_StairsMode_STAIRS_MODE_OFF = 1,
  MobilityParams_StairsMode_STAIRS_MODE_ON = 2,
  MobilityParams_StairsMode_STAIRS_MODE_AUTO = 3,
  MobilityParams_StairsMode_MobilityParams_StairsMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MobilityParams_StairsMode_MobilityParams_StairsMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MobilityParams_StairsMode_IsValid(int value);
constexpr MobilityParams_StairsMode MobilityParams_StairsMode_StairsMode_MIN = MobilityParams_StairsMode_STAIRS_MODE_UNKNOWN;
constexpr MobilityParams_StairsMode MobilityParams_StairsMode_StairsMode_MAX = MobilityParams_StairsMode_STAIRS_MODE_AUTO;
constexpr int MobilityParams_StairsMode_StairsMode_ARRAYSIZE = MobilityParams_StairsMode_StairsMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MobilityParams_StairsMode_descriptor();
template<typename T>
inline const std::string& MobilityParams_StairsMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MobilityParams_StairsMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MobilityParams_StairsMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MobilityParams_StairsMode_descriptor(), enum_t_value);
}
inline bool MobilityParams_StairsMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MobilityParams_StairsMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MobilityParams_StairsMode>(
    MobilityParams_StairsMode_descriptor(), name, value);
}
enum BodyControlParams_RotationSetting : int {
  BodyControlParams_RotationSetting_ROTATION_SETTING_UNKNOWN = 0,
  BodyControlParams_RotationSetting_ROTATION_SETTING_OFFSET = 1,
  BodyControlParams_RotationSetting_ROTATION_SETTING_ABSOLUTE = 2,
  BodyControlParams_RotationSetting_BodyControlParams_RotationSetting_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BodyControlParams_RotationSetting_BodyControlParams_RotationSetting_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BodyControlParams_RotationSetting_IsValid(int value);
constexpr BodyControlParams_RotationSetting BodyControlParams_RotationSetting_RotationSetting_MIN = BodyControlParams_RotationSetting_ROTATION_SETTING_UNKNOWN;
constexpr BodyControlParams_RotationSetting BodyControlParams_RotationSetting_RotationSetting_MAX = BodyControlParams_RotationSetting_ROTATION_SETTING_ABSOLUTE;
constexpr int BodyControlParams_RotationSetting_RotationSetting_ARRAYSIZE = BodyControlParams_RotationSetting_RotationSetting_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BodyControlParams_RotationSetting_descriptor();
template<typename T>
inline const std::string& BodyControlParams_RotationSetting_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BodyControlParams_RotationSetting>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BodyControlParams_RotationSetting_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BodyControlParams_RotationSetting_descriptor(), enum_t_value);
}
inline bool BodyControlParams_RotationSetting_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BodyControlParams_RotationSetting* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BodyControlParams_RotationSetting>(
    BodyControlParams_RotationSetting_descriptor(), name, value);
}
enum TerrainParams_GratedSurfacesMode : int {
  TerrainParams_GratedSurfacesMode_GRATED_SURFACES_MODE_UNKNOWN = 0,
  TerrainParams_GratedSurfacesMode_GRATED_SURFACES_MODE_OFF = 1,
  TerrainParams_GratedSurfacesMode_GRATED_SURFACES_MODE_ON = 2,
  TerrainParams_GratedSurfacesMode_GRATED_SURFACES_MODE_AUTO = 3,
  TerrainParams_GratedSurfacesMode_TerrainParams_GratedSurfacesMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TerrainParams_GratedSurfacesMode_TerrainParams_GratedSurfacesMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TerrainParams_GratedSurfacesMode_IsValid(int value);
constexpr TerrainParams_GratedSurfacesMode TerrainParams_GratedSurfacesMode_GratedSurfacesMode_MIN = TerrainParams_GratedSurfacesMode_GRATED_SURFACES_MODE_UNKNOWN;
constexpr TerrainParams_GratedSurfacesMode TerrainParams_GratedSurfacesMode_GratedSurfacesMode_MAX = TerrainParams_GratedSurfacesMode_GRATED_SURFACES_MODE_AUTO;
constexpr int TerrainParams_GratedSurfacesMode_GratedSurfacesMode_ARRAYSIZE = TerrainParams_GratedSurfacesMode_GratedSurfacesMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TerrainParams_GratedSurfacesMode_descriptor();
template<typename T>
inline const std::string& TerrainParams_GratedSurfacesMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TerrainParams_GratedSurfacesMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TerrainParams_GratedSurfacesMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TerrainParams_GratedSurfacesMode_descriptor(), enum_t_value);
}
inline bool TerrainParams_GratedSurfacesMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TerrainParams_GratedSurfacesMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TerrainParams_GratedSurfacesMode>(
    TerrainParams_GratedSurfacesMode_descriptor(), name, value);
}
enum BodyExternalForceParams_ExternalForceIndicator : int {
  BodyExternalForceParams_ExternalForceIndicator_EXTERNAL_FORCE_NONE = 0,
  BodyExternalForceParams_ExternalForceIndicator_EXTERNAL_FORCE_USE_ESTIMATE = 1,
  BodyExternalForceParams_ExternalForceIndicator_EXTERNAL_FORCE_USE_OVERRIDE = 2,
  BodyExternalForceParams_ExternalForceIndicator_BodyExternalForceParams_ExternalForceIndicator_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BodyExternalForceParams_ExternalForceIndicator_BodyExternalForceParams_ExternalForceIndicator_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BodyExternalForceParams_ExternalForceIndicator_IsValid(int value);
constexpr BodyExternalForceParams_ExternalForceIndicator BodyExternalForceParams_ExternalForceIndicator_ExternalForceIndicator_MIN = BodyExternalForceParams_ExternalForceIndicator_EXTERNAL_FORCE_NONE;
constexpr BodyExternalForceParams_ExternalForceIndicator BodyExternalForceParams_ExternalForceIndicator_ExternalForceIndicator_MAX = BodyExternalForceParams_ExternalForceIndicator_EXTERNAL_FORCE_USE_OVERRIDE;
constexpr int BodyExternalForceParams_ExternalForceIndicator_ExternalForceIndicator_ARRAYSIZE = BodyExternalForceParams_ExternalForceIndicator_ExternalForceIndicator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BodyExternalForceParams_ExternalForceIndicator_descriptor();
template<typename T>
inline const std::string& BodyExternalForceParams_ExternalForceIndicator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BodyExternalForceParams_ExternalForceIndicator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BodyExternalForceParams_ExternalForceIndicator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BodyExternalForceParams_ExternalForceIndicator_descriptor(), enum_t_value);
}
inline bool BodyExternalForceParams_ExternalForceIndicator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BodyExternalForceParams_ExternalForceIndicator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BodyExternalForceParams_ExternalForceIndicator>(
    BodyExternalForceParams_ExternalForceIndicator_descriptor(), name, value);
}
enum LocomotionHint : int {
  HINT_UNKNOWN = 0,
  HINT_AUTO = 1,
  HINT_TROT = 2,
  HINT_SPEED_SELECT_TROT = 3,
  HINT_CRAWL = 4,
  HINT_SPEED_SELECT_CRAWL = 10,
  HINT_AMBLE = 5,
  HINT_SPEED_SELECT_AMBLE = 6,
  HINT_JOG = 7,
  HINT_HOP = 8,
  HINT_AUTO_TROT = 3,
  HINT_AUTO_AMBLE = 6,
  LocomotionHint_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LocomotionHint_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LocomotionHint_IsValid(int value);
constexpr LocomotionHint LocomotionHint_MIN = HINT_UNKNOWN;
constexpr LocomotionHint LocomotionHint_MAX = HINT_SPEED_SELECT_CRAWL;
constexpr int LocomotionHint_ARRAYSIZE = LocomotionHint_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LocomotionHint_descriptor();
template<typename T>
inline const std::string& LocomotionHint_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LocomotionHint>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LocomotionHint_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LocomotionHint_descriptor(), enum_t_value);
}
inline bool LocomotionHint_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LocomotionHint* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LocomotionHint>(
    LocomotionHint_descriptor(), name, value);
}
enum SwingHeight : int {
  SWING_HEIGHT_UNKNOWN = 0,
  SWING_HEIGHT_LOW = 1,
  SWING_HEIGHT_MEDIUM = 2,
  SWING_HEIGHT_HIGH = 3,
  SwingHeight_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SwingHeight_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SwingHeight_IsValid(int value);
constexpr SwingHeight SwingHeight_MIN = SWING_HEIGHT_UNKNOWN;
constexpr SwingHeight SwingHeight_MAX = SWING_HEIGHT_HIGH;
constexpr int SwingHeight_ARRAYSIZE = SwingHeight_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SwingHeight_descriptor();
template<typename T>
inline const std::string& SwingHeight_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SwingHeight>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SwingHeight_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SwingHeight_descriptor(), enum_t_value);
}
inline bool SwingHeight_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SwingHeight* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SwingHeight>(
    SwingHeight_descriptor(), name, value);
}
// ===================================================================

class MobilityParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.MobilityParams) */ {
 public:
  inline MobilityParams() : MobilityParams(nullptr) {}
  ~MobilityParams() override;
  explicit PROTOBUF_CONSTEXPR MobilityParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MobilityParams(const MobilityParams& from);
  MobilityParams(MobilityParams&& from) noexcept
    : MobilityParams() {
    *this = ::std::move(from);
  }

  inline MobilityParams& operator=(const MobilityParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline MobilityParams& operator=(MobilityParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MobilityParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const MobilityParams* internal_default_instance() {
    return reinterpret_cast<const MobilityParams*>(
               &_MobilityParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MobilityParams& a, MobilityParams& b) {
    a.Swap(&b);
  }
  inline void Swap(MobilityParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MobilityParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MobilityParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MobilityParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MobilityParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MobilityParams& from) {
    MobilityParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MobilityParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.MobilityParams";
  }
  protected:
  explicit MobilityParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MobilityParams_StairsMode StairsMode;
  static constexpr StairsMode STAIRS_MODE_UNKNOWN =
    MobilityParams_StairsMode_STAIRS_MODE_UNKNOWN;
  static constexpr StairsMode STAIRS_MODE_OFF =
    MobilityParams_StairsMode_STAIRS_MODE_OFF;
  static constexpr StairsMode STAIRS_MODE_ON =
    MobilityParams_StairsMode_STAIRS_MODE_ON;
  static constexpr StairsMode STAIRS_MODE_AUTO =
    MobilityParams_StairsMode_STAIRS_MODE_AUTO;
  static inline bool StairsMode_IsValid(int value) {
    return MobilityParams_StairsMode_IsValid(value);
  }
  static constexpr StairsMode StairsMode_MIN =
    MobilityParams_StairsMode_StairsMode_MIN;
  static constexpr StairsMode StairsMode_MAX =
    MobilityParams_StairsMode_StairsMode_MAX;
  static constexpr int StairsMode_ARRAYSIZE =
    MobilityParams_StairsMode_StairsMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StairsMode_descriptor() {
    return MobilityParams_StairsMode_descriptor();
  }
  template<typename T>
  static inline const std::string& StairsMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StairsMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StairsMode_Name.");
    return MobilityParams_StairsMode_Name(enum_t_value);
  }
  static inline bool StairsMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StairsMode* value) {
    return MobilityParams_StairsMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVelLimitFieldNumber = 1,
    kBodyControlFieldNumber = 2,
    kObstacleParamsFieldNumber = 6,
    kTerrainParamsFieldNumber = 8,
    kExternalForceParamsFieldNumber = 10,
    kLocomotionHintFieldNumber = 3,
    kSwingHeightFieldNumber = 7,
    kStairHintFieldNumber = 4,
    kAllowDegradedPerceptionFieldNumber = 5,
    kDisallowStairTrackerFieldNumber = 9,
    kDisableStairErrorAutoDescentFieldNumber = 16,
    kDisallowNonStairsPitchLimitingFieldNumber = 11,
    kDisableNearmapCliffAvoidanceFieldNumber = 12,
    kStairsModeFieldNumber = 17,
  };
  // .bosdyn.api.SE2VelocityLimit vel_limit = 1;
  bool has_vel_limit() const;
  private:
  bool _internal_has_vel_limit() const;
  public:
  void clear_vel_limit();
  const ::bosdyn::api::SE2VelocityLimit& vel_limit() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE2VelocityLimit* release_vel_limit();
  ::bosdyn::api::SE2VelocityLimit* mutable_vel_limit();
  void set_allocated_vel_limit(::bosdyn::api::SE2VelocityLimit* vel_limit);
  private:
  const ::bosdyn::api::SE2VelocityLimit& _internal_vel_limit() const;
  ::bosdyn::api::SE2VelocityLimit* _internal_mutable_vel_limit();
  public:
  void unsafe_arena_set_allocated_vel_limit(
      ::bosdyn::api::SE2VelocityLimit* vel_limit);
  ::bosdyn::api::SE2VelocityLimit* unsafe_arena_release_vel_limit();

  // .bosdyn.api.spot.BodyControlParams body_control = 2;
  bool has_body_control() const;
  private:
  bool _internal_has_body_control() const;
  public:
  void clear_body_control();
  const ::bosdyn::api::spot::BodyControlParams& body_control() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::BodyControlParams* release_body_control();
  ::bosdyn::api::spot::BodyControlParams* mutable_body_control();
  void set_allocated_body_control(::bosdyn::api::spot::BodyControlParams* body_control);
  private:
  const ::bosdyn::api::spot::BodyControlParams& _internal_body_control() const;
  ::bosdyn::api::spot::BodyControlParams* _internal_mutable_body_control();
  public:
  void unsafe_arena_set_allocated_body_control(
      ::bosdyn::api::spot::BodyControlParams* body_control);
  ::bosdyn::api::spot::BodyControlParams* unsafe_arena_release_body_control();

  // .bosdyn.api.spot.ObstacleParams obstacle_params = 6;
  bool has_obstacle_params() const;
  private:
  bool _internal_has_obstacle_params() const;
  public:
  void clear_obstacle_params();
  const ::bosdyn::api::spot::ObstacleParams& obstacle_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::ObstacleParams* release_obstacle_params();
  ::bosdyn::api::spot::ObstacleParams* mutable_obstacle_params();
  void set_allocated_obstacle_params(::bosdyn::api::spot::ObstacleParams* obstacle_params);
  private:
  const ::bosdyn::api::spot::ObstacleParams& _internal_obstacle_params() const;
  ::bosdyn::api::spot::ObstacleParams* _internal_mutable_obstacle_params();
  public:
  void unsafe_arena_set_allocated_obstacle_params(
      ::bosdyn::api::spot::ObstacleParams* obstacle_params);
  ::bosdyn::api::spot::ObstacleParams* unsafe_arena_release_obstacle_params();

  // .bosdyn.api.spot.TerrainParams terrain_params = 8;
  bool has_terrain_params() const;
  private:
  bool _internal_has_terrain_params() const;
  public:
  void clear_terrain_params();
  const ::bosdyn::api::spot::TerrainParams& terrain_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::TerrainParams* release_terrain_params();
  ::bosdyn::api::spot::TerrainParams* mutable_terrain_params();
  void set_allocated_terrain_params(::bosdyn::api::spot::TerrainParams* terrain_params);
  private:
  const ::bosdyn::api::spot::TerrainParams& _internal_terrain_params() const;
  ::bosdyn::api::spot::TerrainParams* _internal_mutable_terrain_params();
  public:
  void unsafe_arena_set_allocated_terrain_params(
      ::bosdyn::api::spot::TerrainParams* terrain_params);
  ::bosdyn::api::spot::TerrainParams* unsafe_arena_release_terrain_params();

  // .bosdyn.api.spot.BodyExternalForceParams external_force_params = 10;
  bool has_external_force_params() const;
  private:
  bool _internal_has_external_force_params() const;
  public:
  void clear_external_force_params();
  const ::bosdyn::api::spot::BodyExternalForceParams& external_force_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::BodyExternalForceParams* release_external_force_params();
  ::bosdyn::api::spot::BodyExternalForceParams* mutable_external_force_params();
  void set_allocated_external_force_params(::bosdyn::api::spot::BodyExternalForceParams* external_force_params);
  private:
  const ::bosdyn::api::spot::BodyExternalForceParams& _internal_external_force_params() const;
  ::bosdyn::api::spot::BodyExternalForceParams* _internal_mutable_external_force_params();
  public:
  void unsafe_arena_set_allocated_external_force_params(
      ::bosdyn::api::spot::BodyExternalForceParams* external_force_params);
  ::bosdyn::api::spot::BodyExternalForceParams* unsafe_arena_release_external_force_params();

  // .bosdyn.api.spot.LocomotionHint locomotion_hint = 3;
  void clear_locomotion_hint();
  ::bosdyn::api::spot::LocomotionHint locomotion_hint() const;
  void set_locomotion_hint(::bosdyn::api::spot::LocomotionHint value);
  private:
  ::bosdyn::api::spot::LocomotionHint _internal_locomotion_hint() const;
  void _internal_set_locomotion_hint(::bosdyn::api::spot::LocomotionHint value);
  public:

  // .bosdyn.api.spot.SwingHeight swing_height = 7;
  void clear_swing_height();
  ::bosdyn::api::spot::SwingHeight swing_height() const;
  void set_swing_height(::bosdyn::api::spot::SwingHeight value);
  private:
  ::bosdyn::api::spot::SwingHeight _internal_swing_height() const;
  void _internal_set_swing_height(::bosdyn::api::spot::SwingHeight value);
  public:

  // bool stair_hint = 4 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_stair_hint();
  PROTOBUF_DEPRECATED bool stair_hint() const;
  PROTOBUF_DEPRECATED void set_stair_hint(bool value);
  private:
  bool _internal_stair_hint() const;
  void _internal_set_stair_hint(bool value);
  public:

  // bool allow_degraded_perception = 5;
  void clear_allow_degraded_perception();
  bool allow_degraded_perception() const;
  void set_allow_degraded_perception(bool value);
  private:
  bool _internal_allow_degraded_perception() const;
  void _internal_set_allow_degraded_perception(bool value);
  public:

  // bool disallow_stair_tracker = 9;
  void clear_disallow_stair_tracker();
  bool disallow_stair_tracker() const;
  void set_disallow_stair_tracker(bool value);
  private:
  bool _internal_disallow_stair_tracker() const;
  void _internal_set_disallow_stair_tracker(bool value);
  public:

  // bool disable_stair_error_auto_descent = 16;
  void clear_disable_stair_error_auto_descent();
  bool disable_stair_error_auto_descent() const;
  void set_disable_stair_error_auto_descent(bool value);
  private:
  bool _internal_disable_stair_error_auto_descent() const;
  void _internal_set_disable_stair_error_auto_descent(bool value);
  public:

  // bool disallow_non_stairs_pitch_limiting = 11;
  void clear_disallow_non_stairs_pitch_limiting();
  bool disallow_non_stairs_pitch_limiting() const;
  void set_disallow_non_stairs_pitch_limiting(bool value);
  private:
  bool _internal_disallow_non_stairs_pitch_limiting() const;
  void _internal_set_disallow_non_stairs_pitch_limiting(bool value);
  public:

  // bool disable_nearmap_cliff_avoidance = 12;
  void clear_disable_nearmap_cliff_avoidance();
  bool disable_nearmap_cliff_avoidance() const;
  void set_disable_nearmap_cliff_avoidance(bool value);
  private:
  bool _internal_disable_nearmap_cliff_avoidance() const;
  void _internal_set_disable_nearmap_cliff_avoidance(bool value);
  public:

  // .bosdyn.api.spot.MobilityParams.StairsMode stairs_mode = 17;
  void clear_stairs_mode();
  ::bosdyn::api::spot::MobilityParams_StairsMode stairs_mode() const;
  void set_stairs_mode(::bosdyn::api::spot::MobilityParams_StairsMode value);
  private:
  ::bosdyn::api::spot::MobilityParams_StairsMode _internal_stairs_mode() const;
  void _internal_set_stairs_mode(::bosdyn::api::spot::MobilityParams_StairsMode value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.MobilityParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::SE2VelocityLimit* vel_limit_;
    ::bosdyn::api::spot::BodyControlParams* body_control_;
    ::bosdyn::api::spot::ObstacleParams* obstacle_params_;
    ::bosdyn::api::spot::TerrainParams* terrain_params_;
    ::bosdyn::api::spot::BodyExternalForceParams* external_force_params_;
    int locomotion_hint_;
    int swing_height_;
    bool stair_hint_;
    bool allow_degraded_perception_;
    bool disallow_stair_tracker_;
    bool disable_stair_error_auto_descent_;
    bool disallow_non_stairs_pitch_limiting_;
    bool disable_nearmap_cliff_avoidance_;
    int stairs_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2frobot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class BodyControlParams_BodyAssistForManipulation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.BodyControlParams.BodyAssistForManipulation) */ {
 public:
  inline BodyControlParams_BodyAssistForManipulation() : BodyControlParams_BodyAssistForManipulation(nullptr) {}
  ~BodyControlParams_BodyAssistForManipulation() override;
  explicit PROTOBUF_CONSTEXPR BodyControlParams_BodyAssistForManipulation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BodyControlParams_BodyAssistForManipulation(const BodyControlParams_BodyAssistForManipulation& from);
  BodyControlParams_BodyAssistForManipulation(BodyControlParams_BodyAssistForManipulation&& from) noexcept
    : BodyControlParams_BodyAssistForManipulation() {
    *this = ::std::move(from);
  }

  inline BodyControlParams_BodyAssistForManipulation& operator=(const BodyControlParams_BodyAssistForManipulation& from) {
    CopyFrom(from);
    return *this;
  }
  inline BodyControlParams_BodyAssistForManipulation& operator=(BodyControlParams_BodyAssistForManipulation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BodyControlParams_BodyAssistForManipulation& default_instance() {
    return *internal_default_instance();
  }
  static inline const BodyControlParams_BodyAssistForManipulation* internal_default_instance() {
    return reinterpret_cast<const BodyControlParams_BodyAssistForManipulation*>(
               &_BodyControlParams_BodyAssistForManipulation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BodyControlParams_BodyAssistForManipulation& a, BodyControlParams_BodyAssistForManipulation& b) {
    a.Swap(&b);
  }
  inline void Swap(BodyControlParams_BodyAssistForManipulation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BodyControlParams_BodyAssistForManipulation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BodyControlParams_BodyAssistForManipulation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BodyControlParams_BodyAssistForManipulation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BodyControlParams_BodyAssistForManipulation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BodyControlParams_BodyAssistForManipulation& from) {
    BodyControlParams_BodyAssistForManipulation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BodyControlParams_BodyAssistForManipulation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.BodyControlParams.BodyAssistForManipulation";
  }
  protected:
  explicit BodyControlParams_BodyAssistForManipulation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableBodyYawAssistFieldNumber = 1,
    kEnableHipHeightAssistFieldNumber = 2,
  };
  // bool enable_body_yaw_assist = 1;
  void clear_enable_body_yaw_assist();
  bool enable_body_yaw_assist() const;
  void set_enable_body_yaw_assist(bool value);
  private:
  bool _internal_enable_body_yaw_assist() const;
  void _internal_set_enable_body_yaw_assist(bool value);
  public:

  // bool enable_hip_height_assist = 2;
  void clear_enable_hip_height_assist();
  bool enable_hip_height_assist() const;
  void set_enable_hip_height_assist(bool value);
  private:
  bool _internal_enable_hip_height_assist() const;
  void _internal_set_enable_hip_height_assist(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.BodyControlParams.BodyAssistForManipulation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool enable_body_yaw_assist_;
    bool enable_hip_height_assist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2frobot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class BodyControlParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.BodyControlParams) */ {
 public:
  inline BodyControlParams() : BodyControlParams(nullptr) {}
  ~BodyControlParams() override;
  explicit PROTOBUF_CONSTEXPR BodyControlParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BodyControlParams(const BodyControlParams& from);
  BodyControlParams(BodyControlParams&& from) noexcept
    : BodyControlParams() {
    *this = ::std::move(from);
  }

  inline BodyControlParams& operator=(const BodyControlParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline BodyControlParams& operator=(BodyControlParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BodyControlParams& default_instance() {
    return *internal_default_instance();
  }
  enum ParamCase {
    kBaseOffsetRtFootprint = 1,
    kBodyAssistForManipulation = 3,
    PARAM_NOT_SET = 0,
  };

  static inline const BodyControlParams* internal_default_instance() {
    return reinterpret_cast<const BodyControlParams*>(
               &_BodyControlParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BodyControlParams& a, BodyControlParams& b) {
    a.Swap(&b);
  }
  inline void Swap(BodyControlParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BodyControlParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BodyControlParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BodyControlParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BodyControlParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BodyControlParams& from) {
    BodyControlParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BodyControlParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.BodyControlParams";
  }
  protected:
  explicit BodyControlParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BodyControlParams_BodyAssistForManipulation BodyAssistForManipulation;

  typedef BodyControlParams_RotationSetting RotationSetting;
  static constexpr RotationSetting ROTATION_SETTING_UNKNOWN =
    BodyControlParams_RotationSetting_ROTATION_SETTING_UNKNOWN;
  static constexpr RotationSetting ROTATION_SETTING_OFFSET =
    BodyControlParams_RotationSetting_ROTATION_SETTING_OFFSET;
  static constexpr RotationSetting ROTATION_SETTING_ABSOLUTE =
    BodyControlParams_RotationSetting_ROTATION_SETTING_ABSOLUTE;
  static inline bool RotationSetting_IsValid(int value) {
    return BodyControlParams_RotationSetting_IsValid(value);
  }
  static constexpr RotationSetting RotationSetting_MIN =
    BodyControlParams_RotationSetting_RotationSetting_MIN;
  static constexpr RotationSetting RotationSetting_MAX =
    BodyControlParams_RotationSetting_RotationSetting_MAX;
  static constexpr int RotationSetting_ARRAYSIZE =
    BodyControlParams_RotationSetting_RotationSetting_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RotationSetting_descriptor() {
    return BodyControlParams_RotationSetting_descriptor();
  }
  template<typename T>
  static inline const std::string& RotationSetting_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RotationSetting>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RotationSetting_Name.");
    return BodyControlParams_RotationSetting_Name(enum_t_value);
  }
  static inline bool RotationSetting_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RotationSetting* value) {
    return BodyControlParams_RotationSetting_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRotationSettingFieldNumber = 2,
    kBaseOffsetRtFootprintFieldNumber = 1,
    kBodyAssistForManipulationFieldNumber = 3,
  };
  // .bosdyn.api.spot.BodyControlParams.RotationSetting rotation_setting = 2;
  void clear_rotation_setting();
  ::bosdyn::api::spot::BodyControlParams_RotationSetting rotation_setting() const;
  void set_rotation_setting(::bosdyn::api::spot::BodyControlParams_RotationSetting value);
  private:
  ::bosdyn::api::spot::BodyControlParams_RotationSetting _internal_rotation_setting() const;
  void _internal_set_rotation_setting(::bosdyn::api::spot::BodyControlParams_RotationSetting value);
  public:

  // .bosdyn.api.SE3Trajectory base_offset_rt_footprint = 1;
  bool has_base_offset_rt_footprint() const;
  private:
  bool _internal_has_base_offset_rt_footprint() const;
  public:
  void clear_base_offset_rt_footprint();
  const ::bosdyn::api::SE3Trajectory& base_offset_rt_footprint() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Trajectory* release_base_offset_rt_footprint();
  ::bosdyn::api::SE3Trajectory* mutable_base_offset_rt_footprint();
  void set_allocated_base_offset_rt_footprint(::bosdyn::api::SE3Trajectory* base_offset_rt_footprint);
  private:
  const ::bosdyn::api::SE3Trajectory& _internal_base_offset_rt_footprint() const;
  ::bosdyn::api::SE3Trajectory* _internal_mutable_base_offset_rt_footprint();
  public:
  void unsafe_arena_set_allocated_base_offset_rt_footprint(
      ::bosdyn::api::SE3Trajectory* base_offset_rt_footprint);
  ::bosdyn::api::SE3Trajectory* unsafe_arena_release_base_offset_rt_footprint();

  // .bosdyn.api.spot.BodyControlParams.BodyAssistForManipulation body_assist_for_manipulation = 3;
  bool has_body_assist_for_manipulation() const;
  private:
  bool _internal_has_body_assist_for_manipulation() const;
  public:
  void clear_body_assist_for_manipulation();
  const ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation& body_assist_for_manipulation() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* release_body_assist_for_manipulation();
  ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* mutable_body_assist_for_manipulation();
  void set_allocated_body_assist_for_manipulation(::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* body_assist_for_manipulation);
  private:
  const ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation& _internal_body_assist_for_manipulation() const;
  ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* _internal_mutable_body_assist_for_manipulation();
  public:
  void unsafe_arena_set_allocated_body_assist_for_manipulation(
      ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* body_assist_for_manipulation);
  ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* unsafe_arena_release_body_assist_for_manipulation();

  void clear_param();
  ParamCase param_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.BodyControlParams)
 private:
  class _Internal;
  void set_has_base_offset_rt_footprint();
  void set_has_body_assist_for_manipulation();

  inline bool has_param() const;
  inline void clear_has_param();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int rotation_setting_;
    union ParamUnion {
      constexpr ParamUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::SE3Trajectory* base_offset_rt_footprint_;
      ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* body_assist_for_manipulation_;
    } param_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2frobot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class ObstacleParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ObstacleParams) */ {
 public:
  inline ObstacleParams() : ObstacleParams(nullptr) {}
  ~ObstacleParams() override;
  explicit PROTOBUF_CONSTEXPR ObstacleParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleParams(const ObstacleParams& from);
  ObstacleParams(ObstacleParams&& from) noexcept
    : ObstacleParams() {
    *this = ::std::move(from);
  }

  inline ObstacleParams& operator=(const ObstacleParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleParams& operator=(ObstacleParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleParams* internal_default_instance() {
    return reinterpret_cast<const ObstacleParams*>(
               &_ObstacleParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ObstacleParams& a, ObstacleParams& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObstacleParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObstacleParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObstacleParams& from) {
    ObstacleParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ObstacleParams";
  }
  protected:
  explicit ObstacleParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisableVisionFootObstacleAvoidanceFieldNumber = 1,
    kDisableVisionFootConstraintAvoidanceFieldNumber = 2,
    kDisableVisionBodyObstacleAvoidanceFieldNumber = 3,
    kDisableVisionFootObstacleBodyAssistFieldNumber = 5,
    kDisableVisionNegativeObstaclesFieldNumber = 6,
    kObstacleAvoidancePaddingFieldNumber = 4,
  };
  // bool disable_vision_foot_obstacle_avoidance = 1;
  void clear_disable_vision_foot_obstacle_avoidance();
  bool disable_vision_foot_obstacle_avoidance() const;
  void set_disable_vision_foot_obstacle_avoidance(bool value);
  private:
  bool _internal_disable_vision_foot_obstacle_avoidance() const;
  void _internal_set_disable_vision_foot_obstacle_avoidance(bool value);
  public:

  // bool disable_vision_foot_constraint_avoidance = 2;
  void clear_disable_vision_foot_constraint_avoidance();
  bool disable_vision_foot_constraint_avoidance() const;
  void set_disable_vision_foot_constraint_avoidance(bool value);
  private:
  bool _internal_disable_vision_foot_constraint_avoidance() const;
  void _internal_set_disable_vision_foot_constraint_avoidance(bool value);
  public:

  // bool disable_vision_body_obstacle_avoidance = 3;
  void clear_disable_vision_body_obstacle_avoidance();
  bool disable_vision_body_obstacle_avoidance() const;
  void set_disable_vision_body_obstacle_avoidance(bool value);
  private:
  bool _internal_disable_vision_body_obstacle_avoidance() const;
  void _internal_set_disable_vision_body_obstacle_avoidance(bool value);
  public:

  // bool disable_vision_foot_obstacle_body_assist = 5;
  void clear_disable_vision_foot_obstacle_body_assist();
  bool disable_vision_foot_obstacle_body_assist() const;
  void set_disable_vision_foot_obstacle_body_assist(bool value);
  private:
  bool _internal_disable_vision_foot_obstacle_body_assist() const;
  void _internal_set_disable_vision_foot_obstacle_body_assist(bool value);
  public:

  // bool disable_vision_negative_obstacles = 6;
  void clear_disable_vision_negative_obstacles();
  bool disable_vision_negative_obstacles() const;
  void set_disable_vision_negative_obstacles(bool value);
  private:
  bool _internal_disable_vision_negative_obstacles() const;
  void _internal_set_disable_vision_negative_obstacles(bool value);
  public:

  // double obstacle_avoidance_padding = 4;
  void clear_obstacle_avoidance_padding();
  double obstacle_avoidance_padding() const;
  void set_obstacle_avoidance_padding(double value);
  private:
  double _internal_obstacle_avoidance_padding() const;
  void _internal_set_obstacle_avoidance_padding(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ObstacleParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool disable_vision_foot_obstacle_avoidance_;
    bool disable_vision_foot_constraint_avoidance_;
    bool disable_vision_body_obstacle_avoidance_;
    bool disable_vision_foot_obstacle_body_assist_;
    bool disable_vision_negative_obstacles_;
    double obstacle_avoidance_padding_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2frobot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class TerrainParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.TerrainParams) */ {
 public:
  inline TerrainParams() : TerrainParams(nullptr) {}
  ~TerrainParams() override;
  explicit PROTOBUF_CONSTEXPR TerrainParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TerrainParams(const TerrainParams& from);
  TerrainParams(TerrainParams&& from) noexcept
    : TerrainParams() {
    *this = ::std::move(from);
  }

  inline TerrainParams& operator=(const TerrainParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerrainParams& operator=(TerrainParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TerrainParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const TerrainParams* internal_default_instance() {
    return reinterpret_cast<const TerrainParams*>(
               &_TerrainParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TerrainParams& a, TerrainParams& b) {
    a.Swap(&b);
  }
  inline void Swap(TerrainParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TerrainParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TerrainParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TerrainParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TerrainParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TerrainParams& from) {
    TerrainParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TerrainParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.TerrainParams";
  }
  protected:
  explicit TerrainParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TerrainParams_GratedSurfacesMode GratedSurfacesMode;
  static constexpr GratedSurfacesMode GRATED_SURFACES_MODE_UNKNOWN =
    TerrainParams_GratedSurfacesMode_GRATED_SURFACES_MODE_UNKNOWN;
  static constexpr GratedSurfacesMode GRATED_SURFACES_MODE_OFF =
    TerrainParams_GratedSurfacesMode_GRATED_SURFACES_MODE_OFF;
  static constexpr GratedSurfacesMode GRATED_SURFACES_MODE_ON =
    TerrainParams_GratedSurfacesMode_GRATED_SURFACES_MODE_ON;
  static constexpr GratedSurfacesMode GRATED_SURFACES_MODE_AUTO =
    TerrainParams_GratedSurfacesMode_GRATED_SURFACES_MODE_AUTO;
  static inline bool GratedSurfacesMode_IsValid(int value) {
    return TerrainParams_GratedSurfacesMode_IsValid(value);
  }
  static constexpr GratedSurfacesMode GratedSurfacesMode_MIN =
    TerrainParams_GratedSurfacesMode_GratedSurfacesMode_MIN;
  static constexpr GratedSurfacesMode GratedSurfacesMode_MAX =
    TerrainParams_GratedSurfacesMode_GratedSurfacesMode_MAX;
  static constexpr int GratedSurfacesMode_ARRAYSIZE =
    TerrainParams_GratedSurfacesMode_GratedSurfacesMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GratedSurfacesMode_descriptor() {
    return TerrainParams_GratedSurfacesMode_descriptor();
  }
  template<typename T>
  static inline const std::string& GratedSurfacesMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GratedSurfacesMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GratedSurfacesMode_Name.");
    return TerrainParams_GratedSurfacesMode_Name(enum_t_value);
  }
  static inline bool GratedSurfacesMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      GratedSurfacesMode* value) {
    return TerrainParams_GratedSurfacesMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGroundMuHintFieldNumber = 2,
    kEnableGratedFloorFieldNumber = 3,
    kGratedSurfacesModeFieldNumber = 4,
  };
  // .google.protobuf.DoubleValue ground_mu_hint = 2;
  bool has_ground_mu_hint() const;
  private:
  bool _internal_has_ground_mu_hint() const;
  public:
  void clear_ground_mu_hint();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ground_mu_hint() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_ground_mu_hint();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_ground_mu_hint();
  void set_allocated_ground_mu_hint(::PROTOBUF_NAMESPACE_ID::DoubleValue* ground_mu_hint);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_ground_mu_hint() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_ground_mu_hint();
  public:
  void unsafe_arena_set_allocated_ground_mu_hint(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* ground_mu_hint);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_ground_mu_hint();

  // bool enable_grated_floor = 3 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_enable_grated_floor();
  PROTOBUF_DEPRECATED bool enable_grated_floor() const;
  PROTOBUF_DEPRECATED void set_enable_grated_floor(bool value);
  private:
  bool _internal_enable_grated_floor() const;
  void _internal_set_enable_grated_floor(bool value);
  public:

  // .bosdyn.api.spot.TerrainParams.GratedSurfacesMode grated_surfaces_mode = 4;
  void clear_grated_surfaces_mode();
  ::bosdyn::api::spot::TerrainParams_GratedSurfacesMode grated_surfaces_mode() const;
  void set_grated_surfaces_mode(::bosdyn::api::spot::TerrainParams_GratedSurfacesMode value);
  private:
  ::bosdyn::api::spot::TerrainParams_GratedSurfacesMode _internal_grated_surfaces_mode() const;
  void _internal_set_grated_surfaces_mode(::bosdyn::api::spot::TerrainParams_GratedSurfacesMode value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.TerrainParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* ground_mu_hint_;
    bool enable_grated_floor_;
    int grated_surfaces_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2frobot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class BodyExternalForceParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.BodyExternalForceParams) */ {
 public:
  inline BodyExternalForceParams() : BodyExternalForceParams(nullptr) {}
  ~BodyExternalForceParams() override;
  explicit PROTOBUF_CONSTEXPR BodyExternalForceParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BodyExternalForceParams(const BodyExternalForceParams& from);
  BodyExternalForceParams(BodyExternalForceParams&& from) noexcept
    : BodyExternalForceParams() {
    *this = ::std::move(from);
  }

  inline BodyExternalForceParams& operator=(const BodyExternalForceParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline BodyExternalForceParams& operator=(BodyExternalForceParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BodyExternalForceParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const BodyExternalForceParams* internal_default_instance() {
    return reinterpret_cast<const BodyExternalForceParams*>(
               &_BodyExternalForceParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BodyExternalForceParams& a, BodyExternalForceParams& b) {
    a.Swap(&b);
  }
  inline void Swap(BodyExternalForceParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BodyExternalForceParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BodyExternalForceParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BodyExternalForceParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BodyExternalForceParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BodyExternalForceParams& from) {
    BodyExternalForceParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BodyExternalForceParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.BodyExternalForceParams";
  }
  protected:
  explicit BodyExternalForceParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BodyExternalForceParams_ExternalForceIndicator ExternalForceIndicator;
  static constexpr ExternalForceIndicator EXTERNAL_FORCE_NONE =
    BodyExternalForceParams_ExternalForceIndicator_EXTERNAL_FORCE_NONE;
  static constexpr ExternalForceIndicator EXTERNAL_FORCE_USE_ESTIMATE =
    BodyExternalForceParams_ExternalForceIndicator_EXTERNAL_FORCE_USE_ESTIMATE;
  static constexpr ExternalForceIndicator EXTERNAL_FORCE_USE_OVERRIDE =
    BodyExternalForceParams_ExternalForceIndicator_EXTERNAL_FORCE_USE_OVERRIDE;
  static inline bool ExternalForceIndicator_IsValid(int value) {
    return BodyExternalForceParams_ExternalForceIndicator_IsValid(value);
  }
  static constexpr ExternalForceIndicator ExternalForceIndicator_MIN =
    BodyExternalForceParams_ExternalForceIndicator_ExternalForceIndicator_MIN;
  static constexpr ExternalForceIndicator ExternalForceIndicator_MAX =
    BodyExternalForceParams_ExternalForceIndicator_ExternalForceIndicator_MAX;
  static constexpr int ExternalForceIndicator_ARRAYSIZE =
    BodyExternalForceParams_ExternalForceIndicator_ExternalForceIndicator_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ExternalForceIndicator_descriptor() {
    return BodyExternalForceParams_ExternalForceIndicator_descriptor();
  }
  template<typename T>
  static inline const std::string& ExternalForceIndicator_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ExternalForceIndicator>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ExternalForceIndicator_Name.");
    return BodyExternalForceParams_ExternalForceIndicator_Name(enum_t_value);
  }
  static inline bool ExternalForceIndicator_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ExternalForceIndicator* value) {
    return BodyExternalForceParams_ExternalForceIndicator_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFieldNumber = 4,
    kExternalForceOverrideFieldNumber = 3,
    kExternalForceIndicatorFieldNumber = 1,
  };
  // string frame_name = 4;
  void clear_frame_name();
  const std::string& frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name();
  PROTOBUF_NODISCARD std::string* release_frame_name();
  void set_allocated_frame_name(std::string* frame_name);
  private:
  const std::string& _internal_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name(const std::string& value);
  std::string* _internal_mutable_frame_name();
  public:

  // .bosdyn.api.Vec3 external_force_override = 3;
  bool has_external_force_override() const;
  private:
  bool _internal_has_external_force_override() const;
  public:
  void clear_external_force_override();
  const ::bosdyn::api::Vec3& external_force_override() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_external_force_override();
  ::bosdyn::api::Vec3* mutable_external_force_override();
  void set_allocated_external_force_override(::bosdyn::api::Vec3* external_force_override);
  private:
  const ::bosdyn::api::Vec3& _internal_external_force_override() const;
  ::bosdyn::api::Vec3* _internal_mutable_external_force_override();
  public:
  void unsafe_arena_set_allocated_external_force_override(
      ::bosdyn::api::Vec3* external_force_override);
  ::bosdyn::api::Vec3* unsafe_arena_release_external_force_override();

  // .bosdyn.api.spot.BodyExternalForceParams.ExternalForceIndicator external_force_indicator = 1;
  void clear_external_force_indicator();
  ::bosdyn::api::spot::BodyExternalForceParams_ExternalForceIndicator external_force_indicator() const;
  void set_external_force_indicator(::bosdyn::api::spot::BodyExternalForceParams_ExternalForceIndicator value);
  private:
  ::bosdyn::api::spot::BodyExternalForceParams_ExternalForceIndicator _internal_external_force_indicator() const;
  void _internal_set_external_force_indicator(::bosdyn::api::spot::BodyExternalForceParams_ExternalForceIndicator value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.BodyExternalForceParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_;
    ::bosdyn::api::Vec3* external_force_override_;
    int external_force_indicator_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2frobot_5fcommand_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MobilityParams

// .bosdyn.api.SE2VelocityLimit vel_limit = 1;
inline bool MobilityParams::_internal_has_vel_limit() const {
  return this != internal_default_instance() && _impl_.vel_limit_ != nullptr;
}
inline bool MobilityParams::has_vel_limit() const {
  return _internal_has_vel_limit();
}
inline const ::bosdyn::api::SE2VelocityLimit& MobilityParams::_internal_vel_limit() const {
  const ::bosdyn::api::SE2VelocityLimit* p = _impl_.vel_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE2VelocityLimit&>(
      ::bosdyn::api::_SE2VelocityLimit_default_instance_);
}
inline const ::bosdyn::api::SE2VelocityLimit& MobilityParams::vel_limit() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MobilityParams.vel_limit)
  return _internal_vel_limit();
}
inline void MobilityParams::unsafe_arena_set_allocated_vel_limit(
    ::bosdyn::api::SE2VelocityLimit* vel_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vel_limit_);
  }
  _impl_.vel_limit_ = vel_limit;
  if (vel_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MobilityParams.vel_limit)
}
inline ::bosdyn::api::SE2VelocityLimit* MobilityParams::release_vel_limit() {
  
  ::bosdyn::api::SE2VelocityLimit* temp = _impl_.vel_limit_;
  _impl_.vel_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE2VelocityLimit* MobilityParams::unsafe_arena_release_vel_limit() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MobilityParams.vel_limit)
  
  ::bosdyn::api::SE2VelocityLimit* temp = _impl_.vel_limit_;
  _impl_.vel_limit_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE2VelocityLimit* MobilityParams::_internal_mutable_vel_limit() {
  
  if (_impl_.vel_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE2VelocityLimit>(GetArenaForAllocation());
    _impl_.vel_limit_ = p;
  }
  return _impl_.vel_limit_;
}
inline ::bosdyn::api::SE2VelocityLimit* MobilityParams::mutable_vel_limit() {
  ::bosdyn::api::SE2VelocityLimit* _msg = _internal_mutable_vel_limit();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MobilityParams.vel_limit)
  return _msg;
}
inline void MobilityParams::set_allocated_vel_limit(::bosdyn::api::SE2VelocityLimit* vel_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vel_limit_);
  }
  if (vel_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vel_limit));
    if (message_arena != submessage_arena) {
      vel_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vel_limit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vel_limit_ = vel_limit;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.MobilityParams.vel_limit)
}

// .bosdyn.api.spot.BodyControlParams body_control = 2;
inline bool MobilityParams::_internal_has_body_control() const {
  return this != internal_default_instance() && _impl_.body_control_ != nullptr;
}
inline bool MobilityParams::has_body_control() const {
  return _internal_has_body_control();
}
inline void MobilityParams::clear_body_control() {
  if (GetArenaForAllocation() == nullptr && _impl_.body_control_ != nullptr) {
    delete _impl_.body_control_;
  }
  _impl_.body_control_ = nullptr;
}
inline const ::bosdyn::api::spot::BodyControlParams& MobilityParams::_internal_body_control() const {
  const ::bosdyn::api::spot::BodyControlParams* p = _impl_.body_control_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::BodyControlParams&>(
      ::bosdyn::api::spot::_BodyControlParams_default_instance_);
}
inline const ::bosdyn::api::spot::BodyControlParams& MobilityParams::body_control() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MobilityParams.body_control)
  return _internal_body_control();
}
inline void MobilityParams::unsafe_arena_set_allocated_body_control(
    ::bosdyn::api::spot::BodyControlParams* body_control) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_control_);
  }
  _impl_.body_control_ = body_control;
  if (body_control) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MobilityParams.body_control)
}
inline ::bosdyn::api::spot::BodyControlParams* MobilityParams::release_body_control() {
  
  ::bosdyn::api::spot::BodyControlParams* temp = _impl_.body_control_;
  _impl_.body_control_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::BodyControlParams* MobilityParams::unsafe_arena_release_body_control() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MobilityParams.body_control)
  
  ::bosdyn::api::spot::BodyControlParams* temp = _impl_.body_control_;
  _impl_.body_control_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::BodyControlParams* MobilityParams::_internal_mutable_body_control() {
  
  if (_impl_.body_control_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::BodyControlParams>(GetArenaForAllocation());
    _impl_.body_control_ = p;
  }
  return _impl_.body_control_;
}
inline ::bosdyn::api::spot::BodyControlParams* MobilityParams::mutable_body_control() {
  ::bosdyn::api::spot::BodyControlParams* _msg = _internal_mutable_body_control();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MobilityParams.body_control)
  return _msg;
}
inline void MobilityParams::set_allocated_body_control(::bosdyn::api::spot::BodyControlParams* body_control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.body_control_;
  }
  if (body_control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_control);
    if (message_arena != submessage_arena) {
      body_control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_control, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.body_control_ = body_control;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.MobilityParams.body_control)
}

// .bosdyn.api.spot.LocomotionHint locomotion_hint = 3;
inline void MobilityParams::clear_locomotion_hint() {
  _impl_.locomotion_hint_ = 0;
}
inline ::bosdyn::api::spot::LocomotionHint MobilityParams::_internal_locomotion_hint() const {
  return static_cast< ::bosdyn::api::spot::LocomotionHint >(_impl_.locomotion_hint_);
}
inline ::bosdyn::api::spot::LocomotionHint MobilityParams::locomotion_hint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MobilityParams.locomotion_hint)
  return _internal_locomotion_hint();
}
inline void MobilityParams::_internal_set_locomotion_hint(::bosdyn::api::spot::LocomotionHint value) {
  
  _impl_.locomotion_hint_ = value;
}
inline void MobilityParams::set_locomotion_hint(::bosdyn::api::spot::LocomotionHint value) {
  _internal_set_locomotion_hint(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MobilityParams.locomotion_hint)
}

// bool stair_hint = 4 [deprecated = true];
inline void MobilityParams::clear_stair_hint() {
  _impl_.stair_hint_ = false;
}
inline bool MobilityParams::_internal_stair_hint() const {
  return _impl_.stair_hint_;
}
inline bool MobilityParams::stair_hint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MobilityParams.stair_hint)
  return _internal_stair_hint();
}
inline void MobilityParams::_internal_set_stair_hint(bool value) {
  
  _impl_.stair_hint_ = value;
}
inline void MobilityParams::set_stair_hint(bool value) {
  _internal_set_stair_hint(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MobilityParams.stair_hint)
}

// .bosdyn.api.spot.MobilityParams.StairsMode stairs_mode = 17;
inline void MobilityParams::clear_stairs_mode() {
  _impl_.stairs_mode_ = 0;
}
inline ::bosdyn::api::spot::MobilityParams_StairsMode MobilityParams::_internal_stairs_mode() const {
  return static_cast< ::bosdyn::api::spot::MobilityParams_StairsMode >(_impl_.stairs_mode_);
}
inline ::bosdyn::api::spot::MobilityParams_StairsMode MobilityParams::stairs_mode() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MobilityParams.stairs_mode)
  return _internal_stairs_mode();
}
inline void MobilityParams::_internal_set_stairs_mode(::bosdyn::api::spot::MobilityParams_StairsMode value) {
  
  _impl_.stairs_mode_ = value;
}
inline void MobilityParams::set_stairs_mode(::bosdyn::api::spot::MobilityParams_StairsMode value) {
  _internal_set_stairs_mode(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MobilityParams.stairs_mode)
}

// bool allow_degraded_perception = 5;
inline void MobilityParams::clear_allow_degraded_perception() {
  _impl_.allow_degraded_perception_ = false;
}
inline bool MobilityParams::_internal_allow_degraded_perception() const {
  return _impl_.allow_degraded_perception_;
}
inline bool MobilityParams::allow_degraded_perception() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MobilityParams.allow_degraded_perception)
  return _internal_allow_degraded_perception();
}
inline void MobilityParams::_internal_set_allow_degraded_perception(bool value) {
  
  _impl_.allow_degraded_perception_ = value;
}
inline void MobilityParams::set_allow_degraded_perception(bool value) {
  _internal_set_allow_degraded_perception(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MobilityParams.allow_degraded_perception)
}

// .bosdyn.api.spot.ObstacleParams obstacle_params = 6;
inline bool MobilityParams::_internal_has_obstacle_params() const {
  return this != internal_default_instance() && _impl_.obstacle_params_ != nullptr;
}
inline bool MobilityParams::has_obstacle_params() const {
  return _internal_has_obstacle_params();
}
inline void MobilityParams::clear_obstacle_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.obstacle_params_ != nullptr) {
    delete _impl_.obstacle_params_;
  }
  _impl_.obstacle_params_ = nullptr;
}
inline const ::bosdyn::api::spot::ObstacleParams& MobilityParams::_internal_obstacle_params() const {
  const ::bosdyn::api::spot::ObstacleParams* p = _impl_.obstacle_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::ObstacleParams&>(
      ::bosdyn::api::spot::_ObstacleParams_default_instance_);
}
inline const ::bosdyn::api::spot::ObstacleParams& MobilityParams::obstacle_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MobilityParams.obstacle_params)
  return _internal_obstacle_params();
}
inline void MobilityParams::unsafe_arena_set_allocated_obstacle_params(
    ::bosdyn::api::spot::ObstacleParams* obstacle_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obstacle_params_);
  }
  _impl_.obstacle_params_ = obstacle_params;
  if (obstacle_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MobilityParams.obstacle_params)
}
inline ::bosdyn::api::spot::ObstacleParams* MobilityParams::release_obstacle_params() {
  
  ::bosdyn::api::spot::ObstacleParams* temp = _impl_.obstacle_params_;
  _impl_.obstacle_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::ObstacleParams* MobilityParams::unsafe_arena_release_obstacle_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MobilityParams.obstacle_params)
  
  ::bosdyn::api::spot::ObstacleParams* temp = _impl_.obstacle_params_;
  _impl_.obstacle_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::ObstacleParams* MobilityParams::_internal_mutable_obstacle_params() {
  
  if (_impl_.obstacle_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::ObstacleParams>(GetArenaForAllocation());
    _impl_.obstacle_params_ = p;
  }
  return _impl_.obstacle_params_;
}
inline ::bosdyn::api::spot::ObstacleParams* MobilityParams::mutable_obstacle_params() {
  ::bosdyn::api::spot::ObstacleParams* _msg = _internal_mutable_obstacle_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MobilityParams.obstacle_params)
  return _msg;
}
inline void MobilityParams::set_allocated_obstacle_params(::bosdyn::api::spot::ObstacleParams* obstacle_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.obstacle_params_;
  }
  if (obstacle_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(obstacle_params);
    if (message_arena != submessage_arena) {
      obstacle_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obstacle_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.obstacle_params_ = obstacle_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.MobilityParams.obstacle_params)
}

// .bosdyn.api.spot.SwingHeight swing_height = 7;
inline void MobilityParams::clear_swing_height() {
  _impl_.swing_height_ = 0;
}
inline ::bosdyn::api::spot::SwingHeight MobilityParams::_internal_swing_height() const {
  return static_cast< ::bosdyn::api::spot::SwingHeight >(_impl_.swing_height_);
}
inline ::bosdyn::api::spot::SwingHeight MobilityParams::swing_height() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MobilityParams.swing_height)
  return _internal_swing_height();
}
inline void MobilityParams::_internal_set_swing_height(::bosdyn::api::spot::SwingHeight value) {
  
  _impl_.swing_height_ = value;
}
inline void MobilityParams::set_swing_height(::bosdyn::api::spot::SwingHeight value) {
  _internal_set_swing_height(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MobilityParams.swing_height)
}

// .bosdyn.api.spot.TerrainParams terrain_params = 8;
inline bool MobilityParams::_internal_has_terrain_params() const {
  return this != internal_default_instance() && _impl_.terrain_params_ != nullptr;
}
inline bool MobilityParams::has_terrain_params() const {
  return _internal_has_terrain_params();
}
inline void MobilityParams::clear_terrain_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.terrain_params_ != nullptr) {
    delete _impl_.terrain_params_;
  }
  _impl_.terrain_params_ = nullptr;
}
inline const ::bosdyn::api::spot::TerrainParams& MobilityParams::_internal_terrain_params() const {
  const ::bosdyn::api::spot::TerrainParams* p = _impl_.terrain_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::TerrainParams&>(
      ::bosdyn::api::spot::_TerrainParams_default_instance_);
}
inline const ::bosdyn::api::spot::TerrainParams& MobilityParams::terrain_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MobilityParams.terrain_params)
  return _internal_terrain_params();
}
inline void MobilityParams::unsafe_arena_set_allocated_terrain_params(
    ::bosdyn::api::spot::TerrainParams* terrain_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.terrain_params_);
  }
  _impl_.terrain_params_ = terrain_params;
  if (terrain_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MobilityParams.terrain_params)
}
inline ::bosdyn::api::spot::TerrainParams* MobilityParams::release_terrain_params() {
  
  ::bosdyn::api::spot::TerrainParams* temp = _impl_.terrain_params_;
  _impl_.terrain_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::TerrainParams* MobilityParams::unsafe_arena_release_terrain_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MobilityParams.terrain_params)
  
  ::bosdyn::api::spot::TerrainParams* temp = _impl_.terrain_params_;
  _impl_.terrain_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::TerrainParams* MobilityParams::_internal_mutable_terrain_params() {
  
  if (_impl_.terrain_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::TerrainParams>(GetArenaForAllocation());
    _impl_.terrain_params_ = p;
  }
  return _impl_.terrain_params_;
}
inline ::bosdyn::api::spot::TerrainParams* MobilityParams::mutable_terrain_params() {
  ::bosdyn::api::spot::TerrainParams* _msg = _internal_mutable_terrain_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MobilityParams.terrain_params)
  return _msg;
}
inline void MobilityParams::set_allocated_terrain_params(::bosdyn::api::spot::TerrainParams* terrain_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.terrain_params_;
  }
  if (terrain_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(terrain_params);
    if (message_arena != submessage_arena) {
      terrain_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terrain_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.terrain_params_ = terrain_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.MobilityParams.terrain_params)
}

// bool disallow_stair_tracker = 9;
inline void MobilityParams::clear_disallow_stair_tracker() {
  _impl_.disallow_stair_tracker_ = false;
}
inline bool MobilityParams::_internal_disallow_stair_tracker() const {
  return _impl_.disallow_stair_tracker_;
}
inline bool MobilityParams::disallow_stair_tracker() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MobilityParams.disallow_stair_tracker)
  return _internal_disallow_stair_tracker();
}
inline void MobilityParams::_internal_set_disallow_stair_tracker(bool value) {
  
  _impl_.disallow_stair_tracker_ = value;
}
inline void MobilityParams::set_disallow_stair_tracker(bool value) {
  _internal_set_disallow_stair_tracker(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MobilityParams.disallow_stair_tracker)
}

// bool disable_stair_error_auto_descent = 16;
inline void MobilityParams::clear_disable_stair_error_auto_descent() {
  _impl_.disable_stair_error_auto_descent_ = false;
}
inline bool MobilityParams::_internal_disable_stair_error_auto_descent() const {
  return _impl_.disable_stair_error_auto_descent_;
}
inline bool MobilityParams::disable_stair_error_auto_descent() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MobilityParams.disable_stair_error_auto_descent)
  return _internal_disable_stair_error_auto_descent();
}
inline void MobilityParams::_internal_set_disable_stair_error_auto_descent(bool value) {
  
  _impl_.disable_stair_error_auto_descent_ = value;
}
inline void MobilityParams::set_disable_stair_error_auto_descent(bool value) {
  _internal_set_disable_stair_error_auto_descent(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MobilityParams.disable_stair_error_auto_descent)
}

// .bosdyn.api.spot.BodyExternalForceParams external_force_params = 10;
inline bool MobilityParams::_internal_has_external_force_params() const {
  return this != internal_default_instance() && _impl_.external_force_params_ != nullptr;
}
inline bool MobilityParams::has_external_force_params() const {
  return _internal_has_external_force_params();
}
inline void MobilityParams::clear_external_force_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.external_force_params_ != nullptr) {
    delete _impl_.external_force_params_;
  }
  _impl_.external_force_params_ = nullptr;
}
inline const ::bosdyn::api::spot::BodyExternalForceParams& MobilityParams::_internal_external_force_params() const {
  const ::bosdyn::api::spot::BodyExternalForceParams* p = _impl_.external_force_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::BodyExternalForceParams&>(
      ::bosdyn::api::spot::_BodyExternalForceParams_default_instance_);
}
inline const ::bosdyn::api::spot::BodyExternalForceParams& MobilityParams::external_force_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MobilityParams.external_force_params)
  return _internal_external_force_params();
}
inline void MobilityParams::unsafe_arena_set_allocated_external_force_params(
    ::bosdyn::api::spot::BodyExternalForceParams* external_force_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_force_params_);
  }
  _impl_.external_force_params_ = external_force_params;
  if (external_force_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MobilityParams.external_force_params)
}
inline ::bosdyn::api::spot::BodyExternalForceParams* MobilityParams::release_external_force_params() {
  
  ::bosdyn::api::spot::BodyExternalForceParams* temp = _impl_.external_force_params_;
  _impl_.external_force_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::BodyExternalForceParams* MobilityParams::unsafe_arena_release_external_force_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MobilityParams.external_force_params)
  
  ::bosdyn::api::spot::BodyExternalForceParams* temp = _impl_.external_force_params_;
  _impl_.external_force_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::BodyExternalForceParams* MobilityParams::_internal_mutable_external_force_params() {
  
  if (_impl_.external_force_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::BodyExternalForceParams>(GetArenaForAllocation());
    _impl_.external_force_params_ = p;
  }
  return _impl_.external_force_params_;
}
inline ::bosdyn::api::spot::BodyExternalForceParams* MobilityParams::mutable_external_force_params() {
  ::bosdyn::api::spot::BodyExternalForceParams* _msg = _internal_mutable_external_force_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MobilityParams.external_force_params)
  return _msg;
}
inline void MobilityParams::set_allocated_external_force_params(::bosdyn::api::spot::BodyExternalForceParams* external_force_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.external_force_params_;
  }
  if (external_force_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external_force_params);
    if (message_arena != submessage_arena) {
      external_force_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_force_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.external_force_params_ = external_force_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.MobilityParams.external_force_params)
}

// bool disallow_non_stairs_pitch_limiting = 11;
inline void MobilityParams::clear_disallow_non_stairs_pitch_limiting() {
  _impl_.disallow_non_stairs_pitch_limiting_ = false;
}
inline bool MobilityParams::_internal_disallow_non_stairs_pitch_limiting() const {
  return _impl_.disallow_non_stairs_pitch_limiting_;
}
inline bool MobilityParams::disallow_non_stairs_pitch_limiting() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MobilityParams.disallow_non_stairs_pitch_limiting)
  return _internal_disallow_non_stairs_pitch_limiting();
}
inline void MobilityParams::_internal_set_disallow_non_stairs_pitch_limiting(bool value) {
  
  _impl_.disallow_non_stairs_pitch_limiting_ = value;
}
inline void MobilityParams::set_disallow_non_stairs_pitch_limiting(bool value) {
  _internal_set_disallow_non_stairs_pitch_limiting(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MobilityParams.disallow_non_stairs_pitch_limiting)
}

// bool disable_nearmap_cliff_avoidance = 12;
inline void MobilityParams::clear_disable_nearmap_cliff_avoidance() {
  _impl_.disable_nearmap_cliff_avoidance_ = false;
}
inline bool MobilityParams::_internal_disable_nearmap_cliff_avoidance() const {
  return _impl_.disable_nearmap_cliff_avoidance_;
}
inline bool MobilityParams::disable_nearmap_cliff_avoidance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MobilityParams.disable_nearmap_cliff_avoidance)
  return _internal_disable_nearmap_cliff_avoidance();
}
inline void MobilityParams::_internal_set_disable_nearmap_cliff_avoidance(bool value) {
  
  _impl_.disable_nearmap_cliff_avoidance_ = value;
}
inline void MobilityParams::set_disable_nearmap_cliff_avoidance(bool value) {
  _internal_set_disable_nearmap_cliff_avoidance(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MobilityParams.disable_nearmap_cliff_avoidance)
}

// -------------------------------------------------------------------

// BodyControlParams_BodyAssistForManipulation

// bool enable_body_yaw_assist = 1;
inline void BodyControlParams_BodyAssistForManipulation::clear_enable_body_yaw_assist() {
  _impl_.enable_body_yaw_assist_ = false;
}
inline bool BodyControlParams_BodyAssistForManipulation::_internal_enable_body_yaw_assist() const {
  return _impl_.enable_body_yaw_assist_;
}
inline bool BodyControlParams_BodyAssistForManipulation::enable_body_yaw_assist() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.BodyControlParams.BodyAssistForManipulation.enable_body_yaw_assist)
  return _internal_enable_body_yaw_assist();
}
inline void BodyControlParams_BodyAssistForManipulation::_internal_set_enable_body_yaw_assist(bool value) {
  
  _impl_.enable_body_yaw_assist_ = value;
}
inline void BodyControlParams_BodyAssistForManipulation::set_enable_body_yaw_assist(bool value) {
  _internal_set_enable_body_yaw_assist(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.BodyControlParams.BodyAssistForManipulation.enable_body_yaw_assist)
}

// bool enable_hip_height_assist = 2;
inline void BodyControlParams_BodyAssistForManipulation::clear_enable_hip_height_assist() {
  _impl_.enable_hip_height_assist_ = false;
}
inline bool BodyControlParams_BodyAssistForManipulation::_internal_enable_hip_height_assist() const {
  return _impl_.enable_hip_height_assist_;
}
inline bool BodyControlParams_BodyAssistForManipulation::enable_hip_height_assist() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.BodyControlParams.BodyAssistForManipulation.enable_hip_height_assist)
  return _internal_enable_hip_height_assist();
}
inline void BodyControlParams_BodyAssistForManipulation::_internal_set_enable_hip_height_assist(bool value) {
  
  _impl_.enable_hip_height_assist_ = value;
}
inline void BodyControlParams_BodyAssistForManipulation::set_enable_hip_height_assist(bool value) {
  _internal_set_enable_hip_height_assist(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.BodyControlParams.BodyAssistForManipulation.enable_hip_height_assist)
}

// -------------------------------------------------------------------

// BodyControlParams

// .bosdyn.api.SE3Trajectory base_offset_rt_footprint = 1;
inline bool BodyControlParams::_internal_has_base_offset_rt_footprint() const {
  return param_case() == kBaseOffsetRtFootprint;
}
inline bool BodyControlParams::has_base_offset_rt_footprint() const {
  return _internal_has_base_offset_rt_footprint();
}
inline void BodyControlParams::set_has_base_offset_rt_footprint() {
  _impl_._oneof_case_[0] = kBaseOffsetRtFootprint;
}
inline ::bosdyn::api::SE3Trajectory* BodyControlParams::release_base_offset_rt_footprint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.BodyControlParams.base_offset_rt_footprint)
  if (_internal_has_base_offset_rt_footprint()) {
    clear_has_param();
    ::bosdyn::api::SE3Trajectory* temp = _impl_.param_.base_offset_rt_footprint_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.param_.base_offset_rt_footprint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::SE3Trajectory& BodyControlParams::_internal_base_offset_rt_footprint() const {
  return _internal_has_base_offset_rt_footprint()
      ? *_impl_.param_.base_offset_rt_footprint_
      : reinterpret_cast< ::bosdyn::api::SE3Trajectory&>(::bosdyn::api::_SE3Trajectory_default_instance_);
}
inline const ::bosdyn::api::SE3Trajectory& BodyControlParams::base_offset_rt_footprint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.BodyControlParams.base_offset_rt_footprint)
  return _internal_base_offset_rt_footprint();
}
inline ::bosdyn::api::SE3Trajectory* BodyControlParams::unsafe_arena_release_base_offset_rt_footprint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.BodyControlParams.base_offset_rt_footprint)
  if (_internal_has_base_offset_rt_footprint()) {
    clear_has_param();
    ::bosdyn::api::SE3Trajectory* temp = _impl_.param_.base_offset_rt_footprint_;
    _impl_.param_.base_offset_rt_footprint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BodyControlParams::unsafe_arena_set_allocated_base_offset_rt_footprint(::bosdyn::api::SE3Trajectory* base_offset_rt_footprint) {
  clear_param();
  if (base_offset_rt_footprint) {
    set_has_base_offset_rt_footprint();
    _impl_.param_.base_offset_rt_footprint_ = base_offset_rt_footprint;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.BodyControlParams.base_offset_rt_footprint)
}
inline ::bosdyn::api::SE3Trajectory* BodyControlParams::_internal_mutable_base_offset_rt_footprint() {
  if (!_internal_has_base_offset_rt_footprint()) {
    clear_param();
    set_has_base_offset_rt_footprint();
    _impl_.param_.base_offset_rt_footprint_ = CreateMaybeMessage< ::bosdyn::api::SE3Trajectory >(GetArenaForAllocation());
  }
  return _impl_.param_.base_offset_rt_footprint_;
}
inline ::bosdyn::api::SE3Trajectory* BodyControlParams::mutable_base_offset_rt_footprint() {
  ::bosdyn::api::SE3Trajectory* _msg = _internal_mutable_base_offset_rt_footprint();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.BodyControlParams.base_offset_rt_footprint)
  return _msg;
}

// .bosdyn.api.spot.BodyControlParams.BodyAssistForManipulation body_assist_for_manipulation = 3;
inline bool BodyControlParams::_internal_has_body_assist_for_manipulation() const {
  return param_case() == kBodyAssistForManipulation;
}
inline bool BodyControlParams::has_body_assist_for_manipulation() const {
  return _internal_has_body_assist_for_manipulation();
}
inline void BodyControlParams::set_has_body_assist_for_manipulation() {
  _impl_._oneof_case_[0] = kBodyAssistForManipulation;
}
inline void BodyControlParams::clear_body_assist_for_manipulation() {
  if (_internal_has_body_assist_for_manipulation()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.param_.body_assist_for_manipulation_;
    }
    clear_has_param();
  }
}
inline ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* BodyControlParams::release_body_assist_for_manipulation() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.BodyControlParams.body_assist_for_manipulation)
  if (_internal_has_body_assist_for_manipulation()) {
    clear_has_param();
    ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* temp = _impl_.param_.body_assist_for_manipulation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.param_.body_assist_for_manipulation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation& BodyControlParams::_internal_body_assist_for_manipulation() const {
  return _internal_has_body_assist_for_manipulation()
      ? *_impl_.param_.body_assist_for_manipulation_
      : reinterpret_cast< ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation&>(::bosdyn::api::spot::_BodyControlParams_BodyAssistForManipulation_default_instance_);
}
inline const ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation& BodyControlParams::body_assist_for_manipulation() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.BodyControlParams.body_assist_for_manipulation)
  return _internal_body_assist_for_manipulation();
}
inline ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* BodyControlParams::unsafe_arena_release_body_assist_for_manipulation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.BodyControlParams.body_assist_for_manipulation)
  if (_internal_has_body_assist_for_manipulation()) {
    clear_has_param();
    ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* temp = _impl_.param_.body_assist_for_manipulation_;
    _impl_.param_.body_assist_for_manipulation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BodyControlParams::unsafe_arena_set_allocated_body_assist_for_manipulation(::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* body_assist_for_manipulation) {
  clear_param();
  if (body_assist_for_manipulation) {
    set_has_body_assist_for_manipulation();
    _impl_.param_.body_assist_for_manipulation_ = body_assist_for_manipulation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.BodyControlParams.body_assist_for_manipulation)
}
inline ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* BodyControlParams::_internal_mutable_body_assist_for_manipulation() {
  if (!_internal_has_body_assist_for_manipulation()) {
    clear_param();
    set_has_body_assist_for_manipulation();
    _impl_.param_.body_assist_for_manipulation_ = CreateMaybeMessage< ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation >(GetArenaForAllocation());
  }
  return _impl_.param_.body_assist_for_manipulation_;
}
inline ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* BodyControlParams::mutable_body_assist_for_manipulation() {
  ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* _msg = _internal_mutable_body_assist_for_manipulation();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.BodyControlParams.body_assist_for_manipulation)
  return _msg;
}

// .bosdyn.api.spot.BodyControlParams.RotationSetting rotation_setting = 2;
inline void BodyControlParams::clear_rotation_setting() {
  _impl_.rotation_setting_ = 0;
}
inline ::bosdyn::api::spot::BodyControlParams_RotationSetting BodyControlParams::_internal_rotation_setting() const {
  return static_cast< ::bosdyn::api::spot::BodyControlParams_RotationSetting >(_impl_.rotation_setting_);
}
inline ::bosdyn::api::spot::BodyControlParams_RotationSetting BodyControlParams::rotation_setting() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.BodyControlParams.rotation_setting)
  return _internal_rotation_setting();
}
inline void BodyControlParams::_internal_set_rotation_setting(::bosdyn::api::spot::BodyControlParams_RotationSetting value) {
  
  _impl_.rotation_setting_ = value;
}
inline void BodyControlParams::set_rotation_setting(::bosdyn::api::spot::BodyControlParams_RotationSetting value) {
  _internal_set_rotation_setting(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.BodyControlParams.rotation_setting)
}

inline bool BodyControlParams::has_param() const {
  return param_case() != PARAM_NOT_SET;
}
inline void BodyControlParams::clear_has_param() {
  _impl_._oneof_case_[0] = PARAM_NOT_SET;
}
inline BodyControlParams::ParamCase BodyControlParams::param_case() const {
  return BodyControlParams::ParamCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ObstacleParams

// bool disable_vision_foot_obstacle_avoidance = 1;
inline void ObstacleParams::clear_disable_vision_foot_obstacle_avoidance() {
  _impl_.disable_vision_foot_obstacle_avoidance_ = false;
}
inline bool ObstacleParams::_internal_disable_vision_foot_obstacle_avoidance() const {
  return _impl_.disable_vision_foot_obstacle_avoidance_;
}
inline bool ObstacleParams::disable_vision_foot_obstacle_avoidance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ObstacleParams.disable_vision_foot_obstacle_avoidance)
  return _internal_disable_vision_foot_obstacle_avoidance();
}
inline void ObstacleParams::_internal_set_disable_vision_foot_obstacle_avoidance(bool value) {
  
  _impl_.disable_vision_foot_obstacle_avoidance_ = value;
}
inline void ObstacleParams::set_disable_vision_foot_obstacle_avoidance(bool value) {
  _internal_set_disable_vision_foot_obstacle_avoidance(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ObstacleParams.disable_vision_foot_obstacle_avoidance)
}

// bool disable_vision_foot_constraint_avoidance = 2;
inline void ObstacleParams::clear_disable_vision_foot_constraint_avoidance() {
  _impl_.disable_vision_foot_constraint_avoidance_ = false;
}
inline bool ObstacleParams::_internal_disable_vision_foot_constraint_avoidance() const {
  return _impl_.disable_vision_foot_constraint_avoidance_;
}
inline bool ObstacleParams::disable_vision_foot_constraint_avoidance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ObstacleParams.disable_vision_foot_constraint_avoidance)
  return _internal_disable_vision_foot_constraint_avoidance();
}
inline void ObstacleParams::_internal_set_disable_vision_foot_constraint_avoidance(bool value) {
  
  _impl_.disable_vision_foot_constraint_avoidance_ = value;
}
inline void ObstacleParams::set_disable_vision_foot_constraint_avoidance(bool value) {
  _internal_set_disable_vision_foot_constraint_avoidance(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ObstacleParams.disable_vision_foot_constraint_avoidance)
}

// bool disable_vision_body_obstacle_avoidance = 3;
inline void ObstacleParams::clear_disable_vision_body_obstacle_avoidance() {
  _impl_.disable_vision_body_obstacle_avoidance_ = false;
}
inline bool ObstacleParams::_internal_disable_vision_body_obstacle_avoidance() const {
  return _impl_.disable_vision_body_obstacle_avoidance_;
}
inline bool ObstacleParams::disable_vision_body_obstacle_avoidance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ObstacleParams.disable_vision_body_obstacle_avoidance)
  return _internal_disable_vision_body_obstacle_avoidance();
}
inline void ObstacleParams::_internal_set_disable_vision_body_obstacle_avoidance(bool value) {
  
  _impl_.disable_vision_body_obstacle_avoidance_ = value;
}
inline void ObstacleParams::set_disable_vision_body_obstacle_avoidance(bool value) {
  _internal_set_disable_vision_body_obstacle_avoidance(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ObstacleParams.disable_vision_body_obstacle_avoidance)
}

// double obstacle_avoidance_padding = 4;
inline void ObstacleParams::clear_obstacle_avoidance_padding() {
  _impl_.obstacle_avoidance_padding_ = 0;
}
inline double ObstacleParams::_internal_obstacle_avoidance_padding() const {
  return _impl_.obstacle_avoidance_padding_;
}
inline double ObstacleParams::obstacle_avoidance_padding() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ObstacleParams.obstacle_avoidance_padding)
  return _internal_obstacle_avoidance_padding();
}
inline void ObstacleParams::_internal_set_obstacle_avoidance_padding(double value) {
  
  _impl_.obstacle_avoidance_padding_ = value;
}
inline void ObstacleParams::set_obstacle_avoidance_padding(double value) {
  _internal_set_obstacle_avoidance_padding(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ObstacleParams.obstacle_avoidance_padding)
}

// bool disable_vision_foot_obstacle_body_assist = 5;
inline void ObstacleParams::clear_disable_vision_foot_obstacle_body_assist() {
  _impl_.disable_vision_foot_obstacle_body_assist_ = false;
}
inline bool ObstacleParams::_internal_disable_vision_foot_obstacle_body_assist() const {
  return _impl_.disable_vision_foot_obstacle_body_assist_;
}
inline bool ObstacleParams::disable_vision_foot_obstacle_body_assist() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ObstacleParams.disable_vision_foot_obstacle_body_assist)
  return _internal_disable_vision_foot_obstacle_body_assist();
}
inline void ObstacleParams::_internal_set_disable_vision_foot_obstacle_body_assist(bool value) {
  
  _impl_.disable_vision_foot_obstacle_body_assist_ = value;
}
inline void ObstacleParams::set_disable_vision_foot_obstacle_body_assist(bool value) {
  _internal_set_disable_vision_foot_obstacle_body_assist(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ObstacleParams.disable_vision_foot_obstacle_body_assist)
}

// bool disable_vision_negative_obstacles = 6;
inline void ObstacleParams::clear_disable_vision_negative_obstacles() {
  _impl_.disable_vision_negative_obstacles_ = false;
}
inline bool ObstacleParams::_internal_disable_vision_negative_obstacles() const {
  return _impl_.disable_vision_negative_obstacles_;
}
inline bool ObstacleParams::disable_vision_negative_obstacles() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ObstacleParams.disable_vision_negative_obstacles)
  return _internal_disable_vision_negative_obstacles();
}
inline void ObstacleParams::_internal_set_disable_vision_negative_obstacles(bool value) {
  
  _impl_.disable_vision_negative_obstacles_ = value;
}
inline void ObstacleParams::set_disable_vision_negative_obstacles(bool value) {
  _internal_set_disable_vision_negative_obstacles(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ObstacleParams.disable_vision_negative_obstacles)
}

// -------------------------------------------------------------------

// TerrainParams

// .google.protobuf.DoubleValue ground_mu_hint = 2;
inline bool TerrainParams::_internal_has_ground_mu_hint() const {
  return this != internal_default_instance() && _impl_.ground_mu_hint_ != nullptr;
}
inline bool TerrainParams::has_ground_mu_hint() const {
  return _internal_has_ground_mu_hint();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& TerrainParams::_internal_ground_mu_hint() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.ground_mu_hint_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& TerrainParams::ground_mu_hint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.TerrainParams.ground_mu_hint)
  return _internal_ground_mu_hint();
}
inline void TerrainParams::unsafe_arena_set_allocated_ground_mu_hint(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* ground_mu_hint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ground_mu_hint_);
  }
  _impl_.ground_mu_hint_ = ground_mu_hint;
  if (ground_mu_hint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.TerrainParams.ground_mu_hint)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* TerrainParams::release_ground_mu_hint() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.ground_mu_hint_;
  _impl_.ground_mu_hint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* TerrainParams::unsafe_arena_release_ground_mu_hint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.TerrainParams.ground_mu_hint)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.ground_mu_hint_;
  _impl_.ground_mu_hint_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* TerrainParams::_internal_mutable_ground_mu_hint() {
  
  if (_impl_.ground_mu_hint_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.ground_mu_hint_ = p;
  }
  return _impl_.ground_mu_hint_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* TerrainParams::mutable_ground_mu_hint() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_ground_mu_hint();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.TerrainParams.ground_mu_hint)
  return _msg;
}
inline void TerrainParams::set_allocated_ground_mu_hint(::PROTOBUF_NAMESPACE_ID::DoubleValue* ground_mu_hint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ground_mu_hint_);
  }
  if (ground_mu_hint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ground_mu_hint));
    if (message_arena != submessage_arena) {
      ground_mu_hint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ground_mu_hint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ground_mu_hint_ = ground_mu_hint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.TerrainParams.ground_mu_hint)
}

// bool enable_grated_floor = 3 [deprecated = true];
inline void TerrainParams::clear_enable_grated_floor() {
  _impl_.enable_grated_floor_ = false;
}
inline bool TerrainParams::_internal_enable_grated_floor() const {
  return _impl_.enable_grated_floor_;
}
inline bool TerrainParams::enable_grated_floor() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.TerrainParams.enable_grated_floor)
  return _internal_enable_grated_floor();
}
inline void TerrainParams::_internal_set_enable_grated_floor(bool value) {
  
  _impl_.enable_grated_floor_ = value;
}
inline void TerrainParams::set_enable_grated_floor(bool value) {
  _internal_set_enable_grated_floor(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.TerrainParams.enable_grated_floor)
}

// .bosdyn.api.spot.TerrainParams.GratedSurfacesMode grated_surfaces_mode = 4;
inline void TerrainParams::clear_grated_surfaces_mode() {
  _impl_.grated_surfaces_mode_ = 0;
}
inline ::bosdyn::api::spot::TerrainParams_GratedSurfacesMode TerrainParams::_internal_grated_surfaces_mode() const {
  return static_cast< ::bosdyn::api::spot::TerrainParams_GratedSurfacesMode >(_impl_.grated_surfaces_mode_);
}
inline ::bosdyn::api::spot::TerrainParams_GratedSurfacesMode TerrainParams::grated_surfaces_mode() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.TerrainParams.grated_surfaces_mode)
  return _internal_grated_surfaces_mode();
}
inline void TerrainParams::_internal_set_grated_surfaces_mode(::bosdyn::api::spot::TerrainParams_GratedSurfacesMode value) {
  
  _impl_.grated_surfaces_mode_ = value;
}
inline void TerrainParams::set_grated_surfaces_mode(::bosdyn::api::spot::TerrainParams_GratedSurfacesMode value) {
  _internal_set_grated_surfaces_mode(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.TerrainParams.grated_surfaces_mode)
}

// -------------------------------------------------------------------

// BodyExternalForceParams

// .bosdyn.api.spot.BodyExternalForceParams.ExternalForceIndicator external_force_indicator = 1;
inline void BodyExternalForceParams::clear_external_force_indicator() {
  _impl_.external_force_indicator_ = 0;
}
inline ::bosdyn::api::spot::BodyExternalForceParams_ExternalForceIndicator BodyExternalForceParams::_internal_external_force_indicator() const {
  return static_cast< ::bosdyn::api::spot::BodyExternalForceParams_ExternalForceIndicator >(_impl_.external_force_indicator_);
}
inline ::bosdyn::api::spot::BodyExternalForceParams_ExternalForceIndicator BodyExternalForceParams::external_force_indicator() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.BodyExternalForceParams.external_force_indicator)
  return _internal_external_force_indicator();
}
inline void BodyExternalForceParams::_internal_set_external_force_indicator(::bosdyn::api::spot::BodyExternalForceParams_ExternalForceIndicator value) {
  
  _impl_.external_force_indicator_ = value;
}
inline void BodyExternalForceParams::set_external_force_indicator(::bosdyn::api::spot::BodyExternalForceParams_ExternalForceIndicator value) {
  _internal_set_external_force_indicator(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.BodyExternalForceParams.external_force_indicator)
}

// string frame_name = 4;
inline void BodyExternalForceParams::clear_frame_name() {
  _impl_.frame_name_.ClearToEmpty();
}
inline const std::string& BodyExternalForceParams::frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.BodyExternalForceParams.frame_name)
  return _internal_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BodyExternalForceParams::set_frame_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.BodyExternalForceParams.frame_name)
}
inline std::string* BodyExternalForceParams::mutable_frame_name() {
  std::string* _s = _internal_mutable_frame_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.BodyExternalForceParams.frame_name)
  return _s;
}
inline const std::string& BodyExternalForceParams::_internal_frame_name() const {
  return _impl_.frame_name_.Get();
}
inline void BodyExternalForceParams::_internal_set_frame_name(const std::string& value) {
  
  _impl_.frame_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BodyExternalForceParams::_internal_mutable_frame_name() {
  
  return _impl_.frame_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BodyExternalForceParams::release_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.BodyExternalForceParams.frame_name)
  return _impl_.frame_name_.Release();
}
inline void BodyExternalForceParams::set_allocated_frame_name(std::string* frame_name) {
  if (frame_name != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_.SetAllocated(frame_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_.IsDefault()) {
    _impl_.frame_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.BodyExternalForceParams.frame_name)
}

// .bosdyn.api.Vec3 external_force_override = 3;
inline bool BodyExternalForceParams::_internal_has_external_force_override() const {
  return this != internal_default_instance() && _impl_.external_force_override_ != nullptr;
}
inline bool BodyExternalForceParams::has_external_force_override() const {
  return _internal_has_external_force_override();
}
inline const ::bosdyn::api::Vec3& BodyExternalForceParams::_internal_external_force_override() const {
  const ::bosdyn::api::Vec3* p = _impl_.external_force_override_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& BodyExternalForceParams::external_force_override() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.BodyExternalForceParams.external_force_override)
  return _internal_external_force_override();
}
inline void BodyExternalForceParams::unsafe_arena_set_allocated_external_force_override(
    ::bosdyn::api::Vec3* external_force_override) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_force_override_);
  }
  _impl_.external_force_override_ = external_force_override;
  if (external_force_override) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.BodyExternalForceParams.external_force_override)
}
inline ::bosdyn::api::Vec3* BodyExternalForceParams::release_external_force_override() {
  
  ::bosdyn::api::Vec3* temp = _impl_.external_force_override_;
  _impl_.external_force_override_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* BodyExternalForceParams::unsafe_arena_release_external_force_override() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.BodyExternalForceParams.external_force_override)
  
  ::bosdyn::api::Vec3* temp = _impl_.external_force_override_;
  _impl_.external_force_override_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* BodyExternalForceParams::_internal_mutable_external_force_override() {
  
  if (_impl_.external_force_override_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.external_force_override_ = p;
  }
  return _impl_.external_force_override_;
}
inline ::bosdyn::api::Vec3* BodyExternalForceParams::mutable_external_force_override() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_external_force_override();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.BodyExternalForceParams.external_force_override)
  return _msg;
}
inline void BodyExternalForceParams::set_allocated_external_force_override(::bosdyn::api::Vec3* external_force_override) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_force_override_);
  }
  if (external_force_override) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(external_force_override));
    if (message_arena != submessage_arena) {
      external_force_override = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_force_override, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.external_force_override_ = external_force_override;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.BodyExternalForceParams.external_force_override)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace spot
}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::spot::MobilityParams_StairsMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::MobilityParams_StairsMode>() {
  return ::bosdyn::api::spot::MobilityParams_StairsMode_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::BodyControlParams_RotationSetting> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::BodyControlParams_RotationSetting>() {
  return ::bosdyn::api::spot::BodyControlParams_RotationSetting_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::TerrainParams_GratedSurfacesMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::TerrainParams_GratedSurfacesMode>() {
  return ::bosdyn::api::spot::TerrainParams_GratedSurfacesMode_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::BodyExternalForceParams_ExternalForceIndicator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::BodyExternalForceParams_ExternalForceIndicator>() {
  return ::bosdyn::api::spot::BodyExternalForceParams_ExternalForceIndicator_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::LocomotionHint> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::LocomotionHint>() {
  return ::bosdyn::api::spot::LocomotionHint_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::SwingHeight> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::SwingHeight>() {
  return ::bosdyn::api::spot::SwingHeight_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_2frobot_5fcommand_2eproto
