// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: bosdyn/api/spot/choreography_service.proto
// Original file comments:
// Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).
//
#ifndef GRPC_bosdyn_2fapi_2fspot_2fchoreography_5fservice_2eproto__INCLUDED
#define GRPC_bosdyn_2fapi_2fspot_2fchoreography_5fservice_2eproto__INCLUDED

#include "bosdyn/api/spot/choreography_service.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace bosdyn {
namespace api {
namespace spot {

class ChoreographyService final {
 public:
  static constexpr char const* service_full_name() {
    return "bosdyn.api.spot.ChoreographyService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // List the available dance moves and their parameter information.
    virtual ::grpc::Status ListAllMoves(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllMovesRequest& request, ::bosdyn::api::spot::ListAllMovesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ListAllMovesResponse>> AsyncListAllMoves(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllMovesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ListAllMovesResponse>>(AsyncListAllMovesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ListAllMovesResponse>> PrepareAsyncListAllMoves(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllMovesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ListAllMovesResponse>>(PrepareAsyncListAllMovesRaw(context, request, cq));
    }
    // List the available choreography sequences currently on the robot.
    virtual ::grpc::Status ListAllSequences(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllSequencesRequest& request, ::bosdyn::api::spot::ListAllSequencesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ListAllSequencesResponse>> AsyncListAllSequences(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllSequencesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ListAllSequencesResponse>>(AsyncListAllSequencesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ListAllSequencesResponse>> PrepareAsyncListAllSequences(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllSequencesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ListAllSequencesResponse>>(PrepareAsyncListAllSequencesRaw(context, request, cq));
    }
    // Delete a retained choreography sequence from the collection of user uploaded 
    // choreography sequences.
    virtual ::grpc::Status DeleteSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::DeleteSequenceRequest& request, ::bosdyn::api::spot::DeleteSequenceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::DeleteSequenceResponse>> AsyncDeleteSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::DeleteSequenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::DeleteSequenceResponse>>(AsyncDeleteSequenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::DeleteSequenceResponse>> PrepareAsyncDeleteSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::DeleteSequenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::DeleteSequenceResponse>>(PrepareAsyncDeleteSequenceRaw(context, request, cq));
    }
    // Save a user uploaded choreography sequence to the robots collection of 
    // retained choreography sequences.
    virtual ::grpc::Status SaveSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::SaveSequenceRequest& request, ::bosdyn::api::spot::SaveSequenceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::SaveSequenceResponse>> AsyncSaveSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::SaveSequenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::SaveSequenceResponse>>(AsyncSaveSequenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::SaveSequenceResponse>> PrepareAsyncSaveSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::SaveSequenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::SaveSequenceResponse>>(PrepareAsyncSaveSequenceRaw(context, request, cq));
    }
    // Modify the metadata of a choreography sequence.
    virtual ::grpc::Status ModifyChoreographyInfo(::grpc::ClientContext* context, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest& request, ::bosdyn::api::spot::ModifyChoreographyInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ModifyChoreographyInfoResponse>> AsyncModifyChoreographyInfo(::grpc::ClientContext* context, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ModifyChoreographyInfoResponse>>(AsyncModifyChoreographyInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ModifyChoreographyInfoResponse>> PrepareAsyncModifyChoreographyInfo(::grpc::ClientContext* context, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ModifyChoreographyInfoResponse>>(PrepareAsyncModifyChoreographyInfoRaw(context, request, cq));
    }
    // Clear all retained choreography sequence files from robot memory.
    virtual ::grpc::Status ClearAllSequenceFiles(::grpc::ClientContext* context, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest& request, ::bosdyn::api::spot::ClearAllSequenceFilesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ClearAllSequenceFilesResponse>> AsyncClearAllSequenceFiles(::grpc::ClientContext* context, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ClearAllSequenceFilesResponse>>(AsyncClearAllSequenceFilesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ClearAllSequenceFilesResponse>> PrepareAsyncClearAllSequenceFiles(::grpc::ClientContext* context, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ClearAllSequenceFilesResponse>>(PrepareAsyncClearAllSequenceFilesRaw(context, request, cq));
    }
    // Upload a dance to the robot.
    virtual ::grpc::Status UploadChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadChoreographyRequest& request, ::bosdyn::api::spot::UploadChoreographyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::UploadChoreographyResponse>> AsyncUploadChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadChoreographyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::UploadChoreographyResponse>>(AsyncUploadChoreographyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::UploadChoreographyResponse>> PrepareAsyncUploadChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadChoreographyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::UploadChoreographyResponse>>(PrepareAsyncUploadChoreographyRaw(context, request, cq));
    }
    // Upload an animation to the robot.
    virtual ::grpc::Status UploadAnimatedMove(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadAnimatedMoveRequest& request, ::bosdyn::api::spot::UploadAnimatedMoveResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::UploadAnimatedMoveResponse>> AsyncUploadAnimatedMove(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadAnimatedMoveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::UploadAnimatedMoveResponse>>(AsyncUploadAnimatedMoveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::UploadAnimatedMoveResponse>> PrepareAsyncUploadAnimatedMove(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadAnimatedMoveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::UploadAnimatedMoveResponse>>(PrepareAsyncUploadAnimatedMoveRaw(context, request, cq));
    }
    // Execute the uploaded dance.
    virtual ::grpc::Status ExecuteChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::ExecuteChoreographyRequest& request, ::bosdyn::api::spot::ExecuteChoreographyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ExecuteChoreographyResponse>> AsyncExecuteChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::ExecuteChoreographyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ExecuteChoreographyResponse>>(AsyncExecuteChoreographyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ExecuteChoreographyResponse>> PrepareAsyncExecuteChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::ExecuteChoreographyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ExecuteChoreographyResponse>>(PrepareAsyncExecuteChoreographyRaw(context, request, cq));
    }
    // Manually start (or continue) recording the robot state.
    virtual ::grpc::Status StartRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StartRecordingStateRequest& request, ::bosdyn::api::spot::StartRecordingStateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::StartRecordingStateResponse>> AsyncStartRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StartRecordingStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::StartRecordingStateResponse>>(AsyncStartRecordingStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::StartRecordingStateResponse>> PrepareAsyncStartRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StartRecordingStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::StartRecordingStateResponse>>(PrepareAsyncStartRecordingStateRaw(context, request, cq));
    }
    // Manually stop recording the robot state.
    virtual ::grpc::Status StopRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StopRecordingStateRequest& request, ::bosdyn::api::spot::StopRecordingStateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::StopRecordingStateResponse>> AsyncStopRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StopRecordingStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::StopRecordingStateResponse>>(AsyncStopRecordingStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::StopRecordingStateResponse>> PrepareAsyncStopRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StopRecordingStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::StopRecordingStateResponse>>(PrepareAsyncStopRecordingStateRaw(context, request, cq));
    }
    // Download log of the latest recorded robot state information.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::bosdyn::api::spot::DownloadRobotStateLogResponse>> DownloadRobotStateLog(::grpc::ClientContext* context, const ::bosdyn::api::spot::DownloadRobotStateLogRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::bosdyn::api::spot::DownloadRobotStateLogResponse>>(DownloadRobotStateLogRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot::DownloadRobotStateLogResponse>> AsyncDownloadRobotStateLog(::grpc::ClientContext* context, const ::bosdyn::api::spot::DownloadRobotStateLogRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot::DownloadRobotStateLogResponse>>(AsyncDownloadRobotStateLogRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot::DownloadRobotStateLogResponse>> PrepareAsyncDownloadRobotStateLog(::grpc::ClientContext* context, const ::bosdyn::api::spot::DownloadRobotStateLogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot::DownloadRobotStateLogResponse>>(PrepareAsyncDownloadRobotStateLogRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // List the available dance moves and their parameter information.
      virtual void ListAllMoves(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllMovesRequest* request, ::bosdyn::api::spot::ListAllMovesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListAllMoves(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllMovesRequest* request, ::bosdyn::api::spot::ListAllMovesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // List the available choreography sequences currently on the robot.
      virtual void ListAllSequences(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllSequencesRequest* request, ::bosdyn::api::spot::ListAllSequencesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListAllSequences(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllSequencesRequest* request, ::bosdyn::api::spot::ListAllSequencesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Delete a retained choreography sequence from the collection of user uploaded 
      // choreography sequences.
      virtual void DeleteSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::DeleteSequenceRequest* request, ::bosdyn::api::spot::DeleteSequenceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::DeleteSequenceRequest* request, ::bosdyn::api::spot::DeleteSequenceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Save a user uploaded choreography sequence to the robots collection of 
      // retained choreography sequences.
      virtual void SaveSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::SaveSequenceRequest* request, ::bosdyn::api::spot::SaveSequenceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SaveSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::SaveSequenceRequest* request, ::bosdyn::api::spot::SaveSequenceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Modify the metadata of a choreography sequence.
      virtual void ModifyChoreographyInfo(::grpc::ClientContext* context, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest* request, ::bosdyn::api::spot::ModifyChoreographyInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ModifyChoreographyInfo(::grpc::ClientContext* context, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest* request, ::bosdyn::api::spot::ModifyChoreographyInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Clear all retained choreography sequence files from robot memory.
      virtual void ClearAllSequenceFiles(::grpc::ClientContext* context, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest* request, ::bosdyn::api::spot::ClearAllSequenceFilesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ClearAllSequenceFiles(::grpc::ClientContext* context, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest* request, ::bosdyn::api::spot::ClearAllSequenceFilesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Upload a dance to the robot.
      virtual void UploadChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadChoreographyRequest* request, ::bosdyn::api::spot::UploadChoreographyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UploadChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadChoreographyRequest* request, ::bosdyn::api::spot::UploadChoreographyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Upload an animation to the robot.
      virtual void UploadAnimatedMove(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadAnimatedMoveRequest* request, ::bosdyn::api::spot::UploadAnimatedMoveResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UploadAnimatedMove(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadAnimatedMoveRequest* request, ::bosdyn::api::spot::UploadAnimatedMoveResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Execute the uploaded dance.
      virtual void ExecuteChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::ExecuteChoreographyRequest* request, ::bosdyn::api::spot::ExecuteChoreographyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ExecuteChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::ExecuteChoreographyRequest* request, ::bosdyn::api::spot::ExecuteChoreographyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Manually start (or continue) recording the robot state.
      virtual void StartRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StartRecordingStateRequest* request, ::bosdyn::api::spot::StartRecordingStateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StartRecordingStateRequest* request, ::bosdyn::api::spot::StartRecordingStateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Manually stop recording the robot state.
      virtual void StopRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StopRecordingStateRequest* request, ::bosdyn::api::spot::StopRecordingStateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StopRecordingStateRequest* request, ::bosdyn::api::spot::StopRecordingStateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Download log of the latest recorded robot state information.
      virtual void DownloadRobotStateLog(::grpc::ClientContext* context, const ::bosdyn::api::spot::DownloadRobotStateLogRequest* request, ::grpc::ClientReadReactor< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ListAllMovesResponse>* AsyncListAllMovesRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllMovesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ListAllMovesResponse>* PrepareAsyncListAllMovesRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllMovesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ListAllSequencesResponse>* AsyncListAllSequencesRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllSequencesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ListAllSequencesResponse>* PrepareAsyncListAllSequencesRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllSequencesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::DeleteSequenceResponse>* AsyncDeleteSequenceRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::DeleteSequenceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::DeleteSequenceResponse>* PrepareAsyncDeleteSequenceRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::DeleteSequenceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::SaveSequenceResponse>* AsyncSaveSequenceRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::SaveSequenceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::SaveSequenceResponse>* PrepareAsyncSaveSequenceRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::SaveSequenceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ModifyChoreographyInfoResponse>* AsyncModifyChoreographyInfoRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ModifyChoreographyInfoResponse>* PrepareAsyncModifyChoreographyInfoRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ClearAllSequenceFilesResponse>* AsyncClearAllSequenceFilesRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ClearAllSequenceFilesResponse>* PrepareAsyncClearAllSequenceFilesRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::UploadChoreographyResponse>* AsyncUploadChoreographyRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadChoreographyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::UploadChoreographyResponse>* PrepareAsyncUploadChoreographyRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadChoreographyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::UploadAnimatedMoveResponse>* AsyncUploadAnimatedMoveRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadAnimatedMoveRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::UploadAnimatedMoveResponse>* PrepareAsyncUploadAnimatedMoveRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadAnimatedMoveRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ExecuteChoreographyResponse>* AsyncExecuteChoreographyRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ExecuteChoreographyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::ExecuteChoreographyResponse>* PrepareAsyncExecuteChoreographyRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ExecuteChoreographyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::StartRecordingStateResponse>* AsyncStartRecordingStateRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::StartRecordingStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::StartRecordingStateResponse>* PrepareAsyncStartRecordingStateRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::StartRecordingStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::StopRecordingStateResponse>* AsyncStopRecordingStateRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::StopRecordingStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot::StopRecordingStateResponse>* PrepareAsyncStopRecordingStateRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::StopRecordingStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* DownloadRobotStateLogRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::DownloadRobotStateLogRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* AsyncDownloadRobotStateLogRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::DownloadRobotStateLogRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* PrepareAsyncDownloadRobotStateLogRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::DownloadRobotStateLogRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status ListAllMoves(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllMovesRequest& request, ::bosdyn::api::spot::ListAllMovesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ListAllMovesResponse>> AsyncListAllMoves(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllMovesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ListAllMovesResponse>>(AsyncListAllMovesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ListAllMovesResponse>> PrepareAsyncListAllMoves(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllMovesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ListAllMovesResponse>>(PrepareAsyncListAllMovesRaw(context, request, cq));
    }
    ::grpc::Status ListAllSequences(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllSequencesRequest& request, ::bosdyn::api::spot::ListAllSequencesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ListAllSequencesResponse>> AsyncListAllSequences(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllSequencesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ListAllSequencesResponse>>(AsyncListAllSequencesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ListAllSequencesResponse>> PrepareAsyncListAllSequences(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllSequencesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ListAllSequencesResponse>>(PrepareAsyncListAllSequencesRaw(context, request, cq));
    }
    ::grpc::Status DeleteSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::DeleteSequenceRequest& request, ::bosdyn::api::spot::DeleteSequenceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::DeleteSequenceResponse>> AsyncDeleteSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::DeleteSequenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::DeleteSequenceResponse>>(AsyncDeleteSequenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::DeleteSequenceResponse>> PrepareAsyncDeleteSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::DeleteSequenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::DeleteSequenceResponse>>(PrepareAsyncDeleteSequenceRaw(context, request, cq));
    }
    ::grpc::Status SaveSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::SaveSequenceRequest& request, ::bosdyn::api::spot::SaveSequenceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::SaveSequenceResponse>> AsyncSaveSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::SaveSequenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::SaveSequenceResponse>>(AsyncSaveSequenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::SaveSequenceResponse>> PrepareAsyncSaveSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::SaveSequenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::SaveSequenceResponse>>(PrepareAsyncSaveSequenceRaw(context, request, cq));
    }
    ::grpc::Status ModifyChoreographyInfo(::grpc::ClientContext* context, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest& request, ::bosdyn::api::spot::ModifyChoreographyInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ModifyChoreographyInfoResponse>> AsyncModifyChoreographyInfo(::grpc::ClientContext* context, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ModifyChoreographyInfoResponse>>(AsyncModifyChoreographyInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ModifyChoreographyInfoResponse>> PrepareAsyncModifyChoreographyInfo(::grpc::ClientContext* context, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ModifyChoreographyInfoResponse>>(PrepareAsyncModifyChoreographyInfoRaw(context, request, cq));
    }
    ::grpc::Status ClearAllSequenceFiles(::grpc::ClientContext* context, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest& request, ::bosdyn::api::spot::ClearAllSequenceFilesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ClearAllSequenceFilesResponse>> AsyncClearAllSequenceFiles(::grpc::ClientContext* context, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ClearAllSequenceFilesResponse>>(AsyncClearAllSequenceFilesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ClearAllSequenceFilesResponse>> PrepareAsyncClearAllSequenceFiles(::grpc::ClientContext* context, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ClearAllSequenceFilesResponse>>(PrepareAsyncClearAllSequenceFilesRaw(context, request, cq));
    }
    ::grpc::Status UploadChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadChoreographyRequest& request, ::bosdyn::api::spot::UploadChoreographyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::UploadChoreographyResponse>> AsyncUploadChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadChoreographyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::UploadChoreographyResponse>>(AsyncUploadChoreographyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::UploadChoreographyResponse>> PrepareAsyncUploadChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadChoreographyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::UploadChoreographyResponse>>(PrepareAsyncUploadChoreographyRaw(context, request, cq));
    }
    ::grpc::Status UploadAnimatedMove(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadAnimatedMoveRequest& request, ::bosdyn::api::spot::UploadAnimatedMoveResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::UploadAnimatedMoveResponse>> AsyncUploadAnimatedMove(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadAnimatedMoveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::UploadAnimatedMoveResponse>>(AsyncUploadAnimatedMoveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::UploadAnimatedMoveResponse>> PrepareAsyncUploadAnimatedMove(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadAnimatedMoveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::UploadAnimatedMoveResponse>>(PrepareAsyncUploadAnimatedMoveRaw(context, request, cq));
    }
    ::grpc::Status ExecuteChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::ExecuteChoreographyRequest& request, ::bosdyn::api::spot::ExecuteChoreographyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ExecuteChoreographyResponse>> AsyncExecuteChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::ExecuteChoreographyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ExecuteChoreographyResponse>>(AsyncExecuteChoreographyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ExecuteChoreographyResponse>> PrepareAsyncExecuteChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::ExecuteChoreographyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ExecuteChoreographyResponse>>(PrepareAsyncExecuteChoreographyRaw(context, request, cq));
    }
    ::grpc::Status StartRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StartRecordingStateRequest& request, ::bosdyn::api::spot::StartRecordingStateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::StartRecordingStateResponse>> AsyncStartRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StartRecordingStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::StartRecordingStateResponse>>(AsyncStartRecordingStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::StartRecordingStateResponse>> PrepareAsyncStartRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StartRecordingStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::StartRecordingStateResponse>>(PrepareAsyncStartRecordingStateRaw(context, request, cq));
    }
    ::grpc::Status StopRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StopRecordingStateRequest& request, ::bosdyn::api::spot::StopRecordingStateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::StopRecordingStateResponse>> AsyncStopRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StopRecordingStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::StopRecordingStateResponse>>(AsyncStopRecordingStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::StopRecordingStateResponse>> PrepareAsyncStopRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StopRecordingStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::StopRecordingStateResponse>>(PrepareAsyncStopRecordingStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::bosdyn::api::spot::DownloadRobotStateLogResponse>> DownloadRobotStateLog(::grpc::ClientContext* context, const ::bosdyn::api::spot::DownloadRobotStateLogRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::bosdyn::api::spot::DownloadRobotStateLogResponse>>(DownloadRobotStateLogRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::bosdyn::api::spot::DownloadRobotStateLogResponse>> AsyncDownloadRobotStateLog(::grpc::ClientContext* context, const ::bosdyn::api::spot::DownloadRobotStateLogRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::bosdyn::api::spot::DownloadRobotStateLogResponse>>(AsyncDownloadRobotStateLogRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::bosdyn::api::spot::DownloadRobotStateLogResponse>> PrepareAsyncDownloadRobotStateLog(::grpc::ClientContext* context, const ::bosdyn::api::spot::DownloadRobotStateLogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::bosdyn::api::spot::DownloadRobotStateLogResponse>>(PrepareAsyncDownloadRobotStateLogRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void ListAllMoves(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllMovesRequest* request, ::bosdyn::api::spot::ListAllMovesResponse* response, std::function<void(::grpc::Status)>) override;
      void ListAllMoves(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllMovesRequest* request, ::bosdyn::api::spot::ListAllMovesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListAllSequences(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllSequencesRequest* request, ::bosdyn::api::spot::ListAllSequencesResponse* response, std::function<void(::grpc::Status)>) override;
      void ListAllSequences(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllSequencesRequest* request, ::bosdyn::api::spot::ListAllSequencesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeleteSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::DeleteSequenceRequest* request, ::bosdyn::api::spot::DeleteSequenceResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::DeleteSequenceRequest* request, ::bosdyn::api::spot::DeleteSequenceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SaveSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::SaveSequenceRequest* request, ::bosdyn::api::spot::SaveSequenceResponse* response, std::function<void(::grpc::Status)>) override;
      void SaveSequence(::grpc::ClientContext* context, const ::bosdyn::api::spot::SaveSequenceRequest* request, ::bosdyn::api::spot::SaveSequenceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ModifyChoreographyInfo(::grpc::ClientContext* context, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest* request, ::bosdyn::api::spot::ModifyChoreographyInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void ModifyChoreographyInfo(::grpc::ClientContext* context, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest* request, ::bosdyn::api::spot::ModifyChoreographyInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ClearAllSequenceFiles(::grpc::ClientContext* context, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest* request, ::bosdyn::api::spot::ClearAllSequenceFilesResponse* response, std::function<void(::grpc::Status)>) override;
      void ClearAllSequenceFiles(::grpc::ClientContext* context, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest* request, ::bosdyn::api::spot::ClearAllSequenceFilesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UploadChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadChoreographyRequest* request, ::bosdyn::api::spot::UploadChoreographyResponse* response, std::function<void(::grpc::Status)>) override;
      void UploadChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadChoreographyRequest* request, ::bosdyn::api::spot::UploadChoreographyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UploadAnimatedMove(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadAnimatedMoveRequest* request, ::bosdyn::api::spot::UploadAnimatedMoveResponse* response, std::function<void(::grpc::Status)>) override;
      void UploadAnimatedMove(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadAnimatedMoveRequest* request, ::bosdyn::api::spot::UploadAnimatedMoveResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ExecuteChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::ExecuteChoreographyRequest* request, ::bosdyn::api::spot::ExecuteChoreographyResponse* response, std::function<void(::grpc::Status)>) override;
      void ExecuteChoreography(::grpc::ClientContext* context, const ::bosdyn::api::spot::ExecuteChoreographyRequest* request, ::bosdyn::api::spot::ExecuteChoreographyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StartRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StartRecordingStateRequest* request, ::bosdyn::api::spot::StartRecordingStateResponse* response, std::function<void(::grpc::Status)>) override;
      void StartRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StartRecordingStateRequest* request, ::bosdyn::api::spot::StartRecordingStateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StopRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StopRecordingStateRequest* request, ::bosdyn::api::spot::StopRecordingStateResponse* response, std::function<void(::grpc::Status)>) override;
      void StopRecordingState(::grpc::ClientContext* context, const ::bosdyn::api::spot::StopRecordingStateRequest* request, ::bosdyn::api::spot::StopRecordingStateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DownloadRobotStateLog(::grpc::ClientContext* context, const ::bosdyn::api::spot::DownloadRobotStateLogRequest* request, ::grpc::ClientReadReactor< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ListAllMovesResponse>* AsyncListAllMovesRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllMovesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ListAllMovesResponse>* PrepareAsyncListAllMovesRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllMovesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ListAllSequencesResponse>* AsyncListAllSequencesRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllSequencesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ListAllSequencesResponse>* PrepareAsyncListAllSequencesRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ListAllSequencesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::DeleteSequenceResponse>* AsyncDeleteSequenceRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::DeleteSequenceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::DeleteSequenceResponse>* PrepareAsyncDeleteSequenceRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::DeleteSequenceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::SaveSequenceResponse>* AsyncSaveSequenceRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::SaveSequenceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::SaveSequenceResponse>* PrepareAsyncSaveSequenceRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::SaveSequenceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ModifyChoreographyInfoResponse>* AsyncModifyChoreographyInfoRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ModifyChoreographyInfoResponse>* PrepareAsyncModifyChoreographyInfoRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ClearAllSequenceFilesResponse>* AsyncClearAllSequenceFilesRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ClearAllSequenceFilesResponse>* PrepareAsyncClearAllSequenceFilesRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::UploadChoreographyResponse>* AsyncUploadChoreographyRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadChoreographyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::UploadChoreographyResponse>* PrepareAsyncUploadChoreographyRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadChoreographyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::UploadAnimatedMoveResponse>* AsyncUploadAnimatedMoveRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadAnimatedMoveRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::UploadAnimatedMoveResponse>* PrepareAsyncUploadAnimatedMoveRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::UploadAnimatedMoveRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ExecuteChoreographyResponse>* AsyncExecuteChoreographyRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ExecuteChoreographyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::ExecuteChoreographyResponse>* PrepareAsyncExecuteChoreographyRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::ExecuteChoreographyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::StartRecordingStateResponse>* AsyncStartRecordingStateRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::StartRecordingStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::StartRecordingStateResponse>* PrepareAsyncStartRecordingStateRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::StartRecordingStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::StopRecordingStateResponse>* AsyncStopRecordingStateRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::StopRecordingStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot::StopRecordingStateResponse>* PrepareAsyncStopRecordingStateRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::StopRecordingStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* DownloadRobotStateLogRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::DownloadRobotStateLogRequest& request) override;
    ::grpc::ClientAsyncReader< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* AsyncDownloadRobotStateLogRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::DownloadRobotStateLogRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* PrepareAsyncDownloadRobotStateLogRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot::DownloadRobotStateLogRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ListAllMoves_;
    const ::grpc::internal::RpcMethod rpcmethod_ListAllSequences_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteSequence_;
    const ::grpc::internal::RpcMethod rpcmethod_SaveSequence_;
    const ::grpc::internal::RpcMethod rpcmethod_ModifyChoreographyInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_ClearAllSequenceFiles_;
    const ::grpc::internal::RpcMethod rpcmethod_UploadChoreography_;
    const ::grpc::internal::RpcMethod rpcmethod_UploadAnimatedMove_;
    const ::grpc::internal::RpcMethod rpcmethod_ExecuteChoreography_;
    const ::grpc::internal::RpcMethod rpcmethod_StartRecordingState_;
    const ::grpc::internal::RpcMethod rpcmethod_StopRecordingState_;
    const ::grpc::internal::RpcMethod rpcmethod_DownloadRobotStateLog_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // List the available dance moves and their parameter information.
    virtual ::grpc::Status ListAllMoves(::grpc::ServerContext* context, const ::bosdyn::api::spot::ListAllMovesRequest* request, ::bosdyn::api::spot::ListAllMovesResponse* response);
    // List the available choreography sequences currently on the robot.
    virtual ::grpc::Status ListAllSequences(::grpc::ServerContext* context, const ::bosdyn::api::spot::ListAllSequencesRequest* request, ::bosdyn::api::spot::ListAllSequencesResponse* response);
    // Delete a retained choreography sequence from the collection of user uploaded 
    // choreography sequences.
    virtual ::grpc::Status DeleteSequence(::grpc::ServerContext* context, const ::bosdyn::api::spot::DeleteSequenceRequest* request, ::bosdyn::api::spot::DeleteSequenceResponse* response);
    // Save a user uploaded choreography sequence to the robots collection of 
    // retained choreography sequences.
    virtual ::grpc::Status SaveSequence(::grpc::ServerContext* context, const ::bosdyn::api::spot::SaveSequenceRequest* request, ::bosdyn::api::spot::SaveSequenceResponse* response);
    // Modify the metadata of a choreography sequence.
    virtual ::grpc::Status ModifyChoreographyInfo(::grpc::ServerContext* context, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest* request, ::bosdyn::api::spot::ModifyChoreographyInfoResponse* response);
    // Clear all retained choreography sequence files from robot memory.
    virtual ::grpc::Status ClearAllSequenceFiles(::grpc::ServerContext* context, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest* request, ::bosdyn::api::spot::ClearAllSequenceFilesResponse* response);
    // Upload a dance to the robot.
    virtual ::grpc::Status UploadChoreography(::grpc::ServerContext* context, const ::bosdyn::api::spot::UploadChoreographyRequest* request, ::bosdyn::api::spot::UploadChoreographyResponse* response);
    // Upload an animation to the robot.
    virtual ::grpc::Status UploadAnimatedMove(::grpc::ServerContext* context, const ::bosdyn::api::spot::UploadAnimatedMoveRequest* request, ::bosdyn::api::spot::UploadAnimatedMoveResponse* response);
    // Execute the uploaded dance.
    virtual ::grpc::Status ExecuteChoreography(::grpc::ServerContext* context, const ::bosdyn::api::spot::ExecuteChoreographyRequest* request, ::bosdyn::api::spot::ExecuteChoreographyResponse* response);
    // Manually start (or continue) recording the robot state.
    virtual ::grpc::Status StartRecordingState(::grpc::ServerContext* context, const ::bosdyn::api::spot::StartRecordingStateRequest* request, ::bosdyn::api::spot::StartRecordingStateResponse* response);
    // Manually stop recording the robot state.
    virtual ::grpc::Status StopRecordingState(::grpc::ServerContext* context, const ::bosdyn::api::spot::StopRecordingStateRequest* request, ::bosdyn::api::spot::StopRecordingStateResponse* response);
    // Download log of the latest recorded robot state information.
    virtual ::grpc::Status DownloadRobotStateLog(::grpc::ServerContext* context, const ::bosdyn::api::spot::DownloadRobotStateLogRequest* request, ::grpc::ServerWriter< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_ListAllMoves : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListAllMoves() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ListAllMoves() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAllMoves(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ListAllMovesRequest* /*request*/, ::bosdyn::api::spot::ListAllMovesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListAllMoves(::grpc::ServerContext* context, ::bosdyn::api::spot::ListAllMovesRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot::ListAllMovesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListAllSequences : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListAllSequences() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ListAllSequences() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAllSequences(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ListAllSequencesRequest* /*request*/, ::bosdyn::api::spot::ListAllSequencesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListAllSequences(::grpc::ServerContext* context, ::bosdyn::api::spot::ListAllSequencesRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot::ListAllSequencesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteSequence() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_DeleteSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSequence(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::DeleteSequenceRequest* /*request*/, ::bosdyn::api::spot::DeleteSequenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteSequence(::grpc::ServerContext* context, ::bosdyn::api::spot::DeleteSequenceRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot::DeleteSequenceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SaveSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SaveSequence() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SaveSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveSequence(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::SaveSequenceRequest* /*request*/, ::bosdyn::api::spot::SaveSequenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSaveSequence(::grpc::ServerContext* context, ::bosdyn::api::spot::SaveSequenceRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot::SaveSequenceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ModifyChoreographyInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ModifyChoreographyInfo() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ModifyChoreographyInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModifyChoreographyInfo(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest* /*request*/, ::bosdyn::api::spot::ModifyChoreographyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestModifyChoreographyInfo(::grpc::ServerContext* context, ::bosdyn::api::spot::ModifyChoreographyInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot::ModifyChoreographyInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ClearAllSequenceFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ClearAllSequenceFiles() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ClearAllSequenceFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearAllSequenceFiles(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest* /*request*/, ::bosdyn::api::spot::ClearAllSequenceFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearAllSequenceFiles(::grpc::ServerContext* context, ::bosdyn::api::spot::ClearAllSequenceFilesRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot::ClearAllSequenceFilesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UploadChoreography : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UploadChoreography() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_UploadChoreography() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadChoreography(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::UploadChoreographyRequest* /*request*/, ::bosdyn::api::spot::UploadChoreographyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadChoreography(::grpc::ServerContext* context, ::bosdyn::api::spot::UploadChoreographyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot::UploadChoreographyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UploadAnimatedMove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UploadAnimatedMove() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_UploadAnimatedMove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadAnimatedMove(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::UploadAnimatedMoveRequest* /*request*/, ::bosdyn::api::spot::UploadAnimatedMoveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadAnimatedMove(::grpc::ServerContext* context, ::bosdyn::api::spot::UploadAnimatedMoveRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot::UploadAnimatedMoveResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExecuteChoreography : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExecuteChoreography() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_ExecuteChoreography() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteChoreography(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ExecuteChoreographyRequest* /*request*/, ::bosdyn::api::spot::ExecuteChoreographyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteChoreography(::grpc::ServerContext* context, ::bosdyn::api::spot::ExecuteChoreographyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot::ExecuteChoreographyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartRecordingState() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_StartRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecordingState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::StartRecordingStateRequest* /*request*/, ::bosdyn::api::spot::StartRecordingStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRecordingState(::grpc::ServerContext* context, ::bosdyn::api::spot::StartRecordingStateRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot::StartRecordingStateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopRecordingState() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_StopRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecordingState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::StopRecordingStateRequest* /*request*/, ::bosdyn::api::spot::StopRecordingStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopRecordingState(::grpc::ServerContext* context, ::bosdyn::api::spot::StopRecordingStateRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot::StopRecordingStateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DownloadRobotStateLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DownloadRobotStateLog() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_DownloadRobotStateLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadRobotStateLog(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::DownloadRobotStateLogRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadRobotStateLog(::grpc::ServerContext* context, ::bosdyn::api::spot::DownloadRobotStateLogRequest* request, ::grpc::ServerAsyncWriter< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(11, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ListAllMoves<WithAsyncMethod_ListAllSequences<WithAsyncMethod_DeleteSequence<WithAsyncMethod_SaveSequence<WithAsyncMethod_ModifyChoreographyInfo<WithAsyncMethod_ClearAllSequenceFiles<WithAsyncMethod_UploadChoreography<WithAsyncMethod_UploadAnimatedMove<WithAsyncMethod_ExecuteChoreography<WithAsyncMethod_StartRecordingState<WithAsyncMethod_StopRecordingState<WithAsyncMethod_DownloadRobotStateLog<Service > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_ListAllMoves : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListAllMoves() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::ListAllMovesRequest, ::bosdyn::api::spot::ListAllMovesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bosdyn::api::spot::ListAllMovesRequest* request, ::bosdyn::api::spot::ListAllMovesResponse* response) { return this->ListAllMoves(context, request, response); }));}
    void SetMessageAllocatorFor_ListAllMoves(
        ::grpc::MessageAllocator< ::bosdyn::api::spot::ListAllMovesRequest, ::bosdyn::api::spot::ListAllMovesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::ListAllMovesRequest, ::bosdyn::api::spot::ListAllMovesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListAllMoves() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAllMoves(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ListAllMovesRequest* /*request*/, ::bosdyn::api::spot::ListAllMovesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListAllMoves(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot::ListAllMovesRequest* /*request*/, ::bosdyn::api::spot::ListAllMovesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListAllSequences : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListAllSequences() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::ListAllSequencesRequest, ::bosdyn::api::spot::ListAllSequencesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bosdyn::api::spot::ListAllSequencesRequest* request, ::bosdyn::api::spot::ListAllSequencesResponse* response) { return this->ListAllSequences(context, request, response); }));}
    void SetMessageAllocatorFor_ListAllSequences(
        ::grpc::MessageAllocator< ::bosdyn::api::spot::ListAllSequencesRequest, ::bosdyn::api::spot::ListAllSequencesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::ListAllSequencesRequest, ::bosdyn::api::spot::ListAllSequencesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListAllSequences() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAllSequences(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ListAllSequencesRequest* /*request*/, ::bosdyn::api::spot::ListAllSequencesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListAllSequences(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot::ListAllSequencesRequest* /*request*/, ::bosdyn::api::spot::ListAllSequencesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeleteSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeleteSequence() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::DeleteSequenceRequest, ::bosdyn::api::spot::DeleteSequenceResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bosdyn::api::spot::DeleteSequenceRequest* request, ::bosdyn::api::spot::DeleteSequenceResponse* response) { return this->DeleteSequence(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteSequence(
        ::grpc::MessageAllocator< ::bosdyn::api::spot::DeleteSequenceRequest, ::bosdyn::api::spot::DeleteSequenceResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::DeleteSequenceRequest, ::bosdyn::api::spot::DeleteSequenceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeleteSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSequence(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::DeleteSequenceRequest* /*request*/, ::bosdyn::api::spot::DeleteSequenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteSequence(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot::DeleteSequenceRequest* /*request*/, ::bosdyn::api::spot::DeleteSequenceResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SaveSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SaveSequence() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::SaveSequenceRequest, ::bosdyn::api::spot::SaveSequenceResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bosdyn::api::spot::SaveSequenceRequest* request, ::bosdyn::api::spot::SaveSequenceResponse* response) { return this->SaveSequence(context, request, response); }));}
    void SetMessageAllocatorFor_SaveSequence(
        ::grpc::MessageAllocator< ::bosdyn::api::spot::SaveSequenceRequest, ::bosdyn::api::spot::SaveSequenceResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::SaveSequenceRequest, ::bosdyn::api::spot::SaveSequenceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SaveSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveSequence(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::SaveSequenceRequest* /*request*/, ::bosdyn::api::spot::SaveSequenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SaveSequence(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot::SaveSequenceRequest* /*request*/, ::bosdyn::api::spot::SaveSequenceResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ModifyChoreographyInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ModifyChoreographyInfo() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::ModifyChoreographyInfoRequest, ::bosdyn::api::spot::ModifyChoreographyInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest* request, ::bosdyn::api::spot::ModifyChoreographyInfoResponse* response) { return this->ModifyChoreographyInfo(context, request, response); }));}
    void SetMessageAllocatorFor_ModifyChoreographyInfo(
        ::grpc::MessageAllocator< ::bosdyn::api::spot::ModifyChoreographyInfoRequest, ::bosdyn::api::spot::ModifyChoreographyInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::ModifyChoreographyInfoRequest, ::bosdyn::api::spot::ModifyChoreographyInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ModifyChoreographyInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModifyChoreographyInfo(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest* /*request*/, ::bosdyn::api::spot::ModifyChoreographyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ModifyChoreographyInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest* /*request*/, ::bosdyn::api::spot::ModifyChoreographyInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ClearAllSequenceFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ClearAllSequenceFiles() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::ClearAllSequenceFilesRequest, ::bosdyn::api::spot::ClearAllSequenceFilesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest* request, ::bosdyn::api::spot::ClearAllSequenceFilesResponse* response) { return this->ClearAllSequenceFiles(context, request, response); }));}
    void SetMessageAllocatorFor_ClearAllSequenceFiles(
        ::grpc::MessageAllocator< ::bosdyn::api::spot::ClearAllSequenceFilesRequest, ::bosdyn::api::spot::ClearAllSequenceFilesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::ClearAllSequenceFilesRequest, ::bosdyn::api::spot::ClearAllSequenceFilesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ClearAllSequenceFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearAllSequenceFiles(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest* /*request*/, ::bosdyn::api::spot::ClearAllSequenceFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ClearAllSequenceFiles(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest* /*request*/, ::bosdyn::api::spot::ClearAllSequenceFilesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UploadChoreography : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UploadChoreography() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::UploadChoreographyRequest, ::bosdyn::api::spot::UploadChoreographyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bosdyn::api::spot::UploadChoreographyRequest* request, ::bosdyn::api::spot::UploadChoreographyResponse* response) { return this->UploadChoreography(context, request, response); }));}
    void SetMessageAllocatorFor_UploadChoreography(
        ::grpc::MessageAllocator< ::bosdyn::api::spot::UploadChoreographyRequest, ::bosdyn::api::spot::UploadChoreographyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::UploadChoreographyRequest, ::bosdyn::api::spot::UploadChoreographyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UploadChoreography() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadChoreography(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::UploadChoreographyRequest* /*request*/, ::bosdyn::api::spot::UploadChoreographyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadChoreography(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot::UploadChoreographyRequest* /*request*/, ::bosdyn::api::spot::UploadChoreographyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UploadAnimatedMove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UploadAnimatedMove() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::UploadAnimatedMoveRequest, ::bosdyn::api::spot::UploadAnimatedMoveResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bosdyn::api::spot::UploadAnimatedMoveRequest* request, ::bosdyn::api::spot::UploadAnimatedMoveResponse* response) { return this->UploadAnimatedMove(context, request, response); }));}
    void SetMessageAllocatorFor_UploadAnimatedMove(
        ::grpc::MessageAllocator< ::bosdyn::api::spot::UploadAnimatedMoveRequest, ::bosdyn::api::spot::UploadAnimatedMoveResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::UploadAnimatedMoveRequest, ::bosdyn::api::spot::UploadAnimatedMoveResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UploadAnimatedMove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadAnimatedMove(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::UploadAnimatedMoveRequest* /*request*/, ::bosdyn::api::spot::UploadAnimatedMoveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadAnimatedMove(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot::UploadAnimatedMoveRequest* /*request*/, ::bosdyn::api::spot::UploadAnimatedMoveResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ExecuteChoreography : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ExecuteChoreography() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::ExecuteChoreographyRequest, ::bosdyn::api::spot::ExecuteChoreographyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bosdyn::api::spot::ExecuteChoreographyRequest* request, ::bosdyn::api::spot::ExecuteChoreographyResponse* response) { return this->ExecuteChoreography(context, request, response); }));}
    void SetMessageAllocatorFor_ExecuteChoreography(
        ::grpc::MessageAllocator< ::bosdyn::api::spot::ExecuteChoreographyRequest, ::bosdyn::api::spot::ExecuteChoreographyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::ExecuteChoreographyRequest, ::bosdyn::api::spot::ExecuteChoreographyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ExecuteChoreography() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteChoreography(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ExecuteChoreographyRequest* /*request*/, ::bosdyn::api::spot::ExecuteChoreographyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExecuteChoreography(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot::ExecuteChoreographyRequest* /*request*/, ::bosdyn::api::spot::ExecuteChoreographyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StartRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StartRecordingState() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::StartRecordingStateRequest, ::bosdyn::api::spot::StartRecordingStateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bosdyn::api::spot::StartRecordingStateRequest* request, ::bosdyn::api::spot::StartRecordingStateResponse* response) { return this->StartRecordingState(context, request, response); }));}
    void SetMessageAllocatorFor_StartRecordingState(
        ::grpc::MessageAllocator< ::bosdyn::api::spot::StartRecordingStateRequest, ::bosdyn::api::spot::StartRecordingStateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::StartRecordingStateRequest, ::bosdyn::api::spot::StartRecordingStateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StartRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecordingState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::StartRecordingStateRequest* /*request*/, ::bosdyn::api::spot::StartRecordingStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartRecordingState(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot::StartRecordingStateRequest* /*request*/, ::bosdyn::api::spot::StartRecordingStateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopRecordingState() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::StopRecordingStateRequest, ::bosdyn::api::spot::StopRecordingStateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bosdyn::api::spot::StopRecordingStateRequest* request, ::bosdyn::api::spot::StopRecordingStateResponse* response) { return this->StopRecordingState(context, request, response); }));}
    void SetMessageAllocatorFor_StopRecordingState(
        ::grpc::MessageAllocator< ::bosdyn::api::spot::StopRecordingStateRequest, ::bosdyn::api::spot::StopRecordingStateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot::StopRecordingStateRequest, ::bosdyn::api::spot::StopRecordingStateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecordingState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::StopRecordingStateRequest* /*request*/, ::bosdyn::api::spot::StopRecordingStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopRecordingState(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot::StopRecordingStateRequest* /*request*/, ::bosdyn::api::spot::StopRecordingStateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DownloadRobotStateLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DownloadRobotStateLog() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackServerStreamingHandler< ::bosdyn::api::spot::DownloadRobotStateLogRequest, ::bosdyn::api::spot::DownloadRobotStateLogResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bosdyn::api::spot::DownloadRobotStateLogRequest* request) { return this->DownloadRobotStateLog(context, request); }));
    }
    ~WithCallbackMethod_DownloadRobotStateLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadRobotStateLog(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::DownloadRobotStateLogRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* DownloadRobotStateLog(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot::DownloadRobotStateLogRequest* /*request*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_ListAllMoves<WithCallbackMethod_ListAllSequences<WithCallbackMethod_DeleteSequence<WithCallbackMethod_SaveSequence<WithCallbackMethod_ModifyChoreographyInfo<WithCallbackMethod_ClearAllSequenceFiles<WithCallbackMethod_UploadChoreography<WithCallbackMethod_UploadAnimatedMove<WithCallbackMethod_ExecuteChoreography<WithCallbackMethod_StartRecordingState<WithCallbackMethod_StopRecordingState<WithCallbackMethod_DownloadRobotStateLog<Service > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ListAllMoves : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListAllMoves() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ListAllMoves() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAllMoves(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ListAllMovesRequest* /*request*/, ::bosdyn::api::spot::ListAllMovesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListAllSequences : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListAllSequences() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ListAllSequences() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAllSequences(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ListAllSequencesRequest* /*request*/, ::bosdyn::api::spot::ListAllSequencesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteSequence() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_DeleteSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSequence(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::DeleteSequenceRequest* /*request*/, ::bosdyn::api::spot::DeleteSequenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SaveSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SaveSequence() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SaveSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveSequence(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::SaveSequenceRequest* /*request*/, ::bosdyn::api::spot::SaveSequenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ModifyChoreographyInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ModifyChoreographyInfo() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ModifyChoreographyInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModifyChoreographyInfo(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest* /*request*/, ::bosdyn::api::spot::ModifyChoreographyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ClearAllSequenceFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ClearAllSequenceFiles() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ClearAllSequenceFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearAllSequenceFiles(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest* /*request*/, ::bosdyn::api::spot::ClearAllSequenceFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UploadChoreography : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UploadChoreography() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_UploadChoreography() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadChoreography(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::UploadChoreographyRequest* /*request*/, ::bosdyn::api::spot::UploadChoreographyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UploadAnimatedMove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UploadAnimatedMove() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_UploadAnimatedMove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadAnimatedMove(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::UploadAnimatedMoveRequest* /*request*/, ::bosdyn::api::spot::UploadAnimatedMoveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExecuteChoreography : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExecuteChoreography() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_ExecuteChoreography() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteChoreography(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ExecuteChoreographyRequest* /*request*/, ::bosdyn::api::spot::ExecuteChoreographyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartRecordingState() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_StartRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecordingState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::StartRecordingStateRequest* /*request*/, ::bosdyn::api::spot::StartRecordingStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopRecordingState() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_StopRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecordingState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::StopRecordingStateRequest* /*request*/, ::bosdyn::api::spot::StopRecordingStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DownloadRobotStateLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DownloadRobotStateLog() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_DownloadRobotStateLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadRobotStateLog(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::DownloadRobotStateLogRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListAllMoves : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListAllMoves() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ListAllMoves() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAllMoves(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ListAllMovesRequest* /*request*/, ::bosdyn::api::spot::ListAllMovesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListAllMoves(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListAllSequences : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListAllSequences() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ListAllSequences() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAllSequences(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ListAllSequencesRequest* /*request*/, ::bosdyn::api::spot::ListAllSequencesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListAllSequences(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteSequence() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_DeleteSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSequence(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::DeleteSequenceRequest* /*request*/, ::bosdyn::api::spot::DeleteSequenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteSequence(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SaveSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SaveSequence() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_SaveSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveSequence(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::SaveSequenceRequest* /*request*/, ::bosdyn::api::spot::SaveSequenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSaveSequence(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ModifyChoreographyInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ModifyChoreographyInfo() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ModifyChoreographyInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModifyChoreographyInfo(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest* /*request*/, ::bosdyn::api::spot::ModifyChoreographyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestModifyChoreographyInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ClearAllSequenceFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ClearAllSequenceFiles() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ClearAllSequenceFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearAllSequenceFiles(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest* /*request*/, ::bosdyn::api::spot::ClearAllSequenceFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearAllSequenceFiles(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UploadChoreography : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UploadChoreography() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_UploadChoreography() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadChoreography(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::UploadChoreographyRequest* /*request*/, ::bosdyn::api::spot::UploadChoreographyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadChoreography(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UploadAnimatedMove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UploadAnimatedMove() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_UploadAnimatedMove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadAnimatedMove(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::UploadAnimatedMoveRequest* /*request*/, ::bosdyn::api::spot::UploadAnimatedMoveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadAnimatedMove(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExecuteChoreography : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExecuteChoreography() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_ExecuteChoreography() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteChoreography(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ExecuteChoreographyRequest* /*request*/, ::bosdyn::api::spot::ExecuteChoreographyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteChoreography(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartRecordingState() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_StartRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecordingState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::StartRecordingStateRequest* /*request*/, ::bosdyn::api::spot::StartRecordingStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRecordingState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopRecordingState() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_StopRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecordingState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::StopRecordingStateRequest* /*request*/, ::bosdyn::api::spot::StopRecordingStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopRecordingState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DownloadRobotStateLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DownloadRobotStateLog() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_DownloadRobotStateLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadRobotStateLog(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::DownloadRobotStateLogRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadRobotStateLog(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(11, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListAllMoves : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListAllMoves() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListAllMoves(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListAllMoves() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAllMoves(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ListAllMovesRequest* /*request*/, ::bosdyn::api::spot::ListAllMovesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListAllMoves(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListAllSequences : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListAllSequences() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListAllSequences(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListAllSequences() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAllSequences(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ListAllSequencesRequest* /*request*/, ::bosdyn::api::spot::ListAllSequencesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListAllSequences(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeleteSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeleteSequence() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteSequence(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeleteSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSequence(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::DeleteSequenceRequest* /*request*/, ::bosdyn::api::spot::DeleteSequenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteSequence(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SaveSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SaveSequence() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SaveSequence(context, request, response); }));
    }
    ~WithRawCallbackMethod_SaveSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveSequence(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::SaveSequenceRequest* /*request*/, ::bosdyn::api::spot::SaveSequenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SaveSequence(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ModifyChoreographyInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ModifyChoreographyInfo() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ModifyChoreographyInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_ModifyChoreographyInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModifyChoreographyInfo(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest* /*request*/, ::bosdyn::api::spot::ModifyChoreographyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ModifyChoreographyInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ClearAllSequenceFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ClearAllSequenceFiles() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ClearAllSequenceFiles(context, request, response); }));
    }
    ~WithRawCallbackMethod_ClearAllSequenceFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearAllSequenceFiles(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest* /*request*/, ::bosdyn::api::spot::ClearAllSequenceFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ClearAllSequenceFiles(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UploadChoreography : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UploadChoreography() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UploadChoreography(context, request, response); }));
    }
    ~WithRawCallbackMethod_UploadChoreography() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadChoreography(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::UploadChoreographyRequest* /*request*/, ::bosdyn::api::spot::UploadChoreographyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadChoreography(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UploadAnimatedMove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UploadAnimatedMove() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UploadAnimatedMove(context, request, response); }));
    }
    ~WithRawCallbackMethod_UploadAnimatedMove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadAnimatedMove(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::UploadAnimatedMoveRequest* /*request*/, ::bosdyn::api::spot::UploadAnimatedMoveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadAnimatedMove(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ExecuteChoreography : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ExecuteChoreography() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExecuteChoreography(context, request, response); }));
    }
    ~WithRawCallbackMethod_ExecuteChoreography() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteChoreography(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ExecuteChoreographyRequest* /*request*/, ::bosdyn::api::spot::ExecuteChoreographyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExecuteChoreography(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StartRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StartRecordingState() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartRecordingState(context, request, response); }));
    }
    ~WithRawCallbackMethod_StartRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecordingState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::StartRecordingStateRequest* /*request*/, ::bosdyn::api::spot::StartRecordingStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartRecordingState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopRecordingState() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopRecordingState(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecordingState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::StopRecordingStateRequest* /*request*/, ::bosdyn::api::spot::StopRecordingStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopRecordingState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DownloadRobotStateLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DownloadRobotStateLog() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->DownloadRobotStateLog(context, request); }));
    }
    ~WithRawCallbackMethod_DownloadRobotStateLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadRobotStateLog(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::DownloadRobotStateLogRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* DownloadRobotStateLog(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListAllMoves : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListAllMoves() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot::ListAllMovesRequest, ::bosdyn::api::spot::ListAllMovesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot::ListAllMovesRequest, ::bosdyn::api::spot::ListAllMovesResponse>* streamer) {
                       return this->StreamedListAllMoves(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListAllMoves() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListAllMoves(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ListAllMovesRequest* /*request*/, ::bosdyn::api::spot::ListAllMovesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListAllMoves(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot::ListAllMovesRequest,::bosdyn::api::spot::ListAllMovesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListAllSequences : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListAllSequences() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot::ListAllSequencesRequest, ::bosdyn::api::spot::ListAllSequencesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot::ListAllSequencesRequest, ::bosdyn::api::spot::ListAllSequencesResponse>* streamer) {
                       return this->StreamedListAllSequences(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListAllSequences() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListAllSequences(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ListAllSequencesRequest* /*request*/, ::bosdyn::api::spot::ListAllSequencesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListAllSequences(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot::ListAllSequencesRequest,::bosdyn::api::spot::ListAllSequencesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteSequence() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot::DeleteSequenceRequest, ::bosdyn::api::spot::DeleteSequenceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot::DeleteSequenceRequest, ::bosdyn::api::spot::DeleteSequenceResponse>* streamer) {
                       return this->StreamedDeleteSequence(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteSequence(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::DeleteSequenceRequest* /*request*/, ::bosdyn::api::spot::DeleteSequenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteSequence(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot::DeleteSequenceRequest,::bosdyn::api::spot::DeleteSequenceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SaveSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SaveSequence() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot::SaveSequenceRequest, ::bosdyn::api::spot::SaveSequenceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot::SaveSequenceRequest, ::bosdyn::api::spot::SaveSequenceResponse>* streamer) {
                       return this->StreamedSaveSequence(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SaveSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SaveSequence(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::SaveSequenceRequest* /*request*/, ::bosdyn::api::spot::SaveSequenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSaveSequence(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot::SaveSequenceRequest,::bosdyn::api::spot::SaveSequenceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ModifyChoreographyInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ModifyChoreographyInfo() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot::ModifyChoreographyInfoRequest, ::bosdyn::api::spot::ModifyChoreographyInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot::ModifyChoreographyInfoRequest, ::bosdyn::api::spot::ModifyChoreographyInfoResponse>* streamer) {
                       return this->StreamedModifyChoreographyInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ModifyChoreographyInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ModifyChoreographyInfo(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ModifyChoreographyInfoRequest* /*request*/, ::bosdyn::api::spot::ModifyChoreographyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedModifyChoreographyInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot::ModifyChoreographyInfoRequest,::bosdyn::api::spot::ModifyChoreographyInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ClearAllSequenceFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ClearAllSequenceFiles() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot::ClearAllSequenceFilesRequest, ::bosdyn::api::spot::ClearAllSequenceFilesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot::ClearAllSequenceFilesRequest, ::bosdyn::api::spot::ClearAllSequenceFilesResponse>* streamer) {
                       return this->StreamedClearAllSequenceFiles(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ClearAllSequenceFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ClearAllSequenceFiles(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ClearAllSequenceFilesRequest* /*request*/, ::bosdyn::api::spot::ClearAllSequenceFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClearAllSequenceFiles(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot::ClearAllSequenceFilesRequest,::bosdyn::api::spot::ClearAllSequenceFilesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UploadChoreography : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UploadChoreography() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot::UploadChoreographyRequest, ::bosdyn::api::spot::UploadChoreographyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot::UploadChoreographyRequest, ::bosdyn::api::spot::UploadChoreographyResponse>* streamer) {
                       return this->StreamedUploadChoreography(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UploadChoreography() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UploadChoreography(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::UploadChoreographyRequest* /*request*/, ::bosdyn::api::spot::UploadChoreographyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUploadChoreography(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot::UploadChoreographyRequest,::bosdyn::api::spot::UploadChoreographyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UploadAnimatedMove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UploadAnimatedMove() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot::UploadAnimatedMoveRequest, ::bosdyn::api::spot::UploadAnimatedMoveResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot::UploadAnimatedMoveRequest, ::bosdyn::api::spot::UploadAnimatedMoveResponse>* streamer) {
                       return this->StreamedUploadAnimatedMove(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UploadAnimatedMove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UploadAnimatedMove(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::UploadAnimatedMoveRequest* /*request*/, ::bosdyn::api::spot::UploadAnimatedMoveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUploadAnimatedMove(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot::UploadAnimatedMoveRequest,::bosdyn::api::spot::UploadAnimatedMoveResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExecuteChoreography : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExecuteChoreography() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot::ExecuteChoreographyRequest, ::bosdyn::api::spot::ExecuteChoreographyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot::ExecuteChoreographyRequest, ::bosdyn::api::spot::ExecuteChoreographyResponse>* streamer) {
                       return this->StreamedExecuteChoreography(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExecuteChoreography() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExecuteChoreography(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::ExecuteChoreographyRequest* /*request*/, ::bosdyn::api::spot::ExecuteChoreographyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecuteChoreography(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot::ExecuteChoreographyRequest,::bosdyn::api::spot::ExecuteChoreographyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartRecordingState() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot::StartRecordingStateRequest, ::bosdyn::api::spot::StartRecordingStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot::StartRecordingStateRequest, ::bosdyn::api::spot::StartRecordingStateResponse>* streamer) {
                       return this->StreamedStartRecordingState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartRecordingState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::StartRecordingStateRequest* /*request*/, ::bosdyn::api::spot::StartRecordingStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartRecordingState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot::StartRecordingStateRequest,::bosdyn::api::spot::StartRecordingStateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopRecordingState() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot::StopRecordingStateRequest, ::bosdyn::api::spot::StopRecordingStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot::StopRecordingStateRequest, ::bosdyn::api::spot::StopRecordingStateResponse>* streamer) {
                       return this->StreamedStopRecordingState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopRecordingState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::StopRecordingStateRequest* /*request*/, ::bosdyn::api::spot::StopRecordingStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopRecordingState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot::StopRecordingStateRequest,::bosdyn::api::spot::StopRecordingStateResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ListAllMoves<WithStreamedUnaryMethod_ListAllSequences<WithStreamedUnaryMethod_DeleteSequence<WithStreamedUnaryMethod_SaveSequence<WithStreamedUnaryMethod_ModifyChoreographyInfo<WithStreamedUnaryMethod_ClearAllSequenceFiles<WithStreamedUnaryMethod_UploadChoreography<WithStreamedUnaryMethod_UploadAnimatedMove<WithStreamedUnaryMethod_ExecuteChoreography<WithStreamedUnaryMethod_StartRecordingState<WithStreamedUnaryMethod_StopRecordingState<Service > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_DownloadRobotStateLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_DownloadRobotStateLog() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::bosdyn::api::spot::DownloadRobotStateLogRequest, ::bosdyn::api::spot::DownloadRobotStateLogResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::bosdyn::api::spot::DownloadRobotStateLogRequest, ::bosdyn::api::spot::DownloadRobotStateLogResponse>* streamer) {
                       return this->StreamedDownloadRobotStateLog(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_DownloadRobotStateLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DownloadRobotStateLog(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot::DownloadRobotStateLogRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot::DownloadRobotStateLogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedDownloadRobotStateLog(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::bosdyn::api::spot::DownloadRobotStateLogRequest,::bosdyn::api::spot::DownloadRobotStateLogResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_DownloadRobotStateLog<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_ListAllMoves<WithStreamedUnaryMethod_ListAllSequences<WithStreamedUnaryMethod_DeleteSequence<WithStreamedUnaryMethod_SaveSequence<WithStreamedUnaryMethod_ModifyChoreographyInfo<WithStreamedUnaryMethod_ClearAllSequenceFiles<WithStreamedUnaryMethod_UploadChoreography<WithStreamedUnaryMethod_UploadAnimatedMove<WithStreamedUnaryMethod_ExecuteChoreography<WithStreamedUnaryMethod_StartRecordingState<WithStreamedUnaryMethod_StopRecordingState<WithSplitStreamingMethod_DownloadRobotStateLog<Service > > > > > > > > > > > > StreamedService;
};

}  // namespace spot
}  // namespace api
}  // namespace bosdyn


#endif  // GRPC_bosdyn_2fapi_2fspot_2fchoreography_5fservice_2eproto__INCLUDED
