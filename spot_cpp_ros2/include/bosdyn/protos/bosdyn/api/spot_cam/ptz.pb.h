// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/spot_cam/ptz.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include "bosdyn/api/header.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
namespace bosdyn {
namespace api {
namespace spot_cam {
class GetPtzPositionRequest;
struct GetPtzPositionRequestDefaultTypeInternal;
extern GetPtzPositionRequestDefaultTypeInternal _GetPtzPositionRequest_default_instance_;
class GetPtzPositionResponse;
struct GetPtzPositionResponseDefaultTypeInternal;
extern GetPtzPositionResponseDefaultTypeInternal _GetPtzPositionResponse_default_instance_;
class GetPtzVelocityRequest;
struct GetPtzVelocityRequestDefaultTypeInternal;
extern GetPtzVelocityRequestDefaultTypeInternal _GetPtzVelocityRequest_default_instance_;
class GetPtzVelocityResponse;
struct GetPtzVelocityResponseDefaultTypeInternal;
extern GetPtzVelocityResponseDefaultTypeInternal _GetPtzVelocityResponse_default_instance_;
class InitializeLensRequest;
struct InitializeLensRequestDefaultTypeInternal;
extern InitializeLensRequestDefaultTypeInternal _InitializeLensRequest_default_instance_;
class InitializeLensResponse;
struct InitializeLensResponseDefaultTypeInternal;
extern InitializeLensResponseDefaultTypeInternal _InitializeLensResponse_default_instance_;
class ListPtzRequest;
struct ListPtzRequestDefaultTypeInternal;
extern ListPtzRequestDefaultTypeInternal _ListPtzRequest_default_instance_;
class ListPtzResponse;
struct ListPtzResponseDefaultTypeInternal;
extern ListPtzResponseDefaultTypeInternal _ListPtzResponse_default_instance_;
class PtzDescription;
struct PtzDescriptionDefaultTypeInternal;
extern PtzDescriptionDefaultTypeInternal _PtzDescription_default_instance_;
class PtzDescription_Limits;
struct PtzDescription_LimitsDefaultTypeInternal;
extern PtzDescription_LimitsDefaultTypeInternal _PtzDescription_Limits_default_instance_;
class PtzPosition;
struct PtzPositionDefaultTypeInternal;
extern PtzPositionDefaultTypeInternal _PtzPosition_default_instance_;
class PtzVelocity;
struct PtzVelocityDefaultTypeInternal;
extern PtzVelocityDefaultTypeInternal _PtzVelocity_default_instance_;
class SetPtzPositionRequest;
struct SetPtzPositionRequestDefaultTypeInternal;
extern SetPtzPositionRequestDefaultTypeInternal _SetPtzPositionRequest_default_instance_;
class SetPtzPositionResponse;
struct SetPtzPositionResponseDefaultTypeInternal;
extern SetPtzPositionResponseDefaultTypeInternal _SetPtzPositionResponse_default_instance_;
class SetPtzVelocityRequest;
struct SetPtzVelocityRequestDefaultTypeInternal;
extern SetPtzVelocityRequestDefaultTypeInternal _SetPtzVelocityRequest_default_instance_;
class SetPtzVelocityResponse;
struct SetPtzVelocityResponseDefaultTypeInternal;
extern SetPtzVelocityResponseDefaultTypeInternal _SetPtzVelocityResponse_default_instance_;
}  // namespace spot_cam
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::spot_cam::GetPtzPositionRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::GetPtzPositionRequest>(Arena*);
template<> ::bosdyn::api::spot_cam::GetPtzPositionResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::GetPtzPositionResponse>(Arena*);
template<> ::bosdyn::api::spot_cam::GetPtzVelocityRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::GetPtzVelocityRequest>(Arena*);
template<> ::bosdyn::api::spot_cam::GetPtzVelocityResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::GetPtzVelocityResponse>(Arena*);
template<> ::bosdyn::api::spot_cam::InitializeLensRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::InitializeLensRequest>(Arena*);
template<> ::bosdyn::api::spot_cam::InitializeLensResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::InitializeLensResponse>(Arena*);
template<> ::bosdyn::api::spot_cam::ListPtzRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::ListPtzRequest>(Arena*);
template<> ::bosdyn::api::spot_cam::ListPtzResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::ListPtzResponse>(Arena*);
template<> ::bosdyn::api::spot_cam::PtzDescription* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::PtzDescription>(Arena*);
template<> ::bosdyn::api::spot_cam::PtzDescription_Limits* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::PtzDescription_Limits>(Arena*);
template<> ::bosdyn::api::spot_cam::PtzPosition* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::PtzPosition>(Arena*);
template<> ::bosdyn::api::spot_cam::PtzVelocity* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::PtzVelocity>(Arena*);
template<> ::bosdyn::api::spot_cam::SetPtzPositionRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::SetPtzPositionRequest>(Arena*);
template<> ::bosdyn::api::spot_cam::SetPtzPositionResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::SetPtzPositionResponse>(Arena*);
template<> ::bosdyn::api::spot_cam::SetPtzVelocityRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::SetPtzVelocityRequest>(Arena*);
template<> ::bosdyn::api::spot_cam::SetPtzVelocityResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::SetPtzVelocityResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {
namespace spot_cam {

// ===================================================================

class PtzDescription_Limits final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.PtzDescription.Limits) */ {
 public:
  inline PtzDescription_Limits() : PtzDescription_Limits(nullptr) {}
  ~PtzDescription_Limits() override;
  explicit PROTOBUF_CONSTEXPR PtzDescription_Limits(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PtzDescription_Limits(const PtzDescription_Limits& from);
  PtzDescription_Limits(PtzDescription_Limits&& from) noexcept
    : PtzDescription_Limits() {
    *this = ::std::move(from);
  }

  inline PtzDescription_Limits& operator=(const PtzDescription_Limits& from) {
    CopyFrom(from);
    return *this;
  }
  inline PtzDescription_Limits& operator=(PtzDescription_Limits&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PtzDescription_Limits& default_instance() {
    return *internal_default_instance();
  }
  static inline const PtzDescription_Limits* internal_default_instance() {
    return reinterpret_cast<const PtzDescription_Limits*>(
               &_PtzDescription_Limits_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PtzDescription_Limits& a, PtzDescription_Limits& b) {
    a.Swap(&b);
  }
  inline void Swap(PtzDescription_Limits* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PtzDescription_Limits* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PtzDescription_Limits* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PtzDescription_Limits>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PtzDescription_Limits& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PtzDescription_Limits& from) {
    PtzDescription_Limits::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PtzDescription_Limits* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.PtzDescription.Limits";
  }
  protected:
  explicit PtzDescription_Limits(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
  };
  // .google.protobuf.FloatValue min = 1;
  bool has_min() const;
  private:
  bool _internal_has_min() const;
  public:
  void clear_min();
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& min() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_min();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_min();
  void set_allocated_min(::PROTOBUF_NAMESPACE_ID::FloatValue* min);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_min() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_min();
  public:
  void unsafe_arena_set_allocated_min(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* min);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_min();

  // .google.protobuf.FloatValue max = 2;
  bool has_max() const;
  private:
  bool _internal_has_max() const;
  public:
  void clear_max();
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& max() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_max();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_max();
  void set_allocated_max(::PROTOBUF_NAMESPACE_ID::FloatValue* max);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_max() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_max();
  public:
  void unsafe_arena_set_allocated_max(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* max);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_max();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.PtzDescription.Limits)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::FloatValue* min_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* max_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
};
// -------------------------------------------------------------------

class PtzDescription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.PtzDescription) */ {
 public:
  inline PtzDescription() : PtzDescription(nullptr) {}
  ~PtzDescription() override;
  explicit PROTOBUF_CONSTEXPR PtzDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PtzDescription(const PtzDescription& from);
  PtzDescription(PtzDescription&& from) noexcept
    : PtzDescription() {
    *this = ::std::move(from);
  }

  inline PtzDescription& operator=(const PtzDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline PtzDescription& operator=(PtzDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PtzDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const PtzDescription* internal_default_instance() {
    return reinterpret_cast<const PtzDescription*>(
               &_PtzDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PtzDescription& a, PtzDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(PtzDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PtzDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PtzDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PtzDescription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PtzDescription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PtzDescription& from) {
    PtzDescription::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PtzDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.PtzDescription";
  }
  protected:
  explicit PtzDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PtzDescription_Limits Limits;

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPanLimitFieldNumber = 2,
    kTiltLimitFieldNumber = 3,
    kZoomLimitFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .bosdyn.api.spot_cam.PtzDescription.Limits pan_limit = 2;
  bool has_pan_limit() const;
  private:
  bool _internal_has_pan_limit() const;
  public:
  void clear_pan_limit();
  const ::bosdyn::api::spot_cam::PtzDescription_Limits& pan_limit() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot_cam::PtzDescription_Limits* release_pan_limit();
  ::bosdyn::api::spot_cam::PtzDescription_Limits* mutable_pan_limit();
  void set_allocated_pan_limit(::bosdyn::api::spot_cam::PtzDescription_Limits* pan_limit);
  private:
  const ::bosdyn::api::spot_cam::PtzDescription_Limits& _internal_pan_limit() const;
  ::bosdyn::api::spot_cam::PtzDescription_Limits* _internal_mutable_pan_limit();
  public:
  void unsafe_arena_set_allocated_pan_limit(
      ::bosdyn::api::spot_cam::PtzDescription_Limits* pan_limit);
  ::bosdyn::api::spot_cam::PtzDescription_Limits* unsafe_arena_release_pan_limit();

  // .bosdyn.api.spot_cam.PtzDescription.Limits tilt_limit = 3;
  bool has_tilt_limit() const;
  private:
  bool _internal_has_tilt_limit() const;
  public:
  void clear_tilt_limit();
  const ::bosdyn::api::spot_cam::PtzDescription_Limits& tilt_limit() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot_cam::PtzDescription_Limits* release_tilt_limit();
  ::bosdyn::api::spot_cam::PtzDescription_Limits* mutable_tilt_limit();
  void set_allocated_tilt_limit(::bosdyn::api::spot_cam::PtzDescription_Limits* tilt_limit);
  private:
  const ::bosdyn::api::spot_cam::PtzDescription_Limits& _internal_tilt_limit() const;
  ::bosdyn::api::spot_cam::PtzDescription_Limits* _internal_mutable_tilt_limit();
  public:
  void unsafe_arena_set_allocated_tilt_limit(
      ::bosdyn::api::spot_cam::PtzDescription_Limits* tilt_limit);
  ::bosdyn::api::spot_cam::PtzDescription_Limits* unsafe_arena_release_tilt_limit();

  // .bosdyn.api.spot_cam.PtzDescription.Limits zoom_limit = 4;
  bool has_zoom_limit() const;
  private:
  bool _internal_has_zoom_limit() const;
  public:
  void clear_zoom_limit();
  const ::bosdyn::api::spot_cam::PtzDescription_Limits& zoom_limit() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot_cam::PtzDescription_Limits* release_zoom_limit();
  ::bosdyn::api::spot_cam::PtzDescription_Limits* mutable_zoom_limit();
  void set_allocated_zoom_limit(::bosdyn::api::spot_cam::PtzDescription_Limits* zoom_limit);
  private:
  const ::bosdyn::api::spot_cam::PtzDescription_Limits& _internal_zoom_limit() const;
  ::bosdyn::api::spot_cam::PtzDescription_Limits* _internal_mutable_zoom_limit();
  public:
  void unsafe_arena_set_allocated_zoom_limit(
      ::bosdyn::api::spot_cam::PtzDescription_Limits* zoom_limit);
  ::bosdyn::api::spot_cam::PtzDescription_Limits* unsafe_arena_release_zoom_limit();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.PtzDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::bosdyn::api::spot_cam::PtzDescription_Limits* pan_limit_;
    ::bosdyn::api::spot_cam::PtzDescription_Limits* tilt_limit_;
    ::bosdyn::api::spot_cam::PtzDescription_Limits* zoom_limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
};
// -------------------------------------------------------------------

class PtzPosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.PtzPosition) */ {
 public:
  inline PtzPosition() : PtzPosition(nullptr) {}
  ~PtzPosition() override;
  explicit PROTOBUF_CONSTEXPR PtzPosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PtzPosition(const PtzPosition& from);
  PtzPosition(PtzPosition&& from) noexcept
    : PtzPosition() {
    *this = ::std::move(from);
  }

  inline PtzPosition& operator=(const PtzPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline PtzPosition& operator=(PtzPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PtzPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const PtzPosition* internal_default_instance() {
    return reinterpret_cast<const PtzPosition*>(
               &_PtzPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PtzPosition& a, PtzPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(PtzPosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PtzPosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PtzPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PtzPosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PtzPosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PtzPosition& from) {
    PtzPosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PtzPosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.PtzPosition";
  }
  protected:
  explicit PtzPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtzFieldNumber = 2,
    kPanFieldNumber = 3,
    kTiltFieldNumber = 4,
    kZoomFieldNumber = 5,
  };
  // .bosdyn.api.spot_cam.PtzDescription ptz = 2;
  bool has_ptz() const;
  private:
  bool _internal_has_ptz() const;
  public:
  void clear_ptz();
  const ::bosdyn::api::spot_cam::PtzDescription& ptz() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot_cam::PtzDescription* release_ptz();
  ::bosdyn::api::spot_cam::PtzDescription* mutable_ptz();
  void set_allocated_ptz(::bosdyn::api::spot_cam::PtzDescription* ptz);
  private:
  const ::bosdyn::api::spot_cam::PtzDescription& _internal_ptz() const;
  ::bosdyn::api::spot_cam::PtzDescription* _internal_mutable_ptz();
  public:
  void unsafe_arena_set_allocated_ptz(
      ::bosdyn::api::spot_cam::PtzDescription* ptz);
  ::bosdyn::api::spot_cam::PtzDescription* unsafe_arena_release_ptz();

  // .google.protobuf.FloatValue pan = 3;
  bool has_pan() const;
  private:
  bool _internal_has_pan() const;
  public:
  void clear_pan();
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& pan() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_pan();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_pan();
  void set_allocated_pan(::PROTOBUF_NAMESPACE_ID::FloatValue* pan);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_pan() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_pan();
  public:
  void unsafe_arena_set_allocated_pan(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* pan);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_pan();

  // .google.protobuf.FloatValue tilt = 4;
  bool has_tilt() const;
  private:
  bool _internal_has_tilt() const;
  public:
  void clear_tilt();
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& tilt() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_tilt();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_tilt();
  void set_allocated_tilt(::PROTOBUF_NAMESPACE_ID::FloatValue* tilt);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_tilt() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_tilt();
  public:
  void unsafe_arena_set_allocated_tilt(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* tilt);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_tilt();

  // .google.protobuf.FloatValue zoom = 5;
  bool has_zoom() const;
  private:
  bool _internal_has_zoom() const;
  public:
  void clear_zoom();
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& zoom() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_zoom();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_zoom();
  void set_allocated_zoom(::PROTOBUF_NAMESPACE_ID::FloatValue* zoom);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_zoom() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_zoom();
  public:
  void unsafe_arena_set_allocated_zoom(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* zoom);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_zoom();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.PtzPosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::spot_cam::PtzDescription* ptz_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* pan_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* tilt_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* zoom_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
};
// -------------------------------------------------------------------

class PtzVelocity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.PtzVelocity) */ {
 public:
  inline PtzVelocity() : PtzVelocity(nullptr) {}
  ~PtzVelocity() override;
  explicit PROTOBUF_CONSTEXPR PtzVelocity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PtzVelocity(const PtzVelocity& from);
  PtzVelocity(PtzVelocity&& from) noexcept
    : PtzVelocity() {
    *this = ::std::move(from);
  }

  inline PtzVelocity& operator=(const PtzVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline PtzVelocity& operator=(PtzVelocity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PtzVelocity& default_instance() {
    return *internal_default_instance();
  }
  static inline const PtzVelocity* internal_default_instance() {
    return reinterpret_cast<const PtzVelocity*>(
               &_PtzVelocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PtzVelocity& a, PtzVelocity& b) {
    a.Swap(&b);
  }
  inline void Swap(PtzVelocity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PtzVelocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PtzVelocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PtzVelocity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PtzVelocity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PtzVelocity& from) {
    PtzVelocity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PtzVelocity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.PtzVelocity";
  }
  protected:
  explicit PtzVelocity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtzFieldNumber = 2,
    kPanFieldNumber = 3,
    kTiltFieldNumber = 4,
    kZoomFieldNumber = 5,
  };
  // .bosdyn.api.spot_cam.PtzDescription ptz = 2;
  bool has_ptz() const;
  private:
  bool _internal_has_ptz() const;
  public:
  void clear_ptz();
  const ::bosdyn::api::spot_cam::PtzDescription& ptz() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot_cam::PtzDescription* release_ptz();
  ::bosdyn::api::spot_cam::PtzDescription* mutable_ptz();
  void set_allocated_ptz(::bosdyn::api::spot_cam::PtzDescription* ptz);
  private:
  const ::bosdyn::api::spot_cam::PtzDescription& _internal_ptz() const;
  ::bosdyn::api::spot_cam::PtzDescription* _internal_mutable_ptz();
  public:
  void unsafe_arena_set_allocated_ptz(
      ::bosdyn::api::spot_cam::PtzDescription* ptz);
  ::bosdyn::api::spot_cam::PtzDescription* unsafe_arena_release_ptz();

  // .google.protobuf.FloatValue pan = 3;
  bool has_pan() const;
  private:
  bool _internal_has_pan() const;
  public:
  void clear_pan();
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& pan() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_pan();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_pan();
  void set_allocated_pan(::PROTOBUF_NAMESPACE_ID::FloatValue* pan);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_pan() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_pan();
  public:
  void unsafe_arena_set_allocated_pan(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* pan);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_pan();

  // .google.protobuf.FloatValue tilt = 4;
  bool has_tilt() const;
  private:
  bool _internal_has_tilt() const;
  public:
  void clear_tilt();
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& tilt() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_tilt();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_tilt();
  void set_allocated_tilt(::PROTOBUF_NAMESPACE_ID::FloatValue* tilt);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_tilt() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_tilt();
  public:
  void unsafe_arena_set_allocated_tilt(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* tilt);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_tilt();

  // .google.protobuf.FloatValue zoom = 5;
  bool has_zoom() const;
  private:
  bool _internal_has_zoom() const;
  public:
  void clear_zoom();
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& zoom() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_zoom();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_zoom();
  void set_allocated_zoom(::PROTOBUF_NAMESPACE_ID::FloatValue* zoom);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_zoom() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_zoom();
  public:
  void unsafe_arena_set_allocated_zoom(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* zoom);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_zoom();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.PtzVelocity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::spot_cam::PtzDescription* ptz_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* pan_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* tilt_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* zoom_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
};
// -------------------------------------------------------------------

class GetPtzPositionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.GetPtzPositionRequest) */ {
 public:
  inline GetPtzPositionRequest() : GetPtzPositionRequest(nullptr) {}
  ~GetPtzPositionRequest() override;
  explicit PROTOBUF_CONSTEXPR GetPtzPositionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPtzPositionRequest(const GetPtzPositionRequest& from);
  GetPtzPositionRequest(GetPtzPositionRequest&& from) noexcept
    : GetPtzPositionRequest() {
    *this = ::std::move(from);
  }

  inline GetPtzPositionRequest& operator=(const GetPtzPositionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPtzPositionRequest& operator=(GetPtzPositionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPtzPositionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPtzPositionRequest* internal_default_instance() {
    return reinterpret_cast<const GetPtzPositionRequest*>(
               &_GetPtzPositionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetPtzPositionRequest& a, GetPtzPositionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPtzPositionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPtzPositionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPtzPositionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPtzPositionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPtzPositionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPtzPositionRequest& from) {
    GetPtzPositionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPtzPositionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.GetPtzPositionRequest";
  }
  protected:
  explicit GetPtzPositionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPtzFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.PtzDescription ptz = 2;
  bool has_ptz() const;
  private:
  bool _internal_has_ptz() const;
  public:
  void clear_ptz();
  const ::bosdyn::api::spot_cam::PtzDescription& ptz() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot_cam::PtzDescription* release_ptz();
  ::bosdyn::api::spot_cam::PtzDescription* mutable_ptz();
  void set_allocated_ptz(::bosdyn::api::spot_cam::PtzDescription* ptz);
  private:
  const ::bosdyn::api::spot_cam::PtzDescription& _internal_ptz() const;
  ::bosdyn::api::spot_cam::PtzDescription* _internal_mutable_ptz();
  public:
  void unsafe_arena_set_allocated_ptz(
      ::bosdyn::api::spot_cam::PtzDescription* ptz);
  ::bosdyn::api::spot_cam::PtzDescription* unsafe_arena_release_ptz();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.GetPtzPositionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::spot_cam::PtzDescription* ptz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
};
// -------------------------------------------------------------------

class GetPtzPositionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.GetPtzPositionResponse) */ {
 public:
  inline GetPtzPositionResponse() : GetPtzPositionResponse(nullptr) {}
  ~GetPtzPositionResponse() override;
  explicit PROTOBUF_CONSTEXPR GetPtzPositionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPtzPositionResponse(const GetPtzPositionResponse& from);
  GetPtzPositionResponse(GetPtzPositionResponse&& from) noexcept
    : GetPtzPositionResponse() {
    *this = ::std::move(from);
  }

  inline GetPtzPositionResponse& operator=(const GetPtzPositionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPtzPositionResponse& operator=(GetPtzPositionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPtzPositionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPtzPositionResponse* internal_default_instance() {
    return reinterpret_cast<const GetPtzPositionResponse*>(
               &_GetPtzPositionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetPtzPositionResponse& a, GetPtzPositionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPtzPositionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPtzPositionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPtzPositionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPtzPositionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPtzPositionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPtzPositionResponse& from) {
    GetPtzPositionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPtzPositionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.GetPtzPositionResponse";
  }
  protected:
  explicit GetPtzPositionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPositionFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.PtzPosition position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::bosdyn::api::spot_cam::PtzPosition& position() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot_cam::PtzPosition* release_position();
  ::bosdyn::api::spot_cam::PtzPosition* mutable_position();
  void set_allocated_position(::bosdyn::api::spot_cam::PtzPosition* position);
  private:
  const ::bosdyn::api::spot_cam::PtzPosition& _internal_position() const;
  ::bosdyn::api::spot_cam::PtzPosition* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::bosdyn::api::spot_cam::PtzPosition* position);
  ::bosdyn::api::spot_cam::PtzPosition* unsafe_arena_release_position();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.GetPtzPositionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::spot_cam::PtzPosition* position_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
};
// -------------------------------------------------------------------

class GetPtzVelocityRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.GetPtzVelocityRequest) */ {
 public:
  inline GetPtzVelocityRequest() : GetPtzVelocityRequest(nullptr) {}
  ~GetPtzVelocityRequest() override;
  explicit PROTOBUF_CONSTEXPR GetPtzVelocityRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPtzVelocityRequest(const GetPtzVelocityRequest& from);
  GetPtzVelocityRequest(GetPtzVelocityRequest&& from) noexcept
    : GetPtzVelocityRequest() {
    *this = ::std::move(from);
  }

  inline GetPtzVelocityRequest& operator=(const GetPtzVelocityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPtzVelocityRequest& operator=(GetPtzVelocityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPtzVelocityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPtzVelocityRequest* internal_default_instance() {
    return reinterpret_cast<const GetPtzVelocityRequest*>(
               &_GetPtzVelocityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetPtzVelocityRequest& a, GetPtzVelocityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPtzVelocityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPtzVelocityRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPtzVelocityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPtzVelocityRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPtzVelocityRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPtzVelocityRequest& from) {
    GetPtzVelocityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPtzVelocityRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.GetPtzVelocityRequest";
  }
  protected:
  explicit GetPtzVelocityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPtzFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.PtzDescription ptz = 2;
  bool has_ptz() const;
  private:
  bool _internal_has_ptz() const;
  public:
  void clear_ptz();
  const ::bosdyn::api::spot_cam::PtzDescription& ptz() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot_cam::PtzDescription* release_ptz();
  ::bosdyn::api::spot_cam::PtzDescription* mutable_ptz();
  void set_allocated_ptz(::bosdyn::api::spot_cam::PtzDescription* ptz);
  private:
  const ::bosdyn::api::spot_cam::PtzDescription& _internal_ptz() const;
  ::bosdyn::api::spot_cam::PtzDescription* _internal_mutable_ptz();
  public:
  void unsafe_arena_set_allocated_ptz(
      ::bosdyn::api::spot_cam::PtzDescription* ptz);
  ::bosdyn::api::spot_cam::PtzDescription* unsafe_arena_release_ptz();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.GetPtzVelocityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::spot_cam::PtzDescription* ptz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
};
// -------------------------------------------------------------------

class GetPtzVelocityResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.GetPtzVelocityResponse) */ {
 public:
  inline GetPtzVelocityResponse() : GetPtzVelocityResponse(nullptr) {}
  ~GetPtzVelocityResponse() override;
  explicit PROTOBUF_CONSTEXPR GetPtzVelocityResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPtzVelocityResponse(const GetPtzVelocityResponse& from);
  GetPtzVelocityResponse(GetPtzVelocityResponse&& from) noexcept
    : GetPtzVelocityResponse() {
    *this = ::std::move(from);
  }

  inline GetPtzVelocityResponse& operator=(const GetPtzVelocityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPtzVelocityResponse& operator=(GetPtzVelocityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPtzVelocityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPtzVelocityResponse* internal_default_instance() {
    return reinterpret_cast<const GetPtzVelocityResponse*>(
               &_GetPtzVelocityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetPtzVelocityResponse& a, GetPtzVelocityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPtzVelocityResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPtzVelocityResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPtzVelocityResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPtzVelocityResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPtzVelocityResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPtzVelocityResponse& from) {
    GetPtzVelocityResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPtzVelocityResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.GetPtzVelocityResponse";
  }
  protected:
  explicit GetPtzVelocityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kVelocityFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.PtzVelocity velocity = 2;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::bosdyn::api::spot_cam::PtzVelocity& velocity() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot_cam::PtzVelocity* release_velocity();
  ::bosdyn::api::spot_cam::PtzVelocity* mutable_velocity();
  void set_allocated_velocity(::bosdyn::api::spot_cam::PtzVelocity* velocity);
  private:
  const ::bosdyn::api::spot_cam::PtzVelocity& _internal_velocity() const;
  ::bosdyn::api::spot_cam::PtzVelocity* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::bosdyn::api::spot_cam::PtzVelocity* velocity);
  ::bosdyn::api::spot_cam::PtzVelocity* unsafe_arena_release_velocity();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.GetPtzVelocityResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::spot_cam::PtzVelocity* velocity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
};
// -------------------------------------------------------------------

class ListPtzRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.ListPtzRequest) */ {
 public:
  inline ListPtzRequest() : ListPtzRequest(nullptr) {}
  ~ListPtzRequest() override;
  explicit PROTOBUF_CONSTEXPR ListPtzRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPtzRequest(const ListPtzRequest& from);
  ListPtzRequest(ListPtzRequest&& from) noexcept
    : ListPtzRequest() {
    *this = ::std::move(from);
  }

  inline ListPtzRequest& operator=(const ListPtzRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPtzRequest& operator=(ListPtzRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPtzRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPtzRequest* internal_default_instance() {
    return reinterpret_cast<const ListPtzRequest*>(
               &_ListPtzRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ListPtzRequest& a, ListPtzRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPtzRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPtzRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPtzRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPtzRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPtzRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListPtzRequest& from) {
    ListPtzRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPtzRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.ListPtzRequest";
  }
  protected:
  explicit ListPtzRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.ListPtzRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
};
// -------------------------------------------------------------------

class ListPtzResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.ListPtzResponse) */ {
 public:
  inline ListPtzResponse() : ListPtzResponse(nullptr) {}
  ~ListPtzResponse() override;
  explicit PROTOBUF_CONSTEXPR ListPtzResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPtzResponse(const ListPtzResponse& from);
  ListPtzResponse(ListPtzResponse&& from) noexcept
    : ListPtzResponse() {
    *this = ::std::move(from);
  }

  inline ListPtzResponse& operator=(const ListPtzResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPtzResponse& operator=(ListPtzResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPtzResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPtzResponse* internal_default_instance() {
    return reinterpret_cast<const ListPtzResponse*>(
               &_ListPtzResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListPtzResponse& a, ListPtzResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPtzResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPtzResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPtzResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPtzResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPtzResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListPtzResponse& from) {
    ListPtzResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPtzResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.ListPtzResponse";
  }
  protected:
  explicit ListPtzResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtzsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.spot_cam.PtzDescription ptzs = 2;
  int ptzs_size() const;
  private:
  int _internal_ptzs_size() const;
  public:
  void clear_ptzs();
  ::bosdyn::api::spot_cam::PtzDescription* mutable_ptzs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::PtzDescription >*
      mutable_ptzs();
  private:
  const ::bosdyn::api::spot_cam::PtzDescription& _internal_ptzs(int index) const;
  ::bosdyn::api::spot_cam::PtzDescription* _internal_add_ptzs();
  public:
  const ::bosdyn::api::spot_cam::PtzDescription& ptzs(int index) const;
  ::bosdyn::api::spot_cam::PtzDescription* add_ptzs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::PtzDescription >&
      ptzs() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.ListPtzResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::PtzDescription > ptzs_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
};
// -------------------------------------------------------------------

class SetPtzPositionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.SetPtzPositionRequest) */ {
 public:
  inline SetPtzPositionRequest() : SetPtzPositionRequest(nullptr) {}
  ~SetPtzPositionRequest() override;
  explicit PROTOBUF_CONSTEXPR SetPtzPositionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPtzPositionRequest(const SetPtzPositionRequest& from);
  SetPtzPositionRequest(SetPtzPositionRequest&& from) noexcept
    : SetPtzPositionRequest() {
    *this = ::std::move(from);
  }

  inline SetPtzPositionRequest& operator=(const SetPtzPositionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPtzPositionRequest& operator=(SetPtzPositionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPtzPositionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPtzPositionRequest* internal_default_instance() {
    return reinterpret_cast<const SetPtzPositionRequest*>(
               &_SetPtzPositionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SetPtzPositionRequest& a, SetPtzPositionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPtzPositionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPtzPositionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPtzPositionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPtzPositionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPtzPositionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetPtzPositionRequest& from) {
    SetPtzPositionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPtzPositionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.SetPtzPositionRequest";
  }
  protected:
  explicit SetPtzPositionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPositionFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.PtzPosition position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::bosdyn::api::spot_cam::PtzPosition& position() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot_cam::PtzPosition* release_position();
  ::bosdyn::api::spot_cam::PtzPosition* mutable_position();
  void set_allocated_position(::bosdyn::api::spot_cam::PtzPosition* position);
  private:
  const ::bosdyn::api::spot_cam::PtzPosition& _internal_position() const;
  ::bosdyn::api::spot_cam::PtzPosition* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::bosdyn::api::spot_cam::PtzPosition* position);
  ::bosdyn::api::spot_cam::PtzPosition* unsafe_arena_release_position();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.SetPtzPositionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::spot_cam::PtzPosition* position_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
};
// -------------------------------------------------------------------

class SetPtzPositionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.SetPtzPositionResponse) */ {
 public:
  inline SetPtzPositionResponse() : SetPtzPositionResponse(nullptr) {}
  ~SetPtzPositionResponse() override;
  explicit PROTOBUF_CONSTEXPR SetPtzPositionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPtzPositionResponse(const SetPtzPositionResponse& from);
  SetPtzPositionResponse(SetPtzPositionResponse&& from) noexcept
    : SetPtzPositionResponse() {
    *this = ::std::move(from);
  }

  inline SetPtzPositionResponse& operator=(const SetPtzPositionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPtzPositionResponse& operator=(SetPtzPositionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPtzPositionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPtzPositionResponse* internal_default_instance() {
    return reinterpret_cast<const SetPtzPositionResponse*>(
               &_SetPtzPositionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SetPtzPositionResponse& a, SetPtzPositionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPtzPositionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPtzPositionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPtzPositionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPtzPositionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPtzPositionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetPtzPositionResponse& from) {
    SetPtzPositionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPtzPositionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.SetPtzPositionResponse";
  }
  protected:
  explicit SetPtzPositionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPositionFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.PtzPosition position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::bosdyn::api::spot_cam::PtzPosition& position() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot_cam::PtzPosition* release_position();
  ::bosdyn::api::spot_cam::PtzPosition* mutable_position();
  void set_allocated_position(::bosdyn::api::spot_cam::PtzPosition* position);
  private:
  const ::bosdyn::api::spot_cam::PtzPosition& _internal_position() const;
  ::bosdyn::api::spot_cam::PtzPosition* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::bosdyn::api::spot_cam::PtzPosition* position);
  ::bosdyn::api::spot_cam::PtzPosition* unsafe_arena_release_position();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.SetPtzPositionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::spot_cam::PtzPosition* position_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
};
// -------------------------------------------------------------------

class SetPtzVelocityRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.SetPtzVelocityRequest) */ {
 public:
  inline SetPtzVelocityRequest() : SetPtzVelocityRequest(nullptr) {}
  ~SetPtzVelocityRequest() override;
  explicit PROTOBUF_CONSTEXPR SetPtzVelocityRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPtzVelocityRequest(const SetPtzVelocityRequest& from);
  SetPtzVelocityRequest(SetPtzVelocityRequest&& from) noexcept
    : SetPtzVelocityRequest() {
    *this = ::std::move(from);
  }

  inline SetPtzVelocityRequest& operator=(const SetPtzVelocityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPtzVelocityRequest& operator=(SetPtzVelocityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPtzVelocityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPtzVelocityRequest* internal_default_instance() {
    return reinterpret_cast<const SetPtzVelocityRequest*>(
               &_SetPtzVelocityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SetPtzVelocityRequest& a, SetPtzVelocityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPtzVelocityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPtzVelocityRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPtzVelocityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPtzVelocityRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPtzVelocityRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetPtzVelocityRequest& from) {
    SetPtzVelocityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPtzVelocityRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.SetPtzVelocityRequest";
  }
  protected:
  explicit SetPtzVelocityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kVelocityFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.PtzVelocity velocity = 2;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::bosdyn::api::spot_cam::PtzVelocity& velocity() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot_cam::PtzVelocity* release_velocity();
  ::bosdyn::api::spot_cam::PtzVelocity* mutable_velocity();
  void set_allocated_velocity(::bosdyn::api::spot_cam::PtzVelocity* velocity);
  private:
  const ::bosdyn::api::spot_cam::PtzVelocity& _internal_velocity() const;
  ::bosdyn::api::spot_cam::PtzVelocity* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::bosdyn::api::spot_cam::PtzVelocity* velocity);
  ::bosdyn::api::spot_cam::PtzVelocity* unsafe_arena_release_velocity();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.SetPtzVelocityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::spot_cam::PtzVelocity* velocity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
};
// -------------------------------------------------------------------

class SetPtzVelocityResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.SetPtzVelocityResponse) */ {
 public:
  inline SetPtzVelocityResponse() : SetPtzVelocityResponse(nullptr) {}
  ~SetPtzVelocityResponse() override;
  explicit PROTOBUF_CONSTEXPR SetPtzVelocityResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPtzVelocityResponse(const SetPtzVelocityResponse& from);
  SetPtzVelocityResponse(SetPtzVelocityResponse&& from) noexcept
    : SetPtzVelocityResponse() {
    *this = ::std::move(from);
  }

  inline SetPtzVelocityResponse& operator=(const SetPtzVelocityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPtzVelocityResponse& operator=(SetPtzVelocityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPtzVelocityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPtzVelocityResponse* internal_default_instance() {
    return reinterpret_cast<const SetPtzVelocityResponse*>(
               &_SetPtzVelocityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SetPtzVelocityResponse& a, SetPtzVelocityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPtzVelocityResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPtzVelocityResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPtzVelocityResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPtzVelocityResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPtzVelocityResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetPtzVelocityResponse& from) {
    SetPtzVelocityResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPtzVelocityResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.SetPtzVelocityResponse";
  }
  protected:
  explicit SetPtzVelocityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kVelocityFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.PtzVelocity velocity = 2;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::bosdyn::api::spot_cam::PtzVelocity& velocity() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot_cam::PtzVelocity* release_velocity();
  ::bosdyn::api::spot_cam::PtzVelocity* mutable_velocity();
  void set_allocated_velocity(::bosdyn::api::spot_cam::PtzVelocity* velocity);
  private:
  const ::bosdyn::api::spot_cam::PtzVelocity& _internal_velocity() const;
  ::bosdyn::api::spot_cam::PtzVelocity* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::bosdyn::api::spot_cam::PtzVelocity* velocity);
  ::bosdyn::api::spot_cam::PtzVelocity* unsafe_arena_release_velocity();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.SetPtzVelocityResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::spot_cam::PtzVelocity* velocity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
};
// -------------------------------------------------------------------

class InitializeLensRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.InitializeLensRequest) */ {
 public:
  inline InitializeLensRequest() : InitializeLensRequest(nullptr) {}
  ~InitializeLensRequest() override;
  explicit PROTOBUF_CONSTEXPR InitializeLensRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitializeLensRequest(const InitializeLensRequest& from);
  InitializeLensRequest(InitializeLensRequest&& from) noexcept
    : InitializeLensRequest() {
    *this = ::std::move(from);
  }

  inline InitializeLensRequest& operator=(const InitializeLensRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitializeLensRequest& operator=(InitializeLensRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitializeLensRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitializeLensRequest* internal_default_instance() {
    return reinterpret_cast<const InitializeLensRequest*>(
               &_InitializeLensRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(InitializeLensRequest& a, InitializeLensRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitializeLensRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitializeLensRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitializeLensRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitializeLensRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitializeLensRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitializeLensRequest& from) {
    InitializeLensRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializeLensRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.InitializeLensRequest";
  }
  protected:
  explicit InitializeLensRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.InitializeLensRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
};
// -------------------------------------------------------------------

class InitializeLensResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.InitializeLensResponse) */ {
 public:
  inline InitializeLensResponse() : InitializeLensResponse(nullptr) {}
  ~InitializeLensResponse() override;
  explicit PROTOBUF_CONSTEXPR InitializeLensResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitializeLensResponse(const InitializeLensResponse& from);
  InitializeLensResponse(InitializeLensResponse&& from) noexcept
    : InitializeLensResponse() {
    *this = ::std::move(from);
  }

  inline InitializeLensResponse& operator=(const InitializeLensResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitializeLensResponse& operator=(InitializeLensResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitializeLensResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitializeLensResponse* internal_default_instance() {
    return reinterpret_cast<const InitializeLensResponse*>(
               &_InitializeLensResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(InitializeLensResponse& a, InitializeLensResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InitializeLensResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitializeLensResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitializeLensResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitializeLensResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitializeLensResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitializeLensResponse& from) {
    InitializeLensResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializeLensResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.InitializeLensResponse";
  }
  protected:
  explicit InitializeLensResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.InitializeLensResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PtzDescription_Limits

// .google.protobuf.FloatValue min = 1;
inline bool PtzDescription_Limits::_internal_has_min() const {
  return this != internal_default_instance() && _impl_.min_ != nullptr;
}
inline bool PtzDescription_Limits::has_min() const {
  return _internal_has_min();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PtzDescription_Limits::_internal_min() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.min_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PtzDescription_Limits::min() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.PtzDescription.Limits.min)
  return _internal_min();
}
inline void PtzDescription_Limits::unsafe_arena_set_allocated_min(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* min) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_);
  }
  _impl_.min_ = min;
  if (min) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.PtzDescription.Limits.min)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzDescription_Limits::release_min() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.min_;
  _impl_.min_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzDescription_Limits::unsafe_arena_release_min() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.PtzDescription.Limits.min)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.min_;
  _impl_.min_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzDescription_Limits::_internal_mutable_min() {
  
  if (_impl_.min_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.min_ = p;
  }
  return _impl_.min_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzDescription_Limits::mutable_min() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_min();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.PtzDescription.Limits.min)
  return _msg;
}
inline void PtzDescription_Limits::set_allocated_min(::PROTOBUF_NAMESPACE_ID::FloatValue* min) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_);
  }
  if (min) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min));
    if (message_arena != submessage_arena) {
      min = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.min_ = min;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.PtzDescription.Limits.min)
}

// .google.protobuf.FloatValue max = 2;
inline bool PtzDescription_Limits::_internal_has_max() const {
  return this != internal_default_instance() && _impl_.max_ != nullptr;
}
inline bool PtzDescription_Limits::has_max() const {
  return _internal_has_max();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PtzDescription_Limits::_internal_max() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.max_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PtzDescription_Limits::max() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.PtzDescription.Limits.max)
  return _internal_max();
}
inline void PtzDescription_Limits::unsafe_arena_set_allocated_max(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* max) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_);
  }
  _impl_.max_ = max;
  if (max) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.PtzDescription.Limits.max)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzDescription_Limits::release_max() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.max_;
  _impl_.max_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzDescription_Limits::unsafe_arena_release_max() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.PtzDescription.Limits.max)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.max_;
  _impl_.max_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzDescription_Limits::_internal_mutable_max() {
  
  if (_impl_.max_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.max_ = p;
  }
  return _impl_.max_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzDescription_Limits::mutable_max() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_max();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.PtzDescription.Limits.max)
  return _msg;
}
inline void PtzDescription_Limits::set_allocated_max(::PROTOBUF_NAMESPACE_ID::FloatValue* max) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_);
  }
  if (max) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(max));
    if (message_arena != submessage_arena) {
      max = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.max_ = max;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.PtzDescription.Limits.max)
}

// -------------------------------------------------------------------

// PtzDescription

// string name = 1;
inline void PtzDescription::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PtzDescription::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.PtzDescription.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PtzDescription::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.PtzDescription.name)
}
inline std::string* PtzDescription::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.PtzDescription.name)
  return _s;
}
inline const std::string& PtzDescription::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PtzDescription::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PtzDescription::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* PtzDescription::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.PtzDescription.name)
  return _impl_.name_.Release();
}
inline void PtzDescription::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.PtzDescription.name)
}

// .bosdyn.api.spot_cam.PtzDescription.Limits pan_limit = 2;
inline bool PtzDescription::_internal_has_pan_limit() const {
  return this != internal_default_instance() && _impl_.pan_limit_ != nullptr;
}
inline bool PtzDescription::has_pan_limit() const {
  return _internal_has_pan_limit();
}
inline void PtzDescription::clear_pan_limit() {
  if (GetArenaForAllocation() == nullptr && _impl_.pan_limit_ != nullptr) {
    delete _impl_.pan_limit_;
  }
  _impl_.pan_limit_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::PtzDescription_Limits& PtzDescription::_internal_pan_limit() const {
  const ::bosdyn::api::spot_cam::PtzDescription_Limits* p = _impl_.pan_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot_cam::PtzDescription_Limits&>(
      ::bosdyn::api::spot_cam::_PtzDescription_Limits_default_instance_);
}
inline const ::bosdyn::api::spot_cam::PtzDescription_Limits& PtzDescription::pan_limit() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.PtzDescription.pan_limit)
  return _internal_pan_limit();
}
inline void PtzDescription::unsafe_arena_set_allocated_pan_limit(
    ::bosdyn::api::spot_cam::PtzDescription_Limits* pan_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pan_limit_);
  }
  _impl_.pan_limit_ = pan_limit;
  if (pan_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.PtzDescription.pan_limit)
}
inline ::bosdyn::api::spot_cam::PtzDescription_Limits* PtzDescription::release_pan_limit() {
  
  ::bosdyn::api::spot_cam::PtzDescription_Limits* temp = _impl_.pan_limit_;
  _impl_.pan_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzDescription_Limits* PtzDescription::unsafe_arena_release_pan_limit() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.PtzDescription.pan_limit)
  
  ::bosdyn::api::spot_cam::PtzDescription_Limits* temp = _impl_.pan_limit_;
  _impl_.pan_limit_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzDescription_Limits* PtzDescription::_internal_mutable_pan_limit() {
  
  if (_impl_.pan_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::PtzDescription_Limits>(GetArenaForAllocation());
    _impl_.pan_limit_ = p;
  }
  return _impl_.pan_limit_;
}
inline ::bosdyn::api::spot_cam::PtzDescription_Limits* PtzDescription::mutable_pan_limit() {
  ::bosdyn::api::spot_cam::PtzDescription_Limits* _msg = _internal_mutable_pan_limit();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.PtzDescription.pan_limit)
  return _msg;
}
inline void PtzDescription::set_allocated_pan_limit(::bosdyn::api::spot_cam::PtzDescription_Limits* pan_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pan_limit_;
  }
  if (pan_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pan_limit);
    if (message_arena != submessage_arena) {
      pan_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pan_limit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pan_limit_ = pan_limit;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.PtzDescription.pan_limit)
}

// .bosdyn.api.spot_cam.PtzDescription.Limits tilt_limit = 3;
inline bool PtzDescription::_internal_has_tilt_limit() const {
  return this != internal_default_instance() && _impl_.tilt_limit_ != nullptr;
}
inline bool PtzDescription::has_tilt_limit() const {
  return _internal_has_tilt_limit();
}
inline void PtzDescription::clear_tilt_limit() {
  if (GetArenaForAllocation() == nullptr && _impl_.tilt_limit_ != nullptr) {
    delete _impl_.tilt_limit_;
  }
  _impl_.tilt_limit_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::PtzDescription_Limits& PtzDescription::_internal_tilt_limit() const {
  const ::bosdyn::api::spot_cam::PtzDescription_Limits* p = _impl_.tilt_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot_cam::PtzDescription_Limits&>(
      ::bosdyn::api::spot_cam::_PtzDescription_Limits_default_instance_);
}
inline const ::bosdyn::api::spot_cam::PtzDescription_Limits& PtzDescription::tilt_limit() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.PtzDescription.tilt_limit)
  return _internal_tilt_limit();
}
inline void PtzDescription::unsafe_arena_set_allocated_tilt_limit(
    ::bosdyn::api::spot_cam::PtzDescription_Limits* tilt_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tilt_limit_);
  }
  _impl_.tilt_limit_ = tilt_limit;
  if (tilt_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.PtzDescription.tilt_limit)
}
inline ::bosdyn::api::spot_cam::PtzDescription_Limits* PtzDescription::release_tilt_limit() {
  
  ::bosdyn::api::spot_cam::PtzDescription_Limits* temp = _impl_.tilt_limit_;
  _impl_.tilt_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzDescription_Limits* PtzDescription::unsafe_arena_release_tilt_limit() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.PtzDescription.tilt_limit)
  
  ::bosdyn::api::spot_cam::PtzDescription_Limits* temp = _impl_.tilt_limit_;
  _impl_.tilt_limit_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzDescription_Limits* PtzDescription::_internal_mutable_tilt_limit() {
  
  if (_impl_.tilt_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::PtzDescription_Limits>(GetArenaForAllocation());
    _impl_.tilt_limit_ = p;
  }
  return _impl_.tilt_limit_;
}
inline ::bosdyn::api::spot_cam::PtzDescription_Limits* PtzDescription::mutable_tilt_limit() {
  ::bosdyn::api::spot_cam::PtzDescription_Limits* _msg = _internal_mutable_tilt_limit();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.PtzDescription.tilt_limit)
  return _msg;
}
inline void PtzDescription::set_allocated_tilt_limit(::bosdyn::api::spot_cam::PtzDescription_Limits* tilt_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tilt_limit_;
  }
  if (tilt_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tilt_limit);
    if (message_arena != submessage_arena) {
      tilt_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tilt_limit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tilt_limit_ = tilt_limit;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.PtzDescription.tilt_limit)
}

// .bosdyn.api.spot_cam.PtzDescription.Limits zoom_limit = 4;
inline bool PtzDescription::_internal_has_zoom_limit() const {
  return this != internal_default_instance() && _impl_.zoom_limit_ != nullptr;
}
inline bool PtzDescription::has_zoom_limit() const {
  return _internal_has_zoom_limit();
}
inline void PtzDescription::clear_zoom_limit() {
  if (GetArenaForAllocation() == nullptr && _impl_.zoom_limit_ != nullptr) {
    delete _impl_.zoom_limit_;
  }
  _impl_.zoom_limit_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::PtzDescription_Limits& PtzDescription::_internal_zoom_limit() const {
  const ::bosdyn::api::spot_cam::PtzDescription_Limits* p = _impl_.zoom_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot_cam::PtzDescription_Limits&>(
      ::bosdyn::api::spot_cam::_PtzDescription_Limits_default_instance_);
}
inline const ::bosdyn::api::spot_cam::PtzDescription_Limits& PtzDescription::zoom_limit() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.PtzDescription.zoom_limit)
  return _internal_zoom_limit();
}
inline void PtzDescription::unsafe_arena_set_allocated_zoom_limit(
    ::bosdyn::api::spot_cam::PtzDescription_Limits* zoom_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.zoom_limit_);
  }
  _impl_.zoom_limit_ = zoom_limit;
  if (zoom_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.PtzDescription.zoom_limit)
}
inline ::bosdyn::api::spot_cam::PtzDescription_Limits* PtzDescription::release_zoom_limit() {
  
  ::bosdyn::api::spot_cam::PtzDescription_Limits* temp = _impl_.zoom_limit_;
  _impl_.zoom_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzDescription_Limits* PtzDescription::unsafe_arena_release_zoom_limit() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.PtzDescription.zoom_limit)
  
  ::bosdyn::api::spot_cam::PtzDescription_Limits* temp = _impl_.zoom_limit_;
  _impl_.zoom_limit_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzDescription_Limits* PtzDescription::_internal_mutable_zoom_limit() {
  
  if (_impl_.zoom_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::PtzDescription_Limits>(GetArenaForAllocation());
    _impl_.zoom_limit_ = p;
  }
  return _impl_.zoom_limit_;
}
inline ::bosdyn::api::spot_cam::PtzDescription_Limits* PtzDescription::mutable_zoom_limit() {
  ::bosdyn::api::spot_cam::PtzDescription_Limits* _msg = _internal_mutable_zoom_limit();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.PtzDescription.zoom_limit)
  return _msg;
}
inline void PtzDescription::set_allocated_zoom_limit(::bosdyn::api::spot_cam::PtzDescription_Limits* zoom_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.zoom_limit_;
  }
  if (zoom_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(zoom_limit);
    if (message_arena != submessage_arena) {
      zoom_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, zoom_limit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.zoom_limit_ = zoom_limit;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.PtzDescription.zoom_limit)
}

// -------------------------------------------------------------------

// PtzPosition

// .bosdyn.api.spot_cam.PtzDescription ptz = 2;
inline bool PtzPosition::_internal_has_ptz() const {
  return this != internal_default_instance() && _impl_.ptz_ != nullptr;
}
inline bool PtzPosition::has_ptz() const {
  return _internal_has_ptz();
}
inline void PtzPosition::clear_ptz() {
  if (GetArenaForAllocation() == nullptr && _impl_.ptz_ != nullptr) {
    delete _impl_.ptz_;
  }
  _impl_.ptz_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::PtzDescription& PtzPosition::_internal_ptz() const {
  const ::bosdyn::api::spot_cam::PtzDescription* p = _impl_.ptz_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot_cam::PtzDescription&>(
      ::bosdyn::api::spot_cam::_PtzDescription_default_instance_);
}
inline const ::bosdyn::api::spot_cam::PtzDescription& PtzPosition::ptz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.PtzPosition.ptz)
  return _internal_ptz();
}
inline void PtzPosition::unsafe_arena_set_allocated_ptz(
    ::bosdyn::api::spot_cam::PtzDescription* ptz) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ptz_);
  }
  _impl_.ptz_ = ptz;
  if (ptz) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.PtzPosition.ptz)
}
inline ::bosdyn::api::spot_cam::PtzDescription* PtzPosition::release_ptz() {
  
  ::bosdyn::api::spot_cam::PtzDescription* temp = _impl_.ptz_;
  _impl_.ptz_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzDescription* PtzPosition::unsafe_arena_release_ptz() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.PtzPosition.ptz)
  
  ::bosdyn::api::spot_cam::PtzDescription* temp = _impl_.ptz_;
  _impl_.ptz_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzDescription* PtzPosition::_internal_mutable_ptz() {
  
  if (_impl_.ptz_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::PtzDescription>(GetArenaForAllocation());
    _impl_.ptz_ = p;
  }
  return _impl_.ptz_;
}
inline ::bosdyn::api::spot_cam::PtzDescription* PtzPosition::mutable_ptz() {
  ::bosdyn::api::spot_cam::PtzDescription* _msg = _internal_mutable_ptz();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.PtzPosition.ptz)
  return _msg;
}
inline void PtzPosition::set_allocated_ptz(::bosdyn::api::spot_cam::PtzDescription* ptz) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ptz_;
  }
  if (ptz) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ptz);
    if (message_arena != submessage_arena) {
      ptz = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ptz, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ptz_ = ptz;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.PtzPosition.ptz)
}

// .google.protobuf.FloatValue pan = 3;
inline bool PtzPosition::_internal_has_pan() const {
  return this != internal_default_instance() && _impl_.pan_ != nullptr;
}
inline bool PtzPosition::has_pan() const {
  return _internal_has_pan();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PtzPosition::_internal_pan() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.pan_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PtzPosition::pan() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.PtzPosition.pan)
  return _internal_pan();
}
inline void PtzPosition::unsafe_arena_set_allocated_pan(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* pan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pan_);
  }
  _impl_.pan_ = pan;
  if (pan) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.PtzPosition.pan)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzPosition::release_pan() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.pan_;
  _impl_.pan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzPosition::unsafe_arena_release_pan() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.PtzPosition.pan)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.pan_;
  _impl_.pan_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzPosition::_internal_mutable_pan() {
  
  if (_impl_.pan_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.pan_ = p;
  }
  return _impl_.pan_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzPosition::mutable_pan() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_pan();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.PtzPosition.pan)
  return _msg;
}
inline void PtzPosition::set_allocated_pan(::PROTOBUF_NAMESPACE_ID::FloatValue* pan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pan_);
  }
  if (pan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pan));
    if (message_arena != submessage_arena) {
      pan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pan, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pan_ = pan;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.PtzPosition.pan)
}

// .google.protobuf.FloatValue tilt = 4;
inline bool PtzPosition::_internal_has_tilt() const {
  return this != internal_default_instance() && _impl_.tilt_ != nullptr;
}
inline bool PtzPosition::has_tilt() const {
  return _internal_has_tilt();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PtzPosition::_internal_tilt() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.tilt_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PtzPosition::tilt() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.PtzPosition.tilt)
  return _internal_tilt();
}
inline void PtzPosition::unsafe_arena_set_allocated_tilt(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* tilt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tilt_);
  }
  _impl_.tilt_ = tilt;
  if (tilt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.PtzPosition.tilt)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzPosition::release_tilt() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.tilt_;
  _impl_.tilt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzPosition::unsafe_arena_release_tilt() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.PtzPosition.tilt)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.tilt_;
  _impl_.tilt_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzPosition::_internal_mutable_tilt() {
  
  if (_impl_.tilt_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.tilt_ = p;
  }
  return _impl_.tilt_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzPosition::mutable_tilt() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_tilt();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.PtzPosition.tilt)
  return _msg;
}
inline void PtzPosition::set_allocated_tilt(::PROTOBUF_NAMESPACE_ID::FloatValue* tilt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tilt_);
  }
  if (tilt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tilt));
    if (message_arena != submessage_arena) {
      tilt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tilt, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tilt_ = tilt;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.PtzPosition.tilt)
}

// .google.protobuf.FloatValue zoom = 5;
inline bool PtzPosition::_internal_has_zoom() const {
  return this != internal_default_instance() && _impl_.zoom_ != nullptr;
}
inline bool PtzPosition::has_zoom() const {
  return _internal_has_zoom();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PtzPosition::_internal_zoom() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.zoom_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PtzPosition::zoom() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.PtzPosition.zoom)
  return _internal_zoom();
}
inline void PtzPosition::unsafe_arena_set_allocated_zoom(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* zoom) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.zoom_);
  }
  _impl_.zoom_ = zoom;
  if (zoom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.PtzPosition.zoom)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzPosition::release_zoom() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.zoom_;
  _impl_.zoom_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzPosition::unsafe_arena_release_zoom() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.PtzPosition.zoom)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.zoom_;
  _impl_.zoom_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzPosition::_internal_mutable_zoom() {
  
  if (_impl_.zoom_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.zoom_ = p;
  }
  return _impl_.zoom_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzPosition::mutable_zoom() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_zoom();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.PtzPosition.zoom)
  return _msg;
}
inline void PtzPosition::set_allocated_zoom(::PROTOBUF_NAMESPACE_ID::FloatValue* zoom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.zoom_);
  }
  if (zoom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(zoom));
    if (message_arena != submessage_arena) {
      zoom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, zoom, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.zoom_ = zoom;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.PtzPosition.zoom)
}

// -------------------------------------------------------------------

// PtzVelocity

// .bosdyn.api.spot_cam.PtzDescription ptz = 2;
inline bool PtzVelocity::_internal_has_ptz() const {
  return this != internal_default_instance() && _impl_.ptz_ != nullptr;
}
inline bool PtzVelocity::has_ptz() const {
  return _internal_has_ptz();
}
inline void PtzVelocity::clear_ptz() {
  if (GetArenaForAllocation() == nullptr && _impl_.ptz_ != nullptr) {
    delete _impl_.ptz_;
  }
  _impl_.ptz_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::PtzDescription& PtzVelocity::_internal_ptz() const {
  const ::bosdyn::api::spot_cam::PtzDescription* p = _impl_.ptz_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot_cam::PtzDescription&>(
      ::bosdyn::api::spot_cam::_PtzDescription_default_instance_);
}
inline const ::bosdyn::api::spot_cam::PtzDescription& PtzVelocity::ptz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.PtzVelocity.ptz)
  return _internal_ptz();
}
inline void PtzVelocity::unsafe_arena_set_allocated_ptz(
    ::bosdyn::api::spot_cam::PtzDescription* ptz) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ptz_);
  }
  _impl_.ptz_ = ptz;
  if (ptz) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.PtzVelocity.ptz)
}
inline ::bosdyn::api::spot_cam::PtzDescription* PtzVelocity::release_ptz() {
  
  ::bosdyn::api::spot_cam::PtzDescription* temp = _impl_.ptz_;
  _impl_.ptz_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzDescription* PtzVelocity::unsafe_arena_release_ptz() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.PtzVelocity.ptz)
  
  ::bosdyn::api::spot_cam::PtzDescription* temp = _impl_.ptz_;
  _impl_.ptz_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzDescription* PtzVelocity::_internal_mutable_ptz() {
  
  if (_impl_.ptz_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::PtzDescription>(GetArenaForAllocation());
    _impl_.ptz_ = p;
  }
  return _impl_.ptz_;
}
inline ::bosdyn::api::spot_cam::PtzDescription* PtzVelocity::mutable_ptz() {
  ::bosdyn::api::spot_cam::PtzDescription* _msg = _internal_mutable_ptz();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.PtzVelocity.ptz)
  return _msg;
}
inline void PtzVelocity::set_allocated_ptz(::bosdyn::api::spot_cam::PtzDescription* ptz) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ptz_;
  }
  if (ptz) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ptz);
    if (message_arena != submessage_arena) {
      ptz = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ptz, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ptz_ = ptz;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.PtzVelocity.ptz)
}

// .google.protobuf.FloatValue pan = 3;
inline bool PtzVelocity::_internal_has_pan() const {
  return this != internal_default_instance() && _impl_.pan_ != nullptr;
}
inline bool PtzVelocity::has_pan() const {
  return _internal_has_pan();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PtzVelocity::_internal_pan() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.pan_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PtzVelocity::pan() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.PtzVelocity.pan)
  return _internal_pan();
}
inline void PtzVelocity::unsafe_arena_set_allocated_pan(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* pan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pan_);
  }
  _impl_.pan_ = pan;
  if (pan) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.PtzVelocity.pan)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzVelocity::release_pan() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.pan_;
  _impl_.pan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzVelocity::unsafe_arena_release_pan() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.PtzVelocity.pan)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.pan_;
  _impl_.pan_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzVelocity::_internal_mutable_pan() {
  
  if (_impl_.pan_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.pan_ = p;
  }
  return _impl_.pan_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzVelocity::mutable_pan() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_pan();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.PtzVelocity.pan)
  return _msg;
}
inline void PtzVelocity::set_allocated_pan(::PROTOBUF_NAMESPACE_ID::FloatValue* pan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pan_);
  }
  if (pan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pan));
    if (message_arena != submessage_arena) {
      pan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pan, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pan_ = pan;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.PtzVelocity.pan)
}

// .google.protobuf.FloatValue tilt = 4;
inline bool PtzVelocity::_internal_has_tilt() const {
  return this != internal_default_instance() && _impl_.tilt_ != nullptr;
}
inline bool PtzVelocity::has_tilt() const {
  return _internal_has_tilt();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PtzVelocity::_internal_tilt() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.tilt_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PtzVelocity::tilt() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.PtzVelocity.tilt)
  return _internal_tilt();
}
inline void PtzVelocity::unsafe_arena_set_allocated_tilt(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* tilt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tilt_);
  }
  _impl_.tilt_ = tilt;
  if (tilt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.PtzVelocity.tilt)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzVelocity::release_tilt() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.tilt_;
  _impl_.tilt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzVelocity::unsafe_arena_release_tilt() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.PtzVelocity.tilt)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.tilt_;
  _impl_.tilt_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzVelocity::_internal_mutable_tilt() {
  
  if (_impl_.tilt_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.tilt_ = p;
  }
  return _impl_.tilt_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzVelocity::mutable_tilt() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_tilt();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.PtzVelocity.tilt)
  return _msg;
}
inline void PtzVelocity::set_allocated_tilt(::PROTOBUF_NAMESPACE_ID::FloatValue* tilt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tilt_);
  }
  if (tilt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tilt));
    if (message_arena != submessage_arena) {
      tilt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tilt, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tilt_ = tilt;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.PtzVelocity.tilt)
}

// .google.protobuf.FloatValue zoom = 5;
inline bool PtzVelocity::_internal_has_zoom() const {
  return this != internal_default_instance() && _impl_.zoom_ != nullptr;
}
inline bool PtzVelocity::has_zoom() const {
  return _internal_has_zoom();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PtzVelocity::_internal_zoom() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.zoom_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PtzVelocity::zoom() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.PtzVelocity.zoom)
  return _internal_zoom();
}
inline void PtzVelocity::unsafe_arena_set_allocated_zoom(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* zoom) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.zoom_);
  }
  _impl_.zoom_ = zoom;
  if (zoom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.PtzVelocity.zoom)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzVelocity::release_zoom() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.zoom_;
  _impl_.zoom_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzVelocity::unsafe_arena_release_zoom() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.PtzVelocity.zoom)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.zoom_;
  _impl_.zoom_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzVelocity::_internal_mutable_zoom() {
  
  if (_impl_.zoom_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.zoom_ = p;
  }
  return _impl_.zoom_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PtzVelocity::mutable_zoom() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_zoom();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.PtzVelocity.zoom)
  return _msg;
}
inline void PtzVelocity::set_allocated_zoom(::PROTOBUF_NAMESPACE_ID::FloatValue* zoom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.zoom_);
  }
  if (zoom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(zoom));
    if (message_arena != submessage_arena) {
      zoom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, zoom, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.zoom_ = zoom;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.PtzVelocity.zoom)
}

// -------------------------------------------------------------------

// GetPtzPositionRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetPtzPositionRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetPtzPositionRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetPtzPositionRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetPtzPositionRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.GetPtzPositionRequest.header)
  return _internal_header();
}
inline void GetPtzPositionRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.GetPtzPositionRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetPtzPositionRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetPtzPositionRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.GetPtzPositionRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetPtzPositionRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* GetPtzPositionRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.GetPtzPositionRequest.header)
  return _msg;
}
inline void GetPtzPositionRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.GetPtzPositionRequest.header)
}

// .bosdyn.api.spot_cam.PtzDescription ptz = 2;
inline bool GetPtzPositionRequest::_internal_has_ptz() const {
  return this != internal_default_instance() && _impl_.ptz_ != nullptr;
}
inline bool GetPtzPositionRequest::has_ptz() const {
  return _internal_has_ptz();
}
inline void GetPtzPositionRequest::clear_ptz() {
  if (GetArenaForAllocation() == nullptr && _impl_.ptz_ != nullptr) {
    delete _impl_.ptz_;
  }
  _impl_.ptz_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::PtzDescription& GetPtzPositionRequest::_internal_ptz() const {
  const ::bosdyn::api::spot_cam::PtzDescription* p = _impl_.ptz_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot_cam::PtzDescription&>(
      ::bosdyn::api::spot_cam::_PtzDescription_default_instance_);
}
inline const ::bosdyn::api::spot_cam::PtzDescription& GetPtzPositionRequest::ptz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.GetPtzPositionRequest.ptz)
  return _internal_ptz();
}
inline void GetPtzPositionRequest::unsafe_arena_set_allocated_ptz(
    ::bosdyn::api::spot_cam::PtzDescription* ptz) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ptz_);
  }
  _impl_.ptz_ = ptz;
  if (ptz) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.GetPtzPositionRequest.ptz)
}
inline ::bosdyn::api::spot_cam::PtzDescription* GetPtzPositionRequest::release_ptz() {
  
  ::bosdyn::api::spot_cam::PtzDescription* temp = _impl_.ptz_;
  _impl_.ptz_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzDescription* GetPtzPositionRequest::unsafe_arena_release_ptz() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.GetPtzPositionRequest.ptz)
  
  ::bosdyn::api::spot_cam::PtzDescription* temp = _impl_.ptz_;
  _impl_.ptz_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzDescription* GetPtzPositionRequest::_internal_mutable_ptz() {
  
  if (_impl_.ptz_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::PtzDescription>(GetArenaForAllocation());
    _impl_.ptz_ = p;
  }
  return _impl_.ptz_;
}
inline ::bosdyn::api::spot_cam::PtzDescription* GetPtzPositionRequest::mutable_ptz() {
  ::bosdyn::api::spot_cam::PtzDescription* _msg = _internal_mutable_ptz();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.GetPtzPositionRequest.ptz)
  return _msg;
}
inline void GetPtzPositionRequest::set_allocated_ptz(::bosdyn::api::spot_cam::PtzDescription* ptz) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ptz_;
  }
  if (ptz) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ptz);
    if (message_arena != submessage_arena) {
      ptz = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ptz, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ptz_ = ptz;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.GetPtzPositionRequest.ptz)
}

// -------------------------------------------------------------------

// GetPtzPositionResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetPtzPositionResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetPtzPositionResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetPtzPositionResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetPtzPositionResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.GetPtzPositionResponse.header)
  return _internal_header();
}
inline void GetPtzPositionResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.GetPtzPositionResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetPtzPositionResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetPtzPositionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.GetPtzPositionResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetPtzPositionResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* GetPtzPositionResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.GetPtzPositionResponse.header)
  return _msg;
}
inline void GetPtzPositionResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.GetPtzPositionResponse.header)
}

// .bosdyn.api.spot_cam.PtzPosition position = 2;
inline bool GetPtzPositionResponse::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool GetPtzPositionResponse::has_position() const {
  return _internal_has_position();
}
inline void GetPtzPositionResponse::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::PtzPosition& GetPtzPositionResponse::_internal_position() const {
  const ::bosdyn::api::spot_cam::PtzPosition* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot_cam::PtzPosition&>(
      ::bosdyn::api::spot_cam::_PtzPosition_default_instance_);
}
inline const ::bosdyn::api::spot_cam::PtzPosition& GetPtzPositionResponse::position() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.GetPtzPositionResponse.position)
  return _internal_position();
}
inline void GetPtzPositionResponse::unsafe_arena_set_allocated_position(
    ::bosdyn::api::spot_cam::PtzPosition* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.GetPtzPositionResponse.position)
}
inline ::bosdyn::api::spot_cam::PtzPosition* GetPtzPositionResponse::release_position() {
  
  ::bosdyn::api::spot_cam::PtzPosition* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzPosition* GetPtzPositionResponse::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.GetPtzPositionResponse.position)
  
  ::bosdyn::api::spot_cam::PtzPosition* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzPosition* GetPtzPositionResponse::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::PtzPosition>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::bosdyn::api::spot_cam::PtzPosition* GetPtzPositionResponse::mutable_position() {
  ::bosdyn::api::spot_cam::PtzPosition* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.GetPtzPositionResponse.position)
  return _msg;
}
inline void GetPtzPositionResponse::set_allocated_position(::bosdyn::api::spot_cam::PtzPosition* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.GetPtzPositionResponse.position)
}

// -------------------------------------------------------------------

// GetPtzVelocityRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetPtzVelocityRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetPtzVelocityRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetPtzVelocityRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetPtzVelocityRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.GetPtzVelocityRequest.header)
  return _internal_header();
}
inline void GetPtzVelocityRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.GetPtzVelocityRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetPtzVelocityRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetPtzVelocityRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.GetPtzVelocityRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetPtzVelocityRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* GetPtzVelocityRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.GetPtzVelocityRequest.header)
  return _msg;
}
inline void GetPtzVelocityRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.GetPtzVelocityRequest.header)
}

// .bosdyn.api.spot_cam.PtzDescription ptz = 2;
inline bool GetPtzVelocityRequest::_internal_has_ptz() const {
  return this != internal_default_instance() && _impl_.ptz_ != nullptr;
}
inline bool GetPtzVelocityRequest::has_ptz() const {
  return _internal_has_ptz();
}
inline void GetPtzVelocityRequest::clear_ptz() {
  if (GetArenaForAllocation() == nullptr && _impl_.ptz_ != nullptr) {
    delete _impl_.ptz_;
  }
  _impl_.ptz_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::PtzDescription& GetPtzVelocityRequest::_internal_ptz() const {
  const ::bosdyn::api::spot_cam::PtzDescription* p = _impl_.ptz_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot_cam::PtzDescription&>(
      ::bosdyn::api::spot_cam::_PtzDescription_default_instance_);
}
inline const ::bosdyn::api::spot_cam::PtzDescription& GetPtzVelocityRequest::ptz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.GetPtzVelocityRequest.ptz)
  return _internal_ptz();
}
inline void GetPtzVelocityRequest::unsafe_arena_set_allocated_ptz(
    ::bosdyn::api::spot_cam::PtzDescription* ptz) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ptz_);
  }
  _impl_.ptz_ = ptz;
  if (ptz) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.GetPtzVelocityRequest.ptz)
}
inline ::bosdyn::api::spot_cam::PtzDescription* GetPtzVelocityRequest::release_ptz() {
  
  ::bosdyn::api::spot_cam::PtzDescription* temp = _impl_.ptz_;
  _impl_.ptz_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzDescription* GetPtzVelocityRequest::unsafe_arena_release_ptz() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.GetPtzVelocityRequest.ptz)
  
  ::bosdyn::api::spot_cam::PtzDescription* temp = _impl_.ptz_;
  _impl_.ptz_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzDescription* GetPtzVelocityRequest::_internal_mutable_ptz() {
  
  if (_impl_.ptz_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::PtzDescription>(GetArenaForAllocation());
    _impl_.ptz_ = p;
  }
  return _impl_.ptz_;
}
inline ::bosdyn::api::spot_cam::PtzDescription* GetPtzVelocityRequest::mutable_ptz() {
  ::bosdyn::api::spot_cam::PtzDescription* _msg = _internal_mutable_ptz();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.GetPtzVelocityRequest.ptz)
  return _msg;
}
inline void GetPtzVelocityRequest::set_allocated_ptz(::bosdyn::api::spot_cam::PtzDescription* ptz) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ptz_;
  }
  if (ptz) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ptz);
    if (message_arena != submessage_arena) {
      ptz = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ptz, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ptz_ = ptz;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.GetPtzVelocityRequest.ptz)
}

// -------------------------------------------------------------------

// GetPtzVelocityResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetPtzVelocityResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetPtzVelocityResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetPtzVelocityResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetPtzVelocityResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.GetPtzVelocityResponse.header)
  return _internal_header();
}
inline void GetPtzVelocityResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.GetPtzVelocityResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetPtzVelocityResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetPtzVelocityResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.GetPtzVelocityResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetPtzVelocityResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* GetPtzVelocityResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.GetPtzVelocityResponse.header)
  return _msg;
}
inline void GetPtzVelocityResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.GetPtzVelocityResponse.header)
}

// .bosdyn.api.spot_cam.PtzVelocity velocity = 2;
inline bool GetPtzVelocityResponse::_internal_has_velocity() const {
  return this != internal_default_instance() && _impl_.velocity_ != nullptr;
}
inline bool GetPtzVelocityResponse::has_velocity() const {
  return _internal_has_velocity();
}
inline void GetPtzVelocityResponse::clear_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.velocity_ != nullptr) {
    delete _impl_.velocity_;
  }
  _impl_.velocity_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::PtzVelocity& GetPtzVelocityResponse::_internal_velocity() const {
  const ::bosdyn::api::spot_cam::PtzVelocity* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot_cam::PtzVelocity&>(
      ::bosdyn::api::spot_cam::_PtzVelocity_default_instance_);
}
inline const ::bosdyn::api::spot_cam::PtzVelocity& GetPtzVelocityResponse::velocity() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.GetPtzVelocityResponse.velocity)
  return _internal_velocity();
}
inline void GetPtzVelocityResponse::unsafe_arena_set_allocated_velocity(
    ::bosdyn::api::spot_cam::PtzVelocity* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.GetPtzVelocityResponse.velocity)
}
inline ::bosdyn::api::spot_cam::PtzVelocity* GetPtzVelocityResponse::release_velocity() {
  
  ::bosdyn::api::spot_cam::PtzVelocity* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzVelocity* GetPtzVelocityResponse::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.GetPtzVelocityResponse.velocity)
  
  ::bosdyn::api::spot_cam::PtzVelocity* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzVelocity* GetPtzVelocityResponse::_internal_mutable_velocity() {
  
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::PtzVelocity>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::bosdyn::api::spot_cam::PtzVelocity* GetPtzVelocityResponse::mutable_velocity() {
  ::bosdyn::api::spot_cam::PtzVelocity* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.GetPtzVelocityResponse.velocity)
  return _msg;
}
inline void GetPtzVelocityResponse::set_allocated_velocity(::bosdyn::api::spot_cam::PtzVelocity* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.GetPtzVelocityResponse.velocity)
}

// -------------------------------------------------------------------

// ListPtzRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListPtzRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListPtzRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListPtzRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListPtzRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.ListPtzRequest.header)
  return _internal_header();
}
inline void ListPtzRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.ListPtzRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListPtzRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListPtzRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.ListPtzRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListPtzRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ListPtzRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.ListPtzRequest.header)
  return _msg;
}
inline void ListPtzRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.ListPtzRequest.header)
}

// -------------------------------------------------------------------

// ListPtzResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListPtzResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListPtzResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListPtzResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListPtzResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.ListPtzResponse.header)
  return _internal_header();
}
inline void ListPtzResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.ListPtzResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListPtzResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListPtzResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.ListPtzResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListPtzResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ListPtzResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.ListPtzResponse.header)
  return _msg;
}
inline void ListPtzResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.ListPtzResponse.header)
}

// repeated .bosdyn.api.spot_cam.PtzDescription ptzs = 2;
inline int ListPtzResponse::_internal_ptzs_size() const {
  return _impl_.ptzs_.size();
}
inline int ListPtzResponse::ptzs_size() const {
  return _internal_ptzs_size();
}
inline void ListPtzResponse::clear_ptzs() {
  _impl_.ptzs_.Clear();
}
inline ::bosdyn::api::spot_cam::PtzDescription* ListPtzResponse::mutable_ptzs(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.ListPtzResponse.ptzs)
  return _impl_.ptzs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::PtzDescription >*
ListPtzResponse::mutable_ptzs() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot_cam.ListPtzResponse.ptzs)
  return &_impl_.ptzs_;
}
inline const ::bosdyn::api::spot_cam::PtzDescription& ListPtzResponse::_internal_ptzs(int index) const {
  return _impl_.ptzs_.Get(index);
}
inline const ::bosdyn::api::spot_cam::PtzDescription& ListPtzResponse::ptzs(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.ListPtzResponse.ptzs)
  return _internal_ptzs(index);
}
inline ::bosdyn::api::spot_cam::PtzDescription* ListPtzResponse::_internal_add_ptzs() {
  return _impl_.ptzs_.Add();
}
inline ::bosdyn::api::spot_cam::PtzDescription* ListPtzResponse::add_ptzs() {
  ::bosdyn::api::spot_cam::PtzDescription* _add = _internal_add_ptzs();
  // @@protoc_insertion_point(field_add:bosdyn.api.spot_cam.ListPtzResponse.ptzs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::PtzDescription >&
ListPtzResponse::ptzs() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot_cam.ListPtzResponse.ptzs)
  return _impl_.ptzs_;
}

// -------------------------------------------------------------------

// SetPtzPositionRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool SetPtzPositionRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SetPtzPositionRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& SetPtzPositionRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& SetPtzPositionRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.SetPtzPositionRequest.header)
  return _internal_header();
}
inline void SetPtzPositionRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.SetPtzPositionRequest.header)
}
inline ::bosdyn::api::RequestHeader* SetPtzPositionRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* SetPtzPositionRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.SetPtzPositionRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* SetPtzPositionRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* SetPtzPositionRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.SetPtzPositionRequest.header)
  return _msg;
}
inline void SetPtzPositionRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.SetPtzPositionRequest.header)
}

// .bosdyn.api.spot_cam.PtzPosition position = 2;
inline bool SetPtzPositionRequest::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool SetPtzPositionRequest::has_position() const {
  return _internal_has_position();
}
inline void SetPtzPositionRequest::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::PtzPosition& SetPtzPositionRequest::_internal_position() const {
  const ::bosdyn::api::spot_cam::PtzPosition* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot_cam::PtzPosition&>(
      ::bosdyn::api::spot_cam::_PtzPosition_default_instance_);
}
inline const ::bosdyn::api::spot_cam::PtzPosition& SetPtzPositionRequest::position() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.SetPtzPositionRequest.position)
  return _internal_position();
}
inline void SetPtzPositionRequest::unsafe_arena_set_allocated_position(
    ::bosdyn::api::spot_cam::PtzPosition* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.SetPtzPositionRequest.position)
}
inline ::bosdyn::api::spot_cam::PtzPosition* SetPtzPositionRequest::release_position() {
  
  ::bosdyn::api::spot_cam::PtzPosition* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzPosition* SetPtzPositionRequest::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.SetPtzPositionRequest.position)
  
  ::bosdyn::api::spot_cam::PtzPosition* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzPosition* SetPtzPositionRequest::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::PtzPosition>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::bosdyn::api::spot_cam::PtzPosition* SetPtzPositionRequest::mutable_position() {
  ::bosdyn::api::spot_cam::PtzPosition* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.SetPtzPositionRequest.position)
  return _msg;
}
inline void SetPtzPositionRequest::set_allocated_position(::bosdyn::api::spot_cam::PtzPosition* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.SetPtzPositionRequest.position)
}

// -------------------------------------------------------------------

// SetPtzPositionResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool SetPtzPositionResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SetPtzPositionResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& SetPtzPositionResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& SetPtzPositionResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.SetPtzPositionResponse.header)
  return _internal_header();
}
inline void SetPtzPositionResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.SetPtzPositionResponse.header)
}
inline ::bosdyn::api::ResponseHeader* SetPtzPositionResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SetPtzPositionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.SetPtzPositionResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SetPtzPositionResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* SetPtzPositionResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.SetPtzPositionResponse.header)
  return _msg;
}
inline void SetPtzPositionResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.SetPtzPositionResponse.header)
}

// .bosdyn.api.spot_cam.PtzPosition position = 2;
inline bool SetPtzPositionResponse::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool SetPtzPositionResponse::has_position() const {
  return _internal_has_position();
}
inline void SetPtzPositionResponse::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::PtzPosition& SetPtzPositionResponse::_internal_position() const {
  const ::bosdyn::api::spot_cam::PtzPosition* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot_cam::PtzPosition&>(
      ::bosdyn::api::spot_cam::_PtzPosition_default_instance_);
}
inline const ::bosdyn::api::spot_cam::PtzPosition& SetPtzPositionResponse::position() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.SetPtzPositionResponse.position)
  return _internal_position();
}
inline void SetPtzPositionResponse::unsafe_arena_set_allocated_position(
    ::bosdyn::api::spot_cam::PtzPosition* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.SetPtzPositionResponse.position)
}
inline ::bosdyn::api::spot_cam::PtzPosition* SetPtzPositionResponse::release_position() {
  
  ::bosdyn::api::spot_cam::PtzPosition* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzPosition* SetPtzPositionResponse::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.SetPtzPositionResponse.position)
  
  ::bosdyn::api::spot_cam::PtzPosition* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzPosition* SetPtzPositionResponse::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::PtzPosition>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::bosdyn::api::spot_cam::PtzPosition* SetPtzPositionResponse::mutable_position() {
  ::bosdyn::api::spot_cam::PtzPosition* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.SetPtzPositionResponse.position)
  return _msg;
}
inline void SetPtzPositionResponse::set_allocated_position(::bosdyn::api::spot_cam::PtzPosition* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.SetPtzPositionResponse.position)
}

// -------------------------------------------------------------------

// SetPtzVelocityRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool SetPtzVelocityRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SetPtzVelocityRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& SetPtzVelocityRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& SetPtzVelocityRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.SetPtzVelocityRequest.header)
  return _internal_header();
}
inline void SetPtzVelocityRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.SetPtzVelocityRequest.header)
}
inline ::bosdyn::api::RequestHeader* SetPtzVelocityRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* SetPtzVelocityRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.SetPtzVelocityRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* SetPtzVelocityRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* SetPtzVelocityRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.SetPtzVelocityRequest.header)
  return _msg;
}
inline void SetPtzVelocityRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.SetPtzVelocityRequest.header)
}

// .bosdyn.api.spot_cam.PtzVelocity velocity = 2;
inline bool SetPtzVelocityRequest::_internal_has_velocity() const {
  return this != internal_default_instance() && _impl_.velocity_ != nullptr;
}
inline bool SetPtzVelocityRequest::has_velocity() const {
  return _internal_has_velocity();
}
inline void SetPtzVelocityRequest::clear_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.velocity_ != nullptr) {
    delete _impl_.velocity_;
  }
  _impl_.velocity_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::PtzVelocity& SetPtzVelocityRequest::_internal_velocity() const {
  const ::bosdyn::api::spot_cam::PtzVelocity* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot_cam::PtzVelocity&>(
      ::bosdyn::api::spot_cam::_PtzVelocity_default_instance_);
}
inline const ::bosdyn::api::spot_cam::PtzVelocity& SetPtzVelocityRequest::velocity() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.SetPtzVelocityRequest.velocity)
  return _internal_velocity();
}
inline void SetPtzVelocityRequest::unsafe_arena_set_allocated_velocity(
    ::bosdyn::api::spot_cam::PtzVelocity* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.SetPtzVelocityRequest.velocity)
}
inline ::bosdyn::api::spot_cam::PtzVelocity* SetPtzVelocityRequest::release_velocity() {
  
  ::bosdyn::api::spot_cam::PtzVelocity* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzVelocity* SetPtzVelocityRequest::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.SetPtzVelocityRequest.velocity)
  
  ::bosdyn::api::spot_cam::PtzVelocity* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzVelocity* SetPtzVelocityRequest::_internal_mutable_velocity() {
  
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::PtzVelocity>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::bosdyn::api::spot_cam::PtzVelocity* SetPtzVelocityRequest::mutable_velocity() {
  ::bosdyn::api::spot_cam::PtzVelocity* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.SetPtzVelocityRequest.velocity)
  return _msg;
}
inline void SetPtzVelocityRequest::set_allocated_velocity(::bosdyn::api::spot_cam::PtzVelocity* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.SetPtzVelocityRequest.velocity)
}

// -------------------------------------------------------------------

// SetPtzVelocityResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool SetPtzVelocityResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SetPtzVelocityResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& SetPtzVelocityResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& SetPtzVelocityResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.SetPtzVelocityResponse.header)
  return _internal_header();
}
inline void SetPtzVelocityResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.SetPtzVelocityResponse.header)
}
inline ::bosdyn::api::ResponseHeader* SetPtzVelocityResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SetPtzVelocityResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.SetPtzVelocityResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SetPtzVelocityResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* SetPtzVelocityResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.SetPtzVelocityResponse.header)
  return _msg;
}
inline void SetPtzVelocityResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.SetPtzVelocityResponse.header)
}

// .bosdyn.api.spot_cam.PtzVelocity velocity = 2;
inline bool SetPtzVelocityResponse::_internal_has_velocity() const {
  return this != internal_default_instance() && _impl_.velocity_ != nullptr;
}
inline bool SetPtzVelocityResponse::has_velocity() const {
  return _internal_has_velocity();
}
inline void SetPtzVelocityResponse::clear_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.velocity_ != nullptr) {
    delete _impl_.velocity_;
  }
  _impl_.velocity_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::PtzVelocity& SetPtzVelocityResponse::_internal_velocity() const {
  const ::bosdyn::api::spot_cam::PtzVelocity* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot_cam::PtzVelocity&>(
      ::bosdyn::api::spot_cam::_PtzVelocity_default_instance_);
}
inline const ::bosdyn::api::spot_cam::PtzVelocity& SetPtzVelocityResponse::velocity() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.SetPtzVelocityResponse.velocity)
  return _internal_velocity();
}
inline void SetPtzVelocityResponse::unsafe_arena_set_allocated_velocity(
    ::bosdyn::api::spot_cam::PtzVelocity* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.SetPtzVelocityResponse.velocity)
}
inline ::bosdyn::api::spot_cam::PtzVelocity* SetPtzVelocityResponse::release_velocity() {
  
  ::bosdyn::api::spot_cam::PtzVelocity* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzVelocity* SetPtzVelocityResponse::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.SetPtzVelocityResponse.velocity)
  
  ::bosdyn::api::spot_cam::PtzVelocity* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzVelocity* SetPtzVelocityResponse::_internal_mutable_velocity() {
  
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::PtzVelocity>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::bosdyn::api::spot_cam::PtzVelocity* SetPtzVelocityResponse::mutable_velocity() {
  ::bosdyn::api::spot_cam::PtzVelocity* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.SetPtzVelocityResponse.velocity)
  return _msg;
}
inline void SetPtzVelocityResponse::set_allocated_velocity(::bosdyn::api::spot_cam::PtzVelocity* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.SetPtzVelocityResponse.velocity)
}

// -------------------------------------------------------------------

// InitializeLensRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool InitializeLensRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool InitializeLensRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& InitializeLensRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& InitializeLensRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.InitializeLensRequest.header)
  return _internal_header();
}
inline void InitializeLensRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.InitializeLensRequest.header)
}
inline ::bosdyn::api::RequestHeader* InitializeLensRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* InitializeLensRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.InitializeLensRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* InitializeLensRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* InitializeLensRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.InitializeLensRequest.header)
  return _msg;
}
inline void InitializeLensRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.InitializeLensRequest.header)
}

// -------------------------------------------------------------------

// InitializeLensResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool InitializeLensResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool InitializeLensResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& InitializeLensResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& InitializeLensResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.InitializeLensResponse.header)
  return _internal_header();
}
inline void InitializeLensResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.InitializeLensResponse.header)
}
inline ::bosdyn::api::ResponseHeader* InitializeLensResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* InitializeLensResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.InitializeLensResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* InitializeLensResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* InitializeLensResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.InitializeLensResponse.header)
  return _msg;
}
inline void InitializeLensResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.InitializeLensResponse.header)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace spot_cam
}  // namespace api
}  // namespace bosdyn

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_5fcam_2fptz_2eproto
