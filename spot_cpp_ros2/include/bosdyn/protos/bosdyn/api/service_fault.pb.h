// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/service_fault.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fservice_5ffault_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fservice_5ffault_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/header.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fservice_5ffault_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fservice_5ffault_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fservice_5ffault_2eproto;
namespace bosdyn {
namespace api {
class ClearServiceFaultRequest;
struct ClearServiceFaultRequestDefaultTypeInternal;
extern ClearServiceFaultRequestDefaultTypeInternal _ClearServiceFaultRequest_default_instance_;
class ClearServiceFaultResponse;
struct ClearServiceFaultResponseDefaultTypeInternal;
extern ClearServiceFaultResponseDefaultTypeInternal _ClearServiceFaultResponse_default_instance_;
class ServiceFault;
struct ServiceFaultDefaultTypeInternal;
extern ServiceFaultDefaultTypeInternal _ServiceFault_default_instance_;
class ServiceFaultId;
struct ServiceFaultIdDefaultTypeInternal;
extern ServiceFaultIdDefaultTypeInternal _ServiceFaultId_default_instance_;
class TriggerServiceFaultRequest;
struct TriggerServiceFaultRequestDefaultTypeInternal;
extern TriggerServiceFaultRequestDefaultTypeInternal _TriggerServiceFaultRequest_default_instance_;
class TriggerServiceFaultResponse;
struct TriggerServiceFaultResponseDefaultTypeInternal;
extern TriggerServiceFaultResponseDefaultTypeInternal _TriggerServiceFaultResponse_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::ClearServiceFaultRequest* Arena::CreateMaybeMessage<::bosdyn::api::ClearServiceFaultRequest>(Arena*);
template<> ::bosdyn::api::ClearServiceFaultResponse* Arena::CreateMaybeMessage<::bosdyn::api::ClearServiceFaultResponse>(Arena*);
template<> ::bosdyn::api::ServiceFault* Arena::CreateMaybeMessage<::bosdyn::api::ServiceFault>(Arena*);
template<> ::bosdyn::api::ServiceFaultId* Arena::CreateMaybeMessage<::bosdyn::api::ServiceFaultId>(Arena*);
template<> ::bosdyn::api::TriggerServiceFaultRequest* Arena::CreateMaybeMessage<::bosdyn::api::TriggerServiceFaultRequest>(Arena*);
template<> ::bosdyn::api::TriggerServiceFaultResponse* Arena::CreateMaybeMessage<::bosdyn::api::TriggerServiceFaultResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum ServiceFault_Severity : int {
  ServiceFault_Severity_SEVERITY_UNKNOWN = 0,
  ServiceFault_Severity_SEVERITY_INFO = 1,
  ServiceFault_Severity_SEVERITY_WARN = 2,
  ServiceFault_Severity_SEVERITY_CRITICAL = 3,
  ServiceFault_Severity_ServiceFault_Severity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ServiceFault_Severity_ServiceFault_Severity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ServiceFault_Severity_IsValid(int value);
constexpr ServiceFault_Severity ServiceFault_Severity_Severity_MIN = ServiceFault_Severity_SEVERITY_UNKNOWN;
constexpr ServiceFault_Severity ServiceFault_Severity_Severity_MAX = ServiceFault_Severity_SEVERITY_CRITICAL;
constexpr int ServiceFault_Severity_Severity_ARRAYSIZE = ServiceFault_Severity_Severity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceFault_Severity_descriptor();
template<typename T>
inline const std::string& ServiceFault_Severity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceFault_Severity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceFault_Severity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServiceFault_Severity_descriptor(), enum_t_value);
}
inline bool ServiceFault_Severity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceFault_Severity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServiceFault_Severity>(
    ServiceFault_Severity_descriptor(), name, value);
}
enum TriggerServiceFaultResponse_Status : int {
  TriggerServiceFaultResponse_Status_STATUS_UNKNOWN = 0,
  TriggerServiceFaultResponse_Status_STATUS_OK = 1,
  TriggerServiceFaultResponse_Status_STATUS_FAULT_ALREADY_ACTIVE = 2,
  TriggerServiceFaultResponse_Status_TriggerServiceFaultResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TriggerServiceFaultResponse_Status_TriggerServiceFaultResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TriggerServiceFaultResponse_Status_IsValid(int value);
constexpr TriggerServiceFaultResponse_Status TriggerServiceFaultResponse_Status_Status_MIN = TriggerServiceFaultResponse_Status_STATUS_UNKNOWN;
constexpr TriggerServiceFaultResponse_Status TriggerServiceFaultResponse_Status_Status_MAX = TriggerServiceFaultResponse_Status_STATUS_FAULT_ALREADY_ACTIVE;
constexpr int TriggerServiceFaultResponse_Status_Status_ARRAYSIZE = TriggerServiceFaultResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TriggerServiceFaultResponse_Status_descriptor();
template<typename T>
inline const std::string& TriggerServiceFaultResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TriggerServiceFaultResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TriggerServiceFaultResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TriggerServiceFaultResponse_Status_descriptor(), enum_t_value);
}
inline bool TriggerServiceFaultResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TriggerServiceFaultResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TriggerServiceFaultResponse_Status>(
    TriggerServiceFaultResponse_Status_descriptor(), name, value);
}
enum ClearServiceFaultResponse_Status : int {
  ClearServiceFaultResponse_Status_STATUS_UNKNOWN = 0,
  ClearServiceFaultResponse_Status_STATUS_OK = 1,
  ClearServiceFaultResponse_Status_STATUS_FAULT_NOT_ACTIVE = 2,
  ClearServiceFaultResponse_Status_ClearServiceFaultResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ClearServiceFaultResponse_Status_ClearServiceFaultResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ClearServiceFaultResponse_Status_IsValid(int value);
constexpr ClearServiceFaultResponse_Status ClearServiceFaultResponse_Status_Status_MIN = ClearServiceFaultResponse_Status_STATUS_UNKNOWN;
constexpr ClearServiceFaultResponse_Status ClearServiceFaultResponse_Status_Status_MAX = ClearServiceFaultResponse_Status_STATUS_FAULT_NOT_ACTIVE;
constexpr int ClearServiceFaultResponse_Status_Status_ARRAYSIZE = ClearServiceFaultResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClearServiceFaultResponse_Status_descriptor();
template<typename T>
inline const std::string& ClearServiceFaultResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClearServiceFaultResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClearServiceFaultResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClearServiceFaultResponse_Status_descriptor(), enum_t_value);
}
inline bool ClearServiceFaultResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClearServiceFaultResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClearServiceFaultResponse_Status>(
    ClearServiceFaultResponse_Status_descriptor(), name, value);
}
// ===================================================================

class ServiceFaultId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ServiceFaultId) */ {
 public:
  inline ServiceFaultId() : ServiceFaultId(nullptr) {}
  ~ServiceFaultId() override;
  explicit PROTOBUF_CONSTEXPR ServiceFaultId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceFaultId(const ServiceFaultId& from);
  ServiceFaultId(ServiceFaultId&& from) noexcept
    : ServiceFaultId() {
    *this = ::std::move(from);
  }

  inline ServiceFaultId& operator=(const ServiceFaultId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceFaultId& operator=(ServiceFaultId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceFaultId& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceFaultId* internal_default_instance() {
    return reinterpret_cast<const ServiceFaultId*>(
               &_ServiceFaultId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ServiceFaultId& a, ServiceFaultId& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceFaultId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceFaultId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceFaultId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceFaultId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceFaultId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceFaultId& from) {
    ServiceFaultId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceFaultId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ServiceFaultId";
  }
  protected:
  explicit ServiceFaultId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFaultNameFieldNumber = 1,
    kServiceNameFieldNumber = 2,
    kPayloadGuidFieldNumber = 3,
  };
  // string fault_name = 1;
  void clear_fault_name();
  const std::string& fault_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fault_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fault_name();
  PROTOBUF_NODISCARD std::string* release_fault_name();
  void set_allocated_fault_name(std::string* fault_name);
  private:
  const std::string& _internal_fault_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fault_name(const std::string& value);
  std::string* _internal_mutable_fault_name();
  public:

  // string service_name = 2;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string payload_guid = 3;
  void clear_payload_guid();
  const std::string& payload_guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload_guid();
  PROTOBUF_NODISCARD std::string* release_payload_guid();
  void set_allocated_payload_guid(std::string* payload_guid);
  private:
  const std::string& _internal_payload_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload_guid(const std::string& value);
  std::string* _internal_mutable_payload_guid();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ServiceFaultId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fault_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_guid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fservice_5ffault_2eproto;
};
// -------------------------------------------------------------------

class ServiceFault final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ServiceFault) */ {
 public:
  inline ServiceFault() : ServiceFault(nullptr) {}
  ~ServiceFault() override;
  explicit PROTOBUF_CONSTEXPR ServiceFault(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceFault(const ServiceFault& from);
  ServiceFault(ServiceFault&& from) noexcept
    : ServiceFault() {
    *this = ::std::move(from);
  }

  inline ServiceFault& operator=(const ServiceFault& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceFault& operator=(ServiceFault&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceFault& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceFault* internal_default_instance() {
    return reinterpret_cast<const ServiceFault*>(
               &_ServiceFault_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ServiceFault& a, ServiceFault& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceFault* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceFault* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceFault* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceFault>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceFault& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceFault& from) {
    ServiceFault::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceFault* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ServiceFault";
  }
  protected:
  explicit ServiceFault(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ServiceFault_Severity Severity;
  static constexpr Severity SEVERITY_UNKNOWN =
    ServiceFault_Severity_SEVERITY_UNKNOWN;
  static constexpr Severity SEVERITY_INFO =
    ServiceFault_Severity_SEVERITY_INFO;
  static constexpr Severity SEVERITY_WARN =
    ServiceFault_Severity_SEVERITY_WARN;
  static constexpr Severity SEVERITY_CRITICAL =
    ServiceFault_Severity_SEVERITY_CRITICAL;
  static inline bool Severity_IsValid(int value) {
    return ServiceFault_Severity_IsValid(value);
  }
  static constexpr Severity Severity_MIN =
    ServiceFault_Severity_Severity_MIN;
  static constexpr Severity Severity_MAX =
    ServiceFault_Severity_Severity_MAX;
  static constexpr int Severity_ARRAYSIZE =
    ServiceFault_Severity_Severity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Severity_descriptor() {
    return ServiceFault_Severity_descriptor();
  }
  template<typename T>
  static inline const std::string& Severity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Severity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Severity_Name.");
    return ServiceFault_Severity_Name(enum_t_value);
  }
  static inline bool Severity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Severity* value) {
    return ServiceFault_Severity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kErrorMessageFieldNumber = 2,
    kFaultIdFieldNumber = 1,
    kOnsetTimestampFieldNumber = 5,
    kDurationFieldNumber = 6,
    kSeverityFieldNumber = 4,
  };
  // repeated string attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  const std::string& attributes(int index) const;
  std::string* mutable_attributes(int index);
  void set_attributes(int index, const std::string& value);
  void set_attributes(int index, std::string&& value);
  void set_attributes(int index, const char* value);
  void set_attributes(int index, const char* value, size_t size);
  std::string* add_attributes();
  void add_attributes(const std::string& value);
  void add_attributes(std::string&& value);
  void add_attributes(const char* value);
  void add_attributes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& attributes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_attributes();
  private:
  const std::string& _internal_attributes(int index) const;
  std::string* _internal_add_attributes();
  public:

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .bosdyn.api.ServiceFaultId fault_id = 1;
  bool has_fault_id() const;
  private:
  bool _internal_has_fault_id() const;
  public:
  void clear_fault_id();
  const ::bosdyn::api::ServiceFaultId& fault_id() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ServiceFaultId* release_fault_id();
  ::bosdyn::api::ServiceFaultId* mutable_fault_id();
  void set_allocated_fault_id(::bosdyn::api::ServiceFaultId* fault_id);
  private:
  const ::bosdyn::api::ServiceFaultId& _internal_fault_id() const;
  ::bosdyn::api::ServiceFaultId* _internal_mutable_fault_id();
  public:
  void unsafe_arena_set_allocated_fault_id(
      ::bosdyn::api::ServiceFaultId* fault_id);
  ::bosdyn::api::ServiceFaultId* unsafe_arena_release_fault_id();

  // .google.protobuf.Timestamp onset_timestamp = 5;
  bool has_onset_timestamp() const;
  private:
  bool _internal_has_onset_timestamp() const;
  public:
  void clear_onset_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& onset_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_onset_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_onset_timestamp();
  void set_allocated_onset_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_onset_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_onset_timestamp();
  public:
  void unsafe_arena_set_allocated_onset_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_onset_timestamp();

  // .google.protobuf.Duration duration = 6;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_duration();
  void set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_duration();

  // .bosdyn.api.ServiceFault.Severity severity = 4;
  void clear_severity();
  ::bosdyn::api::ServiceFault_Severity severity() const;
  void set_severity(::bosdyn::api::ServiceFault_Severity value);
  private:
  ::bosdyn::api::ServiceFault_Severity _internal_severity() const;
  void _internal_set_severity(::bosdyn::api::ServiceFault_Severity value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ServiceFault)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::bosdyn::api::ServiceFaultId* fault_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp_;
    ::PROTOBUF_NAMESPACE_ID::Duration* duration_;
    int severity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fservice_5ffault_2eproto;
};
// -------------------------------------------------------------------

class TriggerServiceFaultRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.TriggerServiceFaultRequest) */ {
 public:
  inline TriggerServiceFaultRequest() : TriggerServiceFaultRequest(nullptr) {}
  ~TriggerServiceFaultRequest() override;
  explicit PROTOBUF_CONSTEXPR TriggerServiceFaultRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerServiceFaultRequest(const TriggerServiceFaultRequest& from);
  TriggerServiceFaultRequest(TriggerServiceFaultRequest&& from) noexcept
    : TriggerServiceFaultRequest() {
    *this = ::std::move(from);
  }

  inline TriggerServiceFaultRequest& operator=(const TriggerServiceFaultRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerServiceFaultRequest& operator=(TriggerServiceFaultRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TriggerServiceFaultRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerServiceFaultRequest* internal_default_instance() {
    return reinterpret_cast<const TriggerServiceFaultRequest*>(
               &_TriggerServiceFaultRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TriggerServiceFaultRequest& a, TriggerServiceFaultRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TriggerServiceFaultRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerServiceFaultRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerServiceFaultRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerServiceFaultRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TriggerServiceFaultRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TriggerServiceFaultRequest& from) {
    TriggerServiceFaultRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TriggerServiceFaultRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.TriggerServiceFaultRequest";
  }
  protected:
  explicit TriggerServiceFaultRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kFaultFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.ServiceFault fault = 2;
  bool has_fault() const;
  private:
  bool _internal_has_fault() const;
  public:
  void clear_fault();
  const ::bosdyn::api::ServiceFault& fault() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ServiceFault* release_fault();
  ::bosdyn::api::ServiceFault* mutable_fault();
  void set_allocated_fault(::bosdyn::api::ServiceFault* fault);
  private:
  const ::bosdyn::api::ServiceFault& _internal_fault() const;
  ::bosdyn::api::ServiceFault* _internal_mutable_fault();
  public:
  void unsafe_arena_set_allocated_fault(
      ::bosdyn::api::ServiceFault* fault);
  ::bosdyn::api::ServiceFault* unsafe_arena_release_fault();

  // @@protoc_insertion_point(class_scope:bosdyn.api.TriggerServiceFaultRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::ServiceFault* fault_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fservice_5ffault_2eproto;
};
// -------------------------------------------------------------------

class TriggerServiceFaultResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.TriggerServiceFaultResponse) */ {
 public:
  inline TriggerServiceFaultResponse() : TriggerServiceFaultResponse(nullptr) {}
  ~TriggerServiceFaultResponse() override;
  explicit PROTOBUF_CONSTEXPR TriggerServiceFaultResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerServiceFaultResponse(const TriggerServiceFaultResponse& from);
  TriggerServiceFaultResponse(TriggerServiceFaultResponse&& from) noexcept
    : TriggerServiceFaultResponse() {
    *this = ::std::move(from);
  }

  inline TriggerServiceFaultResponse& operator=(const TriggerServiceFaultResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerServiceFaultResponse& operator=(TriggerServiceFaultResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TriggerServiceFaultResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerServiceFaultResponse* internal_default_instance() {
    return reinterpret_cast<const TriggerServiceFaultResponse*>(
               &_TriggerServiceFaultResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TriggerServiceFaultResponse& a, TriggerServiceFaultResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TriggerServiceFaultResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerServiceFaultResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerServiceFaultResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerServiceFaultResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TriggerServiceFaultResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TriggerServiceFaultResponse& from) {
    TriggerServiceFaultResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TriggerServiceFaultResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.TriggerServiceFaultResponse";
  }
  protected:
  explicit TriggerServiceFaultResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TriggerServiceFaultResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    TriggerServiceFaultResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    TriggerServiceFaultResponse_Status_STATUS_OK;
  static constexpr Status STATUS_FAULT_ALREADY_ACTIVE =
    TriggerServiceFaultResponse_Status_STATUS_FAULT_ALREADY_ACTIVE;
  static inline bool Status_IsValid(int value) {
    return TriggerServiceFaultResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    TriggerServiceFaultResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    TriggerServiceFaultResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    TriggerServiceFaultResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return TriggerServiceFaultResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return TriggerServiceFaultResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return TriggerServiceFaultResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.TriggerServiceFaultResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::TriggerServiceFaultResponse_Status status() const;
  void set_status(::bosdyn::api::TriggerServiceFaultResponse_Status value);
  private:
  ::bosdyn::api::TriggerServiceFaultResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::TriggerServiceFaultResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.TriggerServiceFaultResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fservice_5ffault_2eproto;
};
// -------------------------------------------------------------------

class ClearServiceFaultRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ClearServiceFaultRequest) */ {
 public:
  inline ClearServiceFaultRequest() : ClearServiceFaultRequest(nullptr) {}
  ~ClearServiceFaultRequest() override;
  explicit PROTOBUF_CONSTEXPR ClearServiceFaultRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearServiceFaultRequest(const ClearServiceFaultRequest& from);
  ClearServiceFaultRequest(ClearServiceFaultRequest&& from) noexcept
    : ClearServiceFaultRequest() {
    *this = ::std::move(from);
  }

  inline ClearServiceFaultRequest& operator=(const ClearServiceFaultRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearServiceFaultRequest& operator=(ClearServiceFaultRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearServiceFaultRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearServiceFaultRequest* internal_default_instance() {
    return reinterpret_cast<const ClearServiceFaultRequest*>(
               &_ClearServiceFaultRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ClearServiceFaultRequest& a, ClearServiceFaultRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearServiceFaultRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearServiceFaultRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearServiceFaultRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearServiceFaultRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearServiceFaultRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearServiceFaultRequest& from) {
    ClearServiceFaultRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearServiceFaultRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ClearServiceFaultRequest";
  }
  protected:
  explicit ClearServiceFaultRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kFaultIdFieldNumber = 2,
    kClearAllServiceFaultsFieldNumber = 3,
    kClearAllPayloadFaultsFieldNumber = 4,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.ServiceFaultId fault_id = 2;
  bool has_fault_id() const;
  private:
  bool _internal_has_fault_id() const;
  public:
  void clear_fault_id();
  const ::bosdyn::api::ServiceFaultId& fault_id() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ServiceFaultId* release_fault_id();
  ::bosdyn::api::ServiceFaultId* mutable_fault_id();
  void set_allocated_fault_id(::bosdyn::api::ServiceFaultId* fault_id);
  private:
  const ::bosdyn::api::ServiceFaultId& _internal_fault_id() const;
  ::bosdyn::api::ServiceFaultId* _internal_mutable_fault_id();
  public:
  void unsafe_arena_set_allocated_fault_id(
      ::bosdyn::api::ServiceFaultId* fault_id);
  ::bosdyn::api::ServiceFaultId* unsafe_arena_release_fault_id();

  // bool clear_all_service_faults = 3;
  void clear_clear_all_service_faults();
  bool clear_all_service_faults() const;
  void set_clear_all_service_faults(bool value);
  private:
  bool _internal_clear_all_service_faults() const;
  void _internal_set_clear_all_service_faults(bool value);
  public:

  // bool clear_all_payload_faults = 4;
  void clear_clear_all_payload_faults();
  bool clear_all_payload_faults() const;
  void set_clear_all_payload_faults(bool value);
  private:
  bool _internal_clear_all_payload_faults() const;
  void _internal_set_clear_all_payload_faults(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ClearServiceFaultRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::ServiceFaultId* fault_id_;
    bool clear_all_service_faults_;
    bool clear_all_payload_faults_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fservice_5ffault_2eproto;
};
// -------------------------------------------------------------------

class ClearServiceFaultResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ClearServiceFaultResponse) */ {
 public:
  inline ClearServiceFaultResponse() : ClearServiceFaultResponse(nullptr) {}
  ~ClearServiceFaultResponse() override;
  explicit PROTOBUF_CONSTEXPR ClearServiceFaultResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearServiceFaultResponse(const ClearServiceFaultResponse& from);
  ClearServiceFaultResponse(ClearServiceFaultResponse&& from) noexcept
    : ClearServiceFaultResponse() {
    *this = ::std::move(from);
  }

  inline ClearServiceFaultResponse& operator=(const ClearServiceFaultResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearServiceFaultResponse& operator=(ClearServiceFaultResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearServiceFaultResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearServiceFaultResponse* internal_default_instance() {
    return reinterpret_cast<const ClearServiceFaultResponse*>(
               &_ClearServiceFaultResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ClearServiceFaultResponse& a, ClearServiceFaultResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearServiceFaultResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearServiceFaultResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearServiceFaultResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearServiceFaultResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearServiceFaultResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearServiceFaultResponse& from) {
    ClearServiceFaultResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearServiceFaultResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ClearServiceFaultResponse";
  }
  protected:
  explicit ClearServiceFaultResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClearServiceFaultResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    ClearServiceFaultResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    ClearServiceFaultResponse_Status_STATUS_OK;
  static constexpr Status STATUS_FAULT_NOT_ACTIVE =
    ClearServiceFaultResponse_Status_STATUS_FAULT_NOT_ACTIVE;
  static inline bool Status_IsValid(int value) {
    return ClearServiceFaultResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ClearServiceFaultResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ClearServiceFaultResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ClearServiceFaultResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return ClearServiceFaultResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ClearServiceFaultResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return ClearServiceFaultResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.ClearServiceFaultResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::ClearServiceFaultResponse_Status status() const;
  void set_status(::bosdyn::api::ClearServiceFaultResponse_Status value);
  private:
  ::bosdyn::api::ClearServiceFaultResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::ClearServiceFaultResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ClearServiceFaultResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fservice_5ffault_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ServiceFaultId

// string fault_name = 1;
inline void ServiceFaultId::clear_fault_name() {
  _impl_.fault_name_.ClearToEmpty();
}
inline const std::string& ServiceFaultId::fault_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ServiceFaultId.fault_name)
  return _internal_fault_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceFaultId::set_fault_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fault_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.ServiceFaultId.fault_name)
}
inline std::string* ServiceFaultId::mutable_fault_name() {
  std::string* _s = _internal_mutable_fault_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ServiceFaultId.fault_name)
  return _s;
}
inline const std::string& ServiceFaultId::_internal_fault_name() const {
  return _impl_.fault_name_.Get();
}
inline void ServiceFaultId::_internal_set_fault_name(const std::string& value) {
  
  _impl_.fault_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceFaultId::_internal_mutable_fault_name() {
  
  return _impl_.fault_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceFaultId::release_fault_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ServiceFaultId.fault_name)
  return _impl_.fault_name_.Release();
}
inline void ServiceFaultId::set_allocated_fault_name(std::string* fault_name) {
  if (fault_name != nullptr) {
    
  } else {
    
  }
  _impl_.fault_name_.SetAllocated(fault_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fault_name_.IsDefault()) {
    _impl_.fault_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ServiceFaultId.fault_name)
}

// string service_name = 2;
inline void ServiceFaultId::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& ServiceFaultId::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ServiceFaultId.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceFaultId::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.ServiceFaultId.service_name)
}
inline std::string* ServiceFaultId::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ServiceFaultId.service_name)
  return _s;
}
inline const std::string& ServiceFaultId::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void ServiceFaultId::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceFaultId::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceFaultId::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ServiceFaultId.service_name)
  return _impl_.service_name_.Release();
}
inline void ServiceFaultId::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ServiceFaultId.service_name)
}

// string payload_guid = 3;
inline void ServiceFaultId::clear_payload_guid() {
  _impl_.payload_guid_.ClearToEmpty();
}
inline const std::string& ServiceFaultId::payload_guid() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ServiceFaultId.payload_guid)
  return _internal_payload_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceFaultId::set_payload_guid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_guid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.ServiceFaultId.payload_guid)
}
inline std::string* ServiceFaultId::mutable_payload_guid() {
  std::string* _s = _internal_mutable_payload_guid();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ServiceFaultId.payload_guid)
  return _s;
}
inline const std::string& ServiceFaultId::_internal_payload_guid() const {
  return _impl_.payload_guid_.Get();
}
inline void ServiceFaultId::_internal_set_payload_guid(const std::string& value) {
  
  _impl_.payload_guid_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceFaultId::_internal_mutable_payload_guid() {
  
  return _impl_.payload_guid_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceFaultId::release_payload_guid() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ServiceFaultId.payload_guid)
  return _impl_.payload_guid_.Release();
}
inline void ServiceFaultId::set_allocated_payload_guid(std::string* payload_guid) {
  if (payload_guid != nullptr) {
    
  } else {
    
  }
  _impl_.payload_guid_.SetAllocated(payload_guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_guid_.IsDefault()) {
    _impl_.payload_guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ServiceFaultId.payload_guid)
}

// -------------------------------------------------------------------

// ServiceFault

// .bosdyn.api.ServiceFaultId fault_id = 1;
inline bool ServiceFault::_internal_has_fault_id() const {
  return this != internal_default_instance() && _impl_.fault_id_ != nullptr;
}
inline bool ServiceFault::has_fault_id() const {
  return _internal_has_fault_id();
}
inline void ServiceFault::clear_fault_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.fault_id_ != nullptr) {
    delete _impl_.fault_id_;
  }
  _impl_.fault_id_ = nullptr;
}
inline const ::bosdyn::api::ServiceFaultId& ServiceFault::_internal_fault_id() const {
  const ::bosdyn::api::ServiceFaultId* p = _impl_.fault_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ServiceFaultId&>(
      ::bosdyn::api::_ServiceFaultId_default_instance_);
}
inline const ::bosdyn::api::ServiceFaultId& ServiceFault::fault_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ServiceFault.fault_id)
  return _internal_fault_id();
}
inline void ServiceFault::unsafe_arena_set_allocated_fault_id(
    ::bosdyn::api::ServiceFaultId* fault_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fault_id_);
  }
  _impl_.fault_id_ = fault_id;
  if (fault_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ServiceFault.fault_id)
}
inline ::bosdyn::api::ServiceFaultId* ServiceFault::release_fault_id() {
  
  ::bosdyn::api::ServiceFaultId* temp = _impl_.fault_id_;
  _impl_.fault_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ServiceFaultId* ServiceFault::unsafe_arena_release_fault_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ServiceFault.fault_id)
  
  ::bosdyn::api::ServiceFaultId* temp = _impl_.fault_id_;
  _impl_.fault_id_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ServiceFaultId* ServiceFault::_internal_mutable_fault_id() {
  
  if (_impl_.fault_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ServiceFaultId>(GetArenaForAllocation());
    _impl_.fault_id_ = p;
  }
  return _impl_.fault_id_;
}
inline ::bosdyn::api::ServiceFaultId* ServiceFault::mutable_fault_id() {
  ::bosdyn::api::ServiceFaultId* _msg = _internal_mutable_fault_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ServiceFault.fault_id)
  return _msg;
}
inline void ServiceFault::set_allocated_fault_id(::bosdyn::api::ServiceFaultId* fault_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fault_id_;
  }
  if (fault_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fault_id);
    if (message_arena != submessage_arena) {
      fault_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fault_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fault_id_ = fault_id;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ServiceFault.fault_id)
}

// string error_message = 2;
inline void ServiceFault::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& ServiceFault::error_message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ServiceFault.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceFault::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.ServiceFault.error_message)
}
inline std::string* ServiceFault::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ServiceFault.error_message)
  return _s;
}
inline const std::string& ServiceFault::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void ServiceFault::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceFault::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceFault::release_error_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ServiceFault.error_message)
  return _impl_.error_message_.Release();
}
inline void ServiceFault::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ServiceFault.error_message)
}

// repeated string attributes = 3;
inline int ServiceFault::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int ServiceFault::attributes_size() const {
  return _internal_attributes_size();
}
inline void ServiceFault::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline std::string* ServiceFault::add_attributes() {
  std::string* _s = _internal_add_attributes();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.ServiceFault.attributes)
  return _s;
}
inline const std::string& ServiceFault::_internal_attributes(int index) const {
  return _impl_.attributes_.Get(index);
}
inline const std::string& ServiceFault::attributes(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ServiceFault.attributes)
  return _internal_attributes(index);
}
inline std::string* ServiceFault::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ServiceFault.attributes)
  return _impl_.attributes_.Mutable(index);
}
inline void ServiceFault::set_attributes(int index, const std::string& value) {
  _impl_.attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ServiceFault.attributes)
}
inline void ServiceFault::set_attributes(int index, std::string&& value) {
  _impl_.attributes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.ServiceFault.attributes)
}
inline void ServiceFault::set_attributes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.ServiceFault.attributes)
}
inline void ServiceFault::set_attributes(int index, const char* value, size_t size) {
  _impl_.attributes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.ServiceFault.attributes)
}
inline std::string* ServiceFault::_internal_add_attributes() {
  return _impl_.attributes_.Add();
}
inline void ServiceFault::add_attributes(const std::string& value) {
  _impl_.attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.ServiceFault.attributes)
}
inline void ServiceFault::add_attributes(std::string&& value) {
  _impl_.attributes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.ServiceFault.attributes)
}
inline void ServiceFault::add_attributes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.ServiceFault.attributes)
}
inline void ServiceFault::add_attributes(const char* value, size_t size) {
  _impl_.attributes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.ServiceFault.attributes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServiceFault::attributes() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ServiceFault.attributes)
  return _impl_.attributes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ServiceFault::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ServiceFault.attributes)
  return &_impl_.attributes_;
}

// .bosdyn.api.ServiceFault.Severity severity = 4;
inline void ServiceFault::clear_severity() {
  _impl_.severity_ = 0;
}
inline ::bosdyn::api::ServiceFault_Severity ServiceFault::_internal_severity() const {
  return static_cast< ::bosdyn::api::ServiceFault_Severity >(_impl_.severity_);
}
inline ::bosdyn::api::ServiceFault_Severity ServiceFault::severity() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ServiceFault.severity)
  return _internal_severity();
}
inline void ServiceFault::_internal_set_severity(::bosdyn::api::ServiceFault_Severity value) {
  
  _impl_.severity_ = value;
}
inline void ServiceFault::set_severity(::bosdyn::api::ServiceFault_Severity value) {
  _internal_set_severity(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ServiceFault.severity)
}

// .google.protobuf.Timestamp onset_timestamp = 5;
inline bool ServiceFault::_internal_has_onset_timestamp() const {
  return this != internal_default_instance() && _impl_.onset_timestamp_ != nullptr;
}
inline bool ServiceFault::has_onset_timestamp() const {
  return _internal_has_onset_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ServiceFault::_internal_onset_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.onset_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ServiceFault::onset_timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ServiceFault.onset_timestamp)
  return _internal_onset_timestamp();
}
inline void ServiceFault::unsafe_arena_set_allocated_onset_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.onset_timestamp_);
  }
  _impl_.onset_timestamp_ = onset_timestamp;
  if (onset_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ServiceFault.onset_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceFault::release_onset_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.onset_timestamp_;
  _impl_.onset_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceFault::unsafe_arena_release_onset_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ServiceFault.onset_timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.onset_timestamp_;
  _impl_.onset_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceFault::_internal_mutable_onset_timestamp() {
  
  if (_impl_.onset_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.onset_timestamp_ = p;
  }
  return _impl_.onset_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceFault::mutable_onset_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_onset_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ServiceFault.onset_timestamp)
  return _msg;
}
inline void ServiceFault::set_allocated_onset_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.onset_timestamp_);
  }
  if (onset_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(onset_timestamp));
    if (message_arena != submessage_arena) {
      onset_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, onset_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.onset_timestamp_ = onset_timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ServiceFault.onset_timestamp)
}

// .google.protobuf.Duration duration = 6;
inline bool ServiceFault::_internal_has_duration() const {
  return this != internal_default_instance() && _impl_.duration_ != nullptr;
}
inline bool ServiceFault::has_duration() const {
  return _internal_has_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ServiceFault::_internal_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ServiceFault::duration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ServiceFault.duration)
  return _internal_duration();
}
inline void ServiceFault::unsafe_arena_set_allocated_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_);
  }
  _impl_.duration_ = duration;
  if (duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ServiceFault.duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ServiceFault::release_duration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ServiceFault::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ServiceFault.duration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ServiceFault::_internal_mutable_duration() {
  
  if (_impl_.duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.duration_ = p;
  }
  return _impl_.duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ServiceFault::mutable_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ServiceFault.duration)
  return _msg;
}
inline void ServiceFault::set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_);
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration));
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ServiceFault.duration)
}

// -------------------------------------------------------------------

// TriggerServiceFaultRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool TriggerServiceFaultRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool TriggerServiceFaultRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& TriggerServiceFaultRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& TriggerServiceFaultRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TriggerServiceFaultRequest.header)
  return _internal_header();
}
inline void TriggerServiceFaultRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.TriggerServiceFaultRequest.header)
}
inline ::bosdyn::api::RequestHeader* TriggerServiceFaultRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* TriggerServiceFaultRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.TriggerServiceFaultRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* TriggerServiceFaultRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* TriggerServiceFaultRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.TriggerServiceFaultRequest.header)
  return _msg;
}
inline void TriggerServiceFaultRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.TriggerServiceFaultRequest.header)
}

// .bosdyn.api.ServiceFault fault = 2;
inline bool TriggerServiceFaultRequest::_internal_has_fault() const {
  return this != internal_default_instance() && _impl_.fault_ != nullptr;
}
inline bool TriggerServiceFaultRequest::has_fault() const {
  return _internal_has_fault();
}
inline void TriggerServiceFaultRequest::clear_fault() {
  if (GetArenaForAllocation() == nullptr && _impl_.fault_ != nullptr) {
    delete _impl_.fault_;
  }
  _impl_.fault_ = nullptr;
}
inline const ::bosdyn::api::ServiceFault& TriggerServiceFaultRequest::_internal_fault() const {
  const ::bosdyn::api::ServiceFault* p = _impl_.fault_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ServiceFault&>(
      ::bosdyn::api::_ServiceFault_default_instance_);
}
inline const ::bosdyn::api::ServiceFault& TriggerServiceFaultRequest::fault() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TriggerServiceFaultRequest.fault)
  return _internal_fault();
}
inline void TriggerServiceFaultRequest::unsafe_arena_set_allocated_fault(
    ::bosdyn::api::ServiceFault* fault) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fault_);
  }
  _impl_.fault_ = fault;
  if (fault) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.TriggerServiceFaultRequest.fault)
}
inline ::bosdyn::api::ServiceFault* TriggerServiceFaultRequest::release_fault() {
  
  ::bosdyn::api::ServiceFault* temp = _impl_.fault_;
  _impl_.fault_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ServiceFault* TriggerServiceFaultRequest::unsafe_arena_release_fault() {
  // @@protoc_insertion_point(field_release:bosdyn.api.TriggerServiceFaultRequest.fault)
  
  ::bosdyn::api::ServiceFault* temp = _impl_.fault_;
  _impl_.fault_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ServiceFault* TriggerServiceFaultRequest::_internal_mutable_fault() {
  
  if (_impl_.fault_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ServiceFault>(GetArenaForAllocation());
    _impl_.fault_ = p;
  }
  return _impl_.fault_;
}
inline ::bosdyn::api::ServiceFault* TriggerServiceFaultRequest::mutable_fault() {
  ::bosdyn::api::ServiceFault* _msg = _internal_mutable_fault();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.TriggerServiceFaultRequest.fault)
  return _msg;
}
inline void TriggerServiceFaultRequest::set_allocated_fault(::bosdyn::api::ServiceFault* fault) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fault_;
  }
  if (fault) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fault);
    if (message_arena != submessage_arena) {
      fault = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fault, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fault_ = fault;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.TriggerServiceFaultRequest.fault)
}

// -------------------------------------------------------------------

// TriggerServiceFaultResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool TriggerServiceFaultResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool TriggerServiceFaultResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& TriggerServiceFaultResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& TriggerServiceFaultResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TriggerServiceFaultResponse.header)
  return _internal_header();
}
inline void TriggerServiceFaultResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.TriggerServiceFaultResponse.header)
}
inline ::bosdyn::api::ResponseHeader* TriggerServiceFaultResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* TriggerServiceFaultResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.TriggerServiceFaultResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* TriggerServiceFaultResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* TriggerServiceFaultResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.TriggerServiceFaultResponse.header)
  return _msg;
}
inline void TriggerServiceFaultResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.TriggerServiceFaultResponse.header)
}

// .bosdyn.api.TriggerServiceFaultResponse.Status status = 2;
inline void TriggerServiceFaultResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::TriggerServiceFaultResponse_Status TriggerServiceFaultResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::TriggerServiceFaultResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::TriggerServiceFaultResponse_Status TriggerServiceFaultResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TriggerServiceFaultResponse.status)
  return _internal_status();
}
inline void TriggerServiceFaultResponse::_internal_set_status(::bosdyn::api::TriggerServiceFaultResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void TriggerServiceFaultResponse::set_status(::bosdyn::api::TriggerServiceFaultResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.TriggerServiceFaultResponse.status)
}

// -------------------------------------------------------------------

// ClearServiceFaultRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ClearServiceFaultRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ClearServiceFaultRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ClearServiceFaultRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ClearServiceFaultRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ClearServiceFaultRequest.header)
  return _internal_header();
}
inline void ClearServiceFaultRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ClearServiceFaultRequest.header)
}
inline ::bosdyn::api::RequestHeader* ClearServiceFaultRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ClearServiceFaultRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ClearServiceFaultRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ClearServiceFaultRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ClearServiceFaultRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ClearServiceFaultRequest.header)
  return _msg;
}
inline void ClearServiceFaultRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ClearServiceFaultRequest.header)
}

// .bosdyn.api.ServiceFaultId fault_id = 2;
inline bool ClearServiceFaultRequest::_internal_has_fault_id() const {
  return this != internal_default_instance() && _impl_.fault_id_ != nullptr;
}
inline bool ClearServiceFaultRequest::has_fault_id() const {
  return _internal_has_fault_id();
}
inline void ClearServiceFaultRequest::clear_fault_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.fault_id_ != nullptr) {
    delete _impl_.fault_id_;
  }
  _impl_.fault_id_ = nullptr;
}
inline const ::bosdyn::api::ServiceFaultId& ClearServiceFaultRequest::_internal_fault_id() const {
  const ::bosdyn::api::ServiceFaultId* p = _impl_.fault_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ServiceFaultId&>(
      ::bosdyn::api::_ServiceFaultId_default_instance_);
}
inline const ::bosdyn::api::ServiceFaultId& ClearServiceFaultRequest::fault_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ClearServiceFaultRequest.fault_id)
  return _internal_fault_id();
}
inline void ClearServiceFaultRequest::unsafe_arena_set_allocated_fault_id(
    ::bosdyn::api::ServiceFaultId* fault_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fault_id_);
  }
  _impl_.fault_id_ = fault_id;
  if (fault_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ClearServiceFaultRequest.fault_id)
}
inline ::bosdyn::api::ServiceFaultId* ClearServiceFaultRequest::release_fault_id() {
  
  ::bosdyn::api::ServiceFaultId* temp = _impl_.fault_id_;
  _impl_.fault_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ServiceFaultId* ClearServiceFaultRequest::unsafe_arena_release_fault_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ClearServiceFaultRequest.fault_id)
  
  ::bosdyn::api::ServiceFaultId* temp = _impl_.fault_id_;
  _impl_.fault_id_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ServiceFaultId* ClearServiceFaultRequest::_internal_mutable_fault_id() {
  
  if (_impl_.fault_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ServiceFaultId>(GetArenaForAllocation());
    _impl_.fault_id_ = p;
  }
  return _impl_.fault_id_;
}
inline ::bosdyn::api::ServiceFaultId* ClearServiceFaultRequest::mutable_fault_id() {
  ::bosdyn::api::ServiceFaultId* _msg = _internal_mutable_fault_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ClearServiceFaultRequest.fault_id)
  return _msg;
}
inline void ClearServiceFaultRequest::set_allocated_fault_id(::bosdyn::api::ServiceFaultId* fault_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fault_id_;
  }
  if (fault_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fault_id);
    if (message_arena != submessage_arena) {
      fault_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fault_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fault_id_ = fault_id;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ClearServiceFaultRequest.fault_id)
}

// bool clear_all_service_faults = 3;
inline void ClearServiceFaultRequest::clear_clear_all_service_faults() {
  _impl_.clear_all_service_faults_ = false;
}
inline bool ClearServiceFaultRequest::_internal_clear_all_service_faults() const {
  return _impl_.clear_all_service_faults_;
}
inline bool ClearServiceFaultRequest::clear_all_service_faults() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ClearServiceFaultRequest.clear_all_service_faults)
  return _internal_clear_all_service_faults();
}
inline void ClearServiceFaultRequest::_internal_set_clear_all_service_faults(bool value) {
  
  _impl_.clear_all_service_faults_ = value;
}
inline void ClearServiceFaultRequest::set_clear_all_service_faults(bool value) {
  _internal_set_clear_all_service_faults(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ClearServiceFaultRequest.clear_all_service_faults)
}

// bool clear_all_payload_faults = 4;
inline void ClearServiceFaultRequest::clear_clear_all_payload_faults() {
  _impl_.clear_all_payload_faults_ = false;
}
inline bool ClearServiceFaultRequest::_internal_clear_all_payload_faults() const {
  return _impl_.clear_all_payload_faults_;
}
inline bool ClearServiceFaultRequest::clear_all_payload_faults() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ClearServiceFaultRequest.clear_all_payload_faults)
  return _internal_clear_all_payload_faults();
}
inline void ClearServiceFaultRequest::_internal_set_clear_all_payload_faults(bool value) {
  
  _impl_.clear_all_payload_faults_ = value;
}
inline void ClearServiceFaultRequest::set_clear_all_payload_faults(bool value) {
  _internal_set_clear_all_payload_faults(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ClearServiceFaultRequest.clear_all_payload_faults)
}

// -------------------------------------------------------------------

// ClearServiceFaultResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ClearServiceFaultResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ClearServiceFaultResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ClearServiceFaultResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ClearServiceFaultResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ClearServiceFaultResponse.header)
  return _internal_header();
}
inline void ClearServiceFaultResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ClearServiceFaultResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ClearServiceFaultResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ClearServiceFaultResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ClearServiceFaultResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ClearServiceFaultResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ClearServiceFaultResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ClearServiceFaultResponse.header)
  return _msg;
}
inline void ClearServiceFaultResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ClearServiceFaultResponse.header)
}

// .bosdyn.api.ClearServiceFaultResponse.Status status = 2;
inline void ClearServiceFaultResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::ClearServiceFaultResponse_Status ClearServiceFaultResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::ClearServiceFaultResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::ClearServiceFaultResponse_Status ClearServiceFaultResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ClearServiceFaultResponse.status)
  return _internal_status();
}
inline void ClearServiceFaultResponse::_internal_set_status(::bosdyn::api::ClearServiceFaultResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void ClearServiceFaultResponse::set_status(::bosdyn::api::ClearServiceFaultResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ClearServiceFaultResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::ServiceFault_Severity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ServiceFault_Severity>() {
  return ::bosdyn::api::ServiceFault_Severity_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::TriggerServiceFaultResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::TriggerServiceFaultResponse_Status>() {
  return ::bosdyn::api::TriggerServiceFaultResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::ClearServiceFaultResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ClearServiceFaultResponse_Status>() {
  return ::bosdyn::api::ClearServiceFaultResponse_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fservice_5ffault_2eproto
