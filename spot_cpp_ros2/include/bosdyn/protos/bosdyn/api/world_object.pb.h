// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/world_object.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fworld_5fobject_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fworld_5fobject_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/docking/docking.pb.h"
#include "bosdyn/api/geometry.pb.h"
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/image.pb.h"
#include "bosdyn/api/sparse_features.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fworld_5fobject_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fworld_5fobject_2eproto;
namespace bosdyn {
namespace api {
class AprilTagProperties;
struct AprilTagPropertiesDefaultTypeInternal;
extern AprilTagPropertiesDefaultTypeInternal _AprilTagProperties_default_instance_;
class BoundingBoxProperties;
struct BoundingBoxPropertiesDefaultTypeInternal;
extern BoundingBoxPropertiesDefaultTypeInternal _BoundingBoxProperties_default_instance_;
class DockProperties;
struct DockPropertiesDefaultTypeInternal;
extern DockPropertiesDefaultTypeInternal _DockProperties_default_instance_;
class DrawableArrow;
struct DrawableArrowDefaultTypeInternal;
extern DrawableArrowDefaultTypeInternal _DrawableArrow_default_instance_;
class DrawableBox;
struct DrawableBoxDefaultTypeInternal;
extern DrawableBoxDefaultTypeInternal _DrawableBox_default_instance_;
class DrawableCapsule;
struct DrawableCapsuleDefaultTypeInternal;
extern DrawableCapsuleDefaultTypeInternal _DrawableCapsule_default_instance_;
class DrawableCylinder;
struct DrawableCylinderDefaultTypeInternal;
extern DrawableCylinderDefaultTypeInternal _DrawableCylinder_default_instance_;
class DrawableFrame;
struct DrawableFrameDefaultTypeInternal;
extern DrawableFrameDefaultTypeInternal _DrawableFrame_default_instance_;
class DrawableLineStrip;
struct DrawableLineStripDefaultTypeInternal;
extern DrawableLineStripDefaultTypeInternal _DrawableLineStrip_default_instance_;
class DrawablePoints;
struct DrawablePointsDefaultTypeInternal;
extern DrawablePointsDefaultTypeInternal _DrawablePoints_default_instance_;
class DrawableProperties;
struct DrawablePropertiesDefaultTypeInternal;
extern DrawablePropertiesDefaultTypeInternal _DrawableProperties_default_instance_;
class DrawableProperties_Color;
struct DrawableProperties_ColorDefaultTypeInternal;
extern DrawableProperties_ColorDefaultTypeInternal _DrawableProperties_Color_default_instance_;
class DrawableSphere;
struct DrawableSphereDefaultTypeInternal;
extern DrawableSphereDefaultTypeInternal _DrawableSphere_default_instance_;
class ImageProperties;
struct ImagePropertiesDefaultTypeInternal;
extern ImagePropertiesDefaultTypeInternal _ImageProperties_default_instance_;
class ListWorldObjectRequest;
struct ListWorldObjectRequestDefaultTypeInternal;
extern ListWorldObjectRequestDefaultTypeInternal _ListWorldObjectRequest_default_instance_;
class ListWorldObjectResponse;
struct ListWorldObjectResponseDefaultTypeInternal;
extern ListWorldObjectResponseDefaultTypeInternal _ListWorldObjectResponse_default_instance_;
class MutateWorldObjectRequest;
struct MutateWorldObjectRequestDefaultTypeInternal;
extern MutateWorldObjectRequestDefaultTypeInternal _MutateWorldObjectRequest_default_instance_;
class MutateWorldObjectRequest_Mutation;
struct MutateWorldObjectRequest_MutationDefaultTypeInternal;
extern MutateWorldObjectRequest_MutationDefaultTypeInternal _MutateWorldObjectRequest_Mutation_default_instance_;
class MutateWorldObjectResponse;
struct MutateWorldObjectResponseDefaultTypeInternal;
extern MutateWorldObjectResponseDefaultTypeInternal _MutateWorldObjectResponse_default_instance_;
class RayProperties;
struct RayPropertiesDefaultTypeInternal;
extern RayPropertiesDefaultTypeInternal _RayProperties_default_instance_;
class WorldObject;
struct WorldObjectDefaultTypeInternal;
extern WorldObjectDefaultTypeInternal _WorldObject_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::AprilTagProperties* Arena::CreateMaybeMessage<::bosdyn::api::AprilTagProperties>(Arena*);
template<> ::bosdyn::api::BoundingBoxProperties* Arena::CreateMaybeMessage<::bosdyn::api::BoundingBoxProperties>(Arena*);
template<> ::bosdyn::api::DockProperties* Arena::CreateMaybeMessage<::bosdyn::api::DockProperties>(Arena*);
template<> ::bosdyn::api::DrawableArrow* Arena::CreateMaybeMessage<::bosdyn::api::DrawableArrow>(Arena*);
template<> ::bosdyn::api::DrawableBox* Arena::CreateMaybeMessage<::bosdyn::api::DrawableBox>(Arena*);
template<> ::bosdyn::api::DrawableCapsule* Arena::CreateMaybeMessage<::bosdyn::api::DrawableCapsule>(Arena*);
template<> ::bosdyn::api::DrawableCylinder* Arena::CreateMaybeMessage<::bosdyn::api::DrawableCylinder>(Arena*);
template<> ::bosdyn::api::DrawableFrame* Arena::CreateMaybeMessage<::bosdyn::api::DrawableFrame>(Arena*);
template<> ::bosdyn::api::DrawableLineStrip* Arena::CreateMaybeMessage<::bosdyn::api::DrawableLineStrip>(Arena*);
template<> ::bosdyn::api::DrawablePoints* Arena::CreateMaybeMessage<::bosdyn::api::DrawablePoints>(Arena*);
template<> ::bosdyn::api::DrawableProperties* Arena::CreateMaybeMessage<::bosdyn::api::DrawableProperties>(Arena*);
template<> ::bosdyn::api::DrawableProperties_Color* Arena::CreateMaybeMessage<::bosdyn::api::DrawableProperties_Color>(Arena*);
template<> ::bosdyn::api::DrawableSphere* Arena::CreateMaybeMessage<::bosdyn::api::DrawableSphere>(Arena*);
template<> ::bosdyn::api::ImageProperties* Arena::CreateMaybeMessage<::bosdyn::api::ImageProperties>(Arena*);
template<> ::bosdyn::api::ListWorldObjectRequest* Arena::CreateMaybeMessage<::bosdyn::api::ListWorldObjectRequest>(Arena*);
template<> ::bosdyn::api::ListWorldObjectResponse* Arena::CreateMaybeMessage<::bosdyn::api::ListWorldObjectResponse>(Arena*);
template<> ::bosdyn::api::MutateWorldObjectRequest* Arena::CreateMaybeMessage<::bosdyn::api::MutateWorldObjectRequest>(Arena*);
template<> ::bosdyn::api::MutateWorldObjectRequest_Mutation* Arena::CreateMaybeMessage<::bosdyn::api::MutateWorldObjectRequest_Mutation>(Arena*);
template<> ::bosdyn::api::MutateWorldObjectResponse* Arena::CreateMaybeMessage<::bosdyn::api::MutateWorldObjectResponse>(Arena*);
template<> ::bosdyn::api::RayProperties* Arena::CreateMaybeMessage<::bosdyn::api::RayProperties>(Arena*);
template<> ::bosdyn::api::WorldObject* Arena::CreateMaybeMessage<::bosdyn::api::WorldObject>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum MutateWorldObjectRequest_Action : int {
  MutateWorldObjectRequest_Action_ACTION_UNKNOWN = 0,
  MutateWorldObjectRequest_Action_ACTION_ADD = 1,
  MutateWorldObjectRequest_Action_ACTION_CHANGE = 2,
  MutateWorldObjectRequest_Action_ACTION_DELETE = 3,
  MutateWorldObjectRequest_Action_MutateWorldObjectRequest_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MutateWorldObjectRequest_Action_MutateWorldObjectRequest_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MutateWorldObjectRequest_Action_IsValid(int value);
constexpr MutateWorldObjectRequest_Action MutateWorldObjectRequest_Action_Action_MIN = MutateWorldObjectRequest_Action_ACTION_UNKNOWN;
constexpr MutateWorldObjectRequest_Action MutateWorldObjectRequest_Action_Action_MAX = MutateWorldObjectRequest_Action_ACTION_DELETE;
constexpr int MutateWorldObjectRequest_Action_Action_ARRAYSIZE = MutateWorldObjectRequest_Action_Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MutateWorldObjectRequest_Action_descriptor();
template<typename T>
inline const std::string& MutateWorldObjectRequest_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MutateWorldObjectRequest_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MutateWorldObjectRequest_Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MutateWorldObjectRequest_Action_descriptor(), enum_t_value);
}
inline bool MutateWorldObjectRequest_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MutateWorldObjectRequest_Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MutateWorldObjectRequest_Action>(
    MutateWorldObjectRequest_Action_descriptor(), name, value);
}
enum MutateWorldObjectResponse_Status : int {
  MutateWorldObjectResponse_Status_STATUS_UNKNOWN = 0,
  MutateWorldObjectResponse_Status_STATUS_OK = 1,
  MutateWorldObjectResponse_Status_STATUS_INVALID_MUTATION_ID = 2,
  MutateWorldObjectResponse_Status_STATUS_NO_PERMISSION = 3,
  MutateWorldObjectResponse_Status_MutateWorldObjectResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MutateWorldObjectResponse_Status_MutateWorldObjectResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MutateWorldObjectResponse_Status_IsValid(int value);
constexpr MutateWorldObjectResponse_Status MutateWorldObjectResponse_Status_Status_MIN = MutateWorldObjectResponse_Status_STATUS_UNKNOWN;
constexpr MutateWorldObjectResponse_Status MutateWorldObjectResponse_Status_Status_MAX = MutateWorldObjectResponse_Status_STATUS_NO_PERMISSION;
constexpr int MutateWorldObjectResponse_Status_Status_ARRAYSIZE = MutateWorldObjectResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MutateWorldObjectResponse_Status_descriptor();
template<typename T>
inline const std::string& MutateWorldObjectResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MutateWorldObjectResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MutateWorldObjectResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MutateWorldObjectResponse_Status_descriptor(), enum_t_value);
}
inline bool MutateWorldObjectResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MutateWorldObjectResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MutateWorldObjectResponse_Status>(
    MutateWorldObjectResponse_Status_descriptor(), name, value);
}
enum AprilTagProperties_AprilTagPoseStatus : int {
  AprilTagProperties_AprilTagPoseStatus_STATUS_UNKNOWN = 0,
  AprilTagProperties_AprilTagPoseStatus_STATUS_OK = 1,
  AprilTagProperties_AprilTagPoseStatus_STATUS_AMBIGUOUS = 2,
  AprilTagProperties_AprilTagPoseStatus_STATUS_HIGH_ERROR = 3,
  AprilTagProperties_AprilTagPoseStatus_AprilTagProperties_AprilTagPoseStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AprilTagProperties_AprilTagPoseStatus_AprilTagProperties_AprilTagPoseStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AprilTagProperties_AprilTagPoseStatus_IsValid(int value);
constexpr AprilTagProperties_AprilTagPoseStatus AprilTagProperties_AprilTagPoseStatus_AprilTagPoseStatus_MIN = AprilTagProperties_AprilTagPoseStatus_STATUS_UNKNOWN;
constexpr AprilTagProperties_AprilTagPoseStatus AprilTagProperties_AprilTagPoseStatus_AprilTagPoseStatus_MAX = AprilTagProperties_AprilTagPoseStatus_STATUS_HIGH_ERROR;
constexpr int AprilTagProperties_AprilTagPoseStatus_AprilTagPoseStatus_ARRAYSIZE = AprilTagProperties_AprilTagPoseStatus_AprilTagPoseStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AprilTagProperties_AprilTagPoseStatus_descriptor();
template<typename T>
inline const std::string& AprilTagProperties_AprilTagPoseStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AprilTagProperties_AprilTagPoseStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AprilTagProperties_AprilTagPoseStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AprilTagProperties_AprilTagPoseStatus_descriptor(), enum_t_value);
}
inline bool AprilTagProperties_AprilTagPoseStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AprilTagProperties_AprilTagPoseStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AprilTagProperties_AprilTagPoseStatus>(
    AprilTagProperties_AprilTagPoseStatus_descriptor(), name, value);
}
enum WorldObjectType : int {
  WORLD_OBJECT_UNKNOWN = 0,
  WORLD_OBJECT_DRAWABLE = 1,
  WORLD_OBJECT_APRILTAG = 2,
  WORLD_OBJECT_IMAGE_COORDINATES = 5,
  WORLD_OBJECT_DOCK = 6,
  WorldObjectType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WorldObjectType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WorldObjectType_IsValid(int value);
constexpr WorldObjectType WorldObjectType_MIN = WORLD_OBJECT_UNKNOWN;
constexpr WorldObjectType WorldObjectType_MAX = WORLD_OBJECT_DOCK;
constexpr int WorldObjectType_ARRAYSIZE = WorldObjectType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorldObjectType_descriptor();
template<typename T>
inline const std::string& WorldObjectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorldObjectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorldObjectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorldObjectType_descriptor(), enum_t_value);
}
inline bool WorldObjectType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorldObjectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorldObjectType>(
    WorldObjectType_descriptor(), name, value);
}
// ===================================================================

class WorldObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.WorldObject) */ {
 public:
  inline WorldObject() : WorldObject(nullptr) {}
  ~WorldObject() override;
  explicit PROTOBUF_CONSTEXPR WorldObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorldObject(const WorldObject& from);
  WorldObject(WorldObject&& from) noexcept
    : WorldObject() {
    *this = ::std::move(from);
  }

  inline WorldObject& operator=(const WorldObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldObject& operator=(WorldObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorldObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorldObject* internal_default_instance() {
    return reinterpret_cast<const WorldObject*>(
               &_WorldObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(WorldObject& a, WorldObject& b) {
    a.Swap(&b);
  }
  inline void Swap(WorldObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorldObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorldObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorldObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorldObject& from) {
    WorldObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorldObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.WorldObject";
  }
  protected:
  explicit WorldObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrawablePropertiesFieldNumber = 5,
    kNameFieldNumber = 2,
    kApriltagPropertiesFieldNumber = 6,
    kImagePropertiesFieldNumber = 9,
    kDockPropertiesFieldNumber = 10,
    kRayPropertiesFieldNumber = 11,
    kBoundingBoxPropertiesFieldNumber = 12,
    kAcquisitionTimeFieldNumber = 30,
    kTransformsSnapshotFieldNumber = 31,
    kAdditionalPropertiesFieldNumber = 100,
    kIdFieldNumber = 1,
  };
  // repeated .bosdyn.api.DrawableProperties drawable_properties = 5;
  int drawable_properties_size() const;
  private:
  int _internal_drawable_properties_size() const;
  public:
  void clear_drawable_properties();
  ::bosdyn::api::DrawableProperties* mutable_drawable_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DrawableProperties >*
      mutable_drawable_properties();
  private:
  const ::bosdyn::api::DrawableProperties& _internal_drawable_properties(int index) const;
  ::bosdyn::api::DrawableProperties* _internal_add_drawable_properties();
  public:
  const ::bosdyn::api::DrawableProperties& drawable_properties(int index) const;
  ::bosdyn::api::DrawableProperties* add_drawable_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DrawableProperties >&
      drawable_properties() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .bosdyn.api.AprilTagProperties apriltag_properties = 6;
  bool has_apriltag_properties() const;
  private:
  bool _internal_has_apriltag_properties() const;
  public:
  void clear_apriltag_properties();
  const ::bosdyn::api::AprilTagProperties& apriltag_properties() const;
  PROTOBUF_NODISCARD ::bosdyn::api::AprilTagProperties* release_apriltag_properties();
  ::bosdyn::api::AprilTagProperties* mutable_apriltag_properties();
  void set_allocated_apriltag_properties(::bosdyn::api::AprilTagProperties* apriltag_properties);
  private:
  const ::bosdyn::api::AprilTagProperties& _internal_apriltag_properties() const;
  ::bosdyn::api::AprilTagProperties* _internal_mutable_apriltag_properties();
  public:
  void unsafe_arena_set_allocated_apriltag_properties(
      ::bosdyn::api::AprilTagProperties* apriltag_properties);
  ::bosdyn::api::AprilTagProperties* unsafe_arena_release_apriltag_properties();

  // .bosdyn.api.ImageProperties image_properties = 9;
  bool has_image_properties() const;
  private:
  bool _internal_has_image_properties() const;
  public:
  void clear_image_properties();
  const ::bosdyn::api::ImageProperties& image_properties() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ImageProperties* release_image_properties();
  ::bosdyn::api::ImageProperties* mutable_image_properties();
  void set_allocated_image_properties(::bosdyn::api::ImageProperties* image_properties);
  private:
  const ::bosdyn::api::ImageProperties& _internal_image_properties() const;
  ::bosdyn::api::ImageProperties* _internal_mutable_image_properties();
  public:
  void unsafe_arena_set_allocated_image_properties(
      ::bosdyn::api::ImageProperties* image_properties);
  ::bosdyn::api::ImageProperties* unsafe_arena_release_image_properties();

  // .bosdyn.api.DockProperties dock_properties = 10;
  bool has_dock_properties() const;
  private:
  bool _internal_has_dock_properties() const;
  public:
  void clear_dock_properties();
  const ::bosdyn::api::DockProperties& dock_properties() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DockProperties* release_dock_properties();
  ::bosdyn::api::DockProperties* mutable_dock_properties();
  void set_allocated_dock_properties(::bosdyn::api::DockProperties* dock_properties);
  private:
  const ::bosdyn::api::DockProperties& _internal_dock_properties() const;
  ::bosdyn::api::DockProperties* _internal_mutable_dock_properties();
  public:
  void unsafe_arena_set_allocated_dock_properties(
      ::bosdyn::api::DockProperties* dock_properties);
  ::bosdyn::api::DockProperties* unsafe_arena_release_dock_properties();

  // .bosdyn.api.RayProperties ray_properties = 11;
  bool has_ray_properties() const;
  private:
  bool _internal_has_ray_properties() const;
  public:
  void clear_ray_properties();
  const ::bosdyn::api::RayProperties& ray_properties() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RayProperties* release_ray_properties();
  ::bosdyn::api::RayProperties* mutable_ray_properties();
  void set_allocated_ray_properties(::bosdyn::api::RayProperties* ray_properties);
  private:
  const ::bosdyn::api::RayProperties& _internal_ray_properties() const;
  ::bosdyn::api::RayProperties* _internal_mutable_ray_properties();
  public:
  void unsafe_arena_set_allocated_ray_properties(
      ::bosdyn::api::RayProperties* ray_properties);
  ::bosdyn::api::RayProperties* unsafe_arena_release_ray_properties();

  // .bosdyn.api.BoundingBoxProperties bounding_box_properties = 12;
  bool has_bounding_box_properties() const;
  private:
  bool _internal_has_bounding_box_properties() const;
  public:
  void clear_bounding_box_properties();
  const ::bosdyn::api::BoundingBoxProperties& bounding_box_properties() const;
  PROTOBUF_NODISCARD ::bosdyn::api::BoundingBoxProperties* release_bounding_box_properties();
  ::bosdyn::api::BoundingBoxProperties* mutable_bounding_box_properties();
  void set_allocated_bounding_box_properties(::bosdyn::api::BoundingBoxProperties* bounding_box_properties);
  private:
  const ::bosdyn::api::BoundingBoxProperties& _internal_bounding_box_properties() const;
  ::bosdyn::api::BoundingBoxProperties* _internal_mutable_bounding_box_properties();
  public:
  void unsafe_arena_set_allocated_bounding_box_properties(
      ::bosdyn::api::BoundingBoxProperties* bounding_box_properties);
  ::bosdyn::api::BoundingBoxProperties* unsafe_arena_release_bounding_box_properties();

  // .google.protobuf.Timestamp acquisition_time = 30;
  bool has_acquisition_time() const;
  private:
  bool _internal_has_acquisition_time() const;
  public:
  void clear_acquisition_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& acquisition_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_acquisition_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_acquisition_time();
  void set_allocated_acquisition_time(::PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_acquisition_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_acquisition_time();
  public:
  void unsafe_arena_set_allocated_acquisition_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_acquisition_time();

  // .bosdyn.api.FrameTreeSnapshot transforms_snapshot = 31;
  bool has_transforms_snapshot() const;
  private:
  bool _internal_has_transforms_snapshot() const;
  public:
  void clear_transforms_snapshot();
  const ::bosdyn::api::FrameTreeSnapshot& transforms_snapshot() const;
  PROTOBUF_NODISCARD ::bosdyn::api::FrameTreeSnapshot* release_transforms_snapshot();
  ::bosdyn::api::FrameTreeSnapshot* mutable_transforms_snapshot();
  void set_allocated_transforms_snapshot(::bosdyn::api::FrameTreeSnapshot* transforms_snapshot);
  private:
  const ::bosdyn::api::FrameTreeSnapshot& _internal_transforms_snapshot() const;
  ::bosdyn::api::FrameTreeSnapshot* _internal_mutable_transforms_snapshot();
  public:
  void unsafe_arena_set_allocated_transforms_snapshot(
      ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot);
  ::bosdyn::api::FrameTreeSnapshot* unsafe_arena_release_transforms_snapshot();

  // .google.protobuf.Any additional_properties = 100;
  bool has_additional_properties() const;
  private:
  bool _internal_has_additional_properties() const;
  public:
  void clear_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::Any& additional_properties() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_additional_properties();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_additional_properties();
  void set_allocated_additional_properties(::PROTOBUF_NAMESPACE_ID::Any* additional_properties);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_additional_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_additional_properties();
  public:
  void unsafe_arena_set_allocated_additional_properties(
      ::PROTOBUF_NAMESPACE_ID::Any* additional_properties);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_additional_properties();

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.WorldObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DrawableProperties > drawable_properties_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::bosdyn::api::AprilTagProperties* apriltag_properties_;
    ::bosdyn::api::ImageProperties* image_properties_;
    ::bosdyn::api::DockProperties* dock_properties_;
    ::bosdyn::api::RayProperties* ray_properties_;
    ::bosdyn::api::BoundingBoxProperties* bounding_box_properties_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_time_;
    ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_;
    ::PROTOBUF_NAMESPACE_ID::Any* additional_properties_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class ListWorldObjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListWorldObjectRequest) */ {
 public:
  inline ListWorldObjectRequest() : ListWorldObjectRequest(nullptr) {}
  ~ListWorldObjectRequest() override;
  explicit PROTOBUF_CONSTEXPR ListWorldObjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListWorldObjectRequest(const ListWorldObjectRequest& from);
  ListWorldObjectRequest(ListWorldObjectRequest&& from) noexcept
    : ListWorldObjectRequest() {
    *this = ::std::move(from);
  }

  inline ListWorldObjectRequest& operator=(const ListWorldObjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListWorldObjectRequest& operator=(ListWorldObjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListWorldObjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListWorldObjectRequest* internal_default_instance() {
    return reinterpret_cast<const ListWorldObjectRequest*>(
               &_ListWorldObjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ListWorldObjectRequest& a, ListWorldObjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListWorldObjectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListWorldObjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListWorldObjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListWorldObjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListWorldObjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListWorldObjectRequest& from) {
    ListWorldObjectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListWorldObjectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListWorldObjectRequest";
  }
  protected:
  explicit ListWorldObjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectTypeFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kTimestampFilterFieldNumber = 3,
  };
  // repeated .bosdyn.api.WorldObjectType object_type = 2;
  int object_type_size() const;
  private:
  int _internal_object_type_size() const;
  public:
  void clear_object_type();
  private:
  ::bosdyn::api::WorldObjectType _internal_object_type(int index) const;
  void _internal_add_object_type(::bosdyn::api::WorldObjectType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_object_type();
  public:
  ::bosdyn::api::WorldObjectType object_type(int index) const;
  void set_object_type(int index, ::bosdyn::api::WorldObjectType value);
  void add_object_type(::bosdyn::api::WorldObjectType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& object_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_object_type();

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .google.protobuf.Timestamp timestamp_filter = 3;
  bool has_timestamp_filter() const;
  private:
  bool _internal_has_timestamp_filter() const;
  public:
  void clear_timestamp_filter();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp_filter() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp_filter();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp_filter();
  void set_allocated_timestamp_filter(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_filter);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp_filter() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp_filter();
  public:
  void unsafe_arena_set_allocated_timestamp_filter(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_filter);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp_filter();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListWorldObjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> object_type_;
    mutable std::atomic<int> _object_type_cached_byte_size_;
    ::bosdyn::api::RequestHeader* header_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_filter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class ListWorldObjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListWorldObjectResponse) */ {
 public:
  inline ListWorldObjectResponse() : ListWorldObjectResponse(nullptr) {}
  ~ListWorldObjectResponse() override;
  explicit PROTOBUF_CONSTEXPR ListWorldObjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListWorldObjectResponse(const ListWorldObjectResponse& from);
  ListWorldObjectResponse(ListWorldObjectResponse&& from) noexcept
    : ListWorldObjectResponse() {
    *this = ::std::move(from);
  }

  inline ListWorldObjectResponse& operator=(const ListWorldObjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListWorldObjectResponse& operator=(ListWorldObjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListWorldObjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListWorldObjectResponse* internal_default_instance() {
    return reinterpret_cast<const ListWorldObjectResponse*>(
               &_ListWorldObjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ListWorldObjectResponse& a, ListWorldObjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListWorldObjectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListWorldObjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListWorldObjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListWorldObjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListWorldObjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListWorldObjectResponse& from) {
    ListWorldObjectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListWorldObjectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListWorldObjectResponse";
  }
  protected:
  explicit ListWorldObjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldObjectsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.WorldObject world_objects = 2;
  int world_objects_size() const;
  private:
  int _internal_world_objects_size() const;
  public:
  void clear_world_objects();
  ::bosdyn::api::WorldObject* mutable_world_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::WorldObject >*
      mutable_world_objects();
  private:
  const ::bosdyn::api::WorldObject& _internal_world_objects(int index) const;
  ::bosdyn::api::WorldObject* _internal_add_world_objects();
  public:
  const ::bosdyn::api::WorldObject& world_objects(int index) const;
  ::bosdyn::api::WorldObject* add_world_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::WorldObject >&
      world_objects() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListWorldObjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::WorldObject > world_objects_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class MutateWorldObjectRequest_Mutation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.MutateWorldObjectRequest.Mutation) */ {
 public:
  inline MutateWorldObjectRequest_Mutation() : MutateWorldObjectRequest_Mutation(nullptr) {}
  ~MutateWorldObjectRequest_Mutation() override;
  explicit PROTOBUF_CONSTEXPR MutateWorldObjectRequest_Mutation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MutateWorldObjectRequest_Mutation(const MutateWorldObjectRequest_Mutation& from);
  MutateWorldObjectRequest_Mutation(MutateWorldObjectRequest_Mutation&& from) noexcept
    : MutateWorldObjectRequest_Mutation() {
    *this = ::std::move(from);
  }

  inline MutateWorldObjectRequest_Mutation& operator=(const MutateWorldObjectRequest_Mutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline MutateWorldObjectRequest_Mutation& operator=(MutateWorldObjectRequest_Mutation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MutateWorldObjectRequest_Mutation& default_instance() {
    return *internal_default_instance();
  }
  static inline const MutateWorldObjectRequest_Mutation* internal_default_instance() {
    return reinterpret_cast<const MutateWorldObjectRequest_Mutation*>(
               &_MutateWorldObjectRequest_Mutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MutateWorldObjectRequest_Mutation& a, MutateWorldObjectRequest_Mutation& b) {
    a.Swap(&b);
  }
  inline void Swap(MutateWorldObjectRequest_Mutation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MutateWorldObjectRequest_Mutation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MutateWorldObjectRequest_Mutation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MutateWorldObjectRequest_Mutation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MutateWorldObjectRequest_Mutation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MutateWorldObjectRequest_Mutation& from) {
    MutateWorldObjectRequest_Mutation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MutateWorldObjectRequest_Mutation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.MutateWorldObjectRequest.Mutation";
  }
  protected:
  explicit MutateWorldObjectRequest_Mutation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 2,
    kActionFieldNumber = 1,
  };
  // .bosdyn.api.WorldObject object = 2;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::bosdyn::api::WorldObject& object() const;
  PROTOBUF_NODISCARD ::bosdyn::api::WorldObject* release_object();
  ::bosdyn::api::WorldObject* mutable_object();
  void set_allocated_object(::bosdyn::api::WorldObject* object);
  private:
  const ::bosdyn::api::WorldObject& _internal_object() const;
  ::bosdyn::api::WorldObject* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::bosdyn::api::WorldObject* object);
  ::bosdyn::api::WorldObject* unsafe_arena_release_object();

  // .bosdyn.api.MutateWorldObjectRequest.Action action = 1;
  void clear_action();
  ::bosdyn::api::MutateWorldObjectRequest_Action action() const;
  void set_action(::bosdyn::api::MutateWorldObjectRequest_Action value);
  private:
  ::bosdyn::api::MutateWorldObjectRequest_Action _internal_action() const;
  void _internal_set_action(::bosdyn::api::MutateWorldObjectRequest_Action value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.MutateWorldObjectRequest.Mutation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::WorldObject* object_;
    int action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class MutateWorldObjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.MutateWorldObjectRequest) */ {
 public:
  inline MutateWorldObjectRequest() : MutateWorldObjectRequest(nullptr) {}
  ~MutateWorldObjectRequest() override;
  explicit PROTOBUF_CONSTEXPR MutateWorldObjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MutateWorldObjectRequest(const MutateWorldObjectRequest& from);
  MutateWorldObjectRequest(MutateWorldObjectRequest&& from) noexcept
    : MutateWorldObjectRequest() {
    *this = ::std::move(from);
  }

  inline MutateWorldObjectRequest& operator=(const MutateWorldObjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MutateWorldObjectRequest& operator=(MutateWorldObjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MutateWorldObjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MutateWorldObjectRequest* internal_default_instance() {
    return reinterpret_cast<const MutateWorldObjectRequest*>(
               &_MutateWorldObjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MutateWorldObjectRequest& a, MutateWorldObjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MutateWorldObjectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MutateWorldObjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MutateWorldObjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MutateWorldObjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MutateWorldObjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MutateWorldObjectRequest& from) {
    MutateWorldObjectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MutateWorldObjectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.MutateWorldObjectRequest";
  }
  protected:
  explicit MutateWorldObjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MutateWorldObjectRequest_Mutation Mutation;

  typedef MutateWorldObjectRequest_Action Action;
  static constexpr Action ACTION_UNKNOWN =
    MutateWorldObjectRequest_Action_ACTION_UNKNOWN;
  static constexpr Action ACTION_ADD =
    MutateWorldObjectRequest_Action_ACTION_ADD;
  static constexpr Action ACTION_CHANGE =
    MutateWorldObjectRequest_Action_ACTION_CHANGE;
  static constexpr Action ACTION_DELETE =
    MutateWorldObjectRequest_Action_ACTION_DELETE;
  static inline bool Action_IsValid(int value) {
    return MutateWorldObjectRequest_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    MutateWorldObjectRequest_Action_Action_MIN;
  static constexpr Action Action_MAX =
    MutateWorldObjectRequest_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    MutateWorldObjectRequest_Action_Action_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Action_descriptor() {
    return MutateWorldObjectRequest_Action_descriptor();
  }
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return MutateWorldObjectRequest_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return MutateWorldObjectRequest_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kMutationFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.MutateWorldObjectRequest.Mutation mutation = 2;
  bool has_mutation() const;
  private:
  bool _internal_has_mutation() const;
  public:
  void clear_mutation();
  const ::bosdyn::api::MutateWorldObjectRequest_Mutation& mutation() const;
  PROTOBUF_NODISCARD ::bosdyn::api::MutateWorldObjectRequest_Mutation* release_mutation();
  ::bosdyn::api::MutateWorldObjectRequest_Mutation* mutable_mutation();
  void set_allocated_mutation(::bosdyn::api::MutateWorldObjectRequest_Mutation* mutation);
  private:
  const ::bosdyn::api::MutateWorldObjectRequest_Mutation& _internal_mutation() const;
  ::bosdyn::api::MutateWorldObjectRequest_Mutation* _internal_mutable_mutation();
  public:
  void unsafe_arena_set_allocated_mutation(
      ::bosdyn::api::MutateWorldObjectRequest_Mutation* mutation);
  ::bosdyn::api::MutateWorldObjectRequest_Mutation* unsafe_arena_release_mutation();

  // @@protoc_insertion_point(class_scope:bosdyn.api.MutateWorldObjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::MutateWorldObjectRequest_Mutation* mutation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class MutateWorldObjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.MutateWorldObjectResponse) */ {
 public:
  inline MutateWorldObjectResponse() : MutateWorldObjectResponse(nullptr) {}
  ~MutateWorldObjectResponse() override;
  explicit PROTOBUF_CONSTEXPR MutateWorldObjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MutateWorldObjectResponse(const MutateWorldObjectResponse& from);
  MutateWorldObjectResponse(MutateWorldObjectResponse&& from) noexcept
    : MutateWorldObjectResponse() {
    *this = ::std::move(from);
  }

  inline MutateWorldObjectResponse& operator=(const MutateWorldObjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MutateWorldObjectResponse& operator=(MutateWorldObjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MutateWorldObjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MutateWorldObjectResponse* internal_default_instance() {
    return reinterpret_cast<const MutateWorldObjectResponse*>(
               &_MutateWorldObjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MutateWorldObjectResponse& a, MutateWorldObjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MutateWorldObjectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MutateWorldObjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MutateWorldObjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MutateWorldObjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MutateWorldObjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MutateWorldObjectResponse& from) {
    MutateWorldObjectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MutateWorldObjectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.MutateWorldObjectResponse";
  }
  protected:
  explicit MutateWorldObjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MutateWorldObjectResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    MutateWorldObjectResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    MutateWorldObjectResponse_Status_STATUS_OK;
  static constexpr Status STATUS_INVALID_MUTATION_ID =
    MutateWorldObjectResponse_Status_STATUS_INVALID_MUTATION_ID;
  static constexpr Status STATUS_NO_PERMISSION =
    MutateWorldObjectResponse_Status_STATUS_NO_PERMISSION;
  static inline bool Status_IsValid(int value) {
    return MutateWorldObjectResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    MutateWorldObjectResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    MutateWorldObjectResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    MutateWorldObjectResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return MutateWorldObjectResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return MutateWorldObjectResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return MutateWorldObjectResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
    kMutatedObjectIdFieldNumber = 4,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.MutateWorldObjectResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::MutateWorldObjectResponse_Status status() const;
  void set_status(::bosdyn::api::MutateWorldObjectResponse_Status value);
  private:
  ::bosdyn::api::MutateWorldObjectResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::MutateWorldObjectResponse_Status value);
  public:

  // int32 mutated_object_id = 4;
  void clear_mutated_object_id();
  int32_t mutated_object_id() const;
  void set_mutated_object_id(int32_t value);
  private:
  int32_t _internal_mutated_object_id() const;
  void _internal_set_mutated_object_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.MutateWorldObjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    int32_t mutated_object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class ImageProperties final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ImageProperties) */ {
 public:
  inline ImageProperties() : ImageProperties(nullptr) {}
  ~ImageProperties() override;
  explicit PROTOBUF_CONSTEXPR ImageProperties(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageProperties(const ImageProperties& from);
  ImageProperties(ImageProperties&& from) noexcept
    : ImageProperties() {
    *this = ::std::move(from);
  }

  inline ImageProperties& operator=(const ImageProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageProperties& operator=(ImageProperties&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageProperties& default_instance() {
    return *internal_default_instance();
  }
  enum ImageDataCase {
    kCoordinates = 2,
    kKeypoints = 4,
    IMAGE_DATA_NOT_SET = 0,
  };

  static inline const ImageProperties* internal_default_instance() {
    return reinterpret_cast<const ImageProperties*>(
               &_ImageProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ImageProperties& a, ImageProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageProperties* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageProperties* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageProperties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageProperties>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageProperties& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageProperties& from) {
    ImageProperties::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageProperties* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ImageProperties";
  }
  protected:
  explicit ImageProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraSourceFieldNumber = 1,
    kFrameNameImageCoordinatesFieldNumber = 3,
    kImageSourceFieldNumber = 5,
    kImageCaptureFieldNumber = 6,
    kCoordinatesFieldNumber = 2,
    kKeypointsFieldNumber = 4,
  };
  // string camera_source = 1;
  void clear_camera_source();
  const std::string& camera_source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_camera_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_camera_source();
  PROTOBUF_NODISCARD std::string* release_camera_source();
  void set_allocated_camera_source(std::string* camera_source);
  private:
  const std::string& _internal_camera_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_source(const std::string& value);
  std::string* _internal_mutable_camera_source();
  public:

  // string frame_name_image_coordinates = 3;
  void clear_frame_name_image_coordinates();
  const std::string& frame_name_image_coordinates() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name_image_coordinates(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name_image_coordinates();
  PROTOBUF_NODISCARD std::string* release_frame_name_image_coordinates();
  void set_allocated_frame_name_image_coordinates(std::string* frame_name_image_coordinates);
  private:
  const std::string& _internal_frame_name_image_coordinates() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name_image_coordinates(const std::string& value);
  std::string* _internal_mutable_frame_name_image_coordinates();
  public:

  // .bosdyn.api.ImageSource image_source = 5;
  bool has_image_source() const;
  private:
  bool _internal_has_image_source() const;
  public:
  void clear_image_source();
  const ::bosdyn::api::ImageSource& image_source() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ImageSource* release_image_source();
  ::bosdyn::api::ImageSource* mutable_image_source();
  void set_allocated_image_source(::bosdyn::api::ImageSource* image_source);
  private:
  const ::bosdyn::api::ImageSource& _internal_image_source() const;
  ::bosdyn::api::ImageSource* _internal_mutable_image_source();
  public:
  void unsafe_arena_set_allocated_image_source(
      ::bosdyn::api::ImageSource* image_source);
  ::bosdyn::api::ImageSource* unsafe_arena_release_image_source();

  // .bosdyn.api.ImageCapture image_capture = 6;
  bool has_image_capture() const;
  private:
  bool _internal_has_image_capture() const;
  public:
  void clear_image_capture();
  const ::bosdyn::api::ImageCapture& image_capture() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ImageCapture* release_image_capture();
  ::bosdyn::api::ImageCapture* mutable_image_capture();
  void set_allocated_image_capture(::bosdyn::api::ImageCapture* image_capture);
  private:
  const ::bosdyn::api::ImageCapture& _internal_image_capture() const;
  ::bosdyn::api::ImageCapture* _internal_mutable_image_capture();
  public:
  void unsafe_arena_set_allocated_image_capture(
      ::bosdyn::api::ImageCapture* image_capture);
  ::bosdyn::api::ImageCapture* unsafe_arena_release_image_capture();

  // .bosdyn.api.Polygon coordinates = 2;
  bool has_coordinates() const;
  private:
  bool _internal_has_coordinates() const;
  public:
  void clear_coordinates();
  const ::bosdyn::api::Polygon& coordinates() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Polygon* release_coordinates();
  ::bosdyn::api::Polygon* mutable_coordinates();
  void set_allocated_coordinates(::bosdyn::api::Polygon* coordinates);
  private:
  const ::bosdyn::api::Polygon& _internal_coordinates() const;
  ::bosdyn::api::Polygon* _internal_mutable_coordinates();
  public:
  void unsafe_arena_set_allocated_coordinates(
      ::bosdyn::api::Polygon* coordinates);
  ::bosdyn::api::Polygon* unsafe_arena_release_coordinates();

  // .bosdyn.api.KeypointSet keypoints = 4;
  bool has_keypoints() const;
  private:
  bool _internal_has_keypoints() const;
  public:
  void clear_keypoints();
  const ::bosdyn::api::KeypointSet& keypoints() const;
  PROTOBUF_NODISCARD ::bosdyn::api::KeypointSet* release_keypoints();
  ::bosdyn::api::KeypointSet* mutable_keypoints();
  void set_allocated_keypoints(::bosdyn::api::KeypointSet* keypoints);
  private:
  const ::bosdyn::api::KeypointSet& _internal_keypoints() const;
  ::bosdyn::api::KeypointSet* _internal_mutable_keypoints();
  public:
  void unsafe_arena_set_allocated_keypoints(
      ::bosdyn::api::KeypointSet* keypoints);
  ::bosdyn::api::KeypointSet* unsafe_arena_release_keypoints();

  void clear_image_data();
  ImageDataCase image_data_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.ImageProperties)
 private:
  class _Internal;
  void set_has_coordinates();
  void set_has_keypoints();

  inline bool has_image_data() const;
  inline void clear_has_image_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_source_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_image_coordinates_;
    ::bosdyn::api::ImageSource* image_source_;
    ::bosdyn::api::ImageCapture* image_capture_;
    union ImageDataUnion {
      constexpr ImageDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::Polygon* coordinates_;
      ::bosdyn::api::KeypointSet* keypoints_;
    } image_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class DockProperties final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DockProperties) */ {
 public:
  inline DockProperties() : DockProperties(nullptr) {}
  ~DockProperties() override;
  explicit PROTOBUF_CONSTEXPR DockProperties(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DockProperties(const DockProperties& from);
  DockProperties(DockProperties&& from) noexcept
    : DockProperties() {
    *this = ::std::move(from);
  }

  inline DockProperties& operator=(const DockProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline DockProperties& operator=(DockProperties&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DockProperties& default_instance() {
    return *internal_default_instance();
  }
  static inline const DockProperties* internal_default_instance() {
    return reinterpret_cast<const DockProperties*>(
               &_DockProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DockProperties& a, DockProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(DockProperties* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DockProperties* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DockProperties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DockProperties>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DockProperties& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DockProperties& from) {
    DockProperties::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DockProperties* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DockProperties";
  }
  protected:
  explicit DockProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameDockFieldNumber = 3,
    kDockIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kUnavailableFieldNumber = 4,
    kFromPriorFieldNumber = 5,
  };
  // string frame_name_dock = 3;
  void clear_frame_name_dock();
  const std::string& frame_name_dock() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name_dock(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name_dock();
  PROTOBUF_NODISCARD std::string* release_frame_name_dock();
  void set_allocated_frame_name_dock(std::string* frame_name_dock);
  private:
  const std::string& _internal_frame_name_dock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name_dock(const std::string& value);
  std::string* _internal_mutable_frame_name_dock();
  public:

  // uint32 dock_id = 1;
  void clear_dock_id();
  uint32_t dock_id() const;
  void set_dock_id(uint32_t value);
  private:
  uint32_t _internal_dock_id() const;
  void _internal_set_dock_id(uint32_t value);
  public:

  // .bosdyn.api.docking.DockType type = 2;
  void clear_type();
  ::bosdyn::api::docking::DockType type() const;
  void set_type(::bosdyn::api::docking::DockType value);
  private:
  ::bosdyn::api::docking::DockType _internal_type() const;
  void _internal_set_type(::bosdyn::api::docking::DockType value);
  public:

  // bool unavailable = 4;
  void clear_unavailable();
  bool unavailable() const;
  void set_unavailable(bool value);
  private:
  bool _internal_unavailable() const;
  void _internal_set_unavailable(bool value);
  public:

  // bool from_prior = 5;
  void clear_from_prior();
  bool from_prior() const;
  void set_from_prior(bool value);
  private:
  bool _internal_from_prior() const;
  void _internal_set_from_prior(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.DockProperties)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_dock_;
    uint32_t dock_id_;
    int type_;
    bool unavailable_;
    bool from_prior_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class AprilTagProperties final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.AprilTagProperties) */ {
 public:
  inline AprilTagProperties() : AprilTagProperties(nullptr) {}
  ~AprilTagProperties() override;
  explicit PROTOBUF_CONSTEXPR AprilTagProperties(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AprilTagProperties(const AprilTagProperties& from);
  AprilTagProperties(AprilTagProperties&& from) noexcept
    : AprilTagProperties() {
    *this = ::std::move(from);
  }

  inline AprilTagProperties& operator=(const AprilTagProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline AprilTagProperties& operator=(AprilTagProperties&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AprilTagProperties& default_instance() {
    return *internal_default_instance();
  }
  static inline const AprilTagProperties* internal_default_instance() {
    return reinterpret_cast<const AprilTagProperties*>(
               &_AprilTagProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AprilTagProperties& a, AprilTagProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(AprilTagProperties* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AprilTagProperties* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AprilTagProperties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AprilTagProperties>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AprilTagProperties& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AprilTagProperties& from) {
    AprilTagProperties::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AprilTagProperties* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.AprilTagProperties";
  }
  protected:
  explicit AprilTagProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AprilTagProperties_AprilTagPoseStatus AprilTagPoseStatus;
  static constexpr AprilTagPoseStatus STATUS_UNKNOWN =
    AprilTagProperties_AprilTagPoseStatus_STATUS_UNKNOWN;
  static constexpr AprilTagPoseStatus STATUS_OK =
    AprilTagProperties_AprilTagPoseStatus_STATUS_OK;
  static constexpr AprilTagPoseStatus STATUS_AMBIGUOUS =
    AprilTagProperties_AprilTagPoseStatus_STATUS_AMBIGUOUS;
  static constexpr AprilTagPoseStatus STATUS_HIGH_ERROR =
    AprilTagProperties_AprilTagPoseStatus_STATUS_HIGH_ERROR;
  static inline bool AprilTagPoseStatus_IsValid(int value) {
    return AprilTagProperties_AprilTagPoseStatus_IsValid(value);
  }
  static constexpr AprilTagPoseStatus AprilTagPoseStatus_MIN =
    AprilTagProperties_AprilTagPoseStatus_AprilTagPoseStatus_MIN;
  static constexpr AprilTagPoseStatus AprilTagPoseStatus_MAX =
    AprilTagProperties_AprilTagPoseStatus_AprilTagPoseStatus_MAX;
  static constexpr int AprilTagPoseStatus_ARRAYSIZE =
    AprilTagProperties_AprilTagPoseStatus_AprilTagPoseStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AprilTagPoseStatus_descriptor() {
    return AprilTagProperties_AprilTagPoseStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& AprilTagPoseStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AprilTagPoseStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AprilTagPoseStatus_Name.");
    return AprilTagProperties_AprilTagPoseStatus_Name(enum_t_value);
  }
  static inline bool AprilTagPoseStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AprilTagPoseStatus* value) {
    return AprilTagProperties_AprilTagPoseStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFiducialFieldNumber = 3,
    kFrameNameFiducialFilteredFieldNumber = 4,
    kDetectionCovarianceReferenceFrameFieldNumber = 6,
    kFrameNameCameraFieldNumber = 7,
    kDimensionsFieldNumber = 2,
    kDetectionCovarianceFieldNumber = 5,
    kTagIdFieldNumber = 1,
    kFiducialPoseStatusFieldNumber = 8,
    kFiducialFilteredPoseStatusFieldNumber = 9,
  };
  // string frame_name_fiducial = 3;
  void clear_frame_name_fiducial();
  const std::string& frame_name_fiducial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name_fiducial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name_fiducial();
  PROTOBUF_NODISCARD std::string* release_frame_name_fiducial();
  void set_allocated_frame_name_fiducial(std::string* frame_name_fiducial);
  private:
  const std::string& _internal_frame_name_fiducial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name_fiducial(const std::string& value);
  std::string* _internal_mutable_frame_name_fiducial();
  public:

  // string frame_name_fiducial_filtered = 4;
  void clear_frame_name_fiducial_filtered();
  const std::string& frame_name_fiducial_filtered() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name_fiducial_filtered(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name_fiducial_filtered();
  PROTOBUF_NODISCARD std::string* release_frame_name_fiducial_filtered();
  void set_allocated_frame_name_fiducial_filtered(std::string* frame_name_fiducial_filtered);
  private:
  const std::string& _internal_frame_name_fiducial_filtered() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name_fiducial_filtered(const std::string& value);
  std::string* _internal_mutable_frame_name_fiducial_filtered();
  public:

  // string detection_covariance_reference_frame = 6;
  void clear_detection_covariance_reference_frame();
  const std::string& detection_covariance_reference_frame() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detection_covariance_reference_frame(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detection_covariance_reference_frame();
  PROTOBUF_NODISCARD std::string* release_detection_covariance_reference_frame();
  void set_allocated_detection_covariance_reference_frame(std::string* detection_covariance_reference_frame);
  private:
  const std::string& _internal_detection_covariance_reference_frame() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detection_covariance_reference_frame(const std::string& value);
  std::string* _internal_mutable_detection_covariance_reference_frame();
  public:

  // string frame_name_camera = 7;
  void clear_frame_name_camera();
  const std::string& frame_name_camera() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name_camera(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name_camera();
  PROTOBUF_NODISCARD std::string* release_frame_name_camera();
  void set_allocated_frame_name_camera(std::string* frame_name_camera);
  private:
  const std::string& _internal_frame_name_camera() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name_camera(const std::string& value);
  std::string* _internal_mutable_frame_name_camera();
  public:

  // .bosdyn.api.Vec2 dimensions = 2;
  bool has_dimensions() const;
  private:
  bool _internal_has_dimensions() const;
  public:
  void clear_dimensions();
  const ::bosdyn::api::Vec2& dimensions() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec2* release_dimensions();
  ::bosdyn::api::Vec2* mutable_dimensions();
  void set_allocated_dimensions(::bosdyn::api::Vec2* dimensions);
  private:
  const ::bosdyn::api::Vec2& _internal_dimensions() const;
  ::bosdyn::api::Vec2* _internal_mutable_dimensions();
  public:
  void unsafe_arena_set_allocated_dimensions(
      ::bosdyn::api::Vec2* dimensions);
  ::bosdyn::api::Vec2* unsafe_arena_release_dimensions();

  // .bosdyn.api.SE3Covariance detection_covariance = 5;
  bool has_detection_covariance() const;
  private:
  bool _internal_has_detection_covariance() const;
  public:
  void clear_detection_covariance();
  const ::bosdyn::api::SE3Covariance& detection_covariance() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Covariance* release_detection_covariance();
  ::bosdyn::api::SE3Covariance* mutable_detection_covariance();
  void set_allocated_detection_covariance(::bosdyn::api::SE3Covariance* detection_covariance);
  private:
  const ::bosdyn::api::SE3Covariance& _internal_detection_covariance() const;
  ::bosdyn::api::SE3Covariance* _internal_mutable_detection_covariance();
  public:
  void unsafe_arena_set_allocated_detection_covariance(
      ::bosdyn::api::SE3Covariance* detection_covariance);
  ::bosdyn::api::SE3Covariance* unsafe_arena_release_detection_covariance();

  // int32 tag_id = 1;
  void clear_tag_id();
  int32_t tag_id() const;
  void set_tag_id(int32_t value);
  private:
  int32_t _internal_tag_id() const;
  void _internal_set_tag_id(int32_t value);
  public:

  // .bosdyn.api.AprilTagProperties.AprilTagPoseStatus fiducial_pose_status = 8;
  void clear_fiducial_pose_status();
  ::bosdyn::api::AprilTagProperties_AprilTagPoseStatus fiducial_pose_status() const;
  void set_fiducial_pose_status(::bosdyn::api::AprilTagProperties_AprilTagPoseStatus value);
  private:
  ::bosdyn::api::AprilTagProperties_AprilTagPoseStatus _internal_fiducial_pose_status() const;
  void _internal_set_fiducial_pose_status(::bosdyn::api::AprilTagProperties_AprilTagPoseStatus value);
  public:

  // .bosdyn.api.AprilTagProperties.AprilTagPoseStatus fiducial_filtered_pose_status = 9;
  void clear_fiducial_filtered_pose_status();
  ::bosdyn::api::AprilTagProperties_AprilTagPoseStatus fiducial_filtered_pose_status() const;
  void set_fiducial_filtered_pose_status(::bosdyn::api::AprilTagProperties_AprilTagPoseStatus value);
  private:
  ::bosdyn::api::AprilTagProperties_AprilTagPoseStatus _internal_fiducial_filtered_pose_status() const;
  void _internal_set_fiducial_filtered_pose_status(::bosdyn::api::AprilTagProperties_AprilTagPoseStatus value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.AprilTagProperties)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_fiducial_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_fiducial_filtered_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detection_covariance_reference_frame_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_camera_;
    ::bosdyn::api::Vec2* dimensions_;
    ::bosdyn::api::SE3Covariance* detection_covariance_;
    int32_t tag_id_;
    int fiducial_pose_status_;
    int fiducial_filtered_pose_status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class RayProperties final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RayProperties) */ {
 public:
  inline RayProperties() : RayProperties(nullptr) {}
  ~RayProperties() override;
  explicit PROTOBUF_CONSTEXPR RayProperties(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RayProperties(const RayProperties& from);
  RayProperties(RayProperties&& from) noexcept
    : RayProperties() {
    *this = ::std::move(from);
  }

  inline RayProperties& operator=(const RayProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline RayProperties& operator=(RayProperties&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RayProperties& default_instance() {
    return *internal_default_instance();
  }
  static inline const RayProperties* internal_default_instance() {
    return reinterpret_cast<const RayProperties*>(
               &_RayProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RayProperties& a, RayProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(RayProperties* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RayProperties* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RayProperties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RayProperties>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RayProperties& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RayProperties& from) {
    RayProperties::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RayProperties* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RayProperties";
  }
  protected:
  explicit RayProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameFieldNumber = 2,
    kRayFieldNumber = 1,
  };
  // string frame = 2;
  void clear_frame();
  const std::string& frame() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame();
  PROTOBUF_NODISCARD std::string* release_frame();
  void set_allocated_frame(std::string* frame);
  private:
  const std::string& _internal_frame() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame(const std::string& value);
  std::string* _internal_mutable_frame();
  public:

  // .bosdyn.api.Ray ray = 1;
  bool has_ray() const;
  private:
  bool _internal_has_ray() const;
  public:
  void clear_ray();
  const ::bosdyn::api::Ray& ray() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Ray* release_ray();
  ::bosdyn::api::Ray* mutable_ray();
  void set_allocated_ray(::bosdyn::api::Ray* ray);
  private:
  const ::bosdyn::api::Ray& _internal_ray() const;
  ::bosdyn::api::Ray* _internal_mutable_ray();
  public:
  void unsafe_arena_set_allocated_ray(
      ::bosdyn::api::Ray* ray);
  ::bosdyn::api::Ray* unsafe_arena_release_ray();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RayProperties)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_;
    ::bosdyn::api::Ray* ray_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class BoundingBoxProperties final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.BoundingBoxProperties) */ {
 public:
  inline BoundingBoxProperties() : BoundingBoxProperties(nullptr) {}
  ~BoundingBoxProperties() override;
  explicit PROTOBUF_CONSTEXPR BoundingBoxProperties(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoundingBoxProperties(const BoundingBoxProperties& from);
  BoundingBoxProperties(BoundingBoxProperties&& from) noexcept
    : BoundingBoxProperties() {
    *this = ::std::move(from);
  }

  inline BoundingBoxProperties& operator=(const BoundingBoxProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoundingBoxProperties& operator=(BoundingBoxProperties&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoundingBoxProperties& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoundingBoxProperties* internal_default_instance() {
    return reinterpret_cast<const BoundingBoxProperties*>(
               &_BoundingBoxProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BoundingBoxProperties& a, BoundingBoxProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(BoundingBoxProperties* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoundingBoxProperties* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoundingBoxProperties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoundingBoxProperties>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoundingBoxProperties& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoundingBoxProperties& from) {
    BoundingBoxProperties::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoundingBoxProperties* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.BoundingBoxProperties";
  }
  protected:
  explicit BoundingBoxProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameFieldNumber = 2,
    kSizeEwrtFrameFieldNumber = 1,
  };
  // string frame = 2;
  void clear_frame();
  const std::string& frame() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame();
  PROTOBUF_NODISCARD std::string* release_frame();
  void set_allocated_frame(std::string* frame);
  private:
  const std::string& _internal_frame() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame(const std::string& value);
  std::string* _internal_mutable_frame();
  public:

  // .bosdyn.api.Vec3 size_ewrt_frame = 1;
  bool has_size_ewrt_frame() const;
  private:
  bool _internal_has_size_ewrt_frame() const;
  public:
  void clear_size_ewrt_frame();
  const ::bosdyn::api::Vec3& size_ewrt_frame() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_size_ewrt_frame();
  ::bosdyn::api::Vec3* mutable_size_ewrt_frame();
  void set_allocated_size_ewrt_frame(::bosdyn::api::Vec3* size_ewrt_frame);
  private:
  const ::bosdyn::api::Vec3& _internal_size_ewrt_frame() const;
  ::bosdyn::api::Vec3* _internal_mutable_size_ewrt_frame();
  public:
  void unsafe_arena_set_allocated_size_ewrt_frame(
      ::bosdyn::api::Vec3* size_ewrt_frame);
  ::bosdyn::api::Vec3* unsafe_arena_release_size_ewrt_frame();

  // @@protoc_insertion_point(class_scope:bosdyn.api.BoundingBoxProperties)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_;
    ::bosdyn::api::Vec3* size_ewrt_frame_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class DrawableProperties_Color final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DrawableProperties.Color) */ {
 public:
  inline DrawableProperties_Color() : DrawableProperties_Color(nullptr) {}
  ~DrawableProperties_Color() override;
  explicit PROTOBUF_CONSTEXPR DrawableProperties_Color(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawableProperties_Color(const DrawableProperties_Color& from);
  DrawableProperties_Color(DrawableProperties_Color&& from) noexcept
    : DrawableProperties_Color() {
    *this = ::std::move(from);
  }

  inline DrawableProperties_Color& operator=(const DrawableProperties_Color& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawableProperties_Color& operator=(DrawableProperties_Color&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawableProperties_Color& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawableProperties_Color* internal_default_instance() {
    return reinterpret_cast<const DrawableProperties_Color*>(
               &_DrawableProperties_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DrawableProperties_Color& a, DrawableProperties_Color& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawableProperties_Color* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawableProperties_Color* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawableProperties_Color* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawableProperties_Color>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrawableProperties_Color& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrawableProperties_Color& from) {
    DrawableProperties_Color::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawableProperties_Color* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DrawableProperties.Color";
  }
  protected:
  explicit DrawableProperties_Color(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kAFieldNumber = 4,
    kBFieldNumber = 3,
  };
  // int32 r = 1;
  void clear_r();
  int32_t r() const;
  void set_r(int32_t value);
  private:
  int32_t _internal_r() const;
  void _internal_set_r(int32_t value);
  public:

  // int32 g = 2;
  void clear_g();
  int32_t g() const;
  void set_g(int32_t value);
  private:
  int32_t _internal_g() const;
  void _internal_set_g(int32_t value);
  public:

  // double a = 4;
  void clear_a();
  double a() const;
  void set_a(double value);
  private:
  double _internal_a() const;
  void _internal_set_a(double value);
  public:

  // int32 b = 3;
  void clear_b();
  int32_t b() const;
  void set_b(int32_t value);
  private:
  int32_t _internal_b() const;
  void _internal_set_b(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.DrawableProperties.Color)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t r_;
    int32_t g_;
    double a_;
    int32_t b_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class DrawableProperties final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DrawableProperties) */ {
 public:
  inline DrawableProperties() : DrawableProperties(nullptr) {}
  ~DrawableProperties() override;
  explicit PROTOBUF_CONSTEXPR DrawableProperties(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawableProperties(const DrawableProperties& from);
  DrawableProperties(DrawableProperties&& from) noexcept
    : DrawableProperties() {
    *this = ::std::move(from);
  }

  inline DrawableProperties& operator=(const DrawableProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawableProperties& operator=(DrawableProperties&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawableProperties& default_instance() {
    return *internal_default_instance();
  }
  enum DrawableCase {
    kFrame = 4,
    kSphere = 5,
    kBox = 6,
    kArrow = 7,
    kCapsule = 8,
    kCylinder = 9,
    kLinestrip = 10,
    kPoints = 11,
    DRAWABLE_NOT_SET = 0,
  };

  static inline const DrawableProperties* internal_default_instance() {
    return reinterpret_cast<const DrawableProperties*>(
               &_DrawableProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DrawableProperties& a, DrawableProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawableProperties* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawableProperties* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawableProperties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawableProperties>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrawableProperties& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrawableProperties& from) {
    DrawableProperties::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawableProperties* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DrawableProperties";
  }
  protected:
  explicit DrawableProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DrawableProperties_Color Color;

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 2,
    kFrameNameDrawableFieldNumber = 12,
    kColorFieldNumber = 1,
    kWireframeFieldNumber = 3,
    kFrameFieldNumber = 4,
    kSphereFieldNumber = 5,
    kBoxFieldNumber = 6,
    kArrowFieldNumber = 7,
    kCapsuleFieldNumber = 8,
    kCylinderFieldNumber = 9,
    kLinestripFieldNumber = 10,
    kPointsFieldNumber = 11,
  };
  // string label = 2;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // string frame_name_drawable = 12;
  void clear_frame_name_drawable();
  const std::string& frame_name_drawable() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name_drawable(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name_drawable();
  PROTOBUF_NODISCARD std::string* release_frame_name_drawable();
  void set_allocated_frame_name_drawable(std::string* frame_name_drawable);
  private:
  const std::string& _internal_frame_name_drawable() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name_drawable(const std::string& value);
  std::string* _internal_mutable_frame_name_drawable();
  public:

  // .bosdyn.api.DrawableProperties.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::bosdyn::api::DrawableProperties_Color& color() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DrawableProperties_Color* release_color();
  ::bosdyn::api::DrawableProperties_Color* mutable_color();
  void set_allocated_color(::bosdyn::api::DrawableProperties_Color* color);
  private:
  const ::bosdyn::api::DrawableProperties_Color& _internal_color() const;
  ::bosdyn::api::DrawableProperties_Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::bosdyn::api::DrawableProperties_Color* color);
  ::bosdyn::api::DrawableProperties_Color* unsafe_arena_release_color();

  // bool wireframe = 3;
  void clear_wireframe();
  bool wireframe() const;
  void set_wireframe(bool value);
  private:
  bool _internal_wireframe() const;
  void _internal_set_wireframe(bool value);
  public:

  // .bosdyn.api.DrawableFrame frame = 4;
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;
  public:
  void clear_frame();
  const ::bosdyn::api::DrawableFrame& frame() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DrawableFrame* release_frame();
  ::bosdyn::api::DrawableFrame* mutable_frame();
  void set_allocated_frame(::bosdyn::api::DrawableFrame* frame);
  private:
  const ::bosdyn::api::DrawableFrame& _internal_frame() const;
  ::bosdyn::api::DrawableFrame* _internal_mutable_frame();
  public:
  void unsafe_arena_set_allocated_frame(
      ::bosdyn::api::DrawableFrame* frame);
  ::bosdyn::api::DrawableFrame* unsafe_arena_release_frame();

  // .bosdyn.api.DrawableSphere sphere = 5;
  bool has_sphere() const;
  private:
  bool _internal_has_sphere() const;
  public:
  void clear_sphere();
  const ::bosdyn::api::DrawableSphere& sphere() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DrawableSphere* release_sphere();
  ::bosdyn::api::DrawableSphere* mutable_sphere();
  void set_allocated_sphere(::bosdyn::api::DrawableSphere* sphere);
  private:
  const ::bosdyn::api::DrawableSphere& _internal_sphere() const;
  ::bosdyn::api::DrawableSphere* _internal_mutable_sphere();
  public:
  void unsafe_arena_set_allocated_sphere(
      ::bosdyn::api::DrawableSphere* sphere);
  ::bosdyn::api::DrawableSphere* unsafe_arena_release_sphere();

  // .bosdyn.api.DrawableBox box = 6;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::bosdyn::api::DrawableBox& box() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DrawableBox* release_box();
  ::bosdyn::api::DrawableBox* mutable_box();
  void set_allocated_box(::bosdyn::api::DrawableBox* box);
  private:
  const ::bosdyn::api::DrawableBox& _internal_box() const;
  ::bosdyn::api::DrawableBox* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::bosdyn::api::DrawableBox* box);
  ::bosdyn::api::DrawableBox* unsafe_arena_release_box();

  // .bosdyn.api.DrawableArrow arrow = 7;
  bool has_arrow() const;
  private:
  bool _internal_has_arrow() const;
  public:
  void clear_arrow();
  const ::bosdyn::api::DrawableArrow& arrow() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DrawableArrow* release_arrow();
  ::bosdyn::api::DrawableArrow* mutable_arrow();
  void set_allocated_arrow(::bosdyn::api::DrawableArrow* arrow);
  private:
  const ::bosdyn::api::DrawableArrow& _internal_arrow() const;
  ::bosdyn::api::DrawableArrow* _internal_mutable_arrow();
  public:
  void unsafe_arena_set_allocated_arrow(
      ::bosdyn::api::DrawableArrow* arrow);
  ::bosdyn::api::DrawableArrow* unsafe_arena_release_arrow();

  // .bosdyn.api.DrawableCapsule capsule = 8;
  bool has_capsule() const;
  private:
  bool _internal_has_capsule() const;
  public:
  void clear_capsule();
  const ::bosdyn::api::DrawableCapsule& capsule() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DrawableCapsule* release_capsule();
  ::bosdyn::api::DrawableCapsule* mutable_capsule();
  void set_allocated_capsule(::bosdyn::api::DrawableCapsule* capsule);
  private:
  const ::bosdyn::api::DrawableCapsule& _internal_capsule() const;
  ::bosdyn::api::DrawableCapsule* _internal_mutable_capsule();
  public:
  void unsafe_arena_set_allocated_capsule(
      ::bosdyn::api::DrawableCapsule* capsule);
  ::bosdyn::api::DrawableCapsule* unsafe_arena_release_capsule();

  // .bosdyn.api.DrawableCylinder cylinder = 9;
  bool has_cylinder() const;
  private:
  bool _internal_has_cylinder() const;
  public:
  void clear_cylinder();
  const ::bosdyn::api::DrawableCylinder& cylinder() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DrawableCylinder* release_cylinder();
  ::bosdyn::api::DrawableCylinder* mutable_cylinder();
  void set_allocated_cylinder(::bosdyn::api::DrawableCylinder* cylinder);
  private:
  const ::bosdyn::api::DrawableCylinder& _internal_cylinder() const;
  ::bosdyn::api::DrawableCylinder* _internal_mutable_cylinder();
  public:
  void unsafe_arena_set_allocated_cylinder(
      ::bosdyn::api::DrawableCylinder* cylinder);
  ::bosdyn::api::DrawableCylinder* unsafe_arena_release_cylinder();

  // .bosdyn.api.DrawableLineStrip linestrip = 10;
  bool has_linestrip() const;
  private:
  bool _internal_has_linestrip() const;
  public:
  void clear_linestrip();
  const ::bosdyn::api::DrawableLineStrip& linestrip() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DrawableLineStrip* release_linestrip();
  ::bosdyn::api::DrawableLineStrip* mutable_linestrip();
  void set_allocated_linestrip(::bosdyn::api::DrawableLineStrip* linestrip);
  private:
  const ::bosdyn::api::DrawableLineStrip& _internal_linestrip() const;
  ::bosdyn::api::DrawableLineStrip* _internal_mutable_linestrip();
  public:
  void unsafe_arena_set_allocated_linestrip(
      ::bosdyn::api::DrawableLineStrip* linestrip);
  ::bosdyn::api::DrawableLineStrip* unsafe_arena_release_linestrip();

  // .bosdyn.api.DrawablePoints points = 11;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  const ::bosdyn::api::DrawablePoints& points() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DrawablePoints* release_points();
  ::bosdyn::api::DrawablePoints* mutable_points();
  void set_allocated_points(::bosdyn::api::DrawablePoints* points);
  private:
  const ::bosdyn::api::DrawablePoints& _internal_points() const;
  ::bosdyn::api::DrawablePoints* _internal_mutable_points();
  public:
  void unsafe_arena_set_allocated_points(
      ::bosdyn::api::DrawablePoints* points);
  ::bosdyn::api::DrawablePoints* unsafe_arena_release_points();

  void clear_drawable();
  DrawableCase drawable_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.DrawableProperties)
 private:
  class _Internal;
  void set_has_frame();
  void set_has_sphere();
  void set_has_box();
  void set_has_arrow();
  void set_has_capsule();
  void set_has_cylinder();
  void set_has_linestrip();
  void set_has_points();

  inline bool has_drawable() const;
  inline void clear_has_drawable();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_drawable_;
    ::bosdyn::api::DrawableProperties_Color* color_;
    bool wireframe_;
    union DrawableUnion {
      constexpr DrawableUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::DrawableFrame* frame_;
      ::bosdyn::api::DrawableSphere* sphere_;
      ::bosdyn::api::DrawableBox* box_;
      ::bosdyn::api::DrawableArrow* arrow_;
      ::bosdyn::api::DrawableCapsule* capsule_;
      ::bosdyn::api::DrawableCylinder* cylinder_;
      ::bosdyn::api::DrawableLineStrip* linestrip_;
      ::bosdyn::api::DrawablePoints* points_;
    } drawable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class DrawableFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DrawableFrame) */ {
 public:
  inline DrawableFrame() : DrawableFrame(nullptr) {}
  ~DrawableFrame() override;
  explicit PROTOBUF_CONSTEXPR DrawableFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawableFrame(const DrawableFrame& from);
  DrawableFrame(DrawableFrame&& from) noexcept
    : DrawableFrame() {
    *this = ::std::move(from);
  }

  inline DrawableFrame& operator=(const DrawableFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawableFrame& operator=(DrawableFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawableFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawableFrame* internal_default_instance() {
    return reinterpret_cast<const DrawableFrame*>(
               &_DrawableFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DrawableFrame& a, DrawableFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawableFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawableFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawableFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawableFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrawableFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrawableFrame& from) {
    DrawableFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawableFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DrawableFrame";
  }
  protected:
  explicit DrawableFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrowLengthFieldNumber = 1,
    kArrowRadiusFieldNumber = 2,
  };
  // double arrow_length = 1;
  void clear_arrow_length();
  double arrow_length() const;
  void set_arrow_length(double value);
  private:
  double _internal_arrow_length() const;
  void _internal_set_arrow_length(double value);
  public:

  // double arrow_radius = 2;
  void clear_arrow_radius();
  double arrow_radius() const;
  void set_arrow_radius(double value);
  private:
  double _internal_arrow_radius() const;
  void _internal_set_arrow_radius(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.DrawableFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double arrow_length_;
    double arrow_radius_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class DrawableSphere final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DrawableSphere) */ {
 public:
  inline DrawableSphere() : DrawableSphere(nullptr) {}
  ~DrawableSphere() override;
  explicit PROTOBUF_CONSTEXPR DrawableSphere(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawableSphere(const DrawableSphere& from);
  DrawableSphere(DrawableSphere&& from) noexcept
    : DrawableSphere() {
    *this = ::std::move(from);
  }

  inline DrawableSphere& operator=(const DrawableSphere& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawableSphere& operator=(DrawableSphere&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawableSphere& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawableSphere* internal_default_instance() {
    return reinterpret_cast<const DrawableSphere*>(
               &_DrawableSphere_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DrawableSphere& a, DrawableSphere& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawableSphere* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawableSphere* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawableSphere* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawableSphere>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrawableSphere& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrawableSphere& from) {
    DrawableSphere::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawableSphere* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DrawableSphere";
  }
  protected:
  explicit DrawableSphere(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRadiusFieldNumber = 1,
  };
  // double radius = 1;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.DrawableSphere)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double radius_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class DrawableBox final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DrawableBox) */ {
 public:
  inline DrawableBox() : DrawableBox(nullptr) {}
  ~DrawableBox() override;
  explicit PROTOBUF_CONSTEXPR DrawableBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawableBox(const DrawableBox& from);
  DrawableBox(DrawableBox&& from) noexcept
    : DrawableBox() {
    *this = ::std::move(from);
  }

  inline DrawableBox& operator=(const DrawableBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawableBox& operator=(DrawableBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawableBox& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawableBox* internal_default_instance() {
    return reinterpret_cast<const DrawableBox*>(
               &_DrawableBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DrawableBox& a, DrawableBox& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawableBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawableBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawableBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawableBox>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrawableBox& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrawableBox& from) {
    DrawableBox::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawableBox* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DrawableBox";
  }
  protected:
  explicit DrawableBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // .bosdyn.api.Vec3 size = 1;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::bosdyn::api::Vec3& size() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_size();
  ::bosdyn::api::Vec3* mutable_size();
  void set_allocated_size(::bosdyn::api::Vec3* size);
  private:
  const ::bosdyn::api::Vec3& _internal_size() const;
  ::bosdyn::api::Vec3* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::bosdyn::api::Vec3* size);
  ::bosdyn::api::Vec3* unsafe_arena_release_size();

  // @@protoc_insertion_point(class_scope:bosdyn.api.DrawableBox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec3* size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class DrawableArrow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DrawableArrow) */ {
 public:
  inline DrawableArrow() : DrawableArrow(nullptr) {}
  ~DrawableArrow() override;
  explicit PROTOBUF_CONSTEXPR DrawableArrow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawableArrow(const DrawableArrow& from);
  DrawableArrow(DrawableArrow&& from) noexcept
    : DrawableArrow() {
    *this = ::std::move(from);
  }

  inline DrawableArrow& operator=(const DrawableArrow& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawableArrow& operator=(DrawableArrow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawableArrow& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawableArrow* internal_default_instance() {
    return reinterpret_cast<const DrawableArrow*>(
               &_DrawableArrow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DrawableArrow& a, DrawableArrow& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawableArrow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawableArrow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawableArrow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawableArrow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrawableArrow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrawableArrow& from) {
    DrawableArrow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawableArrow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DrawableArrow";
  }
  protected:
  explicit DrawableArrow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionFieldNumber = 1,
    kRadiusFieldNumber = 2,
  };
  // .bosdyn.api.Vec3 direction = 1;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  const ::bosdyn::api::Vec3& direction() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_direction();
  ::bosdyn::api::Vec3* mutable_direction();
  void set_allocated_direction(::bosdyn::api::Vec3* direction);
  private:
  const ::bosdyn::api::Vec3& _internal_direction() const;
  ::bosdyn::api::Vec3* _internal_mutable_direction();
  public:
  void unsafe_arena_set_allocated_direction(
      ::bosdyn::api::Vec3* direction);
  ::bosdyn::api::Vec3* unsafe_arena_release_direction();

  // double radius = 2;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.DrawableArrow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec3* direction_;
    double radius_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class DrawableCapsule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DrawableCapsule) */ {
 public:
  inline DrawableCapsule() : DrawableCapsule(nullptr) {}
  ~DrawableCapsule() override;
  explicit PROTOBUF_CONSTEXPR DrawableCapsule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawableCapsule(const DrawableCapsule& from);
  DrawableCapsule(DrawableCapsule&& from) noexcept
    : DrawableCapsule() {
    *this = ::std::move(from);
  }

  inline DrawableCapsule& operator=(const DrawableCapsule& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawableCapsule& operator=(DrawableCapsule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawableCapsule& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawableCapsule* internal_default_instance() {
    return reinterpret_cast<const DrawableCapsule*>(
               &_DrawableCapsule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DrawableCapsule& a, DrawableCapsule& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawableCapsule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawableCapsule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawableCapsule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawableCapsule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrawableCapsule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrawableCapsule& from) {
    DrawableCapsule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawableCapsule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DrawableCapsule";
  }
  protected:
  explicit DrawableCapsule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionFieldNumber = 1,
    kRadiusFieldNumber = 2,
  };
  // .bosdyn.api.Vec3 direction = 1;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  const ::bosdyn::api::Vec3& direction() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_direction();
  ::bosdyn::api::Vec3* mutable_direction();
  void set_allocated_direction(::bosdyn::api::Vec3* direction);
  private:
  const ::bosdyn::api::Vec3& _internal_direction() const;
  ::bosdyn::api::Vec3* _internal_mutable_direction();
  public:
  void unsafe_arena_set_allocated_direction(
      ::bosdyn::api::Vec3* direction);
  ::bosdyn::api::Vec3* unsafe_arena_release_direction();

  // double radius = 2;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.DrawableCapsule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec3* direction_;
    double radius_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class DrawableCylinder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DrawableCylinder) */ {
 public:
  inline DrawableCylinder() : DrawableCylinder(nullptr) {}
  ~DrawableCylinder() override;
  explicit PROTOBUF_CONSTEXPR DrawableCylinder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawableCylinder(const DrawableCylinder& from);
  DrawableCylinder(DrawableCylinder&& from) noexcept
    : DrawableCylinder() {
    *this = ::std::move(from);
  }

  inline DrawableCylinder& operator=(const DrawableCylinder& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawableCylinder& operator=(DrawableCylinder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawableCylinder& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawableCylinder* internal_default_instance() {
    return reinterpret_cast<const DrawableCylinder*>(
               &_DrawableCylinder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DrawableCylinder& a, DrawableCylinder& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawableCylinder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawableCylinder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawableCylinder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawableCylinder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrawableCylinder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrawableCylinder& from) {
    DrawableCylinder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawableCylinder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DrawableCylinder";
  }
  protected:
  explicit DrawableCylinder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionFieldNumber = 1,
    kRadiusFieldNumber = 2,
  };
  // .bosdyn.api.Vec3 direction = 1;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  const ::bosdyn::api::Vec3& direction() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_direction();
  ::bosdyn::api::Vec3* mutable_direction();
  void set_allocated_direction(::bosdyn::api::Vec3* direction);
  private:
  const ::bosdyn::api::Vec3& _internal_direction() const;
  ::bosdyn::api::Vec3* _internal_mutable_direction();
  public:
  void unsafe_arena_set_allocated_direction(
      ::bosdyn::api::Vec3* direction);
  ::bosdyn::api::Vec3* unsafe_arena_release_direction();

  // double radius = 2;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.DrawableCylinder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec3* direction_;
    double radius_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class DrawableLineStrip final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DrawableLineStrip) */ {
 public:
  inline DrawableLineStrip() : DrawableLineStrip(nullptr) {}
  ~DrawableLineStrip() override;
  explicit PROTOBUF_CONSTEXPR DrawableLineStrip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawableLineStrip(const DrawableLineStrip& from);
  DrawableLineStrip(DrawableLineStrip&& from) noexcept
    : DrawableLineStrip() {
    *this = ::std::move(from);
  }

  inline DrawableLineStrip& operator=(const DrawableLineStrip& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawableLineStrip& operator=(DrawableLineStrip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawableLineStrip& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawableLineStrip* internal_default_instance() {
    return reinterpret_cast<const DrawableLineStrip*>(
               &_DrawableLineStrip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DrawableLineStrip& a, DrawableLineStrip& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawableLineStrip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawableLineStrip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawableLineStrip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawableLineStrip>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrawableLineStrip& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrawableLineStrip& from) {
    DrawableLineStrip::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawableLineStrip* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DrawableLineStrip";
  }
  protected:
  explicit DrawableLineStrip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
  };
  // .bosdyn.api.Vec3 points = 1;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  const ::bosdyn::api::Vec3& points() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_points();
  ::bosdyn::api::Vec3* mutable_points();
  void set_allocated_points(::bosdyn::api::Vec3* points);
  private:
  const ::bosdyn::api::Vec3& _internal_points() const;
  ::bosdyn::api::Vec3* _internal_mutable_points();
  public:
  void unsafe_arena_set_allocated_points(
      ::bosdyn::api::Vec3* points);
  ::bosdyn::api::Vec3* unsafe_arena_release_points();

  // @@protoc_insertion_point(class_scope:bosdyn.api.DrawableLineStrip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec3* points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// -------------------------------------------------------------------

class DrawablePoints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DrawablePoints) */ {
 public:
  inline DrawablePoints() : DrawablePoints(nullptr) {}
  ~DrawablePoints() override;
  explicit PROTOBUF_CONSTEXPR DrawablePoints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawablePoints(const DrawablePoints& from);
  DrawablePoints(DrawablePoints&& from) noexcept
    : DrawablePoints() {
    *this = ::std::move(from);
  }

  inline DrawablePoints& operator=(const DrawablePoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawablePoints& operator=(DrawablePoints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawablePoints& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawablePoints* internal_default_instance() {
    return reinterpret_cast<const DrawablePoints*>(
               &_DrawablePoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DrawablePoints& a, DrawablePoints& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawablePoints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawablePoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawablePoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawablePoints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrawablePoints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrawablePoints& from) {
    DrawablePoints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawablePoints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DrawablePoints";
  }
  protected:
  explicit DrawablePoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
  };
  // repeated .bosdyn.api.Vec3 points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::bosdyn::api::Vec3* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec3 >*
      mutable_points();
  private:
  const ::bosdyn::api::Vec3& _internal_points(int index) const;
  ::bosdyn::api::Vec3* _internal_add_points();
  public:
  const ::bosdyn::api::Vec3& points(int index) const;
  ::bosdyn::api::Vec3* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec3 >&
      points() const;

  // @@protoc_insertion_point(class_scope:bosdyn.api.DrawablePoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec3 > points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fworld_5fobject_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// WorldObject

// int32 id = 1;
inline void WorldObject::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t WorldObject::_internal_id() const {
  return _impl_.id_;
}
inline int32_t WorldObject::id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WorldObject.id)
  return _internal_id();
}
inline void WorldObject::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void WorldObject::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.WorldObject.id)
}

// string name = 2;
inline void WorldObject::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& WorldObject::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WorldObject.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorldObject::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.WorldObject.name)
}
inline std::string* WorldObject::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WorldObject.name)
  return _s;
}
inline const std::string& WorldObject::_internal_name() const {
  return _impl_.name_.Get();
}
inline void WorldObject::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* WorldObject::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* WorldObject::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WorldObject.name)
  return _impl_.name_.Release();
}
inline void WorldObject::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WorldObject.name)
}

// .google.protobuf.Timestamp acquisition_time = 30;
inline bool WorldObject::_internal_has_acquisition_time() const {
  return this != internal_default_instance() && _impl_.acquisition_time_ != nullptr;
}
inline bool WorldObject::has_acquisition_time() const {
  return _internal_has_acquisition_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& WorldObject::_internal_acquisition_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.acquisition_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& WorldObject::acquisition_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WorldObject.acquisition_time)
  return _internal_acquisition_time();
}
inline void WorldObject::unsafe_arena_set_allocated_acquisition_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acquisition_time_);
  }
  _impl_.acquisition_time_ = acquisition_time;
  if (acquisition_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.WorldObject.acquisition_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* WorldObject::release_acquisition_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.acquisition_time_;
  _impl_.acquisition_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* WorldObject::unsafe_arena_release_acquisition_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WorldObject.acquisition_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.acquisition_time_;
  _impl_.acquisition_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* WorldObject::_internal_mutable_acquisition_time() {
  
  if (_impl_.acquisition_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.acquisition_time_ = p;
  }
  return _impl_.acquisition_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* WorldObject::mutable_acquisition_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_acquisition_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WorldObject.acquisition_time)
  return _msg;
}
inline void WorldObject::set_allocated_acquisition_time(::PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acquisition_time_);
  }
  if (acquisition_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acquisition_time));
    if (message_arena != submessage_arena) {
      acquisition_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acquisition_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.acquisition_time_ = acquisition_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WorldObject.acquisition_time)
}

// .bosdyn.api.FrameTreeSnapshot transforms_snapshot = 31;
inline bool WorldObject::_internal_has_transforms_snapshot() const {
  return this != internal_default_instance() && _impl_.transforms_snapshot_ != nullptr;
}
inline bool WorldObject::has_transforms_snapshot() const {
  return _internal_has_transforms_snapshot();
}
inline const ::bosdyn::api::FrameTreeSnapshot& WorldObject::_internal_transforms_snapshot() const {
  const ::bosdyn::api::FrameTreeSnapshot* p = _impl_.transforms_snapshot_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::FrameTreeSnapshot&>(
      ::bosdyn::api::_FrameTreeSnapshot_default_instance_);
}
inline const ::bosdyn::api::FrameTreeSnapshot& WorldObject::transforms_snapshot() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WorldObject.transforms_snapshot)
  return _internal_transforms_snapshot();
}
inline void WorldObject::unsafe_arena_set_allocated_transforms_snapshot(
    ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transforms_snapshot_);
  }
  _impl_.transforms_snapshot_ = transforms_snapshot;
  if (transforms_snapshot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.WorldObject.transforms_snapshot)
}
inline ::bosdyn::api::FrameTreeSnapshot* WorldObject::release_transforms_snapshot() {
  
  ::bosdyn::api::FrameTreeSnapshot* temp = _impl_.transforms_snapshot_;
  _impl_.transforms_snapshot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::FrameTreeSnapshot* WorldObject::unsafe_arena_release_transforms_snapshot() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WorldObject.transforms_snapshot)
  
  ::bosdyn::api::FrameTreeSnapshot* temp = _impl_.transforms_snapshot_;
  _impl_.transforms_snapshot_ = nullptr;
  return temp;
}
inline ::bosdyn::api::FrameTreeSnapshot* WorldObject::_internal_mutable_transforms_snapshot() {
  
  if (_impl_.transforms_snapshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::FrameTreeSnapshot>(GetArenaForAllocation());
    _impl_.transforms_snapshot_ = p;
  }
  return _impl_.transforms_snapshot_;
}
inline ::bosdyn::api::FrameTreeSnapshot* WorldObject::mutable_transforms_snapshot() {
  ::bosdyn::api::FrameTreeSnapshot* _msg = _internal_mutable_transforms_snapshot();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WorldObject.transforms_snapshot)
  return _msg;
}
inline void WorldObject::set_allocated_transforms_snapshot(::bosdyn::api::FrameTreeSnapshot* transforms_snapshot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transforms_snapshot_);
  }
  if (transforms_snapshot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transforms_snapshot));
    if (message_arena != submessage_arena) {
      transforms_snapshot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transforms_snapshot, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transforms_snapshot_ = transforms_snapshot;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WorldObject.transforms_snapshot)
}

// repeated .bosdyn.api.DrawableProperties drawable_properties = 5;
inline int WorldObject::_internal_drawable_properties_size() const {
  return _impl_.drawable_properties_.size();
}
inline int WorldObject::drawable_properties_size() const {
  return _internal_drawable_properties_size();
}
inline void WorldObject::clear_drawable_properties() {
  _impl_.drawable_properties_.Clear();
}
inline ::bosdyn::api::DrawableProperties* WorldObject::mutable_drawable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WorldObject.drawable_properties)
  return _impl_.drawable_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DrawableProperties >*
WorldObject::mutable_drawable_properties() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.WorldObject.drawable_properties)
  return &_impl_.drawable_properties_;
}
inline const ::bosdyn::api::DrawableProperties& WorldObject::_internal_drawable_properties(int index) const {
  return _impl_.drawable_properties_.Get(index);
}
inline const ::bosdyn::api::DrawableProperties& WorldObject::drawable_properties(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WorldObject.drawable_properties)
  return _internal_drawable_properties(index);
}
inline ::bosdyn::api::DrawableProperties* WorldObject::_internal_add_drawable_properties() {
  return _impl_.drawable_properties_.Add();
}
inline ::bosdyn::api::DrawableProperties* WorldObject::add_drawable_properties() {
  ::bosdyn::api::DrawableProperties* _add = _internal_add_drawable_properties();
  // @@protoc_insertion_point(field_add:bosdyn.api.WorldObject.drawable_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DrawableProperties >&
WorldObject::drawable_properties() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.WorldObject.drawable_properties)
  return _impl_.drawable_properties_;
}

// .bosdyn.api.AprilTagProperties apriltag_properties = 6;
inline bool WorldObject::_internal_has_apriltag_properties() const {
  return this != internal_default_instance() && _impl_.apriltag_properties_ != nullptr;
}
inline bool WorldObject::has_apriltag_properties() const {
  return _internal_has_apriltag_properties();
}
inline void WorldObject::clear_apriltag_properties() {
  if (GetArenaForAllocation() == nullptr && _impl_.apriltag_properties_ != nullptr) {
    delete _impl_.apriltag_properties_;
  }
  _impl_.apriltag_properties_ = nullptr;
}
inline const ::bosdyn::api::AprilTagProperties& WorldObject::_internal_apriltag_properties() const {
  const ::bosdyn::api::AprilTagProperties* p = _impl_.apriltag_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::AprilTagProperties&>(
      ::bosdyn::api::_AprilTagProperties_default_instance_);
}
inline const ::bosdyn::api::AprilTagProperties& WorldObject::apriltag_properties() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WorldObject.apriltag_properties)
  return _internal_apriltag_properties();
}
inline void WorldObject::unsafe_arena_set_allocated_apriltag_properties(
    ::bosdyn::api::AprilTagProperties* apriltag_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.apriltag_properties_);
  }
  _impl_.apriltag_properties_ = apriltag_properties;
  if (apriltag_properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.WorldObject.apriltag_properties)
}
inline ::bosdyn::api::AprilTagProperties* WorldObject::release_apriltag_properties() {
  
  ::bosdyn::api::AprilTagProperties* temp = _impl_.apriltag_properties_;
  _impl_.apriltag_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::AprilTagProperties* WorldObject::unsafe_arena_release_apriltag_properties() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WorldObject.apriltag_properties)
  
  ::bosdyn::api::AprilTagProperties* temp = _impl_.apriltag_properties_;
  _impl_.apriltag_properties_ = nullptr;
  return temp;
}
inline ::bosdyn::api::AprilTagProperties* WorldObject::_internal_mutable_apriltag_properties() {
  
  if (_impl_.apriltag_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::AprilTagProperties>(GetArenaForAllocation());
    _impl_.apriltag_properties_ = p;
  }
  return _impl_.apriltag_properties_;
}
inline ::bosdyn::api::AprilTagProperties* WorldObject::mutable_apriltag_properties() {
  ::bosdyn::api::AprilTagProperties* _msg = _internal_mutable_apriltag_properties();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WorldObject.apriltag_properties)
  return _msg;
}
inline void WorldObject::set_allocated_apriltag_properties(::bosdyn::api::AprilTagProperties* apriltag_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.apriltag_properties_;
  }
  if (apriltag_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(apriltag_properties);
    if (message_arena != submessage_arena) {
      apriltag_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, apriltag_properties, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.apriltag_properties_ = apriltag_properties;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WorldObject.apriltag_properties)
}

// .bosdyn.api.ImageProperties image_properties = 9;
inline bool WorldObject::_internal_has_image_properties() const {
  return this != internal_default_instance() && _impl_.image_properties_ != nullptr;
}
inline bool WorldObject::has_image_properties() const {
  return _internal_has_image_properties();
}
inline void WorldObject::clear_image_properties() {
  if (GetArenaForAllocation() == nullptr && _impl_.image_properties_ != nullptr) {
    delete _impl_.image_properties_;
  }
  _impl_.image_properties_ = nullptr;
}
inline const ::bosdyn::api::ImageProperties& WorldObject::_internal_image_properties() const {
  const ::bosdyn::api::ImageProperties* p = _impl_.image_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ImageProperties&>(
      ::bosdyn::api::_ImageProperties_default_instance_);
}
inline const ::bosdyn::api::ImageProperties& WorldObject::image_properties() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WorldObject.image_properties)
  return _internal_image_properties();
}
inline void WorldObject::unsafe_arena_set_allocated_image_properties(
    ::bosdyn::api::ImageProperties* image_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_properties_);
  }
  _impl_.image_properties_ = image_properties;
  if (image_properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.WorldObject.image_properties)
}
inline ::bosdyn::api::ImageProperties* WorldObject::release_image_properties() {
  
  ::bosdyn::api::ImageProperties* temp = _impl_.image_properties_;
  _impl_.image_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ImageProperties* WorldObject::unsafe_arena_release_image_properties() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WorldObject.image_properties)
  
  ::bosdyn::api::ImageProperties* temp = _impl_.image_properties_;
  _impl_.image_properties_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ImageProperties* WorldObject::_internal_mutable_image_properties() {
  
  if (_impl_.image_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ImageProperties>(GetArenaForAllocation());
    _impl_.image_properties_ = p;
  }
  return _impl_.image_properties_;
}
inline ::bosdyn::api::ImageProperties* WorldObject::mutable_image_properties() {
  ::bosdyn::api::ImageProperties* _msg = _internal_mutable_image_properties();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WorldObject.image_properties)
  return _msg;
}
inline void WorldObject::set_allocated_image_properties(::bosdyn::api::ImageProperties* image_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.image_properties_;
  }
  if (image_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image_properties);
    if (message_arena != submessage_arena) {
      image_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_properties, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_properties_ = image_properties;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WorldObject.image_properties)
}

// .bosdyn.api.DockProperties dock_properties = 10;
inline bool WorldObject::_internal_has_dock_properties() const {
  return this != internal_default_instance() && _impl_.dock_properties_ != nullptr;
}
inline bool WorldObject::has_dock_properties() const {
  return _internal_has_dock_properties();
}
inline void WorldObject::clear_dock_properties() {
  if (GetArenaForAllocation() == nullptr && _impl_.dock_properties_ != nullptr) {
    delete _impl_.dock_properties_;
  }
  _impl_.dock_properties_ = nullptr;
}
inline const ::bosdyn::api::DockProperties& WorldObject::_internal_dock_properties() const {
  const ::bosdyn::api::DockProperties* p = _impl_.dock_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DockProperties&>(
      ::bosdyn::api::_DockProperties_default_instance_);
}
inline const ::bosdyn::api::DockProperties& WorldObject::dock_properties() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WorldObject.dock_properties)
  return _internal_dock_properties();
}
inline void WorldObject::unsafe_arena_set_allocated_dock_properties(
    ::bosdyn::api::DockProperties* dock_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dock_properties_);
  }
  _impl_.dock_properties_ = dock_properties;
  if (dock_properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.WorldObject.dock_properties)
}
inline ::bosdyn::api::DockProperties* WorldObject::release_dock_properties() {
  
  ::bosdyn::api::DockProperties* temp = _impl_.dock_properties_;
  _impl_.dock_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DockProperties* WorldObject::unsafe_arena_release_dock_properties() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WorldObject.dock_properties)
  
  ::bosdyn::api::DockProperties* temp = _impl_.dock_properties_;
  _impl_.dock_properties_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DockProperties* WorldObject::_internal_mutable_dock_properties() {
  
  if (_impl_.dock_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DockProperties>(GetArenaForAllocation());
    _impl_.dock_properties_ = p;
  }
  return _impl_.dock_properties_;
}
inline ::bosdyn::api::DockProperties* WorldObject::mutable_dock_properties() {
  ::bosdyn::api::DockProperties* _msg = _internal_mutable_dock_properties();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WorldObject.dock_properties)
  return _msg;
}
inline void WorldObject::set_allocated_dock_properties(::bosdyn::api::DockProperties* dock_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dock_properties_;
  }
  if (dock_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dock_properties);
    if (message_arena != submessage_arena) {
      dock_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dock_properties, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.dock_properties_ = dock_properties;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WorldObject.dock_properties)
}

// .bosdyn.api.RayProperties ray_properties = 11;
inline bool WorldObject::_internal_has_ray_properties() const {
  return this != internal_default_instance() && _impl_.ray_properties_ != nullptr;
}
inline bool WorldObject::has_ray_properties() const {
  return _internal_has_ray_properties();
}
inline void WorldObject::clear_ray_properties() {
  if (GetArenaForAllocation() == nullptr && _impl_.ray_properties_ != nullptr) {
    delete _impl_.ray_properties_;
  }
  _impl_.ray_properties_ = nullptr;
}
inline const ::bosdyn::api::RayProperties& WorldObject::_internal_ray_properties() const {
  const ::bosdyn::api::RayProperties* p = _impl_.ray_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RayProperties&>(
      ::bosdyn::api::_RayProperties_default_instance_);
}
inline const ::bosdyn::api::RayProperties& WorldObject::ray_properties() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WorldObject.ray_properties)
  return _internal_ray_properties();
}
inline void WorldObject::unsafe_arena_set_allocated_ray_properties(
    ::bosdyn::api::RayProperties* ray_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ray_properties_);
  }
  _impl_.ray_properties_ = ray_properties;
  if (ray_properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.WorldObject.ray_properties)
}
inline ::bosdyn::api::RayProperties* WorldObject::release_ray_properties() {
  
  ::bosdyn::api::RayProperties* temp = _impl_.ray_properties_;
  _impl_.ray_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RayProperties* WorldObject::unsafe_arena_release_ray_properties() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WorldObject.ray_properties)
  
  ::bosdyn::api::RayProperties* temp = _impl_.ray_properties_;
  _impl_.ray_properties_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RayProperties* WorldObject::_internal_mutable_ray_properties() {
  
  if (_impl_.ray_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RayProperties>(GetArenaForAllocation());
    _impl_.ray_properties_ = p;
  }
  return _impl_.ray_properties_;
}
inline ::bosdyn::api::RayProperties* WorldObject::mutable_ray_properties() {
  ::bosdyn::api::RayProperties* _msg = _internal_mutable_ray_properties();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WorldObject.ray_properties)
  return _msg;
}
inline void WorldObject::set_allocated_ray_properties(::bosdyn::api::RayProperties* ray_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ray_properties_;
  }
  if (ray_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ray_properties);
    if (message_arena != submessage_arena) {
      ray_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ray_properties, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ray_properties_ = ray_properties;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WorldObject.ray_properties)
}

// .bosdyn.api.BoundingBoxProperties bounding_box_properties = 12;
inline bool WorldObject::_internal_has_bounding_box_properties() const {
  return this != internal_default_instance() && _impl_.bounding_box_properties_ != nullptr;
}
inline bool WorldObject::has_bounding_box_properties() const {
  return _internal_has_bounding_box_properties();
}
inline void WorldObject::clear_bounding_box_properties() {
  if (GetArenaForAllocation() == nullptr && _impl_.bounding_box_properties_ != nullptr) {
    delete _impl_.bounding_box_properties_;
  }
  _impl_.bounding_box_properties_ = nullptr;
}
inline const ::bosdyn::api::BoundingBoxProperties& WorldObject::_internal_bounding_box_properties() const {
  const ::bosdyn::api::BoundingBoxProperties* p = _impl_.bounding_box_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::BoundingBoxProperties&>(
      ::bosdyn::api::_BoundingBoxProperties_default_instance_);
}
inline const ::bosdyn::api::BoundingBoxProperties& WorldObject::bounding_box_properties() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WorldObject.bounding_box_properties)
  return _internal_bounding_box_properties();
}
inline void WorldObject::unsafe_arena_set_allocated_bounding_box_properties(
    ::bosdyn::api::BoundingBoxProperties* bounding_box_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bounding_box_properties_);
  }
  _impl_.bounding_box_properties_ = bounding_box_properties;
  if (bounding_box_properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.WorldObject.bounding_box_properties)
}
inline ::bosdyn::api::BoundingBoxProperties* WorldObject::release_bounding_box_properties() {
  
  ::bosdyn::api::BoundingBoxProperties* temp = _impl_.bounding_box_properties_;
  _impl_.bounding_box_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::BoundingBoxProperties* WorldObject::unsafe_arena_release_bounding_box_properties() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WorldObject.bounding_box_properties)
  
  ::bosdyn::api::BoundingBoxProperties* temp = _impl_.bounding_box_properties_;
  _impl_.bounding_box_properties_ = nullptr;
  return temp;
}
inline ::bosdyn::api::BoundingBoxProperties* WorldObject::_internal_mutable_bounding_box_properties() {
  
  if (_impl_.bounding_box_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::BoundingBoxProperties>(GetArenaForAllocation());
    _impl_.bounding_box_properties_ = p;
  }
  return _impl_.bounding_box_properties_;
}
inline ::bosdyn::api::BoundingBoxProperties* WorldObject::mutable_bounding_box_properties() {
  ::bosdyn::api::BoundingBoxProperties* _msg = _internal_mutable_bounding_box_properties();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WorldObject.bounding_box_properties)
  return _msg;
}
inline void WorldObject::set_allocated_bounding_box_properties(::bosdyn::api::BoundingBoxProperties* bounding_box_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bounding_box_properties_;
  }
  if (bounding_box_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bounding_box_properties);
    if (message_arena != submessage_arena) {
      bounding_box_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bounding_box_properties, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bounding_box_properties_ = bounding_box_properties;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WorldObject.bounding_box_properties)
}

// .google.protobuf.Any additional_properties = 100;
inline bool WorldObject::_internal_has_additional_properties() const {
  return this != internal_default_instance() && _impl_.additional_properties_ != nullptr;
}
inline bool WorldObject::has_additional_properties() const {
  return _internal_has_additional_properties();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& WorldObject::_internal_additional_properties() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.additional_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& WorldObject::additional_properties() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WorldObject.additional_properties)
  return _internal_additional_properties();
}
inline void WorldObject::unsafe_arena_set_allocated_additional_properties(
    ::PROTOBUF_NAMESPACE_ID::Any* additional_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.additional_properties_);
  }
  _impl_.additional_properties_ = additional_properties;
  if (additional_properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.WorldObject.additional_properties)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* WorldObject::release_additional_properties() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.additional_properties_;
  _impl_.additional_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* WorldObject::unsafe_arena_release_additional_properties() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WorldObject.additional_properties)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.additional_properties_;
  _impl_.additional_properties_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* WorldObject::_internal_mutable_additional_properties() {
  
  if (_impl_.additional_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.additional_properties_ = p;
  }
  return _impl_.additional_properties_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* WorldObject::mutable_additional_properties() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_additional_properties();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WorldObject.additional_properties)
  return _msg;
}
inline void WorldObject::set_allocated_additional_properties(::PROTOBUF_NAMESPACE_ID::Any* additional_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.additional_properties_);
  }
  if (additional_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(additional_properties));
    if (message_arena != submessage_arena) {
      additional_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, additional_properties, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.additional_properties_ = additional_properties;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WorldObject.additional_properties)
}

// -------------------------------------------------------------------

// ListWorldObjectRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListWorldObjectRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListWorldObjectRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListWorldObjectRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListWorldObjectRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListWorldObjectRequest.header)
  return _internal_header();
}
inline void ListWorldObjectRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListWorldObjectRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListWorldObjectRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListWorldObjectRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListWorldObjectRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListWorldObjectRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ListWorldObjectRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListWorldObjectRequest.header)
  return _msg;
}
inline void ListWorldObjectRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListWorldObjectRequest.header)
}

// repeated .bosdyn.api.WorldObjectType object_type = 2;
inline int ListWorldObjectRequest::_internal_object_type_size() const {
  return _impl_.object_type_.size();
}
inline int ListWorldObjectRequest::object_type_size() const {
  return _internal_object_type_size();
}
inline void ListWorldObjectRequest::clear_object_type() {
  _impl_.object_type_.Clear();
}
inline ::bosdyn::api::WorldObjectType ListWorldObjectRequest::_internal_object_type(int index) const {
  return static_cast< ::bosdyn::api::WorldObjectType >(_impl_.object_type_.Get(index));
}
inline ::bosdyn::api::WorldObjectType ListWorldObjectRequest::object_type(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListWorldObjectRequest.object_type)
  return _internal_object_type(index);
}
inline void ListWorldObjectRequest::set_object_type(int index, ::bosdyn::api::WorldObjectType value) {
  _impl_.object_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ListWorldObjectRequest.object_type)
}
inline void ListWorldObjectRequest::_internal_add_object_type(::bosdyn::api::WorldObjectType value) {
  _impl_.object_type_.Add(value);
}
inline void ListWorldObjectRequest::add_object_type(::bosdyn::api::WorldObjectType value) {
  _internal_add_object_type(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.ListWorldObjectRequest.object_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ListWorldObjectRequest::object_type() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ListWorldObjectRequest.object_type)
  return _impl_.object_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListWorldObjectRequest::_internal_mutable_object_type() {
  return &_impl_.object_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListWorldObjectRequest::mutable_object_type() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ListWorldObjectRequest.object_type)
  return _internal_mutable_object_type();
}

// .google.protobuf.Timestamp timestamp_filter = 3;
inline bool ListWorldObjectRequest::_internal_has_timestamp_filter() const {
  return this != internal_default_instance() && _impl_.timestamp_filter_ != nullptr;
}
inline bool ListWorldObjectRequest::has_timestamp_filter() const {
  return _internal_has_timestamp_filter();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListWorldObjectRequest::_internal_timestamp_filter() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListWorldObjectRequest::timestamp_filter() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListWorldObjectRequest.timestamp_filter)
  return _internal_timestamp_filter();
}
inline void ListWorldObjectRequest::unsafe_arena_set_allocated_timestamp_filter(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_filter_);
  }
  _impl_.timestamp_filter_ = timestamp_filter;
  if (timestamp_filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListWorldObjectRequest.timestamp_filter)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListWorldObjectRequest::release_timestamp_filter() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_filter_;
  _impl_.timestamp_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListWorldObjectRequest::unsafe_arena_release_timestamp_filter() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListWorldObjectRequest.timestamp_filter)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_filter_;
  _impl_.timestamp_filter_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListWorldObjectRequest::_internal_mutable_timestamp_filter() {
  
  if (_impl_.timestamp_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_filter_ = p;
  }
  return _impl_.timestamp_filter_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListWorldObjectRequest::mutable_timestamp_filter() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp_filter();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListWorldObjectRequest.timestamp_filter)
  return _msg;
}
inline void ListWorldObjectRequest::set_allocated_timestamp_filter(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_filter_);
  }
  if (timestamp_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_filter));
    if (message_arena != submessage_arena) {
      timestamp_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp_filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_filter_ = timestamp_filter;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListWorldObjectRequest.timestamp_filter)
}

// -------------------------------------------------------------------

// ListWorldObjectResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListWorldObjectResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListWorldObjectResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListWorldObjectResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListWorldObjectResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListWorldObjectResponse.header)
  return _internal_header();
}
inline void ListWorldObjectResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListWorldObjectResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListWorldObjectResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListWorldObjectResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListWorldObjectResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListWorldObjectResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ListWorldObjectResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListWorldObjectResponse.header)
  return _msg;
}
inline void ListWorldObjectResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListWorldObjectResponse.header)
}

// repeated .bosdyn.api.WorldObject world_objects = 2;
inline int ListWorldObjectResponse::_internal_world_objects_size() const {
  return _impl_.world_objects_.size();
}
inline int ListWorldObjectResponse::world_objects_size() const {
  return _internal_world_objects_size();
}
inline void ListWorldObjectResponse::clear_world_objects() {
  _impl_.world_objects_.Clear();
}
inline ::bosdyn::api::WorldObject* ListWorldObjectResponse::mutable_world_objects(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListWorldObjectResponse.world_objects)
  return _impl_.world_objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::WorldObject >*
ListWorldObjectResponse::mutable_world_objects() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ListWorldObjectResponse.world_objects)
  return &_impl_.world_objects_;
}
inline const ::bosdyn::api::WorldObject& ListWorldObjectResponse::_internal_world_objects(int index) const {
  return _impl_.world_objects_.Get(index);
}
inline const ::bosdyn::api::WorldObject& ListWorldObjectResponse::world_objects(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListWorldObjectResponse.world_objects)
  return _internal_world_objects(index);
}
inline ::bosdyn::api::WorldObject* ListWorldObjectResponse::_internal_add_world_objects() {
  return _impl_.world_objects_.Add();
}
inline ::bosdyn::api::WorldObject* ListWorldObjectResponse::add_world_objects() {
  ::bosdyn::api::WorldObject* _add = _internal_add_world_objects();
  // @@protoc_insertion_point(field_add:bosdyn.api.ListWorldObjectResponse.world_objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::WorldObject >&
ListWorldObjectResponse::world_objects() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ListWorldObjectResponse.world_objects)
  return _impl_.world_objects_;
}

// -------------------------------------------------------------------

// MutateWorldObjectRequest_Mutation

// .bosdyn.api.MutateWorldObjectRequest.Action action = 1;
inline void MutateWorldObjectRequest_Mutation::clear_action() {
  _impl_.action_ = 0;
}
inline ::bosdyn::api::MutateWorldObjectRequest_Action MutateWorldObjectRequest_Mutation::_internal_action() const {
  return static_cast< ::bosdyn::api::MutateWorldObjectRequest_Action >(_impl_.action_);
}
inline ::bosdyn::api::MutateWorldObjectRequest_Action MutateWorldObjectRequest_Mutation::action() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MutateWorldObjectRequest.Mutation.action)
  return _internal_action();
}
inline void MutateWorldObjectRequest_Mutation::_internal_set_action(::bosdyn::api::MutateWorldObjectRequest_Action value) {
  
  _impl_.action_ = value;
}
inline void MutateWorldObjectRequest_Mutation::set_action(::bosdyn::api::MutateWorldObjectRequest_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MutateWorldObjectRequest.Mutation.action)
}

// .bosdyn.api.WorldObject object = 2;
inline bool MutateWorldObjectRequest_Mutation::_internal_has_object() const {
  return this != internal_default_instance() && _impl_.object_ != nullptr;
}
inline bool MutateWorldObjectRequest_Mutation::has_object() const {
  return _internal_has_object();
}
inline void MutateWorldObjectRequest_Mutation::clear_object() {
  if (GetArenaForAllocation() == nullptr && _impl_.object_ != nullptr) {
    delete _impl_.object_;
  }
  _impl_.object_ = nullptr;
}
inline const ::bosdyn::api::WorldObject& MutateWorldObjectRequest_Mutation::_internal_object() const {
  const ::bosdyn::api::WorldObject* p = _impl_.object_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::WorldObject&>(
      ::bosdyn::api::_WorldObject_default_instance_);
}
inline const ::bosdyn::api::WorldObject& MutateWorldObjectRequest_Mutation::object() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MutateWorldObjectRequest.Mutation.object)
  return _internal_object();
}
inline void MutateWorldObjectRequest_Mutation::unsafe_arena_set_allocated_object(
    ::bosdyn::api::WorldObject* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.object_);
  }
  _impl_.object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.MutateWorldObjectRequest.Mutation.object)
}
inline ::bosdyn::api::WorldObject* MutateWorldObjectRequest_Mutation::release_object() {
  
  ::bosdyn::api::WorldObject* temp = _impl_.object_;
  _impl_.object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::WorldObject* MutateWorldObjectRequest_Mutation::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:bosdyn.api.MutateWorldObjectRequest.Mutation.object)
  
  ::bosdyn::api::WorldObject* temp = _impl_.object_;
  _impl_.object_ = nullptr;
  return temp;
}
inline ::bosdyn::api::WorldObject* MutateWorldObjectRequest_Mutation::_internal_mutable_object() {
  
  if (_impl_.object_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::WorldObject>(GetArenaForAllocation());
    _impl_.object_ = p;
  }
  return _impl_.object_;
}
inline ::bosdyn::api::WorldObject* MutateWorldObjectRequest_Mutation::mutable_object() {
  ::bosdyn::api::WorldObject* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.MutateWorldObjectRequest.Mutation.object)
  return _msg;
}
inline void MutateWorldObjectRequest_Mutation::set_allocated_object(::bosdyn::api::WorldObject* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.object_ = object;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.MutateWorldObjectRequest.Mutation.object)
}

// -------------------------------------------------------------------

// MutateWorldObjectRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool MutateWorldObjectRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool MutateWorldObjectRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& MutateWorldObjectRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& MutateWorldObjectRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MutateWorldObjectRequest.header)
  return _internal_header();
}
inline void MutateWorldObjectRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.MutateWorldObjectRequest.header)
}
inline ::bosdyn::api::RequestHeader* MutateWorldObjectRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* MutateWorldObjectRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.MutateWorldObjectRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* MutateWorldObjectRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* MutateWorldObjectRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.MutateWorldObjectRequest.header)
  return _msg;
}
inline void MutateWorldObjectRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.MutateWorldObjectRequest.header)
}

// .bosdyn.api.MutateWorldObjectRequest.Mutation mutation = 2;
inline bool MutateWorldObjectRequest::_internal_has_mutation() const {
  return this != internal_default_instance() && _impl_.mutation_ != nullptr;
}
inline bool MutateWorldObjectRequest::has_mutation() const {
  return _internal_has_mutation();
}
inline void MutateWorldObjectRequest::clear_mutation() {
  if (GetArenaForAllocation() == nullptr && _impl_.mutation_ != nullptr) {
    delete _impl_.mutation_;
  }
  _impl_.mutation_ = nullptr;
}
inline const ::bosdyn::api::MutateWorldObjectRequest_Mutation& MutateWorldObjectRequest::_internal_mutation() const {
  const ::bosdyn::api::MutateWorldObjectRequest_Mutation* p = _impl_.mutation_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::MutateWorldObjectRequest_Mutation&>(
      ::bosdyn::api::_MutateWorldObjectRequest_Mutation_default_instance_);
}
inline const ::bosdyn::api::MutateWorldObjectRequest_Mutation& MutateWorldObjectRequest::mutation() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MutateWorldObjectRequest.mutation)
  return _internal_mutation();
}
inline void MutateWorldObjectRequest::unsafe_arena_set_allocated_mutation(
    ::bosdyn::api::MutateWorldObjectRequest_Mutation* mutation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mutation_);
  }
  _impl_.mutation_ = mutation;
  if (mutation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.MutateWorldObjectRequest.mutation)
}
inline ::bosdyn::api::MutateWorldObjectRequest_Mutation* MutateWorldObjectRequest::release_mutation() {
  
  ::bosdyn::api::MutateWorldObjectRequest_Mutation* temp = _impl_.mutation_;
  _impl_.mutation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::MutateWorldObjectRequest_Mutation* MutateWorldObjectRequest::unsafe_arena_release_mutation() {
  // @@protoc_insertion_point(field_release:bosdyn.api.MutateWorldObjectRequest.mutation)
  
  ::bosdyn::api::MutateWorldObjectRequest_Mutation* temp = _impl_.mutation_;
  _impl_.mutation_ = nullptr;
  return temp;
}
inline ::bosdyn::api::MutateWorldObjectRequest_Mutation* MutateWorldObjectRequest::_internal_mutable_mutation() {
  
  if (_impl_.mutation_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::MutateWorldObjectRequest_Mutation>(GetArenaForAllocation());
    _impl_.mutation_ = p;
  }
  return _impl_.mutation_;
}
inline ::bosdyn::api::MutateWorldObjectRequest_Mutation* MutateWorldObjectRequest::mutable_mutation() {
  ::bosdyn::api::MutateWorldObjectRequest_Mutation* _msg = _internal_mutable_mutation();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.MutateWorldObjectRequest.mutation)
  return _msg;
}
inline void MutateWorldObjectRequest::set_allocated_mutation(::bosdyn::api::MutateWorldObjectRequest_Mutation* mutation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mutation_;
  }
  if (mutation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mutation);
    if (message_arena != submessage_arena) {
      mutation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mutation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mutation_ = mutation;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.MutateWorldObjectRequest.mutation)
}

// -------------------------------------------------------------------

// MutateWorldObjectResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool MutateWorldObjectResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool MutateWorldObjectResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& MutateWorldObjectResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& MutateWorldObjectResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MutateWorldObjectResponse.header)
  return _internal_header();
}
inline void MutateWorldObjectResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.MutateWorldObjectResponse.header)
}
inline ::bosdyn::api::ResponseHeader* MutateWorldObjectResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* MutateWorldObjectResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.MutateWorldObjectResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* MutateWorldObjectResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* MutateWorldObjectResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.MutateWorldObjectResponse.header)
  return _msg;
}
inline void MutateWorldObjectResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.MutateWorldObjectResponse.header)
}

// .bosdyn.api.MutateWorldObjectResponse.Status status = 2;
inline void MutateWorldObjectResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::MutateWorldObjectResponse_Status MutateWorldObjectResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::MutateWorldObjectResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::MutateWorldObjectResponse_Status MutateWorldObjectResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MutateWorldObjectResponse.status)
  return _internal_status();
}
inline void MutateWorldObjectResponse::_internal_set_status(::bosdyn::api::MutateWorldObjectResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void MutateWorldObjectResponse::set_status(::bosdyn::api::MutateWorldObjectResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MutateWorldObjectResponse.status)
}

// int32 mutated_object_id = 4;
inline void MutateWorldObjectResponse::clear_mutated_object_id() {
  _impl_.mutated_object_id_ = 0;
}
inline int32_t MutateWorldObjectResponse::_internal_mutated_object_id() const {
  return _impl_.mutated_object_id_;
}
inline int32_t MutateWorldObjectResponse::mutated_object_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MutateWorldObjectResponse.mutated_object_id)
  return _internal_mutated_object_id();
}
inline void MutateWorldObjectResponse::_internal_set_mutated_object_id(int32_t value) {
  
  _impl_.mutated_object_id_ = value;
}
inline void MutateWorldObjectResponse::set_mutated_object_id(int32_t value) {
  _internal_set_mutated_object_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MutateWorldObjectResponse.mutated_object_id)
}

// -------------------------------------------------------------------

// ImageProperties

// string camera_source = 1;
inline void ImageProperties::clear_camera_source() {
  _impl_.camera_source_.ClearToEmpty();
}
inline const std::string& ImageProperties::camera_source() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageProperties.camera_source)
  return _internal_camera_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageProperties::set_camera_source(ArgT0&& arg0, ArgT... args) {
 
 _impl_.camera_source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageProperties.camera_source)
}
inline std::string* ImageProperties::mutable_camera_source() {
  std::string* _s = _internal_mutable_camera_source();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageProperties.camera_source)
  return _s;
}
inline const std::string& ImageProperties::_internal_camera_source() const {
  return _impl_.camera_source_.Get();
}
inline void ImageProperties::_internal_set_camera_source(const std::string& value) {
  
  _impl_.camera_source_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageProperties::_internal_mutable_camera_source() {
  
  return _impl_.camera_source_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageProperties::release_camera_source() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageProperties.camera_source)
  return _impl_.camera_source_.Release();
}
inline void ImageProperties::set_allocated_camera_source(std::string* camera_source) {
  if (camera_source != nullptr) {
    
  } else {
    
  }
  _impl_.camera_source_.SetAllocated(camera_source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.camera_source_.IsDefault()) {
    _impl_.camera_source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageProperties.camera_source)
}

// .bosdyn.api.Polygon coordinates = 2;
inline bool ImageProperties::_internal_has_coordinates() const {
  return image_data_case() == kCoordinates;
}
inline bool ImageProperties::has_coordinates() const {
  return _internal_has_coordinates();
}
inline void ImageProperties::set_has_coordinates() {
  _impl_._oneof_case_[0] = kCoordinates;
}
inline ::bosdyn::api::Polygon* ImageProperties::release_coordinates() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageProperties.coordinates)
  if (_internal_has_coordinates()) {
    clear_has_image_data();
    ::bosdyn::api::Polygon* temp = _impl_.image_data_.coordinates_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.image_data_.coordinates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::Polygon& ImageProperties::_internal_coordinates() const {
  return _internal_has_coordinates()
      ? *_impl_.image_data_.coordinates_
      : reinterpret_cast< ::bosdyn::api::Polygon&>(::bosdyn::api::_Polygon_default_instance_);
}
inline const ::bosdyn::api::Polygon& ImageProperties::coordinates() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageProperties.coordinates)
  return _internal_coordinates();
}
inline ::bosdyn::api::Polygon* ImageProperties::unsafe_arena_release_coordinates() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.ImageProperties.coordinates)
  if (_internal_has_coordinates()) {
    clear_has_image_data();
    ::bosdyn::api::Polygon* temp = _impl_.image_data_.coordinates_;
    _impl_.image_data_.coordinates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ImageProperties::unsafe_arena_set_allocated_coordinates(::bosdyn::api::Polygon* coordinates) {
  clear_image_data();
  if (coordinates) {
    set_has_coordinates();
    _impl_.image_data_.coordinates_ = coordinates;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageProperties.coordinates)
}
inline ::bosdyn::api::Polygon* ImageProperties::_internal_mutable_coordinates() {
  if (!_internal_has_coordinates()) {
    clear_image_data();
    set_has_coordinates();
    _impl_.image_data_.coordinates_ = CreateMaybeMessage< ::bosdyn::api::Polygon >(GetArenaForAllocation());
  }
  return _impl_.image_data_.coordinates_;
}
inline ::bosdyn::api::Polygon* ImageProperties::mutable_coordinates() {
  ::bosdyn::api::Polygon* _msg = _internal_mutable_coordinates();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageProperties.coordinates)
  return _msg;
}

// .bosdyn.api.KeypointSet keypoints = 4;
inline bool ImageProperties::_internal_has_keypoints() const {
  return image_data_case() == kKeypoints;
}
inline bool ImageProperties::has_keypoints() const {
  return _internal_has_keypoints();
}
inline void ImageProperties::set_has_keypoints() {
  _impl_._oneof_case_[0] = kKeypoints;
}
inline ::bosdyn::api::KeypointSet* ImageProperties::release_keypoints() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageProperties.keypoints)
  if (_internal_has_keypoints()) {
    clear_has_image_data();
    ::bosdyn::api::KeypointSet* temp = _impl_.image_data_.keypoints_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.image_data_.keypoints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::KeypointSet& ImageProperties::_internal_keypoints() const {
  return _internal_has_keypoints()
      ? *_impl_.image_data_.keypoints_
      : reinterpret_cast< ::bosdyn::api::KeypointSet&>(::bosdyn::api::_KeypointSet_default_instance_);
}
inline const ::bosdyn::api::KeypointSet& ImageProperties::keypoints() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageProperties.keypoints)
  return _internal_keypoints();
}
inline ::bosdyn::api::KeypointSet* ImageProperties::unsafe_arena_release_keypoints() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.ImageProperties.keypoints)
  if (_internal_has_keypoints()) {
    clear_has_image_data();
    ::bosdyn::api::KeypointSet* temp = _impl_.image_data_.keypoints_;
    _impl_.image_data_.keypoints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ImageProperties::unsafe_arena_set_allocated_keypoints(::bosdyn::api::KeypointSet* keypoints) {
  clear_image_data();
  if (keypoints) {
    set_has_keypoints();
    _impl_.image_data_.keypoints_ = keypoints;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageProperties.keypoints)
}
inline ::bosdyn::api::KeypointSet* ImageProperties::_internal_mutable_keypoints() {
  if (!_internal_has_keypoints()) {
    clear_image_data();
    set_has_keypoints();
    _impl_.image_data_.keypoints_ = CreateMaybeMessage< ::bosdyn::api::KeypointSet >(GetArenaForAllocation());
  }
  return _impl_.image_data_.keypoints_;
}
inline ::bosdyn::api::KeypointSet* ImageProperties::mutable_keypoints() {
  ::bosdyn::api::KeypointSet* _msg = _internal_mutable_keypoints();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageProperties.keypoints)
  return _msg;
}

// .bosdyn.api.ImageSource image_source = 5;
inline bool ImageProperties::_internal_has_image_source() const {
  return this != internal_default_instance() && _impl_.image_source_ != nullptr;
}
inline bool ImageProperties::has_image_source() const {
  return _internal_has_image_source();
}
inline const ::bosdyn::api::ImageSource& ImageProperties::_internal_image_source() const {
  const ::bosdyn::api::ImageSource* p = _impl_.image_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ImageSource&>(
      ::bosdyn::api::_ImageSource_default_instance_);
}
inline const ::bosdyn::api::ImageSource& ImageProperties::image_source() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageProperties.image_source)
  return _internal_image_source();
}
inline void ImageProperties::unsafe_arena_set_allocated_image_source(
    ::bosdyn::api::ImageSource* image_source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_source_);
  }
  _impl_.image_source_ = image_source;
  if (image_source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageProperties.image_source)
}
inline ::bosdyn::api::ImageSource* ImageProperties::release_image_source() {
  
  ::bosdyn::api::ImageSource* temp = _impl_.image_source_;
  _impl_.image_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ImageSource* ImageProperties::unsafe_arena_release_image_source() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageProperties.image_source)
  
  ::bosdyn::api::ImageSource* temp = _impl_.image_source_;
  _impl_.image_source_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ImageSource* ImageProperties::_internal_mutable_image_source() {
  
  if (_impl_.image_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ImageSource>(GetArenaForAllocation());
    _impl_.image_source_ = p;
  }
  return _impl_.image_source_;
}
inline ::bosdyn::api::ImageSource* ImageProperties::mutable_image_source() {
  ::bosdyn::api::ImageSource* _msg = _internal_mutable_image_source();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageProperties.image_source)
  return _msg;
}
inline void ImageProperties::set_allocated_image_source(::bosdyn::api::ImageSource* image_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_source_);
  }
  if (image_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_source));
    if (message_arena != submessage_arena) {
      image_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_source_ = image_source;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageProperties.image_source)
}

// .bosdyn.api.ImageCapture image_capture = 6;
inline bool ImageProperties::_internal_has_image_capture() const {
  return this != internal_default_instance() && _impl_.image_capture_ != nullptr;
}
inline bool ImageProperties::has_image_capture() const {
  return _internal_has_image_capture();
}
inline const ::bosdyn::api::ImageCapture& ImageProperties::_internal_image_capture() const {
  const ::bosdyn::api::ImageCapture* p = _impl_.image_capture_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ImageCapture&>(
      ::bosdyn::api::_ImageCapture_default_instance_);
}
inline const ::bosdyn::api::ImageCapture& ImageProperties::image_capture() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageProperties.image_capture)
  return _internal_image_capture();
}
inline void ImageProperties::unsafe_arena_set_allocated_image_capture(
    ::bosdyn::api::ImageCapture* image_capture) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_capture_);
  }
  _impl_.image_capture_ = image_capture;
  if (image_capture) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageProperties.image_capture)
}
inline ::bosdyn::api::ImageCapture* ImageProperties::release_image_capture() {
  
  ::bosdyn::api::ImageCapture* temp = _impl_.image_capture_;
  _impl_.image_capture_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ImageCapture* ImageProperties::unsafe_arena_release_image_capture() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageProperties.image_capture)
  
  ::bosdyn::api::ImageCapture* temp = _impl_.image_capture_;
  _impl_.image_capture_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ImageCapture* ImageProperties::_internal_mutable_image_capture() {
  
  if (_impl_.image_capture_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ImageCapture>(GetArenaForAllocation());
    _impl_.image_capture_ = p;
  }
  return _impl_.image_capture_;
}
inline ::bosdyn::api::ImageCapture* ImageProperties::mutable_image_capture() {
  ::bosdyn::api::ImageCapture* _msg = _internal_mutable_image_capture();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageProperties.image_capture)
  return _msg;
}
inline void ImageProperties::set_allocated_image_capture(::bosdyn::api::ImageCapture* image_capture) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_capture_);
  }
  if (image_capture) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_capture));
    if (message_arena != submessage_arena) {
      image_capture = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_capture, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_capture_ = image_capture;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageProperties.image_capture)
}

// string frame_name_image_coordinates = 3;
inline void ImageProperties::clear_frame_name_image_coordinates() {
  _impl_.frame_name_image_coordinates_.ClearToEmpty();
}
inline const std::string& ImageProperties::frame_name_image_coordinates() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageProperties.frame_name_image_coordinates)
  return _internal_frame_name_image_coordinates();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageProperties::set_frame_name_image_coordinates(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_image_coordinates_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageProperties.frame_name_image_coordinates)
}
inline std::string* ImageProperties::mutable_frame_name_image_coordinates() {
  std::string* _s = _internal_mutable_frame_name_image_coordinates();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageProperties.frame_name_image_coordinates)
  return _s;
}
inline const std::string& ImageProperties::_internal_frame_name_image_coordinates() const {
  return _impl_.frame_name_image_coordinates_.Get();
}
inline void ImageProperties::_internal_set_frame_name_image_coordinates(const std::string& value) {
  
  _impl_.frame_name_image_coordinates_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageProperties::_internal_mutable_frame_name_image_coordinates() {
  
  return _impl_.frame_name_image_coordinates_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageProperties::release_frame_name_image_coordinates() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageProperties.frame_name_image_coordinates)
  return _impl_.frame_name_image_coordinates_.Release();
}
inline void ImageProperties::set_allocated_frame_name_image_coordinates(std::string* frame_name_image_coordinates) {
  if (frame_name_image_coordinates != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_image_coordinates_.SetAllocated(frame_name_image_coordinates, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_image_coordinates_.IsDefault()) {
    _impl_.frame_name_image_coordinates_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageProperties.frame_name_image_coordinates)
}

inline bool ImageProperties::has_image_data() const {
  return image_data_case() != IMAGE_DATA_NOT_SET;
}
inline void ImageProperties::clear_has_image_data() {
  _impl_._oneof_case_[0] = IMAGE_DATA_NOT_SET;
}
inline ImageProperties::ImageDataCase ImageProperties::image_data_case() const {
  return ImageProperties::ImageDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DockProperties

// uint32 dock_id = 1;
inline void DockProperties::clear_dock_id() {
  _impl_.dock_id_ = 0u;
}
inline uint32_t DockProperties::_internal_dock_id() const {
  return _impl_.dock_id_;
}
inline uint32_t DockProperties::dock_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DockProperties.dock_id)
  return _internal_dock_id();
}
inline void DockProperties::_internal_set_dock_id(uint32_t value) {
  
  _impl_.dock_id_ = value;
}
inline void DockProperties::set_dock_id(uint32_t value) {
  _internal_set_dock_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DockProperties.dock_id)
}

// .bosdyn.api.docking.DockType type = 2;
inline void DockProperties::clear_type() {
  _impl_.type_ = 0;
}
inline ::bosdyn::api::docking::DockType DockProperties::_internal_type() const {
  return static_cast< ::bosdyn::api::docking::DockType >(_impl_.type_);
}
inline ::bosdyn::api::docking::DockType DockProperties::type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DockProperties.type)
  return _internal_type();
}
inline void DockProperties::_internal_set_type(::bosdyn::api::docking::DockType value) {
  
  _impl_.type_ = value;
}
inline void DockProperties::set_type(::bosdyn::api::docking::DockType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DockProperties.type)
}

// string frame_name_dock = 3;
inline void DockProperties::clear_frame_name_dock() {
  _impl_.frame_name_dock_.ClearToEmpty();
}
inline const std::string& DockProperties::frame_name_dock() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DockProperties.frame_name_dock)
  return _internal_frame_name_dock();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DockProperties::set_frame_name_dock(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_dock_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.DockProperties.frame_name_dock)
}
inline std::string* DockProperties::mutable_frame_name_dock() {
  std::string* _s = _internal_mutable_frame_name_dock();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DockProperties.frame_name_dock)
  return _s;
}
inline const std::string& DockProperties::_internal_frame_name_dock() const {
  return _impl_.frame_name_dock_.Get();
}
inline void DockProperties::_internal_set_frame_name_dock(const std::string& value) {
  
  _impl_.frame_name_dock_.Set(value, GetArenaForAllocation());
}
inline std::string* DockProperties::_internal_mutable_frame_name_dock() {
  
  return _impl_.frame_name_dock_.Mutable(GetArenaForAllocation());
}
inline std::string* DockProperties::release_frame_name_dock() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DockProperties.frame_name_dock)
  return _impl_.frame_name_dock_.Release();
}
inline void DockProperties::set_allocated_frame_name_dock(std::string* frame_name_dock) {
  if (frame_name_dock != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_dock_.SetAllocated(frame_name_dock, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_dock_.IsDefault()) {
    _impl_.frame_name_dock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DockProperties.frame_name_dock)
}

// bool unavailable = 4;
inline void DockProperties::clear_unavailable() {
  _impl_.unavailable_ = false;
}
inline bool DockProperties::_internal_unavailable() const {
  return _impl_.unavailable_;
}
inline bool DockProperties::unavailable() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DockProperties.unavailable)
  return _internal_unavailable();
}
inline void DockProperties::_internal_set_unavailable(bool value) {
  
  _impl_.unavailable_ = value;
}
inline void DockProperties::set_unavailable(bool value) {
  _internal_set_unavailable(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DockProperties.unavailable)
}

// bool from_prior = 5;
inline void DockProperties::clear_from_prior() {
  _impl_.from_prior_ = false;
}
inline bool DockProperties::_internal_from_prior() const {
  return _impl_.from_prior_;
}
inline bool DockProperties::from_prior() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DockProperties.from_prior)
  return _internal_from_prior();
}
inline void DockProperties::_internal_set_from_prior(bool value) {
  
  _impl_.from_prior_ = value;
}
inline void DockProperties::set_from_prior(bool value) {
  _internal_set_from_prior(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DockProperties.from_prior)
}

// -------------------------------------------------------------------

// AprilTagProperties

// int32 tag_id = 1;
inline void AprilTagProperties::clear_tag_id() {
  _impl_.tag_id_ = 0;
}
inline int32_t AprilTagProperties::_internal_tag_id() const {
  return _impl_.tag_id_;
}
inline int32_t AprilTagProperties::tag_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AprilTagProperties.tag_id)
  return _internal_tag_id();
}
inline void AprilTagProperties::_internal_set_tag_id(int32_t value) {
  
  _impl_.tag_id_ = value;
}
inline void AprilTagProperties::set_tag_id(int32_t value) {
  _internal_set_tag_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.AprilTagProperties.tag_id)
}

// .bosdyn.api.Vec2 dimensions = 2;
inline bool AprilTagProperties::_internal_has_dimensions() const {
  return this != internal_default_instance() && _impl_.dimensions_ != nullptr;
}
inline bool AprilTagProperties::has_dimensions() const {
  return _internal_has_dimensions();
}
inline const ::bosdyn::api::Vec2& AprilTagProperties::_internal_dimensions() const {
  const ::bosdyn::api::Vec2* p = _impl_.dimensions_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec2&>(
      ::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& AprilTagProperties::dimensions() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AprilTagProperties.dimensions)
  return _internal_dimensions();
}
inline void AprilTagProperties::unsafe_arena_set_allocated_dimensions(
    ::bosdyn::api::Vec2* dimensions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dimensions_);
  }
  _impl_.dimensions_ = dimensions;
  if (dimensions) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AprilTagProperties.dimensions)
}
inline ::bosdyn::api::Vec2* AprilTagProperties::release_dimensions() {
  
  ::bosdyn::api::Vec2* temp = _impl_.dimensions_;
  _impl_.dimensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec2* AprilTagProperties::unsafe_arena_release_dimensions() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AprilTagProperties.dimensions)
  
  ::bosdyn::api::Vec2* temp = _impl_.dimensions_;
  _impl_.dimensions_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* AprilTagProperties::_internal_mutable_dimensions() {
  
  if (_impl_.dimensions_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArenaForAllocation());
    _impl_.dimensions_ = p;
  }
  return _impl_.dimensions_;
}
inline ::bosdyn::api::Vec2* AprilTagProperties::mutable_dimensions() {
  ::bosdyn::api::Vec2* _msg = _internal_mutable_dimensions();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AprilTagProperties.dimensions)
  return _msg;
}
inline void AprilTagProperties::set_allocated_dimensions(::bosdyn::api::Vec2* dimensions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dimensions_);
  }
  if (dimensions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dimensions));
    if (message_arena != submessage_arena) {
      dimensions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dimensions, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.dimensions_ = dimensions;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AprilTagProperties.dimensions)
}

// string frame_name_fiducial = 3;
inline void AprilTagProperties::clear_frame_name_fiducial() {
  _impl_.frame_name_fiducial_.ClearToEmpty();
}
inline const std::string& AprilTagProperties::frame_name_fiducial() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AprilTagProperties.frame_name_fiducial)
  return _internal_frame_name_fiducial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AprilTagProperties::set_frame_name_fiducial(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_fiducial_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.AprilTagProperties.frame_name_fiducial)
}
inline std::string* AprilTagProperties::mutable_frame_name_fiducial() {
  std::string* _s = _internal_mutable_frame_name_fiducial();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AprilTagProperties.frame_name_fiducial)
  return _s;
}
inline const std::string& AprilTagProperties::_internal_frame_name_fiducial() const {
  return _impl_.frame_name_fiducial_.Get();
}
inline void AprilTagProperties::_internal_set_frame_name_fiducial(const std::string& value) {
  
  _impl_.frame_name_fiducial_.Set(value, GetArenaForAllocation());
}
inline std::string* AprilTagProperties::_internal_mutable_frame_name_fiducial() {
  
  return _impl_.frame_name_fiducial_.Mutable(GetArenaForAllocation());
}
inline std::string* AprilTagProperties::release_frame_name_fiducial() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AprilTagProperties.frame_name_fiducial)
  return _impl_.frame_name_fiducial_.Release();
}
inline void AprilTagProperties::set_allocated_frame_name_fiducial(std::string* frame_name_fiducial) {
  if (frame_name_fiducial != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_fiducial_.SetAllocated(frame_name_fiducial, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_fiducial_.IsDefault()) {
    _impl_.frame_name_fiducial_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AprilTagProperties.frame_name_fiducial)
}

// .bosdyn.api.AprilTagProperties.AprilTagPoseStatus fiducial_pose_status = 8;
inline void AprilTagProperties::clear_fiducial_pose_status() {
  _impl_.fiducial_pose_status_ = 0;
}
inline ::bosdyn::api::AprilTagProperties_AprilTagPoseStatus AprilTagProperties::_internal_fiducial_pose_status() const {
  return static_cast< ::bosdyn::api::AprilTagProperties_AprilTagPoseStatus >(_impl_.fiducial_pose_status_);
}
inline ::bosdyn::api::AprilTagProperties_AprilTagPoseStatus AprilTagProperties::fiducial_pose_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AprilTagProperties.fiducial_pose_status)
  return _internal_fiducial_pose_status();
}
inline void AprilTagProperties::_internal_set_fiducial_pose_status(::bosdyn::api::AprilTagProperties_AprilTagPoseStatus value) {
  
  _impl_.fiducial_pose_status_ = value;
}
inline void AprilTagProperties::set_fiducial_pose_status(::bosdyn::api::AprilTagProperties_AprilTagPoseStatus value) {
  _internal_set_fiducial_pose_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.AprilTagProperties.fiducial_pose_status)
}

// string frame_name_fiducial_filtered = 4;
inline void AprilTagProperties::clear_frame_name_fiducial_filtered() {
  _impl_.frame_name_fiducial_filtered_.ClearToEmpty();
}
inline const std::string& AprilTagProperties::frame_name_fiducial_filtered() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AprilTagProperties.frame_name_fiducial_filtered)
  return _internal_frame_name_fiducial_filtered();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AprilTagProperties::set_frame_name_fiducial_filtered(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_fiducial_filtered_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.AprilTagProperties.frame_name_fiducial_filtered)
}
inline std::string* AprilTagProperties::mutable_frame_name_fiducial_filtered() {
  std::string* _s = _internal_mutable_frame_name_fiducial_filtered();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AprilTagProperties.frame_name_fiducial_filtered)
  return _s;
}
inline const std::string& AprilTagProperties::_internal_frame_name_fiducial_filtered() const {
  return _impl_.frame_name_fiducial_filtered_.Get();
}
inline void AprilTagProperties::_internal_set_frame_name_fiducial_filtered(const std::string& value) {
  
  _impl_.frame_name_fiducial_filtered_.Set(value, GetArenaForAllocation());
}
inline std::string* AprilTagProperties::_internal_mutable_frame_name_fiducial_filtered() {
  
  return _impl_.frame_name_fiducial_filtered_.Mutable(GetArenaForAllocation());
}
inline std::string* AprilTagProperties::release_frame_name_fiducial_filtered() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AprilTagProperties.frame_name_fiducial_filtered)
  return _impl_.frame_name_fiducial_filtered_.Release();
}
inline void AprilTagProperties::set_allocated_frame_name_fiducial_filtered(std::string* frame_name_fiducial_filtered) {
  if (frame_name_fiducial_filtered != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_fiducial_filtered_.SetAllocated(frame_name_fiducial_filtered, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_fiducial_filtered_.IsDefault()) {
    _impl_.frame_name_fiducial_filtered_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AprilTagProperties.frame_name_fiducial_filtered)
}

// .bosdyn.api.AprilTagProperties.AprilTagPoseStatus fiducial_filtered_pose_status = 9;
inline void AprilTagProperties::clear_fiducial_filtered_pose_status() {
  _impl_.fiducial_filtered_pose_status_ = 0;
}
inline ::bosdyn::api::AprilTagProperties_AprilTagPoseStatus AprilTagProperties::_internal_fiducial_filtered_pose_status() const {
  return static_cast< ::bosdyn::api::AprilTagProperties_AprilTagPoseStatus >(_impl_.fiducial_filtered_pose_status_);
}
inline ::bosdyn::api::AprilTagProperties_AprilTagPoseStatus AprilTagProperties::fiducial_filtered_pose_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AprilTagProperties.fiducial_filtered_pose_status)
  return _internal_fiducial_filtered_pose_status();
}
inline void AprilTagProperties::_internal_set_fiducial_filtered_pose_status(::bosdyn::api::AprilTagProperties_AprilTagPoseStatus value) {
  
  _impl_.fiducial_filtered_pose_status_ = value;
}
inline void AprilTagProperties::set_fiducial_filtered_pose_status(::bosdyn::api::AprilTagProperties_AprilTagPoseStatus value) {
  _internal_set_fiducial_filtered_pose_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.AprilTagProperties.fiducial_filtered_pose_status)
}

// string frame_name_camera = 7;
inline void AprilTagProperties::clear_frame_name_camera() {
  _impl_.frame_name_camera_.ClearToEmpty();
}
inline const std::string& AprilTagProperties::frame_name_camera() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AprilTagProperties.frame_name_camera)
  return _internal_frame_name_camera();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AprilTagProperties::set_frame_name_camera(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_camera_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.AprilTagProperties.frame_name_camera)
}
inline std::string* AprilTagProperties::mutable_frame_name_camera() {
  std::string* _s = _internal_mutable_frame_name_camera();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AprilTagProperties.frame_name_camera)
  return _s;
}
inline const std::string& AprilTagProperties::_internal_frame_name_camera() const {
  return _impl_.frame_name_camera_.Get();
}
inline void AprilTagProperties::_internal_set_frame_name_camera(const std::string& value) {
  
  _impl_.frame_name_camera_.Set(value, GetArenaForAllocation());
}
inline std::string* AprilTagProperties::_internal_mutable_frame_name_camera() {
  
  return _impl_.frame_name_camera_.Mutable(GetArenaForAllocation());
}
inline std::string* AprilTagProperties::release_frame_name_camera() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AprilTagProperties.frame_name_camera)
  return _impl_.frame_name_camera_.Release();
}
inline void AprilTagProperties::set_allocated_frame_name_camera(std::string* frame_name_camera) {
  if (frame_name_camera != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_camera_.SetAllocated(frame_name_camera, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_camera_.IsDefault()) {
    _impl_.frame_name_camera_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AprilTagProperties.frame_name_camera)
}

// .bosdyn.api.SE3Covariance detection_covariance = 5;
inline bool AprilTagProperties::_internal_has_detection_covariance() const {
  return this != internal_default_instance() && _impl_.detection_covariance_ != nullptr;
}
inline bool AprilTagProperties::has_detection_covariance() const {
  return _internal_has_detection_covariance();
}
inline const ::bosdyn::api::SE3Covariance& AprilTagProperties::_internal_detection_covariance() const {
  const ::bosdyn::api::SE3Covariance* p = _impl_.detection_covariance_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Covariance&>(
      ::bosdyn::api::_SE3Covariance_default_instance_);
}
inline const ::bosdyn::api::SE3Covariance& AprilTagProperties::detection_covariance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AprilTagProperties.detection_covariance)
  return _internal_detection_covariance();
}
inline void AprilTagProperties::unsafe_arena_set_allocated_detection_covariance(
    ::bosdyn::api::SE3Covariance* detection_covariance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.detection_covariance_);
  }
  _impl_.detection_covariance_ = detection_covariance;
  if (detection_covariance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AprilTagProperties.detection_covariance)
}
inline ::bosdyn::api::SE3Covariance* AprilTagProperties::release_detection_covariance() {
  
  ::bosdyn::api::SE3Covariance* temp = _impl_.detection_covariance_;
  _impl_.detection_covariance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Covariance* AprilTagProperties::unsafe_arena_release_detection_covariance() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AprilTagProperties.detection_covariance)
  
  ::bosdyn::api::SE3Covariance* temp = _impl_.detection_covariance_;
  _impl_.detection_covariance_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Covariance* AprilTagProperties::_internal_mutable_detection_covariance() {
  
  if (_impl_.detection_covariance_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Covariance>(GetArenaForAllocation());
    _impl_.detection_covariance_ = p;
  }
  return _impl_.detection_covariance_;
}
inline ::bosdyn::api::SE3Covariance* AprilTagProperties::mutable_detection_covariance() {
  ::bosdyn::api::SE3Covariance* _msg = _internal_mutable_detection_covariance();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AprilTagProperties.detection_covariance)
  return _msg;
}
inline void AprilTagProperties::set_allocated_detection_covariance(::bosdyn::api::SE3Covariance* detection_covariance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.detection_covariance_);
  }
  if (detection_covariance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(detection_covariance));
    if (message_arena != submessage_arena) {
      detection_covariance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, detection_covariance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.detection_covariance_ = detection_covariance;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AprilTagProperties.detection_covariance)
}

// string detection_covariance_reference_frame = 6;
inline void AprilTagProperties::clear_detection_covariance_reference_frame() {
  _impl_.detection_covariance_reference_frame_.ClearToEmpty();
}
inline const std::string& AprilTagProperties::detection_covariance_reference_frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AprilTagProperties.detection_covariance_reference_frame)
  return _internal_detection_covariance_reference_frame();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AprilTagProperties::set_detection_covariance_reference_frame(ArgT0&& arg0, ArgT... args) {
 
 _impl_.detection_covariance_reference_frame_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.AprilTagProperties.detection_covariance_reference_frame)
}
inline std::string* AprilTagProperties::mutable_detection_covariance_reference_frame() {
  std::string* _s = _internal_mutable_detection_covariance_reference_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AprilTagProperties.detection_covariance_reference_frame)
  return _s;
}
inline const std::string& AprilTagProperties::_internal_detection_covariance_reference_frame() const {
  return _impl_.detection_covariance_reference_frame_.Get();
}
inline void AprilTagProperties::_internal_set_detection_covariance_reference_frame(const std::string& value) {
  
  _impl_.detection_covariance_reference_frame_.Set(value, GetArenaForAllocation());
}
inline std::string* AprilTagProperties::_internal_mutable_detection_covariance_reference_frame() {
  
  return _impl_.detection_covariance_reference_frame_.Mutable(GetArenaForAllocation());
}
inline std::string* AprilTagProperties::release_detection_covariance_reference_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AprilTagProperties.detection_covariance_reference_frame)
  return _impl_.detection_covariance_reference_frame_.Release();
}
inline void AprilTagProperties::set_allocated_detection_covariance_reference_frame(std::string* detection_covariance_reference_frame) {
  if (detection_covariance_reference_frame != nullptr) {
    
  } else {
    
  }
  _impl_.detection_covariance_reference_frame_.SetAllocated(detection_covariance_reference_frame, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detection_covariance_reference_frame_.IsDefault()) {
    _impl_.detection_covariance_reference_frame_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AprilTagProperties.detection_covariance_reference_frame)
}

// -------------------------------------------------------------------

// RayProperties

// .bosdyn.api.Ray ray = 1;
inline bool RayProperties::_internal_has_ray() const {
  return this != internal_default_instance() && _impl_.ray_ != nullptr;
}
inline bool RayProperties::has_ray() const {
  return _internal_has_ray();
}
inline const ::bosdyn::api::Ray& RayProperties::_internal_ray() const {
  const ::bosdyn::api::Ray* p = _impl_.ray_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Ray&>(
      ::bosdyn::api::_Ray_default_instance_);
}
inline const ::bosdyn::api::Ray& RayProperties::ray() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RayProperties.ray)
  return _internal_ray();
}
inline void RayProperties::unsafe_arena_set_allocated_ray(
    ::bosdyn::api::Ray* ray) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ray_);
  }
  _impl_.ray_ = ray;
  if (ray) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RayProperties.ray)
}
inline ::bosdyn::api::Ray* RayProperties::release_ray() {
  
  ::bosdyn::api::Ray* temp = _impl_.ray_;
  _impl_.ray_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Ray* RayProperties::unsafe_arena_release_ray() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RayProperties.ray)
  
  ::bosdyn::api::Ray* temp = _impl_.ray_;
  _impl_.ray_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Ray* RayProperties::_internal_mutable_ray() {
  
  if (_impl_.ray_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Ray>(GetArenaForAllocation());
    _impl_.ray_ = p;
  }
  return _impl_.ray_;
}
inline ::bosdyn::api::Ray* RayProperties::mutable_ray() {
  ::bosdyn::api::Ray* _msg = _internal_mutable_ray();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RayProperties.ray)
  return _msg;
}
inline void RayProperties::set_allocated_ray(::bosdyn::api::Ray* ray) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ray_);
  }
  if (ray) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ray));
    if (message_arena != submessage_arena) {
      ray = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ray, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ray_ = ray;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RayProperties.ray)
}

// string frame = 2;
inline void RayProperties::clear_frame() {
  _impl_.frame_.ClearToEmpty();
}
inline const std::string& RayProperties::frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RayProperties.frame)
  return _internal_frame();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RayProperties::set_frame(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.RayProperties.frame)
}
inline std::string* RayProperties::mutable_frame() {
  std::string* _s = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RayProperties.frame)
  return _s;
}
inline const std::string& RayProperties::_internal_frame() const {
  return _impl_.frame_.Get();
}
inline void RayProperties::_internal_set_frame(const std::string& value) {
  
  _impl_.frame_.Set(value, GetArenaForAllocation());
}
inline std::string* RayProperties::_internal_mutable_frame() {
  
  return _impl_.frame_.Mutable(GetArenaForAllocation());
}
inline std::string* RayProperties::release_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RayProperties.frame)
  return _impl_.frame_.Release();
}
inline void RayProperties::set_allocated_frame(std::string* frame) {
  if (frame != nullptr) {
    
  } else {
    
  }
  _impl_.frame_.SetAllocated(frame, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_.IsDefault()) {
    _impl_.frame_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RayProperties.frame)
}

// -------------------------------------------------------------------

// BoundingBoxProperties

// .bosdyn.api.Vec3 size_ewrt_frame = 1;
inline bool BoundingBoxProperties::_internal_has_size_ewrt_frame() const {
  return this != internal_default_instance() && _impl_.size_ewrt_frame_ != nullptr;
}
inline bool BoundingBoxProperties::has_size_ewrt_frame() const {
  return _internal_has_size_ewrt_frame();
}
inline const ::bosdyn::api::Vec3& BoundingBoxProperties::_internal_size_ewrt_frame() const {
  const ::bosdyn::api::Vec3* p = _impl_.size_ewrt_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& BoundingBoxProperties::size_ewrt_frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BoundingBoxProperties.size_ewrt_frame)
  return _internal_size_ewrt_frame();
}
inline void BoundingBoxProperties::unsafe_arena_set_allocated_size_ewrt_frame(
    ::bosdyn::api::Vec3* size_ewrt_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.size_ewrt_frame_);
  }
  _impl_.size_ewrt_frame_ = size_ewrt_frame;
  if (size_ewrt_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.BoundingBoxProperties.size_ewrt_frame)
}
inline ::bosdyn::api::Vec3* BoundingBoxProperties::release_size_ewrt_frame() {
  
  ::bosdyn::api::Vec3* temp = _impl_.size_ewrt_frame_;
  _impl_.size_ewrt_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* BoundingBoxProperties::unsafe_arena_release_size_ewrt_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BoundingBoxProperties.size_ewrt_frame)
  
  ::bosdyn::api::Vec3* temp = _impl_.size_ewrt_frame_;
  _impl_.size_ewrt_frame_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* BoundingBoxProperties::_internal_mutable_size_ewrt_frame() {
  
  if (_impl_.size_ewrt_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.size_ewrt_frame_ = p;
  }
  return _impl_.size_ewrt_frame_;
}
inline ::bosdyn::api::Vec3* BoundingBoxProperties::mutable_size_ewrt_frame() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_size_ewrt_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BoundingBoxProperties.size_ewrt_frame)
  return _msg;
}
inline void BoundingBoxProperties::set_allocated_size_ewrt_frame(::bosdyn::api::Vec3* size_ewrt_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.size_ewrt_frame_);
  }
  if (size_ewrt_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_ewrt_frame));
    if (message_arena != submessage_arena) {
      size_ewrt_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size_ewrt_frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.size_ewrt_frame_ = size_ewrt_frame;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BoundingBoxProperties.size_ewrt_frame)
}

// string frame = 2;
inline void BoundingBoxProperties::clear_frame() {
  _impl_.frame_.ClearToEmpty();
}
inline const std::string& BoundingBoxProperties::frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BoundingBoxProperties.frame)
  return _internal_frame();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BoundingBoxProperties::set_frame(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.BoundingBoxProperties.frame)
}
inline std::string* BoundingBoxProperties::mutable_frame() {
  std::string* _s = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BoundingBoxProperties.frame)
  return _s;
}
inline const std::string& BoundingBoxProperties::_internal_frame() const {
  return _impl_.frame_.Get();
}
inline void BoundingBoxProperties::_internal_set_frame(const std::string& value) {
  
  _impl_.frame_.Set(value, GetArenaForAllocation());
}
inline std::string* BoundingBoxProperties::_internal_mutable_frame() {
  
  return _impl_.frame_.Mutable(GetArenaForAllocation());
}
inline std::string* BoundingBoxProperties::release_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BoundingBoxProperties.frame)
  return _impl_.frame_.Release();
}
inline void BoundingBoxProperties::set_allocated_frame(std::string* frame) {
  if (frame != nullptr) {
    
  } else {
    
  }
  _impl_.frame_.SetAllocated(frame, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_.IsDefault()) {
    _impl_.frame_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BoundingBoxProperties.frame)
}

// -------------------------------------------------------------------

// DrawableProperties_Color

// int32 r = 1;
inline void DrawableProperties_Color::clear_r() {
  _impl_.r_ = 0;
}
inline int32_t DrawableProperties_Color::_internal_r() const {
  return _impl_.r_;
}
inline int32_t DrawableProperties_Color::r() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableProperties.Color.r)
  return _internal_r();
}
inline void DrawableProperties_Color::_internal_set_r(int32_t value) {
  
  _impl_.r_ = value;
}
inline void DrawableProperties_Color::set_r(int32_t value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DrawableProperties.Color.r)
}

// int32 g = 2;
inline void DrawableProperties_Color::clear_g() {
  _impl_.g_ = 0;
}
inline int32_t DrawableProperties_Color::_internal_g() const {
  return _impl_.g_;
}
inline int32_t DrawableProperties_Color::g() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableProperties.Color.g)
  return _internal_g();
}
inline void DrawableProperties_Color::_internal_set_g(int32_t value) {
  
  _impl_.g_ = value;
}
inline void DrawableProperties_Color::set_g(int32_t value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DrawableProperties.Color.g)
}

// int32 b = 3;
inline void DrawableProperties_Color::clear_b() {
  _impl_.b_ = 0;
}
inline int32_t DrawableProperties_Color::_internal_b() const {
  return _impl_.b_;
}
inline int32_t DrawableProperties_Color::b() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableProperties.Color.b)
  return _internal_b();
}
inline void DrawableProperties_Color::_internal_set_b(int32_t value) {
  
  _impl_.b_ = value;
}
inline void DrawableProperties_Color::set_b(int32_t value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DrawableProperties.Color.b)
}

// double a = 4;
inline void DrawableProperties_Color::clear_a() {
  _impl_.a_ = 0;
}
inline double DrawableProperties_Color::_internal_a() const {
  return _impl_.a_;
}
inline double DrawableProperties_Color::a() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableProperties.Color.a)
  return _internal_a();
}
inline void DrawableProperties_Color::_internal_set_a(double value) {
  
  _impl_.a_ = value;
}
inline void DrawableProperties_Color::set_a(double value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DrawableProperties.Color.a)
}

// -------------------------------------------------------------------

// DrawableProperties

// .bosdyn.api.DrawableProperties.Color color = 1;
inline bool DrawableProperties::_internal_has_color() const {
  return this != internal_default_instance() && _impl_.color_ != nullptr;
}
inline bool DrawableProperties::has_color() const {
  return _internal_has_color();
}
inline void DrawableProperties::clear_color() {
  if (GetArenaForAllocation() == nullptr && _impl_.color_ != nullptr) {
    delete _impl_.color_;
  }
  _impl_.color_ = nullptr;
}
inline const ::bosdyn::api::DrawableProperties_Color& DrawableProperties::_internal_color() const {
  const ::bosdyn::api::DrawableProperties_Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DrawableProperties_Color&>(
      ::bosdyn::api::_DrawableProperties_Color_default_instance_);
}
inline const ::bosdyn::api::DrawableProperties_Color& DrawableProperties::color() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableProperties.color)
  return _internal_color();
}
inline void DrawableProperties::unsafe_arena_set_allocated_color(
    ::bosdyn::api::DrawableProperties_Color* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DrawableProperties.color)
}
inline ::bosdyn::api::DrawableProperties_Color* DrawableProperties::release_color() {
  
  ::bosdyn::api::DrawableProperties_Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DrawableProperties_Color* DrawableProperties::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DrawableProperties.color)
  
  ::bosdyn::api::DrawableProperties_Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DrawableProperties_Color* DrawableProperties::_internal_mutable_color() {
  
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DrawableProperties_Color>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::bosdyn::api::DrawableProperties_Color* DrawableProperties::mutable_color() {
  ::bosdyn::api::DrawableProperties_Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawableProperties.color)
  return _msg;
}
inline void DrawableProperties::set_allocated_color(::bosdyn::api::DrawableProperties_Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DrawableProperties.color)
}

// string label = 2;
inline void DrawableProperties::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& DrawableProperties::label() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableProperties.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DrawableProperties::set_label(ArgT0&& arg0, ArgT... args) {
 
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.DrawableProperties.label)
}
inline std::string* DrawableProperties::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawableProperties.label)
  return _s;
}
inline const std::string& DrawableProperties::_internal_label() const {
  return _impl_.label_.Get();
}
inline void DrawableProperties::_internal_set_label(const std::string& value) {
  
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* DrawableProperties::_internal_mutable_label() {
  
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* DrawableProperties::release_label() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DrawableProperties.label)
  return _impl_.label_.Release();
}
inline void DrawableProperties::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DrawableProperties.label)
}

// bool wireframe = 3;
inline void DrawableProperties::clear_wireframe() {
  _impl_.wireframe_ = false;
}
inline bool DrawableProperties::_internal_wireframe() const {
  return _impl_.wireframe_;
}
inline bool DrawableProperties::wireframe() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableProperties.wireframe)
  return _internal_wireframe();
}
inline void DrawableProperties::_internal_set_wireframe(bool value) {
  
  _impl_.wireframe_ = value;
}
inline void DrawableProperties::set_wireframe(bool value) {
  _internal_set_wireframe(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DrawableProperties.wireframe)
}

// .bosdyn.api.DrawableFrame frame = 4;
inline bool DrawableProperties::_internal_has_frame() const {
  return drawable_case() == kFrame;
}
inline bool DrawableProperties::has_frame() const {
  return _internal_has_frame();
}
inline void DrawableProperties::set_has_frame() {
  _impl_._oneof_case_[0] = kFrame;
}
inline void DrawableProperties::clear_frame() {
  if (_internal_has_frame()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.drawable_.frame_;
    }
    clear_has_drawable();
  }
}
inline ::bosdyn::api::DrawableFrame* DrawableProperties::release_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DrawableProperties.frame)
  if (_internal_has_frame()) {
    clear_has_drawable();
    ::bosdyn::api::DrawableFrame* temp = _impl_.drawable_.frame_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.drawable_.frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::DrawableFrame& DrawableProperties::_internal_frame() const {
  return _internal_has_frame()
      ? *_impl_.drawable_.frame_
      : reinterpret_cast< ::bosdyn::api::DrawableFrame&>(::bosdyn::api::_DrawableFrame_default_instance_);
}
inline const ::bosdyn::api::DrawableFrame& DrawableProperties::frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableProperties.frame)
  return _internal_frame();
}
inline ::bosdyn::api::DrawableFrame* DrawableProperties::unsafe_arena_release_frame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.DrawableProperties.frame)
  if (_internal_has_frame()) {
    clear_has_drawable();
    ::bosdyn::api::DrawableFrame* temp = _impl_.drawable_.frame_;
    _impl_.drawable_.frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawableProperties::unsafe_arena_set_allocated_frame(::bosdyn::api::DrawableFrame* frame) {
  clear_drawable();
  if (frame) {
    set_has_frame();
    _impl_.drawable_.frame_ = frame;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DrawableProperties.frame)
}
inline ::bosdyn::api::DrawableFrame* DrawableProperties::_internal_mutable_frame() {
  if (!_internal_has_frame()) {
    clear_drawable();
    set_has_frame();
    _impl_.drawable_.frame_ = CreateMaybeMessage< ::bosdyn::api::DrawableFrame >(GetArenaForAllocation());
  }
  return _impl_.drawable_.frame_;
}
inline ::bosdyn::api::DrawableFrame* DrawableProperties::mutable_frame() {
  ::bosdyn::api::DrawableFrame* _msg = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawableProperties.frame)
  return _msg;
}

// .bosdyn.api.DrawableSphere sphere = 5;
inline bool DrawableProperties::_internal_has_sphere() const {
  return drawable_case() == kSphere;
}
inline bool DrawableProperties::has_sphere() const {
  return _internal_has_sphere();
}
inline void DrawableProperties::set_has_sphere() {
  _impl_._oneof_case_[0] = kSphere;
}
inline void DrawableProperties::clear_sphere() {
  if (_internal_has_sphere()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.drawable_.sphere_;
    }
    clear_has_drawable();
  }
}
inline ::bosdyn::api::DrawableSphere* DrawableProperties::release_sphere() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DrawableProperties.sphere)
  if (_internal_has_sphere()) {
    clear_has_drawable();
    ::bosdyn::api::DrawableSphere* temp = _impl_.drawable_.sphere_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.drawable_.sphere_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::DrawableSphere& DrawableProperties::_internal_sphere() const {
  return _internal_has_sphere()
      ? *_impl_.drawable_.sphere_
      : reinterpret_cast< ::bosdyn::api::DrawableSphere&>(::bosdyn::api::_DrawableSphere_default_instance_);
}
inline const ::bosdyn::api::DrawableSphere& DrawableProperties::sphere() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableProperties.sphere)
  return _internal_sphere();
}
inline ::bosdyn::api::DrawableSphere* DrawableProperties::unsafe_arena_release_sphere() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.DrawableProperties.sphere)
  if (_internal_has_sphere()) {
    clear_has_drawable();
    ::bosdyn::api::DrawableSphere* temp = _impl_.drawable_.sphere_;
    _impl_.drawable_.sphere_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawableProperties::unsafe_arena_set_allocated_sphere(::bosdyn::api::DrawableSphere* sphere) {
  clear_drawable();
  if (sphere) {
    set_has_sphere();
    _impl_.drawable_.sphere_ = sphere;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DrawableProperties.sphere)
}
inline ::bosdyn::api::DrawableSphere* DrawableProperties::_internal_mutable_sphere() {
  if (!_internal_has_sphere()) {
    clear_drawable();
    set_has_sphere();
    _impl_.drawable_.sphere_ = CreateMaybeMessage< ::bosdyn::api::DrawableSphere >(GetArenaForAllocation());
  }
  return _impl_.drawable_.sphere_;
}
inline ::bosdyn::api::DrawableSphere* DrawableProperties::mutable_sphere() {
  ::bosdyn::api::DrawableSphere* _msg = _internal_mutable_sphere();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawableProperties.sphere)
  return _msg;
}

// .bosdyn.api.DrawableBox box = 6;
inline bool DrawableProperties::_internal_has_box() const {
  return drawable_case() == kBox;
}
inline bool DrawableProperties::has_box() const {
  return _internal_has_box();
}
inline void DrawableProperties::set_has_box() {
  _impl_._oneof_case_[0] = kBox;
}
inline void DrawableProperties::clear_box() {
  if (_internal_has_box()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.drawable_.box_;
    }
    clear_has_drawable();
  }
}
inline ::bosdyn::api::DrawableBox* DrawableProperties::release_box() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DrawableProperties.box)
  if (_internal_has_box()) {
    clear_has_drawable();
    ::bosdyn::api::DrawableBox* temp = _impl_.drawable_.box_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.drawable_.box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::DrawableBox& DrawableProperties::_internal_box() const {
  return _internal_has_box()
      ? *_impl_.drawable_.box_
      : reinterpret_cast< ::bosdyn::api::DrawableBox&>(::bosdyn::api::_DrawableBox_default_instance_);
}
inline const ::bosdyn::api::DrawableBox& DrawableProperties::box() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableProperties.box)
  return _internal_box();
}
inline ::bosdyn::api::DrawableBox* DrawableProperties::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.DrawableProperties.box)
  if (_internal_has_box()) {
    clear_has_drawable();
    ::bosdyn::api::DrawableBox* temp = _impl_.drawable_.box_;
    _impl_.drawable_.box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawableProperties::unsafe_arena_set_allocated_box(::bosdyn::api::DrawableBox* box) {
  clear_drawable();
  if (box) {
    set_has_box();
    _impl_.drawable_.box_ = box;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DrawableProperties.box)
}
inline ::bosdyn::api::DrawableBox* DrawableProperties::_internal_mutable_box() {
  if (!_internal_has_box()) {
    clear_drawable();
    set_has_box();
    _impl_.drawable_.box_ = CreateMaybeMessage< ::bosdyn::api::DrawableBox >(GetArenaForAllocation());
  }
  return _impl_.drawable_.box_;
}
inline ::bosdyn::api::DrawableBox* DrawableProperties::mutable_box() {
  ::bosdyn::api::DrawableBox* _msg = _internal_mutable_box();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawableProperties.box)
  return _msg;
}

// .bosdyn.api.DrawableArrow arrow = 7;
inline bool DrawableProperties::_internal_has_arrow() const {
  return drawable_case() == kArrow;
}
inline bool DrawableProperties::has_arrow() const {
  return _internal_has_arrow();
}
inline void DrawableProperties::set_has_arrow() {
  _impl_._oneof_case_[0] = kArrow;
}
inline void DrawableProperties::clear_arrow() {
  if (_internal_has_arrow()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.drawable_.arrow_;
    }
    clear_has_drawable();
  }
}
inline ::bosdyn::api::DrawableArrow* DrawableProperties::release_arrow() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DrawableProperties.arrow)
  if (_internal_has_arrow()) {
    clear_has_drawable();
    ::bosdyn::api::DrawableArrow* temp = _impl_.drawable_.arrow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.drawable_.arrow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::DrawableArrow& DrawableProperties::_internal_arrow() const {
  return _internal_has_arrow()
      ? *_impl_.drawable_.arrow_
      : reinterpret_cast< ::bosdyn::api::DrawableArrow&>(::bosdyn::api::_DrawableArrow_default_instance_);
}
inline const ::bosdyn::api::DrawableArrow& DrawableProperties::arrow() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableProperties.arrow)
  return _internal_arrow();
}
inline ::bosdyn::api::DrawableArrow* DrawableProperties::unsafe_arena_release_arrow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.DrawableProperties.arrow)
  if (_internal_has_arrow()) {
    clear_has_drawable();
    ::bosdyn::api::DrawableArrow* temp = _impl_.drawable_.arrow_;
    _impl_.drawable_.arrow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawableProperties::unsafe_arena_set_allocated_arrow(::bosdyn::api::DrawableArrow* arrow) {
  clear_drawable();
  if (arrow) {
    set_has_arrow();
    _impl_.drawable_.arrow_ = arrow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DrawableProperties.arrow)
}
inline ::bosdyn::api::DrawableArrow* DrawableProperties::_internal_mutable_arrow() {
  if (!_internal_has_arrow()) {
    clear_drawable();
    set_has_arrow();
    _impl_.drawable_.arrow_ = CreateMaybeMessage< ::bosdyn::api::DrawableArrow >(GetArenaForAllocation());
  }
  return _impl_.drawable_.arrow_;
}
inline ::bosdyn::api::DrawableArrow* DrawableProperties::mutable_arrow() {
  ::bosdyn::api::DrawableArrow* _msg = _internal_mutable_arrow();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawableProperties.arrow)
  return _msg;
}

// .bosdyn.api.DrawableCapsule capsule = 8;
inline bool DrawableProperties::_internal_has_capsule() const {
  return drawable_case() == kCapsule;
}
inline bool DrawableProperties::has_capsule() const {
  return _internal_has_capsule();
}
inline void DrawableProperties::set_has_capsule() {
  _impl_._oneof_case_[0] = kCapsule;
}
inline void DrawableProperties::clear_capsule() {
  if (_internal_has_capsule()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.drawable_.capsule_;
    }
    clear_has_drawable();
  }
}
inline ::bosdyn::api::DrawableCapsule* DrawableProperties::release_capsule() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DrawableProperties.capsule)
  if (_internal_has_capsule()) {
    clear_has_drawable();
    ::bosdyn::api::DrawableCapsule* temp = _impl_.drawable_.capsule_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.drawable_.capsule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::DrawableCapsule& DrawableProperties::_internal_capsule() const {
  return _internal_has_capsule()
      ? *_impl_.drawable_.capsule_
      : reinterpret_cast< ::bosdyn::api::DrawableCapsule&>(::bosdyn::api::_DrawableCapsule_default_instance_);
}
inline const ::bosdyn::api::DrawableCapsule& DrawableProperties::capsule() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableProperties.capsule)
  return _internal_capsule();
}
inline ::bosdyn::api::DrawableCapsule* DrawableProperties::unsafe_arena_release_capsule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.DrawableProperties.capsule)
  if (_internal_has_capsule()) {
    clear_has_drawable();
    ::bosdyn::api::DrawableCapsule* temp = _impl_.drawable_.capsule_;
    _impl_.drawable_.capsule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawableProperties::unsafe_arena_set_allocated_capsule(::bosdyn::api::DrawableCapsule* capsule) {
  clear_drawable();
  if (capsule) {
    set_has_capsule();
    _impl_.drawable_.capsule_ = capsule;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DrawableProperties.capsule)
}
inline ::bosdyn::api::DrawableCapsule* DrawableProperties::_internal_mutable_capsule() {
  if (!_internal_has_capsule()) {
    clear_drawable();
    set_has_capsule();
    _impl_.drawable_.capsule_ = CreateMaybeMessage< ::bosdyn::api::DrawableCapsule >(GetArenaForAllocation());
  }
  return _impl_.drawable_.capsule_;
}
inline ::bosdyn::api::DrawableCapsule* DrawableProperties::mutable_capsule() {
  ::bosdyn::api::DrawableCapsule* _msg = _internal_mutable_capsule();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawableProperties.capsule)
  return _msg;
}

// .bosdyn.api.DrawableCylinder cylinder = 9;
inline bool DrawableProperties::_internal_has_cylinder() const {
  return drawable_case() == kCylinder;
}
inline bool DrawableProperties::has_cylinder() const {
  return _internal_has_cylinder();
}
inline void DrawableProperties::set_has_cylinder() {
  _impl_._oneof_case_[0] = kCylinder;
}
inline void DrawableProperties::clear_cylinder() {
  if (_internal_has_cylinder()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.drawable_.cylinder_;
    }
    clear_has_drawable();
  }
}
inline ::bosdyn::api::DrawableCylinder* DrawableProperties::release_cylinder() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DrawableProperties.cylinder)
  if (_internal_has_cylinder()) {
    clear_has_drawable();
    ::bosdyn::api::DrawableCylinder* temp = _impl_.drawable_.cylinder_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.drawable_.cylinder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::DrawableCylinder& DrawableProperties::_internal_cylinder() const {
  return _internal_has_cylinder()
      ? *_impl_.drawable_.cylinder_
      : reinterpret_cast< ::bosdyn::api::DrawableCylinder&>(::bosdyn::api::_DrawableCylinder_default_instance_);
}
inline const ::bosdyn::api::DrawableCylinder& DrawableProperties::cylinder() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableProperties.cylinder)
  return _internal_cylinder();
}
inline ::bosdyn::api::DrawableCylinder* DrawableProperties::unsafe_arena_release_cylinder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.DrawableProperties.cylinder)
  if (_internal_has_cylinder()) {
    clear_has_drawable();
    ::bosdyn::api::DrawableCylinder* temp = _impl_.drawable_.cylinder_;
    _impl_.drawable_.cylinder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawableProperties::unsafe_arena_set_allocated_cylinder(::bosdyn::api::DrawableCylinder* cylinder) {
  clear_drawable();
  if (cylinder) {
    set_has_cylinder();
    _impl_.drawable_.cylinder_ = cylinder;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DrawableProperties.cylinder)
}
inline ::bosdyn::api::DrawableCylinder* DrawableProperties::_internal_mutable_cylinder() {
  if (!_internal_has_cylinder()) {
    clear_drawable();
    set_has_cylinder();
    _impl_.drawable_.cylinder_ = CreateMaybeMessage< ::bosdyn::api::DrawableCylinder >(GetArenaForAllocation());
  }
  return _impl_.drawable_.cylinder_;
}
inline ::bosdyn::api::DrawableCylinder* DrawableProperties::mutable_cylinder() {
  ::bosdyn::api::DrawableCylinder* _msg = _internal_mutable_cylinder();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawableProperties.cylinder)
  return _msg;
}

// .bosdyn.api.DrawableLineStrip linestrip = 10;
inline bool DrawableProperties::_internal_has_linestrip() const {
  return drawable_case() == kLinestrip;
}
inline bool DrawableProperties::has_linestrip() const {
  return _internal_has_linestrip();
}
inline void DrawableProperties::set_has_linestrip() {
  _impl_._oneof_case_[0] = kLinestrip;
}
inline void DrawableProperties::clear_linestrip() {
  if (_internal_has_linestrip()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.drawable_.linestrip_;
    }
    clear_has_drawable();
  }
}
inline ::bosdyn::api::DrawableLineStrip* DrawableProperties::release_linestrip() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DrawableProperties.linestrip)
  if (_internal_has_linestrip()) {
    clear_has_drawable();
    ::bosdyn::api::DrawableLineStrip* temp = _impl_.drawable_.linestrip_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.drawable_.linestrip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::DrawableLineStrip& DrawableProperties::_internal_linestrip() const {
  return _internal_has_linestrip()
      ? *_impl_.drawable_.linestrip_
      : reinterpret_cast< ::bosdyn::api::DrawableLineStrip&>(::bosdyn::api::_DrawableLineStrip_default_instance_);
}
inline const ::bosdyn::api::DrawableLineStrip& DrawableProperties::linestrip() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableProperties.linestrip)
  return _internal_linestrip();
}
inline ::bosdyn::api::DrawableLineStrip* DrawableProperties::unsafe_arena_release_linestrip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.DrawableProperties.linestrip)
  if (_internal_has_linestrip()) {
    clear_has_drawable();
    ::bosdyn::api::DrawableLineStrip* temp = _impl_.drawable_.linestrip_;
    _impl_.drawable_.linestrip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawableProperties::unsafe_arena_set_allocated_linestrip(::bosdyn::api::DrawableLineStrip* linestrip) {
  clear_drawable();
  if (linestrip) {
    set_has_linestrip();
    _impl_.drawable_.linestrip_ = linestrip;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DrawableProperties.linestrip)
}
inline ::bosdyn::api::DrawableLineStrip* DrawableProperties::_internal_mutable_linestrip() {
  if (!_internal_has_linestrip()) {
    clear_drawable();
    set_has_linestrip();
    _impl_.drawable_.linestrip_ = CreateMaybeMessage< ::bosdyn::api::DrawableLineStrip >(GetArenaForAllocation());
  }
  return _impl_.drawable_.linestrip_;
}
inline ::bosdyn::api::DrawableLineStrip* DrawableProperties::mutable_linestrip() {
  ::bosdyn::api::DrawableLineStrip* _msg = _internal_mutable_linestrip();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawableProperties.linestrip)
  return _msg;
}

// .bosdyn.api.DrawablePoints points = 11;
inline bool DrawableProperties::_internal_has_points() const {
  return drawable_case() == kPoints;
}
inline bool DrawableProperties::has_points() const {
  return _internal_has_points();
}
inline void DrawableProperties::set_has_points() {
  _impl_._oneof_case_[0] = kPoints;
}
inline void DrawableProperties::clear_points() {
  if (_internal_has_points()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.drawable_.points_;
    }
    clear_has_drawable();
  }
}
inline ::bosdyn::api::DrawablePoints* DrawableProperties::release_points() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DrawableProperties.points)
  if (_internal_has_points()) {
    clear_has_drawable();
    ::bosdyn::api::DrawablePoints* temp = _impl_.drawable_.points_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.drawable_.points_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::DrawablePoints& DrawableProperties::_internal_points() const {
  return _internal_has_points()
      ? *_impl_.drawable_.points_
      : reinterpret_cast< ::bosdyn::api::DrawablePoints&>(::bosdyn::api::_DrawablePoints_default_instance_);
}
inline const ::bosdyn::api::DrawablePoints& DrawableProperties::points() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableProperties.points)
  return _internal_points();
}
inline ::bosdyn::api::DrawablePoints* DrawableProperties::unsafe_arena_release_points() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.DrawableProperties.points)
  if (_internal_has_points()) {
    clear_has_drawable();
    ::bosdyn::api::DrawablePoints* temp = _impl_.drawable_.points_;
    _impl_.drawable_.points_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawableProperties::unsafe_arena_set_allocated_points(::bosdyn::api::DrawablePoints* points) {
  clear_drawable();
  if (points) {
    set_has_points();
    _impl_.drawable_.points_ = points;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DrawableProperties.points)
}
inline ::bosdyn::api::DrawablePoints* DrawableProperties::_internal_mutable_points() {
  if (!_internal_has_points()) {
    clear_drawable();
    set_has_points();
    _impl_.drawable_.points_ = CreateMaybeMessage< ::bosdyn::api::DrawablePoints >(GetArenaForAllocation());
  }
  return _impl_.drawable_.points_;
}
inline ::bosdyn::api::DrawablePoints* DrawableProperties::mutable_points() {
  ::bosdyn::api::DrawablePoints* _msg = _internal_mutable_points();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawableProperties.points)
  return _msg;
}

// string frame_name_drawable = 12;
inline void DrawableProperties::clear_frame_name_drawable() {
  _impl_.frame_name_drawable_.ClearToEmpty();
}
inline const std::string& DrawableProperties::frame_name_drawable() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableProperties.frame_name_drawable)
  return _internal_frame_name_drawable();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DrawableProperties::set_frame_name_drawable(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_drawable_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.DrawableProperties.frame_name_drawable)
}
inline std::string* DrawableProperties::mutable_frame_name_drawable() {
  std::string* _s = _internal_mutable_frame_name_drawable();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawableProperties.frame_name_drawable)
  return _s;
}
inline const std::string& DrawableProperties::_internal_frame_name_drawable() const {
  return _impl_.frame_name_drawable_.Get();
}
inline void DrawableProperties::_internal_set_frame_name_drawable(const std::string& value) {
  
  _impl_.frame_name_drawable_.Set(value, GetArenaForAllocation());
}
inline std::string* DrawableProperties::_internal_mutable_frame_name_drawable() {
  
  return _impl_.frame_name_drawable_.Mutable(GetArenaForAllocation());
}
inline std::string* DrawableProperties::release_frame_name_drawable() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DrawableProperties.frame_name_drawable)
  return _impl_.frame_name_drawable_.Release();
}
inline void DrawableProperties::set_allocated_frame_name_drawable(std::string* frame_name_drawable) {
  if (frame_name_drawable != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_drawable_.SetAllocated(frame_name_drawable, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_drawable_.IsDefault()) {
    _impl_.frame_name_drawable_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DrawableProperties.frame_name_drawable)
}

inline bool DrawableProperties::has_drawable() const {
  return drawable_case() != DRAWABLE_NOT_SET;
}
inline void DrawableProperties::clear_has_drawable() {
  _impl_._oneof_case_[0] = DRAWABLE_NOT_SET;
}
inline DrawableProperties::DrawableCase DrawableProperties::drawable_case() const {
  return DrawableProperties::DrawableCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DrawableFrame

// double arrow_length = 1;
inline void DrawableFrame::clear_arrow_length() {
  _impl_.arrow_length_ = 0;
}
inline double DrawableFrame::_internal_arrow_length() const {
  return _impl_.arrow_length_;
}
inline double DrawableFrame::arrow_length() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableFrame.arrow_length)
  return _internal_arrow_length();
}
inline void DrawableFrame::_internal_set_arrow_length(double value) {
  
  _impl_.arrow_length_ = value;
}
inline void DrawableFrame::set_arrow_length(double value) {
  _internal_set_arrow_length(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DrawableFrame.arrow_length)
}

// double arrow_radius = 2;
inline void DrawableFrame::clear_arrow_radius() {
  _impl_.arrow_radius_ = 0;
}
inline double DrawableFrame::_internal_arrow_radius() const {
  return _impl_.arrow_radius_;
}
inline double DrawableFrame::arrow_radius() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableFrame.arrow_radius)
  return _internal_arrow_radius();
}
inline void DrawableFrame::_internal_set_arrow_radius(double value) {
  
  _impl_.arrow_radius_ = value;
}
inline void DrawableFrame::set_arrow_radius(double value) {
  _internal_set_arrow_radius(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DrawableFrame.arrow_radius)
}

// -------------------------------------------------------------------

// DrawableSphere

// double radius = 1;
inline void DrawableSphere::clear_radius() {
  _impl_.radius_ = 0;
}
inline double DrawableSphere::_internal_radius() const {
  return _impl_.radius_;
}
inline double DrawableSphere::radius() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableSphere.radius)
  return _internal_radius();
}
inline void DrawableSphere::_internal_set_radius(double value) {
  
  _impl_.radius_ = value;
}
inline void DrawableSphere::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DrawableSphere.radius)
}

// -------------------------------------------------------------------

// DrawableBox

// .bosdyn.api.Vec3 size = 1;
inline bool DrawableBox::_internal_has_size() const {
  return this != internal_default_instance() && _impl_.size_ != nullptr;
}
inline bool DrawableBox::has_size() const {
  return _internal_has_size();
}
inline const ::bosdyn::api::Vec3& DrawableBox::_internal_size() const {
  const ::bosdyn::api::Vec3* p = _impl_.size_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& DrawableBox::size() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableBox.size)
  return _internal_size();
}
inline void DrawableBox::unsafe_arena_set_allocated_size(
    ::bosdyn::api::Vec3* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.size_);
  }
  _impl_.size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DrawableBox.size)
}
inline ::bosdyn::api::Vec3* DrawableBox::release_size() {
  
  ::bosdyn::api::Vec3* temp = _impl_.size_;
  _impl_.size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* DrawableBox::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DrawableBox.size)
  
  ::bosdyn::api::Vec3* temp = _impl_.size_;
  _impl_.size_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* DrawableBox::_internal_mutable_size() {
  
  if (_impl_.size_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.size_ = p;
  }
  return _impl_.size_;
}
inline ::bosdyn::api::Vec3* DrawableBox::mutable_size() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawableBox.size)
  return _msg;
}
inline void DrawableBox::set_allocated_size(::bosdyn::api::Vec3* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.size_);
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size));
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.size_ = size;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DrawableBox.size)
}

// -------------------------------------------------------------------

// DrawableArrow

// .bosdyn.api.Vec3 direction = 1;
inline bool DrawableArrow::_internal_has_direction() const {
  return this != internal_default_instance() && _impl_.direction_ != nullptr;
}
inline bool DrawableArrow::has_direction() const {
  return _internal_has_direction();
}
inline const ::bosdyn::api::Vec3& DrawableArrow::_internal_direction() const {
  const ::bosdyn::api::Vec3* p = _impl_.direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& DrawableArrow::direction() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableArrow.direction)
  return _internal_direction();
}
inline void DrawableArrow::unsafe_arena_set_allocated_direction(
    ::bosdyn::api::Vec3* direction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.direction_);
  }
  _impl_.direction_ = direction;
  if (direction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DrawableArrow.direction)
}
inline ::bosdyn::api::Vec3* DrawableArrow::release_direction() {
  
  ::bosdyn::api::Vec3* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* DrawableArrow::unsafe_arena_release_direction() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DrawableArrow.direction)
  
  ::bosdyn::api::Vec3* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* DrawableArrow::_internal_mutable_direction() {
  
  if (_impl_.direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.direction_ = p;
  }
  return _impl_.direction_;
}
inline ::bosdyn::api::Vec3* DrawableArrow::mutable_direction() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawableArrow.direction)
  return _msg;
}
inline void DrawableArrow::set_allocated_direction(::bosdyn::api::Vec3* direction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.direction_);
  }
  if (direction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(direction));
    if (message_arena != submessage_arena) {
      direction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direction, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.direction_ = direction;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DrawableArrow.direction)
}

// double radius = 2;
inline void DrawableArrow::clear_radius() {
  _impl_.radius_ = 0;
}
inline double DrawableArrow::_internal_radius() const {
  return _impl_.radius_;
}
inline double DrawableArrow::radius() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableArrow.radius)
  return _internal_radius();
}
inline void DrawableArrow::_internal_set_radius(double value) {
  
  _impl_.radius_ = value;
}
inline void DrawableArrow::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DrawableArrow.radius)
}

// -------------------------------------------------------------------

// DrawableCapsule

// .bosdyn.api.Vec3 direction = 1;
inline bool DrawableCapsule::_internal_has_direction() const {
  return this != internal_default_instance() && _impl_.direction_ != nullptr;
}
inline bool DrawableCapsule::has_direction() const {
  return _internal_has_direction();
}
inline const ::bosdyn::api::Vec3& DrawableCapsule::_internal_direction() const {
  const ::bosdyn::api::Vec3* p = _impl_.direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& DrawableCapsule::direction() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableCapsule.direction)
  return _internal_direction();
}
inline void DrawableCapsule::unsafe_arena_set_allocated_direction(
    ::bosdyn::api::Vec3* direction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.direction_);
  }
  _impl_.direction_ = direction;
  if (direction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DrawableCapsule.direction)
}
inline ::bosdyn::api::Vec3* DrawableCapsule::release_direction() {
  
  ::bosdyn::api::Vec3* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* DrawableCapsule::unsafe_arena_release_direction() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DrawableCapsule.direction)
  
  ::bosdyn::api::Vec3* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* DrawableCapsule::_internal_mutable_direction() {
  
  if (_impl_.direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.direction_ = p;
  }
  return _impl_.direction_;
}
inline ::bosdyn::api::Vec3* DrawableCapsule::mutable_direction() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawableCapsule.direction)
  return _msg;
}
inline void DrawableCapsule::set_allocated_direction(::bosdyn::api::Vec3* direction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.direction_);
  }
  if (direction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(direction));
    if (message_arena != submessage_arena) {
      direction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direction, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.direction_ = direction;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DrawableCapsule.direction)
}

// double radius = 2;
inline void DrawableCapsule::clear_radius() {
  _impl_.radius_ = 0;
}
inline double DrawableCapsule::_internal_radius() const {
  return _impl_.radius_;
}
inline double DrawableCapsule::radius() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableCapsule.radius)
  return _internal_radius();
}
inline void DrawableCapsule::_internal_set_radius(double value) {
  
  _impl_.radius_ = value;
}
inline void DrawableCapsule::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DrawableCapsule.radius)
}

// -------------------------------------------------------------------

// DrawableCylinder

// .bosdyn.api.Vec3 direction = 1;
inline bool DrawableCylinder::_internal_has_direction() const {
  return this != internal_default_instance() && _impl_.direction_ != nullptr;
}
inline bool DrawableCylinder::has_direction() const {
  return _internal_has_direction();
}
inline const ::bosdyn::api::Vec3& DrawableCylinder::_internal_direction() const {
  const ::bosdyn::api::Vec3* p = _impl_.direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& DrawableCylinder::direction() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableCylinder.direction)
  return _internal_direction();
}
inline void DrawableCylinder::unsafe_arena_set_allocated_direction(
    ::bosdyn::api::Vec3* direction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.direction_);
  }
  _impl_.direction_ = direction;
  if (direction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DrawableCylinder.direction)
}
inline ::bosdyn::api::Vec3* DrawableCylinder::release_direction() {
  
  ::bosdyn::api::Vec3* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* DrawableCylinder::unsafe_arena_release_direction() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DrawableCylinder.direction)
  
  ::bosdyn::api::Vec3* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* DrawableCylinder::_internal_mutable_direction() {
  
  if (_impl_.direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.direction_ = p;
  }
  return _impl_.direction_;
}
inline ::bosdyn::api::Vec3* DrawableCylinder::mutable_direction() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawableCylinder.direction)
  return _msg;
}
inline void DrawableCylinder::set_allocated_direction(::bosdyn::api::Vec3* direction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.direction_);
  }
  if (direction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(direction));
    if (message_arena != submessage_arena) {
      direction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direction, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.direction_ = direction;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DrawableCylinder.direction)
}

// double radius = 2;
inline void DrawableCylinder::clear_radius() {
  _impl_.radius_ = 0;
}
inline double DrawableCylinder::_internal_radius() const {
  return _impl_.radius_;
}
inline double DrawableCylinder::radius() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableCylinder.radius)
  return _internal_radius();
}
inline void DrawableCylinder::_internal_set_radius(double value) {
  
  _impl_.radius_ = value;
}
inline void DrawableCylinder::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DrawableCylinder.radius)
}

// -------------------------------------------------------------------

// DrawableLineStrip

// .bosdyn.api.Vec3 points = 1;
inline bool DrawableLineStrip::_internal_has_points() const {
  return this != internal_default_instance() && _impl_.points_ != nullptr;
}
inline bool DrawableLineStrip::has_points() const {
  return _internal_has_points();
}
inline const ::bosdyn::api::Vec3& DrawableLineStrip::_internal_points() const {
  const ::bosdyn::api::Vec3* p = _impl_.points_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& DrawableLineStrip::points() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawableLineStrip.points)
  return _internal_points();
}
inline void DrawableLineStrip::unsafe_arena_set_allocated_points(
    ::bosdyn::api::Vec3* points) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.points_);
  }
  _impl_.points_ = points;
  if (points) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DrawableLineStrip.points)
}
inline ::bosdyn::api::Vec3* DrawableLineStrip::release_points() {
  
  ::bosdyn::api::Vec3* temp = _impl_.points_;
  _impl_.points_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* DrawableLineStrip::unsafe_arena_release_points() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DrawableLineStrip.points)
  
  ::bosdyn::api::Vec3* temp = _impl_.points_;
  _impl_.points_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* DrawableLineStrip::_internal_mutable_points() {
  
  if (_impl_.points_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.points_ = p;
  }
  return _impl_.points_;
}
inline ::bosdyn::api::Vec3* DrawableLineStrip::mutable_points() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_points();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawableLineStrip.points)
  return _msg;
}
inline void DrawableLineStrip::set_allocated_points(::bosdyn::api::Vec3* points) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.points_);
  }
  if (points) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(points));
    if (message_arena != submessage_arena) {
      points = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, points, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.points_ = points;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DrawableLineStrip.points)
}

// -------------------------------------------------------------------

// DrawablePoints

// repeated .bosdyn.api.Vec3 points = 1;
inline int DrawablePoints::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int DrawablePoints::points_size() const {
  return _internal_points_size();
}
inline ::bosdyn::api::Vec3* DrawablePoints::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DrawablePoints.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec3 >*
DrawablePoints::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.DrawablePoints.points)
  return &_impl_.points_;
}
inline const ::bosdyn::api::Vec3& DrawablePoints::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::bosdyn::api::Vec3& DrawablePoints::points(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DrawablePoints.points)
  return _internal_points(index);
}
inline ::bosdyn::api::Vec3* DrawablePoints::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::bosdyn::api::Vec3* DrawablePoints::add_points() {
  ::bosdyn::api::Vec3* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:bosdyn.api.DrawablePoints.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec3 >&
DrawablePoints::points() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.DrawablePoints.points)
  return _impl_.points_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::MutateWorldObjectRequest_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::MutateWorldObjectRequest_Action>() {
  return ::bosdyn::api::MutateWorldObjectRequest_Action_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::MutateWorldObjectResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::MutateWorldObjectResponse_Status>() {
  return ::bosdyn::api::MutateWorldObjectResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::AprilTagProperties_AprilTagPoseStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::AprilTagProperties_AprilTagPoseStatus>() {
  return ::bosdyn::api::AprilTagProperties_AprilTagPoseStatus_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::WorldObjectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::WorldObjectType>() {
  return ::bosdyn::api::WorldObjectType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fworld_5fobject_2eproto
