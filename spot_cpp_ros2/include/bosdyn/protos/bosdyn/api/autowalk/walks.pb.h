// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/autowalk/walks.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fautowalk_2fwalks_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fautowalk_2fwalks_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
#include "bosdyn/api/mission/nodes.pb.h"
#include "bosdyn/api/mission/util.pb.h"
#include "bosdyn/api/data_acquisition.pb.h"
#include "bosdyn/api/graph_nav/graph_nav.pb.h"
#include "bosdyn/api/graph_nav/nav.pb.h"
#include "bosdyn/api/gripper_command.pb.h"
#include "bosdyn/api/geometry.pb.h"
#include "bosdyn/api/trajectory.pb.h"
#include "bosdyn/api/spot_cam/ptz.pb.h"
#include "bosdyn/api/spot/robot_command.pb.h"
#include "bosdyn/api/arm_command.pb.h"
#include "bosdyn/api/basic_command.pb.h"
#include "bosdyn/api/gripper_camera_param.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fautowalk_2fwalks_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
namespace bosdyn {
namespace api {
namespace autowalk {
class Action;
struct ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class ActionWrapper;
struct ActionWrapperDefaultTypeInternal;
extern ActionWrapperDefaultTypeInternal _ActionWrapper_default_instance_;
class ActionWrapper_ArmSensorPointing;
struct ActionWrapper_ArmSensorPointingDefaultTypeInternal;
extern ActionWrapper_ArmSensorPointingDefaultTypeInternal _ActionWrapper_ArmSensorPointing_default_instance_;
class ActionWrapper_GripperCameraParams;
struct ActionWrapper_GripperCameraParamsDefaultTypeInternal;
extern ActionWrapper_GripperCameraParamsDefaultTypeInternal _ActionWrapper_GripperCameraParams_default_instance_;
class ActionWrapper_GripperCommand;
struct ActionWrapper_GripperCommandDefaultTypeInternal;
extern ActionWrapper_GripperCommandDefaultTypeInternal _ActionWrapper_GripperCommand_default_instance_;
class ActionWrapper_RobotBodyPose;
struct ActionWrapper_RobotBodyPoseDefaultTypeInternal;
extern ActionWrapper_RobotBodyPoseDefaultTypeInternal _ActionWrapper_RobotBodyPose_default_instance_;
class ActionWrapper_RobotBodySit;
struct ActionWrapper_RobotBodySitDefaultTypeInternal;
extern ActionWrapper_RobotBodySitDefaultTypeInternal _ActionWrapper_RobotBodySit_default_instance_;
class ActionWrapper_SpotCamLed;
struct ActionWrapper_SpotCamLedDefaultTypeInternal;
extern ActionWrapper_SpotCamLedDefaultTypeInternal _ActionWrapper_SpotCamLed_default_instance_;
class ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUse;
struct ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUseDefaultTypeInternal;
extern ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUseDefaultTypeInternal _ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUse_default_instance_;
class ActionWrapper_SpotCamPtz;
struct ActionWrapper_SpotCamPtzDefaultTypeInternal;
extern ActionWrapper_SpotCamPtzDefaultTypeInternal _ActionWrapper_SpotCamPtz_default_instance_;
class Action_DataAcquisition;
struct Action_DataAcquisitionDefaultTypeInternal;
extern Action_DataAcquisitionDefaultTypeInternal _Action_DataAcquisition_default_instance_;
class Action_RemoteGrpc;
struct Action_RemoteGrpcDefaultTypeInternal;
extern Action_RemoteGrpcDefaultTypeInternal _Action_RemoteGrpc_default_instance_;
class Action_Sleep;
struct Action_SleepDefaultTypeInternal;
extern Action_SleepDefaultTypeInternal _Action_Sleep_default_instance_;
class BatteryMonitor;
struct BatteryMonitorDefaultTypeInternal;
extern BatteryMonitorDefaultTypeInternal _BatteryMonitor_default_instance_;
class Dock;
struct DockDefaultTypeInternal;
extern DockDefaultTypeInternal _Dock_default_instance_;
class Element;
struct ElementDefaultTypeInternal;
extern ElementDefaultTypeInternal _Element_default_instance_;
class FailureBehavior;
struct FailureBehaviorDefaultTypeInternal;
extern FailureBehaviorDefaultTypeInternal _FailureBehavior_default_instance_;
class FailureBehavior_ProceedIfAble;
struct FailureBehavior_ProceedIfAbleDefaultTypeInternal;
extern FailureBehavior_ProceedIfAbleDefaultTypeInternal _FailureBehavior_ProceedIfAble_default_instance_;
class FailureBehavior_ReturnToStartAndTerminate;
struct FailureBehavior_ReturnToStartAndTerminateDefaultTypeInternal;
extern FailureBehavior_ReturnToStartAndTerminateDefaultTypeInternal _FailureBehavior_ReturnToStartAndTerminate_default_instance_;
class FailureBehavior_ReturnToStartAndTryAgainLater;
struct FailureBehavior_ReturnToStartAndTryAgainLaterDefaultTypeInternal;
extern FailureBehavior_ReturnToStartAndTryAgainLaterDefaultTypeInternal _FailureBehavior_ReturnToStartAndTryAgainLater_default_instance_;
class FailureBehavior_SafePowerOff;
struct FailureBehavior_SafePowerOffDefaultTypeInternal;
extern FailureBehavior_SafePowerOffDefaultTypeInternal _FailureBehavior_SafePowerOff_default_instance_;
class GlobalParameters;
struct GlobalParametersDefaultTypeInternal;
extern GlobalParametersDefaultTypeInternal _GlobalParameters_default_instance_;
class PlaybackMode;
struct PlaybackModeDefaultTypeInternal;
extern PlaybackModeDefaultTypeInternal _PlaybackMode_default_instance_;
class PlaybackMode_Continuous;
struct PlaybackMode_ContinuousDefaultTypeInternal;
extern PlaybackMode_ContinuousDefaultTypeInternal _PlaybackMode_Continuous_default_instance_;
class PlaybackMode_Once;
struct PlaybackMode_OnceDefaultTypeInternal;
extern PlaybackMode_OnceDefaultTypeInternal _PlaybackMode_Once_default_instance_;
class PlaybackMode_Periodic;
struct PlaybackMode_PeriodicDefaultTypeInternal;
extern PlaybackMode_PeriodicDefaultTypeInternal _PlaybackMode_Periodic_default_instance_;
class Target;
struct TargetDefaultTypeInternal;
extern TargetDefaultTypeInternal _Target_default_instance_;
class Target_NavigateRoute;
struct Target_NavigateRouteDefaultTypeInternal;
extern Target_NavigateRouteDefaultTypeInternal _Target_NavigateRoute_default_instance_;
class Target_NavigateTo;
struct Target_NavigateToDefaultTypeInternal;
extern Target_NavigateToDefaultTypeInternal _Target_NavigateTo_default_instance_;
class Target_Relocalize;
struct Target_RelocalizeDefaultTypeInternal;
extern Target_RelocalizeDefaultTypeInternal _Target_Relocalize_default_instance_;
class Walk;
struct WalkDefaultTypeInternal;
extern WalkDefaultTypeInternal _Walk_default_instance_;
}  // namespace autowalk
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::autowalk::Action* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::Action>(Arena*);
template<> ::bosdyn::api::autowalk::ActionWrapper* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper>(Arena*);
template<> ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing>(Arena*);
template<> ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams>(Arena*);
template<> ::bosdyn::api::autowalk::ActionWrapper_GripperCommand* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper_GripperCommand>(Arena*);
template<> ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose>(Arena*);
template<> ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper_RobotBodySit>(Arena*);
template<> ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper_SpotCamLed>(Arena*);
template<> ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz>(Arena*);
template<> ::bosdyn::api::autowalk::Action_DataAcquisition* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::Action_DataAcquisition>(Arena*);
template<> ::bosdyn::api::autowalk::Action_RemoteGrpc* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::Action_RemoteGrpc>(Arena*);
template<> ::bosdyn::api::autowalk::Action_Sleep* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::Action_Sleep>(Arena*);
template<> ::bosdyn::api::autowalk::BatteryMonitor* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::BatteryMonitor>(Arena*);
template<> ::bosdyn::api::autowalk::Dock* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::Dock>(Arena*);
template<> ::bosdyn::api::autowalk::Element* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::Element>(Arena*);
template<> ::bosdyn::api::autowalk::FailureBehavior* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::FailureBehavior>(Arena*);
template<> ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble>(Arena*);
template<> ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate>(Arena*);
template<> ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater>(Arena*);
template<> ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::FailureBehavior_SafePowerOff>(Arena*);
template<> ::bosdyn::api::autowalk::GlobalParameters* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::GlobalParameters>(Arena*);
template<> ::bosdyn::api::autowalk::PlaybackMode* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::PlaybackMode>(Arena*);
template<> ::bosdyn::api::autowalk::PlaybackMode_Continuous* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::PlaybackMode_Continuous>(Arena*);
template<> ::bosdyn::api::autowalk::PlaybackMode_Once* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::PlaybackMode_Once>(Arena*);
template<> ::bosdyn::api::autowalk::PlaybackMode_Periodic* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::PlaybackMode_Periodic>(Arena*);
template<> ::bosdyn::api::autowalk::Target* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::Target>(Arena*);
template<> ::bosdyn::api::autowalk::Target_NavigateRoute* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::Target_NavigateRoute>(Arena*);
template<> ::bosdyn::api::autowalk::Target_NavigateTo* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::Target_NavigateTo>(Arena*);
template<> ::bosdyn::api::autowalk::Target_Relocalize* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::Target_Relocalize>(Arena*);
template<> ::bosdyn::api::autowalk::Walk* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::Walk>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {
namespace autowalk {

// ===================================================================

class Walk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.Walk) */ {
 public:
  inline Walk() : Walk(nullptr) {}
  ~Walk() override;
  explicit PROTOBUF_CONSTEXPR Walk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Walk(const Walk& from);
  Walk(Walk&& from) noexcept
    : Walk() {
    *this = ::std::move(from);
  }

  inline Walk& operator=(const Walk& from) {
    CopyFrom(from);
    return *this;
  }
  inline Walk& operator=(Walk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Walk& default_instance() {
    return *internal_default_instance();
  }
  static inline const Walk* internal_default_instance() {
    return reinterpret_cast<const Walk*>(
               &_Walk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Walk& a, Walk& b) {
    a.Swap(&b);
  }
  inline void Swap(Walk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Walk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Walk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Walk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Walk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Walk& from) {
    Walk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Walk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.Walk";
  }
  protected:
  explicit Walk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementsFieldNumber = 5,
    kDocksFieldNumber = 6,
    kMissionNameFieldNumber = 4,
    kMapNameFieldNumber = 7,
    kGlobalParametersFieldNumber = 1,
    kPlaybackModeFieldNumber = 2,
  };
  // repeated .bosdyn.api.autowalk.Element elements = 5;
  int elements_size() const;
  private:
  int _internal_elements_size() const;
  public:
  void clear_elements();
  ::bosdyn::api::autowalk::Element* mutable_elements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::Element >*
      mutable_elements();
  private:
  const ::bosdyn::api::autowalk::Element& _internal_elements(int index) const;
  ::bosdyn::api::autowalk::Element* _internal_add_elements();
  public:
  const ::bosdyn::api::autowalk::Element& elements(int index) const;
  ::bosdyn::api::autowalk::Element* add_elements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::Element >&
      elements() const;

  // repeated .bosdyn.api.autowalk.Dock docks = 6;
  int docks_size() const;
  private:
  int _internal_docks_size() const;
  public:
  void clear_docks();
  ::bosdyn::api::autowalk::Dock* mutable_docks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::Dock >*
      mutable_docks();
  private:
  const ::bosdyn::api::autowalk::Dock& _internal_docks(int index) const;
  ::bosdyn::api::autowalk::Dock* _internal_add_docks();
  public:
  const ::bosdyn::api::autowalk::Dock& docks(int index) const;
  ::bosdyn::api::autowalk::Dock* add_docks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::Dock >&
      docks() const;

  // string mission_name = 4;
  void clear_mission_name();
  const std::string& mission_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mission_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mission_name();
  PROTOBUF_NODISCARD std::string* release_mission_name();
  void set_allocated_mission_name(std::string* mission_name);
  private:
  const std::string& _internal_mission_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mission_name(const std::string& value);
  std::string* _internal_mutable_mission_name();
  public:

  // string map_name = 7;
  void clear_map_name();
  const std::string& map_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_name();
  PROTOBUF_NODISCARD std::string* release_map_name();
  void set_allocated_map_name(std::string* map_name);
  private:
  const std::string& _internal_map_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map_name(const std::string& value);
  std::string* _internal_mutable_map_name();
  public:

  // .bosdyn.api.autowalk.GlobalParameters global_parameters = 1;
  bool has_global_parameters() const;
  private:
  bool _internal_has_global_parameters() const;
  public:
  void clear_global_parameters();
  const ::bosdyn::api::autowalk::GlobalParameters& global_parameters() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::GlobalParameters* release_global_parameters();
  ::bosdyn::api::autowalk::GlobalParameters* mutable_global_parameters();
  void set_allocated_global_parameters(::bosdyn::api::autowalk::GlobalParameters* global_parameters);
  private:
  const ::bosdyn::api::autowalk::GlobalParameters& _internal_global_parameters() const;
  ::bosdyn::api::autowalk::GlobalParameters* _internal_mutable_global_parameters();
  public:
  void unsafe_arena_set_allocated_global_parameters(
      ::bosdyn::api::autowalk::GlobalParameters* global_parameters);
  ::bosdyn::api::autowalk::GlobalParameters* unsafe_arena_release_global_parameters();

  // .bosdyn.api.autowalk.PlaybackMode playback_mode = 2;
  bool has_playback_mode() const;
  private:
  bool _internal_has_playback_mode() const;
  public:
  void clear_playback_mode();
  const ::bosdyn::api::autowalk::PlaybackMode& playback_mode() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::PlaybackMode* release_playback_mode();
  ::bosdyn::api::autowalk::PlaybackMode* mutable_playback_mode();
  void set_allocated_playback_mode(::bosdyn::api::autowalk::PlaybackMode* playback_mode);
  private:
  const ::bosdyn::api::autowalk::PlaybackMode& _internal_playback_mode() const;
  ::bosdyn::api::autowalk::PlaybackMode* _internal_mutable_playback_mode();
  public:
  void unsafe_arena_set_allocated_playback_mode(
      ::bosdyn::api::autowalk::PlaybackMode* playback_mode);
  ::bosdyn::api::autowalk::PlaybackMode* unsafe_arena_release_playback_mode();

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.Walk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::Element > elements_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::Dock > docks_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mission_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_name_;
    ::bosdyn::api::autowalk::GlobalParameters* global_parameters_;
    ::bosdyn::api::autowalk::PlaybackMode* playback_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class GlobalParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.GlobalParameters) */ {
 public:
  inline GlobalParameters() : GlobalParameters(nullptr) {}
  ~GlobalParameters() override;
  explicit PROTOBUF_CONSTEXPR GlobalParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalParameters(const GlobalParameters& from);
  GlobalParameters(GlobalParameters&& from) noexcept
    : GlobalParameters() {
    *this = ::std::move(from);
  }

  inline GlobalParameters& operator=(const GlobalParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalParameters& operator=(GlobalParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalParameters* internal_default_instance() {
    return reinterpret_cast<const GlobalParameters*>(
               &_GlobalParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GlobalParameters& a, GlobalParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GlobalParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GlobalParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlobalParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GlobalParameters& from) {
    GlobalParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.GlobalParameters";
  }
  protected:
  explicit GlobalParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPostMissionCallbacksFieldNumber = 4,
    kGroupNameFieldNumber = 1,
    kSelfRightAttemptsFieldNumber = 3,
    kShouldAutofocusPtzFieldNumber = 2,
    kSkipActionsFieldNumber = 5,
  };
  // repeated .bosdyn.api.autowalk.Action.RemoteGrpc post_mission_callbacks = 4;
  int post_mission_callbacks_size() const;
  private:
  int _internal_post_mission_callbacks_size() const;
  public:
  void clear_post_mission_callbacks();
  ::bosdyn::api::autowalk::Action_RemoteGrpc* mutable_post_mission_callbacks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::Action_RemoteGrpc >*
      mutable_post_mission_callbacks();
  private:
  const ::bosdyn::api::autowalk::Action_RemoteGrpc& _internal_post_mission_callbacks(int index) const;
  ::bosdyn::api::autowalk::Action_RemoteGrpc* _internal_add_post_mission_callbacks();
  public:
  const ::bosdyn::api::autowalk::Action_RemoteGrpc& post_mission_callbacks(int index) const;
  ::bosdyn::api::autowalk::Action_RemoteGrpc* add_post_mission_callbacks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::Action_RemoteGrpc >&
      post_mission_callbacks() const;

  // string group_name = 1;
  void clear_group_name();
  const std::string& group_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_name();
  PROTOBUF_NODISCARD std::string* release_group_name();
  void set_allocated_group_name(std::string* group_name);
  private:
  const std::string& _internal_group_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_name(const std::string& value);
  std::string* _internal_mutable_group_name();
  public:

  // int32 self_right_attempts = 3;
  void clear_self_right_attempts();
  int32_t self_right_attempts() const;
  void set_self_right_attempts(int32_t value);
  private:
  int32_t _internal_self_right_attempts() const;
  void _internal_set_self_right_attempts(int32_t value);
  public:

  // bool should_autofocus_ptz = 2;
  void clear_should_autofocus_ptz();
  bool should_autofocus_ptz() const;
  void set_should_autofocus_ptz(bool value);
  private:
  bool _internal_should_autofocus_ptz() const;
  void _internal_set_should_autofocus_ptz(bool value);
  public:

  // bool skip_actions = 5;
  void clear_skip_actions();
  bool skip_actions() const;
  void set_skip_actions(bool value);
  private:
  bool _internal_skip_actions() const;
  void _internal_set_skip_actions(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.GlobalParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::Action_RemoteGrpc > post_mission_callbacks_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_name_;
    int32_t self_right_attempts_;
    bool should_autofocus_ptz_;
    bool skip_actions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class Dock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.Dock) */ {
 public:
  inline Dock() : Dock(nullptr) {}
  ~Dock() override;
  explicit PROTOBUF_CONSTEXPR Dock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dock(const Dock& from);
  Dock(Dock&& from) noexcept
    : Dock() {
    *this = ::std::move(from);
  }

  inline Dock& operator=(const Dock& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dock& operator=(Dock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dock& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dock* internal_default_instance() {
    return reinterpret_cast<const Dock*>(
               &_Dock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Dock& a, Dock& b) {
    a.Swap(&b);
  }
  inline void Swap(Dock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Dock& from) {
    Dock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.Dock";
  }
  protected:
  explicit Dock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDockedWaypointIdFieldNumber = 2,
    kTargetPrepPoseFieldNumber = 3,
    kPromptDurationFieldNumber = 4,
    kDockIdFieldNumber = 1,
  };
  // string docked_waypoint_id = 2;
  void clear_docked_waypoint_id();
  const std::string& docked_waypoint_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_docked_waypoint_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_docked_waypoint_id();
  PROTOBUF_NODISCARD std::string* release_docked_waypoint_id();
  void set_allocated_docked_waypoint_id(std::string* docked_waypoint_id);
  private:
  const std::string& _internal_docked_waypoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_docked_waypoint_id(const std::string& value);
  std::string* _internal_mutable_docked_waypoint_id();
  public:

  // .bosdyn.api.autowalk.Target target_prep_pose = 3;
  bool has_target_prep_pose() const;
  private:
  bool _internal_has_target_prep_pose() const;
  public:
  void clear_target_prep_pose();
  const ::bosdyn::api::autowalk::Target& target_prep_pose() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::Target* release_target_prep_pose();
  ::bosdyn::api::autowalk::Target* mutable_target_prep_pose();
  void set_allocated_target_prep_pose(::bosdyn::api::autowalk::Target* target_prep_pose);
  private:
  const ::bosdyn::api::autowalk::Target& _internal_target_prep_pose() const;
  ::bosdyn::api::autowalk::Target* _internal_mutable_target_prep_pose();
  public:
  void unsafe_arena_set_allocated_target_prep_pose(
      ::bosdyn::api::autowalk::Target* target_prep_pose);
  ::bosdyn::api::autowalk::Target* unsafe_arena_release_target_prep_pose();

  // .google.protobuf.Duration prompt_duration = 4;
  bool has_prompt_duration() const;
  private:
  bool _internal_has_prompt_duration() const;
  public:
  void clear_prompt_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& prompt_duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_prompt_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_prompt_duration();
  void set_allocated_prompt_duration(::PROTOBUF_NAMESPACE_ID::Duration* prompt_duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_prompt_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_prompt_duration();
  public:
  void unsafe_arena_set_allocated_prompt_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* prompt_duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_prompt_duration();

  // uint32 dock_id = 1;
  void clear_dock_id();
  uint32_t dock_id() const;
  void set_dock_id(uint32_t value);
  private:
  uint32_t _internal_dock_id() const;
  void _internal_set_dock_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.Dock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr docked_waypoint_id_;
    ::bosdyn::api::autowalk::Target* target_prep_pose_;
    ::PROTOBUF_NAMESPACE_ID::Duration* prompt_duration_;
    uint32_t dock_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class PlaybackMode_Once final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.PlaybackMode.Once) */ {
 public:
  inline PlaybackMode_Once() : PlaybackMode_Once(nullptr) {}
  ~PlaybackMode_Once() override;
  explicit PROTOBUF_CONSTEXPR PlaybackMode_Once(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlaybackMode_Once(const PlaybackMode_Once& from);
  PlaybackMode_Once(PlaybackMode_Once&& from) noexcept
    : PlaybackMode_Once() {
    *this = ::std::move(from);
  }

  inline PlaybackMode_Once& operator=(const PlaybackMode_Once& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlaybackMode_Once& operator=(PlaybackMode_Once&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlaybackMode_Once& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlaybackMode_Once* internal_default_instance() {
    return reinterpret_cast<const PlaybackMode_Once*>(
               &_PlaybackMode_Once_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PlaybackMode_Once& a, PlaybackMode_Once& b) {
    a.Swap(&b);
  }
  inline void Swap(PlaybackMode_Once* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlaybackMode_Once* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlaybackMode_Once* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlaybackMode_Once>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlaybackMode_Once& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlaybackMode_Once& from) {
    PlaybackMode_Once::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlaybackMode_Once* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.PlaybackMode.Once";
  }
  protected:
  explicit PlaybackMode_Once(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkipDockingAfterCompletionFieldNumber = 1,
  };
  // bool skip_docking_after_completion = 1;
  void clear_skip_docking_after_completion();
  bool skip_docking_after_completion() const;
  void set_skip_docking_after_completion(bool value);
  private:
  bool _internal_skip_docking_after_completion() const;
  void _internal_set_skip_docking_after_completion(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.PlaybackMode.Once)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool skip_docking_after_completion_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class PlaybackMode_Periodic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.PlaybackMode.Periodic) */ {
 public:
  inline PlaybackMode_Periodic() : PlaybackMode_Periodic(nullptr) {}
  ~PlaybackMode_Periodic() override;
  explicit PROTOBUF_CONSTEXPR PlaybackMode_Periodic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlaybackMode_Periodic(const PlaybackMode_Periodic& from);
  PlaybackMode_Periodic(PlaybackMode_Periodic&& from) noexcept
    : PlaybackMode_Periodic() {
    *this = ::std::move(from);
  }

  inline PlaybackMode_Periodic& operator=(const PlaybackMode_Periodic& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlaybackMode_Periodic& operator=(PlaybackMode_Periodic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlaybackMode_Periodic& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlaybackMode_Periodic* internal_default_instance() {
    return reinterpret_cast<const PlaybackMode_Periodic*>(
               &_PlaybackMode_Periodic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PlaybackMode_Periodic& a, PlaybackMode_Periodic& b) {
    a.Swap(&b);
  }
  inline void Swap(PlaybackMode_Periodic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlaybackMode_Periodic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlaybackMode_Periodic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlaybackMode_Periodic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlaybackMode_Periodic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlaybackMode_Periodic& from) {
    PlaybackMode_Periodic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlaybackMode_Periodic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.PlaybackMode.Periodic";
  }
  protected:
  explicit PlaybackMode_Periodic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntervalFieldNumber = 1,
    kRepetitionsFieldNumber = 2,
  };
  // .google.protobuf.Duration interval = 1;
  bool has_interval() const;
  private:
  bool _internal_has_interval() const;
  public:
  void clear_interval();
  const ::PROTOBUF_NAMESPACE_ID::Duration& interval() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_interval();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_interval();
  void set_allocated_interval(::PROTOBUF_NAMESPACE_ID::Duration* interval);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_interval() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_interval();
  public:
  void unsafe_arena_set_allocated_interval(
      ::PROTOBUF_NAMESPACE_ID::Duration* interval);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_interval();

  // int32 repetitions = 2;
  void clear_repetitions();
  int32_t repetitions() const;
  void set_repetitions(int32_t value);
  private:
  int32_t _internal_repetitions() const;
  void _internal_set_repetitions(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.PlaybackMode.Periodic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Duration* interval_;
    int32_t repetitions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class PlaybackMode_Continuous final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.PlaybackMode.Continuous) */ {
 public:
  inline PlaybackMode_Continuous() : PlaybackMode_Continuous(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PlaybackMode_Continuous(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlaybackMode_Continuous(const PlaybackMode_Continuous& from);
  PlaybackMode_Continuous(PlaybackMode_Continuous&& from) noexcept
    : PlaybackMode_Continuous() {
    *this = ::std::move(from);
  }

  inline PlaybackMode_Continuous& operator=(const PlaybackMode_Continuous& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlaybackMode_Continuous& operator=(PlaybackMode_Continuous&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlaybackMode_Continuous& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlaybackMode_Continuous* internal_default_instance() {
    return reinterpret_cast<const PlaybackMode_Continuous*>(
               &_PlaybackMode_Continuous_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PlaybackMode_Continuous& a, PlaybackMode_Continuous& b) {
    a.Swap(&b);
  }
  inline void Swap(PlaybackMode_Continuous* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlaybackMode_Continuous* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlaybackMode_Continuous* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlaybackMode_Continuous>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PlaybackMode_Continuous& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PlaybackMode_Continuous& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.PlaybackMode.Continuous";
  }
  protected:
  explicit PlaybackMode_Continuous(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.PlaybackMode.Continuous)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class PlaybackMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.PlaybackMode) */ {
 public:
  inline PlaybackMode() : PlaybackMode(nullptr) {}
  ~PlaybackMode() override;
  explicit PROTOBUF_CONSTEXPR PlaybackMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlaybackMode(const PlaybackMode& from);
  PlaybackMode(PlaybackMode&& from) noexcept
    : PlaybackMode() {
    *this = ::std::move(from);
  }

  inline PlaybackMode& operator=(const PlaybackMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlaybackMode& operator=(PlaybackMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlaybackMode& default_instance() {
    return *internal_default_instance();
  }
  enum ModeCase {
    kOnce = 2,
    kPeriodic = 3,
    kContinuous = 4,
    MODE_NOT_SET = 0,
  };

  static inline const PlaybackMode* internal_default_instance() {
    return reinterpret_cast<const PlaybackMode*>(
               &_PlaybackMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PlaybackMode& a, PlaybackMode& b) {
    a.Swap(&b);
  }
  inline void Swap(PlaybackMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlaybackMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlaybackMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlaybackMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlaybackMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlaybackMode& from) {
    PlaybackMode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlaybackMode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.PlaybackMode";
  }
  protected:
  explicit PlaybackMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PlaybackMode_Once Once;
  typedef PlaybackMode_Periodic Periodic;
  typedef PlaybackMode_Continuous Continuous;

  // accessors -------------------------------------------------------

  enum : int {
    kOnceFieldNumber = 2,
    kPeriodicFieldNumber = 3,
    kContinuousFieldNumber = 4,
  };
  // .bosdyn.api.autowalk.PlaybackMode.Once once = 2;
  bool has_once() const;
  private:
  bool _internal_has_once() const;
  public:
  void clear_once();
  const ::bosdyn::api::autowalk::PlaybackMode_Once& once() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::PlaybackMode_Once* release_once();
  ::bosdyn::api::autowalk::PlaybackMode_Once* mutable_once();
  void set_allocated_once(::bosdyn::api::autowalk::PlaybackMode_Once* once);
  private:
  const ::bosdyn::api::autowalk::PlaybackMode_Once& _internal_once() const;
  ::bosdyn::api::autowalk::PlaybackMode_Once* _internal_mutable_once();
  public:
  void unsafe_arena_set_allocated_once(
      ::bosdyn::api::autowalk::PlaybackMode_Once* once);
  ::bosdyn::api::autowalk::PlaybackMode_Once* unsafe_arena_release_once();

  // .bosdyn.api.autowalk.PlaybackMode.Periodic periodic = 3;
  bool has_periodic() const;
  private:
  bool _internal_has_periodic() const;
  public:
  void clear_periodic();
  const ::bosdyn::api::autowalk::PlaybackMode_Periodic& periodic() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::PlaybackMode_Periodic* release_periodic();
  ::bosdyn::api::autowalk::PlaybackMode_Periodic* mutable_periodic();
  void set_allocated_periodic(::bosdyn::api::autowalk::PlaybackMode_Periodic* periodic);
  private:
  const ::bosdyn::api::autowalk::PlaybackMode_Periodic& _internal_periodic() const;
  ::bosdyn::api::autowalk::PlaybackMode_Periodic* _internal_mutable_periodic();
  public:
  void unsafe_arena_set_allocated_periodic(
      ::bosdyn::api::autowalk::PlaybackMode_Periodic* periodic);
  ::bosdyn::api::autowalk::PlaybackMode_Periodic* unsafe_arena_release_periodic();

  // .bosdyn.api.autowalk.PlaybackMode.Continuous continuous = 4;
  bool has_continuous() const;
  private:
  bool _internal_has_continuous() const;
  public:
  void clear_continuous();
  const ::bosdyn::api::autowalk::PlaybackMode_Continuous& continuous() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::PlaybackMode_Continuous* release_continuous();
  ::bosdyn::api::autowalk::PlaybackMode_Continuous* mutable_continuous();
  void set_allocated_continuous(::bosdyn::api::autowalk::PlaybackMode_Continuous* continuous);
  private:
  const ::bosdyn::api::autowalk::PlaybackMode_Continuous& _internal_continuous() const;
  ::bosdyn::api::autowalk::PlaybackMode_Continuous* _internal_mutable_continuous();
  public:
  void unsafe_arena_set_allocated_continuous(
      ::bosdyn::api::autowalk::PlaybackMode_Continuous* continuous);
  ::bosdyn::api::autowalk::PlaybackMode_Continuous* unsafe_arena_release_continuous();

  void clear_mode();
  ModeCase mode_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.PlaybackMode)
 private:
  class _Internal;
  void set_has_once();
  void set_has_periodic();
  void set_has_continuous();

  inline bool has_mode() const;
  inline void clear_has_mode();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ModeUnion {
      constexpr ModeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::autowalk::PlaybackMode_Once* once_;
      ::bosdyn::api::autowalk::PlaybackMode_Periodic* periodic_;
      ::bosdyn::api::autowalk::PlaybackMode_Continuous* continuous_;
    } mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class Element final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.Element) */ {
 public:
  inline Element() : Element(nullptr) {}
  ~Element() override;
  explicit PROTOBUF_CONSTEXPR Element(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Element(const Element& from);
  Element(Element&& from) noexcept
    : Element() {
    *this = ::std::move(from);
  }

  inline Element& operator=(const Element& from) {
    CopyFrom(from);
    return *this;
  }
  inline Element& operator=(Element&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Element& default_instance() {
    return *internal_default_instance();
  }
  static inline const Element* internal_default_instance() {
    return reinterpret_cast<const Element*>(
               &_Element_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Element& a, Element& b) {
    a.Swap(&b);
  }
  inline void Swap(Element* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Element* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Element* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Element>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Element& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Element& from) {
    Element::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Element* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.Element";
  }
  protected:
  explicit Element(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTargetFieldNumber = 2,
    kTargetFailureBehaviorFieldNumber = 3,
    kActionFieldNumber = 4,
    kActionWrapperFieldNumber = 5,
    kActionFailureBehaviorFieldNumber = 6,
    kBatteryMonitorFieldNumber = 8,
    kActionDurationFieldNumber = 9,
    kIsSkippedFieldNumber = 7,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .bosdyn.api.autowalk.Target target = 2;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::bosdyn::api::autowalk::Target& target() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::Target* release_target();
  ::bosdyn::api::autowalk::Target* mutable_target();
  void set_allocated_target(::bosdyn::api::autowalk::Target* target);
  private:
  const ::bosdyn::api::autowalk::Target& _internal_target() const;
  ::bosdyn::api::autowalk::Target* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::bosdyn::api::autowalk::Target* target);
  ::bosdyn::api::autowalk::Target* unsafe_arena_release_target();

  // .bosdyn.api.autowalk.FailureBehavior target_failure_behavior = 3;
  bool has_target_failure_behavior() const;
  private:
  bool _internal_has_target_failure_behavior() const;
  public:
  void clear_target_failure_behavior();
  const ::bosdyn::api::autowalk::FailureBehavior& target_failure_behavior() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::FailureBehavior* release_target_failure_behavior();
  ::bosdyn::api::autowalk::FailureBehavior* mutable_target_failure_behavior();
  void set_allocated_target_failure_behavior(::bosdyn::api::autowalk::FailureBehavior* target_failure_behavior);
  private:
  const ::bosdyn::api::autowalk::FailureBehavior& _internal_target_failure_behavior() const;
  ::bosdyn::api::autowalk::FailureBehavior* _internal_mutable_target_failure_behavior();
  public:
  void unsafe_arena_set_allocated_target_failure_behavior(
      ::bosdyn::api::autowalk::FailureBehavior* target_failure_behavior);
  ::bosdyn::api::autowalk::FailureBehavior* unsafe_arena_release_target_failure_behavior();

  // .bosdyn.api.autowalk.Action action = 4;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::bosdyn::api::autowalk::Action& action() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::Action* release_action();
  ::bosdyn::api::autowalk::Action* mutable_action();
  void set_allocated_action(::bosdyn::api::autowalk::Action* action);
  private:
  const ::bosdyn::api::autowalk::Action& _internal_action() const;
  ::bosdyn::api::autowalk::Action* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::bosdyn::api::autowalk::Action* action);
  ::bosdyn::api::autowalk::Action* unsafe_arena_release_action();

  // .bosdyn.api.autowalk.ActionWrapper action_wrapper = 5;
  bool has_action_wrapper() const;
  private:
  bool _internal_has_action_wrapper() const;
  public:
  void clear_action_wrapper();
  const ::bosdyn::api::autowalk::ActionWrapper& action_wrapper() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::ActionWrapper* release_action_wrapper();
  ::bosdyn::api::autowalk::ActionWrapper* mutable_action_wrapper();
  void set_allocated_action_wrapper(::bosdyn::api::autowalk::ActionWrapper* action_wrapper);
  private:
  const ::bosdyn::api::autowalk::ActionWrapper& _internal_action_wrapper() const;
  ::bosdyn::api::autowalk::ActionWrapper* _internal_mutable_action_wrapper();
  public:
  void unsafe_arena_set_allocated_action_wrapper(
      ::bosdyn::api::autowalk::ActionWrapper* action_wrapper);
  ::bosdyn::api::autowalk::ActionWrapper* unsafe_arena_release_action_wrapper();

  // .bosdyn.api.autowalk.FailureBehavior action_failure_behavior = 6;
  bool has_action_failure_behavior() const;
  private:
  bool _internal_has_action_failure_behavior() const;
  public:
  void clear_action_failure_behavior();
  const ::bosdyn::api::autowalk::FailureBehavior& action_failure_behavior() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::FailureBehavior* release_action_failure_behavior();
  ::bosdyn::api::autowalk::FailureBehavior* mutable_action_failure_behavior();
  void set_allocated_action_failure_behavior(::bosdyn::api::autowalk::FailureBehavior* action_failure_behavior);
  private:
  const ::bosdyn::api::autowalk::FailureBehavior& _internal_action_failure_behavior() const;
  ::bosdyn::api::autowalk::FailureBehavior* _internal_mutable_action_failure_behavior();
  public:
  void unsafe_arena_set_allocated_action_failure_behavior(
      ::bosdyn::api::autowalk::FailureBehavior* action_failure_behavior);
  ::bosdyn::api::autowalk::FailureBehavior* unsafe_arena_release_action_failure_behavior();

  // .bosdyn.api.autowalk.BatteryMonitor battery_monitor = 8;
  bool has_battery_monitor() const;
  private:
  bool _internal_has_battery_monitor() const;
  public:
  void clear_battery_monitor();
  const ::bosdyn::api::autowalk::BatteryMonitor& battery_monitor() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::BatteryMonitor* release_battery_monitor();
  ::bosdyn::api::autowalk::BatteryMonitor* mutable_battery_monitor();
  void set_allocated_battery_monitor(::bosdyn::api::autowalk::BatteryMonitor* battery_monitor);
  private:
  const ::bosdyn::api::autowalk::BatteryMonitor& _internal_battery_monitor() const;
  ::bosdyn::api::autowalk::BatteryMonitor* _internal_mutable_battery_monitor();
  public:
  void unsafe_arena_set_allocated_battery_monitor(
      ::bosdyn::api::autowalk::BatteryMonitor* battery_monitor);
  ::bosdyn::api::autowalk::BatteryMonitor* unsafe_arena_release_battery_monitor();

  // .google.protobuf.Duration action_duration = 9;
  bool has_action_duration() const;
  private:
  bool _internal_has_action_duration() const;
  public:
  void clear_action_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& action_duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_action_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_action_duration();
  void set_allocated_action_duration(::PROTOBUF_NAMESPACE_ID::Duration* action_duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_action_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_action_duration();
  public:
  void unsafe_arena_set_allocated_action_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* action_duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_action_duration();

  // bool is_skipped = 7;
  void clear_is_skipped();
  bool is_skipped() const;
  void set_is_skipped(bool value);
  private:
  bool _internal_is_skipped() const;
  void _internal_set_is_skipped(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.Element)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::bosdyn::api::autowalk::Target* target_;
    ::bosdyn::api::autowalk::FailureBehavior* target_failure_behavior_;
    ::bosdyn::api::autowalk::Action* action_;
    ::bosdyn::api::autowalk::ActionWrapper* action_wrapper_;
    ::bosdyn::api::autowalk::FailureBehavior* action_failure_behavior_;
    ::bosdyn::api::autowalk::BatteryMonitor* battery_monitor_;
    ::PROTOBUF_NAMESPACE_ID::Duration* action_duration_;
    bool is_skipped_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class Target_Relocalize final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.Target.Relocalize) */ {
 public:
  inline Target_Relocalize() : Target_Relocalize(nullptr) {}
  ~Target_Relocalize() override;
  explicit PROTOBUF_CONSTEXPR Target_Relocalize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Target_Relocalize(const Target_Relocalize& from);
  Target_Relocalize(Target_Relocalize&& from) noexcept
    : Target_Relocalize() {
    *this = ::std::move(from);
  }

  inline Target_Relocalize& operator=(const Target_Relocalize& from) {
    CopyFrom(from);
    return *this;
  }
  inline Target_Relocalize& operator=(Target_Relocalize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Target_Relocalize& default_instance() {
    return *internal_default_instance();
  }
  static inline const Target_Relocalize* internal_default_instance() {
    return reinterpret_cast<const Target_Relocalize*>(
               &_Target_Relocalize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Target_Relocalize& a, Target_Relocalize& b) {
    a.Swap(&b);
  }
  inline void Swap(Target_Relocalize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Target_Relocalize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Target_Relocalize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Target_Relocalize>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Target_Relocalize& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Target_Relocalize& from) {
    Target_Relocalize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Target_Relocalize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.Target.Relocalize";
  }
  protected:
  explicit Target_Relocalize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetLocalizationRequestFieldNumber = 1,
  };
  // .bosdyn.api.graph_nav.SetLocalizationRequest set_localization_request = 1;
  bool has_set_localization_request() const;
  private:
  bool _internal_has_set_localization_request() const;
  public:
  void clear_set_localization_request();
  const ::bosdyn::api::graph_nav::SetLocalizationRequest& set_localization_request() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::SetLocalizationRequest* release_set_localization_request();
  ::bosdyn::api::graph_nav::SetLocalizationRequest* mutable_set_localization_request();
  void set_allocated_set_localization_request(::bosdyn::api::graph_nav::SetLocalizationRequest* set_localization_request);
  private:
  const ::bosdyn::api::graph_nav::SetLocalizationRequest& _internal_set_localization_request() const;
  ::bosdyn::api::graph_nav::SetLocalizationRequest* _internal_mutable_set_localization_request();
  public:
  void unsafe_arena_set_allocated_set_localization_request(
      ::bosdyn::api::graph_nav::SetLocalizationRequest* set_localization_request);
  ::bosdyn::api::graph_nav::SetLocalizationRequest* unsafe_arena_release_set_localization_request();

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.Target.Relocalize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::graph_nav::SetLocalizationRequest* set_localization_request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class Target_NavigateTo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.Target.NavigateTo) */ {
 public:
  inline Target_NavigateTo() : Target_NavigateTo(nullptr) {}
  ~Target_NavigateTo() override;
  explicit PROTOBUF_CONSTEXPR Target_NavigateTo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Target_NavigateTo(const Target_NavigateTo& from);
  Target_NavigateTo(Target_NavigateTo&& from) noexcept
    : Target_NavigateTo() {
    *this = ::std::move(from);
  }

  inline Target_NavigateTo& operator=(const Target_NavigateTo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Target_NavigateTo& operator=(Target_NavigateTo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Target_NavigateTo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Target_NavigateTo* internal_default_instance() {
    return reinterpret_cast<const Target_NavigateTo*>(
               &_Target_NavigateTo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Target_NavigateTo& a, Target_NavigateTo& b) {
    a.Swap(&b);
  }
  inline void Swap(Target_NavigateTo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Target_NavigateTo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Target_NavigateTo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Target_NavigateTo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Target_NavigateTo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Target_NavigateTo& from) {
    Target_NavigateTo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Target_NavigateTo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.Target.NavigateTo";
  }
  protected:
  explicit Target_NavigateTo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationWaypointIdFieldNumber = 1,
    kTravelParamsFieldNumber = 3,
  };
  // string destination_waypoint_id = 1;
  void clear_destination_waypoint_id();
  const std::string& destination_waypoint_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination_waypoint_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination_waypoint_id();
  PROTOBUF_NODISCARD std::string* release_destination_waypoint_id();
  void set_allocated_destination_waypoint_id(std::string* destination_waypoint_id);
  private:
  const std::string& _internal_destination_waypoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_waypoint_id(const std::string& value);
  std::string* _internal_mutable_destination_waypoint_id();
  public:

  // .bosdyn.api.graph_nav.TravelParams travel_params = 3;
  bool has_travel_params() const;
  private:
  bool _internal_has_travel_params() const;
  public:
  void clear_travel_params();
  const ::bosdyn::api::graph_nav::TravelParams& travel_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::TravelParams* release_travel_params();
  ::bosdyn::api::graph_nav::TravelParams* mutable_travel_params();
  void set_allocated_travel_params(::bosdyn::api::graph_nav::TravelParams* travel_params);
  private:
  const ::bosdyn::api::graph_nav::TravelParams& _internal_travel_params() const;
  ::bosdyn::api::graph_nav::TravelParams* _internal_mutable_travel_params();
  public:
  void unsafe_arena_set_allocated_travel_params(
      ::bosdyn::api::graph_nav::TravelParams* travel_params);
  ::bosdyn::api::graph_nav::TravelParams* unsafe_arena_release_travel_params();

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.Target.NavigateTo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_waypoint_id_;
    ::bosdyn::api::graph_nav::TravelParams* travel_params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class Target_NavigateRoute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.Target.NavigateRoute) */ {
 public:
  inline Target_NavigateRoute() : Target_NavigateRoute(nullptr) {}
  ~Target_NavigateRoute() override;
  explicit PROTOBUF_CONSTEXPR Target_NavigateRoute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Target_NavigateRoute(const Target_NavigateRoute& from);
  Target_NavigateRoute(Target_NavigateRoute&& from) noexcept
    : Target_NavigateRoute() {
    *this = ::std::move(from);
  }

  inline Target_NavigateRoute& operator=(const Target_NavigateRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline Target_NavigateRoute& operator=(Target_NavigateRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Target_NavigateRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const Target_NavigateRoute* internal_default_instance() {
    return reinterpret_cast<const Target_NavigateRoute*>(
               &_Target_NavigateRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Target_NavigateRoute& a, Target_NavigateRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(Target_NavigateRoute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Target_NavigateRoute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Target_NavigateRoute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Target_NavigateRoute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Target_NavigateRoute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Target_NavigateRoute& from) {
    Target_NavigateRoute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Target_NavigateRoute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.Target.NavigateRoute";
  }
  protected:
  explicit Target_NavigateRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRouteFieldNumber = 1,
    kTravelParamsFieldNumber = 2,
  };
  // .bosdyn.api.graph_nav.Route route = 1;
  bool has_route() const;
  private:
  bool _internal_has_route() const;
  public:
  void clear_route();
  const ::bosdyn::api::graph_nav::Route& route() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::Route* release_route();
  ::bosdyn::api::graph_nav::Route* mutable_route();
  void set_allocated_route(::bosdyn::api::graph_nav::Route* route);
  private:
  const ::bosdyn::api::graph_nav::Route& _internal_route() const;
  ::bosdyn::api::graph_nav::Route* _internal_mutable_route();
  public:
  void unsafe_arena_set_allocated_route(
      ::bosdyn::api::graph_nav::Route* route);
  ::bosdyn::api::graph_nav::Route* unsafe_arena_release_route();

  // .bosdyn.api.graph_nav.TravelParams travel_params = 2;
  bool has_travel_params() const;
  private:
  bool _internal_has_travel_params() const;
  public:
  void clear_travel_params();
  const ::bosdyn::api::graph_nav::TravelParams& travel_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::TravelParams* release_travel_params();
  ::bosdyn::api::graph_nav::TravelParams* mutable_travel_params();
  void set_allocated_travel_params(::bosdyn::api::graph_nav::TravelParams* travel_params);
  private:
  const ::bosdyn::api::graph_nav::TravelParams& _internal_travel_params() const;
  ::bosdyn::api::graph_nav::TravelParams* _internal_mutable_travel_params();
  public:
  void unsafe_arena_set_allocated_travel_params(
      ::bosdyn::api::graph_nav::TravelParams* travel_params);
  ::bosdyn::api::graph_nav::TravelParams* unsafe_arena_release_travel_params();

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.Target.NavigateRoute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::graph_nav::Route* route_;
    ::bosdyn::api::graph_nav::TravelParams* travel_params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class Target final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.Target) */ {
 public:
  inline Target() : Target(nullptr) {}
  ~Target() override;
  explicit PROTOBUF_CONSTEXPR Target(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Target(const Target& from);
  Target(Target&& from) noexcept
    : Target() {
    *this = ::std::move(from);
  }

  inline Target& operator=(const Target& from) {
    CopyFrom(from);
    return *this;
  }
  inline Target& operator=(Target&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Target& default_instance() {
    return *internal_default_instance();
  }
  enum TargetCase {
    kNavigateTo = 1,
    kNavigateRoute = 2,
    TARGET_NOT_SET = 0,
  };

  static inline const Target* internal_default_instance() {
    return reinterpret_cast<const Target*>(
               &_Target_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Target& a, Target& b) {
    a.Swap(&b);
  }
  inline void Swap(Target* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Target* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Target* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Target>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Target& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Target& from) {
    Target::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Target* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.Target";
  }
  protected:
  explicit Target(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Target_Relocalize Relocalize;
  typedef Target_NavigateTo NavigateTo;
  typedef Target_NavigateRoute NavigateRoute;

  // accessors -------------------------------------------------------

  enum : int {
    kRelocalizeFieldNumber = 3,
    kNavigateToFieldNumber = 1,
    kNavigateRouteFieldNumber = 2,
  };
  // .bosdyn.api.autowalk.Target.Relocalize relocalize = 3;
  bool has_relocalize() const;
  private:
  bool _internal_has_relocalize() const;
  public:
  void clear_relocalize();
  const ::bosdyn::api::autowalk::Target_Relocalize& relocalize() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::Target_Relocalize* release_relocalize();
  ::bosdyn::api::autowalk::Target_Relocalize* mutable_relocalize();
  void set_allocated_relocalize(::bosdyn::api::autowalk::Target_Relocalize* relocalize);
  private:
  const ::bosdyn::api::autowalk::Target_Relocalize& _internal_relocalize() const;
  ::bosdyn::api::autowalk::Target_Relocalize* _internal_mutable_relocalize();
  public:
  void unsafe_arena_set_allocated_relocalize(
      ::bosdyn::api::autowalk::Target_Relocalize* relocalize);
  ::bosdyn::api::autowalk::Target_Relocalize* unsafe_arena_release_relocalize();

  // .bosdyn.api.autowalk.Target.NavigateTo navigate_to = 1;
  bool has_navigate_to() const;
  private:
  bool _internal_has_navigate_to() const;
  public:
  void clear_navigate_to();
  const ::bosdyn::api::autowalk::Target_NavigateTo& navigate_to() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::Target_NavigateTo* release_navigate_to();
  ::bosdyn::api::autowalk::Target_NavigateTo* mutable_navigate_to();
  void set_allocated_navigate_to(::bosdyn::api::autowalk::Target_NavigateTo* navigate_to);
  private:
  const ::bosdyn::api::autowalk::Target_NavigateTo& _internal_navigate_to() const;
  ::bosdyn::api::autowalk::Target_NavigateTo* _internal_mutable_navigate_to();
  public:
  void unsafe_arena_set_allocated_navigate_to(
      ::bosdyn::api::autowalk::Target_NavigateTo* navigate_to);
  ::bosdyn::api::autowalk::Target_NavigateTo* unsafe_arena_release_navigate_to();

  // .bosdyn.api.autowalk.Target.NavigateRoute navigate_route = 2;
  bool has_navigate_route() const;
  private:
  bool _internal_has_navigate_route() const;
  public:
  void clear_navigate_route();
  const ::bosdyn::api::autowalk::Target_NavigateRoute& navigate_route() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::Target_NavigateRoute* release_navigate_route();
  ::bosdyn::api::autowalk::Target_NavigateRoute* mutable_navigate_route();
  void set_allocated_navigate_route(::bosdyn::api::autowalk::Target_NavigateRoute* navigate_route);
  private:
  const ::bosdyn::api::autowalk::Target_NavigateRoute& _internal_navigate_route() const;
  ::bosdyn::api::autowalk::Target_NavigateRoute* _internal_mutable_navigate_route();
  public:
  void unsafe_arena_set_allocated_navigate_route(
      ::bosdyn::api::autowalk::Target_NavigateRoute* navigate_route);
  ::bosdyn::api::autowalk::Target_NavigateRoute* unsafe_arena_release_navigate_route();

  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.Target)
 private:
  class _Internal;
  void set_has_navigate_to();
  void set_has_navigate_route();

  inline bool has_target() const;
  inline void clear_has_target();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::autowalk::Target_Relocalize* relocalize_;
    union TargetUnion {
      constexpr TargetUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::autowalk::Target_NavigateTo* navigate_to_;
      ::bosdyn::api::autowalk::Target_NavigateRoute* navigate_route_;
    } target_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class Action_Sleep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.Action.Sleep) */ {
 public:
  inline Action_Sleep() : Action_Sleep(nullptr) {}
  ~Action_Sleep() override;
  explicit PROTOBUF_CONSTEXPR Action_Sleep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Action_Sleep(const Action_Sleep& from);
  Action_Sleep(Action_Sleep&& from) noexcept
    : Action_Sleep() {
    *this = ::std::move(from);
  }

  inline Action_Sleep& operator=(const Action_Sleep& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action_Sleep& operator=(Action_Sleep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Action_Sleep& default_instance() {
    return *internal_default_instance();
  }
  static inline const Action_Sleep* internal_default_instance() {
    return reinterpret_cast<const Action_Sleep*>(
               &_Action_Sleep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Action_Sleep& a, Action_Sleep& b) {
    a.Swap(&b);
  }
  inline void Swap(Action_Sleep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action_Sleep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Action_Sleep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Action_Sleep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Action_Sleep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Action_Sleep& from) {
    Action_Sleep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action_Sleep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.Action.Sleep";
  }
  protected:
  explicit Action_Sleep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDurationFieldNumber = 2,
  };
  // .google.protobuf.Duration duration = 2;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_duration();
  void set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_duration();

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.Action.Sleep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Duration* duration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class Action_DataAcquisition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.Action.DataAcquisition) */ {
 public:
  inline Action_DataAcquisition() : Action_DataAcquisition(nullptr) {}
  ~Action_DataAcquisition() override;
  explicit PROTOBUF_CONSTEXPR Action_DataAcquisition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Action_DataAcquisition(const Action_DataAcquisition& from);
  Action_DataAcquisition(Action_DataAcquisition&& from) noexcept
    : Action_DataAcquisition() {
    *this = ::std::move(from);
  }

  inline Action_DataAcquisition& operator=(const Action_DataAcquisition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action_DataAcquisition& operator=(Action_DataAcquisition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Action_DataAcquisition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Action_DataAcquisition* internal_default_instance() {
    return reinterpret_cast<const Action_DataAcquisition*>(
               &_Action_DataAcquisition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Action_DataAcquisition& a, Action_DataAcquisition& b) {
    a.Swap(&b);
  }
  inline void Swap(Action_DataAcquisition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action_DataAcquisition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Action_DataAcquisition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Action_DataAcquisition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Action_DataAcquisition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Action_DataAcquisition& from) {
    Action_DataAcquisition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action_DataAcquisition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.Action.DataAcquisition";
  }
  protected:
  explicit Action_DataAcquisition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcquireDataRequestFieldNumber = 1,
    kCompletionBehaviorFieldNumber = 2,
  };
  // .bosdyn.api.AcquireDataRequest acquire_data_request = 1;
  bool has_acquire_data_request() const;
  private:
  bool _internal_has_acquire_data_request() const;
  public:
  void clear_acquire_data_request();
  const ::bosdyn::api::AcquireDataRequest& acquire_data_request() const;
  PROTOBUF_NODISCARD ::bosdyn::api::AcquireDataRequest* release_acquire_data_request();
  ::bosdyn::api::AcquireDataRequest* mutable_acquire_data_request();
  void set_allocated_acquire_data_request(::bosdyn::api::AcquireDataRequest* acquire_data_request);
  private:
  const ::bosdyn::api::AcquireDataRequest& _internal_acquire_data_request() const;
  ::bosdyn::api::AcquireDataRequest* _internal_mutable_acquire_data_request();
  public:
  void unsafe_arena_set_allocated_acquire_data_request(
      ::bosdyn::api::AcquireDataRequest* acquire_data_request);
  ::bosdyn::api::AcquireDataRequest* unsafe_arena_release_acquire_data_request();

  // .bosdyn.api.mission.DataAcquisition.CompletionBehavior completion_behavior = 2;
  void clear_completion_behavior();
  ::bosdyn::api::mission::DataAcquisition_CompletionBehavior completion_behavior() const;
  void set_completion_behavior(::bosdyn::api::mission::DataAcquisition_CompletionBehavior value);
  private:
  ::bosdyn::api::mission::DataAcquisition_CompletionBehavior _internal_completion_behavior() const;
  void _internal_set_completion_behavior(::bosdyn::api::mission::DataAcquisition_CompletionBehavior value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.Action.DataAcquisition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::AcquireDataRequest* acquire_data_request_;
    int completion_behavior_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class Action_RemoteGrpc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.Action.RemoteGrpc) */ {
 public:
  inline Action_RemoteGrpc() : Action_RemoteGrpc(nullptr) {}
  ~Action_RemoteGrpc() override;
  explicit PROTOBUF_CONSTEXPR Action_RemoteGrpc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Action_RemoteGrpc(const Action_RemoteGrpc& from);
  Action_RemoteGrpc(Action_RemoteGrpc&& from) noexcept
    : Action_RemoteGrpc() {
    *this = ::std::move(from);
  }

  inline Action_RemoteGrpc& operator=(const Action_RemoteGrpc& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action_RemoteGrpc& operator=(Action_RemoteGrpc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Action_RemoteGrpc& default_instance() {
    return *internal_default_instance();
  }
  static inline const Action_RemoteGrpc* internal_default_instance() {
    return reinterpret_cast<const Action_RemoteGrpc*>(
               &_Action_RemoteGrpc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Action_RemoteGrpc& a, Action_RemoteGrpc& b) {
    a.Swap(&b);
  }
  inline void Swap(Action_RemoteGrpc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action_RemoteGrpc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Action_RemoteGrpc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Action_RemoteGrpc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Action_RemoteGrpc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Action_RemoteGrpc& from) {
    Action_RemoteGrpc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action_RemoteGrpc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.Action.RemoteGrpc";
  }
  protected:
  explicit Action_RemoteGrpc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaseResourcesFieldNumber = 3,
    kInputsFieldNumber = 4,
    kServiceNameFieldNumber = 1,
    kRpcTimeoutFieldNumber = 2,
  };
  // repeated string lease_resources = 3;
  int lease_resources_size() const;
  private:
  int _internal_lease_resources_size() const;
  public:
  void clear_lease_resources();
  const std::string& lease_resources(int index) const;
  std::string* mutable_lease_resources(int index);
  void set_lease_resources(int index, const std::string& value);
  void set_lease_resources(int index, std::string&& value);
  void set_lease_resources(int index, const char* value);
  void set_lease_resources(int index, const char* value, size_t size);
  std::string* add_lease_resources();
  void add_lease_resources(const std::string& value);
  void add_lease_resources(std::string&& value);
  void add_lease_resources(const char* value);
  void add_lease_resources(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& lease_resources() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_lease_resources();
  private:
  const std::string& _internal_lease_resources(int index) const;
  std::string* _internal_add_lease_resources();
  public:

  // repeated .bosdyn.api.mission.KeyValue inputs = 4;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::bosdyn::api::mission::KeyValue* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
      mutable_inputs();
  private:
  const ::bosdyn::api::mission::KeyValue& _internal_inputs(int index) const;
  ::bosdyn::api::mission::KeyValue* _internal_add_inputs();
  public:
  const ::bosdyn::api::mission::KeyValue& inputs(int index) const;
  ::bosdyn::api::mission::KeyValue* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
      inputs() const;

  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // .google.protobuf.Duration rpc_timeout = 2;
  bool has_rpc_timeout() const;
  private:
  bool _internal_has_rpc_timeout() const;
  public:
  void clear_rpc_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& rpc_timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_rpc_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_rpc_timeout();
  void set_allocated_rpc_timeout(::PROTOBUF_NAMESPACE_ID::Duration* rpc_timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_rpc_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_rpc_timeout();
  public:
  void unsafe_arena_set_allocated_rpc_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* rpc_timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_rpc_timeout();

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.Action.RemoteGrpc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> lease_resources_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue > inputs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::Duration* rpc_timeout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class Action final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.Action) */ {
 public:
  inline Action() : Action(nullptr) {}
  ~Action() override;
  explicit PROTOBUF_CONSTEXPR Action(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Action(const Action& from);
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action& operator=(Action&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Action& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kSleep = 1,
    kDataAcquisition = 2,
    kRemoteGrpc = 3,
    kNode = 4,
    ACTION_NOT_SET = 0,
  };

  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }
  inline void Swap(Action* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Action& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Action& from) {
    Action::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.Action";
  }
  protected:
  explicit Action(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Action_Sleep Sleep;
  typedef Action_DataAcquisition DataAcquisition;
  typedef Action_RemoteGrpc RemoteGrpc;

  // accessors -------------------------------------------------------

  enum : int {
    kSleepFieldNumber = 1,
    kDataAcquisitionFieldNumber = 2,
    kRemoteGrpcFieldNumber = 3,
    kNodeFieldNumber = 4,
  };
  // .bosdyn.api.autowalk.Action.Sleep sleep = 1;
  bool has_sleep() const;
  private:
  bool _internal_has_sleep() const;
  public:
  void clear_sleep();
  const ::bosdyn::api::autowalk::Action_Sleep& sleep() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::Action_Sleep* release_sleep();
  ::bosdyn::api::autowalk::Action_Sleep* mutable_sleep();
  void set_allocated_sleep(::bosdyn::api::autowalk::Action_Sleep* sleep);
  private:
  const ::bosdyn::api::autowalk::Action_Sleep& _internal_sleep() const;
  ::bosdyn::api::autowalk::Action_Sleep* _internal_mutable_sleep();
  public:
  void unsafe_arena_set_allocated_sleep(
      ::bosdyn::api::autowalk::Action_Sleep* sleep);
  ::bosdyn::api::autowalk::Action_Sleep* unsafe_arena_release_sleep();

  // .bosdyn.api.autowalk.Action.DataAcquisition data_acquisition = 2;
  bool has_data_acquisition() const;
  private:
  bool _internal_has_data_acquisition() const;
  public:
  void clear_data_acquisition();
  const ::bosdyn::api::autowalk::Action_DataAcquisition& data_acquisition() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::Action_DataAcquisition* release_data_acquisition();
  ::bosdyn::api::autowalk::Action_DataAcquisition* mutable_data_acquisition();
  void set_allocated_data_acquisition(::bosdyn::api::autowalk::Action_DataAcquisition* data_acquisition);
  private:
  const ::bosdyn::api::autowalk::Action_DataAcquisition& _internal_data_acquisition() const;
  ::bosdyn::api::autowalk::Action_DataAcquisition* _internal_mutable_data_acquisition();
  public:
  void unsafe_arena_set_allocated_data_acquisition(
      ::bosdyn::api::autowalk::Action_DataAcquisition* data_acquisition);
  ::bosdyn::api::autowalk::Action_DataAcquisition* unsafe_arena_release_data_acquisition();

  // .bosdyn.api.autowalk.Action.RemoteGrpc remote_grpc = 3;
  bool has_remote_grpc() const;
  private:
  bool _internal_has_remote_grpc() const;
  public:
  void clear_remote_grpc();
  const ::bosdyn::api::autowalk::Action_RemoteGrpc& remote_grpc() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::Action_RemoteGrpc* release_remote_grpc();
  ::bosdyn::api::autowalk::Action_RemoteGrpc* mutable_remote_grpc();
  void set_allocated_remote_grpc(::bosdyn::api::autowalk::Action_RemoteGrpc* remote_grpc);
  private:
  const ::bosdyn::api::autowalk::Action_RemoteGrpc& _internal_remote_grpc() const;
  ::bosdyn::api::autowalk::Action_RemoteGrpc* _internal_mutable_remote_grpc();
  public:
  void unsafe_arena_set_allocated_remote_grpc(
      ::bosdyn::api::autowalk::Action_RemoteGrpc* remote_grpc);
  ::bosdyn::api::autowalk::Action_RemoteGrpc* unsafe_arena_release_remote_grpc();

  // .bosdyn.api.mission.Node node = 4;
  bool has_node() const;
  private:
  bool _internal_has_node() const;
  public:
  void clear_node();
  const ::bosdyn::api::mission::Node& node() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Node* release_node();
  ::bosdyn::api::mission::Node* mutable_node();
  void set_allocated_node(::bosdyn::api::mission::Node* node);
  private:
  const ::bosdyn::api::mission::Node& _internal_node() const;
  ::bosdyn::api::mission::Node* _internal_mutable_node();
  public:
  void unsafe_arena_set_allocated_node(
      ::bosdyn::api::mission::Node* node);
  ::bosdyn::api::mission::Node* unsafe_arena_release_node();

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.Action)
 private:
  class _Internal;
  void set_has_sleep();
  void set_has_data_acquisition();
  void set_has_remote_grpc();
  void set_has_node();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::autowalk::Action_Sleep* sleep_;
      ::bosdyn::api::autowalk::Action_DataAcquisition* data_acquisition_;
      ::bosdyn::api::autowalk::Action_RemoteGrpc* remote_grpc_;
      ::bosdyn::api::mission::Node* node_;
    } action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class ActionWrapper_RobotBodySit final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.ActionWrapper.RobotBodySit) */ {
 public:
  inline ActionWrapper_RobotBodySit() : ActionWrapper_RobotBodySit(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ActionWrapper_RobotBodySit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionWrapper_RobotBodySit(const ActionWrapper_RobotBodySit& from);
  ActionWrapper_RobotBodySit(ActionWrapper_RobotBodySit&& from) noexcept
    : ActionWrapper_RobotBodySit() {
    *this = ::std::move(from);
  }

  inline ActionWrapper_RobotBodySit& operator=(const ActionWrapper_RobotBodySit& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionWrapper_RobotBodySit& operator=(ActionWrapper_RobotBodySit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionWrapper_RobotBodySit& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionWrapper_RobotBodySit* internal_default_instance() {
    return reinterpret_cast<const ActionWrapper_RobotBodySit*>(
               &_ActionWrapper_RobotBodySit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ActionWrapper_RobotBodySit& a, ActionWrapper_RobotBodySit& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionWrapper_RobotBodySit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionWrapper_RobotBodySit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionWrapper_RobotBodySit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionWrapper_RobotBodySit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ActionWrapper_RobotBodySit& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ActionWrapper_RobotBodySit& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.ActionWrapper.RobotBodySit";
  }
  protected:
  explicit ActionWrapper_RobotBodySit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.ActionWrapper.RobotBodySit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class ActionWrapper_RobotBodyPose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.ActionWrapper.RobotBodyPose) */ {
 public:
  inline ActionWrapper_RobotBodyPose() : ActionWrapper_RobotBodyPose(nullptr) {}
  ~ActionWrapper_RobotBodyPose() override;
  explicit PROTOBUF_CONSTEXPR ActionWrapper_RobotBodyPose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionWrapper_RobotBodyPose(const ActionWrapper_RobotBodyPose& from);
  ActionWrapper_RobotBodyPose(ActionWrapper_RobotBodyPose&& from) noexcept
    : ActionWrapper_RobotBodyPose() {
    *this = ::std::move(from);
  }

  inline ActionWrapper_RobotBodyPose& operator=(const ActionWrapper_RobotBodyPose& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionWrapper_RobotBodyPose& operator=(ActionWrapper_RobotBodyPose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionWrapper_RobotBodyPose& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionWrapper_RobotBodyPose* internal_default_instance() {
    return reinterpret_cast<const ActionWrapper_RobotBodyPose*>(
               &_ActionWrapper_RobotBodyPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ActionWrapper_RobotBodyPose& a, ActionWrapper_RobotBodyPose& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionWrapper_RobotBodyPose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionWrapper_RobotBodyPose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionWrapper_RobotBodyPose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionWrapper_RobotBodyPose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionWrapper_RobotBodyPose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionWrapper_RobotBodyPose& from) {
    ActionWrapper_RobotBodyPose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionWrapper_RobotBodyPose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.ActionWrapper.RobotBodyPose";
  }
  protected:
  explicit ActionWrapper_RobotBodyPose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetTformBodyFieldNumber = 1,
  };
  // .bosdyn.api.SE3Pose target_tform_body = 1;
  bool has_target_tform_body() const;
  private:
  bool _internal_has_target_tform_body() const;
  public:
  void clear_target_tform_body();
  const ::bosdyn::api::SE3Pose& target_tform_body() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Pose* release_target_tform_body();
  ::bosdyn::api::SE3Pose* mutable_target_tform_body();
  void set_allocated_target_tform_body(::bosdyn::api::SE3Pose* target_tform_body);
  private:
  const ::bosdyn::api::SE3Pose& _internal_target_tform_body() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_target_tform_body();
  public:
  void unsafe_arena_set_allocated_target_tform_body(
      ::bosdyn::api::SE3Pose* target_tform_body);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_target_tform_body();

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.ActionWrapper.RobotBodyPose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::SE3Pose* target_tform_body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUse, 
    int32_t, float,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUse, 
    int32_t, float,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT> SuperType;
  ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUse& other);
  static const ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUse*>(&_ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};

// -------------------------------------------------------------------

class ActionWrapper_SpotCamLed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.ActionWrapper.SpotCamLed) */ {
 public:
  inline ActionWrapper_SpotCamLed() : ActionWrapper_SpotCamLed(nullptr) {}
  ~ActionWrapper_SpotCamLed() override;
  explicit PROTOBUF_CONSTEXPR ActionWrapper_SpotCamLed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionWrapper_SpotCamLed(const ActionWrapper_SpotCamLed& from);
  ActionWrapper_SpotCamLed(ActionWrapper_SpotCamLed&& from) noexcept
    : ActionWrapper_SpotCamLed() {
    *this = ::std::move(from);
  }

  inline ActionWrapper_SpotCamLed& operator=(const ActionWrapper_SpotCamLed& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionWrapper_SpotCamLed& operator=(ActionWrapper_SpotCamLed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionWrapper_SpotCamLed& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionWrapper_SpotCamLed* internal_default_instance() {
    return reinterpret_cast<const ActionWrapper_SpotCamLed*>(
               &_ActionWrapper_SpotCamLed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ActionWrapper_SpotCamLed& a, ActionWrapper_SpotCamLed& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionWrapper_SpotCamLed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionWrapper_SpotCamLed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionWrapper_SpotCamLed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionWrapper_SpotCamLed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionWrapper_SpotCamLed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionWrapper_SpotCamLed& from) {
    ActionWrapper_SpotCamLed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionWrapper_SpotCamLed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.ActionWrapper.SpotCamLed";
  }
  protected:
  explicit ActionWrapper_SpotCamLed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kBrightnessesFieldNumber = 1,
  };
  // map<int32, float> brightnesses = 1;
  int brightnesses_size() const;
  private:
  int _internal_brightnesses_size() const;
  public:
  void clear_brightnesses();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, float >&
      _internal_brightnesses() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, float >*
      _internal_mutable_brightnesses();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, float >&
      brightnesses() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, float >*
      mutable_brightnesses();

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.ActionWrapper.SpotCamLed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ActionWrapper_SpotCamLed_BrightnessesEntry_DoNotUse,
        int32_t, float,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT> brightnesses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class ActionWrapper_SpotCamPtz final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.ActionWrapper.SpotCamPtz) */ {
 public:
  inline ActionWrapper_SpotCamPtz() : ActionWrapper_SpotCamPtz(nullptr) {}
  ~ActionWrapper_SpotCamPtz() override;
  explicit PROTOBUF_CONSTEXPR ActionWrapper_SpotCamPtz(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionWrapper_SpotCamPtz(const ActionWrapper_SpotCamPtz& from);
  ActionWrapper_SpotCamPtz(ActionWrapper_SpotCamPtz&& from) noexcept
    : ActionWrapper_SpotCamPtz() {
    *this = ::std::move(from);
  }

  inline ActionWrapper_SpotCamPtz& operator=(const ActionWrapper_SpotCamPtz& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionWrapper_SpotCamPtz& operator=(ActionWrapper_SpotCamPtz&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionWrapper_SpotCamPtz& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionWrapper_SpotCamPtz* internal_default_instance() {
    return reinterpret_cast<const ActionWrapper_SpotCamPtz*>(
               &_ActionWrapper_SpotCamPtz_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ActionWrapper_SpotCamPtz& a, ActionWrapper_SpotCamPtz& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionWrapper_SpotCamPtz* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionWrapper_SpotCamPtz* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionWrapper_SpotCamPtz* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionWrapper_SpotCamPtz>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionWrapper_SpotCamPtz& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionWrapper_SpotCamPtz& from) {
    ActionWrapper_SpotCamPtz::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionWrapper_SpotCamPtz* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.ActionWrapper.SpotCamPtz";
  }
  protected:
  explicit ActionWrapper_SpotCamPtz(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtzPositionFieldNumber = 1,
  };
  // .bosdyn.api.spot_cam.PtzPosition ptz_position = 1;
  bool has_ptz_position() const;
  private:
  bool _internal_has_ptz_position() const;
  public:
  void clear_ptz_position();
  const ::bosdyn::api::spot_cam::PtzPosition& ptz_position() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot_cam::PtzPosition* release_ptz_position();
  ::bosdyn::api::spot_cam::PtzPosition* mutable_ptz_position();
  void set_allocated_ptz_position(::bosdyn::api::spot_cam::PtzPosition* ptz_position);
  private:
  const ::bosdyn::api::spot_cam::PtzPosition& _internal_ptz_position() const;
  ::bosdyn::api::spot_cam::PtzPosition* _internal_mutable_ptz_position();
  public:
  void unsafe_arena_set_allocated_ptz_position(
      ::bosdyn::api::spot_cam::PtzPosition* ptz_position);
  ::bosdyn::api::spot_cam::PtzPosition* unsafe_arena_release_ptz_position();

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.ActionWrapper.SpotCamPtz)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::spot_cam::PtzPosition* ptz_position_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class ActionWrapper_ArmSensorPointing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing) */ {
 public:
  inline ActionWrapper_ArmSensorPointing() : ActionWrapper_ArmSensorPointing(nullptr) {}
  ~ActionWrapper_ArmSensorPointing() override;
  explicit PROTOBUF_CONSTEXPR ActionWrapper_ArmSensorPointing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionWrapper_ArmSensorPointing(const ActionWrapper_ArmSensorPointing& from);
  ActionWrapper_ArmSensorPointing(ActionWrapper_ArmSensorPointing&& from) noexcept
    : ActionWrapper_ArmSensorPointing() {
    *this = ::std::move(from);
  }

  inline ActionWrapper_ArmSensorPointing& operator=(const ActionWrapper_ArmSensorPointing& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionWrapper_ArmSensorPointing& operator=(ActionWrapper_ArmSensorPointing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionWrapper_ArmSensorPointing& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionWrapper_ArmSensorPointing* internal_default_instance() {
    return reinterpret_cast<const ActionWrapper_ArmSensorPointing*>(
               &_ActionWrapper_ArmSensorPointing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ActionWrapper_ArmSensorPointing& a, ActionWrapper_ArmSensorPointing& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionWrapper_ArmSensorPointing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionWrapper_ArmSensorPointing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionWrapper_ArmSensorPointing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionWrapper_ArmSensorPointing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionWrapper_ArmSensorPointing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionWrapper_ArmSensorPointing& from) {
    ActionWrapper_ArmSensorPointing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionWrapper_ArmSensorPointing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing";
  }
  protected:
  explicit ActionWrapper_ArmSensorPointing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointTrajectoryFieldNumber = 2,
    kWristTformToolFieldNumber = 3,
    kPoseTrajectoryRtTargetFieldNumber = 4,
    kBodyAssistParamsFieldNumber = 5,
    kTargetTformMeasuredOffsetFieldNumber = 7,
    kForceStowOverrideFieldNumber = 6,
  };
  // .bosdyn.api.ArmJointTrajectory joint_trajectory = 2;
  bool has_joint_trajectory() const;
  private:
  bool _internal_has_joint_trajectory() const;
  public:
  void clear_joint_trajectory();
  const ::bosdyn::api::ArmJointTrajectory& joint_trajectory() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ArmJointTrajectory* release_joint_trajectory();
  ::bosdyn::api::ArmJointTrajectory* mutable_joint_trajectory();
  void set_allocated_joint_trajectory(::bosdyn::api::ArmJointTrajectory* joint_trajectory);
  private:
  const ::bosdyn::api::ArmJointTrajectory& _internal_joint_trajectory() const;
  ::bosdyn::api::ArmJointTrajectory* _internal_mutable_joint_trajectory();
  public:
  void unsafe_arena_set_allocated_joint_trajectory(
      ::bosdyn::api::ArmJointTrajectory* joint_trajectory);
  ::bosdyn::api::ArmJointTrajectory* unsafe_arena_release_joint_trajectory();

  // .bosdyn.api.SE3Pose wrist_tform_tool = 3;
  bool has_wrist_tform_tool() const;
  private:
  bool _internal_has_wrist_tform_tool() const;
  public:
  void clear_wrist_tform_tool();
  const ::bosdyn::api::SE3Pose& wrist_tform_tool() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Pose* release_wrist_tform_tool();
  ::bosdyn::api::SE3Pose* mutable_wrist_tform_tool();
  void set_allocated_wrist_tform_tool(::bosdyn::api::SE3Pose* wrist_tform_tool);
  private:
  const ::bosdyn::api::SE3Pose& _internal_wrist_tform_tool() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_wrist_tform_tool();
  public:
  void unsafe_arena_set_allocated_wrist_tform_tool(
      ::bosdyn::api::SE3Pose* wrist_tform_tool);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_wrist_tform_tool();

  // .bosdyn.api.SE3Trajectory pose_trajectory_rt_target = 4;
  bool has_pose_trajectory_rt_target() const;
  private:
  bool _internal_has_pose_trajectory_rt_target() const;
  public:
  void clear_pose_trajectory_rt_target();
  const ::bosdyn::api::SE3Trajectory& pose_trajectory_rt_target() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Trajectory* release_pose_trajectory_rt_target();
  ::bosdyn::api::SE3Trajectory* mutable_pose_trajectory_rt_target();
  void set_allocated_pose_trajectory_rt_target(::bosdyn::api::SE3Trajectory* pose_trajectory_rt_target);
  private:
  const ::bosdyn::api::SE3Trajectory& _internal_pose_trajectory_rt_target() const;
  ::bosdyn::api::SE3Trajectory* _internal_mutable_pose_trajectory_rt_target();
  public:
  void unsafe_arena_set_allocated_pose_trajectory_rt_target(
      ::bosdyn::api::SE3Trajectory* pose_trajectory_rt_target);
  ::bosdyn::api::SE3Trajectory* unsafe_arena_release_pose_trajectory_rt_target();

  // .bosdyn.api.spot.BodyControlParams.BodyAssistForManipulation body_assist_params = 5;
  bool has_body_assist_params() const;
  private:
  bool _internal_has_body_assist_params() const;
  public:
  void clear_body_assist_params();
  const ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation& body_assist_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* release_body_assist_params();
  ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* mutable_body_assist_params();
  void set_allocated_body_assist_params(::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* body_assist_params);
  private:
  const ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation& _internal_body_assist_params() const;
  ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* _internal_mutable_body_assist_params();
  public:
  void unsafe_arena_set_allocated_body_assist_params(
      ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* body_assist_params);
  ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* unsafe_arena_release_body_assist_params();

  // .bosdyn.api.SE2Pose target_tform_measured_offset = 7;
  bool has_target_tform_measured_offset() const;
  private:
  bool _internal_has_target_tform_measured_offset() const;
  public:
  void clear_target_tform_measured_offset();
  const ::bosdyn::api::SE2Pose& target_tform_measured_offset() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE2Pose* release_target_tform_measured_offset();
  ::bosdyn::api::SE2Pose* mutable_target_tform_measured_offset();
  void set_allocated_target_tform_measured_offset(::bosdyn::api::SE2Pose* target_tform_measured_offset);
  private:
  const ::bosdyn::api::SE2Pose& _internal_target_tform_measured_offset() const;
  ::bosdyn::api::SE2Pose* _internal_mutable_target_tform_measured_offset();
  public:
  void unsafe_arena_set_allocated_target_tform_measured_offset(
      ::bosdyn::api::SE2Pose* target_tform_measured_offset);
  ::bosdyn::api::SE2Pose* unsafe_arena_release_target_tform_measured_offset();

  // bool force_stow_override = 6;
  void clear_force_stow_override();
  bool force_stow_override() const;
  void set_force_stow_override(bool value);
  private:
  bool _internal_force_stow_override() const;
  void _internal_set_force_stow_override(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ArmJointTrajectory* joint_trajectory_;
    ::bosdyn::api::SE3Pose* wrist_tform_tool_;
    ::bosdyn::api::SE3Trajectory* pose_trajectory_rt_target_;
    ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* body_assist_params_;
    ::bosdyn::api::SE2Pose* target_tform_measured_offset_;
    bool force_stow_override_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class ActionWrapper_GripperCameraParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.ActionWrapper.GripperCameraParams) */ {
 public:
  inline ActionWrapper_GripperCameraParams() : ActionWrapper_GripperCameraParams(nullptr) {}
  ~ActionWrapper_GripperCameraParams() override;
  explicit PROTOBUF_CONSTEXPR ActionWrapper_GripperCameraParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionWrapper_GripperCameraParams(const ActionWrapper_GripperCameraParams& from);
  ActionWrapper_GripperCameraParams(ActionWrapper_GripperCameraParams&& from) noexcept
    : ActionWrapper_GripperCameraParams() {
    *this = ::std::move(from);
  }

  inline ActionWrapper_GripperCameraParams& operator=(const ActionWrapper_GripperCameraParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionWrapper_GripperCameraParams& operator=(ActionWrapper_GripperCameraParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionWrapper_GripperCameraParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionWrapper_GripperCameraParams* internal_default_instance() {
    return reinterpret_cast<const ActionWrapper_GripperCameraParams*>(
               &_ActionWrapper_GripperCameraParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ActionWrapper_GripperCameraParams& a, ActionWrapper_GripperCameraParams& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionWrapper_GripperCameraParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionWrapper_GripperCameraParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionWrapper_GripperCameraParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionWrapper_GripperCameraParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionWrapper_GripperCameraParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionWrapper_GripperCameraParams& from) {
    ActionWrapper_GripperCameraParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionWrapper_GripperCameraParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.ActionWrapper.GripperCameraParams";
  }
  protected:
  explicit ActionWrapper_GripperCameraParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 1,
  };
  // .bosdyn.api.GripperCameraParams params = 1;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::bosdyn::api::GripperCameraParams& params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::GripperCameraParams* release_params();
  ::bosdyn::api::GripperCameraParams* mutable_params();
  void set_allocated_params(::bosdyn::api::GripperCameraParams* params);
  private:
  const ::bosdyn::api::GripperCameraParams& _internal_params() const;
  ::bosdyn::api::GripperCameraParams* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::bosdyn::api::GripperCameraParams* params);
  ::bosdyn::api::GripperCameraParams* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.ActionWrapper.GripperCameraParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::GripperCameraParams* params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class ActionWrapper_GripperCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.ActionWrapper.GripperCommand) */ {
 public:
  inline ActionWrapper_GripperCommand() : ActionWrapper_GripperCommand(nullptr) {}
  ~ActionWrapper_GripperCommand() override;
  explicit PROTOBUF_CONSTEXPR ActionWrapper_GripperCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionWrapper_GripperCommand(const ActionWrapper_GripperCommand& from);
  ActionWrapper_GripperCommand(ActionWrapper_GripperCommand&& from) noexcept
    : ActionWrapper_GripperCommand() {
    *this = ::std::move(from);
  }

  inline ActionWrapper_GripperCommand& operator=(const ActionWrapper_GripperCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionWrapper_GripperCommand& operator=(ActionWrapper_GripperCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionWrapper_GripperCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionWrapper_GripperCommand* internal_default_instance() {
    return reinterpret_cast<const ActionWrapper_GripperCommand*>(
               &_ActionWrapper_GripperCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ActionWrapper_GripperCommand& a, ActionWrapper_GripperCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionWrapper_GripperCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionWrapper_GripperCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionWrapper_GripperCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionWrapper_GripperCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionWrapper_GripperCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionWrapper_GripperCommand& from) {
    ActionWrapper_GripperCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionWrapper_GripperCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.ActionWrapper.GripperCommand";
  }
  protected:
  explicit ActionWrapper_GripperCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 1,
  };
  // .bosdyn.api.GripperCommand.Request request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::bosdyn::api::GripperCommand_Request& request() const;
  PROTOBUF_NODISCARD ::bosdyn::api::GripperCommand_Request* release_request();
  ::bosdyn::api::GripperCommand_Request* mutable_request();
  void set_allocated_request(::bosdyn::api::GripperCommand_Request* request);
  private:
  const ::bosdyn::api::GripperCommand_Request& _internal_request() const;
  ::bosdyn::api::GripperCommand_Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::bosdyn::api::GripperCommand_Request* request);
  ::bosdyn::api::GripperCommand_Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.ActionWrapper.GripperCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::GripperCommand_Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class ActionWrapper final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.ActionWrapper) */ {
 public:
  inline ActionWrapper() : ActionWrapper(nullptr) {}
  ~ActionWrapper() override;
  explicit PROTOBUF_CONSTEXPR ActionWrapper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionWrapper(const ActionWrapper& from);
  ActionWrapper(ActionWrapper&& from) noexcept
    : ActionWrapper() {
    *this = ::std::move(from);
  }

  inline ActionWrapper& operator=(const ActionWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionWrapper& operator=(ActionWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionWrapper& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionWrapper* internal_default_instance() {
    return reinterpret_cast<const ActionWrapper*>(
               &_ActionWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ActionWrapper& a, ActionWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionWrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionWrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionWrapper>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionWrapper& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionWrapper& from) {
    ActionWrapper::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionWrapper* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.ActionWrapper";
  }
  protected:
  explicit ActionWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ActionWrapper_RobotBodySit RobotBodySit;
  typedef ActionWrapper_RobotBodyPose RobotBodyPose;
  typedef ActionWrapper_SpotCamLed SpotCamLed;
  typedef ActionWrapper_SpotCamPtz SpotCamPtz;
  typedef ActionWrapper_ArmSensorPointing ArmSensorPointing;
  typedef ActionWrapper_GripperCameraParams GripperCameraParams;
  typedef ActionWrapper_GripperCommand GripperCommand;

  // accessors -------------------------------------------------------

  enum : int {
    kRobotBodySitFieldNumber = 1,
    kRobotBodyPoseFieldNumber = 2,
    kSpotCamLedFieldNumber = 4,
    kSpotCamPtzFieldNumber = 5,
    kArmSensorPointingFieldNumber = 6,
    kGripperCameraParamsFieldNumber = 7,
    kGripperCommandFieldNumber = 8,
  };
  // .bosdyn.api.autowalk.ActionWrapper.RobotBodySit robot_body_sit = 1;
  bool has_robot_body_sit() const;
  private:
  bool _internal_has_robot_body_sit() const;
  public:
  void clear_robot_body_sit();
  const ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit& robot_body_sit() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* release_robot_body_sit();
  ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* mutable_robot_body_sit();
  void set_allocated_robot_body_sit(::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* robot_body_sit);
  private:
  const ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit& _internal_robot_body_sit() const;
  ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* _internal_mutable_robot_body_sit();
  public:
  void unsafe_arena_set_allocated_robot_body_sit(
      ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* robot_body_sit);
  ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* unsafe_arena_release_robot_body_sit();

  // .bosdyn.api.autowalk.ActionWrapper.RobotBodyPose robot_body_pose = 2;
  bool has_robot_body_pose() const;
  private:
  bool _internal_has_robot_body_pose() const;
  public:
  void clear_robot_body_pose();
  const ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose& robot_body_pose() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* release_robot_body_pose();
  ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* mutable_robot_body_pose();
  void set_allocated_robot_body_pose(::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* robot_body_pose);
  private:
  const ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose& _internal_robot_body_pose() const;
  ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* _internal_mutable_robot_body_pose();
  public:
  void unsafe_arena_set_allocated_robot_body_pose(
      ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* robot_body_pose);
  ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* unsafe_arena_release_robot_body_pose();

  // .bosdyn.api.autowalk.ActionWrapper.SpotCamLed spot_cam_led = 4;
  bool has_spot_cam_led() const;
  private:
  bool _internal_has_spot_cam_led() const;
  public:
  void clear_spot_cam_led();
  const ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed& spot_cam_led() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* release_spot_cam_led();
  ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* mutable_spot_cam_led();
  void set_allocated_spot_cam_led(::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* spot_cam_led);
  private:
  const ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed& _internal_spot_cam_led() const;
  ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* _internal_mutable_spot_cam_led();
  public:
  void unsafe_arena_set_allocated_spot_cam_led(
      ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* spot_cam_led);
  ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* unsafe_arena_release_spot_cam_led();

  // .bosdyn.api.autowalk.ActionWrapper.SpotCamPtz spot_cam_ptz = 5;
  bool has_spot_cam_ptz() const;
  private:
  bool _internal_has_spot_cam_ptz() const;
  public:
  void clear_spot_cam_ptz();
  const ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz& spot_cam_ptz() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* release_spot_cam_ptz();
  ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* mutable_spot_cam_ptz();
  void set_allocated_spot_cam_ptz(::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* spot_cam_ptz);
  private:
  const ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz& _internal_spot_cam_ptz() const;
  ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* _internal_mutable_spot_cam_ptz();
  public:
  void unsafe_arena_set_allocated_spot_cam_ptz(
      ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* spot_cam_ptz);
  ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* unsafe_arena_release_spot_cam_ptz();

  // .bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing arm_sensor_pointing = 6;
  bool has_arm_sensor_pointing() const;
  private:
  bool _internal_has_arm_sensor_pointing() const;
  public:
  void clear_arm_sensor_pointing();
  const ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing& arm_sensor_pointing() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* release_arm_sensor_pointing();
  ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* mutable_arm_sensor_pointing();
  void set_allocated_arm_sensor_pointing(::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* arm_sensor_pointing);
  private:
  const ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing& _internal_arm_sensor_pointing() const;
  ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* _internal_mutable_arm_sensor_pointing();
  public:
  void unsafe_arena_set_allocated_arm_sensor_pointing(
      ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* arm_sensor_pointing);
  ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* unsafe_arena_release_arm_sensor_pointing();

  // .bosdyn.api.autowalk.ActionWrapper.GripperCameraParams gripper_camera_params = 7;
  bool has_gripper_camera_params() const;
  private:
  bool _internal_has_gripper_camera_params() const;
  public:
  void clear_gripper_camera_params();
  const ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams& gripper_camera_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* release_gripper_camera_params();
  ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* mutable_gripper_camera_params();
  void set_allocated_gripper_camera_params(::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* gripper_camera_params);
  private:
  const ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams& _internal_gripper_camera_params() const;
  ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* _internal_mutable_gripper_camera_params();
  public:
  void unsafe_arena_set_allocated_gripper_camera_params(
      ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* gripper_camera_params);
  ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* unsafe_arena_release_gripper_camera_params();

  // .bosdyn.api.autowalk.ActionWrapper.GripperCommand gripper_command = 8;
  bool has_gripper_command() const;
  private:
  bool _internal_has_gripper_command() const;
  public:
  void clear_gripper_command();
  const ::bosdyn::api::autowalk::ActionWrapper_GripperCommand& gripper_command() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::ActionWrapper_GripperCommand* release_gripper_command();
  ::bosdyn::api::autowalk::ActionWrapper_GripperCommand* mutable_gripper_command();
  void set_allocated_gripper_command(::bosdyn::api::autowalk::ActionWrapper_GripperCommand* gripper_command);
  private:
  const ::bosdyn::api::autowalk::ActionWrapper_GripperCommand& _internal_gripper_command() const;
  ::bosdyn::api::autowalk::ActionWrapper_GripperCommand* _internal_mutable_gripper_command();
  public:
  void unsafe_arena_set_allocated_gripper_command(
      ::bosdyn::api::autowalk::ActionWrapper_GripperCommand* gripper_command);
  ::bosdyn::api::autowalk::ActionWrapper_GripperCommand* unsafe_arena_release_gripper_command();

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.ActionWrapper)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* robot_body_sit_;
    ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* robot_body_pose_;
    ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* spot_cam_led_;
    ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* spot_cam_ptz_;
    ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* arm_sensor_pointing_;
    ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* gripper_camera_params_;
    ::bosdyn::api::autowalk::ActionWrapper_GripperCommand* gripper_command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class FailureBehavior_SafePowerOff final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.FailureBehavior.SafePowerOff) */ {
 public:
  inline FailureBehavior_SafePowerOff() : FailureBehavior_SafePowerOff(nullptr) {}
  ~FailureBehavior_SafePowerOff() override;
  explicit PROTOBUF_CONSTEXPR FailureBehavior_SafePowerOff(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FailureBehavior_SafePowerOff(const FailureBehavior_SafePowerOff& from);
  FailureBehavior_SafePowerOff(FailureBehavior_SafePowerOff&& from) noexcept
    : FailureBehavior_SafePowerOff() {
    *this = ::std::move(from);
  }

  inline FailureBehavior_SafePowerOff& operator=(const FailureBehavior_SafePowerOff& from) {
    CopyFrom(from);
    return *this;
  }
  inline FailureBehavior_SafePowerOff& operator=(FailureBehavior_SafePowerOff&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FailureBehavior_SafePowerOff& default_instance() {
    return *internal_default_instance();
  }
  static inline const FailureBehavior_SafePowerOff* internal_default_instance() {
    return reinterpret_cast<const FailureBehavior_SafePowerOff*>(
               &_FailureBehavior_SafePowerOff_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(FailureBehavior_SafePowerOff& a, FailureBehavior_SafePowerOff& b) {
    a.Swap(&b);
  }
  inline void Swap(FailureBehavior_SafePowerOff* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FailureBehavior_SafePowerOff* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FailureBehavior_SafePowerOff* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FailureBehavior_SafePowerOff>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FailureBehavior_SafePowerOff& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FailureBehavior_SafePowerOff& from) {
    FailureBehavior_SafePowerOff::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FailureBehavior_SafePowerOff* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.FailureBehavior.SafePowerOff";
  }
  protected:
  explicit FailureBehavior_SafePowerOff(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 1,
  };
  // .bosdyn.api.SafePowerOffCommand.Request request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::bosdyn::api::SafePowerOffCommand_Request& request() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SafePowerOffCommand_Request* release_request();
  ::bosdyn::api::SafePowerOffCommand_Request* mutable_request();
  void set_allocated_request(::bosdyn::api::SafePowerOffCommand_Request* request);
  private:
  const ::bosdyn::api::SafePowerOffCommand_Request& _internal_request() const;
  ::bosdyn::api::SafePowerOffCommand_Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::bosdyn::api::SafePowerOffCommand_Request* request);
  ::bosdyn::api::SafePowerOffCommand_Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.FailureBehavior.SafePowerOff)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::SafePowerOffCommand_Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class FailureBehavior_ProceedIfAble final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.FailureBehavior.ProceedIfAble) */ {
 public:
  inline FailureBehavior_ProceedIfAble() : FailureBehavior_ProceedIfAble(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FailureBehavior_ProceedIfAble(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FailureBehavior_ProceedIfAble(const FailureBehavior_ProceedIfAble& from);
  FailureBehavior_ProceedIfAble(FailureBehavior_ProceedIfAble&& from) noexcept
    : FailureBehavior_ProceedIfAble() {
    *this = ::std::move(from);
  }

  inline FailureBehavior_ProceedIfAble& operator=(const FailureBehavior_ProceedIfAble& from) {
    CopyFrom(from);
    return *this;
  }
  inline FailureBehavior_ProceedIfAble& operator=(FailureBehavior_ProceedIfAble&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FailureBehavior_ProceedIfAble& default_instance() {
    return *internal_default_instance();
  }
  static inline const FailureBehavior_ProceedIfAble* internal_default_instance() {
    return reinterpret_cast<const FailureBehavior_ProceedIfAble*>(
               &_FailureBehavior_ProceedIfAble_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(FailureBehavior_ProceedIfAble& a, FailureBehavior_ProceedIfAble& b) {
    a.Swap(&b);
  }
  inline void Swap(FailureBehavior_ProceedIfAble* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FailureBehavior_ProceedIfAble* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FailureBehavior_ProceedIfAble* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FailureBehavior_ProceedIfAble>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FailureBehavior_ProceedIfAble& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FailureBehavior_ProceedIfAble& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.FailureBehavior.ProceedIfAble";
  }
  protected:
  explicit FailureBehavior_ProceedIfAble(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.FailureBehavior.ProceedIfAble)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class FailureBehavior_ReturnToStartAndTryAgainLater final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.FailureBehavior.ReturnToStartAndTryAgainLater) */ {
 public:
  inline FailureBehavior_ReturnToStartAndTryAgainLater() : FailureBehavior_ReturnToStartAndTryAgainLater(nullptr) {}
  ~FailureBehavior_ReturnToStartAndTryAgainLater() override;
  explicit PROTOBUF_CONSTEXPR FailureBehavior_ReturnToStartAndTryAgainLater(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FailureBehavior_ReturnToStartAndTryAgainLater(const FailureBehavior_ReturnToStartAndTryAgainLater& from);
  FailureBehavior_ReturnToStartAndTryAgainLater(FailureBehavior_ReturnToStartAndTryAgainLater&& from) noexcept
    : FailureBehavior_ReturnToStartAndTryAgainLater() {
    *this = ::std::move(from);
  }

  inline FailureBehavior_ReturnToStartAndTryAgainLater& operator=(const FailureBehavior_ReturnToStartAndTryAgainLater& from) {
    CopyFrom(from);
    return *this;
  }
  inline FailureBehavior_ReturnToStartAndTryAgainLater& operator=(FailureBehavior_ReturnToStartAndTryAgainLater&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FailureBehavior_ReturnToStartAndTryAgainLater& default_instance() {
    return *internal_default_instance();
  }
  static inline const FailureBehavior_ReturnToStartAndTryAgainLater* internal_default_instance() {
    return reinterpret_cast<const FailureBehavior_ReturnToStartAndTryAgainLater*>(
               &_FailureBehavior_ReturnToStartAndTryAgainLater_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(FailureBehavior_ReturnToStartAndTryAgainLater& a, FailureBehavior_ReturnToStartAndTryAgainLater& b) {
    a.Swap(&b);
  }
  inline void Swap(FailureBehavior_ReturnToStartAndTryAgainLater* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FailureBehavior_ReturnToStartAndTryAgainLater* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FailureBehavior_ReturnToStartAndTryAgainLater* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FailureBehavior_ReturnToStartAndTryAgainLater>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FailureBehavior_ReturnToStartAndTryAgainLater& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FailureBehavior_ReturnToStartAndTryAgainLater& from) {
    FailureBehavior_ReturnToStartAndTryAgainLater::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FailureBehavior_ReturnToStartAndTryAgainLater* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.FailureBehavior.ReturnToStartAndTryAgainLater";
  }
  protected:
  explicit FailureBehavior_ReturnToStartAndTryAgainLater(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTryAgainDelayFieldNumber = 1,
  };
  // .google.protobuf.Duration try_again_delay = 1;
  bool has_try_again_delay() const;
  private:
  bool _internal_has_try_again_delay() const;
  public:
  void clear_try_again_delay();
  const ::PROTOBUF_NAMESPACE_ID::Duration& try_again_delay() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_try_again_delay();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_try_again_delay();
  void set_allocated_try_again_delay(::PROTOBUF_NAMESPACE_ID::Duration* try_again_delay);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_try_again_delay() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_try_again_delay();
  public:
  void unsafe_arena_set_allocated_try_again_delay(
      ::PROTOBUF_NAMESPACE_ID::Duration* try_again_delay);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_try_again_delay();

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.FailureBehavior.ReturnToStartAndTryAgainLater)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Duration* try_again_delay_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class FailureBehavior_ReturnToStartAndTerminate final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.FailureBehavior.ReturnToStartAndTerminate) */ {
 public:
  inline FailureBehavior_ReturnToStartAndTerminate() : FailureBehavior_ReturnToStartAndTerminate(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FailureBehavior_ReturnToStartAndTerminate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FailureBehavior_ReturnToStartAndTerminate(const FailureBehavior_ReturnToStartAndTerminate& from);
  FailureBehavior_ReturnToStartAndTerminate(FailureBehavior_ReturnToStartAndTerminate&& from) noexcept
    : FailureBehavior_ReturnToStartAndTerminate() {
    *this = ::std::move(from);
  }

  inline FailureBehavior_ReturnToStartAndTerminate& operator=(const FailureBehavior_ReturnToStartAndTerminate& from) {
    CopyFrom(from);
    return *this;
  }
  inline FailureBehavior_ReturnToStartAndTerminate& operator=(FailureBehavior_ReturnToStartAndTerminate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FailureBehavior_ReturnToStartAndTerminate& default_instance() {
    return *internal_default_instance();
  }
  static inline const FailureBehavior_ReturnToStartAndTerminate* internal_default_instance() {
    return reinterpret_cast<const FailureBehavior_ReturnToStartAndTerminate*>(
               &_FailureBehavior_ReturnToStartAndTerminate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(FailureBehavior_ReturnToStartAndTerminate& a, FailureBehavior_ReturnToStartAndTerminate& b) {
    a.Swap(&b);
  }
  inline void Swap(FailureBehavior_ReturnToStartAndTerminate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FailureBehavior_ReturnToStartAndTerminate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FailureBehavior_ReturnToStartAndTerminate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FailureBehavior_ReturnToStartAndTerminate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FailureBehavior_ReturnToStartAndTerminate& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FailureBehavior_ReturnToStartAndTerminate& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.FailureBehavior.ReturnToStartAndTerminate";
  }
  protected:
  explicit FailureBehavior_ReturnToStartAndTerminate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.FailureBehavior.ReturnToStartAndTerminate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class FailureBehavior final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.FailureBehavior) */ {
 public:
  inline FailureBehavior() : FailureBehavior(nullptr) {}
  ~FailureBehavior() override;
  explicit PROTOBUF_CONSTEXPR FailureBehavior(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FailureBehavior(const FailureBehavior& from);
  FailureBehavior(FailureBehavior&& from) noexcept
    : FailureBehavior() {
    *this = ::std::move(from);
  }

  inline FailureBehavior& operator=(const FailureBehavior& from) {
    CopyFrom(from);
    return *this;
  }
  inline FailureBehavior& operator=(FailureBehavior&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FailureBehavior& default_instance() {
    return *internal_default_instance();
  }
  enum DefaultBehaviorCase {
    kSafePowerOff = 3,
    kProceedIfAble = 4,
    kReturnToStartAndTryAgainLater = 5,
    kReturnToStartAndTerminate = 6,
    DEFAULT_BEHAVIOR_NOT_SET = 0,
  };

  static inline const FailureBehavior* internal_default_instance() {
    return reinterpret_cast<const FailureBehavior*>(
               &_FailureBehavior_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(FailureBehavior& a, FailureBehavior& b) {
    a.Swap(&b);
  }
  inline void Swap(FailureBehavior* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FailureBehavior* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FailureBehavior* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FailureBehavior>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FailureBehavior& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FailureBehavior& from) {
    FailureBehavior::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FailureBehavior* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.FailureBehavior";
  }
  protected:
  explicit FailureBehavior(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FailureBehavior_SafePowerOff SafePowerOff;
  typedef FailureBehavior_ProceedIfAble ProceedIfAble;
  typedef FailureBehavior_ReturnToStartAndTryAgainLater ReturnToStartAndTryAgainLater;
  typedef FailureBehavior_ReturnToStartAndTerminate ReturnToStartAndTerminate;

  // accessors -------------------------------------------------------

  enum : int {
    kPromptDurationFieldNumber = 2,
    kRetryCountFieldNumber = 1,
    kSafePowerOffFieldNumber = 3,
    kProceedIfAbleFieldNumber = 4,
    kReturnToStartAndTryAgainLaterFieldNumber = 5,
    kReturnToStartAndTerminateFieldNumber = 6,
  };
  // .google.protobuf.Duration prompt_duration = 2;
  bool has_prompt_duration() const;
  private:
  bool _internal_has_prompt_duration() const;
  public:
  void clear_prompt_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& prompt_duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_prompt_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_prompt_duration();
  void set_allocated_prompt_duration(::PROTOBUF_NAMESPACE_ID::Duration* prompt_duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_prompt_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_prompt_duration();
  public:
  void unsafe_arena_set_allocated_prompt_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* prompt_duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_prompt_duration();

  // int32 retry_count = 1;
  void clear_retry_count();
  int32_t retry_count() const;
  void set_retry_count(int32_t value);
  private:
  int32_t _internal_retry_count() const;
  void _internal_set_retry_count(int32_t value);
  public:

  // .bosdyn.api.autowalk.FailureBehavior.SafePowerOff safe_power_off = 3;
  bool has_safe_power_off() const;
  private:
  bool _internal_has_safe_power_off() const;
  public:
  void clear_safe_power_off();
  const ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff& safe_power_off() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff* release_safe_power_off();
  ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff* mutable_safe_power_off();
  void set_allocated_safe_power_off(::bosdyn::api::autowalk::FailureBehavior_SafePowerOff* safe_power_off);
  private:
  const ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff& _internal_safe_power_off() const;
  ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff* _internal_mutable_safe_power_off();
  public:
  void unsafe_arena_set_allocated_safe_power_off(
      ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff* safe_power_off);
  ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff* unsafe_arena_release_safe_power_off();

  // .bosdyn.api.autowalk.FailureBehavior.ProceedIfAble proceed_if_able = 4;
  bool has_proceed_if_able() const;
  private:
  bool _internal_has_proceed_if_able() const;
  public:
  void clear_proceed_if_able();
  const ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble& proceed_if_able() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble* release_proceed_if_able();
  ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble* mutable_proceed_if_able();
  void set_allocated_proceed_if_able(::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble* proceed_if_able);
  private:
  const ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble& _internal_proceed_if_able() const;
  ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble* _internal_mutable_proceed_if_able();
  public:
  void unsafe_arena_set_allocated_proceed_if_able(
      ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble* proceed_if_able);
  ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble* unsafe_arena_release_proceed_if_able();

  // .bosdyn.api.autowalk.FailureBehavior.ReturnToStartAndTryAgainLater return_to_start_and_try_again_later = 5;
  bool has_return_to_start_and_try_again_later() const;
  private:
  bool _internal_has_return_to_start_and_try_again_later() const;
  public:
  void clear_return_to_start_and_try_again_later();
  const ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater& return_to_start_and_try_again_later() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater* release_return_to_start_and_try_again_later();
  ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater* mutable_return_to_start_and_try_again_later();
  void set_allocated_return_to_start_and_try_again_later(::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater* return_to_start_and_try_again_later);
  private:
  const ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater& _internal_return_to_start_and_try_again_later() const;
  ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater* _internal_mutable_return_to_start_and_try_again_later();
  public:
  void unsafe_arena_set_allocated_return_to_start_and_try_again_later(
      ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater* return_to_start_and_try_again_later);
  ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater* unsafe_arena_release_return_to_start_and_try_again_later();

  // .bosdyn.api.autowalk.FailureBehavior.ReturnToStartAndTerminate return_to_start_and_terminate = 6;
  bool has_return_to_start_and_terminate() const;
  private:
  bool _internal_has_return_to_start_and_terminate() const;
  public:
  void clear_return_to_start_and_terminate();
  const ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate& return_to_start_and_terminate() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate* release_return_to_start_and_terminate();
  ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate* mutable_return_to_start_and_terminate();
  void set_allocated_return_to_start_and_terminate(::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate* return_to_start_and_terminate);
  private:
  const ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate& _internal_return_to_start_and_terminate() const;
  ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate* _internal_mutable_return_to_start_and_terminate();
  public:
  void unsafe_arena_set_allocated_return_to_start_and_terminate(
      ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate* return_to_start_and_terminate);
  ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate* unsafe_arena_release_return_to_start_and_terminate();

  void clear_default_behavior();
  DefaultBehaviorCase default_behavior_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.FailureBehavior)
 private:
  class _Internal;
  void set_has_safe_power_off();
  void set_has_proceed_if_able();
  void set_has_return_to_start_and_try_again_later();
  void set_has_return_to_start_and_terminate();

  inline bool has_default_behavior() const;
  inline void clear_has_default_behavior();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Duration* prompt_duration_;
    int32_t retry_count_;
    union DefaultBehaviorUnion {
      constexpr DefaultBehaviorUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff* safe_power_off_;
      ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble* proceed_if_able_;
      ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater* return_to_start_and_try_again_later_;
      ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate* return_to_start_and_terminate_;
    } default_behavior_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// -------------------------------------------------------------------

class BatteryMonitor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.BatteryMonitor) */ {
 public:
  inline BatteryMonitor() : BatteryMonitor(nullptr) {}
  ~BatteryMonitor() override;
  explicit PROTOBUF_CONSTEXPR BatteryMonitor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatteryMonitor(const BatteryMonitor& from);
  BatteryMonitor(BatteryMonitor&& from) noexcept
    : BatteryMonitor() {
    *this = ::std::move(from);
  }

  inline BatteryMonitor& operator=(const BatteryMonitor& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatteryMonitor& operator=(BatteryMonitor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatteryMonitor& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatteryMonitor* internal_default_instance() {
    return reinterpret_cast<const BatteryMonitor*>(
               &_BatteryMonitor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(BatteryMonitor& a, BatteryMonitor& b) {
    a.Swap(&b);
  }
  inline void Swap(BatteryMonitor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatteryMonitor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatteryMonitor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatteryMonitor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatteryMonitor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatteryMonitor& from) {
    BatteryMonitor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatteryMonitor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.BatteryMonitor";
  }
  protected:
  explicit BatteryMonitor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatteryStartThresholdFieldNumber = 2,
    kBatteryStopThresholdFieldNumber = 3,
  };
  // float battery_start_threshold = 2;
  void clear_battery_start_threshold();
  float battery_start_threshold() const;
  void set_battery_start_threshold(float value);
  private:
  float _internal_battery_start_threshold() const;
  void _internal_set_battery_start_threshold(float value);
  public:

  // float battery_stop_threshold = 3;
  void clear_battery_stop_threshold();
  float battery_stop_threshold() const;
  void set_battery_stop_threshold(float value);
  private:
  float _internal_battery_stop_threshold() const;
  void _internal_set_battery_stop_threshold(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.BatteryMonitor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float battery_start_threshold_;
    float battery_stop_threshold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fwalks_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Walk

// .bosdyn.api.autowalk.GlobalParameters global_parameters = 1;
inline bool Walk::_internal_has_global_parameters() const {
  return this != internal_default_instance() && _impl_.global_parameters_ != nullptr;
}
inline bool Walk::has_global_parameters() const {
  return _internal_has_global_parameters();
}
inline void Walk::clear_global_parameters() {
  if (GetArenaForAllocation() == nullptr && _impl_.global_parameters_ != nullptr) {
    delete _impl_.global_parameters_;
  }
  _impl_.global_parameters_ = nullptr;
}
inline const ::bosdyn::api::autowalk::GlobalParameters& Walk::_internal_global_parameters() const {
  const ::bosdyn::api::autowalk::GlobalParameters* p = _impl_.global_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::GlobalParameters&>(
      ::bosdyn::api::autowalk::_GlobalParameters_default_instance_);
}
inline const ::bosdyn::api::autowalk::GlobalParameters& Walk::global_parameters() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Walk.global_parameters)
  return _internal_global_parameters();
}
inline void Walk::unsafe_arena_set_allocated_global_parameters(
    ::bosdyn::api::autowalk::GlobalParameters* global_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.global_parameters_);
  }
  _impl_.global_parameters_ = global_parameters;
  if (global_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Walk.global_parameters)
}
inline ::bosdyn::api::autowalk::GlobalParameters* Walk::release_global_parameters() {
  
  ::bosdyn::api::autowalk::GlobalParameters* temp = _impl_.global_parameters_;
  _impl_.global_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::GlobalParameters* Walk::unsafe_arena_release_global_parameters() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Walk.global_parameters)
  
  ::bosdyn::api::autowalk::GlobalParameters* temp = _impl_.global_parameters_;
  _impl_.global_parameters_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::GlobalParameters* Walk::_internal_mutable_global_parameters() {
  
  if (_impl_.global_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::GlobalParameters>(GetArenaForAllocation());
    _impl_.global_parameters_ = p;
  }
  return _impl_.global_parameters_;
}
inline ::bosdyn::api::autowalk::GlobalParameters* Walk::mutable_global_parameters() {
  ::bosdyn::api::autowalk::GlobalParameters* _msg = _internal_mutable_global_parameters();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Walk.global_parameters)
  return _msg;
}
inline void Walk::set_allocated_global_parameters(::bosdyn::api::autowalk::GlobalParameters* global_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.global_parameters_;
  }
  if (global_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(global_parameters);
    if (message_arena != submessage_arena) {
      global_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, global_parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.global_parameters_ = global_parameters;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Walk.global_parameters)
}

// .bosdyn.api.autowalk.PlaybackMode playback_mode = 2;
inline bool Walk::_internal_has_playback_mode() const {
  return this != internal_default_instance() && _impl_.playback_mode_ != nullptr;
}
inline bool Walk::has_playback_mode() const {
  return _internal_has_playback_mode();
}
inline void Walk::clear_playback_mode() {
  if (GetArenaForAllocation() == nullptr && _impl_.playback_mode_ != nullptr) {
    delete _impl_.playback_mode_;
  }
  _impl_.playback_mode_ = nullptr;
}
inline const ::bosdyn::api::autowalk::PlaybackMode& Walk::_internal_playback_mode() const {
  const ::bosdyn::api::autowalk::PlaybackMode* p = _impl_.playback_mode_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::PlaybackMode&>(
      ::bosdyn::api::autowalk::_PlaybackMode_default_instance_);
}
inline const ::bosdyn::api::autowalk::PlaybackMode& Walk::playback_mode() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Walk.playback_mode)
  return _internal_playback_mode();
}
inline void Walk::unsafe_arena_set_allocated_playback_mode(
    ::bosdyn::api::autowalk::PlaybackMode* playback_mode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.playback_mode_);
  }
  _impl_.playback_mode_ = playback_mode;
  if (playback_mode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Walk.playback_mode)
}
inline ::bosdyn::api::autowalk::PlaybackMode* Walk::release_playback_mode() {
  
  ::bosdyn::api::autowalk::PlaybackMode* temp = _impl_.playback_mode_;
  _impl_.playback_mode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::PlaybackMode* Walk::unsafe_arena_release_playback_mode() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Walk.playback_mode)
  
  ::bosdyn::api::autowalk::PlaybackMode* temp = _impl_.playback_mode_;
  _impl_.playback_mode_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::PlaybackMode* Walk::_internal_mutable_playback_mode() {
  
  if (_impl_.playback_mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::PlaybackMode>(GetArenaForAllocation());
    _impl_.playback_mode_ = p;
  }
  return _impl_.playback_mode_;
}
inline ::bosdyn::api::autowalk::PlaybackMode* Walk::mutable_playback_mode() {
  ::bosdyn::api::autowalk::PlaybackMode* _msg = _internal_mutable_playback_mode();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Walk.playback_mode)
  return _msg;
}
inline void Walk::set_allocated_playback_mode(::bosdyn::api::autowalk::PlaybackMode* playback_mode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.playback_mode_;
  }
  if (playback_mode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(playback_mode);
    if (message_arena != submessage_arena) {
      playback_mode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playback_mode, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.playback_mode_ = playback_mode;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Walk.playback_mode)
}

// string map_name = 7;
inline void Walk::clear_map_name() {
  _impl_.map_name_.ClearToEmpty();
}
inline const std::string& Walk::map_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Walk.map_name)
  return _internal_map_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Walk::set_map_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.map_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.Walk.map_name)
}
inline std::string* Walk::mutable_map_name() {
  std::string* _s = _internal_mutable_map_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Walk.map_name)
  return _s;
}
inline const std::string& Walk::_internal_map_name() const {
  return _impl_.map_name_.Get();
}
inline void Walk::_internal_set_map_name(const std::string& value) {
  
  _impl_.map_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Walk::_internal_mutable_map_name() {
  
  return _impl_.map_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Walk::release_map_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Walk.map_name)
  return _impl_.map_name_.Release();
}
inline void Walk::set_allocated_map_name(std::string* map_name) {
  if (map_name != nullptr) {
    
  } else {
    
  }
  _impl_.map_name_.SetAllocated(map_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.map_name_.IsDefault()) {
    _impl_.map_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Walk.map_name)
}

// string mission_name = 4;
inline void Walk::clear_mission_name() {
  _impl_.mission_name_.ClearToEmpty();
}
inline const std::string& Walk::mission_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Walk.mission_name)
  return _internal_mission_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Walk::set_mission_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mission_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.Walk.mission_name)
}
inline std::string* Walk::mutable_mission_name() {
  std::string* _s = _internal_mutable_mission_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Walk.mission_name)
  return _s;
}
inline const std::string& Walk::_internal_mission_name() const {
  return _impl_.mission_name_.Get();
}
inline void Walk::_internal_set_mission_name(const std::string& value) {
  
  _impl_.mission_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Walk::_internal_mutable_mission_name() {
  
  return _impl_.mission_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Walk::release_mission_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Walk.mission_name)
  return _impl_.mission_name_.Release();
}
inline void Walk::set_allocated_mission_name(std::string* mission_name) {
  if (mission_name != nullptr) {
    
  } else {
    
  }
  _impl_.mission_name_.SetAllocated(mission_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mission_name_.IsDefault()) {
    _impl_.mission_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Walk.mission_name)
}

// repeated .bosdyn.api.autowalk.Element elements = 5;
inline int Walk::_internal_elements_size() const {
  return _impl_.elements_.size();
}
inline int Walk::elements_size() const {
  return _internal_elements_size();
}
inline void Walk::clear_elements() {
  _impl_.elements_.Clear();
}
inline ::bosdyn::api::autowalk::Element* Walk::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Walk.elements)
  return _impl_.elements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::Element >*
Walk::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.autowalk.Walk.elements)
  return &_impl_.elements_;
}
inline const ::bosdyn::api::autowalk::Element& Walk::_internal_elements(int index) const {
  return _impl_.elements_.Get(index);
}
inline const ::bosdyn::api::autowalk::Element& Walk::elements(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Walk.elements)
  return _internal_elements(index);
}
inline ::bosdyn::api::autowalk::Element* Walk::_internal_add_elements() {
  return _impl_.elements_.Add();
}
inline ::bosdyn::api::autowalk::Element* Walk::add_elements() {
  ::bosdyn::api::autowalk::Element* _add = _internal_add_elements();
  // @@protoc_insertion_point(field_add:bosdyn.api.autowalk.Walk.elements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::Element >&
Walk::elements() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.autowalk.Walk.elements)
  return _impl_.elements_;
}

// repeated .bosdyn.api.autowalk.Dock docks = 6;
inline int Walk::_internal_docks_size() const {
  return _impl_.docks_.size();
}
inline int Walk::docks_size() const {
  return _internal_docks_size();
}
inline void Walk::clear_docks() {
  _impl_.docks_.Clear();
}
inline ::bosdyn::api::autowalk::Dock* Walk::mutable_docks(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Walk.docks)
  return _impl_.docks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::Dock >*
Walk::mutable_docks() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.autowalk.Walk.docks)
  return &_impl_.docks_;
}
inline const ::bosdyn::api::autowalk::Dock& Walk::_internal_docks(int index) const {
  return _impl_.docks_.Get(index);
}
inline const ::bosdyn::api::autowalk::Dock& Walk::docks(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Walk.docks)
  return _internal_docks(index);
}
inline ::bosdyn::api::autowalk::Dock* Walk::_internal_add_docks() {
  return _impl_.docks_.Add();
}
inline ::bosdyn::api::autowalk::Dock* Walk::add_docks() {
  ::bosdyn::api::autowalk::Dock* _add = _internal_add_docks();
  // @@protoc_insertion_point(field_add:bosdyn.api.autowalk.Walk.docks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::Dock >&
Walk::docks() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.autowalk.Walk.docks)
  return _impl_.docks_;
}

// -------------------------------------------------------------------

// GlobalParameters

// string group_name = 1;
inline void GlobalParameters::clear_group_name() {
  _impl_.group_name_.ClearToEmpty();
}
inline const std::string& GlobalParameters::group_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.GlobalParameters.group_name)
  return _internal_group_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GlobalParameters::set_group_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.group_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.GlobalParameters.group_name)
}
inline std::string* GlobalParameters::mutable_group_name() {
  std::string* _s = _internal_mutable_group_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.GlobalParameters.group_name)
  return _s;
}
inline const std::string& GlobalParameters::_internal_group_name() const {
  return _impl_.group_name_.Get();
}
inline void GlobalParameters::_internal_set_group_name(const std::string& value) {
  
  _impl_.group_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GlobalParameters::_internal_mutable_group_name() {
  
  return _impl_.group_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GlobalParameters::release_group_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.GlobalParameters.group_name)
  return _impl_.group_name_.Release();
}
inline void GlobalParameters::set_allocated_group_name(std::string* group_name) {
  if (group_name != nullptr) {
    
  } else {
    
  }
  _impl_.group_name_.SetAllocated(group_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_name_.IsDefault()) {
    _impl_.group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.GlobalParameters.group_name)
}

// bool should_autofocus_ptz = 2;
inline void GlobalParameters::clear_should_autofocus_ptz() {
  _impl_.should_autofocus_ptz_ = false;
}
inline bool GlobalParameters::_internal_should_autofocus_ptz() const {
  return _impl_.should_autofocus_ptz_;
}
inline bool GlobalParameters::should_autofocus_ptz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.GlobalParameters.should_autofocus_ptz)
  return _internal_should_autofocus_ptz();
}
inline void GlobalParameters::_internal_set_should_autofocus_ptz(bool value) {
  
  _impl_.should_autofocus_ptz_ = value;
}
inline void GlobalParameters::set_should_autofocus_ptz(bool value) {
  _internal_set_should_autofocus_ptz(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.GlobalParameters.should_autofocus_ptz)
}

// int32 self_right_attempts = 3;
inline void GlobalParameters::clear_self_right_attempts() {
  _impl_.self_right_attempts_ = 0;
}
inline int32_t GlobalParameters::_internal_self_right_attempts() const {
  return _impl_.self_right_attempts_;
}
inline int32_t GlobalParameters::self_right_attempts() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.GlobalParameters.self_right_attempts)
  return _internal_self_right_attempts();
}
inline void GlobalParameters::_internal_set_self_right_attempts(int32_t value) {
  
  _impl_.self_right_attempts_ = value;
}
inline void GlobalParameters::set_self_right_attempts(int32_t value) {
  _internal_set_self_right_attempts(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.GlobalParameters.self_right_attempts)
}

// repeated .bosdyn.api.autowalk.Action.RemoteGrpc post_mission_callbacks = 4;
inline int GlobalParameters::_internal_post_mission_callbacks_size() const {
  return _impl_.post_mission_callbacks_.size();
}
inline int GlobalParameters::post_mission_callbacks_size() const {
  return _internal_post_mission_callbacks_size();
}
inline void GlobalParameters::clear_post_mission_callbacks() {
  _impl_.post_mission_callbacks_.Clear();
}
inline ::bosdyn::api::autowalk::Action_RemoteGrpc* GlobalParameters::mutable_post_mission_callbacks(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.GlobalParameters.post_mission_callbacks)
  return _impl_.post_mission_callbacks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::Action_RemoteGrpc >*
GlobalParameters::mutable_post_mission_callbacks() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.autowalk.GlobalParameters.post_mission_callbacks)
  return &_impl_.post_mission_callbacks_;
}
inline const ::bosdyn::api::autowalk::Action_RemoteGrpc& GlobalParameters::_internal_post_mission_callbacks(int index) const {
  return _impl_.post_mission_callbacks_.Get(index);
}
inline const ::bosdyn::api::autowalk::Action_RemoteGrpc& GlobalParameters::post_mission_callbacks(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.GlobalParameters.post_mission_callbacks)
  return _internal_post_mission_callbacks(index);
}
inline ::bosdyn::api::autowalk::Action_RemoteGrpc* GlobalParameters::_internal_add_post_mission_callbacks() {
  return _impl_.post_mission_callbacks_.Add();
}
inline ::bosdyn::api::autowalk::Action_RemoteGrpc* GlobalParameters::add_post_mission_callbacks() {
  ::bosdyn::api::autowalk::Action_RemoteGrpc* _add = _internal_add_post_mission_callbacks();
  // @@protoc_insertion_point(field_add:bosdyn.api.autowalk.GlobalParameters.post_mission_callbacks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::Action_RemoteGrpc >&
GlobalParameters::post_mission_callbacks() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.autowalk.GlobalParameters.post_mission_callbacks)
  return _impl_.post_mission_callbacks_;
}

// bool skip_actions = 5;
inline void GlobalParameters::clear_skip_actions() {
  _impl_.skip_actions_ = false;
}
inline bool GlobalParameters::_internal_skip_actions() const {
  return _impl_.skip_actions_;
}
inline bool GlobalParameters::skip_actions() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.GlobalParameters.skip_actions)
  return _internal_skip_actions();
}
inline void GlobalParameters::_internal_set_skip_actions(bool value) {
  
  _impl_.skip_actions_ = value;
}
inline void GlobalParameters::set_skip_actions(bool value) {
  _internal_set_skip_actions(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.GlobalParameters.skip_actions)
}

// -------------------------------------------------------------------

// Dock

// uint32 dock_id = 1;
inline void Dock::clear_dock_id() {
  _impl_.dock_id_ = 0u;
}
inline uint32_t Dock::_internal_dock_id() const {
  return _impl_.dock_id_;
}
inline uint32_t Dock::dock_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Dock.dock_id)
  return _internal_dock_id();
}
inline void Dock::_internal_set_dock_id(uint32_t value) {
  
  _impl_.dock_id_ = value;
}
inline void Dock::set_dock_id(uint32_t value) {
  _internal_set_dock_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.Dock.dock_id)
}

// string docked_waypoint_id = 2;
inline void Dock::clear_docked_waypoint_id() {
  _impl_.docked_waypoint_id_.ClearToEmpty();
}
inline const std::string& Dock::docked_waypoint_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Dock.docked_waypoint_id)
  return _internal_docked_waypoint_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dock::set_docked_waypoint_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.docked_waypoint_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.Dock.docked_waypoint_id)
}
inline std::string* Dock::mutable_docked_waypoint_id() {
  std::string* _s = _internal_mutable_docked_waypoint_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Dock.docked_waypoint_id)
  return _s;
}
inline const std::string& Dock::_internal_docked_waypoint_id() const {
  return _impl_.docked_waypoint_id_.Get();
}
inline void Dock::_internal_set_docked_waypoint_id(const std::string& value) {
  
  _impl_.docked_waypoint_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Dock::_internal_mutable_docked_waypoint_id() {
  
  return _impl_.docked_waypoint_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Dock::release_docked_waypoint_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Dock.docked_waypoint_id)
  return _impl_.docked_waypoint_id_.Release();
}
inline void Dock::set_allocated_docked_waypoint_id(std::string* docked_waypoint_id) {
  if (docked_waypoint_id != nullptr) {
    
  } else {
    
  }
  _impl_.docked_waypoint_id_.SetAllocated(docked_waypoint_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.docked_waypoint_id_.IsDefault()) {
    _impl_.docked_waypoint_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Dock.docked_waypoint_id)
}

// .bosdyn.api.autowalk.Target target_prep_pose = 3;
inline bool Dock::_internal_has_target_prep_pose() const {
  return this != internal_default_instance() && _impl_.target_prep_pose_ != nullptr;
}
inline bool Dock::has_target_prep_pose() const {
  return _internal_has_target_prep_pose();
}
inline void Dock::clear_target_prep_pose() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_prep_pose_ != nullptr) {
    delete _impl_.target_prep_pose_;
  }
  _impl_.target_prep_pose_ = nullptr;
}
inline const ::bosdyn::api::autowalk::Target& Dock::_internal_target_prep_pose() const {
  const ::bosdyn::api::autowalk::Target* p = _impl_.target_prep_pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::Target&>(
      ::bosdyn::api::autowalk::_Target_default_instance_);
}
inline const ::bosdyn::api::autowalk::Target& Dock::target_prep_pose() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Dock.target_prep_pose)
  return _internal_target_prep_pose();
}
inline void Dock::unsafe_arena_set_allocated_target_prep_pose(
    ::bosdyn::api::autowalk::Target* target_prep_pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_prep_pose_);
  }
  _impl_.target_prep_pose_ = target_prep_pose;
  if (target_prep_pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Dock.target_prep_pose)
}
inline ::bosdyn::api::autowalk::Target* Dock::release_target_prep_pose() {
  
  ::bosdyn::api::autowalk::Target* temp = _impl_.target_prep_pose_;
  _impl_.target_prep_pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::Target* Dock::unsafe_arena_release_target_prep_pose() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Dock.target_prep_pose)
  
  ::bosdyn::api::autowalk::Target* temp = _impl_.target_prep_pose_;
  _impl_.target_prep_pose_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::Target* Dock::_internal_mutable_target_prep_pose() {
  
  if (_impl_.target_prep_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::Target>(GetArenaForAllocation());
    _impl_.target_prep_pose_ = p;
  }
  return _impl_.target_prep_pose_;
}
inline ::bosdyn::api::autowalk::Target* Dock::mutable_target_prep_pose() {
  ::bosdyn::api::autowalk::Target* _msg = _internal_mutable_target_prep_pose();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Dock.target_prep_pose)
  return _msg;
}
inline void Dock::set_allocated_target_prep_pose(::bosdyn::api::autowalk::Target* target_prep_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_prep_pose_;
  }
  if (target_prep_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_prep_pose);
    if (message_arena != submessage_arena) {
      target_prep_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_prep_pose, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_prep_pose_ = target_prep_pose;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Dock.target_prep_pose)
}

// .google.protobuf.Duration prompt_duration = 4;
inline bool Dock::_internal_has_prompt_duration() const {
  return this != internal_default_instance() && _impl_.prompt_duration_ != nullptr;
}
inline bool Dock::has_prompt_duration() const {
  return _internal_has_prompt_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Dock::_internal_prompt_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.prompt_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Dock::prompt_duration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Dock.prompt_duration)
  return _internal_prompt_duration();
}
inline void Dock::unsafe_arena_set_allocated_prompt_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* prompt_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prompt_duration_);
  }
  _impl_.prompt_duration_ = prompt_duration;
  if (prompt_duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Dock.prompt_duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Dock::release_prompt_duration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.prompt_duration_;
  _impl_.prompt_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Dock::unsafe_arena_release_prompt_duration() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Dock.prompt_duration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.prompt_duration_;
  _impl_.prompt_duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Dock::_internal_mutable_prompt_duration() {
  
  if (_impl_.prompt_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.prompt_duration_ = p;
  }
  return _impl_.prompt_duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Dock::mutable_prompt_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_prompt_duration();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Dock.prompt_duration)
  return _msg;
}
inline void Dock::set_allocated_prompt_duration(::PROTOBUF_NAMESPACE_ID::Duration* prompt_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prompt_duration_);
  }
  if (prompt_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prompt_duration));
    if (message_arena != submessage_arena) {
      prompt_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prompt_duration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.prompt_duration_ = prompt_duration;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Dock.prompt_duration)
}

// -------------------------------------------------------------------

// PlaybackMode_Once

// bool skip_docking_after_completion = 1;
inline void PlaybackMode_Once::clear_skip_docking_after_completion() {
  _impl_.skip_docking_after_completion_ = false;
}
inline bool PlaybackMode_Once::_internal_skip_docking_after_completion() const {
  return _impl_.skip_docking_after_completion_;
}
inline bool PlaybackMode_Once::skip_docking_after_completion() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.PlaybackMode.Once.skip_docking_after_completion)
  return _internal_skip_docking_after_completion();
}
inline void PlaybackMode_Once::_internal_set_skip_docking_after_completion(bool value) {
  
  _impl_.skip_docking_after_completion_ = value;
}
inline void PlaybackMode_Once::set_skip_docking_after_completion(bool value) {
  _internal_set_skip_docking_after_completion(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.PlaybackMode.Once.skip_docking_after_completion)
}

// -------------------------------------------------------------------

// PlaybackMode_Periodic

// .google.protobuf.Duration interval = 1;
inline bool PlaybackMode_Periodic::_internal_has_interval() const {
  return this != internal_default_instance() && _impl_.interval_ != nullptr;
}
inline bool PlaybackMode_Periodic::has_interval() const {
  return _internal_has_interval();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PlaybackMode_Periodic::_internal_interval() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PlaybackMode_Periodic::interval() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.PlaybackMode.Periodic.interval)
  return _internal_interval();
}
inline void PlaybackMode_Periodic::unsafe_arena_set_allocated_interval(
    ::PROTOBUF_NAMESPACE_ID::Duration* interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  _impl_.interval_ = interval;
  if (interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.PlaybackMode.Periodic.interval)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PlaybackMode_Periodic::release_interval() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PlaybackMode_Periodic::unsafe_arena_release_interval() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.PlaybackMode.Periodic.interval)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PlaybackMode_Periodic::_internal_mutable_interval() {
  
  if (_impl_.interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.interval_ = p;
  }
  return _impl_.interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PlaybackMode_Periodic::mutable_interval() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.PlaybackMode.Periodic.interval)
  return _msg;
}
inline void PlaybackMode_Periodic::set_allocated_interval(::PROTOBUF_NAMESPACE_ID::Duration* interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  if (interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interval));
    if (message_arena != submessage_arena) {
      interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.PlaybackMode.Periodic.interval)
}

// int32 repetitions = 2;
inline void PlaybackMode_Periodic::clear_repetitions() {
  _impl_.repetitions_ = 0;
}
inline int32_t PlaybackMode_Periodic::_internal_repetitions() const {
  return _impl_.repetitions_;
}
inline int32_t PlaybackMode_Periodic::repetitions() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.PlaybackMode.Periodic.repetitions)
  return _internal_repetitions();
}
inline void PlaybackMode_Periodic::_internal_set_repetitions(int32_t value) {
  
  _impl_.repetitions_ = value;
}
inline void PlaybackMode_Periodic::set_repetitions(int32_t value) {
  _internal_set_repetitions(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.PlaybackMode.Periodic.repetitions)
}

// -------------------------------------------------------------------

// PlaybackMode_Continuous

// -------------------------------------------------------------------

// PlaybackMode

// .bosdyn.api.autowalk.PlaybackMode.Once once = 2;
inline bool PlaybackMode::_internal_has_once() const {
  return mode_case() == kOnce;
}
inline bool PlaybackMode::has_once() const {
  return _internal_has_once();
}
inline void PlaybackMode::set_has_once() {
  _impl_._oneof_case_[0] = kOnce;
}
inline void PlaybackMode::clear_once() {
  if (_internal_has_once()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.mode_.once_;
    }
    clear_has_mode();
  }
}
inline ::bosdyn::api::autowalk::PlaybackMode_Once* PlaybackMode::release_once() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.PlaybackMode.once)
  if (_internal_has_once()) {
    clear_has_mode();
    ::bosdyn::api::autowalk::PlaybackMode_Once* temp = _impl_.mode_.once_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mode_.once_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::autowalk::PlaybackMode_Once& PlaybackMode::_internal_once() const {
  return _internal_has_once()
      ? *_impl_.mode_.once_
      : reinterpret_cast< ::bosdyn::api::autowalk::PlaybackMode_Once&>(::bosdyn::api::autowalk::_PlaybackMode_Once_default_instance_);
}
inline const ::bosdyn::api::autowalk::PlaybackMode_Once& PlaybackMode::once() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.PlaybackMode.once)
  return _internal_once();
}
inline ::bosdyn::api::autowalk::PlaybackMode_Once* PlaybackMode::unsafe_arena_release_once() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.autowalk.PlaybackMode.once)
  if (_internal_has_once()) {
    clear_has_mode();
    ::bosdyn::api::autowalk::PlaybackMode_Once* temp = _impl_.mode_.once_;
    _impl_.mode_.once_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlaybackMode::unsafe_arena_set_allocated_once(::bosdyn::api::autowalk::PlaybackMode_Once* once) {
  clear_mode();
  if (once) {
    set_has_once();
    _impl_.mode_.once_ = once;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.PlaybackMode.once)
}
inline ::bosdyn::api::autowalk::PlaybackMode_Once* PlaybackMode::_internal_mutable_once() {
  if (!_internal_has_once()) {
    clear_mode();
    set_has_once();
    _impl_.mode_.once_ = CreateMaybeMessage< ::bosdyn::api::autowalk::PlaybackMode_Once >(GetArenaForAllocation());
  }
  return _impl_.mode_.once_;
}
inline ::bosdyn::api::autowalk::PlaybackMode_Once* PlaybackMode::mutable_once() {
  ::bosdyn::api::autowalk::PlaybackMode_Once* _msg = _internal_mutable_once();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.PlaybackMode.once)
  return _msg;
}

// .bosdyn.api.autowalk.PlaybackMode.Periodic periodic = 3;
inline bool PlaybackMode::_internal_has_periodic() const {
  return mode_case() == kPeriodic;
}
inline bool PlaybackMode::has_periodic() const {
  return _internal_has_periodic();
}
inline void PlaybackMode::set_has_periodic() {
  _impl_._oneof_case_[0] = kPeriodic;
}
inline void PlaybackMode::clear_periodic() {
  if (_internal_has_periodic()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.mode_.periodic_;
    }
    clear_has_mode();
  }
}
inline ::bosdyn::api::autowalk::PlaybackMode_Periodic* PlaybackMode::release_periodic() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.PlaybackMode.periodic)
  if (_internal_has_periodic()) {
    clear_has_mode();
    ::bosdyn::api::autowalk::PlaybackMode_Periodic* temp = _impl_.mode_.periodic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mode_.periodic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::autowalk::PlaybackMode_Periodic& PlaybackMode::_internal_periodic() const {
  return _internal_has_periodic()
      ? *_impl_.mode_.periodic_
      : reinterpret_cast< ::bosdyn::api::autowalk::PlaybackMode_Periodic&>(::bosdyn::api::autowalk::_PlaybackMode_Periodic_default_instance_);
}
inline const ::bosdyn::api::autowalk::PlaybackMode_Periodic& PlaybackMode::periodic() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.PlaybackMode.periodic)
  return _internal_periodic();
}
inline ::bosdyn::api::autowalk::PlaybackMode_Periodic* PlaybackMode::unsafe_arena_release_periodic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.autowalk.PlaybackMode.periodic)
  if (_internal_has_periodic()) {
    clear_has_mode();
    ::bosdyn::api::autowalk::PlaybackMode_Periodic* temp = _impl_.mode_.periodic_;
    _impl_.mode_.periodic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlaybackMode::unsafe_arena_set_allocated_periodic(::bosdyn::api::autowalk::PlaybackMode_Periodic* periodic) {
  clear_mode();
  if (periodic) {
    set_has_periodic();
    _impl_.mode_.periodic_ = periodic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.PlaybackMode.periodic)
}
inline ::bosdyn::api::autowalk::PlaybackMode_Periodic* PlaybackMode::_internal_mutable_periodic() {
  if (!_internal_has_periodic()) {
    clear_mode();
    set_has_periodic();
    _impl_.mode_.periodic_ = CreateMaybeMessage< ::bosdyn::api::autowalk::PlaybackMode_Periodic >(GetArenaForAllocation());
  }
  return _impl_.mode_.periodic_;
}
inline ::bosdyn::api::autowalk::PlaybackMode_Periodic* PlaybackMode::mutable_periodic() {
  ::bosdyn::api::autowalk::PlaybackMode_Periodic* _msg = _internal_mutable_periodic();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.PlaybackMode.periodic)
  return _msg;
}

// .bosdyn.api.autowalk.PlaybackMode.Continuous continuous = 4;
inline bool PlaybackMode::_internal_has_continuous() const {
  return mode_case() == kContinuous;
}
inline bool PlaybackMode::has_continuous() const {
  return _internal_has_continuous();
}
inline void PlaybackMode::set_has_continuous() {
  _impl_._oneof_case_[0] = kContinuous;
}
inline void PlaybackMode::clear_continuous() {
  if (_internal_has_continuous()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.mode_.continuous_;
    }
    clear_has_mode();
  }
}
inline ::bosdyn::api::autowalk::PlaybackMode_Continuous* PlaybackMode::release_continuous() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.PlaybackMode.continuous)
  if (_internal_has_continuous()) {
    clear_has_mode();
    ::bosdyn::api::autowalk::PlaybackMode_Continuous* temp = _impl_.mode_.continuous_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mode_.continuous_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::autowalk::PlaybackMode_Continuous& PlaybackMode::_internal_continuous() const {
  return _internal_has_continuous()
      ? *_impl_.mode_.continuous_
      : reinterpret_cast< ::bosdyn::api::autowalk::PlaybackMode_Continuous&>(::bosdyn::api::autowalk::_PlaybackMode_Continuous_default_instance_);
}
inline const ::bosdyn::api::autowalk::PlaybackMode_Continuous& PlaybackMode::continuous() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.PlaybackMode.continuous)
  return _internal_continuous();
}
inline ::bosdyn::api::autowalk::PlaybackMode_Continuous* PlaybackMode::unsafe_arena_release_continuous() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.autowalk.PlaybackMode.continuous)
  if (_internal_has_continuous()) {
    clear_has_mode();
    ::bosdyn::api::autowalk::PlaybackMode_Continuous* temp = _impl_.mode_.continuous_;
    _impl_.mode_.continuous_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlaybackMode::unsafe_arena_set_allocated_continuous(::bosdyn::api::autowalk::PlaybackMode_Continuous* continuous) {
  clear_mode();
  if (continuous) {
    set_has_continuous();
    _impl_.mode_.continuous_ = continuous;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.PlaybackMode.continuous)
}
inline ::bosdyn::api::autowalk::PlaybackMode_Continuous* PlaybackMode::_internal_mutable_continuous() {
  if (!_internal_has_continuous()) {
    clear_mode();
    set_has_continuous();
    _impl_.mode_.continuous_ = CreateMaybeMessage< ::bosdyn::api::autowalk::PlaybackMode_Continuous >(GetArenaForAllocation());
  }
  return _impl_.mode_.continuous_;
}
inline ::bosdyn::api::autowalk::PlaybackMode_Continuous* PlaybackMode::mutable_continuous() {
  ::bosdyn::api::autowalk::PlaybackMode_Continuous* _msg = _internal_mutable_continuous();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.PlaybackMode.continuous)
  return _msg;
}

inline bool PlaybackMode::has_mode() const {
  return mode_case() != MODE_NOT_SET;
}
inline void PlaybackMode::clear_has_mode() {
  _impl_._oneof_case_[0] = MODE_NOT_SET;
}
inline PlaybackMode::ModeCase PlaybackMode::mode_case() const {
  return PlaybackMode::ModeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Element

// string name = 1;
inline void Element::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Element::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Element.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Element::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.Element.name)
}
inline std::string* Element::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Element.name)
  return _s;
}
inline const std::string& Element::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Element::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Element::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Element::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Element.name)
  return _impl_.name_.Release();
}
inline void Element::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Element.name)
}

// .bosdyn.api.autowalk.Target target = 2;
inline bool Element::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool Element::has_target() const {
  return _internal_has_target();
}
inline void Element::clear_target() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
}
inline const ::bosdyn::api::autowalk::Target& Element::_internal_target() const {
  const ::bosdyn::api::autowalk::Target* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::Target&>(
      ::bosdyn::api::autowalk::_Target_default_instance_);
}
inline const ::bosdyn::api::autowalk::Target& Element::target() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Element.target)
  return _internal_target();
}
inline void Element::unsafe_arena_set_allocated_target(
    ::bosdyn::api::autowalk::Target* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Element.target)
}
inline ::bosdyn::api::autowalk::Target* Element::release_target() {
  
  ::bosdyn::api::autowalk::Target* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::Target* Element::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Element.target)
  
  ::bosdyn::api::autowalk::Target* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::Target* Element::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::Target>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::bosdyn::api::autowalk::Target* Element::mutable_target() {
  ::bosdyn::api::autowalk::Target* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Element.target)
  return _msg;
}
inline void Element::set_allocated_target(::bosdyn::api::autowalk::Target* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Element.target)
}

// .bosdyn.api.autowalk.FailureBehavior target_failure_behavior = 3;
inline bool Element::_internal_has_target_failure_behavior() const {
  return this != internal_default_instance() && _impl_.target_failure_behavior_ != nullptr;
}
inline bool Element::has_target_failure_behavior() const {
  return _internal_has_target_failure_behavior();
}
inline void Element::clear_target_failure_behavior() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_failure_behavior_ != nullptr) {
    delete _impl_.target_failure_behavior_;
  }
  _impl_.target_failure_behavior_ = nullptr;
}
inline const ::bosdyn::api::autowalk::FailureBehavior& Element::_internal_target_failure_behavior() const {
  const ::bosdyn::api::autowalk::FailureBehavior* p = _impl_.target_failure_behavior_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::FailureBehavior&>(
      ::bosdyn::api::autowalk::_FailureBehavior_default_instance_);
}
inline const ::bosdyn::api::autowalk::FailureBehavior& Element::target_failure_behavior() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Element.target_failure_behavior)
  return _internal_target_failure_behavior();
}
inline void Element::unsafe_arena_set_allocated_target_failure_behavior(
    ::bosdyn::api::autowalk::FailureBehavior* target_failure_behavior) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_failure_behavior_);
  }
  _impl_.target_failure_behavior_ = target_failure_behavior;
  if (target_failure_behavior) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Element.target_failure_behavior)
}
inline ::bosdyn::api::autowalk::FailureBehavior* Element::release_target_failure_behavior() {
  
  ::bosdyn::api::autowalk::FailureBehavior* temp = _impl_.target_failure_behavior_;
  _impl_.target_failure_behavior_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::FailureBehavior* Element::unsafe_arena_release_target_failure_behavior() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Element.target_failure_behavior)
  
  ::bosdyn::api::autowalk::FailureBehavior* temp = _impl_.target_failure_behavior_;
  _impl_.target_failure_behavior_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::FailureBehavior* Element::_internal_mutable_target_failure_behavior() {
  
  if (_impl_.target_failure_behavior_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::FailureBehavior>(GetArenaForAllocation());
    _impl_.target_failure_behavior_ = p;
  }
  return _impl_.target_failure_behavior_;
}
inline ::bosdyn::api::autowalk::FailureBehavior* Element::mutable_target_failure_behavior() {
  ::bosdyn::api::autowalk::FailureBehavior* _msg = _internal_mutable_target_failure_behavior();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Element.target_failure_behavior)
  return _msg;
}
inline void Element::set_allocated_target_failure_behavior(::bosdyn::api::autowalk::FailureBehavior* target_failure_behavior) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_failure_behavior_;
  }
  if (target_failure_behavior) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_failure_behavior);
    if (message_arena != submessage_arena) {
      target_failure_behavior = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_failure_behavior, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_failure_behavior_ = target_failure_behavior;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Element.target_failure_behavior)
}

// .bosdyn.api.autowalk.Action action = 4;
inline bool Element::_internal_has_action() const {
  return this != internal_default_instance() && _impl_.action_ != nullptr;
}
inline bool Element::has_action() const {
  return _internal_has_action();
}
inline void Element::clear_action() {
  if (GetArenaForAllocation() == nullptr && _impl_.action_ != nullptr) {
    delete _impl_.action_;
  }
  _impl_.action_ = nullptr;
}
inline const ::bosdyn::api::autowalk::Action& Element::_internal_action() const {
  const ::bosdyn::api::autowalk::Action* p = _impl_.action_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::Action&>(
      ::bosdyn::api::autowalk::_Action_default_instance_);
}
inline const ::bosdyn::api::autowalk::Action& Element::action() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Element.action)
  return _internal_action();
}
inline void Element::unsafe_arena_set_allocated_action(
    ::bosdyn::api::autowalk::Action* action) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.action_);
  }
  _impl_.action_ = action;
  if (action) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Element.action)
}
inline ::bosdyn::api::autowalk::Action* Element::release_action() {
  
  ::bosdyn::api::autowalk::Action* temp = _impl_.action_;
  _impl_.action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::Action* Element::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Element.action)
  
  ::bosdyn::api::autowalk::Action* temp = _impl_.action_;
  _impl_.action_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::Action* Element::_internal_mutable_action() {
  
  if (_impl_.action_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::Action>(GetArenaForAllocation());
    _impl_.action_ = p;
  }
  return _impl_.action_;
}
inline ::bosdyn::api::autowalk::Action* Element::mutable_action() {
  ::bosdyn::api::autowalk::Action* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Element.action)
  return _msg;
}
inline void Element::set_allocated_action(::bosdyn::api::autowalk::Action* action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.action_;
  }
  if (action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(action);
    if (message_arena != submessage_arena) {
      action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.action_ = action;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Element.action)
}

// .bosdyn.api.autowalk.ActionWrapper action_wrapper = 5;
inline bool Element::_internal_has_action_wrapper() const {
  return this != internal_default_instance() && _impl_.action_wrapper_ != nullptr;
}
inline bool Element::has_action_wrapper() const {
  return _internal_has_action_wrapper();
}
inline void Element::clear_action_wrapper() {
  if (GetArenaForAllocation() == nullptr && _impl_.action_wrapper_ != nullptr) {
    delete _impl_.action_wrapper_;
  }
  _impl_.action_wrapper_ = nullptr;
}
inline const ::bosdyn::api::autowalk::ActionWrapper& Element::_internal_action_wrapper() const {
  const ::bosdyn::api::autowalk::ActionWrapper* p = _impl_.action_wrapper_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::ActionWrapper&>(
      ::bosdyn::api::autowalk::_ActionWrapper_default_instance_);
}
inline const ::bosdyn::api::autowalk::ActionWrapper& Element::action_wrapper() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Element.action_wrapper)
  return _internal_action_wrapper();
}
inline void Element::unsafe_arena_set_allocated_action_wrapper(
    ::bosdyn::api::autowalk::ActionWrapper* action_wrapper) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.action_wrapper_);
  }
  _impl_.action_wrapper_ = action_wrapper;
  if (action_wrapper) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Element.action_wrapper)
}
inline ::bosdyn::api::autowalk::ActionWrapper* Element::release_action_wrapper() {
  
  ::bosdyn::api::autowalk::ActionWrapper* temp = _impl_.action_wrapper_;
  _impl_.action_wrapper_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::ActionWrapper* Element::unsafe_arena_release_action_wrapper() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Element.action_wrapper)
  
  ::bosdyn::api::autowalk::ActionWrapper* temp = _impl_.action_wrapper_;
  _impl_.action_wrapper_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::ActionWrapper* Element::_internal_mutable_action_wrapper() {
  
  if (_impl_.action_wrapper_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper>(GetArenaForAllocation());
    _impl_.action_wrapper_ = p;
  }
  return _impl_.action_wrapper_;
}
inline ::bosdyn::api::autowalk::ActionWrapper* Element::mutable_action_wrapper() {
  ::bosdyn::api::autowalk::ActionWrapper* _msg = _internal_mutable_action_wrapper();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Element.action_wrapper)
  return _msg;
}
inline void Element::set_allocated_action_wrapper(::bosdyn::api::autowalk::ActionWrapper* action_wrapper) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.action_wrapper_;
  }
  if (action_wrapper) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(action_wrapper);
    if (message_arena != submessage_arena) {
      action_wrapper = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action_wrapper, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.action_wrapper_ = action_wrapper;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Element.action_wrapper)
}

// .bosdyn.api.autowalk.FailureBehavior action_failure_behavior = 6;
inline bool Element::_internal_has_action_failure_behavior() const {
  return this != internal_default_instance() && _impl_.action_failure_behavior_ != nullptr;
}
inline bool Element::has_action_failure_behavior() const {
  return _internal_has_action_failure_behavior();
}
inline void Element::clear_action_failure_behavior() {
  if (GetArenaForAllocation() == nullptr && _impl_.action_failure_behavior_ != nullptr) {
    delete _impl_.action_failure_behavior_;
  }
  _impl_.action_failure_behavior_ = nullptr;
}
inline const ::bosdyn::api::autowalk::FailureBehavior& Element::_internal_action_failure_behavior() const {
  const ::bosdyn::api::autowalk::FailureBehavior* p = _impl_.action_failure_behavior_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::FailureBehavior&>(
      ::bosdyn::api::autowalk::_FailureBehavior_default_instance_);
}
inline const ::bosdyn::api::autowalk::FailureBehavior& Element::action_failure_behavior() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Element.action_failure_behavior)
  return _internal_action_failure_behavior();
}
inline void Element::unsafe_arena_set_allocated_action_failure_behavior(
    ::bosdyn::api::autowalk::FailureBehavior* action_failure_behavior) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.action_failure_behavior_);
  }
  _impl_.action_failure_behavior_ = action_failure_behavior;
  if (action_failure_behavior) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Element.action_failure_behavior)
}
inline ::bosdyn::api::autowalk::FailureBehavior* Element::release_action_failure_behavior() {
  
  ::bosdyn::api::autowalk::FailureBehavior* temp = _impl_.action_failure_behavior_;
  _impl_.action_failure_behavior_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::FailureBehavior* Element::unsafe_arena_release_action_failure_behavior() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Element.action_failure_behavior)
  
  ::bosdyn::api::autowalk::FailureBehavior* temp = _impl_.action_failure_behavior_;
  _impl_.action_failure_behavior_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::FailureBehavior* Element::_internal_mutable_action_failure_behavior() {
  
  if (_impl_.action_failure_behavior_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::FailureBehavior>(GetArenaForAllocation());
    _impl_.action_failure_behavior_ = p;
  }
  return _impl_.action_failure_behavior_;
}
inline ::bosdyn::api::autowalk::FailureBehavior* Element::mutable_action_failure_behavior() {
  ::bosdyn::api::autowalk::FailureBehavior* _msg = _internal_mutable_action_failure_behavior();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Element.action_failure_behavior)
  return _msg;
}
inline void Element::set_allocated_action_failure_behavior(::bosdyn::api::autowalk::FailureBehavior* action_failure_behavior) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.action_failure_behavior_;
  }
  if (action_failure_behavior) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(action_failure_behavior);
    if (message_arena != submessage_arena) {
      action_failure_behavior = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action_failure_behavior, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.action_failure_behavior_ = action_failure_behavior;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Element.action_failure_behavior)
}

// bool is_skipped = 7;
inline void Element::clear_is_skipped() {
  _impl_.is_skipped_ = false;
}
inline bool Element::_internal_is_skipped() const {
  return _impl_.is_skipped_;
}
inline bool Element::is_skipped() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Element.is_skipped)
  return _internal_is_skipped();
}
inline void Element::_internal_set_is_skipped(bool value) {
  
  _impl_.is_skipped_ = value;
}
inline void Element::set_is_skipped(bool value) {
  _internal_set_is_skipped(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.Element.is_skipped)
}

// .bosdyn.api.autowalk.BatteryMonitor battery_monitor = 8;
inline bool Element::_internal_has_battery_monitor() const {
  return this != internal_default_instance() && _impl_.battery_monitor_ != nullptr;
}
inline bool Element::has_battery_monitor() const {
  return _internal_has_battery_monitor();
}
inline void Element::clear_battery_monitor() {
  if (GetArenaForAllocation() == nullptr && _impl_.battery_monitor_ != nullptr) {
    delete _impl_.battery_monitor_;
  }
  _impl_.battery_monitor_ = nullptr;
}
inline const ::bosdyn::api::autowalk::BatteryMonitor& Element::_internal_battery_monitor() const {
  const ::bosdyn::api::autowalk::BatteryMonitor* p = _impl_.battery_monitor_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::BatteryMonitor&>(
      ::bosdyn::api::autowalk::_BatteryMonitor_default_instance_);
}
inline const ::bosdyn::api::autowalk::BatteryMonitor& Element::battery_monitor() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Element.battery_monitor)
  return _internal_battery_monitor();
}
inline void Element::unsafe_arena_set_allocated_battery_monitor(
    ::bosdyn::api::autowalk::BatteryMonitor* battery_monitor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.battery_monitor_);
  }
  _impl_.battery_monitor_ = battery_monitor;
  if (battery_monitor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Element.battery_monitor)
}
inline ::bosdyn::api::autowalk::BatteryMonitor* Element::release_battery_monitor() {
  
  ::bosdyn::api::autowalk::BatteryMonitor* temp = _impl_.battery_monitor_;
  _impl_.battery_monitor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::BatteryMonitor* Element::unsafe_arena_release_battery_monitor() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Element.battery_monitor)
  
  ::bosdyn::api::autowalk::BatteryMonitor* temp = _impl_.battery_monitor_;
  _impl_.battery_monitor_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::BatteryMonitor* Element::_internal_mutable_battery_monitor() {
  
  if (_impl_.battery_monitor_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::BatteryMonitor>(GetArenaForAllocation());
    _impl_.battery_monitor_ = p;
  }
  return _impl_.battery_monitor_;
}
inline ::bosdyn::api::autowalk::BatteryMonitor* Element::mutable_battery_monitor() {
  ::bosdyn::api::autowalk::BatteryMonitor* _msg = _internal_mutable_battery_monitor();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Element.battery_monitor)
  return _msg;
}
inline void Element::set_allocated_battery_monitor(::bosdyn::api::autowalk::BatteryMonitor* battery_monitor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.battery_monitor_;
  }
  if (battery_monitor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(battery_monitor);
    if (message_arena != submessage_arena) {
      battery_monitor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, battery_monitor, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.battery_monitor_ = battery_monitor;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Element.battery_monitor)
}

// .google.protobuf.Duration action_duration = 9;
inline bool Element::_internal_has_action_duration() const {
  return this != internal_default_instance() && _impl_.action_duration_ != nullptr;
}
inline bool Element::has_action_duration() const {
  return _internal_has_action_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Element::_internal_action_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.action_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Element::action_duration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Element.action_duration)
  return _internal_action_duration();
}
inline void Element::unsafe_arena_set_allocated_action_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* action_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.action_duration_);
  }
  _impl_.action_duration_ = action_duration;
  if (action_duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Element.action_duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Element::release_action_duration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.action_duration_;
  _impl_.action_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Element::unsafe_arena_release_action_duration() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Element.action_duration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.action_duration_;
  _impl_.action_duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Element::_internal_mutable_action_duration() {
  
  if (_impl_.action_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.action_duration_ = p;
  }
  return _impl_.action_duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Element::mutable_action_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_action_duration();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Element.action_duration)
  return _msg;
}
inline void Element::set_allocated_action_duration(::PROTOBUF_NAMESPACE_ID::Duration* action_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.action_duration_);
  }
  if (action_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_duration));
    if (message_arena != submessage_arena) {
      action_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action_duration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.action_duration_ = action_duration;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Element.action_duration)
}

// -------------------------------------------------------------------

// Target_Relocalize

// .bosdyn.api.graph_nav.SetLocalizationRequest set_localization_request = 1;
inline bool Target_Relocalize::_internal_has_set_localization_request() const {
  return this != internal_default_instance() && _impl_.set_localization_request_ != nullptr;
}
inline bool Target_Relocalize::has_set_localization_request() const {
  return _internal_has_set_localization_request();
}
inline const ::bosdyn::api::graph_nav::SetLocalizationRequest& Target_Relocalize::_internal_set_localization_request() const {
  const ::bosdyn::api::graph_nav::SetLocalizationRequest* p = _impl_.set_localization_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::SetLocalizationRequest&>(
      ::bosdyn::api::graph_nav::_SetLocalizationRequest_default_instance_);
}
inline const ::bosdyn::api::graph_nav::SetLocalizationRequest& Target_Relocalize::set_localization_request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Target.Relocalize.set_localization_request)
  return _internal_set_localization_request();
}
inline void Target_Relocalize::unsafe_arena_set_allocated_set_localization_request(
    ::bosdyn::api::graph_nav::SetLocalizationRequest* set_localization_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.set_localization_request_);
  }
  _impl_.set_localization_request_ = set_localization_request;
  if (set_localization_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Target.Relocalize.set_localization_request)
}
inline ::bosdyn::api::graph_nav::SetLocalizationRequest* Target_Relocalize::release_set_localization_request() {
  
  ::bosdyn::api::graph_nav::SetLocalizationRequest* temp = _impl_.set_localization_request_;
  _impl_.set_localization_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::SetLocalizationRequest* Target_Relocalize::unsafe_arena_release_set_localization_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Target.Relocalize.set_localization_request)
  
  ::bosdyn::api::graph_nav::SetLocalizationRequest* temp = _impl_.set_localization_request_;
  _impl_.set_localization_request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::SetLocalizationRequest* Target_Relocalize::_internal_mutable_set_localization_request() {
  
  if (_impl_.set_localization_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::SetLocalizationRequest>(GetArenaForAllocation());
    _impl_.set_localization_request_ = p;
  }
  return _impl_.set_localization_request_;
}
inline ::bosdyn::api::graph_nav::SetLocalizationRequest* Target_Relocalize::mutable_set_localization_request() {
  ::bosdyn::api::graph_nav::SetLocalizationRequest* _msg = _internal_mutable_set_localization_request();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Target.Relocalize.set_localization_request)
  return _msg;
}
inline void Target_Relocalize::set_allocated_set_localization_request(::bosdyn::api::graph_nav::SetLocalizationRequest* set_localization_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.set_localization_request_);
  }
  if (set_localization_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(set_localization_request));
    if (message_arena != submessage_arena) {
      set_localization_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_localization_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.set_localization_request_ = set_localization_request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Target.Relocalize.set_localization_request)
}

// -------------------------------------------------------------------

// Target_NavigateTo

// string destination_waypoint_id = 1;
inline void Target_NavigateTo::clear_destination_waypoint_id() {
  _impl_.destination_waypoint_id_.ClearToEmpty();
}
inline const std::string& Target_NavigateTo::destination_waypoint_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Target.NavigateTo.destination_waypoint_id)
  return _internal_destination_waypoint_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Target_NavigateTo::set_destination_waypoint_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.destination_waypoint_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.Target.NavigateTo.destination_waypoint_id)
}
inline std::string* Target_NavigateTo::mutable_destination_waypoint_id() {
  std::string* _s = _internal_mutable_destination_waypoint_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Target.NavigateTo.destination_waypoint_id)
  return _s;
}
inline const std::string& Target_NavigateTo::_internal_destination_waypoint_id() const {
  return _impl_.destination_waypoint_id_.Get();
}
inline void Target_NavigateTo::_internal_set_destination_waypoint_id(const std::string& value) {
  
  _impl_.destination_waypoint_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Target_NavigateTo::_internal_mutable_destination_waypoint_id() {
  
  return _impl_.destination_waypoint_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Target_NavigateTo::release_destination_waypoint_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Target.NavigateTo.destination_waypoint_id)
  return _impl_.destination_waypoint_id_.Release();
}
inline void Target_NavigateTo::set_allocated_destination_waypoint_id(std::string* destination_waypoint_id) {
  if (destination_waypoint_id != nullptr) {
    
  } else {
    
  }
  _impl_.destination_waypoint_id_.SetAllocated(destination_waypoint_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destination_waypoint_id_.IsDefault()) {
    _impl_.destination_waypoint_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Target.NavigateTo.destination_waypoint_id)
}

// .bosdyn.api.graph_nav.TravelParams travel_params = 3;
inline bool Target_NavigateTo::_internal_has_travel_params() const {
  return this != internal_default_instance() && _impl_.travel_params_ != nullptr;
}
inline bool Target_NavigateTo::has_travel_params() const {
  return _internal_has_travel_params();
}
inline const ::bosdyn::api::graph_nav::TravelParams& Target_NavigateTo::_internal_travel_params() const {
  const ::bosdyn::api::graph_nav::TravelParams* p = _impl_.travel_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::TravelParams&>(
      ::bosdyn::api::graph_nav::_TravelParams_default_instance_);
}
inline const ::bosdyn::api::graph_nav::TravelParams& Target_NavigateTo::travel_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Target.NavigateTo.travel_params)
  return _internal_travel_params();
}
inline void Target_NavigateTo::unsafe_arena_set_allocated_travel_params(
    ::bosdyn::api::graph_nav::TravelParams* travel_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.travel_params_);
  }
  _impl_.travel_params_ = travel_params;
  if (travel_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Target.NavigateTo.travel_params)
}
inline ::bosdyn::api::graph_nav::TravelParams* Target_NavigateTo::release_travel_params() {
  
  ::bosdyn::api::graph_nav::TravelParams* temp = _impl_.travel_params_;
  _impl_.travel_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::TravelParams* Target_NavigateTo::unsafe_arena_release_travel_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Target.NavigateTo.travel_params)
  
  ::bosdyn::api::graph_nav::TravelParams* temp = _impl_.travel_params_;
  _impl_.travel_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::TravelParams* Target_NavigateTo::_internal_mutable_travel_params() {
  
  if (_impl_.travel_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::TravelParams>(GetArenaForAllocation());
    _impl_.travel_params_ = p;
  }
  return _impl_.travel_params_;
}
inline ::bosdyn::api::graph_nav::TravelParams* Target_NavigateTo::mutable_travel_params() {
  ::bosdyn::api::graph_nav::TravelParams* _msg = _internal_mutable_travel_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Target.NavigateTo.travel_params)
  return _msg;
}
inline void Target_NavigateTo::set_allocated_travel_params(::bosdyn::api::graph_nav::TravelParams* travel_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.travel_params_);
  }
  if (travel_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(travel_params));
    if (message_arena != submessage_arena) {
      travel_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, travel_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.travel_params_ = travel_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Target.NavigateTo.travel_params)
}

// -------------------------------------------------------------------

// Target_NavigateRoute

// .bosdyn.api.graph_nav.Route route = 1;
inline bool Target_NavigateRoute::_internal_has_route() const {
  return this != internal_default_instance() && _impl_.route_ != nullptr;
}
inline bool Target_NavigateRoute::has_route() const {
  return _internal_has_route();
}
inline const ::bosdyn::api::graph_nav::Route& Target_NavigateRoute::_internal_route() const {
  const ::bosdyn::api::graph_nav::Route* p = _impl_.route_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::Route&>(
      ::bosdyn::api::graph_nav::_Route_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Route& Target_NavigateRoute::route() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Target.NavigateRoute.route)
  return _internal_route();
}
inline void Target_NavigateRoute::unsafe_arena_set_allocated_route(
    ::bosdyn::api::graph_nav::Route* route) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_);
  }
  _impl_.route_ = route;
  if (route) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Target.NavigateRoute.route)
}
inline ::bosdyn::api::graph_nav::Route* Target_NavigateRoute::release_route() {
  
  ::bosdyn::api::graph_nav::Route* temp = _impl_.route_;
  _impl_.route_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::Route* Target_NavigateRoute::unsafe_arena_release_route() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Target.NavigateRoute.route)
  
  ::bosdyn::api::graph_nav::Route* temp = _impl_.route_;
  _impl_.route_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Route* Target_NavigateRoute::_internal_mutable_route() {
  
  if (_impl_.route_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Route>(GetArenaForAllocation());
    _impl_.route_ = p;
  }
  return _impl_.route_;
}
inline ::bosdyn::api::graph_nav::Route* Target_NavigateRoute::mutable_route() {
  ::bosdyn::api::graph_nav::Route* _msg = _internal_mutable_route();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Target.NavigateRoute.route)
  return _msg;
}
inline void Target_NavigateRoute::set_allocated_route(::bosdyn::api::graph_nav::Route* route) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_);
  }
  if (route) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(route));
    if (message_arena != submessage_arena) {
      route = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.route_ = route;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Target.NavigateRoute.route)
}

// .bosdyn.api.graph_nav.TravelParams travel_params = 2;
inline bool Target_NavigateRoute::_internal_has_travel_params() const {
  return this != internal_default_instance() && _impl_.travel_params_ != nullptr;
}
inline bool Target_NavigateRoute::has_travel_params() const {
  return _internal_has_travel_params();
}
inline const ::bosdyn::api::graph_nav::TravelParams& Target_NavigateRoute::_internal_travel_params() const {
  const ::bosdyn::api::graph_nav::TravelParams* p = _impl_.travel_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::TravelParams&>(
      ::bosdyn::api::graph_nav::_TravelParams_default_instance_);
}
inline const ::bosdyn::api::graph_nav::TravelParams& Target_NavigateRoute::travel_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Target.NavigateRoute.travel_params)
  return _internal_travel_params();
}
inline void Target_NavigateRoute::unsafe_arena_set_allocated_travel_params(
    ::bosdyn::api::graph_nav::TravelParams* travel_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.travel_params_);
  }
  _impl_.travel_params_ = travel_params;
  if (travel_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Target.NavigateRoute.travel_params)
}
inline ::bosdyn::api::graph_nav::TravelParams* Target_NavigateRoute::release_travel_params() {
  
  ::bosdyn::api::graph_nav::TravelParams* temp = _impl_.travel_params_;
  _impl_.travel_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::TravelParams* Target_NavigateRoute::unsafe_arena_release_travel_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Target.NavigateRoute.travel_params)
  
  ::bosdyn::api::graph_nav::TravelParams* temp = _impl_.travel_params_;
  _impl_.travel_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::TravelParams* Target_NavigateRoute::_internal_mutable_travel_params() {
  
  if (_impl_.travel_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::TravelParams>(GetArenaForAllocation());
    _impl_.travel_params_ = p;
  }
  return _impl_.travel_params_;
}
inline ::bosdyn::api::graph_nav::TravelParams* Target_NavigateRoute::mutable_travel_params() {
  ::bosdyn::api::graph_nav::TravelParams* _msg = _internal_mutable_travel_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Target.NavigateRoute.travel_params)
  return _msg;
}
inline void Target_NavigateRoute::set_allocated_travel_params(::bosdyn::api::graph_nav::TravelParams* travel_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.travel_params_);
  }
  if (travel_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(travel_params));
    if (message_arena != submessage_arena) {
      travel_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, travel_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.travel_params_ = travel_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Target.NavigateRoute.travel_params)
}

// -------------------------------------------------------------------

// Target

// .bosdyn.api.autowalk.Target.NavigateTo navigate_to = 1;
inline bool Target::_internal_has_navigate_to() const {
  return target_case() == kNavigateTo;
}
inline bool Target::has_navigate_to() const {
  return _internal_has_navigate_to();
}
inline void Target::set_has_navigate_to() {
  _impl_._oneof_case_[0] = kNavigateTo;
}
inline void Target::clear_navigate_to() {
  if (_internal_has_navigate_to()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.target_.navigate_to_;
    }
    clear_has_target();
  }
}
inline ::bosdyn::api::autowalk::Target_NavigateTo* Target::release_navigate_to() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Target.navigate_to)
  if (_internal_has_navigate_to()) {
    clear_has_target();
    ::bosdyn::api::autowalk::Target_NavigateTo* temp = _impl_.target_.navigate_to_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.target_.navigate_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::autowalk::Target_NavigateTo& Target::_internal_navigate_to() const {
  return _internal_has_navigate_to()
      ? *_impl_.target_.navigate_to_
      : reinterpret_cast< ::bosdyn::api::autowalk::Target_NavigateTo&>(::bosdyn::api::autowalk::_Target_NavigateTo_default_instance_);
}
inline const ::bosdyn::api::autowalk::Target_NavigateTo& Target::navigate_to() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Target.navigate_to)
  return _internal_navigate_to();
}
inline ::bosdyn::api::autowalk::Target_NavigateTo* Target::unsafe_arena_release_navigate_to() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.autowalk.Target.navigate_to)
  if (_internal_has_navigate_to()) {
    clear_has_target();
    ::bosdyn::api::autowalk::Target_NavigateTo* temp = _impl_.target_.navigate_to_;
    _impl_.target_.navigate_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Target::unsafe_arena_set_allocated_navigate_to(::bosdyn::api::autowalk::Target_NavigateTo* navigate_to) {
  clear_target();
  if (navigate_to) {
    set_has_navigate_to();
    _impl_.target_.navigate_to_ = navigate_to;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Target.navigate_to)
}
inline ::bosdyn::api::autowalk::Target_NavigateTo* Target::_internal_mutable_navigate_to() {
  if (!_internal_has_navigate_to()) {
    clear_target();
    set_has_navigate_to();
    _impl_.target_.navigate_to_ = CreateMaybeMessage< ::bosdyn::api::autowalk::Target_NavigateTo >(GetArenaForAllocation());
  }
  return _impl_.target_.navigate_to_;
}
inline ::bosdyn::api::autowalk::Target_NavigateTo* Target::mutable_navigate_to() {
  ::bosdyn::api::autowalk::Target_NavigateTo* _msg = _internal_mutable_navigate_to();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Target.navigate_to)
  return _msg;
}

// .bosdyn.api.autowalk.Target.NavigateRoute navigate_route = 2;
inline bool Target::_internal_has_navigate_route() const {
  return target_case() == kNavigateRoute;
}
inline bool Target::has_navigate_route() const {
  return _internal_has_navigate_route();
}
inline void Target::set_has_navigate_route() {
  _impl_._oneof_case_[0] = kNavigateRoute;
}
inline void Target::clear_navigate_route() {
  if (_internal_has_navigate_route()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.target_.navigate_route_;
    }
    clear_has_target();
  }
}
inline ::bosdyn::api::autowalk::Target_NavigateRoute* Target::release_navigate_route() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Target.navigate_route)
  if (_internal_has_navigate_route()) {
    clear_has_target();
    ::bosdyn::api::autowalk::Target_NavigateRoute* temp = _impl_.target_.navigate_route_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.target_.navigate_route_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::autowalk::Target_NavigateRoute& Target::_internal_navigate_route() const {
  return _internal_has_navigate_route()
      ? *_impl_.target_.navigate_route_
      : reinterpret_cast< ::bosdyn::api::autowalk::Target_NavigateRoute&>(::bosdyn::api::autowalk::_Target_NavigateRoute_default_instance_);
}
inline const ::bosdyn::api::autowalk::Target_NavigateRoute& Target::navigate_route() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Target.navigate_route)
  return _internal_navigate_route();
}
inline ::bosdyn::api::autowalk::Target_NavigateRoute* Target::unsafe_arena_release_navigate_route() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.autowalk.Target.navigate_route)
  if (_internal_has_navigate_route()) {
    clear_has_target();
    ::bosdyn::api::autowalk::Target_NavigateRoute* temp = _impl_.target_.navigate_route_;
    _impl_.target_.navigate_route_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Target::unsafe_arena_set_allocated_navigate_route(::bosdyn::api::autowalk::Target_NavigateRoute* navigate_route) {
  clear_target();
  if (navigate_route) {
    set_has_navigate_route();
    _impl_.target_.navigate_route_ = navigate_route;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Target.navigate_route)
}
inline ::bosdyn::api::autowalk::Target_NavigateRoute* Target::_internal_mutable_navigate_route() {
  if (!_internal_has_navigate_route()) {
    clear_target();
    set_has_navigate_route();
    _impl_.target_.navigate_route_ = CreateMaybeMessage< ::bosdyn::api::autowalk::Target_NavigateRoute >(GetArenaForAllocation());
  }
  return _impl_.target_.navigate_route_;
}
inline ::bosdyn::api::autowalk::Target_NavigateRoute* Target::mutable_navigate_route() {
  ::bosdyn::api::autowalk::Target_NavigateRoute* _msg = _internal_mutable_navigate_route();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Target.navigate_route)
  return _msg;
}

// .bosdyn.api.autowalk.Target.Relocalize relocalize = 3;
inline bool Target::_internal_has_relocalize() const {
  return this != internal_default_instance() && _impl_.relocalize_ != nullptr;
}
inline bool Target::has_relocalize() const {
  return _internal_has_relocalize();
}
inline void Target::clear_relocalize() {
  if (GetArenaForAllocation() == nullptr && _impl_.relocalize_ != nullptr) {
    delete _impl_.relocalize_;
  }
  _impl_.relocalize_ = nullptr;
}
inline const ::bosdyn::api::autowalk::Target_Relocalize& Target::_internal_relocalize() const {
  const ::bosdyn::api::autowalk::Target_Relocalize* p = _impl_.relocalize_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::Target_Relocalize&>(
      ::bosdyn::api::autowalk::_Target_Relocalize_default_instance_);
}
inline const ::bosdyn::api::autowalk::Target_Relocalize& Target::relocalize() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Target.relocalize)
  return _internal_relocalize();
}
inline void Target::unsafe_arena_set_allocated_relocalize(
    ::bosdyn::api::autowalk::Target_Relocalize* relocalize) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relocalize_);
  }
  _impl_.relocalize_ = relocalize;
  if (relocalize) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Target.relocalize)
}
inline ::bosdyn::api::autowalk::Target_Relocalize* Target::release_relocalize() {
  
  ::bosdyn::api::autowalk::Target_Relocalize* temp = _impl_.relocalize_;
  _impl_.relocalize_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::Target_Relocalize* Target::unsafe_arena_release_relocalize() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Target.relocalize)
  
  ::bosdyn::api::autowalk::Target_Relocalize* temp = _impl_.relocalize_;
  _impl_.relocalize_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::Target_Relocalize* Target::_internal_mutable_relocalize() {
  
  if (_impl_.relocalize_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::Target_Relocalize>(GetArenaForAllocation());
    _impl_.relocalize_ = p;
  }
  return _impl_.relocalize_;
}
inline ::bosdyn::api::autowalk::Target_Relocalize* Target::mutable_relocalize() {
  ::bosdyn::api::autowalk::Target_Relocalize* _msg = _internal_mutable_relocalize();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Target.relocalize)
  return _msg;
}
inline void Target::set_allocated_relocalize(::bosdyn::api::autowalk::Target_Relocalize* relocalize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.relocalize_;
  }
  if (relocalize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(relocalize);
    if (message_arena != submessage_arena) {
      relocalize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relocalize, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.relocalize_ = relocalize;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Target.relocalize)
}

inline bool Target::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void Target::clear_has_target() {
  _impl_._oneof_case_[0] = TARGET_NOT_SET;
}
inline Target::TargetCase Target::target_case() const {
  return Target::TargetCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Action_Sleep

// .google.protobuf.Duration duration = 2;
inline bool Action_Sleep::_internal_has_duration() const {
  return this != internal_default_instance() && _impl_.duration_ != nullptr;
}
inline bool Action_Sleep::has_duration() const {
  return _internal_has_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Action_Sleep::_internal_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Action_Sleep::duration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Action.Sleep.duration)
  return _internal_duration();
}
inline void Action_Sleep::unsafe_arena_set_allocated_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_);
  }
  _impl_.duration_ = duration;
  if (duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Action.Sleep.duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Action_Sleep::release_duration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Action_Sleep::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Action.Sleep.duration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Action_Sleep::_internal_mutable_duration() {
  
  if (_impl_.duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.duration_ = p;
  }
  return _impl_.duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Action_Sleep::mutable_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Action.Sleep.duration)
  return _msg;
}
inline void Action_Sleep::set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_);
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration));
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Action.Sleep.duration)
}

// -------------------------------------------------------------------

// Action_DataAcquisition

// .bosdyn.api.AcquireDataRequest acquire_data_request = 1;
inline bool Action_DataAcquisition::_internal_has_acquire_data_request() const {
  return this != internal_default_instance() && _impl_.acquire_data_request_ != nullptr;
}
inline bool Action_DataAcquisition::has_acquire_data_request() const {
  return _internal_has_acquire_data_request();
}
inline const ::bosdyn::api::AcquireDataRequest& Action_DataAcquisition::_internal_acquire_data_request() const {
  const ::bosdyn::api::AcquireDataRequest* p = _impl_.acquire_data_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::AcquireDataRequest&>(
      ::bosdyn::api::_AcquireDataRequest_default_instance_);
}
inline const ::bosdyn::api::AcquireDataRequest& Action_DataAcquisition::acquire_data_request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Action.DataAcquisition.acquire_data_request)
  return _internal_acquire_data_request();
}
inline void Action_DataAcquisition::unsafe_arena_set_allocated_acquire_data_request(
    ::bosdyn::api::AcquireDataRequest* acquire_data_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acquire_data_request_);
  }
  _impl_.acquire_data_request_ = acquire_data_request;
  if (acquire_data_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Action.DataAcquisition.acquire_data_request)
}
inline ::bosdyn::api::AcquireDataRequest* Action_DataAcquisition::release_acquire_data_request() {
  
  ::bosdyn::api::AcquireDataRequest* temp = _impl_.acquire_data_request_;
  _impl_.acquire_data_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::AcquireDataRequest* Action_DataAcquisition::unsafe_arena_release_acquire_data_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Action.DataAcquisition.acquire_data_request)
  
  ::bosdyn::api::AcquireDataRequest* temp = _impl_.acquire_data_request_;
  _impl_.acquire_data_request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::AcquireDataRequest* Action_DataAcquisition::_internal_mutable_acquire_data_request() {
  
  if (_impl_.acquire_data_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::AcquireDataRequest>(GetArenaForAllocation());
    _impl_.acquire_data_request_ = p;
  }
  return _impl_.acquire_data_request_;
}
inline ::bosdyn::api::AcquireDataRequest* Action_DataAcquisition::mutable_acquire_data_request() {
  ::bosdyn::api::AcquireDataRequest* _msg = _internal_mutable_acquire_data_request();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Action.DataAcquisition.acquire_data_request)
  return _msg;
}
inline void Action_DataAcquisition::set_allocated_acquire_data_request(::bosdyn::api::AcquireDataRequest* acquire_data_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acquire_data_request_);
  }
  if (acquire_data_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acquire_data_request));
    if (message_arena != submessage_arena) {
      acquire_data_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acquire_data_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.acquire_data_request_ = acquire_data_request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Action.DataAcquisition.acquire_data_request)
}

// .bosdyn.api.mission.DataAcquisition.CompletionBehavior completion_behavior = 2;
inline void Action_DataAcquisition::clear_completion_behavior() {
  _impl_.completion_behavior_ = 0;
}
inline ::bosdyn::api::mission::DataAcquisition_CompletionBehavior Action_DataAcquisition::_internal_completion_behavior() const {
  return static_cast< ::bosdyn::api::mission::DataAcquisition_CompletionBehavior >(_impl_.completion_behavior_);
}
inline ::bosdyn::api::mission::DataAcquisition_CompletionBehavior Action_DataAcquisition::completion_behavior() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Action.DataAcquisition.completion_behavior)
  return _internal_completion_behavior();
}
inline void Action_DataAcquisition::_internal_set_completion_behavior(::bosdyn::api::mission::DataAcquisition_CompletionBehavior value) {
  
  _impl_.completion_behavior_ = value;
}
inline void Action_DataAcquisition::set_completion_behavior(::bosdyn::api::mission::DataAcquisition_CompletionBehavior value) {
  _internal_set_completion_behavior(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.Action.DataAcquisition.completion_behavior)
}

// -------------------------------------------------------------------

// Action_RemoteGrpc

// string service_name = 1;
inline void Action_RemoteGrpc::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& Action_RemoteGrpc::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Action.RemoteGrpc.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Action_RemoteGrpc::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.Action.RemoteGrpc.service_name)
}
inline std::string* Action_RemoteGrpc::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Action.RemoteGrpc.service_name)
  return _s;
}
inline const std::string& Action_RemoteGrpc::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void Action_RemoteGrpc::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Action_RemoteGrpc::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Action_RemoteGrpc::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Action.RemoteGrpc.service_name)
  return _impl_.service_name_.Release();
}
inline void Action_RemoteGrpc::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Action.RemoteGrpc.service_name)
}

// .google.protobuf.Duration rpc_timeout = 2;
inline bool Action_RemoteGrpc::_internal_has_rpc_timeout() const {
  return this != internal_default_instance() && _impl_.rpc_timeout_ != nullptr;
}
inline bool Action_RemoteGrpc::has_rpc_timeout() const {
  return _internal_has_rpc_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Action_RemoteGrpc::_internal_rpc_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.rpc_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Action_RemoteGrpc::rpc_timeout() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Action.RemoteGrpc.rpc_timeout)
  return _internal_rpc_timeout();
}
inline void Action_RemoteGrpc::unsafe_arena_set_allocated_rpc_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* rpc_timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rpc_timeout_);
  }
  _impl_.rpc_timeout_ = rpc_timeout;
  if (rpc_timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Action.RemoteGrpc.rpc_timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Action_RemoteGrpc::release_rpc_timeout() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.rpc_timeout_;
  _impl_.rpc_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Action_RemoteGrpc::unsafe_arena_release_rpc_timeout() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Action.RemoteGrpc.rpc_timeout)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.rpc_timeout_;
  _impl_.rpc_timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Action_RemoteGrpc::_internal_mutable_rpc_timeout() {
  
  if (_impl_.rpc_timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.rpc_timeout_ = p;
  }
  return _impl_.rpc_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Action_RemoteGrpc::mutable_rpc_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_rpc_timeout();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Action.RemoteGrpc.rpc_timeout)
  return _msg;
}
inline void Action_RemoteGrpc::set_allocated_rpc_timeout(::PROTOBUF_NAMESPACE_ID::Duration* rpc_timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rpc_timeout_);
  }
  if (rpc_timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rpc_timeout));
    if (message_arena != submessage_arena) {
      rpc_timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rpc_timeout, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rpc_timeout_ = rpc_timeout;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.Action.RemoteGrpc.rpc_timeout)
}

// repeated string lease_resources = 3;
inline int Action_RemoteGrpc::_internal_lease_resources_size() const {
  return _impl_.lease_resources_.size();
}
inline int Action_RemoteGrpc::lease_resources_size() const {
  return _internal_lease_resources_size();
}
inline void Action_RemoteGrpc::clear_lease_resources() {
  _impl_.lease_resources_.Clear();
}
inline std::string* Action_RemoteGrpc::add_lease_resources() {
  std::string* _s = _internal_add_lease_resources();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.autowalk.Action.RemoteGrpc.lease_resources)
  return _s;
}
inline const std::string& Action_RemoteGrpc::_internal_lease_resources(int index) const {
  return _impl_.lease_resources_.Get(index);
}
inline const std::string& Action_RemoteGrpc::lease_resources(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Action.RemoteGrpc.lease_resources)
  return _internal_lease_resources(index);
}
inline std::string* Action_RemoteGrpc::mutable_lease_resources(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Action.RemoteGrpc.lease_resources)
  return _impl_.lease_resources_.Mutable(index);
}
inline void Action_RemoteGrpc::set_lease_resources(int index, const std::string& value) {
  _impl_.lease_resources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.Action.RemoteGrpc.lease_resources)
}
inline void Action_RemoteGrpc::set_lease_resources(int index, std::string&& value) {
  _impl_.lease_resources_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.Action.RemoteGrpc.lease_resources)
}
inline void Action_RemoteGrpc::set_lease_resources(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.lease_resources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.autowalk.Action.RemoteGrpc.lease_resources)
}
inline void Action_RemoteGrpc::set_lease_resources(int index, const char* value, size_t size) {
  _impl_.lease_resources_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.autowalk.Action.RemoteGrpc.lease_resources)
}
inline std::string* Action_RemoteGrpc::_internal_add_lease_resources() {
  return _impl_.lease_resources_.Add();
}
inline void Action_RemoteGrpc::add_lease_resources(const std::string& value) {
  _impl_.lease_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.autowalk.Action.RemoteGrpc.lease_resources)
}
inline void Action_RemoteGrpc::add_lease_resources(std::string&& value) {
  _impl_.lease_resources_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.autowalk.Action.RemoteGrpc.lease_resources)
}
inline void Action_RemoteGrpc::add_lease_resources(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.lease_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.autowalk.Action.RemoteGrpc.lease_resources)
}
inline void Action_RemoteGrpc::add_lease_resources(const char* value, size_t size) {
  _impl_.lease_resources_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.autowalk.Action.RemoteGrpc.lease_resources)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Action_RemoteGrpc::lease_resources() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.autowalk.Action.RemoteGrpc.lease_resources)
  return _impl_.lease_resources_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Action_RemoteGrpc::mutable_lease_resources() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.autowalk.Action.RemoteGrpc.lease_resources)
  return &_impl_.lease_resources_;
}

// repeated .bosdyn.api.mission.KeyValue inputs = 4;
inline int Action_RemoteGrpc::_internal_inputs_size() const {
  return _impl_.inputs_.size();
}
inline int Action_RemoteGrpc::inputs_size() const {
  return _internal_inputs_size();
}
inline ::bosdyn::api::mission::KeyValue* Action_RemoteGrpc::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Action.RemoteGrpc.inputs)
  return _impl_.inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
Action_RemoteGrpc::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.autowalk.Action.RemoteGrpc.inputs)
  return &_impl_.inputs_;
}
inline const ::bosdyn::api::mission::KeyValue& Action_RemoteGrpc::_internal_inputs(int index) const {
  return _impl_.inputs_.Get(index);
}
inline const ::bosdyn::api::mission::KeyValue& Action_RemoteGrpc::inputs(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Action.RemoteGrpc.inputs)
  return _internal_inputs(index);
}
inline ::bosdyn::api::mission::KeyValue* Action_RemoteGrpc::_internal_add_inputs() {
  return _impl_.inputs_.Add();
}
inline ::bosdyn::api::mission::KeyValue* Action_RemoteGrpc::add_inputs() {
  ::bosdyn::api::mission::KeyValue* _add = _internal_add_inputs();
  // @@protoc_insertion_point(field_add:bosdyn.api.autowalk.Action.RemoteGrpc.inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
Action_RemoteGrpc::inputs() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.autowalk.Action.RemoteGrpc.inputs)
  return _impl_.inputs_;
}

// -------------------------------------------------------------------

// Action

// .bosdyn.api.autowalk.Action.Sleep sleep = 1;
inline bool Action::_internal_has_sleep() const {
  return action_case() == kSleep;
}
inline bool Action::has_sleep() const {
  return _internal_has_sleep();
}
inline void Action::set_has_sleep() {
  _impl_._oneof_case_[0] = kSleep;
}
inline void Action::clear_sleep() {
  if (_internal_has_sleep()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.sleep_;
    }
    clear_has_action();
  }
}
inline ::bosdyn::api::autowalk::Action_Sleep* Action::release_sleep() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Action.sleep)
  if (_internal_has_sleep()) {
    clear_has_action();
    ::bosdyn::api::autowalk::Action_Sleep* temp = _impl_.action_.sleep_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.sleep_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::autowalk::Action_Sleep& Action::_internal_sleep() const {
  return _internal_has_sleep()
      ? *_impl_.action_.sleep_
      : reinterpret_cast< ::bosdyn::api::autowalk::Action_Sleep&>(::bosdyn::api::autowalk::_Action_Sleep_default_instance_);
}
inline const ::bosdyn::api::autowalk::Action_Sleep& Action::sleep() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Action.sleep)
  return _internal_sleep();
}
inline ::bosdyn::api::autowalk::Action_Sleep* Action::unsafe_arena_release_sleep() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.autowalk.Action.sleep)
  if (_internal_has_sleep()) {
    clear_has_action();
    ::bosdyn::api::autowalk::Action_Sleep* temp = _impl_.action_.sleep_;
    _impl_.action_.sleep_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_sleep(::bosdyn::api::autowalk::Action_Sleep* sleep) {
  clear_action();
  if (sleep) {
    set_has_sleep();
    _impl_.action_.sleep_ = sleep;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Action.sleep)
}
inline ::bosdyn::api::autowalk::Action_Sleep* Action::_internal_mutable_sleep() {
  if (!_internal_has_sleep()) {
    clear_action();
    set_has_sleep();
    _impl_.action_.sleep_ = CreateMaybeMessage< ::bosdyn::api::autowalk::Action_Sleep >(GetArenaForAllocation());
  }
  return _impl_.action_.sleep_;
}
inline ::bosdyn::api::autowalk::Action_Sleep* Action::mutable_sleep() {
  ::bosdyn::api::autowalk::Action_Sleep* _msg = _internal_mutable_sleep();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Action.sleep)
  return _msg;
}

// .bosdyn.api.autowalk.Action.DataAcquisition data_acquisition = 2;
inline bool Action::_internal_has_data_acquisition() const {
  return action_case() == kDataAcquisition;
}
inline bool Action::has_data_acquisition() const {
  return _internal_has_data_acquisition();
}
inline void Action::set_has_data_acquisition() {
  _impl_._oneof_case_[0] = kDataAcquisition;
}
inline void Action::clear_data_acquisition() {
  if (_internal_has_data_acquisition()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.data_acquisition_;
    }
    clear_has_action();
  }
}
inline ::bosdyn::api::autowalk::Action_DataAcquisition* Action::release_data_acquisition() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Action.data_acquisition)
  if (_internal_has_data_acquisition()) {
    clear_has_action();
    ::bosdyn::api::autowalk::Action_DataAcquisition* temp = _impl_.action_.data_acquisition_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.data_acquisition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::autowalk::Action_DataAcquisition& Action::_internal_data_acquisition() const {
  return _internal_has_data_acquisition()
      ? *_impl_.action_.data_acquisition_
      : reinterpret_cast< ::bosdyn::api::autowalk::Action_DataAcquisition&>(::bosdyn::api::autowalk::_Action_DataAcquisition_default_instance_);
}
inline const ::bosdyn::api::autowalk::Action_DataAcquisition& Action::data_acquisition() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Action.data_acquisition)
  return _internal_data_acquisition();
}
inline ::bosdyn::api::autowalk::Action_DataAcquisition* Action::unsafe_arena_release_data_acquisition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.autowalk.Action.data_acquisition)
  if (_internal_has_data_acquisition()) {
    clear_has_action();
    ::bosdyn::api::autowalk::Action_DataAcquisition* temp = _impl_.action_.data_acquisition_;
    _impl_.action_.data_acquisition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_data_acquisition(::bosdyn::api::autowalk::Action_DataAcquisition* data_acquisition) {
  clear_action();
  if (data_acquisition) {
    set_has_data_acquisition();
    _impl_.action_.data_acquisition_ = data_acquisition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Action.data_acquisition)
}
inline ::bosdyn::api::autowalk::Action_DataAcquisition* Action::_internal_mutable_data_acquisition() {
  if (!_internal_has_data_acquisition()) {
    clear_action();
    set_has_data_acquisition();
    _impl_.action_.data_acquisition_ = CreateMaybeMessage< ::bosdyn::api::autowalk::Action_DataAcquisition >(GetArenaForAllocation());
  }
  return _impl_.action_.data_acquisition_;
}
inline ::bosdyn::api::autowalk::Action_DataAcquisition* Action::mutable_data_acquisition() {
  ::bosdyn::api::autowalk::Action_DataAcquisition* _msg = _internal_mutable_data_acquisition();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Action.data_acquisition)
  return _msg;
}

// .bosdyn.api.autowalk.Action.RemoteGrpc remote_grpc = 3;
inline bool Action::_internal_has_remote_grpc() const {
  return action_case() == kRemoteGrpc;
}
inline bool Action::has_remote_grpc() const {
  return _internal_has_remote_grpc();
}
inline void Action::set_has_remote_grpc() {
  _impl_._oneof_case_[0] = kRemoteGrpc;
}
inline void Action::clear_remote_grpc() {
  if (_internal_has_remote_grpc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.remote_grpc_;
    }
    clear_has_action();
  }
}
inline ::bosdyn::api::autowalk::Action_RemoteGrpc* Action::release_remote_grpc() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Action.remote_grpc)
  if (_internal_has_remote_grpc()) {
    clear_has_action();
    ::bosdyn::api::autowalk::Action_RemoteGrpc* temp = _impl_.action_.remote_grpc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.remote_grpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::autowalk::Action_RemoteGrpc& Action::_internal_remote_grpc() const {
  return _internal_has_remote_grpc()
      ? *_impl_.action_.remote_grpc_
      : reinterpret_cast< ::bosdyn::api::autowalk::Action_RemoteGrpc&>(::bosdyn::api::autowalk::_Action_RemoteGrpc_default_instance_);
}
inline const ::bosdyn::api::autowalk::Action_RemoteGrpc& Action::remote_grpc() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Action.remote_grpc)
  return _internal_remote_grpc();
}
inline ::bosdyn::api::autowalk::Action_RemoteGrpc* Action::unsafe_arena_release_remote_grpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.autowalk.Action.remote_grpc)
  if (_internal_has_remote_grpc()) {
    clear_has_action();
    ::bosdyn::api::autowalk::Action_RemoteGrpc* temp = _impl_.action_.remote_grpc_;
    _impl_.action_.remote_grpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_remote_grpc(::bosdyn::api::autowalk::Action_RemoteGrpc* remote_grpc) {
  clear_action();
  if (remote_grpc) {
    set_has_remote_grpc();
    _impl_.action_.remote_grpc_ = remote_grpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Action.remote_grpc)
}
inline ::bosdyn::api::autowalk::Action_RemoteGrpc* Action::_internal_mutable_remote_grpc() {
  if (!_internal_has_remote_grpc()) {
    clear_action();
    set_has_remote_grpc();
    _impl_.action_.remote_grpc_ = CreateMaybeMessage< ::bosdyn::api::autowalk::Action_RemoteGrpc >(GetArenaForAllocation());
  }
  return _impl_.action_.remote_grpc_;
}
inline ::bosdyn::api::autowalk::Action_RemoteGrpc* Action::mutable_remote_grpc() {
  ::bosdyn::api::autowalk::Action_RemoteGrpc* _msg = _internal_mutable_remote_grpc();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Action.remote_grpc)
  return _msg;
}

// .bosdyn.api.mission.Node node = 4;
inline bool Action::_internal_has_node() const {
  return action_case() == kNode;
}
inline bool Action::has_node() const {
  return _internal_has_node();
}
inline void Action::set_has_node() {
  _impl_._oneof_case_[0] = kNode;
}
inline ::bosdyn::api::mission::Node* Action::release_node() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.Action.node)
  if (_internal_has_node()) {
    clear_has_action();
    ::bosdyn::api::mission::Node* temp = _impl_.action_.node_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.node_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::mission::Node& Action::_internal_node() const {
  return _internal_has_node()
      ? *_impl_.action_.node_
      : reinterpret_cast< ::bosdyn::api::mission::Node&>(::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& Action::node() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.Action.node)
  return _internal_node();
}
inline ::bosdyn::api::mission::Node* Action::unsafe_arena_release_node() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.autowalk.Action.node)
  if (_internal_has_node()) {
    clear_has_action();
    ::bosdyn::api::mission::Node* temp = _impl_.action_.node_;
    _impl_.action_.node_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_node(::bosdyn::api::mission::Node* node) {
  clear_action();
  if (node) {
    set_has_node();
    _impl_.action_.node_ = node;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.Action.node)
}
inline ::bosdyn::api::mission::Node* Action::_internal_mutable_node() {
  if (!_internal_has_node()) {
    clear_action();
    set_has_node();
    _impl_.action_.node_ = CreateMaybeMessage< ::bosdyn::api::mission::Node >(GetArenaForAllocation());
  }
  return _impl_.action_.node_;
}
inline ::bosdyn::api::mission::Node* Action::mutable_node() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.Action.node)
  return _msg;
}

inline bool Action::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void Action::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline Action::ActionCase Action::action_case() const {
  return Action::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionWrapper_RobotBodySit

// -------------------------------------------------------------------

// ActionWrapper_RobotBodyPose

// .bosdyn.api.SE3Pose target_tform_body = 1;
inline bool ActionWrapper_RobotBodyPose::_internal_has_target_tform_body() const {
  return this != internal_default_instance() && _impl_.target_tform_body_ != nullptr;
}
inline bool ActionWrapper_RobotBodyPose::has_target_tform_body() const {
  return _internal_has_target_tform_body();
}
inline const ::bosdyn::api::SE3Pose& ActionWrapper_RobotBodyPose::_internal_target_tform_body() const {
  const ::bosdyn::api::SE3Pose* p = _impl_.target_tform_body_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Pose&>(
      ::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& ActionWrapper_RobotBodyPose::target_tform_body() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.RobotBodyPose.target_tform_body)
  return _internal_target_tform_body();
}
inline void ActionWrapper_RobotBodyPose::unsafe_arena_set_allocated_target_tform_body(
    ::bosdyn::api::SE3Pose* target_tform_body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_tform_body_);
  }
  _impl_.target_tform_body_ = target_tform_body;
  if (target_tform_body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ActionWrapper.RobotBodyPose.target_tform_body)
}
inline ::bosdyn::api::SE3Pose* ActionWrapper_RobotBodyPose::release_target_tform_body() {
  
  ::bosdyn::api::SE3Pose* temp = _impl_.target_tform_body_;
  _impl_.target_tform_body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Pose* ActionWrapper_RobotBodyPose::unsafe_arena_release_target_tform_body() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ActionWrapper.RobotBodyPose.target_tform_body)
  
  ::bosdyn::api::SE3Pose* temp = _impl_.target_tform_body_;
  _impl_.target_tform_body_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* ActionWrapper_RobotBodyPose::_internal_mutable_target_tform_body() {
  
  if (_impl_.target_tform_body_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArenaForAllocation());
    _impl_.target_tform_body_ = p;
  }
  return _impl_.target_tform_body_;
}
inline ::bosdyn::api::SE3Pose* ActionWrapper_RobotBodyPose::mutable_target_tform_body() {
  ::bosdyn::api::SE3Pose* _msg = _internal_mutable_target_tform_body();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ActionWrapper.RobotBodyPose.target_tform_body)
  return _msg;
}
inline void ActionWrapper_RobotBodyPose::set_allocated_target_tform_body(::bosdyn::api::SE3Pose* target_tform_body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_tform_body_);
  }
  if (target_tform_body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_tform_body));
    if (message_arena != submessage_arena) {
      target_tform_body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_tform_body, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_tform_body_ = target_tform_body;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ActionWrapper.RobotBodyPose.target_tform_body)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ActionWrapper_SpotCamLed

// map<int32, float> brightnesses = 1;
inline int ActionWrapper_SpotCamLed::_internal_brightnesses_size() const {
  return _impl_.brightnesses_.size();
}
inline int ActionWrapper_SpotCamLed::brightnesses_size() const {
  return _internal_brightnesses_size();
}
inline void ActionWrapper_SpotCamLed::clear_brightnesses() {
  _impl_.brightnesses_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, float >&
ActionWrapper_SpotCamLed::_internal_brightnesses() const {
  return _impl_.brightnesses_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, float >&
ActionWrapper_SpotCamLed::brightnesses() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.autowalk.ActionWrapper.SpotCamLed.brightnesses)
  return _internal_brightnesses();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, float >*
ActionWrapper_SpotCamLed::_internal_mutable_brightnesses() {
  return _impl_.brightnesses_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, float >*
ActionWrapper_SpotCamLed::mutable_brightnesses() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.autowalk.ActionWrapper.SpotCamLed.brightnesses)
  return _internal_mutable_brightnesses();
}

// -------------------------------------------------------------------

// ActionWrapper_SpotCamPtz

// .bosdyn.api.spot_cam.PtzPosition ptz_position = 1;
inline bool ActionWrapper_SpotCamPtz::_internal_has_ptz_position() const {
  return this != internal_default_instance() && _impl_.ptz_position_ != nullptr;
}
inline bool ActionWrapper_SpotCamPtz::has_ptz_position() const {
  return _internal_has_ptz_position();
}
inline const ::bosdyn::api::spot_cam::PtzPosition& ActionWrapper_SpotCamPtz::_internal_ptz_position() const {
  const ::bosdyn::api::spot_cam::PtzPosition* p = _impl_.ptz_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot_cam::PtzPosition&>(
      ::bosdyn::api::spot_cam::_PtzPosition_default_instance_);
}
inline const ::bosdyn::api::spot_cam::PtzPosition& ActionWrapper_SpotCamPtz::ptz_position() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.SpotCamPtz.ptz_position)
  return _internal_ptz_position();
}
inline void ActionWrapper_SpotCamPtz::unsafe_arena_set_allocated_ptz_position(
    ::bosdyn::api::spot_cam::PtzPosition* ptz_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ptz_position_);
  }
  _impl_.ptz_position_ = ptz_position;
  if (ptz_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ActionWrapper.SpotCamPtz.ptz_position)
}
inline ::bosdyn::api::spot_cam::PtzPosition* ActionWrapper_SpotCamPtz::release_ptz_position() {
  
  ::bosdyn::api::spot_cam::PtzPosition* temp = _impl_.ptz_position_;
  _impl_.ptz_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzPosition* ActionWrapper_SpotCamPtz::unsafe_arena_release_ptz_position() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ActionWrapper.SpotCamPtz.ptz_position)
  
  ::bosdyn::api::spot_cam::PtzPosition* temp = _impl_.ptz_position_;
  _impl_.ptz_position_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::PtzPosition* ActionWrapper_SpotCamPtz::_internal_mutable_ptz_position() {
  
  if (_impl_.ptz_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::PtzPosition>(GetArenaForAllocation());
    _impl_.ptz_position_ = p;
  }
  return _impl_.ptz_position_;
}
inline ::bosdyn::api::spot_cam::PtzPosition* ActionWrapper_SpotCamPtz::mutable_ptz_position() {
  ::bosdyn::api::spot_cam::PtzPosition* _msg = _internal_mutable_ptz_position();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ActionWrapper.SpotCamPtz.ptz_position)
  return _msg;
}
inline void ActionWrapper_SpotCamPtz::set_allocated_ptz_position(::bosdyn::api::spot_cam::PtzPosition* ptz_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ptz_position_);
  }
  if (ptz_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ptz_position));
    if (message_arena != submessage_arena) {
      ptz_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ptz_position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ptz_position_ = ptz_position;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ActionWrapper.SpotCamPtz.ptz_position)
}

// -------------------------------------------------------------------

// ActionWrapper_ArmSensorPointing

// .bosdyn.api.ArmJointTrajectory joint_trajectory = 2;
inline bool ActionWrapper_ArmSensorPointing::_internal_has_joint_trajectory() const {
  return this != internal_default_instance() && _impl_.joint_trajectory_ != nullptr;
}
inline bool ActionWrapper_ArmSensorPointing::has_joint_trajectory() const {
  return _internal_has_joint_trajectory();
}
inline const ::bosdyn::api::ArmJointTrajectory& ActionWrapper_ArmSensorPointing::_internal_joint_trajectory() const {
  const ::bosdyn::api::ArmJointTrajectory* p = _impl_.joint_trajectory_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ArmJointTrajectory&>(
      ::bosdyn::api::_ArmJointTrajectory_default_instance_);
}
inline const ::bosdyn::api::ArmJointTrajectory& ActionWrapper_ArmSensorPointing::joint_trajectory() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.joint_trajectory)
  return _internal_joint_trajectory();
}
inline void ActionWrapper_ArmSensorPointing::unsafe_arena_set_allocated_joint_trajectory(
    ::bosdyn::api::ArmJointTrajectory* joint_trajectory) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.joint_trajectory_);
  }
  _impl_.joint_trajectory_ = joint_trajectory;
  if (joint_trajectory) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.joint_trajectory)
}
inline ::bosdyn::api::ArmJointTrajectory* ActionWrapper_ArmSensorPointing::release_joint_trajectory() {
  
  ::bosdyn::api::ArmJointTrajectory* temp = _impl_.joint_trajectory_;
  _impl_.joint_trajectory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ArmJointTrajectory* ActionWrapper_ArmSensorPointing::unsafe_arena_release_joint_trajectory() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.joint_trajectory)
  
  ::bosdyn::api::ArmJointTrajectory* temp = _impl_.joint_trajectory_;
  _impl_.joint_trajectory_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ArmJointTrajectory* ActionWrapper_ArmSensorPointing::_internal_mutable_joint_trajectory() {
  
  if (_impl_.joint_trajectory_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ArmJointTrajectory>(GetArenaForAllocation());
    _impl_.joint_trajectory_ = p;
  }
  return _impl_.joint_trajectory_;
}
inline ::bosdyn::api::ArmJointTrajectory* ActionWrapper_ArmSensorPointing::mutable_joint_trajectory() {
  ::bosdyn::api::ArmJointTrajectory* _msg = _internal_mutable_joint_trajectory();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.joint_trajectory)
  return _msg;
}
inline void ActionWrapper_ArmSensorPointing::set_allocated_joint_trajectory(::bosdyn::api::ArmJointTrajectory* joint_trajectory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.joint_trajectory_);
  }
  if (joint_trajectory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(joint_trajectory));
    if (message_arena != submessage_arena) {
      joint_trajectory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joint_trajectory, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.joint_trajectory_ = joint_trajectory;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.joint_trajectory)
}

// .bosdyn.api.SE3Pose wrist_tform_tool = 3;
inline bool ActionWrapper_ArmSensorPointing::_internal_has_wrist_tform_tool() const {
  return this != internal_default_instance() && _impl_.wrist_tform_tool_ != nullptr;
}
inline bool ActionWrapper_ArmSensorPointing::has_wrist_tform_tool() const {
  return _internal_has_wrist_tform_tool();
}
inline const ::bosdyn::api::SE3Pose& ActionWrapper_ArmSensorPointing::_internal_wrist_tform_tool() const {
  const ::bosdyn::api::SE3Pose* p = _impl_.wrist_tform_tool_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Pose&>(
      ::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& ActionWrapper_ArmSensorPointing::wrist_tform_tool() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.wrist_tform_tool)
  return _internal_wrist_tform_tool();
}
inline void ActionWrapper_ArmSensorPointing::unsafe_arena_set_allocated_wrist_tform_tool(
    ::bosdyn::api::SE3Pose* wrist_tform_tool) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wrist_tform_tool_);
  }
  _impl_.wrist_tform_tool_ = wrist_tform_tool;
  if (wrist_tform_tool) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.wrist_tform_tool)
}
inline ::bosdyn::api::SE3Pose* ActionWrapper_ArmSensorPointing::release_wrist_tform_tool() {
  
  ::bosdyn::api::SE3Pose* temp = _impl_.wrist_tform_tool_;
  _impl_.wrist_tform_tool_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Pose* ActionWrapper_ArmSensorPointing::unsafe_arena_release_wrist_tform_tool() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.wrist_tform_tool)
  
  ::bosdyn::api::SE3Pose* temp = _impl_.wrist_tform_tool_;
  _impl_.wrist_tform_tool_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* ActionWrapper_ArmSensorPointing::_internal_mutable_wrist_tform_tool() {
  
  if (_impl_.wrist_tform_tool_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArenaForAllocation());
    _impl_.wrist_tform_tool_ = p;
  }
  return _impl_.wrist_tform_tool_;
}
inline ::bosdyn::api::SE3Pose* ActionWrapper_ArmSensorPointing::mutable_wrist_tform_tool() {
  ::bosdyn::api::SE3Pose* _msg = _internal_mutable_wrist_tform_tool();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.wrist_tform_tool)
  return _msg;
}
inline void ActionWrapper_ArmSensorPointing::set_allocated_wrist_tform_tool(::bosdyn::api::SE3Pose* wrist_tform_tool) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wrist_tform_tool_);
  }
  if (wrist_tform_tool) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wrist_tform_tool));
    if (message_arena != submessage_arena) {
      wrist_tform_tool = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wrist_tform_tool, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.wrist_tform_tool_ = wrist_tform_tool;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.wrist_tform_tool)
}

// .bosdyn.api.SE3Trajectory pose_trajectory_rt_target = 4;
inline bool ActionWrapper_ArmSensorPointing::_internal_has_pose_trajectory_rt_target() const {
  return this != internal_default_instance() && _impl_.pose_trajectory_rt_target_ != nullptr;
}
inline bool ActionWrapper_ArmSensorPointing::has_pose_trajectory_rt_target() const {
  return _internal_has_pose_trajectory_rt_target();
}
inline const ::bosdyn::api::SE3Trajectory& ActionWrapper_ArmSensorPointing::_internal_pose_trajectory_rt_target() const {
  const ::bosdyn::api::SE3Trajectory* p = _impl_.pose_trajectory_rt_target_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Trajectory&>(
      ::bosdyn::api::_SE3Trajectory_default_instance_);
}
inline const ::bosdyn::api::SE3Trajectory& ActionWrapper_ArmSensorPointing::pose_trajectory_rt_target() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.pose_trajectory_rt_target)
  return _internal_pose_trajectory_rt_target();
}
inline void ActionWrapper_ArmSensorPointing::unsafe_arena_set_allocated_pose_trajectory_rt_target(
    ::bosdyn::api::SE3Trajectory* pose_trajectory_rt_target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pose_trajectory_rt_target_);
  }
  _impl_.pose_trajectory_rt_target_ = pose_trajectory_rt_target;
  if (pose_trajectory_rt_target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.pose_trajectory_rt_target)
}
inline ::bosdyn::api::SE3Trajectory* ActionWrapper_ArmSensorPointing::release_pose_trajectory_rt_target() {
  
  ::bosdyn::api::SE3Trajectory* temp = _impl_.pose_trajectory_rt_target_;
  _impl_.pose_trajectory_rt_target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Trajectory* ActionWrapper_ArmSensorPointing::unsafe_arena_release_pose_trajectory_rt_target() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.pose_trajectory_rt_target)
  
  ::bosdyn::api::SE3Trajectory* temp = _impl_.pose_trajectory_rt_target_;
  _impl_.pose_trajectory_rt_target_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Trajectory* ActionWrapper_ArmSensorPointing::_internal_mutable_pose_trajectory_rt_target() {
  
  if (_impl_.pose_trajectory_rt_target_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Trajectory>(GetArenaForAllocation());
    _impl_.pose_trajectory_rt_target_ = p;
  }
  return _impl_.pose_trajectory_rt_target_;
}
inline ::bosdyn::api::SE3Trajectory* ActionWrapper_ArmSensorPointing::mutable_pose_trajectory_rt_target() {
  ::bosdyn::api::SE3Trajectory* _msg = _internal_mutable_pose_trajectory_rt_target();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.pose_trajectory_rt_target)
  return _msg;
}
inline void ActionWrapper_ArmSensorPointing::set_allocated_pose_trajectory_rt_target(::bosdyn::api::SE3Trajectory* pose_trajectory_rt_target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pose_trajectory_rt_target_);
  }
  if (pose_trajectory_rt_target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_trajectory_rt_target));
    if (message_arena != submessage_arena) {
      pose_trajectory_rt_target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose_trajectory_rt_target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pose_trajectory_rt_target_ = pose_trajectory_rt_target;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.pose_trajectory_rt_target)
}

// .bosdyn.api.SE2Pose target_tform_measured_offset = 7;
inline bool ActionWrapper_ArmSensorPointing::_internal_has_target_tform_measured_offset() const {
  return this != internal_default_instance() && _impl_.target_tform_measured_offset_ != nullptr;
}
inline bool ActionWrapper_ArmSensorPointing::has_target_tform_measured_offset() const {
  return _internal_has_target_tform_measured_offset();
}
inline const ::bosdyn::api::SE2Pose& ActionWrapper_ArmSensorPointing::_internal_target_tform_measured_offset() const {
  const ::bosdyn::api::SE2Pose* p = _impl_.target_tform_measured_offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE2Pose&>(
      ::bosdyn::api::_SE2Pose_default_instance_);
}
inline const ::bosdyn::api::SE2Pose& ActionWrapper_ArmSensorPointing::target_tform_measured_offset() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.target_tform_measured_offset)
  return _internal_target_tform_measured_offset();
}
inline void ActionWrapper_ArmSensorPointing::unsafe_arena_set_allocated_target_tform_measured_offset(
    ::bosdyn::api::SE2Pose* target_tform_measured_offset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_tform_measured_offset_);
  }
  _impl_.target_tform_measured_offset_ = target_tform_measured_offset;
  if (target_tform_measured_offset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.target_tform_measured_offset)
}
inline ::bosdyn::api::SE2Pose* ActionWrapper_ArmSensorPointing::release_target_tform_measured_offset() {
  
  ::bosdyn::api::SE2Pose* temp = _impl_.target_tform_measured_offset_;
  _impl_.target_tform_measured_offset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE2Pose* ActionWrapper_ArmSensorPointing::unsafe_arena_release_target_tform_measured_offset() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.target_tform_measured_offset)
  
  ::bosdyn::api::SE2Pose* temp = _impl_.target_tform_measured_offset_;
  _impl_.target_tform_measured_offset_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE2Pose* ActionWrapper_ArmSensorPointing::_internal_mutable_target_tform_measured_offset() {
  
  if (_impl_.target_tform_measured_offset_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE2Pose>(GetArenaForAllocation());
    _impl_.target_tform_measured_offset_ = p;
  }
  return _impl_.target_tform_measured_offset_;
}
inline ::bosdyn::api::SE2Pose* ActionWrapper_ArmSensorPointing::mutable_target_tform_measured_offset() {
  ::bosdyn::api::SE2Pose* _msg = _internal_mutable_target_tform_measured_offset();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.target_tform_measured_offset)
  return _msg;
}
inline void ActionWrapper_ArmSensorPointing::set_allocated_target_tform_measured_offset(::bosdyn::api::SE2Pose* target_tform_measured_offset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_tform_measured_offset_);
  }
  if (target_tform_measured_offset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_tform_measured_offset));
    if (message_arena != submessage_arena) {
      target_tform_measured_offset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_tform_measured_offset, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_tform_measured_offset_ = target_tform_measured_offset;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.target_tform_measured_offset)
}

// .bosdyn.api.spot.BodyControlParams.BodyAssistForManipulation body_assist_params = 5;
inline bool ActionWrapper_ArmSensorPointing::_internal_has_body_assist_params() const {
  return this != internal_default_instance() && _impl_.body_assist_params_ != nullptr;
}
inline bool ActionWrapper_ArmSensorPointing::has_body_assist_params() const {
  return _internal_has_body_assist_params();
}
inline const ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation& ActionWrapper_ArmSensorPointing::_internal_body_assist_params() const {
  const ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* p = _impl_.body_assist_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation&>(
      ::bosdyn::api::spot::_BodyControlParams_BodyAssistForManipulation_default_instance_);
}
inline const ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation& ActionWrapper_ArmSensorPointing::body_assist_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.body_assist_params)
  return _internal_body_assist_params();
}
inline void ActionWrapper_ArmSensorPointing::unsafe_arena_set_allocated_body_assist_params(
    ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* body_assist_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_assist_params_);
  }
  _impl_.body_assist_params_ = body_assist_params;
  if (body_assist_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.body_assist_params)
}
inline ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* ActionWrapper_ArmSensorPointing::release_body_assist_params() {
  
  ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* temp = _impl_.body_assist_params_;
  _impl_.body_assist_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* ActionWrapper_ArmSensorPointing::unsafe_arena_release_body_assist_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.body_assist_params)
  
  ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* temp = _impl_.body_assist_params_;
  _impl_.body_assist_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* ActionWrapper_ArmSensorPointing::_internal_mutable_body_assist_params() {
  
  if (_impl_.body_assist_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation>(GetArenaForAllocation());
    _impl_.body_assist_params_ = p;
  }
  return _impl_.body_assist_params_;
}
inline ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* ActionWrapper_ArmSensorPointing::mutable_body_assist_params() {
  ::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* _msg = _internal_mutable_body_assist_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.body_assist_params)
  return _msg;
}
inline void ActionWrapper_ArmSensorPointing::set_allocated_body_assist_params(::bosdyn::api::spot::BodyControlParams_BodyAssistForManipulation* body_assist_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_assist_params_);
  }
  if (body_assist_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(body_assist_params));
    if (message_arena != submessage_arena) {
      body_assist_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_assist_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.body_assist_params_ = body_assist_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.body_assist_params)
}

// bool force_stow_override = 6;
inline void ActionWrapper_ArmSensorPointing::clear_force_stow_override() {
  _impl_.force_stow_override_ = false;
}
inline bool ActionWrapper_ArmSensorPointing::_internal_force_stow_override() const {
  return _impl_.force_stow_override_;
}
inline bool ActionWrapper_ArmSensorPointing::force_stow_override() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.force_stow_override)
  return _internal_force_stow_override();
}
inline void ActionWrapper_ArmSensorPointing::_internal_set_force_stow_override(bool value) {
  
  _impl_.force_stow_override_ = value;
}
inline void ActionWrapper_ArmSensorPointing::set_force_stow_override(bool value) {
  _internal_set_force_stow_override(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing.force_stow_override)
}

// -------------------------------------------------------------------

// ActionWrapper_GripperCameraParams

// .bosdyn.api.GripperCameraParams params = 1;
inline bool ActionWrapper_GripperCameraParams::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool ActionWrapper_GripperCameraParams::has_params() const {
  return _internal_has_params();
}
inline const ::bosdyn::api::GripperCameraParams& ActionWrapper_GripperCameraParams::_internal_params() const {
  const ::bosdyn::api::GripperCameraParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::GripperCameraParams&>(
      ::bosdyn::api::_GripperCameraParams_default_instance_);
}
inline const ::bosdyn::api::GripperCameraParams& ActionWrapper_GripperCameraParams::params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.GripperCameraParams.params)
  return _internal_params();
}
inline void ActionWrapper_GripperCameraParams::unsafe_arena_set_allocated_params(
    ::bosdyn::api::GripperCameraParams* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ActionWrapper.GripperCameraParams.params)
}
inline ::bosdyn::api::GripperCameraParams* ActionWrapper_GripperCameraParams::release_params() {
  
  ::bosdyn::api::GripperCameraParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::GripperCameraParams* ActionWrapper_GripperCameraParams::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ActionWrapper.GripperCameraParams.params)
  
  ::bosdyn::api::GripperCameraParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::GripperCameraParams* ActionWrapper_GripperCameraParams::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::GripperCameraParams>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::bosdyn::api::GripperCameraParams* ActionWrapper_GripperCameraParams::mutable_params() {
  ::bosdyn::api::GripperCameraParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ActionWrapper.GripperCameraParams.params)
  return _msg;
}
inline void ActionWrapper_GripperCameraParams::set_allocated_params(::bosdyn::api::GripperCameraParams* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ActionWrapper.GripperCameraParams.params)
}

// -------------------------------------------------------------------

// ActionWrapper_GripperCommand

// .bosdyn.api.GripperCommand.Request request = 1;
inline bool ActionWrapper_GripperCommand::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool ActionWrapper_GripperCommand::has_request() const {
  return _internal_has_request();
}
inline const ::bosdyn::api::GripperCommand_Request& ActionWrapper_GripperCommand::_internal_request() const {
  const ::bosdyn::api::GripperCommand_Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::GripperCommand_Request&>(
      ::bosdyn::api::_GripperCommand_Request_default_instance_);
}
inline const ::bosdyn::api::GripperCommand_Request& ActionWrapper_GripperCommand::request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.GripperCommand.request)
  return _internal_request();
}
inline void ActionWrapper_GripperCommand::unsafe_arena_set_allocated_request(
    ::bosdyn::api::GripperCommand_Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ActionWrapper.GripperCommand.request)
}
inline ::bosdyn::api::GripperCommand_Request* ActionWrapper_GripperCommand::release_request() {
  
  ::bosdyn::api::GripperCommand_Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::GripperCommand_Request* ActionWrapper_GripperCommand::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ActionWrapper.GripperCommand.request)
  
  ::bosdyn::api::GripperCommand_Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::GripperCommand_Request* ActionWrapper_GripperCommand::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::GripperCommand_Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::bosdyn::api::GripperCommand_Request* ActionWrapper_GripperCommand::mutable_request() {
  ::bosdyn::api::GripperCommand_Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ActionWrapper.GripperCommand.request)
  return _msg;
}
inline void ActionWrapper_GripperCommand::set_allocated_request(::bosdyn::api::GripperCommand_Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ActionWrapper.GripperCommand.request)
}

// -------------------------------------------------------------------

// ActionWrapper

// .bosdyn.api.autowalk.ActionWrapper.RobotBodySit robot_body_sit = 1;
inline bool ActionWrapper::_internal_has_robot_body_sit() const {
  return this != internal_default_instance() && _impl_.robot_body_sit_ != nullptr;
}
inline bool ActionWrapper::has_robot_body_sit() const {
  return _internal_has_robot_body_sit();
}
inline void ActionWrapper::clear_robot_body_sit() {
  if (GetArenaForAllocation() == nullptr && _impl_.robot_body_sit_ != nullptr) {
    delete _impl_.robot_body_sit_;
  }
  _impl_.robot_body_sit_ = nullptr;
}
inline const ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit& ActionWrapper::_internal_robot_body_sit() const {
  const ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* p = _impl_.robot_body_sit_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit&>(
      ::bosdyn::api::autowalk::_ActionWrapper_RobotBodySit_default_instance_);
}
inline const ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit& ActionWrapper::robot_body_sit() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.robot_body_sit)
  return _internal_robot_body_sit();
}
inline void ActionWrapper::unsafe_arena_set_allocated_robot_body_sit(
    ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* robot_body_sit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_body_sit_);
  }
  _impl_.robot_body_sit_ = robot_body_sit;
  if (robot_body_sit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ActionWrapper.robot_body_sit)
}
inline ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* ActionWrapper::release_robot_body_sit() {
  
  ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* temp = _impl_.robot_body_sit_;
  _impl_.robot_body_sit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* ActionWrapper::unsafe_arena_release_robot_body_sit() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ActionWrapper.robot_body_sit)
  
  ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* temp = _impl_.robot_body_sit_;
  _impl_.robot_body_sit_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* ActionWrapper::_internal_mutable_robot_body_sit() {
  
  if (_impl_.robot_body_sit_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper_RobotBodySit>(GetArenaForAllocation());
    _impl_.robot_body_sit_ = p;
  }
  return _impl_.robot_body_sit_;
}
inline ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* ActionWrapper::mutable_robot_body_sit() {
  ::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* _msg = _internal_mutable_robot_body_sit();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ActionWrapper.robot_body_sit)
  return _msg;
}
inline void ActionWrapper::set_allocated_robot_body_sit(::bosdyn::api::autowalk::ActionWrapper_RobotBodySit* robot_body_sit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.robot_body_sit_;
  }
  if (robot_body_sit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot_body_sit);
    if (message_arena != submessage_arena) {
      robot_body_sit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_body_sit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.robot_body_sit_ = robot_body_sit;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ActionWrapper.robot_body_sit)
}

// .bosdyn.api.autowalk.ActionWrapper.RobotBodyPose robot_body_pose = 2;
inline bool ActionWrapper::_internal_has_robot_body_pose() const {
  return this != internal_default_instance() && _impl_.robot_body_pose_ != nullptr;
}
inline bool ActionWrapper::has_robot_body_pose() const {
  return _internal_has_robot_body_pose();
}
inline void ActionWrapper::clear_robot_body_pose() {
  if (GetArenaForAllocation() == nullptr && _impl_.robot_body_pose_ != nullptr) {
    delete _impl_.robot_body_pose_;
  }
  _impl_.robot_body_pose_ = nullptr;
}
inline const ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose& ActionWrapper::_internal_robot_body_pose() const {
  const ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* p = _impl_.robot_body_pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose&>(
      ::bosdyn::api::autowalk::_ActionWrapper_RobotBodyPose_default_instance_);
}
inline const ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose& ActionWrapper::robot_body_pose() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.robot_body_pose)
  return _internal_robot_body_pose();
}
inline void ActionWrapper::unsafe_arena_set_allocated_robot_body_pose(
    ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* robot_body_pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_body_pose_);
  }
  _impl_.robot_body_pose_ = robot_body_pose;
  if (robot_body_pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ActionWrapper.robot_body_pose)
}
inline ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* ActionWrapper::release_robot_body_pose() {
  
  ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* temp = _impl_.robot_body_pose_;
  _impl_.robot_body_pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* ActionWrapper::unsafe_arena_release_robot_body_pose() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ActionWrapper.robot_body_pose)
  
  ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* temp = _impl_.robot_body_pose_;
  _impl_.robot_body_pose_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* ActionWrapper::_internal_mutable_robot_body_pose() {
  
  if (_impl_.robot_body_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose>(GetArenaForAllocation());
    _impl_.robot_body_pose_ = p;
  }
  return _impl_.robot_body_pose_;
}
inline ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* ActionWrapper::mutable_robot_body_pose() {
  ::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* _msg = _internal_mutable_robot_body_pose();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ActionWrapper.robot_body_pose)
  return _msg;
}
inline void ActionWrapper::set_allocated_robot_body_pose(::bosdyn::api::autowalk::ActionWrapper_RobotBodyPose* robot_body_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.robot_body_pose_;
  }
  if (robot_body_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot_body_pose);
    if (message_arena != submessage_arena) {
      robot_body_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_body_pose, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.robot_body_pose_ = robot_body_pose;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ActionWrapper.robot_body_pose)
}

// .bosdyn.api.autowalk.ActionWrapper.SpotCamLed spot_cam_led = 4;
inline bool ActionWrapper::_internal_has_spot_cam_led() const {
  return this != internal_default_instance() && _impl_.spot_cam_led_ != nullptr;
}
inline bool ActionWrapper::has_spot_cam_led() const {
  return _internal_has_spot_cam_led();
}
inline void ActionWrapper::clear_spot_cam_led() {
  if (GetArenaForAllocation() == nullptr && _impl_.spot_cam_led_ != nullptr) {
    delete _impl_.spot_cam_led_;
  }
  _impl_.spot_cam_led_ = nullptr;
}
inline const ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed& ActionWrapper::_internal_spot_cam_led() const {
  const ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* p = _impl_.spot_cam_led_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed&>(
      ::bosdyn::api::autowalk::_ActionWrapper_SpotCamLed_default_instance_);
}
inline const ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed& ActionWrapper::spot_cam_led() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.spot_cam_led)
  return _internal_spot_cam_led();
}
inline void ActionWrapper::unsafe_arena_set_allocated_spot_cam_led(
    ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* spot_cam_led) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spot_cam_led_);
  }
  _impl_.spot_cam_led_ = spot_cam_led;
  if (spot_cam_led) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ActionWrapper.spot_cam_led)
}
inline ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* ActionWrapper::release_spot_cam_led() {
  
  ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* temp = _impl_.spot_cam_led_;
  _impl_.spot_cam_led_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* ActionWrapper::unsafe_arena_release_spot_cam_led() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ActionWrapper.spot_cam_led)
  
  ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* temp = _impl_.spot_cam_led_;
  _impl_.spot_cam_led_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* ActionWrapper::_internal_mutable_spot_cam_led() {
  
  if (_impl_.spot_cam_led_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper_SpotCamLed>(GetArenaForAllocation());
    _impl_.spot_cam_led_ = p;
  }
  return _impl_.spot_cam_led_;
}
inline ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* ActionWrapper::mutable_spot_cam_led() {
  ::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* _msg = _internal_mutable_spot_cam_led();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ActionWrapper.spot_cam_led)
  return _msg;
}
inline void ActionWrapper::set_allocated_spot_cam_led(::bosdyn::api::autowalk::ActionWrapper_SpotCamLed* spot_cam_led) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.spot_cam_led_;
  }
  if (spot_cam_led) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spot_cam_led);
    if (message_arena != submessage_arena) {
      spot_cam_led = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spot_cam_led, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spot_cam_led_ = spot_cam_led;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ActionWrapper.spot_cam_led)
}

// .bosdyn.api.autowalk.ActionWrapper.SpotCamPtz spot_cam_ptz = 5;
inline bool ActionWrapper::_internal_has_spot_cam_ptz() const {
  return this != internal_default_instance() && _impl_.spot_cam_ptz_ != nullptr;
}
inline bool ActionWrapper::has_spot_cam_ptz() const {
  return _internal_has_spot_cam_ptz();
}
inline void ActionWrapper::clear_spot_cam_ptz() {
  if (GetArenaForAllocation() == nullptr && _impl_.spot_cam_ptz_ != nullptr) {
    delete _impl_.spot_cam_ptz_;
  }
  _impl_.spot_cam_ptz_ = nullptr;
}
inline const ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz& ActionWrapper::_internal_spot_cam_ptz() const {
  const ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* p = _impl_.spot_cam_ptz_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz&>(
      ::bosdyn::api::autowalk::_ActionWrapper_SpotCamPtz_default_instance_);
}
inline const ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz& ActionWrapper::spot_cam_ptz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.spot_cam_ptz)
  return _internal_spot_cam_ptz();
}
inline void ActionWrapper::unsafe_arena_set_allocated_spot_cam_ptz(
    ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* spot_cam_ptz) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spot_cam_ptz_);
  }
  _impl_.spot_cam_ptz_ = spot_cam_ptz;
  if (spot_cam_ptz) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ActionWrapper.spot_cam_ptz)
}
inline ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* ActionWrapper::release_spot_cam_ptz() {
  
  ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* temp = _impl_.spot_cam_ptz_;
  _impl_.spot_cam_ptz_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* ActionWrapper::unsafe_arena_release_spot_cam_ptz() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ActionWrapper.spot_cam_ptz)
  
  ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* temp = _impl_.spot_cam_ptz_;
  _impl_.spot_cam_ptz_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* ActionWrapper::_internal_mutable_spot_cam_ptz() {
  
  if (_impl_.spot_cam_ptz_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz>(GetArenaForAllocation());
    _impl_.spot_cam_ptz_ = p;
  }
  return _impl_.spot_cam_ptz_;
}
inline ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* ActionWrapper::mutable_spot_cam_ptz() {
  ::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* _msg = _internal_mutable_spot_cam_ptz();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ActionWrapper.spot_cam_ptz)
  return _msg;
}
inline void ActionWrapper::set_allocated_spot_cam_ptz(::bosdyn::api::autowalk::ActionWrapper_SpotCamPtz* spot_cam_ptz) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.spot_cam_ptz_;
  }
  if (spot_cam_ptz) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spot_cam_ptz);
    if (message_arena != submessage_arena) {
      spot_cam_ptz = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spot_cam_ptz, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spot_cam_ptz_ = spot_cam_ptz;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ActionWrapper.spot_cam_ptz)
}

// .bosdyn.api.autowalk.ActionWrapper.ArmSensorPointing arm_sensor_pointing = 6;
inline bool ActionWrapper::_internal_has_arm_sensor_pointing() const {
  return this != internal_default_instance() && _impl_.arm_sensor_pointing_ != nullptr;
}
inline bool ActionWrapper::has_arm_sensor_pointing() const {
  return _internal_has_arm_sensor_pointing();
}
inline void ActionWrapper::clear_arm_sensor_pointing() {
  if (GetArenaForAllocation() == nullptr && _impl_.arm_sensor_pointing_ != nullptr) {
    delete _impl_.arm_sensor_pointing_;
  }
  _impl_.arm_sensor_pointing_ = nullptr;
}
inline const ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing& ActionWrapper::_internal_arm_sensor_pointing() const {
  const ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* p = _impl_.arm_sensor_pointing_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing&>(
      ::bosdyn::api::autowalk::_ActionWrapper_ArmSensorPointing_default_instance_);
}
inline const ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing& ActionWrapper::arm_sensor_pointing() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.arm_sensor_pointing)
  return _internal_arm_sensor_pointing();
}
inline void ActionWrapper::unsafe_arena_set_allocated_arm_sensor_pointing(
    ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* arm_sensor_pointing) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arm_sensor_pointing_);
  }
  _impl_.arm_sensor_pointing_ = arm_sensor_pointing;
  if (arm_sensor_pointing) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ActionWrapper.arm_sensor_pointing)
}
inline ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* ActionWrapper::release_arm_sensor_pointing() {
  
  ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* temp = _impl_.arm_sensor_pointing_;
  _impl_.arm_sensor_pointing_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* ActionWrapper::unsafe_arena_release_arm_sensor_pointing() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ActionWrapper.arm_sensor_pointing)
  
  ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* temp = _impl_.arm_sensor_pointing_;
  _impl_.arm_sensor_pointing_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* ActionWrapper::_internal_mutable_arm_sensor_pointing() {
  
  if (_impl_.arm_sensor_pointing_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing>(GetArenaForAllocation());
    _impl_.arm_sensor_pointing_ = p;
  }
  return _impl_.arm_sensor_pointing_;
}
inline ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* ActionWrapper::mutable_arm_sensor_pointing() {
  ::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* _msg = _internal_mutable_arm_sensor_pointing();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ActionWrapper.arm_sensor_pointing)
  return _msg;
}
inline void ActionWrapper::set_allocated_arm_sensor_pointing(::bosdyn::api::autowalk::ActionWrapper_ArmSensorPointing* arm_sensor_pointing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.arm_sensor_pointing_;
  }
  if (arm_sensor_pointing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(arm_sensor_pointing);
    if (message_arena != submessage_arena) {
      arm_sensor_pointing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arm_sensor_pointing, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.arm_sensor_pointing_ = arm_sensor_pointing;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ActionWrapper.arm_sensor_pointing)
}

// .bosdyn.api.autowalk.ActionWrapper.GripperCameraParams gripper_camera_params = 7;
inline bool ActionWrapper::_internal_has_gripper_camera_params() const {
  return this != internal_default_instance() && _impl_.gripper_camera_params_ != nullptr;
}
inline bool ActionWrapper::has_gripper_camera_params() const {
  return _internal_has_gripper_camera_params();
}
inline void ActionWrapper::clear_gripper_camera_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.gripper_camera_params_ != nullptr) {
    delete _impl_.gripper_camera_params_;
  }
  _impl_.gripper_camera_params_ = nullptr;
}
inline const ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams& ActionWrapper::_internal_gripper_camera_params() const {
  const ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* p = _impl_.gripper_camera_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams&>(
      ::bosdyn::api::autowalk::_ActionWrapper_GripperCameraParams_default_instance_);
}
inline const ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams& ActionWrapper::gripper_camera_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.gripper_camera_params)
  return _internal_gripper_camera_params();
}
inline void ActionWrapper::unsafe_arena_set_allocated_gripper_camera_params(
    ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* gripper_camera_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gripper_camera_params_);
  }
  _impl_.gripper_camera_params_ = gripper_camera_params;
  if (gripper_camera_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ActionWrapper.gripper_camera_params)
}
inline ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* ActionWrapper::release_gripper_camera_params() {
  
  ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* temp = _impl_.gripper_camera_params_;
  _impl_.gripper_camera_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* ActionWrapper::unsafe_arena_release_gripper_camera_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ActionWrapper.gripper_camera_params)
  
  ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* temp = _impl_.gripper_camera_params_;
  _impl_.gripper_camera_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* ActionWrapper::_internal_mutable_gripper_camera_params() {
  
  if (_impl_.gripper_camera_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams>(GetArenaForAllocation());
    _impl_.gripper_camera_params_ = p;
  }
  return _impl_.gripper_camera_params_;
}
inline ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* ActionWrapper::mutable_gripper_camera_params() {
  ::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* _msg = _internal_mutable_gripper_camera_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ActionWrapper.gripper_camera_params)
  return _msg;
}
inline void ActionWrapper::set_allocated_gripper_camera_params(::bosdyn::api::autowalk::ActionWrapper_GripperCameraParams* gripper_camera_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gripper_camera_params_;
  }
  if (gripper_camera_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gripper_camera_params);
    if (message_arena != submessage_arena) {
      gripper_camera_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gripper_camera_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.gripper_camera_params_ = gripper_camera_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ActionWrapper.gripper_camera_params)
}

// .bosdyn.api.autowalk.ActionWrapper.GripperCommand gripper_command = 8;
inline bool ActionWrapper::_internal_has_gripper_command() const {
  return this != internal_default_instance() && _impl_.gripper_command_ != nullptr;
}
inline bool ActionWrapper::has_gripper_command() const {
  return _internal_has_gripper_command();
}
inline void ActionWrapper::clear_gripper_command() {
  if (GetArenaForAllocation() == nullptr && _impl_.gripper_command_ != nullptr) {
    delete _impl_.gripper_command_;
  }
  _impl_.gripper_command_ = nullptr;
}
inline const ::bosdyn::api::autowalk::ActionWrapper_GripperCommand& ActionWrapper::_internal_gripper_command() const {
  const ::bosdyn::api::autowalk::ActionWrapper_GripperCommand* p = _impl_.gripper_command_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::ActionWrapper_GripperCommand&>(
      ::bosdyn::api::autowalk::_ActionWrapper_GripperCommand_default_instance_);
}
inline const ::bosdyn::api::autowalk::ActionWrapper_GripperCommand& ActionWrapper::gripper_command() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ActionWrapper.gripper_command)
  return _internal_gripper_command();
}
inline void ActionWrapper::unsafe_arena_set_allocated_gripper_command(
    ::bosdyn::api::autowalk::ActionWrapper_GripperCommand* gripper_command) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gripper_command_);
  }
  _impl_.gripper_command_ = gripper_command;
  if (gripper_command) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ActionWrapper.gripper_command)
}
inline ::bosdyn::api::autowalk::ActionWrapper_GripperCommand* ActionWrapper::release_gripper_command() {
  
  ::bosdyn::api::autowalk::ActionWrapper_GripperCommand* temp = _impl_.gripper_command_;
  _impl_.gripper_command_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::ActionWrapper_GripperCommand* ActionWrapper::unsafe_arena_release_gripper_command() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ActionWrapper.gripper_command)
  
  ::bosdyn::api::autowalk::ActionWrapper_GripperCommand* temp = _impl_.gripper_command_;
  _impl_.gripper_command_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::ActionWrapper_GripperCommand* ActionWrapper::_internal_mutable_gripper_command() {
  
  if (_impl_.gripper_command_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::ActionWrapper_GripperCommand>(GetArenaForAllocation());
    _impl_.gripper_command_ = p;
  }
  return _impl_.gripper_command_;
}
inline ::bosdyn::api::autowalk::ActionWrapper_GripperCommand* ActionWrapper::mutable_gripper_command() {
  ::bosdyn::api::autowalk::ActionWrapper_GripperCommand* _msg = _internal_mutable_gripper_command();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ActionWrapper.gripper_command)
  return _msg;
}
inline void ActionWrapper::set_allocated_gripper_command(::bosdyn::api::autowalk::ActionWrapper_GripperCommand* gripper_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gripper_command_;
  }
  if (gripper_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gripper_command);
    if (message_arena != submessage_arena) {
      gripper_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gripper_command, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.gripper_command_ = gripper_command;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ActionWrapper.gripper_command)
}

// -------------------------------------------------------------------

// FailureBehavior_SafePowerOff

// .bosdyn.api.SafePowerOffCommand.Request request = 1;
inline bool FailureBehavior_SafePowerOff::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool FailureBehavior_SafePowerOff::has_request() const {
  return _internal_has_request();
}
inline const ::bosdyn::api::SafePowerOffCommand_Request& FailureBehavior_SafePowerOff::_internal_request() const {
  const ::bosdyn::api::SafePowerOffCommand_Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SafePowerOffCommand_Request&>(
      ::bosdyn::api::_SafePowerOffCommand_Request_default_instance_);
}
inline const ::bosdyn::api::SafePowerOffCommand_Request& FailureBehavior_SafePowerOff::request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.FailureBehavior.SafePowerOff.request)
  return _internal_request();
}
inline void FailureBehavior_SafePowerOff::unsafe_arena_set_allocated_request(
    ::bosdyn::api::SafePowerOffCommand_Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.FailureBehavior.SafePowerOff.request)
}
inline ::bosdyn::api::SafePowerOffCommand_Request* FailureBehavior_SafePowerOff::release_request() {
  
  ::bosdyn::api::SafePowerOffCommand_Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SafePowerOffCommand_Request* FailureBehavior_SafePowerOff::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.FailureBehavior.SafePowerOff.request)
  
  ::bosdyn::api::SafePowerOffCommand_Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SafePowerOffCommand_Request* FailureBehavior_SafePowerOff::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SafePowerOffCommand_Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::bosdyn::api::SafePowerOffCommand_Request* FailureBehavior_SafePowerOff::mutable_request() {
  ::bosdyn::api::SafePowerOffCommand_Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.FailureBehavior.SafePowerOff.request)
  return _msg;
}
inline void FailureBehavior_SafePowerOff::set_allocated_request(::bosdyn::api::SafePowerOffCommand_Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.FailureBehavior.SafePowerOff.request)
}

// -------------------------------------------------------------------

// FailureBehavior_ProceedIfAble

// -------------------------------------------------------------------

// FailureBehavior_ReturnToStartAndTryAgainLater

// .google.protobuf.Duration try_again_delay = 1;
inline bool FailureBehavior_ReturnToStartAndTryAgainLater::_internal_has_try_again_delay() const {
  return this != internal_default_instance() && _impl_.try_again_delay_ != nullptr;
}
inline bool FailureBehavior_ReturnToStartAndTryAgainLater::has_try_again_delay() const {
  return _internal_has_try_again_delay();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& FailureBehavior_ReturnToStartAndTryAgainLater::_internal_try_again_delay() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.try_again_delay_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& FailureBehavior_ReturnToStartAndTryAgainLater::try_again_delay() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.FailureBehavior.ReturnToStartAndTryAgainLater.try_again_delay)
  return _internal_try_again_delay();
}
inline void FailureBehavior_ReturnToStartAndTryAgainLater::unsafe_arena_set_allocated_try_again_delay(
    ::PROTOBUF_NAMESPACE_ID::Duration* try_again_delay) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.try_again_delay_);
  }
  _impl_.try_again_delay_ = try_again_delay;
  if (try_again_delay) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.FailureBehavior.ReturnToStartAndTryAgainLater.try_again_delay)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* FailureBehavior_ReturnToStartAndTryAgainLater::release_try_again_delay() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.try_again_delay_;
  _impl_.try_again_delay_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* FailureBehavior_ReturnToStartAndTryAgainLater::unsafe_arena_release_try_again_delay() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.FailureBehavior.ReturnToStartAndTryAgainLater.try_again_delay)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.try_again_delay_;
  _impl_.try_again_delay_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* FailureBehavior_ReturnToStartAndTryAgainLater::_internal_mutable_try_again_delay() {
  
  if (_impl_.try_again_delay_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.try_again_delay_ = p;
  }
  return _impl_.try_again_delay_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* FailureBehavior_ReturnToStartAndTryAgainLater::mutable_try_again_delay() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_try_again_delay();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.FailureBehavior.ReturnToStartAndTryAgainLater.try_again_delay)
  return _msg;
}
inline void FailureBehavior_ReturnToStartAndTryAgainLater::set_allocated_try_again_delay(::PROTOBUF_NAMESPACE_ID::Duration* try_again_delay) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.try_again_delay_);
  }
  if (try_again_delay) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(try_again_delay));
    if (message_arena != submessage_arena) {
      try_again_delay = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, try_again_delay, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.try_again_delay_ = try_again_delay;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.FailureBehavior.ReturnToStartAndTryAgainLater.try_again_delay)
}

// -------------------------------------------------------------------

// FailureBehavior_ReturnToStartAndTerminate

// -------------------------------------------------------------------

// FailureBehavior

// int32 retry_count = 1;
inline void FailureBehavior::clear_retry_count() {
  _impl_.retry_count_ = 0;
}
inline int32_t FailureBehavior::_internal_retry_count() const {
  return _impl_.retry_count_;
}
inline int32_t FailureBehavior::retry_count() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.FailureBehavior.retry_count)
  return _internal_retry_count();
}
inline void FailureBehavior::_internal_set_retry_count(int32_t value) {
  
  _impl_.retry_count_ = value;
}
inline void FailureBehavior::set_retry_count(int32_t value) {
  _internal_set_retry_count(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.FailureBehavior.retry_count)
}

// .google.protobuf.Duration prompt_duration = 2;
inline bool FailureBehavior::_internal_has_prompt_duration() const {
  return this != internal_default_instance() && _impl_.prompt_duration_ != nullptr;
}
inline bool FailureBehavior::has_prompt_duration() const {
  return _internal_has_prompt_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& FailureBehavior::_internal_prompt_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.prompt_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& FailureBehavior::prompt_duration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.FailureBehavior.prompt_duration)
  return _internal_prompt_duration();
}
inline void FailureBehavior::unsafe_arena_set_allocated_prompt_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* prompt_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prompt_duration_);
  }
  _impl_.prompt_duration_ = prompt_duration;
  if (prompt_duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.FailureBehavior.prompt_duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* FailureBehavior::release_prompt_duration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.prompt_duration_;
  _impl_.prompt_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* FailureBehavior::unsafe_arena_release_prompt_duration() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.FailureBehavior.prompt_duration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.prompt_duration_;
  _impl_.prompt_duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* FailureBehavior::_internal_mutable_prompt_duration() {
  
  if (_impl_.prompt_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.prompt_duration_ = p;
  }
  return _impl_.prompt_duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* FailureBehavior::mutable_prompt_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_prompt_duration();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.FailureBehavior.prompt_duration)
  return _msg;
}
inline void FailureBehavior::set_allocated_prompt_duration(::PROTOBUF_NAMESPACE_ID::Duration* prompt_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prompt_duration_);
  }
  if (prompt_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prompt_duration));
    if (message_arena != submessage_arena) {
      prompt_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prompt_duration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.prompt_duration_ = prompt_duration;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.FailureBehavior.prompt_duration)
}

// .bosdyn.api.autowalk.FailureBehavior.SafePowerOff safe_power_off = 3;
inline bool FailureBehavior::_internal_has_safe_power_off() const {
  return default_behavior_case() == kSafePowerOff;
}
inline bool FailureBehavior::has_safe_power_off() const {
  return _internal_has_safe_power_off();
}
inline void FailureBehavior::set_has_safe_power_off() {
  _impl_._oneof_case_[0] = kSafePowerOff;
}
inline void FailureBehavior::clear_safe_power_off() {
  if (_internal_has_safe_power_off()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.default_behavior_.safe_power_off_;
    }
    clear_has_default_behavior();
  }
}
inline ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff* FailureBehavior::release_safe_power_off() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.FailureBehavior.safe_power_off)
  if (_internal_has_safe_power_off()) {
    clear_has_default_behavior();
    ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff* temp = _impl_.default_behavior_.safe_power_off_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.default_behavior_.safe_power_off_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff& FailureBehavior::_internal_safe_power_off() const {
  return _internal_has_safe_power_off()
      ? *_impl_.default_behavior_.safe_power_off_
      : reinterpret_cast< ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff&>(::bosdyn::api::autowalk::_FailureBehavior_SafePowerOff_default_instance_);
}
inline const ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff& FailureBehavior::safe_power_off() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.FailureBehavior.safe_power_off)
  return _internal_safe_power_off();
}
inline ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff* FailureBehavior::unsafe_arena_release_safe_power_off() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.autowalk.FailureBehavior.safe_power_off)
  if (_internal_has_safe_power_off()) {
    clear_has_default_behavior();
    ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff* temp = _impl_.default_behavior_.safe_power_off_;
    _impl_.default_behavior_.safe_power_off_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FailureBehavior::unsafe_arena_set_allocated_safe_power_off(::bosdyn::api::autowalk::FailureBehavior_SafePowerOff* safe_power_off) {
  clear_default_behavior();
  if (safe_power_off) {
    set_has_safe_power_off();
    _impl_.default_behavior_.safe_power_off_ = safe_power_off;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.FailureBehavior.safe_power_off)
}
inline ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff* FailureBehavior::_internal_mutable_safe_power_off() {
  if (!_internal_has_safe_power_off()) {
    clear_default_behavior();
    set_has_safe_power_off();
    _impl_.default_behavior_.safe_power_off_ = CreateMaybeMessage< ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff >(GetArenaForAllocation());
  }
  return _impl_.default_behavior_.safe_power_off_;
}
inline ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff* FailureBehavior::mutable_safe_power_off() {
  ::bosdyn::api::autowalk::FailureBehavior_SafePowerOff* _msg = _internal_mutable_safe_power_off();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.FailureBehavior.safe_power_off)
  return _msg;
}

// .bosdyn.api.autowalk.FailureBehavior.ProceedIfAble proceed_if_able = 4;
inline bool FailureBehavior::_internal_has_proceed_if_able() const {
  return default_behavior_case() == kProceedIfAble;
}
inline bool FailureBehavior::has_proceed_if_able() const {
  return _internal_has_proceed_if_able();
}
inline void FailureBehavior::set_has_proceed_if_able() {
  _impl_._oneof_case_[0] = kProceedIfAble;
}
inline void FailureBehavior::clear_proceed_if_able() {
  if (_internal_has_proceed_if_able()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.default_behavior_.proceed_if_able_;
    }
    clear_has_default_behavior();
  }
}
inline ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble* FailureBehavior::release_proceed_if_able() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.FailureBehavior.proceed_if_able)
  if (_internal_has_proceed_if_able()) {
    clear_has_default_behavior();
    ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble* temp = _impl_.default_behavior_.proceed_if_able_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.default_behavior_.proceed_if_able_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble& FailureBehavior::_internal_proceed_if_able() const {
  return _internal_has_proceed_if_able()
      ? *_impl_.default_behavior_.proceed_if_able_
      : reinterpret_cast< ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble&>(::bosdyn::api::autowalk::_FailureBehavior_ProceedIfAble_default_instance_);
}
inline const ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble& FailureBehavior::proceed_if_able() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.FailureBehavior.proceed_if_able)
  return _internal_proceed_if_able();
}
inline ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble* FailureBehavior::unsafe_arena_release_proceed_if_able() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.autowalk.FailureBehavior.proceed_if_able)
  if (_internal_has_proceed_if_able()) {
    clear_has_default_behavior();
    ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble* temp = _impl_.default_behavior_.proceed_if_able_;
    _impl_.default_behavior_.proceed_if_able_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FailureBehavior::unsafe_arena_set_allocated_proceed_if_able(::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble* proceed_if_able) {
  clear_default_behavior();
  if (proceed_if_able) {
    set_has_proceed_if_able();
    _impl_.default_behavior_.proceed_if_able_ = proceed_if_able;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.FailureBehavior.proceed_if_able)
}
inline ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble* FailureBehavior::_internal_mutable_proceed_if_able() {
  if (!_internal_has_proceed_if_able()) {
    clear_default_behavior();
    set_has_proceed_if_able();
    _impl_.default_behavior_.proceed_if_able_ = CreateMaybeMessage< ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble >(GetArenaForAllocation());
  }
  return _impl_.default_behavior_.proceed_if_able_;
}
inline ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble* FailureBehavior::mutable_proceed_if_able() {
  ::bosdyn::api::autowalk::FailureBehavior_ProceedIfAble* _msg = _internal_mutable_proceed_if_able();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.FailureBehavior.proceed_if_able)
  return _msg;
}

// .bosdyn.api.autowalk.FailureBehavior.ReturnToStartAndTryAgainLater return_to_start_and_try_again_later = 5;
inline bool FailureBehavior::_internal_has_return_to_start_and_try_again_later() const {
  return default_behavior_case() == kReturnToStartAndTryAgainLater;
}
inline bool FailureBehavior::has_return_to_start_and_try_again_later() const {
  return _internal_has_return_to_start_and_try_again_later();
}
inline void FailureBehavior::set_has_return_to_start_and_try_again_later() {
  _impl_._oneof_case_[0] = kReturnToStartAndTryAgainLater;
}
inline void FailureBehavior::clear_return_to_start_and_try_again_later() {
  if (_internal_has_return_to_start_and_try_again_later()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.default_behavior_.return_to_start_and_try_again_later_;
    }
    clear_has_default_behavior();
  }
}
inline ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater* FailureBehavior::release_return_to_start_and_try_again_later() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.FailureBehavior.return_to_start_and_try_again_later)
  if (_internal_has_return_to_start_and_try_again_later()) {
    clear_has_default_behavior();
    ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater* temp = _impl_.default_behavior_.return_to_start_and_try_again_later_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.default_behavior_.return_to_start_and_try_again_later_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater& FailureBehavior::_internal_return_to_start_and_try_again_later() const {
  return _internal_has_return_to_start_and_try_again_later()
      ? *_impl_.default_behavior_.return_to_start_and_try_again_later_
      : reinterpret_cast< ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater&>(::bosdyn::api::autowalk::_FailureBehavior_ReturnToStartAndTryAgainLater_default_instance_);
}
inline const ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater& FailureBehavior::return_to_start_and_try_again_later() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.FailureBehavior.return_to_start_and_try_again_later)
  return _internal_return_to_start_and_try_again_later();
}
inline ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater* FailureBehavior::unsafe_arena_release_return_to_start_and_try_again_later() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.autowalk.FailureBehavior.return_to_start_and_try_again_later)
  if (_internal_has_return_to_start_and_try_again_later()) {
    clear_has_default_behavior();
    ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater* temp = _impl_.default_behavior_.return_to_start_and_try_again_later_;
    _impl_.default_behavior_.return_to_start_and_try_again_later_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FailureBehavior::unsafe_arena_set_allocated_return_to_start_and_try_again_later(::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater* return_to_start_and_try_again_later) {
  clear_default_behavior();
  if (return_to_start_and_try_again_later) {
    set_has_return_to_start_and_try_again_later();
    _impl_.default_behavior_.return_to_start_and_try_again_later_ = return_to_start_and_try_again_later;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.FailureBehavior.return_to_start_and_try_again_later)
}
inline ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater* FailureBehavior::_internal_mutable_return_to_start_and_try_again_later() {
  if (!_internal_has_return_to_start_and_try_again_later()) {
    clear_default_behavior();
    set_has_return_to_start_and_try_again_later();
    _impl_.default_behavior_.return_to_start_and_try_again_later_ = CreateMaybeMessage< ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater >(GetArenaForAllocation());
  }
  return _impl_.default_behavior_.return_to_start_and_try_again_later_;
}
inline ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater* FailureBehavior::mutable_return_to_start_and_try_again_later() {
  ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTryAgainLater* _msg = _internal_mutable_return_to_start_and_try_again_later();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.FailureBehavior.return_to_start_and_try_again_later)
  return _msg;
}

// .bosdyn.api.autowalk.FailureBehavior.ReturnToStartAndTerminate return_to_start_and_terminate = 6;
inline bool FailureBehavior::_internal_has_return_to_start_and_terminate() const {
  return default_behavior_case() == kReturnToStartAndTerminate;
}
inline bool FailureBehavior::has_return_to_start_and_terminate() const {
  return _internal_has_return_to_start_and_terminate();
}
inline void FailureBehavior::set_has_return_to_start_and_terminate() {
  _impl_._oneof_case_[0] = kReturnToStartAndTerminate;
}
inline void FailureBehavior::clear_return_to_start_and_terminate() {
  if (_internal_has_return_to_start_and_terminate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.default_behavior_.return_to_start_and_terminate_;
    }
    clear_has_default_behavior();
  }
}
inline ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate* FailureBehavior::release_return_to_start_and_terminate() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.FailureBehavior.return_to_start_and_terminate)
  if (_internal_has_return_to_start_and_terminate()) {
    clear_has_default_behavior();
    ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate* temp = _impl_.default_behavior_.return_to_start_and_terminate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.default_behavior_.return_to_start_and_terminate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate& FailureBehavior::_internal_return_to_start_and_terminate() const {
  return _internal_has_return_to_start_and_terminate()
      ? *_impl_.default_behavior_.return_to_start_and_terminate_
      : reinterpret_cast< ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate&>(::bosdyn::api::autowalk::_FailureBehavior_ReturnToStartAndTerminate_default_instance_);
}
inline const ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate& FailureBehavior::return_to_start_and_terminate() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.FailureBehavior.return_to_start_and_terminate)
  return _internal_return_to_start_and_terminate();
}
inline ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate* FailureBehavior::unsafe_arena_release_return_to_start_and_terminate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.autowalk.FailureBehavior.return_to_start_and_terminate)
  if (_internal_has_return_to_start_and_terminate()) {
    clear_has_default_behavior();
    ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate* temp = _impl_.default_behavior_.return_to_start_and_terminate_;
    _impl_.default_behavior_.return_to_start_and_terminate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FailureBehavior::unsafe_arena_set_allocated_return_to_start_and_terminate(::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate* return_to_start_and_terminate) {
  clear_default_behavior();
  if (return_to_start_and_terminate) {
    set_has_return_to_start_and_terminate();
    _impl_.default_behavior_.return_to_start_and_terminate_ = return_to_start_and_terminate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.FailureBehavior.return_to_start_and_terminate)
}
inline ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate* FailureBehavior::_internal_mutable_return_to_start_and_terminate() {
  if (!_internal_has_return_to_start_and_terminate()) {
    clear_default_behavior();
    set_has_return_to_start_and_terminate();
    _impl_.default_behavior_.return_to_start_and_terminate_ = CreateMaybeMessage< ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate >(GetArenaForAllocation());
  }
  return _impl_.default_behavior_.return_to_start_and_terminate_;
}
inline ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate* FailureBehavior::mutable_return_to_start_and_terminate() {
  ::bosdyn::api::autowalk::FailureBehavior_ReturnToStartAndTerminate* _msg = _internal_mutable_return_to_start_and_terminate();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.FailureBehavior.return_to_start_and_terminate)
  return _msg;
}

inline bool FailureBehavior::has_default_behavior() const {
  return default_behavior_case() != DEFAULT_BEHAVIOR_NOT_SET;
}
inline void FailureBehavior::clear_has_default_behavior() {
  _impl_._oneof_case_[0] = DEFAULT_BEHAVIOR_NOT_SET;
}
inline FailureBehavior::DefaultBehaviorCase FailureBehavior::default_behavior_case() const {
  return FailureBehavior::DefaultBehaviorCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BatteryMonitor

// float battery_start_threshold = 2;
inline void BatteryMonitor::clear_battery_start_threshold() {
  _impl_.battery_start_threshold_ = 0;
}
inline float BatteryMonitor::_internal_battery_start_threshold() const {
  return _impl_.battery_start_threshold_;
}
inline float BatteryMonitor::battery_start_threshold() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.BatteryMonitor.battery_start_threshold)
  return _internal_battery_start_threshold();
}
inline void BatteryMonitor::_internal_set_battery_start_threshold(float value) {
  
  _impl_.battery_start_threshold_ = value;
}
inline void BatteryMonitor::set_battery_start_threshold(float value) {
  _internal_set_battery_start_threshold(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.BatteryMonitor.battery_start_threshold)
}

// float battery_stop_threshold = 3;
inline void BatteryMonitor::clear_battery_stop_threshold() {
  _impl_.battery_stop_threshold_ = 0;
}
inline float BatteryMonitor::_internal_battery_stop_threshold() const {
  return _impl_.battery_stop_threshold_;
}
inline float BatteryMonitor::battery_stop_threshold() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.BatteryMonitor.battery_stop_threshold)
  return _internal_battery_stop_threshold();
}
inline void BatteryMonitor::_internal_set_battery_stop_threshold(float value) {
  
  _impl_.battery_stop_threshold_ = value;
}
inline void BatteryMonitor::set_battery_stop_threshold(float value) {
  _internal_set_battery_stop_threshold(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.BatteryMonitor.battery_stop_threshold)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace autowalk
}  // namespace api
}  // namespace bosdyn

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fautowalk_2fwalks_2eproto
