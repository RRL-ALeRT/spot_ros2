// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/estop.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2festop_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2festop_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/header.pb.h"
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2festop_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2festop_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2festop_2eproto;
namespace bosdyn {
namespace api {
class DeregisterEstopEndpointRequest;
struct DeregisterEstopEndpointRequestDefaultTypeInternal;
extern DeregisterEstopEndpointRequestDefaultTypeInternal _DeregisterEstopEndpointRequest_default_instance_;
class DeregisterEstopEndpointResponse;
struct DeregisterEstopEndpointResponseDefaultTypeInternal;
extern DeregisterEstopEndpointResponseDefaultTypeInternal _DeregisterEstopEndpointResponse_default_instance_;
class EstopCheckInRequest;
struct EstopCheckInRequestDefaultTypeInternal;
extern EstopCheckInRequestDefaultTypeInternal _EstopCheckInRequest_default_instance_;
class EstopCheckInResponse;
struct EstopCheckInResponseDefaultTypeInternal;
extern EstopCheckInResponseDefaultTypeInternal _EstopCheckInResponse_default_instance_;
class EstopConfig;
struct EstopConfigDefaultTypeInternal;
extern EstopConfigDefaultTypeInternal _EstopConfig_default_instance_;
class EstopEndpoint;
struct EstopEndpointDefaultTypeInternal;
extern EstopEndpointDefaultTypeInternal _EstopEndpoint_default_instance_;
class EstopEndpointWithStatus;
struct EstopEndpointWithStatusDefaultTypeInternal;
extern EstopEndpointWithStatusDefaultTypeInternal _EstopEndpointWithStatus_default_instance_;
class EstopSystemStatus;
struct EstopSystemStatusDefaultTypeInternal;
extern EstopSystemStatusDefaultTypeInternal _EstopSystemStatus_default_instance_;
class GetEstopConfigRequest;
struct GetEstopConfigRequestDefaultTypeInternal;
extern GetEstopConfigRequestDefaultTypeInternal _GetEstopConfigRequest_default_instance_;
class GetEstopConfigResponse;
struct GetEstopConfigResponseDefaultTypeInternal;
extern GetEstopConfigResponseDefaultTypeInternal _GetEstopConfigResponse_default_instance_;
class GetEstopSystemStatusRequest;
struct GetEstopSystemStatusRequestDefaultTypeInternal;
extern GetEstopSystemStatusRequestDefaultTypeInternal _GetEstopSystemStatusRequest_default_instance_;
class GetEstopSystemStatusResponse;
struct GetEstopSystemStatusResponseDefaultTypeInternal;
extern GetEstopSystemStatusResponseDefaultTypeInternal _GetEstopSystemStatusResponse_default_instance_;
class RegisterEstopEndpointRequest;
struct RegisterEstopEndpointRequestDefaultTypeInternal;
extern RegisterEstopEndpointRequestDefaultTypeInternal _RegisterEstopEndpointRequest_default_instance_;
class RegisterEstopEndpointResponse;
struct RegisterEstopEndpointResponseDefaultTypeInternal;
extern RegisterEstopEndpointResponseDefaultTypeInternal _RegisterEstopEndpointResponse_default_instance_;
class SetEstopConfigRequest;
struct SetEstopConfigRequestDefaultTypeInternal;
extern SetEstopConfigRequestDefaultTypeInternal _SetEstopConfigRequest_default_instance_;
class SetEstopConfigResponse;
struct SetEstopConfigResponseDefaultTypeInternal;
extern SetEstopConfigResponseDefaultTypeInternal _SetEstopConfigResponse_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::DeregisterEstopEndpointRequest* Arena::CreateMaybeMessage<::bosdyn::api::DeregisterEstopEndpointRequest>(Arena*);
template<> ::bosdyn::api::DeregisterEstopEndpointResponse* Arena::CreateMaybeMessage<::bosdyn::api::DeregisterEstopEndpointResponse>(Arena*);
template<> ::bosdyn::api::EstopCheckInRequest* Arena::CreateMaybeMessage<::bosdyn::api::EstopCheckInRequest>(Arena*);
template<> ::bosdyn::api::EstopCheckInResponse* Arena::CreateMaybeMessage<::bosdyn::api::EstopCheckInResponse>(Arena*);
template<> ::bosdyn::api::EstopConfig* Arena::CreateMaybeMessage<::bosdyn::api::EstopConfig>(Arena*);
template<> ::bosdyn::api::EstopEndpoint* Arena::CreateMaybeMessage<::bosdyn::api::EstopEndpoint>(Arena*);
template<> ::bosdyn::api::EstopEndpointWithStatus* Arena::CreateMaybeMessage<::bosdyn::api::EstopEndpointWithStatus>(Arena*);
template<> ::bosdyn::api::EstopSystemStatus* Arena::CreateMaybeMessage<::bosdyn::api::EstopSystemStatus>(Arena*);
template<> ::bosdyn::api::GetEstopConfigRequest* Arena::CreateMaybeMessage<::bosdyn::api::GetEstopConfigRequest>(Arena*);
template<> ::bosdyn::api::GetEstopConfigResponse* Arena::CreateMaybeMessage<::bosdyn::api::GetEstopConfigResponse>(Arena*);
template<> ::bosdyn::api::GetEstopSystemStatusRequest* Arena::CreateMaybeMessage<::bosdyn::api::GetEstopSystemStatusRequest>(Arena*);
template<> ::bosdyn::api::GetEstopSystemStatusResponse* Arena::CreateMaybeMessage<::bosdyn::api::GetEstopSystemStatusResponse>(Arena*);
template<> ::bosdyn::api::RegisterEstopEndpointRequest* Arena::CreateMaybeMessage<::bosdyn::api::RegisterEstopEndpointRequest>(Arena*);
template<> ::bosdyn::api::RegisterEstopEndpointResponse* Arena::CreateMaybeMessage<::bosdyn::api::RegisterEstopEndpointResponse>(Arena*);
template<> ::bosdyn::api::SetEstopConfigRequest* Arena::CreateMaybeMessage<::bosdyn::api::SetEstopConfigRequest>(Arena*);
template<> ::bosdyn::api::SetEstopConfigResponse* Arena::CreateMaybeMessage<::bosdyn::api::SetEstopConfigResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum EstopCheckInResponse_Status : int {
  EstopCheckInResponse_Status_STATUS_UNKNOWN = 0,
  EstopCheckInResponse_Status_STATUS_OK = 1,
  EstopCheckInResponse_Status_STATUS_ENDPOINT_UNKNOWN = 2,
  EstopCheckInResponse_Status_STATUS_INCORRECT_CHALLENGE_RESPONSE = 5,
  EstopCheckInResponse_Status_EstopCheckInResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EstopCheckInResponse_Status_EstopCheckInResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EstopCheckInResponse_Status_IsValid(int value);
constexpr EstopCheckInResponse_Status EstopCheckInResponse_Status_Status_MIN = EstopCheckInResponse_Status_STATUS_UNKNOWN;
constexpr EstopCheckInResponse_Status EstopCheckInResponse_Status_Status_MAX = EstopCheckInResponse_Status_STATUS_INCORRECT_CHALLENGE_RESPONSE;
constexpr int EstopCheckInResponse_Status_Status_ARRAYSIZE = EstopCheckInResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EstopCheckInResponse_Status_descriptor();
template<typename T>
inline const std::string& EstopCheckInResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EstopCheckInResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EstopCheckInResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EstopCheckInResponse_Status_descriptor(), enum_t_value);
}
inline bool EstopCheckInResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EstopCheckInResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EstopCheckInResponse_Status>(
    EstopCheckInResponse_Status_descriptor(), name, value);
}
enum RegisterEstopEndpointResponse_Status : int {
  RegisterEstopEndpointResponse_Status_STATUS_UNKNOWN = 0,
  RegisterEstopEndpointResponse_Status_STATUS_SUCCESS = 1,
  RegisterEstopEndpointResponse_Status_STATUS_ENDPOINT_MISMATCH = 2,
  RegisterEstopEndpointResponse_Status_STATUS_CONFIG_MISMATCH = 3,
  RegisterEstopEndpointResponse_Status_STATUS_INVALID_ENDPOINT = 4,
  RegisterEstopEndpointResponse_Status_RegisterEstopEndpointResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RegisterEstopEndpointResponse_Status_RegisterEstopEndpointResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RegisterEstopEndpointResponse_Status_IsValid(int value);
constexpr RegisterEstopEndpointResponse_Status RegisterEstopEndpointResponse_Status_Status_MIN = RegisterEstopEndpointResponse_Status_STATUS_UNKNOWN;
constexpr RegisterEstopEndpointResponse_Status RegisterEstopEndpointResponse_Status_Status_MAX = RegisterEstopEndpointResponse_Status_STATUS_INVALID_ENDPOINT;
constexpr int RegisterEstopEndpointResponse_Status_Status_ARRAYSIZE = RegisterEstopEndpointResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegisterEstopEndpointResponse_Status_descriptor();
template<typename T>
inline const std::string& RegisterEstopEndpointResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegisterEstopEndpointResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegisterEstopEndpointResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RegisterEstopEndpointResponse_Status_descriptor(), enum_t_value);
}
inline bool RegisterEstopEndpointResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RegisterEstopEndpointResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RegisterEstopEndpointResponse_Status>(
    RegisterEstopEndpointResponse_Status_descriptor(), name, value);
}
enum DeregisterEstopEndpointResponse_Status : int {
  DeregisterEstopEndpointResponse_Status_STATUS_UNKNOWN = 0,
  DeregisterEstopEndpointResponse_Status_STATUS_SUCCESS = 1,
  DeregisterEstopEndpointResponse_Status_STATUS_ENDPOINT_MISMATCH = 2,
  DeregisterEstopEndpointResponse_Status_STATUS_CONFIG_MISMATCH = 3,
  DeregisterEstopEndpointResponse_Status_STATUS_MOTORS_ON = 4,
  DeregisterEstopEndpointResponse_Status_DeregisterEstopEndpointResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DeregisterEstopEndpointResponse_Status_DeregisterEstopEndpointResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DeregisterEstopEndpointResponse_Status_IsValid(int value);
constexpr DeregisterEstopEndpointResponse_Status DeregisterEstopEndpointResponse_Status_Status_MIN = DeregisterEstopEndpointResponse_Status_STATUS_UNKNOWN;
constexpr DeregisterEstopEndpointResponse_Status DeregisterEstopEndpointResponse_Status_Status_MAX = DeregisterEstopEndpointResponse_Status_STATUS_MOTORS_ON;
constexpr int DeregisterEstopEndpointResponse_Status_Status_ARRAYSIZE = DeregisterEstopEndpointResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeregisterEstopEndpointResponse_Status_descriptor();
template<typename T>
inline const std::string& DeregisterEstopEndpointResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeregisterEstopEndpointResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeregisterEstopEndpointResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeregisterEstopEndpointResponse_Status_descriptor(), enum_t_value);
}
inline bool DeregisterEstopEndpointResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeregisterEstopEndpointResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeregisterEstopEndpointResponse_Status>(
    DeregisterEstopEndpointResponse_Status_descriptor(), name, value);
}
enum SetEstopConfigResponse_Status : int {
  SetEstopConfigResponse_Status_STATUS_UNKNOWN = 0,
  SetEstopConfigResponse_Status_STATUS_SUCCESS = 1,
  SetEstopConfigResponse_Status_STATUS_INVALID_ID = 2,
  SetEstopConfigResponse_Status_STATUS_MOTORS_ON = 4,
  SetEstopConfigResponse_Status_SetEstopConfigResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SetEstopConfigResponse_Status_SetEstopConfigResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SetEstopConfigResponse_Status_IsValid(int value);
constexpr SetEstopConfigResponse_Status SetEstopConfigResponse_Status_Status_MIN = SetEstopConfigResponse_Status_STATUS_UNKNOWN;
constexpr SetEstopConfigResponse_Status SetEstopConfigResponse_Status_Status_MAX = SetEstopConfigResponse_Status_STATUS_MOTORS_ON;
constexpr int SetEstopConfigResponse_Status_Status_ARRAYSIZE = SetEstopConfigResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SetEstopConfigResponse_Status_descriptor();
template<typename T>
inline const std::string& SetEstopConfigResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SetEstopConfigResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SetEstopConfigResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SetEstopConfigResponse_Status_descriptor(), enum_t_value);
}
inline bool SetEstopConfigResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SetEstopConfigResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SetEstopConfigResponse_Status>(
    SetEstopConfigResponse_Status_descriptor(), name, value);
}
enum EstopStopLevel : int {
  ESTOP_LEVEL_UNKNOWN = 0,
  ESTOP_LEVEL_CUT = 1,
  ESTOP_LEVEL_SETTLE_THEN_CUT = 2,
  ESTOP_LEVEL_NONE = 4,
  EstopStopLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EstopStopLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EstopStopLevel_IsValid(int value);
constexpr EstopStopLevel EstopStopLevel_MIN = ESTOP_LEVEL_UNKNOWN;
constexpr EstopStopLevel EstopStopLevel_MAX = ESTOP_LEVEL_NONE;
constexpr int EstopStopLevel_ARRAYSIZE = EstopStopLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EstopStopLevel_descriptor();
template<typename T>
inline const std::string& EstopStopLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EstopStopLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EstopStopLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EstopStopLevel_descriptor(), enum_t_value);
}
inline bool EstopStopLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EstopStopLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EstopStopLevel>(
    EstopStopLevel_descriptor(), name, value);
}
// ===================================================================

class EstopEndpoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EstopEndpoint) */ {
 public:
  inline EstopEndpoint() : EstopEndpoint(nullptr) {}
  ~EstopEndpoint() override;
  explicit PROTOBUF_CONSTEXPR EstopEndpoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EstopEndpoint(const EstopEndpoint& from);
  EstopEndpoint(EstopEndpoint&& from) noexcept
    : EstopEndpoint() {
    *this = ::std::move(from);
  }

  inline EstopEndpoint& operator=(const EstopEndpoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline EstopEndpoint& operator=(EstopEndpoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EstopEndpoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const EstopEndpoint* internal_default_instance() {
    return reinterpret_cast<const EstopEndpoint*>(
               &_EstopEndpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EstopEndpoint& a, EstopEndpoint& b) {
    a.Swap(&b);
  }
  inline void Swap(EstopEndpoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EstopEndpoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EstopEndpoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EstopEndpoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EstopEndpoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EstopEndpoint& from) {
    EstopEndpoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EstopEndpoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EstopEndpoint";
  }
  protected:
  explicit EstopEndpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 1,
    kNameFieldNumber = 2,
    kUniqueIdFieldNumber = 3,
    kTimeoutFieldNumber = 4,
    kCutPowerTimeoutFieldNumber = 5,
  };
  // string role = 1;
  void clear_role();
  const std::string& role() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_role(ArgT0&& arg0, ArgT... args);
  std::string* mutable_role();
  PROTOBUF_NODISCARD std::string* release_role();
  void set_allocated_role(std::string* role);
  private:
  const std::string& _internal_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role(const std::string& value);
  std::string* _internal_mutable_role();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string unique_id = 3;
  void clear_unique_id();
  const std::string& unique_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unique_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unique_id();
  PROTOBUF_NODISCARD std::string* release_unique_id();
  void set_allocated_unique_id(std::string* unique_id);
  private:
  const std::string& _internal_unique_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unique_id(const std::string& value);
  std::string* _internal_mutable_unique_id();
  public:

  // .google.protobuf.Duration timeout = 4;
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;
  public:
  void clear_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_timeout();
  void set_allocated_timeout(::PROTOBUF_NAMESPACE_ID::Duration* timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_timeout();
  public:
  void unsafe_arena_set_allocated_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_timeout();

  // .google.protobuf.Duration cut_power_timeout = 5;
  bool has_cut_power_timeout() const;
  private:
  bool _internal_has_cut_power_timeout() const;
  public:
  void clear_cut_power_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& cut_power_timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_cut_power_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_cut_power_timeout();
  void set_allocated_cut_power_timeout(::PROTOBUF_NAMESPACE_ID::Duration* cut_power_timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_cut_power_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_cut_power_timeout();
  public:
  void unsafe_arena_set_allocated_cut_power_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* cut_power_timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_cut_power_timeout();

  // @@protoc_insertion_point(class_scope:bosdyn.api.EstopEndpoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_id_;
    ::PROTOBUF_NAMESPACE_ID::Duration* timeout_;
    ::PROTOBUF_NAMESPACE_ID::Duration* cut_power_timeout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class EstopConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EstopConfig) */ {
 public:
  inline EstopConfig() : EstopConfig(nullptr) {}
  ~EstopConfig() override;
  explicit PROTOBUF_CONSTEXPR EstopConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EstopConfig(const EstopConfig& from);
  EstopConfig(EstopConfig&& from) noexcept
    : EstopConfig() {
    *this = ::std::move(from);
  }

  inline EstopConfig& operator=(const EstopConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline EstopConfig& operator=(EstopConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EstopConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const EstopConfig* internal_default_instance() {
    return reinterpret_cast<const EstopConfig*>(
               &_EstopConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EstopConfig& a, EstopConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(EstopConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EstopConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EstopConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EstopConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EstopConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EstopConfig& from) {
    EstopConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EstopConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EstopConfig";
  }
  protected:
  explicit EstopConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointsFieldNumber = 1,
    kUniqueIdFieldNumber = 2,
  };
  // repeated .bosdyn.api.EstopEndpoint endpoints = 1;
  int endpoints_size() const;
  private:
  int _internal_endpoints_size() const;
  public:
  void clear_endpoints();
  ::bosdyn::api::EstopEndpoint* mutable_endpoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpoint >*
      mutable_endpoints();
  private:
  const ::bosdyn::api::EstopEndpoint& _internal_endpoints(int index) const;
  ::bosdyn::api::EstopEndpoint* _internal_add_endpoints();
  public:
  const ::bosdyn::api::EstopEndpoint& endpoints(int index) const;
  ::bosdyn::api::EstopEndpoint* add_endpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpoint >&
      endpoints() const;

  // string unique_id = 2;
  void clear_unique_id();
  const std::string& unique_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unique_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unique_id();
  PROTOBUF_NODISCARD std::string* release_unique_id();
  void set_allocated_unique_id(std::string* unique_id);
  private:
  const std::string& _internal_unique_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unique_id(const std::string& value);
  std::string* _internal_mutable_unique_id();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.EstopConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpoint > endpoints_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class EstopEndpointWithStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EstopEndpointWithStatus) */ {
 public:
  inline EstopEndpointWithStatus() : EstopEndpointWithStatus(nullptr) {}
  ~EstopEndpointWithStatus() override;
  explicit PROTOBUF_CONSTEXPR EstopEndpointWithStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EstopEndpointWithStatus(const EstopEndpointWithStatus& from);
  EstopEndpointWithStatus(EstopEndpointWithStatus&& from) noexcept
    : EstopEndpointWithStatus() {
    *this = ::std::move(from);
  }

  inline EstopEndpointWithStatus& operator=(const EstopEndpointWithStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline EstopEndpointWithStatus& operator=(EstopEndpointWithStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EstopEndpointWithStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const EstopEndpointWithStatus* internal_default_instance() {
    return reinterpret_cast<const EstopEndpointWithStatus*>(
               &_EstopEndpointWithStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EstopEndpointWithStatus& a, EstopEndpointWithStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(EstopEndpointWithStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EstopEndpointWithStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EstopEndpointWithStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EstopEndpointWithStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EstopEndpointWithStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EstopEndpointWithStatus& from) {
    EstopEndpointWithStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EstopEndpointWithStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EstopEndpointWithStatus";
  }
  protected:
  explicit EstopEndpointWithStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointFieldNumber = 1,
    kTimeSinceValidResponseFieldNumber = 3,
    kStopLevelFieldNumber = 2,
  };
  // .bosdyn.api.EstopEndpoint endpoint = 1;
  bool has_endpoint() const;
  private:
  bool _internal_has_endpoint() const;
  public:
  void clear_endpoint();
  const ::bosdyn::api::EstopEndpoint& endpoint() const;
  PROTOBUF_NODISCARD ::bosdyn::api::EstopEndpoint* release_endpoint();
  ::bosdyn::api::EstopEndpoint* mutable_endpoint();
  void set_allocated_endpoint(::bosdyn::api::EstopEndpoint* endpoint);
  private:
  const ::bosdyn::api::EstopEndpoint& _internal_endpoint() const;
  ::bosdyn::api::EstopEndpoint* _internal_mutable_endpoint();
  public:
  void unsafe_arena_set_allocated_endpoint(
      ::bosdyn::api::EstopEndpoint* endpoint);
  ::bosdyn::api::EstopEndpoint* unsafe_arena_release_endpoint();

  // .google.protobuf.Duration time_since_valid_response = 3;
  bool has_time_since_valid_response() const;
  private:
  bool _internal_has_time_since_valid_response() const;
  public:
  void clear_time_since_valid_response();
  const ::PROTOBUF_NAMESPACE_ID::Duration& time_since_valid_response() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_time_since_valid_response();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_time_since_valid_response();
  void set_allocated_time_since_valid_response(::PROTOBUF_NAMESPACE_ID::Duration* time_since_valid_response);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_time_since_valid_response() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_time_since_valid_response();
  public:
  void unsafe_arena_set_allocated_time_since_valid_response(
      ::PROTOBUF_NAMESPACE_ID::Duration* time_since_valid_response);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_time_since_valid_response();

  // .bosdyn.api.EstopStopLevel stop_level = 2;
  void clear_stop_level();
  ::bosdyn::api::EstopStopLevel stop_level() const;
  void set_stop_level(::bosdyn::api::EstopStopLevel value);
  private:
  ::bosdyn::api::EstopStopLevel _internal_stop_level() const;
  void _internal_set_stop_level(::bosdyn::api::EstopStopLevel value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.EstopEndpointWithStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::EstopEndpoint* endpoint_;
    ::PROTOBUF_NAMESPACE_ID::Duration* time_since_valid_response_;
    int stop_level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class EstopSystemStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EstopSystemStatus) */ {
 public:
  inline EstopSystemStatus() : EstopSystemStatus(nullptr) {}
  ~EstopSystemStatus() override;
  explicit PROTOBUF_CONSTEXPR EstopSystemStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EstopSystemStatus(const EstopSystemStatus& from);
  EstopSystemStatus(EstopSystemStatus&& from) noexcept
    : EstopSystemStatus() {
    *this = ::std::move(from);
  }

  inline EstopSystemStatus& operator=(const EstopSystemStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline EstopSystemStatus& operator=(EstopSystemStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EstopSystemStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const EstopSystemStatus* internal_default_instance() {
    return reinterpret_cast<const EstopSystemStatus*>(
               &_EstopSystemStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EstopSystemStatus& a, EstopSystemStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(EstopSystemStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EstopSystemStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EstopSystemStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EstopSystemStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EstopSystemStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EstopSystemStatus& from) {
    EstopSystemStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EstopSystemStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EstopSystemStatus";
  }
  protected:
  explicit EstopSystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointsFieldNumber = 3,
    kStopLevelDetailsFieldNumber = 5,
    kStopLevelFieldNumber = 4,
  };
  // repeated .bosdyn.api.EstopEndpointWithStatus endpoints = 3;
  int endpoints_size() const;
  private:
  int _internal_endpoints_size() const;
  public:
  void clear_endpoints();
  ::bosdyn::api::EstopEndpointWithStatus* mutable_endpoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpointWithStatus >*
      mutable_endpoints();
  private:
  const ::bosdyn::api::EstopEndpointWithStatus& _internal_endpoints(int index) const;
  ::bosdyn::api::EstopEndpointWithStatus* _internal_add_endpoints();
  public:
  const ::bosdyn::api::EstopEndpointWithStatus& endpoints(int index) const;
  ::bosdyn::api::EstopEndpointWithStatus* add_endpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpointWithStatus >&
      endpoints() const;

  // string stop_level_details = 5;
  void clear_stop_level_details();
  const std::string& stop_level_details() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_level_details(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_level_details();
  PROTOBUF_NODISCARD std::string* release_stop_level_details();
  void set_allocated_stop_level_details(std::string* stop_level_details);
  private:
  const std::string& _internal_stop_level_details() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_level_details(const std::string& value);
  std::string* _internal_mutable_stop_level_details();
  public:

  // .bosdyn.api.EstopStopLevel stop_level = 4;
  void clear_stop_level();
  ::bosdyn::api::EstopStopLevel stop_level() const;
  void set_stop_level(::bosdyn::api::EstopStopLevel value);
  private:
  ::bosdyn::api::EstopStopLevel _internal_stop_level() const;
  void _internal_set_stop_level(::bosdyn::api::EstopStopLevel value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.EstopSystemStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpointWithStatus > endpoints_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_level_details_;
    int stop_level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class EstopCheckInRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EstopCheckInRequest) */ {
 public:
  inline EstopCheckInRequest() : EstopCheckInRequest(nullptr) {}
  ~EstopCheckInRequest() override;
  explicit PROTOBUF_CONSTEXPR EstopCheckInRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EstopCheckInRequest(const EstopCheckInRequest& from);
  EstopCheckInRequest(EstopCheckInRequest&& from) noexcept
    : EstopCheckInRequest() {
    *this = ::std::move(from);
  }

  inline EstopCheckInRequest& operator=(const EstopCheckInRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EstopCheckInRequest& operator=(EstopCheckInRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EstopCheckInRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EstopCheckInRequest* internal_default_instance() {
    return reinterpret_cast<const EstopCheckInRequest*>(
               &_EstopCheckInRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EstopCheckInRequest& a, EstopCheckInRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EstopCheckInRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EstopCheckInRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EstopCheckInRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EstopCheckInRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EstopCheckInRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EstopCheckInRequest& from) {
    EstopCheckInRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EstopCheckInRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EstopCheckInRequest";
  }
  protected:
  explicit EstopCheckInRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kEndpointFieldNumber = 2,
    kChallengeFieldNumber = 3,
    kResponseFieldNumber = 4,
    kStopLevelFieldNumber = 5,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.EstopEndpoint endpoint = 2;
  bool has_endpoint() const;
  private:
  bool _internal_has_endpoint() const;
  public:
  void clear_endpoint();
  const ::bosdyn::api::EstopEndpoint& endpoint() const;
  PROTOBUF_NODISCARD ::bosdyn::api::EstopEndpoint* release_endpoint();
  ::bosdyn::api::EstopEndpoint* mutable_endpoint();
  void set_allocated_endpoint(::bosdyn::api::EstopEndpoint* endpoint);
  private:
  const ::bosdyn::api::EstopEndpoint& _internal_endpoint() const;
  ::bosdyn::api::EstopEndpoint* _internal_mutable_endpoint();
  public:
  void unsafe_arena_set_allocated_endpoint(
      ::bosdyn::api::EstopEndpoint* endpoint);
  ::bosdyn::api::EstopEndpoint* unsafe_arena_release_endpoint();

  // uint64 challenge = 3;
  void clear_challenge();
  uint64_t challenge() const;
  void set_challenge(uint64_t value);
  private:
  uint64_t _internal_challenge() const;
  void _internal_set_challenge(uint64_t value);
  public:

  // uint64 response = 4;
  void clear_response();
  uint64_t response() const;
  void set_response(uint64_t value);
  private:
  uint64_t _internal_response() const;
  void _internal_set_response(uint64_t value);
  public:

  // .bosdyn.api.EstopStopLevel stop_level = 5;
  void clear_stop_level();
  ::bosdyn::api::EstopStopLevel stop_level() const;
  void set_stop_level(::bosdyn::api::EstopStopLevel value);
  private:
  ::bosdyn::api::EstopStopLevel _internal_stop_level() const;
  void _internal_set_stop_level(::bosdyn::api::EstopStopLevel value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.EstopCheckInRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::EstopEndpoint* endpoint_;
    uint64_t challenge_;
    uint64_t response_;
    int stop_level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class EstopCheckInResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EstopCheckInResponse) */ {
 public:
  inline EstopCheckInResponse() : EstopCheckInResponse(nullptr) {}
  ~EstopCheckInResponse() override;
  explicit PROTOBUF_CONSTEXPR EstopCheckInResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EstopCheckInResponse(const EstopCheckInResponse& from);
  EstopCheckInResponse(EstopCheckInResponse&& from) noexcept
    : EstopCheckInResponse() {
    *this = ::std::move(from);
  }

  inline EstopCheckInResponse& operator=(const EstopCheckInResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EstopCheckInResponse& operator=(EstopCheckInResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EstopCheckInResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EstopCheckInResponse* internal_default_instance() {
    return reinterpret_cast<const EstopCheckInResponse*>(
               &_EstopCheckInResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EstopCheckInResponse& a, EstopCheckInResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EstopCheckInResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EstopCheckInResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EstopCheckInResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EstopCheckInResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EstopCheckInResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EstopCheckInResponse& from) {
    EstopCheckInResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EstopCheckInResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EstopCheckInResponse";
  }
  protected:
  explicit EstopCheckInResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EstopCheckInResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    EstopCheckInResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    EstopCheckInResponse_Status_STATUS_OK;
  static constexpr Status STATUS_ENDPOINT_UNKNOWN =
    EstopCheckInResponse_Status_STATUS_ENDPOINT_UNKNOWN;
  static constexpr Status STATUS_INCORRECT_CHALLENGE_RESPONSE =
    EstopCheckInResponse_Status_STATUS_INCORRECT_CHALLENGE_RESPONSE;
  static inline bool Status_IsValid(int value) {
    return EstopCheckInResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    EstopCheckInResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    EstopCheckInResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    EstopCheckInResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return EstopCheckInResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return EstopCheckInResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return EstopCheckInResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRequestFieldNumber = 2,
    kChallengeFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.EstopCheckInRequest request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::bosdyn::api::EstopCheckInRequest& request() const;
  PROTOBUF_NODISCARD ::bosdyn::api::EstopCheckInRequest* release_request();
  ::bosdyn::api::EstopCheckInRequest* mutable_request();
  void set_allocated_request(::bosdyn::api::EstopCheckInRequest* request);
  private:
  const ::bosdyn::api::EstopCheckInRequest& _internal_request() const;
  ::bosdyn::api::EstopCheckInRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::bosdyn::api::EstopCheckInRequest* request);
  ::bosdyn::api::EstopCheckInRequest* unsafe_arena_release_request();

  // uint64 challenge = 3;
  void clear_challenge();
  uint64_t challenge() const;
  void set_challenge(uint64_t value);
  private:
  uint64_t _internal_challenge() const;
  void _internal_set_challenge(uint64_t value);
  public:

  // .bosdyn.api.EstopCheckInResponse.Status status = 4;
  void clear_status();
  ::bosdyn::api::EstopCheckInResponse_Status status() const;
  void set_status(::bosdyn::api::EstopCheckInResponse_Status value);
  private:
  ::bosdyn::api::EstopCheckInResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::EstopCheckInResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.EstopCheckInResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::EstopCheckInRequest* request_;
    uint64_t challenge_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class RegisterEstopEndpointRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RegisterEstopEndpointRequest) */ {
 public:
  inline RegisterEstopEndpointRequest() : RegisterEstopEndpointRequest(nullptr) {}
  ~RegisterEstopEndpointRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterEstopEndpointRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterEstopEndpointRequest(const RegisterEstopEndpointRequest& from);
  RegisterEstopEndpointRequest(RegisterEstopEndpointRequest&& from) noexcept
    : RegisterEstopEndpointRequest() {
    *this = ::std::move(from);
  }

  inline RegisterEstopEndpointRequest& operator=(const RegisterEstopEndpointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterEstopEndpointRequest& operator=(RegisterEstopEndpointRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterEstopEndpointRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterEstopEndpointRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterEstopEndpointRequest*>(
               &_RegisterEstopEndpointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RegisterEstopEndpointRequest& a, RegisterEstopEndpointRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterEstopEndpointRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterEstopEndpointRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterEstopEndpointRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterEstopEndpointRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterEstopEndpointRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterEstopEndpointRequest& from) {
    RegisterEstopEndpointRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterEstopEndpointRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RegisterEstopEndpointRequest";
  }
  protected:
  explicit RegisterEstopEndpointRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetConfigIdFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kTargetEndpointFieldNumber = 2,
    kNewEndpointFieldNumber = 4,
  };
  // string target_config_id = 3;
  void clear_target_config_id();
  const std::string& target_config_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_config_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_config_id();
  PROTOBUF_NODISCARD std::string* release_target_config_id();
  void set_allocated_target_config_id(std::string* target_config_id);
  private:
  const std::string& _internal_target_config_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_config_id(const std::string& value);
  std::string* _internal_mutable_target_config_id();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.EstopEndpoint target_endpoint = 2;
  bool has_target_endpoint() const;
  private:
  bool _internal_has_target_endpoint() const;
  public:
  void clear_target_endpoint();
  const ::bosdyn::api::EstopEndpoint& target_endpoint() const;
  PROTOBUF_NODISCARD ::bosdyn::api::EstopEndpoint* release_target_endpoint();
  ::bosdyn::api::EstopEndpoint* mutable_target_endpoint();
  void set_allocated_target_endpoint(::bosdyn::api::EstopEndpoint* target_endpoint);
  private:
  const ::bosdyn::api::EstopEndpoint& _internal_target_endpoint() const;
  ::bosdyn::api::EstopEndpoint* _internal_mutable_target_endpoint();
  public:
  void unsafe_arena_set_allocated_target_endpoint(
      ::bosdyn::api::EstopEndpoint* target_endpoint);
  ::bosdyn::api::EstopEndpoint* unsafe_arena_release_target_endpoint();

  // .bosdyn.api.EstopEndpoint new_endpoint = 4;
  bool has_new_endpoint() const;
  private:
  bool _internal_has_new_endpoint() const;
  public:
  void clear_new_endpoint();
  const ::bosdyn::api::EstopEndpoint& new_endpoint() const;
  PROTOBUF_NODISCARD ::bosdyn::api::EstopEndpoint* release_new_endpoint();
  ::bosdyn::api::EstopEndpoint* mutable_new_endpoint();
  void set_allocated_new_endpoint(::bosdyn::api::EstopEndpoint* new_endpoint);
  private:
  const ::bosdyn::api::EstopEndpoint& _internal_new_endpoint() const;
  ::bosdyn::api::EstopEndpoint* _internal_mutable_new_endpoint();
  public:
  void unsafe_arena_set_allocated_new_endpoint(
      ::bosdyn::api::EstopEndpoint* new_endpoint);
  ::bosdyn::api::EstopEndpoint* unsafe_arena_release_new_endpoint();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RegisterEstopEndpointRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_config_id_;
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::EstopEndpoint* target_endpoint_;
    ::bosdyn::api::EstopEndpoint* new_endpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class RegisterEstopEndpointResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RegisterEstopEndpointResponse) */ {
 public:
  inline RegisterEstopEndpointResponse() : RegisterEstopEndpointResponse(nullptr) {}
  ~RegisterEstopEndpointResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterEstopEndpointResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterEstopEndpointResponse(const RegisterEstopEndpointResponse& from);
  RegisterEstopEndpointResponse(RegisterEstopEndpointResponse&& from) noexcept
    : RegisterEstopEndpointResponse() {
    *this = ::std::move(from);
  }

  inline RegisterEstopEndpointResponse& operator=(const RegisterEstopEndpointResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterEstopEndpointResponse& operator=(RegisterEstopEndpointResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterEstopEndpointResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterEstopEndpointResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterEstopEndpointResponse*>(
               &_RegisterEstopEndpointResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RegisterEstopEndpointResponse& a, RegisterEstopEndpointResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterEstopEndpointResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterEstopEndpointResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterEstopEndpointResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterEstopEndpointResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterEstopEndpointResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterEstopEndpointResponse& from) {
    RegisterEstopEndpointResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterEstopEndpointResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RegisterEstopEndpointResponse";
  }
  protected:
  explicit RegisterEstopEndpointResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RegisterEstopEndpointResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    RegisterEstopEndpointResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_SUCCESS =
    RegisterEstopEndpointResponse_Status_STATUS_SUCCESS;
  static constexpr Status STATUS_ENDPOINT_MISMATCH =
    RegisterEstopEndpointResponse_Status_STATUS_ENDPOINT_MISMATCH;
  static constexpr Status STATUS_CONFIG_MISMATCH =
    RegisterEstopEndpointResponse_Status_STATUS_CONFIG_MISMATCH;
  static constexpr Status STATUS_INVALID_ENDPOINT =
    RegisterEstopEndpointResponse_Status_STATUS_INVALID_ENDPOINT;
  static inline bool Status_IsValid(int value) {
    return RegisterEstopEndpointResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    RegisterEstopEndpointResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    RegisterEstopEndpointResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    RegisterEstopEndpointResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return RegisterEstopEndpointResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return RegisterEstopEndpointResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return RegisterEstopEndpointResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRequestFieldNumber = 2,
    kNewEndpointFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.RegisterEstopEndpointRequest request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::bosdyn::api::RegisterEstopEndpointRequest& request() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RegisterEstopEndpointRequest* release_request();
  ::bosdyn::api::RegisterEstopEndpointRequest* mutable_request();
  void set_allocated_request(::bosdyn::api::RegisterEstopEndpointRequest* request);
  private:
  const ::bosdyn::api::RegisterEstopEndpointRequest& _internal_request() const;
  ::bosdyn::api::RegisterEstopEndpointRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::bosdyn::api::RegisterEstopEndpointRequest* request);
  ::bosdyn::api::RegisterEstopEndpointRequest* unsafe_arena_release_request();

  // .bosdyn.api.EstopEndpoint new_endpoint = 3;
  bool has_new_endpoint() const;
  private:
  bool _internal_has_new_endpoint() const;
  public:
  void clear_new_endpoint();
  const ::bosdyn::api::EstopEndpoint& new_endpoint() const;
  PROTOBUF_NODISCARD ::bosdyn::api::EstopEndpoint* release_new_endpoint();
  ::bosdyn::api::EstopEndpoint* mutable_new_endpoint();
  void set_allocated_new_endpoint(::bosdyn::api::EstopEndpoint* new_endpoint);
  private:
  const ::bosdyn::api::EstopEndpoint& _internal_new_endpoint() const;
  ::bosdyn::api::EstopEndpoint* _internal_mutable_new_endpoint();
  public:
  void unsafe_arena_set_allocated_new_endpoint(
      ::bosdyn::api::EstopEndpoint* new_endpoint);
  ::bosdyn::api::EstopEndpoint* unsafe_arena_release_new_endpoint();

  // .bosdyn.api.RegisterEstopEndpointResponse.Status status = 4;
  void clear_status();
  ::bosdyn::api::RegisterEstopEndpointResponse_Status status() const;
  void set_status(::bosdyn::api::RegisterEstopEndpointResponse_Status value);
  private:
  ::bosdyn::api::RegisterEstopEndpointResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::RegisterEstopEndpointResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.RegisterEstopEndpointResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::RegisterEstopEndpointRequest* request_;
    ::bosdyn::api::EstopEndpoint* new_endpoint_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class DeregisterEstopEndpointRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DeregisterEstopEndpointRequest) */ {
 public:
  inline DeregisterEstopEndpointRequest() : DeregisterEstopEndpointRequest(nullptr) {}
  ~DeregisterEstopEndpointRequest() override;
  explicit PROTOBUF_CONSTEXPR DeregisterEstopEndpointRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeregisterEstopEndpointRequest(const DeregisterEstopEndpointRequest& from);
  DeregisterEstopEndpointRequest(DeregisterEstopEndpointRequest&& from) noexcept
    : DeregisterEstopEndpointRequest() {
    *this = ::std::move(from);
  }

  inline DeregisterEstopEndpointRequest& operator=(const DeregisterEstopEndpointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeregisterEstopEndpointRequest& operator=(DeregisterEstopEndpointRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeregisterEstopEndpointRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeregisterEstopEndpointRequest* internal_default_instance() {
    return reinterpret_cast<const DeregisterEstopEndpointRequest*>(
               &_DeregisterEstopEndpointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeregisterEstopEndpointRequest& a, DeregisterEstopEndpointRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeregisterEstopEndpointRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeregisterEstopEndpointRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeregisterEstopEndpointRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeregisterEstopEndpointRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeregisterEstopEndpointRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeregisterEstopEndpointRequest& from) {
    DeregisterEstopEndpointRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeregisterEstopEndpointRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DeregisterEstopEndpointRequest";
  }
  protected:
  explicit DeregisterEstopEndpointRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetConfigIdFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kTargetEndpointFieldNumber = 2,
  };
  // string target_config_id = 3;
  void clear_target_config_id();
  const std::string& target_config_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_config_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_config_id();
  PROTOBUF_NODISCARD std::string* release_target_config_id();
  void set_allocated_target_config_id(std::string* target_config_id);
  private:
  const std::string& _internal_target_config_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_config_id(const std::string& value);
  std::string* _internal_mutable_target_config_id();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.EstopEndpoint target_endpoint = 2;
  bool has_target_endpoint() const;
  private:
  bool _internal_has_target_endpoint() const;
  public:
  void clear_target_endpoint();
  const ::bosdyn::api::EstopEndpoint& target_endpoint() const;
  PROTOBUF_NODISCARD ::bosdyn::api::EstopEndpoint* release_target_endpoint();
  ::bosdyn::api::EstopEndpoint* mutable_target_endpoint();
  void set_allocated_target_endpoint(::bosdyn::api::EstopEndpoint* target_endpoint);
  private:
  const ::bosdyn::api::EstopEndpoint& _internal_target_endpoint() const;
  ::bosdyn::api::EstopEndpoint* _internal_mutable_target_endpoint();
  public:
  void unsafe_arena_set_allocated_target_endpoint(
      ::bosdyn::api::EstopEndpoint* target_endpoint);
  ::bosdyn::api::EstopEndpoint* unsafe_arena_release_target_endpoint();

  // @@protoc_insertion_point(class_scope:bosdyn.api.DeregisterEstopEndpointRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_config_id_;
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::EstopEndpoint* target_endpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class DeregisterEstopEndpointResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DeregisterEstopEndpointResponse) */ {
 public:
  inline DeregisterEstopEndpointResponse() : DeregisterEstopEndpointResponse(nullptr) {}
  ~DeregisterEstopEndpointResponse() override;
  explicit PROTOBUF_CONSTEXPR DeregisterEstopEndpointResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeregisterEstopEndpointResponse(const DeregisterEstopEndpointResponse& from);
  DeregisterEstopEndpointResponse(DeregisterEstopEndpointResponse&& from) noexcept
    : DeregisterEstopEndpointResponse() {
    *this = ::std::move(from);
  }

  inline DeregisterEstopEndpointResponse& operator=(const DeregisterEstopEndpointResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeregisterEstopEndpointResponse& operator=(DeregisterEstopEndpointResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeregisterEstopEndpointResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeregisterEstopEndpointResponse* internal_default_instance() {
    return reinterpret_cast<const DeregisterEstopEndpointResponse*>(
               &_DeregisterEstopEndpointResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DeregisterEstopEndpointResponse& a, DeregisterEstopEndpointResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeregisterEstopEndpointResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeregisterEstopEndpointResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeregisterEstopEndpointResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeregisterEstopEndpointResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeregisterEstopEndpointResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeregisterEstopEndpointResponse& from) {
    DeregisterEstopEndpointResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeregisterEstopEndpointResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DeregisterEstopEndpointResponse";
  }
  protected:
  explicit DeregisterEstopEndpointResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DeregisterEstopEndpointResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    DeregisterEstopEndpointResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_SUCCESS =
    DeregisterEstopEndpointResponse_Status_STATUS_SUCCESS;
  static constexpr Status STATUS_ENDPOINT_MISMATCH =
    DeregisterEstopEndpointResponse_Status_STATUS_ENDPOINT_MISMATCH;
  static constexpr Status STATUS_CONFIG_MISMATCH =
    DeregisterEstopEndpointResponse_Status_STATUS_CONFIG_MISMATCH;
  static constexpr Status STATUS_MOTORS_ON =
    DeregisterEstopEndpointResponse_Status_STATUS_MOTORS_ON;
  static inline bool Status_IsValid(int value) {
    return DeregisterEstopEndpointResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    DeregisterEstopEndpointResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    DeregisterEstopEndpointResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    DeregisterEstopEndpointResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return DeregisterEstopEndpointResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return DeregisterEstopEndpointResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return DeregisterEstopEndpointResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRequestFieldNumber = 2,
    kStatusFieldNumber = 4,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.DeregisterEstopEndpointRequest request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::bosdyn::api::DeregisterEstopEndpointRequest& request() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DeregisterEstopEndpointRequest* release_request();
  ::bosdyn::api::DeregisterEstopEndpointRequest* mutable_request();
  void set_allocated_request(::bosdyn::api::DeregisterEstopEndpointRequest* request);
  private:
  const ::bosdyn::api::DeregisterEstopEndpointRequest& _internal_request() const;
  ::bosdyn::api::DeregisterEstopEndpointRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::bosdyn::api::DeregisterEstopEndpointRequest* request);
  ::bosdyn::api::DeregisterEstopEndpointRequest* unsafe_arena_release_request();

  // .bosdyn.api.DeregisterEstopEndpointResponse.Status status = 4;
  void clear_status();
  ::bosdyn::api::DeregisterEstopEndpointResponse_Status status() const;
  void set_status(::bosdyn::api::DeregisterEstopEndpointResponse_Status value);
  private:
  ::bosdyn::api::DeregisterEstopEndpointResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::DeregisterEstopEndpointResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.DeregisterEstopEndpointResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::DeregisterEstopEndpointRequest* request_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class GetEstopConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetEstopConfigRequest) */ {
 public:
  inline GetEstopConfigRequest() : GetEstopConfigRequest(nullptr) {}
  ~GetEstopConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR GetEstopConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEstopConfigRequest(const GetEstopConfigRequest& from);
  GetEstopConfigRequest(GetEstopConfigRequest&& from) noexcept
    : GetEstopConfigRequest() {
    *this = ::std::move(from);
  }

  inline GetEstopConfigRequest& operator=(const GetEstopConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEstopConfigRequest& operator=(GetEstopConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEstopConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEstopConfigRequest* internal_default_instance() {
    return reinterpret_cast<const GetEstopConfigRequest*>(
               &_GetEstopConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetEstopConfigRequest& a, GetEstopConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEstopConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEstopConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEstopConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEstopConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEstopConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetEstopConfigRequest& from) {
    GetEstopConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEstopConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetEstopConfigRequest";
  }
  protected:
  explicit GetEstopConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetConfigIdFieldNumber = 4,
    kHeaderFieldNumber = 1,
  };
  // string target_config_id = 4;
  void clear_target_config_id();
  const std::string& target_config_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_config_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_config_id();
  PROTOBUF_NODISCARD std::string* release_target_config_id();
  void set_allocated_target_config_id(std::string* target_config_id);
  private:
  const std::string& _internal_target_config_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_config_id(const std::string& value);
  std::string* _internal_mutable_target_config_id();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetEstopConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_config_id_;
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class GetEstopConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetEstopConfigResponse) */ {
 public:
  inline GetEstopConfigResponse() : GetEstopConfigResponse(nullptr) {}
  ~GetEstopConfigResponse() override;
  explicit PROTOBUF_CONSTEXPR GetEstopConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEstopConfigResponse(const GetEstopConfigResponse& from);
  GetEstopConfigResponse(GetEstopConfigResponse&& from) noexcept
    : GetEstopConfigResponse() {
    *this = ::std::move(from);
  }

  inline GetEstopConfigResponse& operator=(const GetEstopConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEstopConfigResponse& operator=(GetEstopConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEstopConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEstopConfigResponse* internal_default_instance() {
    return reinterpret_cast<const GetEstopConfigResponse*>(
               &_GetEstopConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetEstopConfigResponse& a, GetEstopConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEstopConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEstopConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEstopConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEstopConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEstopConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetEstopConfigResponse& from) {
    GetEstopConfigResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEstopConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetEstopConfigResponse";
  }
  protected:
  explicit GetEstopConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRequestFieldNumber = 2,
    kActiveConfigFieldNumber = 3,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.GetEstopConfigRequest request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::bosdyn::api::GetEstopConfigRequest& request() const;
  PROTOBUF_NODISCARD ::bosdyn::api::GetEstopConfigRequest* release_request();
  ::bosdyn::api::GetEstopConfigRequest* mutable_request();
  void set_allocated_request(::bosdyn::api::GetEstopConfigRequest* request);
  private:
  const ::bosdyn::api::GetEstopConfigRequest& _internal_request() const;
  ::bosdyn::api::GetEstopConfigRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::bosdyn::api::GetEstopConfigRequest* request);
  ::bosdyn::api::GetEstopConfigRequest* unsafe_arena_release_request();

  // .bosdyn.api.EstopConfig active_config = 3;
  bool has_active_config() const;
  private:
  bool _internal_has_active_config() const;
  public:
  void clear_active_config();
  const ::bosdyn::api::EstopConfig& active_config() const;
  PROTOBUF_NODISCARD ::bosdyn::api::EstopConfig* release_active_config();
  ::bosdyn::api::EstopConfig* mutable_active_config();
  void set_allocated_active_config(::bosdyn::api::EstopConfig* active_config);
  private:
  const ::bosdyn::api::EstopConfig& _internal_active_config() const;
  ::bosdyn::api::EstopConfig* _internal_mutable_active_config();
  public:
  void unsafe_arena_set_allocated_active_config(
      ::bosdyn::api::EstopConfig* active_config);
  ::bosdyn::api::EstopConfig* unsafe_arena_release_active_config();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetEstopConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::GetEstopConfigRequest* request_;
    ::bosdyn::api::EstopConfig* active_config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class SetEstopConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SetEstopConfigRequest) */ {
 public:
  inline SetEstopConfigRequest() : SetEstopConfigRequest(nullptr) {}
  ~SetEstopConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR SetEstopConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetEstopConfigRequest(const SetEstopConfigRequest& from);
  SetEstopConfigRequest(SetEstopConfigRequest&& from) noexcept
    : SetEstopConfigRequest() {
    *this = ::std::move(from);
  }

  inline SetEstopConfigRequest& operator=(const SetEstopConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetEstopConfigRequest& operator=(SetEstopConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetEstopConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetEstopConfigRequest* internal_default_instance() {
    return reinterpret_cast<const SetEstopConfigRequest*>(
               &_SetEstopConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SetEstopConfigRequest& a, SetEstopConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetEstopConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetEstopConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetEstopConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetEstopConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetEstopConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetEstopConfigRequest& from) {
    SetEstopConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetEstopConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SetEstopConfigRequest";
  }
  protected:
  explicit SetEstopConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetConfigIdFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kConfigFieldNumber = 3,
  };
  // string target_config_id = 4;
  void clear_target_config_id();
  const std::string& target_config_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_config_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_config_id();
  PROTOBUF_NODISCARD std::string* release_target_config_id();
  void set_allocated_target_config_id(std::string* target_config_id);
  private:
  const std::string& _internal_target_config_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_config_id(const std::string& value);
  std::string* _internal_mutable_target_config_id();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.EstopConfig config = 3;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::bosdyn::api::EstopConfig& config() const;
  PROTOBUF_NODISCARD ::bosdyn::api::EstopConfig* release_config();
  ::bosdyn::api::EstopConfig* mutable_config();
  void set_allocated_config(::bosdyn::api::EstopConfig* config);
  private:
  const ::bosdyn::api::EstopConfig& _internal_config() const;
  ::bosdyn::api::EstopConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::bosdyn::api::EstopConfig* config);
  ::bosdyn::api::EstopConfig* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:bosdyn.api.SetEstopConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_config_id_;
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::EstopConfig* config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class SetEstopConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SetEstopConfigResponse) */ {
 public:
  inline SetEstopConfigResponse() : SetEstopConfigResponse(nullptr) {}
  ~SetEstopConfigResponse() override;
  explicit PROTOBUF_CONSTEXPR SetEstopConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetEstopConfigResponse(const SetEstopConfigResponse& from);
  SetEstopConfigResponse(SetEstopConfigResponse&& from) noexcept
    : SetEstopConfigResponse() {
    *this = ::std::move(from);
  }

  inline SetEstopConfigResponse& operator=(const SetEstopConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetEstopConfigResponse& operator=(SetEstopConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetEstopConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetEstopConfigResponse* internal_default_instance() {
    return reinterpret_cast<const SetEstopConfigResponse*>(
               &_SetEstopConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SetEstopConfigResponse& a, SetEstopConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetEstopConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetEstopConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetEstopConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetEstopConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetEstopConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetEstopConfigResponse& from) {
    SetEstopConfigResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetEstopConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SetEstopConfigResponse";
  }
  protected:
  explicit SetEstopConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SetEstopConfigResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    SetEstopConfigResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_SUCCESS =
    SetEstopConfigResponse_Status_STATUS_SUCCESS;
  static constexpr Status STATUS_INVALID_ID =
    SetEstopConfigResponse_Status_STATUS_INVALID_ID;
  static constexpr Status STATUS_MOTORS_ON =
    SetEstopConfigResponse_Status_STATUS_MOTORS_ON;
  static inline bool Status_IsValid(int value) {
    return SetEstopConfigResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    SetEstopConfigResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    SetEstopConfigResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    SetEstopConfigResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return SetEstopConfigResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return SetEstopConfigResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return SetEstopConfigResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRequestFieldNumber = 2,
    kActiveConfigFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.SetEstopConfigRequest request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::bosdyn::api::SetEstopConfigRequest& request() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SetEstopConfigRequest* release_request();
  ::bosdyn::api::SetEstopConfigRequest* mutable_request();
  void set_allocated_request(::bosdyn::api::SetEstopConfigRequest* request);
  private:
  const ::bosdyn::api::SetEstopConfigRequest& _internal_request() const;
  ::bosdyn::api::SetEstopConfigRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::bosdyn::api::SetEstopConfigRequest* request);
  ::bosdyn::api::SetEstopConfigRequest* unsafe_arena_release_request();

  // .bosdyn.api.EstopConfig active_config = 3;
  bool has_active_config() const;
  private:
  bool _internal_has_active_config() const;
  public:
  void clear_active_config();
  const ::bosdyn::api::EstopConfig& active_config() const;
  PROTOBUF_NODISCARD ::bosdyn::api::EstopConfig* release_active_config();
  ::bosdyn::api::EstopConfig* mutable_active_config();
  void set_allocated_active_config(::bosdyn::api::EstopConfig* active_config);
  private:
  const ::bosdyn::api::EstopConfig& _internal_active_config() const;
  ::bosdyn::api::EstopConfig* _internal_mutable_active_config();
  public:
  void unsafe_arena_set_allocated_active_config(
      ::bosdyn::api::EstopConfig* active_config);
  ::bosdyn::api::EstopConfig* unsafe_arena_release_active_config();

  // .bosdyn.api.SetEstopConfigResponse.Status status = 4;
  void clear_status();
  ::bosdyn::api::SetEstopConfigResponse_Status status() const;
  void set_status(::bosdyn::api::SetEstopConfigResponse_Status value);
  private:
  ::bosdyn::api::SetEstopConfigResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::SetEstopConfigResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SetEstopConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::SetEstopConfigRequest* request_;
    ::bosdyn::api::EstopConfig* active_config_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class GetEstopSystemStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetEstopSystemStatusRequest) */ {
 public:
  inline GetEstopSystemStatusRequest() : GetEstopSystemStatusRequest(nullptr) {}
  ~GetEstopSystemStatusRequest() override;
  explicit PROTOBUF_CONSTEXPR GetEstopSystemStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEstopSystemStatusRequest(const GetEstopSystemStatusRequest& from);
  GetEstopSystemStatusRequest(GetEstopSystemStatusRequest&& from) noexcept
    : GetEstopSystemStatusRequest() {
    *this = ::std::move(from);
  }

  inline GetEstopSystemStatusRequest& operator=(const GetEstopSystemStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEstopSystemStatusRequest& operator=(GetEstopSystemStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEstopSystemStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEstopSystemStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GetEstopSystemStatusRequest*>(
               &_GetEstopSystemStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetEstopSystemStatusRequest& a, GetEstopSystemStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEstopSystemStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEstopSystemStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEstopSystemStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEstopSystemStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEstopSystemStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetEstopSystemStatusRequest& from) {
    GetEstopSystemStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEstopSystemStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetEstopSystemStatusRequest";
  }
  protected:
  explicit GetEstopSystemStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetEstopSystemStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class GetEstopSystemStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetEstopSystemStatusResponse) */ {
 public:
  inline GetEstopSystemStatusResponse() : GetEstopSystemStatusResponse(nullptr) {}
  ~GetEstopSystemStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR GetEstopSystemStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEstopSystemStatusResponse(const GetEstopSystemStatusResponse& from);
  GetEstopSystemStatusResponse(GetEstopSystemStatusResponse&& from) noexcept
    : GetEstopSystemStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetEstopSystemStatusResponse& operator=(const GetEstopSystemStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEstopSystemStatusResponse& operator=(GetEstopSystemStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEstopSystemStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEstopSystemStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetEstopSystemStatusResponse*>(
               &_GetEstopSystemStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetEstopSystemStatusResponse& a, GetEstopSystemStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEstopSystemStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEstopSystemStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEstopSystemStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEstopSystemStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEstopSystemStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetEstopSystemStatusResponse& from) {
    GetEstopSystemStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEstopSystemStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetEstopSystemStatusResponse";
  }
  protected:
  explicit GetEstopSystemStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 3,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.EstopSystemStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::bosdyn::api::EstopSystemStatus& status() const;
  PROTOBUF_NODISCARD ::bosdyn::api::EstopSystemStatus* release_status();
  ::bosdyn::api::EstopSystemStatus* mutable_status();
  void set_allocated_status(::bosdyn::api::EstopSystemStatus* status);
  private:
  const ::bosdyn::api::EstopSystemStatus& _internal_status() const;
  ::bosdyn::api::EstopSystemStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::bosdyn::api::EstopSystemStatus* status);
  ::bosdyn::api::EstopSystemStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetEstopSystemStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::EstopSystemStatus* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EstopEndpoint

// string role = 1;
inline void EstopEndpoint::clear_role() {
  _impl_.role_.ClearToEmpty();
}
inline const std::string& EstopEndpoint::role() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopEndpoint.role)
  return _internal_role();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EstopEndpoint::set_role(ArgT0&& arg0, ArgT... args) {
 
 _impl_.role_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopEndpoint.role)
}
inline std::string* EstopEndpoint::mutable_role() {
  std::string* _s = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopEndpoint.role)
  return _s;
}
inline const std::string& EstopEndpoint::_internal_role() const {
  return _impl_.role_.Get();
}
inline void EstopEndpoint::_internal_set_role(const std::string& value) {
  
  _impl_.role_.Set(value, GetArenaForAllocation());
}
inline std::string* EstopEndpoint::_internal_mutable_role() {
  
  return _impl_.role_.Mutable(GetArenaForAllocation());
}
inline std::string* EstopEndpoint::release_role() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopEndpoint.role)
  return _impl_.role_.Release();
}
inline void EstopEndpoint::set_allocated_role(std::string* role) {
  if (role != nullptr) {
    
  } else {
    
  }
  _impl_.role_.SetAllocated(role, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.role_.IsDefault()) {
    _impl_.role_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopEndpoint.role)
}

// string name = 2;
inline void EstopEndpoint::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& EstopEndpoint::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopEndpoint.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EstopEndpoint::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopEndpoint.name)
}
inline std::string* EstopEndpoint::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopEndpoint.name)
  return _s;
}
inline const std::string& EstopEndpoint::_internal_name() const {
  return _impl_.name_.Get();
}
inline void EstopEndpoint::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* EstopEndpoint::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* EstopEndpoint::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopEndpoint.name)
  return _impl_.name_.Release();
}
inline void EstopEndpoint::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopEndpoint.name)
}

// string unique_id = 3;
inline void EstopEndpoint::clear_unique_id() {
  _impl_.unique_id_.ClearToEmpty();
}
inline const std::string& EstopEndpoint::unique_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopEndpoint.unique_id)
  return _internal_unique_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EstopEndpoint::set_unique_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.unique_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopEndpoint.unique_id)
}
inline std::string* EstopEndpoint::mutable_unique_id() {
  std::string* _s = _internal_mutable_unique_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopEndpoint.unique_id)
  return _s;
}
inline const std::string& EstopEndpoint::_internal_unique_id() const {
  return _impl_.unique_id_.Get();
}
inline void EstopEndpoint::_internal_set_unique_id(const std::string& value) {
  
  _impl_.unique_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EstopEndpoint::_internal_mutable_unique_id() {
  
  return _impl_.unique_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EstopEndpoint::release_unique_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopEndpoint.unique_id)
  return _impl_.unique_id_.Release();
}
inline void EstopEndpoint::set_allocated_unique_id(std::string* unique_id) {
  if (unique_id != nullptr) {
    
  } else {
    
  }
  _impl_.unique_id_.SetAllocated(unique_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unique_id_.IsDefault()) {
    _impl_.unique_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopEndpoint.unique_id)
}

// .google.protobuf.Duration timeout = 4;
inline bool EstopEndpoint::_internal_has_timeout() const {
  return this != internal_default_instance() && _impl_.timeout_ != nullptr;
}
inline bool EstopEndpoint::has_timeout() const {
  return _internal_has_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& EstopEndpoint::_internal_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& EstopEndpoint::timeout() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopEndpoint.timeout)
  return _internal_timeout();
}
inline void EstopEndpoint::unsafe_arena_set_allocated_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timeout_);
  }
  _impl_.timeout_ = timeout;
  if (timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EstopEndpoint.timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EstopEndpoint::release_timeout() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.timeout_;
  _impl_.timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EstopEndpoint::unsafe_arena_release_timeout() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopEndpoint.timeout)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.timeout_;
  _impl_.timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EstopEndpoint::_internal_mutable_timeout() {
  
  if (_impl_.timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.timeout_ = p;
  }
  return _impl_.timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EstopEndpoint::mutable_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_timeout();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopEndpoint.timeout)
  return _msg;
}
inline void EstopEndpoint::set_allocated_timeout(::PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timeout_);
  }
  if (timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout));
    if (message_arena != submessage_arena) {
      timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timeout, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timeout_ = timeout;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopEndpoint.timeout)
}

// .google.protobuf.Duration cut_power_timeout = 5;
inline bool EstopEndpoint::_internal_has_cut_power_timeout() const {
  return this != internal_default_instance() && _impl_.cut_power_timeout_ != nullptr;
}
inline bool EstopEndpoint::has_cut_power_timeout() const {
  return _internal_has_cut_power_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& EstopEndpoint::_internal_cut_power_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.cut_power_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& EstopEndpoint::cut_power_timeout() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopEndpoint.cut_power_timeout)
  return _internal_cut_power_timeout();
}
inline void EstopEndpoint::unsafe_arena_set_allocated_cut_power_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* cut_power_timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cut_power_timeout_);
  }
  _impl_.cut_power_timeout_ = cut_power_timeout;
  if (cut_power_timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EstopEndpoint.cut_power_timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EstopEndpoint::release_cut_power_timeout() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.cut_power_timeout_;
  _impl_.cut_power_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EstopEndpoint::unsafe_arena_release_cut_power_timeout() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopEndpoint.cut_power_timeout)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.cut_power_timeout_;
  _impl_.cut_power_timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EstopEndpoint::_internal_mutable_cut_power_timeout() {
  
  if (_impl_.cut_power_timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.cut_power_timeout_ = p;
  }
  return _impl_.cut_power_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EstopEndpoint::mutable_cut_power_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_cut_power_timeout();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopEndpoint.cut_power_timeout)
  return _msg;
}
inline void EstopEndpoint::set_allocated_cut_power_timeout(::PROTOBUF_NAMESPACE_ID::Duration* cut_power_timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cut_power_timeout_);
  }
  if (cut_power_timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cut_power_timeout));
    if (message_arena != submessage_arena) {
      cut_power_timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cut_power_timeout, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cut_power_timeout_ = cut_power_timeout;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopEndpoint.cut_power_timeout)
}

// -------------------------------------------------------------------

// EstopConfig

// repeated .bosdyn.api.EstopEndpoint endpoints = 1;
inline int EstopConfig::_internal_endpoints_size() const {
  return _impl_.endpoints_.size();
}
inline int EstopConfig::endpoints_size() const {
  return _internal_endpoints_size();
}
inline void EstopConfig::clear_endpoints() {
  _impl_.endpoints_.Clear();
}
inline ::bosdyn::api::EstopEndpoint* EstopConfig::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopConfig.endpoints)
  return _impl_.endpoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpoint >*
EstopConfig::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.EstopConfig.endpoints)
  return &_impl_.endpoints_;
}
inline const ::bosdyn::api::EstopEndpoint& EstopConfig::_internal_endpoints(int index) const {
  return _impl_.endpoints_.Get(index);
}
inline const ::bosdyn::api::EstopEndpoint& EstopConfig::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopConfig.endpoints)
  return _internal_endpoints(index);
}
inline ::bosdyn::api::EstopEndpoint* EstopConfig::_internal_add_endpoints() {
  return _impl_.endpoints_.Add();
}
inline ::bosdyn::api::EstopEndpoint* EstopConfig::add_endpoints() {
  ::bosdyn::api::EstopEndpoint* _add = _internal_add_endpoints();
  // @@protoc_insertion_point(field_add:bosdyn.api.EstopConfig.endpoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpoint >&
EstopConfig::endpoints() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.EstopConfig.endpoints)
  return _impl_.endpoints_;
}

// string unique_id = 2;
inline void EstopConfig::clear_unique_id() {
  _impl_.unique_id_.ClearToEmpty();
}
inline const std::string& EstopConfig::unique_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopConfig.unique_id)
  return _internal_unique_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EstopConfig::set_unique_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.unique_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopConfig.unique_id)
}
inline std::string* EstopConfig::mutable_unique_id() {
  std::string* _s = _internal_mutable_unique_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopConfig.unique_id)
  return _s;
}
inline const std::string& EstopConfig::_internal_unique_id() const {
  return _impl_.unique_id_.Get();
}
inline void EstopConfig::_internal_set_unique_id(const std::string& value) {
  
  _impl_.unique_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EstopConfig::_internal_mutable_unique_id() {
  
  return _impl_.unique_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EstopConfig::release_unique_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopConfig.unique_id)
  return _impl_.unique_id_.Release();
}
inline void EstopConfig::set_allocated_unique_id(std::string* unique_id) {
  if (unique_id != nullptr) {
    
  } else {
    
  }
  _impl_.unique_id_.SetAllocated(unique_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unique_id_.IsDefault()) {
    _impl_.unique_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopConfig.unique_id)
}

// -------------------------------------------------------------------

// EstopEndpointWithStatus

// .bosdyn.api.EstopEndpoint endpoint = 1;
inline bool EstopEndpointWithStatus::_internal_has_endpoint() const {
  return this != internal_default_instance() && _impl_.endpoint_ != nullptr;
}
inline bool EstopEndpointWithStatus::has_endpoint() const {
  return _internal_has_endpoint();
}
inline void EstopEndpointWithStatus::clear_endpoint() {
  if (GetArenaForAllocation() == nullptr && _impl_.endpoint_ != nullptr) {
    delete _impl_.endpoint_;
  }
  _impl_.endpoint_ = nullptr;
}
inline const ::bosdyn::api::EstopEndpoint& EstopEndpointWithStatus::_internal_endpoint() const {
  const ::bosdyn::api::EstopEndpoint* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::EstopEndpoint&>(
      ::bosdyn::api::_EstopEndpoint_default_instance_);
}
inline const ::bosdyn::api::EstopEndpoint& EstopEndpointWithStatus::endpoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopEndpointWithStatus.endpoint)
  return _internal_endpoint();
}
inline void EstopEndpointWithStatus::unsafe_arena_set_allocated_endpoint(
    ::bosdyn::api::EstopEndpoint* endpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = endpoint;
  if (endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EstopEndpointWithStatus.endpoint)
}
inline ::bosdyn::api::EstopEndpoint* EstopEndpointWithStatus::release_endpoint() {
  
  ::bosdyn::api::EstopEndpoint* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* EstopEndpointWithStatus::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopEndpointWithStatus.endpoint)
  
  ::bosdyn::api::EstopEndpoint* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* EstopEndpointWithStatus::_internal_mutable_endpoint() {
  
  if (_impl_.endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopEndpoint>(GetArenaForAllocation());
    _impl_.endpoint_ = p;
  }
  return _impl_.endpoint_;
}
inline ::bosdyn::api::EstopEndpoint* EstopEndpointWithStatus::mutable_endpoint() {
  ::bosdyn::api::EstopEndpoint* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopEndpointWithStatus.endpoint)
  return _msg;
}
inline void EstopEndpointWithStatus::set_allocated_endpoint(::bosdyn::api::EstopEndpoint* endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.endpoint_;
  }
  if (endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(endpoint);
    if (message_arena != submessage_arena) {
      endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.endpoint_ = endpoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopEndpointWithStatus.endpoint)
}

// .bosdyn.api.EstopStopLevel stop_level = 2;
inline void EstopEndpointWithStatus::clear_stop_level() {
  _impl_.stop_level_ = 0;
}
inline ::bosdyn::api::EstopStopLevel EstopEndpointWithStatus::_internal_stop_level() const {
  return static_cast< ::bosdyn::api::EstopStopLevel >(_impl_.stop_level_);
}
inline ::bosdyn::api::EstopStopLevel EstopEndpointWithStatus::stop_level() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopEndpointWithStatus.stop_level)
  return _internal_stop_level();
}
inline void EstopEndpointWithStatus::_internal_set_stop_level(::bosdyn::api::EstopStopLevel value) {
  
  _impl_.stop_level_ = value;
}
inline void EstopEndpointWithStatus::set_stop_level(::bosdyn::api::EstopStopLevel value) {
  _internal_set_stop_level(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopEndpointWithStatus.stop_level)
}

// .google.protobuf.Duration time_since_valid_response = 3;
inline bool EstopEndpointWithStatus::_internal_has_time_since_valid_response() const {
  return this != internal_default_instance() && _impl_.time_since_valid_response_ != nullptr;
}
inline bool EstopEndpointWithStatus::has_time_since_valid_response() const {
  return _internal_has_time_since_valid_response();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& EstopEndpointWithStatus::_internal_time_since_valid_response() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.time_since_valid_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& EstopEndpointWithStatus::time_since_valid_response() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopEndpointWithStatus.time_since_valid_response)
  return _internal_time_since_valid_response();
}
inline void EstopEndpointWithStatus::unsafe_arena_set_allocated_time_since_valid_response(
    ::PROTOBUF_NAMESPACE_ID::Duration* time_since_valid_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_since_valid_response_);
  }
  _impl_.time_since_valid_response_ = time_since_valid_response;
  if (time_since_valid_response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EstopEndpointWithStatus.time_since_valid_response)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EstopEndpointWithStatus::release_time_since_valid_response() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.time_since_valid_response_;
  _impl_.time_since_valid_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EstopEndpointWithStatus::unsafe_arena_release_time_since_valid_response() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopEndpointWithStatus.time_since_valid_response)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.time_since_valid_response_;
  _impl_.time_since_valid_response_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EstopEndpointWithStatus::_internal_mutable_time_since_valid_response() {
  
  if (_impl_.time_since_valid_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.time_since_valid_response_ = p;
  }
  return _impl_.time_since_valid_response_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* EstopEndpointWithStatus::mutable_time_since_valid_response() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_time_since_valid_response();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopEndpointWithStatus.time_since_valid_response)
  return _msg;
}
inline void EstopEndpointWithStatus::set_allocated_time_since_valid_response(::PROTOBUF_NAMESPACE_ID::Duration* time_since_valid_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_since_valid_response_);
  }
  if (time_since_valid_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_since_valid_response));
    if (message_arena != submessage_arena) {
      time_since_valid_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_since_valid_response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_since_valid_response_ = time_since_valid_response;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopEndpointWithStatus.time_since_valid_response)
}

// -------------------------------------------------------------------

// EstopSystemStatus

// repeated .bosdyn.api.EstopEndpointWithStatus endpoints = 3;
inline int EstopSystemStatus::_internal_endpoints_size() const {
  return _impl_.endpoints_.size();
}
inline int EstopSystemStatus::endpoints_size() const {
  return _internal_endpoints_size();
}
inline void EstopSystemStatus::clear_endpoints() {
  _impl_.endpoints_.Clear();
}
inline ::bosdyn::api::EstopEndpointWithStatus* EstopSystemStatus::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopSystemStatus.endpoints)
  return _impl_.endpoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpointWithStatus >*
EstopSystemStatus::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.EstopSystemStatus.endpoints)
  return &_impl_.endpoints_;
}
inline const ::bosdyn::api::EstopEndpointWithStatus& EstopSystemStatus::_internal_endpoints(int index) const {
  return _impl_.endpoints_.Get(index);
}
inline const ::bosdyn::api::EstopEndpointWithStatus& EstopSystemStatus::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopSystemStatus.endpoints)
  return _internal_endpoints(index);
}
inline ::bosdyn::api::EstopEndpointWithStatus* EstopSystemStatus::_internal_add_endpoints() {
  return _impl_.endpoints_.Add();
}
inline ::bosdyn::api::EstopEndpointWithStatus* EstopSystemStatus::add_endpoints() {
  ::bosdyn::api::EstopEndpointWithStatus* _add = _internal_add_endpoints();
  // @@protoc_insertion_point(field_add:bosdyn.api.EstopSystemStatus.endpoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpointWithStatus >&
EstopSystemStatus::endpoints() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.EstopSystemStatus.endpoints)
  return _impl_.endpoints_;
}

// .bosdyn.api.EstopStopLevel stop_level = 4;
inline void EstopSystemStatus::clear_stop_level() {
  _impl_.stop_level_ = 0;
}
inline ::bosdyn::api::EstopStopLevel EstopSystemStatus::_internal_stop_level() const {
  return static_cast< ::bosdyn::api::EstopStopLevel >(_impl_.stop_level_);
}
inline ::bosdyn::api::EstopStopLevel EstopSystemStatus::stop_level() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopSystemStatus.stop_level)
  return _internal_stop_level();
}
inline void EstopSystemStatus::_internal_set_stop_level(::bosdyn::api::EstopStopLevel value) {
  
  _impl_.stop_level_ = value;
}
inline void EstopSystemStatus::set_stop_level(::bosdyn::api::EstopStopLevel value) {
  _internal_set_stop_level(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopSystemStatus.stop_level)
}

// string stop_level_details = 5;
inline void EstopSystemStatus::clear_stop_level_details() {
  _impl_.stop_level_details_.ClearToEmpty();
}
inline const std::string& EstopSystemStatus::stop_level_details() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopSystemStatus.stop_level_details)
  return _internal_stop_level_details();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EstopSystemStatus::set_stop_level_details(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stop_level_details_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopSystemStatus.stop_level_details)
}
inline std::string* EstopSystemStatus::mutable_stop_level_details() {
  std::string* _s = _internal_mutable_stop_level_details();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopSystemStatus.stop_level_details)
  return _s;
}
inline const std::string& EstopSystemStatus::_internal_stop_level_details() const {
  return _impl_.stop_level_details_.Get();
}
inline void EstopSystemStatus::_internal_set_stop_level_details(const std::string& value) {
  
  _impl_.stop_level_details_.Set(value, GetArenaForAllocation());
}
inline std::string* EstopSystemStatus::_internal_mutable_stop_level_details() {
  
  return _impl_.stop_level_details_.Mutable(GetArenaForAllocation());
}
inline std::string* EstopSystemStatus::release_stop_level_details() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopSystemStatus.stop_level_details)
  return _impl_.stop_level_details_.Release();
}
inline void EstopSystemStatus::set_allocated_stop_level_details(std::string* stop_level_details) {
  if (stop_level_details != nullptr) {
    
  } else {
    
  }
  _impl_.stop_level_details_.SetAllocated(stop_level_details, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stop_level_details_.IsDefault()) {
    _impl_.stop_level_details_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopSystemStatus.stop_level_details)
}

// -------------------------------------------------------------------

// EstopCheckInRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool EstopCheckInRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool EstopCheckInRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& EstopCheckInRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& EstopCheckInRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInRequest.header)
  return _internal_header();
}
inline void EstopCheckInRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EstopCheckInRequest.header)
}
inline ::bosdyn::api::RequestHeader* EstopCheckInRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* EstopCheckInRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopCheckInRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* EstopCheckInRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* EstopCheckInRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopCheckInRequest.header)
  return _msg;
}
inline void EstopCheckInRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopCheckInRequest.header)
}

// .bosdyn.api.EstopEndpoint endpoint = 2;
inline bool EstopCheckInRequest::_internal_has_endpoint() const {
  return this != internal_default_instance() && _impl_.endpoint_ != nullptr;
}
inline bool EstopCheckInRequest::has_endpoint() const {
  return _internal_has_endpoint();
}
inline void EstopCheckInRequest::clear_endpoint() {
  if (GetArenaForAllocation() == nullptr && _impl_.endpoint_ != nullptr) {
    delete _impl_.endpoint_;
  }
  _impl_.endpoint_ = nullptr;
}
inline const ::bosdyn::api::EstopEndpoint& EstopCheckInRequest::_internal_endpoint() const {
  const ::bosdyn::api::EstopEndpoint* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::EstopEndpoint&>(
      ::bosdyn::api::_EstopEndpoint_default_instance_);
}
inline const ::bosdyn::api::EstopEndpoint& EstopCheckInRequest::endpoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInRequest.endpoint)
  return _internal_endpoint();
}
inline void EstopCheckInRequest::unsafe_arena_set_allocated_endpoint(
    ::bosdyn::api::EstopEndpoint* endpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = endpoint;
  if (endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EstopCheckInRequest.endpoint)
}
inline ::bosdyn::api::EstopEndpoint* EstopCheckInRequest::release_endpoint() {
  
  ::bosdyn::api::EstopEndpoint* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* EstopCheckInRequest::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopCheckInRequest.endpoint)
  
  ::bosdyn::api::EstopEndpoint* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* EstopCheckInRequest::_internal_mutable_endpoint() {
  
  if (_impl_.endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopEndpoint>(GetArenaForAllocation());
    _impl_.endpoint_ = p;
  }
  return _impl_.endpoint_;
}
inline ::bosdyn::api::EstopEndpoint* EstopCheckInRequest::mutable_endpoint() {
  ::bosdyn::api::EstopEndpoint* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopCheckInRequest.endpoint)
  return _msg;
}
inline void EstopCheckInRequest::set_allocated_endpoint(::bosdyn::api::EstopEndpoint* endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.endpoint_;
  }
  if (endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(endpoint);
    if (message_arena != submessage_arena) {
      endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.endpoint_ = endpoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopCheckInRequest.endpoint)
}

// uint64 challenge = 3;
inline void EstopCheckInRequest::clear_challenge() {
  _impl_.challenge_ = uint64_t{0u};
}
inline uint64_t EstopCheckInRequest::_internal_challenge() const {
  return _impl_.challenge_;
}
inline uint64_t EstopCheckInRequest::challenge() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInRequest.challenge)
  return _internal_challenge();
}
inline void EstopCheckInRequest::_internal_set_challenge(uint64_t value) {
  
  _impl_.challenge_ = value;
}
inline void EstopCheckInRequest::set_challenge(uint64_t value) {
  _internal_set_challenge(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopCheckInRequest.challenge)
}

// uint64 response = 4;
inline void EstopCheckInRequest::clear_response() {
  _impl_.response_ = uint64_t{0u};
}
inline uint64_t EstopCheckInRequest::_internal_response() const {
  return _impl_.response_;
}
inline uint64_t EstopCheckInRequest::response() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInRequest.response)
  return _internal_response();
}
inline void EstopCheckInRequest::_internal_set_response(uint64_t value) {
  
  _impl_.response_ = value;
}
inline void EstopCheckInRequest::set_response(uint64_t value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopCheckInRequest.response)
}

// .bosdyn.api.EstopStopLevel stop_level = 5;
inline void EstopCheckInRequest::clear_stop_level() {
  _impl_.stop_level_ = 0;
}
inline ::bosdyn::api::EstopStopLevel EstopCheckInRequest::_internal_stop_level() const {
  return static_cast< ::bosdyn::api::EstopStopLevel >(_impl_.stop_level_);
}
inline ::bosdyn::api::EstopStopLevel EstopCheckInRequest::stop_level() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInRequest.stop_level)
  return _internal_stop_level();
}
inline void EstopCheckInRequest::_internal_set_stop_level(::bosdyn::api::EstopStopLevel value) {
  
  _impl_.stop_level_ = value;
}
inline void EstopCheckInRequest::set_stop_level(::bosdyn::api::EstopStopLevel value) {
  _internal_set_stop_level(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopCheckInRequest.stop_level)
}

// -------------------------------------------------------------------

// EstopCheckInResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool EstopCheckInResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool EstopCheckInResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& EstopCheckInResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& EstopCheckInResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInResponse.header)
  return _internal_header();
}
inline void EstopCheckInResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EstopCheckInResponse.header)
}
inline ::bosdyn::api::ResponseHeader* EstopCheckInResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* EstopCheckInResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopCheckInResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* EstopCheckInResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* EstopCheckInResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopCheckInResponse.header)
  return _msg;
}
inline void EstopCheckInResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopCheckInResponse.header)
}

// .bosdyn.api.EstopCheckInRequest request = 2;
inline bool EstopCheckInResponse::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool EstopCheckInResponse::has_request() const {
  return _internal_has_request();
}
inline void EstopCheckInResponse::clear_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_ != nullptr) {
    delete _impl_.request_;
  }
  _impl_.request_ = nullptr;
}
inline const ::bosdyn::api::EstopCheckInRequest& EstopCheckInResponse::_internal_request() const {
  const ::bosdyn::api::EstopCheckInRequest* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::EstopCheckInRequest&>(
      ::bosdyn::api::_EstopCheckInRequest_default_instance_);
}
inline const ::bosdyn::api::EstopCheckInRequest& EstopCheckInResponse::request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInResponse.request)
  return _internal_request();
}
inline void EstopCheckInResponse::unsafe_arena_set_allocated_request(
    ::bosdyn::api::EstopCheckInRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EstopCheckInResponse.request)
}
inline ::bosdyn::api::EstopCheckInRequest* EstopCheckInResponse::release_request() {
  
  ::bosdyn::api::EstopCheckInRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::EstopCheckInRequest* EstopCheckInResponse::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopCheckInResponse.request)
  
  ::bosdyn::api::EstopCheckInRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopCheckInRequest* EstopCheckInResponse::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopCheckInRequest>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::bosdyn::api::EstopCheckInRequest* EstopCheckInResponse::mutable_request() {
  ::bosdyn::api::EstopCheckInRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopCheckInResponse.request)
  return _msg;
}
inline void EstopCheckInResponse::set_allocated_request(::bosdyn::api::EstopCheckInRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopCheckInResponse.request)
}

// uint64 challenge = 3;
inline void EstopCheckInResponse::clear_challenge() {
  _impl_.challenge_ = uint64_t{0u};
}
inline uint64_t EstopCheckInResponse::_internal_challenge() const {
  return _impl_.challenge_;
}
inline uint64_t EstopCheckInResponse::challenge() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInResponse.challenge)
  return _internal_challenge();
}
inline void EstopCheckInResponse::_internal_set_challenge(uint64_t value) {
  
  _impl_.challenge_ = value;
}
inline void EstopCheckInResponse::set_challenge(uint64_t value) {
  _internal_set_challenge(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopCheckInResponse.challenge)
}

// .bosdyn.api.EstopCheckInResponse.Status status = 4;
inline void EstopCheckInResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::EstopCheckInResponse_Status EstopCheckInResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::EstopCheckInResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::EstopCheckInResponse_Status EstopCheckInResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInResponse.status)
  return _internal_status();
}
inline void EstopCheckInResponse::_internal_set_status(::bosdyn::api::EstopCheckInResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void EstopCheckInResponse::set_status(::bosdyn::api::EstopCheckInResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopCheckInResponse.status)
}

// -------------------------------------------------------------------

// RegisterEstopEndpointRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RegisterEstopEndpointRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RegisterEstopEndpointRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RegisterEstopEndpointRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RegisterEstopEndpointRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterEstopEndpointRequest.header)
  return _internal_header();
}
inline void RegisterEstopEndpointRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RegisterEstopEndpointRequest.header)
}
inline ::bosdyn::api::RequestHeader* RegisterEstopEndpointRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* RegisterEstopEndpointRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterEstopEndpointRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RegisterEstopEndpointRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* RegisterEstopEndpointRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterEstopEndpointRequest.header)
  return _msg;
}
inline void RegisterEstopEndpointRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterEstopEndpointRequest.header)
}

// .bosdyn.api.EstopEndpoint target_endpoint = 2;
inline bool RegisterEstopEndpointRequest::_internal_has_target_endpoint() const {
  return this != internal_default_instance() && _impl_.target_endpoint_ != nullptr;
}
inline bool RegisterEstopEndpointRequest::has_target_endpoint() const {
  return _internal_has_target_endpoint();
}
inline void RegisterEstopEndpointRequest::clear_target_endpoint() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_endpoint_ != nullptr) {
    delete _impl_.target_endpoint_;
  }
  _impl_.target_endpoint_ = nullptr;
}
inline const ::bosdyn::api::EstopEndpoint& RegisterEstopEndpointRequest::_internal_target_endpoint() const {
  const ::bosdyn::api::EstopEndpoint* p = _impl_.target_endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::EstopEndpoint&>(
      ::bosdyn::api::_EstopEndpoint_default_instance_);
}
inline const ::bosdyn::api::EstopEndpoint& RegisterEstopEndpointRequest::target_endpoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterEstopEndpointRequest.target_endpoint)
  return _internal_target_endpoint();
}
inline void RegisterEstopEndpointRequest::unsafe_arena_set_allocated_target_endpoint(
    ::bosdyn::api::EstopEndpoint* target_endpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_endpoint_);
  }
  _impl_.target_endpoint_ = target_endpoint;
  if (target_endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RegisterEstopEndpointRequest.target_endpoint)
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointRequest::release_target_endpoint() {
  
  ::bosdyn::api::EstopEndpoint* temp = _impl_.target_endpoint_;
  _impl_.target_endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointRequest::unsafe_arena_release_target_endpoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterEstopEndpointRequest.target_endpoint)
  
  ::bosdyn::api::EstopEndpoint* temp = _impl_.target_endpoint_;
  _impl_.target_endpoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointRequest::_internal_mutable_target_endpoint() {
  
  if (_impl_.target_endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopEndpoint>(GetArenaForAllocation());
    _impl_.target_endpoint_ = p;
  }
  return _impl_.target_endpoint_;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointRequest::mutable_target_endpoint() {
  ::bosdyn::api::EstopEndpoint* _msg = _internal_mutable_target_endpoint();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterEstopEndpointRequest.target_endpoint)
  return _msg;
}
inline void RegisterEstopEndpointRequest::set_allocated_target_endpoint(::bosdyn::api::EstopEndpoint* target_endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_endpoint_;
  }
  if (target_endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_endpoint);
    if (message_arena != submessage_arena) {
      target_endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_endpoint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_endpoint_ = target_endpoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterEstopEndpointRequest.target_endpoint)
}

// string target_config_id = 3;
inline void RegisterEstopEndpointRequest::clear_target_config_id() {
  _impl_.target_config_id_.ClearToEmpty();
}
inline const std::string& RegisterEstopEndpointRequest::target_config_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterEstopEndpointRequest.target_config_id)
  return _internal_target_config_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterEstopEndpointRequest::set_target_config_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.target_config_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.RegisterEstopEndpointRequest.target_config_id)
}
inline std::string* RegisterEstopEndpointRequest::mutable_target_config_id() {
  std::string* _s = _internal_mutable_target_config_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterEstopEndpointRequest.target_config_id)
  return _s;
}
inline const std::string& RegisterEstopEndpointRequest::_internal_target_config_id() const {
  return _impl_.target_config_id_.Get();
}
inline void RegisterEstopEndpointRequest::_internal_set_target_config_id(const std::string& value) {
  
  _impl_.target_config_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterEstopEndpointRequest::_internal_mutable_target_config_id() {
  
  return _impl_.target_config_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterEstopEndpointRequest::release_target_config_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterEstopEndpointRequest.target_config_id)
  return _impl_.target_config_id_.Release();
}
inline void RegisterEstopEndpointRequest::set_allocated_target_config_id(std::string* target_config_id) {
  if (target_config_id != nullptr) {
    
  } else {
    
  }
  _impl_.target_config_id_.SetAllocated(target_config_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_config_id_.IsDefault()) {
    _impl_.target_config_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterEstopEndpointRequest.target_config_id)
}

// .bosdyn.api.EstopEndpoint new_endpoint = 4;
inline bool RegisterEstopEndpointRequest::_internal_has_new_endpoint() const {
  return this != internal_default_instance() && _impl_.new_endpoint_ != nullptr;
}
inline bool RegisterEstopEndpointRequest::has_new_endpoint() const {
  return _internal_has_new_endpoint();
}
inline void RegisterEstopEndpointRequest::clear_new_endpoint() {
  if (GetArenaForAllocation() == nullptr && _impl_.new_endpoint_ != nullptr) {
    delete _impl_.new_endpoint_;
  }
  _impl_.new_endpoint_ = nullptr;
}
inline const ::bosdyn::api::EstopEndpoint& RegisterEstopEndpointRequest::_internal_new_endpoint() const {
  const ::bosdyn::api::EstopEndpoint* p = _impl_.new_endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::EstopEndpoint&>(
      ::bosdyn::api::_EstopEndpoint_default_instance_);
}
inline const ::bosdyn::api::EstopEndpoint& RegisterEstopEndpointRequest::new_endpoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterEstopEndpointRequest.new_endpoint)
  return _internal_new_endpoint();
}
inline void RegisterEstopEndpointRequest::unsafe_arena_set_allocated_new_endpoint(
    ::bosdyn::api::EstopEndpoint* new_endpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_endpoint_);
  }
  _impl_.new_endpoint_ = new_endpoint;
  if (new_endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RegisterEstopEndpointRequest.new_endpoint)
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointRequest::release_new_endpoint() {
  
  ::bosdyn::api::EstopEndpoint* temp = _impl_.new_endpoint_;
  _impl_.new_endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointRequest::unsafe_arena_release_new_endpoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterEstopEndpointRequest.new_endpoint)
  
  ::bosdyn::api::EstopEndpoint* temp = _impl_.new_endpoint_;
  _impl_.new_endpoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointRequest::_internal_mutable_new_endpoint() {
  
  if (_impl_.new_endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopEndpoint>(GetArenaForAllocation());
    _impl_.new_endpoint_ = p;
  }
  return _impl_.new_endpoint_;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointRequest::mutable_new_endpoint() {
  ::bosdyn::api::EstopEndpoint* _msg = _internal_mutable_new_endpoint();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterEstopEndpointRequest.new_endpoint)
  return _msg;
}
inline void RegisterEstopEndpointRequest::set_allocated_new_endpoint(::bosdyn::api::EstopEndpoint* new_endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.new_endpoint_;
  }
  if (new_endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(new_endpoint);
    if (message_arena != submessage_arena) {
      new_endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_endpoint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.new_endpoint_ = new_endpoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterEstopEndpointRequest.new_endpoint)
}

// -------------------------------------------------------------------

// RegisterEstopEndpointResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RegisterEstopEndpointResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RegisterEstopEndpointResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RegisterEstopEndpointResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RegisterEstopEndpointResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterEstopEndpointResponse.header)
  return _internal_header();
}
inline void RegisterEstopEndpointResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RegisterEstopEndpointResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RegisterEstopEndpointResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RegisterEstopEndpointResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterEstopEndpointResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RegisterEstopEndpointResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* RegisterEstopEndpointResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterEstopEndpointResponse.header)
  return _msg;
}
inline void RegisterEstopEndpointResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterEstopEndpointResponse.header)
}

// .bosdyn.api.RegisterEstopEndpointRequest request = 2;
inline bool RegisterEstopEndpointResponse::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool RegisterEstopEndpointResponse::has_request() const {
  return _internal_has_request();
}
inline void RegisterEstopEndpointResponse::clear_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_ != nullptr) {
    delete _impl_.request_;
  }
  _impl_.request_ = nullptr;
}
inline const ::bosdyn::api::RegisterEstopEndpointRequest& RegisterEstopEndpointResponse::_internal_request() const {
  const ::bosdyn::api::RegisterEstopEndpointRequest* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RegisterEstopEndpointRequest&>(
      ::bosdyn::api::_RegisterEstopEndpointRequest_default_instance_);
}
inline const ::bosdyn::api::RegisterEstopEndpointRequest& RegisterEstopEndpointResponse::request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterEstopEndpointResponse.request)
  return _internal_request();
}
inline void RegisterEstopEndpointResponse::unsafe_arena_set_allocated_request(
    ::bosdyn::api::RegisterEstopEndpointRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RegisterEstopEndpointResponse.request)
}
inline ::bosdyn::api::RegisterEstopEndpointRequest* RegisterEstopEndpointResponse::release_request() {
  
  ::bosdyn::api::RegisterEstopEndpointRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RegisterEstopEndpointRequest* RegisterEstopEndpointResponse::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterEstopEndpointResponse.request)
  
  ::bosdyn::api::RegisterEstopEndpointRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RegisterEstopEndpointRequest* RegisterEstopEndpointResponse::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RegisterEstopEndpointRequest>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::bosdyn::api::RegisterEstopEndpointRequest* RegisterEstopEndpointResponse::mutable_request() {
  ::bosdyn::api::RegisterEstopEndpointRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterEstopEndpointResponse.request)
  return _msg;
}
inline void RegisterEstopEndpointResponse::set_allocated_request(::bosdyn::api::RegisterEstopEndpointRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterEstopEndpointResponse.request)
}

// .bosdyn.api.EstopEndpoint new_endpoint = 3;
inline bool RegisterEstopEndpointResponse::_internal_has_new_endpoint() const {
  return this != internal_default_instance() && _impl_.new_endpoint_ != nullptr;
}
inline bool RegisterEstopEndpointResponse::has_new_endpoint() const {
  return _internal_has_new_endpoint();
}
inline void RegisterEstopEndpointResponse::clear_new_endpoint() {
  if (GetArenaForAllocation() == nullptr && _impl_.new_endpoint_ != nullptr) {
    delete _impl_.new_endpoint_;
  }
  _impl_.new_endpoint_ = nullptr;
}
inline const ::bosdyn::api::EstopEndpoint& RegisterEstopEndpointResponse::_internal_new_endpoint() const {
  const ::bosdyn::api::EstopEndpoint* p = _impl_.new_endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::EstopEndpoint&>(
      ::bosdyn::api::_EstopEndpoint_default_instance_);
}
inline const ::bosdyn::api::EstopEndpoint& RegisterEstopEndpointResponse::new_endpoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterEstopEndpointResponse.new_endpoint)
  return _internal_new_endpoint();
}
inline void RegisterEstopEndpointResponse::unsafe_arena_set_allocated_new_endpoint(
    ::bosdyn::api::EstopEndpoint* new_endpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_endpoint_);
  }
  _impl_.new_endpoint_ = new_endpoint;
  if (new_endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RegisterEstopEndpointResponse.new_endpoint)
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointResponse::release_new_endpoint() {
  
  ::bosdyn::api::EstopEndpoint* temp = _impl_.new_endpoint_;
  _impl_.new_endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointResponse::unsafe_arena_release_new_endpoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterEstopEndpointResponse.new_endpoint)
  
  ::bosdyn::api::EstopEndpoint* temp = _impl_.new_endpoint_;
  _impl_.new_endpoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointResponse::_internal_mutable_new_endpoint() {
  
  if (_impl_.new_endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopEndpoint>(GetArenaForAllocation());
    _impl_.new_endpoint_ = p;
  }
  return _impl_.new_endpoint_;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointResponse::mutable_new_endpoint() {
  ::bosdyn::api::EstopEndpoint* _msg = _internal_mutable_new_endpoint();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterEstopEndpointResponse.new_endpoint)
  return _msg;
}
inline void RegisterEstopEndpointResponse::set_allocated_new_endpoint(::bosdyn::api::EstopEndpoint* new_endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.new_endpoint_;
  }
  if (new_endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(new_endpoint);
    if (message_arena != submessage_arena) {
      new_endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_endpoint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.new_endpoint_ = new_endpoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterEstopEndpointResponse.new_endpoint)
}

// .bosdyn.api.RegisterEstopEndpointResponse.Status status = 4;
inline void RegisterEstopEndpointResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::RegisterEstopEndpointResponse_Status RegisterEstopEndpointResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::RegisterEstopEndpointResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::RegisterEstopEndpointResponse_Status RegisterEstopEndpointResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterEstopEndpointResponse.status)
  return _internal_status();
}
inline void RegisterEstopEndpointResponse::_internal_set_status(::bosdyn::api::RegisterEstopEndpointResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void RegisterEstopEndpointResponse::set_status(::bosdyn::api::RegisterEstopEndpointResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RegisterEstopEndpointResponse.status)
}

// -------------------------------------------------------------------

// DeregisterEstopEndpointRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool DeregisterEstopEndpointRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DeregisterEstopEndpointRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& DeregisterEstopEndpointRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& DeregisterEstopEndpointRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeregisterEstopEndpointRequest.header)
  return _internal_header();
}
inline void DeregisterEstopEndpointRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DeregisterEstopEndpointRequest.header)
}
inline ::bosdyn::api::RequestHeader* DeregisterEstopEndpointRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* DeregisterEstopEndpointRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DeregisterEstopEndpointRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* DeregisterEstopEndpointRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* DeregisterEstopEndpointRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DeregisterEstopEndpointRequest.header)
  return _msg;
}
inline void DeregisterEstopEndpointRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DeregisterEstopEndpointRequest.header)
}

// .bosdyn.api.EstopEndpoint target_endpoint = 2;
inline bool DeregisterEstopEndpointRequest::_internal_has_target_endpoint() const {
  return this != internal_default_instance() && _impl_.target_endpoint_ != nullptr;
}
inline bool DeregisterEstopEndpointRequest::has_target_endpoint() const {
  return _internal_has_target_endpoint();
}
inline void DeregisterEstopEndpointRequest::clear_target_endpoint() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_endpoint_ != nullptr) {
    delete _impl_.target_endpoint_;
  }
  _impl_.target_endpoint_ = nullptr;
}
inline const ::bosdyn::api::EstopEndpoint& DeregisterEstopEndpointRequest::_internal_target_endpoint() const {
  const ::bosdyn::api::EstopEndpoint* p = _impl_.target_endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::EstopEndpoint&>(
      ::bosdyn::api::_EstopEndpoint_default_instance_);
}
inline const ::bosdyn::api::EstopEndpoint& DeregisterEstopEndpointRequest::target_endpoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeregisterEstopEndpointRequest.target_endpoint)
  return _internal_target_endpoint();
}
inline void DeregisterEstopEndpointRequest::unsafe_arena_set_allocated_target_endpoint(
    ::bosdyn::api::EstopEndpoint* target_endpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_endpoint_);
  }
  _impl_.target_endpoint_ = target_endpoint;
  if (target_endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DeregisterEstopEndpointRequest.target_endpoint)
}
inline ::bosdyn::api::EstopEndpoint* DeregisterEstopEndpointRequest::release_target_endpoint() {
  
  ::bosdyn::api::EstopEndpoint* temp = _impl_.target_endpoint_;
  _impl_.target_endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* DeregisterEstopEndpointRequest::unsafe_arena_release_target_endpoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DeregisterEstopEndpointRequest.target_endpoint)
  
  ::bosdyn::api::EstopEndpoint* temp = _impl_.target_endpoint_;
  _impl_.target_endpoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* DeregisterEstopEndpointRequest::_internal_mutable_target_endpoint() {
  
  if (_impl_.target_endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopEndpoint>(GetArenaForAllocation());
    _impl_.target_endpoint_ = p;
  }
  return _impl_.target_endpoint_;
}
inline ::bosdyn::api::EstopEndpoint* DeregisterEstopEndpointRequest::mutable_target_endpoint() {
  ::bosdyn::api::EstopEndpoint* _msg = _internal_mutable_target_endpoint();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DeregisterEstopEndpointRequest.target_endpoint)
  return _msg;
}
inline void DeregisterEstopEndpointRequest::set_allocated_target_endpoint(::bosdyn::api::EstopEndpoint* target_endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_endpoint_;
  }
  if (target_endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_endpoint);
    if (message_arena != submessage_arena) {
      target_endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_endpoint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_endpoint_ = target_endpoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DeregisterEstopEndpointRequest.target_endpoint)
}

// string target_config_id = 3;
inline void DeregisterEstopEndpointRequest::clear_target_config_id() {
  _impl_.target_config_id_.ClearToEmpty();
}
inline const std::string& DeregisterEstopEndpointRequest::target_config_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeregisterEstopEndpointRequest.target_config_id)
  return _internal_target_config_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeregisterEstopEndpointRequest::set_target_config_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.target_config_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.DeregisterEstopEndpointRequest.target_config_id)
}
inline std::string* DeregisterEstopEndpointRequest::mutable_target_config_id() {
  std::string* _s = _internal_mutable_target_config_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DeregisterEstopEndpointRequest.target_config_id)
  return _s;
}
inline const std::string& DeregisterEstopEndpointRequest::_internal_target_config_id() const {
  return _impl_.target_config_id_.Get();
}
inline void DeregisterEstopEndpointRequest::_internal_set_target_config_id(const std::string& value) {
  
  _impl_.target_config_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeregisterEstopEndpointRequest::_internal_mutable_target_config_id() {
  
  return _impl_.target_config_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeregisterEstopEndpointRequest::release_target_config_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DeregisterEstopEndpointRequest.target_config_id)
  return _impl_.target_config_id_.Release();
}
inline void DeregisterEstopEndpointRequest::set_allocated_target_config_id(std::string* target_config_id) {
  if (target_config_id != nullptr) {
    
  } else {
    
  }
  _impl_.target_config_id_.SetAllocated(target_config_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_config_id_.IsDefault()) {
    _impl_.target_config_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DeregisterEstopEndpointRequest.target_config_id)
}

// -------------------------------------------------------------------

// DeregisterEstopEndpointResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool DeregisterEstopEndpointResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DeregisterEstopEndpointResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& DeregisterEstopEndpointResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& DeregisterEstopEndpointResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeregisterEstopEndpointResponse.header)
  return _internal_header();
}
inline void DeregisterEstopEndpointResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DeregisterEstopEndpointResponse.header)
}
inline ::bosdyn::api::ResponseHeader* DeregisterEstopEndpointResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DeregisterEstopEndpointResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DeregisterEstopEndpointResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DeregisterEstopEndpointResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* DeregisterEstopEndpointResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DeregisterEstopEndpointResponse.header)
  return _msg;
}
inline void DeregisterEstopEndpointResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DeregisterEstopEndpointResponse.header)
}

// .bosdyn.api.DeregisterEstopEndpointRequest request = 2;
inline bool DeregisterEstopEndpointResponse::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool DeregisterEstopEndpointResponse::has_request() const {
  return _internal_has_request();
}
inline void DeregisterEstopEndpointResponse::clear_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_ != nullptr) {
    delete _impl_.request_;
  }
  _impl_.request_ = nullptr;
}
inline const ::bosdyn::api::DeregisterEstopEndpointRequest& DeregisterEstopEndpointResponse::_internal_request() const {
  const ::bosdyn::api::DeregisterEstopEndpointRequest* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DeregisterEstopEndpointRequest&>(
      ::bosdyn::api::_DeregisterEstopEndpointRequest_default_instance_);
}
inline const ::bosdyn::api::DeregisterEstopEndpointRequest& DeregisterEstopEndpointResponse::request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeregisterEstopEndpointResponse.request)
  return _internal_request();
}
inline void DeregisterEstopEndpointResponse::unsafe_arena_set_allocated_request(
    ::bosdyn::api::DeregisterEstopEndpointRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DeregisterEstopEndpointResponse.request)
}
inline ::bosdyn::api::DeregisterEstopEndpointRequest* DeregisterEstopEndpointResponse::release_request() {
  
  ::bosdyn::api::DeregisterEstopEndpointRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DeregisterEstopEndpointRequest* DeregisterEstopEndpointResponse::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DeregisterEstopEndpointResponse.request)
  
  ::bosdyn::api::DeregisterEstopEndpointRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DeregisterEstopEndpointRequest* DeregisterEstopEndpointResponse::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DeregisterEstopEndpointRequest>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::bosdyn::api::DeregisterEstopEndpointRequest* DeregisterEstopEndpointResponse::mutable_request() {
  ::bosdyn::api::DeregisterEstopEndpointRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DeregisterEstopEndpointResponse.request)
  return _msg;
}
inline void DeregisterEstopEndpointResponse::set_allocated_request(::bosdyn::api::DeregisterEstopEndpointRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DeregisterEstopEndpointResponse.request)
}

// .bosdyn.api.DeregisterEstopEndpointResponse.Status status = 4;
inline void DeregisterEstopEndpointResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::DeregisterEstopEndpointResponse_Status DeregisterEstopEndpointResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::DeregisterEstopEndpointResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::DeregisterEstopEndpointResponse_Status DeregisterEstopEndpointResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeregisterEstopEndpointResponse.status)
  return _internal_status();
}
inline void DeregisterEstopEndpointResponse::_internal_set_status(::bosdyn::api::DeregisterEstopEndpointResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void DeregisterEstopEndpointResponse::set_status(::bosdyn::api::DeregisterEstopEndpointResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DeregisterEstopEndpointResponse.status)
}

// -------------------------------------------------------------------

// GetEstopConfigRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetEstopConfigRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetEstopConfigRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetEstopConfigRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetEstopConfigRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEstopConfigRequest.header)
  return _internal_header();
}
inline void GetEstopConfigRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEstopConfigRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetEstopConfigRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetEstopConfigRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEstopConfigRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetEstopConfigRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* GetEstopConfigRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEstopConfigRequest.header)
  return _msg;
}
inline void GetEstopConfigRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEstopConfigRequest.header)
}

// string target_config_id = 4;
inline void GetEstopConfigRequest::clear_target_config_id() {
  _impl_.target_config_id_.ClearToEmpty();
}
inline const std::string& GetEstopConfigRequest::target_config_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEstopConfigRequest.target_config_id)
  return _internal_target_config_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetEstopConfigRequest::set_target_config_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.target_config_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.GetEstopConfigRequest.target_config_id)
}
inline std::string* GetEstopConfigRequest::mutable_target_config_id() {
  std::string* _s = _internal_mutable_target_config_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEstopConfigRequest.target_config_id)
  return _s;
}
inline const std::string& GetEstopConfigRequest::_internal_target_config_id() const {
  return _impl_.target_config_id_.Get();
}
inline void GetEstopConfigRequest::_internal_set_target_config_id(const std::string& value) {
  
  _impl_.target_config_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetEstopConfigRequest::_internal_mutable_target_config_id() {
  
  return _impl_.target_config_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetEstopConfigRequest::release_target_config_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEstopConfigRequest.target_config_id)
  return _impl_.target_config_id_.Release();
}
inline void GetEstopConfigRequest::set_allocated_target_config_id(std::string* target_config_id) {
  if (target_config_id != nullptr) {
    
  } else {
    
  }
  _impl_.target_config_id_.SetAllocated(target_config_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_config_id_.IsDefault()) {
    _impl_.target_config_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEstopConfigRequest.target_config_id)
}

// -------------------------------------------------------------------

// GetEstopConfigResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetEstopConfigResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetEstopConfigResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetEstopConfigResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetEstopConfigResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEstopConfigResponse.header)
  return _internal_header();
}
inline void GetEstopConfigResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEstopConfigResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetEstopConfigResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetEstopConfigResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEstopConfigResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetEstopConfigResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* GetEstopConfigResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEstopConfigResponse.header)
  return _msg;
}
inline void GetEstopConfigResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEstopConfigResponse.header)
}

// .bosdyn.api.GetEstopConfigRequest request = 2;
inline bool GetEstopConfigResponse::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool GetEstopConfigResponse::has_request() const {
  return _internal_has_request();
}
inline void GetEstopConfigResponse::clear_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_ != nullptr) {
    delete _impl_.request_;
  }
  _impl_.request_ = nullptr;
}
inline const ::bosdyn::api::GetEstopConfigRequest& GetEstopConfigResponse::_internal_request() const {
  const ::bosdyn::api::GetEstopConfigRequest* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::GetEstopConfigRequest&>(
      ::bosdyn::api::_GetEstopConfigRequest_default_instance_);
}
inline const ::bosdyn::api::GetEstopConfigRequest& GetEstopConfigResponse::request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEstopConfigResponse.request)
  return _internal_request();
}
inline void GetEstopConfigResponse::unsafe_arena_set_allocated_request(
    ::bosdyn::api::GetEstopConfigRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEstopConfigResponse.request)
}
inline ::bosdyn::api::GetEstopConfigRequest* GetEstopConfigResponse::release_request() {
  
  ::bosdyn::api::GetEstopConfigRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::GetEstopConfigRequest* GetEstopConfigResponse::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEstopConfigResponse.request)
  
  ::bosdyn::api::GetEstopConfigRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::GetEstopConfigRequest* GetEstopConfigResponse::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::GetEstopConfigRequest>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::bosdyn::api::GetEstopConfigRequest* GetEstopConfigResponse::mutable_request() {
  ::bosdyn::api::GetEstopConfigRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEstopConfigResponse.request)
  return _msg;
}
inline void GetEstopConfigResponse::set_allocated_request(::bosdyn::api::GetEstopConfigRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEstopConfigResponse.request)
}

// .bosdyn.api.EstopConfig active_config = 3;
inline bool GetEstopConfigResponse::_internal_has_active_config() const {
  return this != internal_default_instance() && _impl_.active_config_ != nullptr;
}
inline bool GetEstopConfigResponse::has_active_config() const {
  return _internal_has_active_config();
}
inline void GetEstopConfigResponse::clear_active_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.active_config_ != nullptr) {
    delete _impl_.active_config_;
  }
  _impl_.active_config_ = nullptr;
}
inline const ::bosdyn::api::EstopConfig& GetEstopConfigResponse::_internal_active_config() const {
  const ::bosdyn::api::EstopConfig* p = _impl_.active_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::EstopConfig&>(
      ::bosdyn::api::_EstopConfig_default_instance_);
}
inline const ::bosdyn::api::EstopConfig& GetEstopConfigResponse::active_config() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEstopConfigResponse.active_config)
  return _internal_active_config();
}
inline void GetEstopConfigResponse::unsafe_arena_set_allocated_active_config(
    ::bosdyn::api::EstopConfig* active_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.active_config_);
  }
  _impl_.active_config_ = active_config;
  if (active_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEstopConfigResponse.active_config)
}
inline ::bosdyn::api::EstopConfig* GetEstopConfigResponse::release_active_config() {
  
  ::bosdyn::api::EstopConfig* temp = _impl_.active_config_;
  _impl_.active_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::EstopConfig* GetEstopConfigResponse::unsafe_arena_release_active_config() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEstopConfigResponse.active_config)
  
  ::bosdyn::api::EstopConfig* temp = _impl_.active_config_;
  _impl_.active_config_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopConfig* GetEstopConfigResponse::_internal_mutable_active_config() {
  
  if (_impl_.active_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopConfig>(GetArenaForAllocation());
    _impl_.active_config_ = p;
  }
  return _impl_.active_config_;
}
inline ::bosdyn::api::EstopConfig* GetEstopConfigResponse::mutable_active_config() {
  ::bosdyn::api::EstopConfig* _msg = _internal_mutable_active_config();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEstopConfigResponse.active_config)
  return _msg;
}
inline void GetEstopConfigResponse::set_allocated_active_config(::bosdyn::api::EstopConfig* active_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.active_config_;
  }
  if (active_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(active_config);
    if (message_arena != submessage_arena) {
      active_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.active_config_ = active_config;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEstopConfigResponse.active_config)
}

// -------------------------------------------------------------------

// SetEstopConfigRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool SetEstopConfigRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SetEstopConfigRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& SetEstopConfigRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& SetEstopConfigRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SetEstopConfigRequest.header)
  return _internal_header();
}
inline void SetEstopConfigRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SetEstopConfigRequest.header)
}
inline ::bosdyn::api::RequestHeader* SetEstopConfigRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* SetEstopConfigRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SetEstopConfigRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* SetEstopConfigRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* SetEstopConfigRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SetEstopConfigRequest.header)
  return _msg;
}
inline void SetEstopConfigRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SetEstopConfigRequest.header)
}

// .bosdyn.api.EstopConfig config = 3;
inline bool SetEstopConfigRequest::_internal_has_config() const {
  return this != internal_default_instance() && _impl_.config_ != nullptr;
}
inline bool SetEstopConfigRequest::has_config() const {
  return _internal_has_config();
}
inline void SetEstopConfigRequest::clear_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
    delete _impl_.config_;
  }
  _impl_.config_ = nullptr;
}
inline const ::bosdyn::api::EstopConfig& SetEstopConfigRequest::_internal_config() const {
  const ::bosdyn::api::EstopConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::EstopConfig&>(
      ::bosdyn::api::_EstopConfig_default_instance_);
}
inline const ::bosdyn::api::EstopConfig& SetEstopConfigRequest::config() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SetEstopConfigRequest.config)
  return _internal_config();
}
inline void SetEstopConfigRequest::unsafe_arena_set_allocated_config(
    ::bosdyn::api::EstopConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SetEstopConfigRequest.config)
}
inline ::bosdyn::api::EstopConfig* SetEstopConfigRequest::release_config() {
  
  ::bosdyn::api::EstopConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::EstopConfig* SetEstopConfigRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SetEstopConfigRequest.config)
  
  ::bosdyn::api::EstopConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopConfig* SetEstopConfigRequest::_internal_mutable_config() {
  
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopConfig>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::bosdyn::api::EstopConfig* SetEstopConfigRequest::mutable_config() {
  ::bosdyn::api::EstopConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SetEstopConfigRequest.config)
  return _msg;
}
inline void SetEstopConfigRequest::set_allocated_config(::bosdyn::api::EstopConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SetEstopConfigRequest.config)
}

// string target_config_id = 4;
inline void SetEstopConfigRequest::clear_target_config_id() {
  _impl_.target_config_id_.ClearToEmpty();
}
inline const std::string& SetEstopConfigRequest::target_config_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SetEstopConfigRequest.target_config_id)
  return _internal_target_config_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetEstopConfigRequest::set_target_config_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.target_config_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.SetEstopConfigRequest.target_config_id)
}
inline std::string* SetEstopConfigRequest::mutable_target_config_id() {
  std::string* _s = _internal_mutable_target_config_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SetEstopConfigRequest.target_config_id)
  return _s;
}
inline const std::string& SetEstopConfigRequest::_internal_target_config_id() const {
  return _impl_.target_config_id_.Get();
}
inline void SetEstopConfigRequest::_internal_set_target_config_id(const std::string& value) {
  
  _impl_.target_config_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SetEstopConfigRequest::_internal_mutable_target_config_id() {
  
  return _impl_.target_config_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SetEstopConfigRequest::release_target_config_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SetEstopConfigRequest.target_config_id)
  return _impl_.target_config_id_.Release();
}
inline void SetEstopConfigRequest::set_allocated_target_config_id(std::string* target_config_id) {
  if (target_config_id != nullptr) {
    
  } else {
    
  }
  _impl_.target_config_id_.SetAllocated(target_config_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_config_id_.IsDefault()) {
    _impl_.target_config_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SetEstopConfigRequest.target_config_id)
}

// -------------------------------------------------------------------

// SetEstopConfigResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool SetEstopConfigResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SetEstopConfigResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& SetEstopConfigResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& SetEstopConfigResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SetEstopConfigResponse.header)
  return _internal_header();
}
inline void SetEstopConfigResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SetEstopConfigResponse.header)
}
inline ::bosdyn::api::ResponseHeader* SetEstopConfigResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SetEstopConfigResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SetEstopConfigResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SetEstopConfigResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* SetEstopConfigResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SetEstopConfigResponse.header)
  return _msg;
}
inline void SetEstopConfigResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SetEstopConfigResponse.header)
}

// .bosdyn.api.SetEstopConfigRequest request = 2;
inline bool SetEstopConfigResponse::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool SetEstopConfigResponse::has_request() const {
  return _internal_has_request();
}
inline void SetEstopConfigResponse::clear_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_ != nullptr) {
    delete _impl_.request_;
  }
  _impl_.request_ = nullptr;
}
inline const ::bosdyn::api::SetEstopConfigRequest& SetEstopConfigResponse::_internal_request() const {
  const ::bosdyn::api::SetEstopConfigRequest* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SetEstopConfigRequest&>(
      ::bosdyn::api::_SetEstopConfigRequest_default_instance_);
}
inline const ::bosdyn::api::SetEstopConfigRequest& SetEstopConfigResponse::request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SetEstopConfigResponse.request)
  return _internal_request();
}
inline void SetEstopConfigResponse::unsafe_arena_set_allocated_request(
    ::bosdyn::api::SetEstopConfigRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SetEstopConfigResponse.request)
}
inline ::bosdyn::api::SetEstopConfigRequest* SetEstopConfigResponse::release_request() {
  
  ::bosdyn::api::SetEstopConfigRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SetEstopConfigRequest* SetEstopConfigResponse::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SetEstopConfigResponse.request)
  
  ::bosdyn::api::SetEstopConfigRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SetEstopConfigRequest* SetEstopConfigResponse::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SetEstopConfigRequest>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::bosdyn::api::SetEstopConfigRequest* SetEstopConfigResponse::mutable_request() {
  ::bosdyn::api::SetEstopConfigRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SetEstopConfigResponse.request)
  return _msg;
}
inline void SetEstopConfigResponse::set_allocated_request(::bosdyn::api::SetEstopConfigRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SetEstopConfigResponse.request)
}

// .bosdyn.api.EstopConfig active_config = 3;
inline bool SetEstopConfigResponse::_internal_has_active_config() const {
  return this != internal_default_instance() && _impl_.active_config_ != nullptr;
}
inline bool SetEstopConfigResponse::has_active_config() const {
  return _internal_has_active_config();
}
inline void SetEstopConfigResponse::clear_active_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.active_config_ != nullptr) {
    delete _impl_.active_config_;
  }
  _impl_.active_config_ = nullptr;
}
inline const ::bosdyn::api::EstopConfig& SetEstopConfigResponse::_internal_active_config() const {
  const ::bosdyn::api::EstopConfig* p = _impl_.active_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::EstopConfig&>(
      ::bosdyn::api::_EstopConfig_default_instance_);
}
inline const ::bosdyn::api::EstopConfig& SetEstopConfigResponse::active_config() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SetEstopConfigResponse.active_config)
  return _internal_active_config();
}
inline void SetEstopConfigResponse::unsafe_arena_set_allocated_active_config(
    ::bosdyn::api::EstopConfig* active_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.active_config_);
  }
  _impl_.active_config_ = active_config;
  if (active_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SetEstopConfigResponse.active_config)
}
inline ::bosdyn::api::EstopConfig* SetEstopConfigResponse::release_active_config() {
  
  ::bosdyn::api::EstopConfig* temp = _impl_.active_config_;
  _impl_.active_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::EstopConfig* SetEstopConfigResponse::unsafe_arena_release_active_config() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SetEstopConfigResponse.active_config)
  
  ::bosdyn::api::EstopConfig* temp = _impl_.active_config_;
  _impl_.active_config_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopConfig* SetEstopConfigResponse::_internal_mutable_active_config() {
  
  if (_impl_.active_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopConfig>(GetArenaForAllocation());
    _impl_.active_config_ = p;
  }
  return _impl_.active_config_;
}
inline ::bosdyn::api::EstopConfig* SetEstopConfigResponse::mutable_active_config() {
  ::bosdyn::api::EstopConfig* _msg = _internal_mutable_active_config();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SetEstopConfigResponse.active_config)
  return _msg;
}
inline void SetEstopConfigResponse::set_allocated_active_config(::bosdyn::api::EstopConfig* active_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.active_config_;
  }
  if (active_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(active_config);
    if (message_arena != submessage_arena) {
      active_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.active_config_ = active_config;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SetEstopConfigResponse.active_config)
}

// .bosdyn.api.SetEstopConfigResponse.Status status = 4;
inline void SetEstopConfigResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::SetEstopConfigResponse_Status SetEstopConfigResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::SetEstopConfigResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::SetEstopConfigResponse_Status SetEstopConfigResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SetEstopConfigResponse.status)
  return _internal_status();
}
inline void SetEstopConfigResponse::_internal_set_status(::bosdyn::api::SetEstopConfigResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void SetEstopConfigResponse::set_status(::bosdyn::api::SetEstopConfigResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SetEstopConfigResponse.status)
}

// -------------------------------------------------------------------

// GetEstopSystemStatusRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetEstopSystemStatusRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetEstopSystemStatusRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetEstopSystemStatusRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetEstopSystemStatusRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEstopSystemStatusRequest.header)
  return _internal_header();
}
inline void GetEstopSystemStatusRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEstopSystemStatusRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetEstopSystemStatusRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetEstopSystemStatusRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEstopSystemStatusRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetEstopSystemStatusRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* GetEstopSystemStatusRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEstopSystemStatusRequest.header)
  return _msg;
}
inline void GetEstopSystemStatusRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEstopSystemStatusRequest.header)
}

// -------------------------------------------------------------------

// GetEstopSystemStatusResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetEstopSystemStatusResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetEstopSystemStatusResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetEstopSystemStatusResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetEstopSystemStatusResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEstopSystemStatusResponse.header)
  return _internal_header();
}
inline void GetEstopSystemStatusResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEstopSystemStatusResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetEstopSystemStatusResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetEstopSystemStatusResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEstopSystemStatusResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetEstopSystemStatusResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* GetEstopSystemStatusResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEstopSystemStatusResponse.header)
  return _msg;
}
inline void GetEstopSystemStatusResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEstopSystemStatusResponse.header)
}

// .bosdyn.api.EstopSystemStatus status = 3;
inline bool GetEstopSystemStatusResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool GetEstopSystemStatusResponse::has_status() const {
  return _internal_has_status();
}
inline void GetEstopSystemStatusResponse::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::bosdyn::api::EstopSystemStatus& GetEstopSystemStatusResponse::_internal_status() const {
  const ::bosdyn::api::EstopSystemStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::EstopSystemStatus&>(
      ::bosdyn::api::_EstopSystemStatus_default_instance_);
}
inline const ::bosdyn::api::EstopSystemStatus& GetEstopSystemStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEstopSystemStatusResponse.status)
  return _internal_status();
}
inline void GetEstopSystemStatusResponse::unsafe_arena_set_allocated_status(
    ::bosdyn::api::EstopSystemStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEstopSystemStatusResponse.status)
}
inline ::bosdyn::api::EstopSystemStatus* GetEstopSystemStatusResponse::release_status() {
  
  ::bosdyn::api::EstopSystemStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::EstopSystemStatus* GetEstopSystemStatusResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEstopSystemStatusResponse.status)
  
  ::bosdyn::api::EstopSystemStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopSystemStatus* GetEstopSystemStatusResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopSystemStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::bosdyn::api::EstopSystemStatus* GetEstopSystemStatusResponse::mutable_status() {
  ::bosdyn::api::EstopSystemStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEstopSystemStatusResponse.status)
  return _msg;
}
inline void GetEstopSystemStatusResponse::set_allocated_status(::bosdyn::api::EstopSystemStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEstopSystemStatusResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::EstopCheckInResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::EstopCheckInResponse_Status>() {
  return ::bosdyn::api::EstopCheckInResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::RegisterEstopEndpointResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::RegisterEstopEndpointResponse_Status>() {
  return ::bosdyn::api::RegisterEstopEndpointResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::DeregisterEstopEndpointResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::DeregisterEstopEndpointResponse_Status>() {
  return ::bosdyn::api::DeregisterEstopEndpointResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::SetEstopConfigResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::SetEstopConfigResponse_Status>() {
  return ::bosdyn::api::SetEstopConfigResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::EstopStopLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::EstopStopLevel>() {
  return ::bosdyn::api::EstopStopLevel_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2festop_2eproto
