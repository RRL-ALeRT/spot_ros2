// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/autowalk/autowalk.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fautowalk_2fautowalk_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fautowalk_2fautowalk_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/lease.pb.h"
#include "bosdyn/api/autowalk/walks.pb.h"
#include "bosdyn/api/mission/mission.pb.h"
#include "bosdyn/api/mission/nodes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fautowalk_2fautowalk_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fautowalk_2fautowalk_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fautowalk_2fautowalk_2eproto;
namespace bosdyn {
namespace api {
namespace autowalk {
class CompileAutowalkRequest;
struct CompileAutowalkRequestDefaultTypeInternal;
extern CompileAutowalkRequestDefaultTypeInternal _CompileAutowalkRequest_default_instance_;
class CompileAutowalkResponse;
struct CompileAutowalkResponseDefaultTypeInternal;
extern CompileAutowalkResponseDefaultTypeInternal _CompileAutowalkResponse_default_instance_;
class CompileAutowalkResponse_FailedElementsEntry_DoNotUse;
struct CompileAutowalkResponse_FailedElementsEntry_DoNotUseDefaultTypeInternal;
extern CompileAutowalkResponse_FailedElementsEntry_DoNotUseDefaultTypeInternal _CompileAutowalkResponse_FailedElementsEntry_DoNotUse_default_instance_;
class ElementIdentifiers;
struct ElementIdentifiersDefaultTypeInternal;
extern ElementIdentifiersDefaultTypeInternal _ElementIdentifiers_default_instance_;
class FailedElement;
struct FailedElementDefaultTypeInternal;
extern FailedElementDefaultTypeInternal _FailedElement_default_instance_;
class LoadAutowalkRequest;
struct LoadAutowalkRequestDefaultTypeInternal;
extern LoadAutowalkRequestDefaultTypeInternal _LoadAutowalkRequest_default_instance_;
class LoadAutowalkResponse;
struct LoadAutowalkResponseDefaultTypeInternal;
extern LoadAutowalkResponseDefaultTypeInternal _LoadAutowalkResponse_default_instance_;
class LoadAutowalkResponse_FailedElementsEntry_DoNotUse;
struct LoadAutowalkResponse_FailedElementsEntry_DoNotUseDefaultTypeInternal;
extern LoadAutowalkResponse_FailedElementsEntry_DoNotUseDefaultTypeInternal _LoadAutowalkResponse_FailedElementsEntry_DoNotUse_default_instance_;
class NodeIdentifier;
struct NodeIdentifierDefaultTypeInternal;
extern NodeIdentifierDefaultTypeInternal _NodeIdentifier_default_instance_;
}  // namespace autowalk
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::autowalk::CompileAutowalkRequest* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::CompileAutowalkRequest>(Arena*);
template<> ::bosdyn::api::autowalk::CompileAutowalkResponse* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::CompileAutowalkResponse>(Arena*);
template<> ::bosdyn::api::autowalk::CompileAutowalkResponse_FailedElementsEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::CompileAutowalkResponse_FailedElementsEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::autowalk::ElementIdentifiers* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::ElementIdentifiers>(Arena*);
template<> ::bosdyn::api::autowalk::FailedElement* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::FailedElement>(Arena*);
template<> ::bosdyn::api::autowalk::LoadAutowalkRequest* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::LoadAutowalkRequest>(Arena*);
template<> ::bosdyn::api::autowalk::LoadAutowalkResponse* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::LoadAutowalkResponse>(Arena*);
template<> ::bosdyn::api::autowalk::LoadAutowalkResponse_FailedElementsEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::LoadAutowalkResponse_FailedElementsEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::autowalk::NodeIdentifier* Arena::CreateMaybeMessage<::bosdyn::api::autowalk::NodeIdentifier>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {
namespace autowalk {

enum CompileAutowalkResponse_Status : int {
  CompileAutowalkResponse_Status_STATUS_UNKNOWN = 0,
  CompileAutowalkResponse_Status_STATUS_OK = 1,
  CompileAutowalkResponse_Status_STATUS_COMPILE_ERROR = 2,
  CompileAutowalkResponse_Status_CompileAutowalkResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CompileAutowalkResponse_Status_CompileAutowalkResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CompileAutowalkResponse_Status_IsValid(int value);
constexpr CompileAutowalkResponse_Status CompileAutowalkResponse_Status_Status_MIN = CompileAutowalkResponse_Status_STATUS_UNKNOWN;
constexpr CompileAutowalkResponse_Status CompileAutowalkResponse_Status_Status_MAX = CompileAutowalkResponse_Status_STATUS_COMPILE_ERROR;
constexpr int CompileAutowalkResponse_Status_Status_ARRAYSIZE = CompileAutowalkResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompileAutowalkResponse_Status_descriptor();
template<typename T>
inline const std::string& CompileAutowalkResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompileAutowalkResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompileAutowalkResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompileAutowalkResponse_Status_descriptor(), enum_t_value);
}
inline bool CompileAutowalkResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompileAutowalkResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompileAutowalkResponse_Status>(
    CompileAutowalkResponse_Status_descriptor(), name, value);
}
enum LoadAutowalkResponse_Status : int {
  LoadAutowalkResponse_Status_STATUS_UNKNOWN = 0,
  LoadAutowalkResponse_Status_STATUS_OK = 1,
  LoadAutowalkResponse_Status_STATUS_COMPILE_ERROR = 2,
  LoadAutowalkResponse_Status_STATUS_VALIDATE_ERROR = 3,
  LoadAutowalkResponse_Status_LoadAutowalkResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LoadAutowalkResponse_Status_LoadAutowalkResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LoadAutowalkResponse_Status_IsValid(int value);
constexpr LoadAutowalkResponse_Status LoadAutowalkResponse_Status_Status_MIN = LoadAutowalkResponse_Status_STATUS_UNKNOWN;
constexpr LoadAutowalkResponse_Status LoadAutowalkResponse_Status_Status_MAX = LoadAutowalkResponse_Status_STATUS_VALIDATE_ERROR;
constexpr int LoadAutowalkResponse_Status_Status_ARRAYSIZE = LoadAutowalkResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoadAutowalkResponse_Status_descriptor();
template<typename T>
inline const std::string& LoadAutowalkResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoadAutowalkResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoadAutowalkResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoadAutowalkResponse_Status_descriptor(), enum_t_value);
}
inline bool LoadAutowalkResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoadAutowalkResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoadAutowalkResponse_Status>(
    LoadAutowalkResponse_Status_descriptor(), name, value);
}
// ===================================================================

class FailedElement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.FailedElement) */ {
 public:
  inline FailedElement() : FailedElement(nullptr) {}
  ~FailedElement() override;
  explicit PROTOBUF_CONSTEXPR FailedElement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FailedElement(const FailedElement& from);
  FailedElement(FailedElement&& from) noexcept
    : FailedElement() {
    *this = ::std::move(from);
  }

  inline FailedElement& operator=(const FailedElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline FailedElement& operator=(FailedElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FailedElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const FailedElement* internal_default_instance() {
    return reinterpret_cast<const FailedElement*>(
               &_FailedElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FailedElement& a, FailedElement& b) {
    a.Swap(&b);
  }
  inline void Swap(FailedElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FailedElement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FailedElement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FailedElement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FailedElement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FailedElement& from) {
    FailedElement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FailedElement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.FailedElement";
  }
  protected:
  explicit FailedElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorsFieldNumber = 1,
    kWarningsFieldNumber = 2,
  };
  // repeated string errors = 1;
  int errors_size() const;
  private:
  int _internal_errors_size() const;
  public:
  void clear_errors();
  const std::string& errors(int index) const;
  std::string* mutable_errors(int index);
  void set_errors(int index, const std::string& value);
  void set_errors(int index, std::string&& value);
  void set_errors(int index, const char* value);
  void set_errors(int index, const char* value, size_t size);
  std::string* add_errors();
  void add_errors(const std::string& value);
  void add_errors(std::string&& value);
  void add_errors(const char* value);
  void add_errors(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& errors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_errors();
  private:
  const std::string& _internal_errors(int index) const;
  std::string* _internal_add_errors();
  public:

  // repeated string warnings = 2;
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;
  public:
  void clear_warnings();
  const std::string& warnings(int index) const;
  std::string* mutable_warnings(int index);
  void set_warnings(int index, const std::string& value);
  void set_warnings(int index, std::string&& value);
  void set_warnings(int index, const char* value);
  void set_warnings(int index, const char* value, size_t size);
  std::string* add_warnings();
  void add_warnings(const std::string& value);
  void add_warnings(std::string&& value);
  void add_warnings(const char* value);
  void add_warnings(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& warnings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_warnings();
  private:
  const std::string& _internal_warnings(int index) const;
  std::string* _internal_add_warnings();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.FailedElement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> errors_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> warnings_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fautowalk_2eproto;
};
// -------------------------------------------------------------------

class NodeIdentifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.NodeIdentifier) */ {
 public:
  inline NodeIdentifier() : NodeIdentifier(nullptr) {}
  ~NodeIdentifier() override;
  explicit PROTOBUF_CONSTEXPR NodeIdentifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeIdentifier(const NodeIdentifier& from);
  NodeIdentifier(NodeIdentifier&& from) noexcept
    : NodeIdentifier() {
    *this = ::std::move(from);
  }

  inline NodeIdentifier& operator=(const NodeIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeIdentifier& operator=(NodeIdentifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeIdentifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeIdentifier* internal_default_instance() {
    return reinterpret_cast<const NodeIdentifier*>(
               &_NodeIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NodeIdentifier& a, NodeIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeIdentifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeIdentifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeIdentifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeIdentifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeIdentifier& from) {
    NodeIdentifier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeIdentifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.NodeIdentifier";
  }
  protected:
  explicit NodeIdentifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserDataIdFieldNumber = 2,
    kNodeIdFieldNumber = 1,
  };
  // string user_data_id = 2;
  void clear_user_data_id();
  const std::string& user_data_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_data_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_data_id();
  PROTOBUF_NODISCARD std::string* release_user_data_id();
  void set_allocated_user_data_id(std::string* user_data_id);
  private:
  const std::string& _internal_user_data_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_data_id(const std::string& value);
  std::string* _internal_mutable_user_data_id();
  public:

  // int64 node_id = 1;
  void clear_node_id();
  int64_t node_id() const;
  void set_node_id(int64_t value);
  private:
  int64_t _internal_node_id() const;
  void _internal_set_node_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.NodeIdentifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_data_id_;
    int64_t node_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fautowalk_2eproto;
};
// -------------------------------------------------------------------

class ElementIdentifiers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.ElementIdentifiers) */ {
 public:
  inline ElementIdentifiers() : ElementIdentifiers(nullptr) {}
  ~ElementIdentifiers() override;
  explicit PROTOBUF_CONSTEXPR ElementIdentifiers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ElementIdentifiers(const ElementIdentifiers& from);
  ElementIdentifiers(ElementIdentifiers&& from) noexcept
    : ElementIdentifiers() {
    *this = ::std::move(from);
  }

  inline ElementIdentifiers& operator=(const ElementIdentifiers& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElementIdentifiers& operator=(ElementIdentifiers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ElementIdentifiers& default_instance() {
    return *internal_default_instance();
  }
  static inline const ElementIdentifiers* internal_default_instance() {
    return reinterpret_cast<const ElementIdentifiers*>(
               &_ElementIdentifiers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ElementIdentifiers& a, ElementIdentifiers& b) {
    a.Swap(&b);
  }
  inline void Swap(ElementIdentifiers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElementIdentifiers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ElementIdentifiers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ElementIdentifiers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ElementIdentifiers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ElementIdentifiers& from) {
    ElementIdentifiers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ElementIdentifiers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.ElementIdentifiers";
  }
  protected:
  explicit ElementIdentifiers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRootIdFieldNumber = 1,
    kActionIdFieldNumber = 2,
  };
  // .bosdyn.api.autowalk.NodeIdentifier root_id = 1;
  bool has_root_id() const;
  private:
  bool _internal_has_root_id() const;
  public:
  void clear_root_id();
  const ::bosdyn::api::autowalk::NodeIdentifier& root_id() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::NodeIdentifier* release_root_id();
  ::bosdyn::api::autowalk::NodeIdentifier* mutable_root_id();
  void set_allocated_root_id(::bosdyn::api::autowalk::NodeIdentifier* root_id);
  private:
  const ::bosdyn::api::autowalk::NodeIdentifier& _internal_root_id() const;
  ::bosdyn::api::autowalk::NodeIdentifier* _internal_mutable_root_id();
  public:
  void unsafe_arena_set_allocated_root_id(
      ::bosdyn::api::autowalk::NodeIdentifier* root_id);
  ::bosdyn::api::autowalk::NodeIdentifier* unsafe_arena_release_root_id();

  // .bosdyn.api.autowalk.NodeIdentifier action_id = 2;
  bool has_action_id() const;
  private:
  bool _internal_has_action_id() const;
  public:
  void clear_action_id();
  const ::bosdyn::api::autowalk::NodeIdentifier& action_id() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::NodeIdentifier* release_action_id();
  ::bosdyn::api::autowalk::NodeIdentifier* mutable_action_id();
  void set_allocated_action_id(::bosdyn::api::autowalk::NodeIdentifier* action_id);
  private:
  const ::bosdyn::api::autowalk::NodeIdentifier& _internal_action_id() const;
  ::bosdyn::api::autowalk::NodeIdentifier* _internal_mutable_action_id();
  public:
  void unsafe_arena_set_allocated_action_id(
      ::bosdyn::api::autowalk::NodeIdentifier* action_id);
  ::bosdyn::api::autowalk::NodeIdentifier* unsafe_arena_release_action_id();

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.ElementIdentifiers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::autowalk::NodeIdentifier* root_id_;
    ::bosdyn::api::autowalk::NodeIdentifier* action_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fautowalk_2eproto;
};
// -------------------------------------------------------------------

class CompileAutowalkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.CompileAutowalkRequest) */ {
 public:
  inline CompileAutowalkRequest() : CompileAutowalkRequest(nullptr) {}
  ~CompileAutowalkRequest() override;
  explicit PROTOBUF_CONSTEXPR CompileAutowalkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompileAutowalkRequest(const CompileAutowalkRequest& from);
  CompileAutowalkRequest(CompileAutowalkRequest&& from) noexcept
    : CompileAutowalkRequest() {
    *this = ::std::move(from);
  }

  inline CompileAutowalkRequest& operator=(const CompileAutowalkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompileAutowalkRequest& operator=(CompileAutowalkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompileAutowalkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompileAutowalkRequest* internal_default_instance() {
    return reinterpret_cast<const CompileAutowalkRequest*>(
               &_CompileAutowalkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CompileAutowalkRequest& a, CompileAutowalkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CompileAutowalkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompileAutowalkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompileAutowalkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompileAutowalkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompileAutowalkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompileAutowalkRequest& from) {
    CompileAutowalkRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompileAutowalkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.CompileAutowalkRequest";
  }
  protected:
  explicit CompileAutowalkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kWalkFieldNumber = 2,
    kTreatWarningsAsErrorsFieldNumber = 5,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.autowalk.Walk walk = 2;
  bool has_walk() const;
  private:
  bool _internal_has_walk() const;
  public:
  void clear_walk();
  const ::bosdyn::api::autowalk::Walk& walk() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::Walk* release_walk();
  ::bosdyn::api::autowalk::Walk* mutable_walk();
  void set_allocated_walk(::bosdyn::api::autowalk::Walk* walk);
  private:
  const ::bosdyn::api::autowalk::Walk& _internal_walk() const;
  ::bosdyn::api::autowalk::Walk* _internal_mutable_walk();
  public:
  void unsafe_arena_set_allocated_walk(
      ::bosdyn::api::autowalk::Walk* walk);
  ::bosdyn::api::autowalk::Walk* unsafe_arena_release_walk();

  // bool treat_warnings_as_errors = 5;
  void clear_treat_warnings_as_errors();
  bool treat_warnings_as_errors() const;
  void set_treat_warnings_as_errors(bool value);
  private:
  bool _internal_treat_warnings_as_errors() const;
  void _internal_set_treat_warnings_as_errors(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.CompileAutowalkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::autowalk::Walk* walk_;
    bool treat_warnings_as_errors_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fautowalk_2eproto;
};
// -------------------------------------------------------------------

class CompileAutowalkResponse_FailedElementsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CompileAutowalkResponse_FailedElementsEntry_DoNotUse, 
    int32_t, ::bosdyn::api::autowalk::FailedElement,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CompileAutowalkResponse_FailedElementsEntry_DoNotUse, 
    int32_t, ::bosdyn::api::autowalk::FailedElement,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  CompileAutowalkResponse_FailedElementsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CompileAutowalkResponse_FailedElementsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CompileAutowalkResponse_FailedElementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CompileAutowalkResponse_FailedElementsEntry_DoNotUse& other);
  static const CompileAutowalkResponse_FailedElementsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CompileAutowalkResponse_FailedElementsEntry_DoNotUse*>(&_CompileAutowalkResponse_FailedElementsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fautowalk_2eproto;
};

// -------------------------------------------------------------------

class CompileAutowalkResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.CompileAutowalkResponse) */ {
 public:
  inline CompileAutowalkResponse() : CompileAutowalkResponse(nullptr) {}
  ~CompileAutowalkResponse() override;
  explicit PROTOBUF_CONSTEXPR CompileAutowalkResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompileAutowalkResponse(const CompileAutowalkResponse& from);
  CompileAutowalkResponse(CompileAutowalkResponse&& from) noexcept
    : CompileAutowalkResponse() {
    *this = ::std::move(from);
  }

  inline CompileAutowalkResponse& operator=(const CompileAutowalkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompileAutowalkResponse& operator=(CompileAutowalkResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompileAutowalkResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompileAutowalkResponse* internal_default_instance() {
    return reinterpret_cast<const CompileAutowalkResponse*>(
               &_CompileAutowalkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CompileAutowalkResponse& a, CompileAutowalkResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CompileAutowalkResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompileAutowalkResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompileAutowalkResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompileAutowalkResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompileAutowalkResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompileAutowalkResponse& from) {
    CompileAutowalkResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompileAutowalkResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.CompileAutowalkResponse";
  }
  protected:
  explicit CompileAutowalkResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef CompileAutowalkResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    CompileAutowalkResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    CompileAutowalkResponse_Status_STATUS_OK;
  static constexpr Status STATUS_COMPILE_ERROR =
    CompileAutowalkResponse_Status_STATUS_COMPILE_ERROR;
  static inline bool Status_IsValid(int value) {
    return CompileAutowalkResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    CompileAutowalkResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    CompileAutowalkResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    CompileAutowalkResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return CompileAutowalkResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return CompileAutowalkResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return CompileAutowalkResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kElementIdentifiersFieldNumber = 5,
    kFailedElementsFieldNumber = 6,
    kHeaderFieldNumber = 1,
    kRootFieldNumber = 4,
    kDockingNodeFieldNumber = 7,
    kLoopNodeFieldNumber = 8,
    kStatusFieldNumber = 2,
  };
  // repeated .bosdyn.api.autowalk.ElementIdentifiers element_identifiers = 5;
  int element_identifiers_size() const;
  private:
  int _internal_element_identifiers_size() const;
  public:
  void clear_element_identifiers();
  ::bosdyn::api::autowalk::ElementIdentifiers* mutable_element_identifiers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::ElementIdentifiers >*
      mutable_element_identifiers();
  private:
  const ::bosdyn::api::autowalk::ElementIdentifiers& _internal_element_identifiers(int index) const;
  ::bosdyn::api::autowalk::ElementIdentifiers* _internal_add_element_identifiers();
  public:
  const ::bosdyn::api::autowalk::ElementIdentifiers& element_identifiers(int index) const;
  ::bosdyn::api::autowalk::ElementIdentifiers* add_element_identifiers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::ElementIdentifiers >&
      element_identifiers() const;

  // map<int32, .bosdyn.api.autowalk.FailedElement> failed_elements = 6;
  int failed_elements_size() const;
  private:
  int _internal_failed_elements_size() const;
  public:
  void clear_failed_elements();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::autowalk::FailedElement >&
      _internal_failed_elements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::autowalk::FailedElement >*
      _internal_mutable_failed_elements();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::autowalk::FailedElement >&
      failed_elements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::autowalk::FailedElement >*
      mutable_failed_elements();

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.mission.Node root = 4;
  bool has_root() const;
  private:
  bool _internal_has_root() const;
  public:
  void clear_root();
  const ::bosdyn::api::mission::Node& root() const;
  PROTOBUF_NODISCARD ::bosdyn::api::mission::Node* release_root();
  ::bosdyn::api::mission::Node* mutable_root();
  void set_allocated_root(::bosdyn::api::mission::Node* root);
  private:
  const ::bosdyn::api::mission::Node& _internal_root() const;
  ::bosdyn::api::mission::Node* _internal_mutable_root();
  public:
  void unsafe_arena_set_allocated_root(
      ::bosdyn::api::mission::Node* root);
  ::bosdyn::api::mission::Node* unsafe_arena_release_root();

  // .bosdyn.api.autowalk.NodeIdentifier docking_node = 7;
  bool has_docking_node() const;
  private:
  bool _internal_has_docking_node() const;
  public:
  void clear_docking_node();
  const ::bosdyn::api::autowalk::NodeIdentifier& docking_node() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::NodeIdentifier* release_docking_node();
  ::bosdyn::api::autowalk::NodeIdentifier* mutable_docking_node();
  void set_allocated_docking_node(::bosdyn::api::autowalk::NodeIdentifier* docking_node);
  private:
  const ::bosdyn::api::autowalk::NodeIdentifier& _internal_docking_node() const;
  ::bosdyn::api::autowalk::NodeIdentifier* _internal_mutable_docking_node();
  public:
  void unsafe_arena_set_allocated_docking_node(
      ::bosdyn::api::autowalk::NodeIdentifier* docking_node);
  ::bosdyn::api::autowalk::NodeIdentifier* unsafe_arena_release_docking_node();

  // .bosdyn.api.autowalk.NodeIdentifier loop_node = 8;
  bool has_loop_node() const;
  private:
  bool _internal_has_loop_node() const;
  public:
  void clear_loop_node();
  const ::bosdyn::api::autowalk::NodeIdentifier& loop_node() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::NodeIdentifier* release_loop_node();
  ::bosdyn::api::autowalk::NodeIdentifier* mutable_loop_node();
  void set_allocated_loop_node(::bosdyn::api::autowalk::NodeIdentifier* loop_node);
  private:
  const ::bosdyn::api::autowalk::NodeIdentifier& _internal_loop_node() const;
  ::bosdyn::api::autowalk::NodeIdentifier* _internal_mutable_loop_node();
  public:
  void unsafe_arena_set_allocated_loop_node(
      ::bosdyn::api::autowalk::NodeIdentifier* loop_node);
  ::bosdyn::api::autowalk::NodeIdentifier* unsafe_arena_release_loop_node();

  // .bosdyn.api.autowalk.CompileAutowalkResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::autowalk::CompileAutowalkResponse_Status status() const;
  void set_status(::bosdyn::api::autowalk::CompileAutowalkResponse_Status value);
  private:
  ::bosdyn::api::autowalk::CompileAutowalkResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::autowalk::CompileAutowalkResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.CompileAutowalkResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::ElementIdentifiers > element_identifiers_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CompileAutowalkResponse_FailedElementsEntry_DoNotUse,
        int32_t, ::bosdyn::api::autowalk::FailedElement,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> failed_elements_;
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::mission::Node* root_;
    ::bosdyn::api::autowalk::NodeIdentifier* docking_node_;
    ::bosdyn::api::autowalk::NodeIdentifier* loop_node_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fautowalk_2eproto;
};
// -------------------------------------------------------------------

class LoadAutowalkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.LoadAutowalkRequest) */ {
 public:
  inline LoadAutowalkRequest() : LoadAutowalkRequest(nullptr) {}
  ~LoadAutowalkRequest() override;
  explicit PROTOBUF_CONSTEXPR LoadAutowalkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadAutowalkRequest(const LoadAutowalkRequest& from);
  LoadAutowalkRequest(LoadAutowalkRequest&& from) noexcept
    : LoadAutowalkRequest() {
    *this = ::std::move(from);
  }

  inline LoadAutowalkRequest& operator=(const LoadAutowalkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadAutowalkRequest& operator=(LoadAutowalkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadAutowalkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadAutowalkRequest* internal_default_instance() {
    return reinterpret_cast<const LoadAutowalkRequest*>(
               &_LoadAutowalkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoadAutowalkRequest& a, LoadAutowalkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadAutowalkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadAutowalkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadAutowalkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadAutowalkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadAutowalkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadAutowalkRequest& from) {
    LoadAutowalkRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadAutowalkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.LoadAutowalkRequest";
  }
  protected:
  explicit LoadAutowalkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeasesFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kWalkFieldNumber = 2,
    kTreatWarningsAsErrorsFieldNumber = 5,
  };
  // repeated .bosdyn.api.Lease leases = 3;
  int leases_size() const;
  private:
  int _internal_leases_size() const;
  public:
  void clear_leases();
  ::bosdyn::api::Lease* mutable_leases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
      mutable_leases();
  private:
  const ::bosdyn::api::Lease& _internal_leases(int index) const;
  ::bosdyn::api::Lease* _internal_add_leases();
  public:
  const ::bosdyn::api::Lease& leases(int index) const;
  ::bosdyn::api::Lease* add_leases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
      leases() const;

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.autowalk.Walk walk = 2;
  bool has_walk() const;
  private:
  bool _internal_has_walk() const;
  public:
  void clear_walk();
  const ::bosdyn::api::autowalk::Walk& walk() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::Walk* release_walk();
  ::bosdyn::api::autowalk::Walk* mutable_walk();
  void set_allocated_walk(::bosdyn::api::autowalk::Walk* walk);
  private:
  const ::bosdyn::api::autowalk::Walk& _internal_walk() const;
  ::bosdyn::api::autowalk::Walk* _internal_mutable_walk();
  public:
  void unsafe_arena_set_allocated_walk(
      ::bosdyn::api::autowalk::Walk* walk);
  ::bosdyn::api::autowalk::Walk* unsafe_arena_release_walk();

  // bool treat_warnings_as_errors = 5;
  void clear_treat_warnings_as_errors();
  bool treat_warnings_as_errors() const;
  void set_treat_warnings_as_errors(bool value);
  private:
  bool _internal_treat_warnings_as_errors() const;
  void _internal_set_treat_warnings_as_errors(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.LoadAutowalkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease > leases_;
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::autowalk::Walk* walk_;
    bool treat_warnings_as_errors_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fautowalk_2eproto;
};
// -------------------------------------------------------------------

class LoadAutowalkResponse_FailedElementsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadAutowalkResponse_FailedElementsEntry_DoNotUse, 
    int32_t, ::bosdyn::api::autowalk::FailedElement,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadAutowalkResponse_FailedElementsEntry_DoNotUse, 
    int32_t, ::bosdyn::api::autowalk::FailedElement,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LoadAutowalkResponse_FailedElementsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LoadAutowalkResponse_FailedElementsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LoadAutowalkResponse_FailedElementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadAutowalkResponse_FailedElementsEntry_DoNotUse& other);
  static const LoadAutowalkResponse_FailedElementsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadAutowalkResponse_FailedElementsEntry_DoNotUse*>(&_LoadAutowalkResponse_FailedElementsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fautowalk_2eproto;
};

// -------------------------------------------------------------------

class LoadAutowalkResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.autowalk.LoadAutowalkResponse) */ {
 public:
  inline LoadAutowalkResponse() : LoadAutowalkResponse(nullptr) {}
  ~LoadAutowalkResponse() override;
  explicit PROTOBUF_CONSTEXPR LoadAutowalkResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadAutowalkResponse(const LoadAutowalkResponse& from);
  LoadAutowalkResponse(LoadAutowalkResponse&& from) noexcept
    : LoadAutowalkResponse() {
    *this = ::std::move(from);
  }

  inline LoadAutowalkResponse& operator=(const LoadAutowalkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadAutowalkResponse& operator=(LoadAutowalkResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadAutowalkResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadAutowalkResponse* internal_default_instance() {
    return reinterpret_cast<const LoadAutowalkResponse*>(
               &_LoadAutowalkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LoadAutowalkResponse& a, LoadAutowalkResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadAutowalkResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadAutowalkResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadAutowalkResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadAutowalkResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadAutowalkResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadAutowalkResponse& from) {
    LoadAutowalkResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadAutowalkResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.autowalk.LoadAutowalkResponse";
  }
  protected:
  explicit LoadAutowalkResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef LoadAutowalkResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    LoadAutowalkResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    LoadAutowalkResponse_Status_STATUS_OK;
  static constexpr Status STATUS_COMPILE_ERROR =
    LoadAutowalkResponse_Status_STATUS_COMPILE_ERROR;
  static constexpr Status STATUS_VALIDATE_ERROR =
    LoadAutowalkResponse_Status_STATUS_VALIDATE_ERROR;
  static inline bool Status_IsValid(int value) {
    return LoadAutowalkResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    LoadAutowalkResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    LoadAutowalkResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    LoadAutowalkResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return LoadAutowalkResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return LoadAutowalkResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return LoadAutowalkResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeaseUseResultsFieldNumber = 3,
    kFailedNodesFieldNumber = 5,
    kElementIdentifiersFieldNumber = 7,
    kFailedElementsFieldNumber = 8,
    kHeaderFieldNumber = 1,
    kDockingNodeFieldNumber = 10,
    kLoopNodeFieldNumber = 11,
    kMissionIdFieldNumber = 9,
    kStatusFieldNumber = 2,
  };
  // repeated .bosdyn.api.LeaseUseResult lease_use_results = 3;
  int lease_use_results_size() const;
  private:
  int _internal_lease_use_results_size() const;
  public:
  void clear_lease_use_results();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
      mutable_lease_use_results();
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* _internal_add_lease_use_results();
  public:
  const ::bosdyn::api::LeaseUseResult& lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* add_lease_use_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
      lease_use_results() const;

  // repeated .bosdyn.api.mission.FailedNode failed_nodes = 5;
  int failed_nodes_size() const;
  private:
  int _internal_failed_nodes_size() const;
  public:
  void clear_failed_nodes();
  ::bosdyn::api::mission::FailedNode* mutable_failed_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::FailedNode >*
      mutable_failed_nodes();
  private:
  const ::bosdyn::api::mission::FailedNode& _internal_failed_nodes(int index) const;
  ::bosdyn::api::mission::FailedNode* _internal_add_failed_nodes();
  public:
  const ::bosdyn::api::mission::FailedNode& failed_nodes(int index) const;
  ::bosdyn::api::mission::FailedNode* add_failed_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::FailedNode >&
      failed_nodes() const;

  // repeated .bosdyn.api.autowalk.ElementIdentifiers element_identifiers = 7;
  int element_identifiers_size() const;
  private:
  int _internal_element_identifiers_size() const;
  public:
  void clear_element_identifiers();
  ::bosdyn::api::autowalk::ElementIdentifiers* mutable_element_identifiers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::ElementIdentifiers >*
      mutable_element_identifiers();
  private:
  const ::bosdyn::api::autowalk::ElementIdentifiers& _internal_element_identifiers(int index) const;
  ::bosdyn::api::autowalk::ElementIdentifiers* _internal_add_element_identifiers();
  public:
  const ::bosdyn::api::autowalk::ElementIdentifiers& element_identifiers(int index) const;
  ::bosdyn::api::autowalk::ElementIdentifiers* add_element_identifiers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::ElementIdentifiers >&
      element_identifiers() const;

  // map<int32, .bosdyn.api.autowalk.FailedElement> failed_elements = 8;
  int failed_elements_size() const;
  private:
  int _internal_failed_elements_size() const;
  public:
  void clear_failed_elements();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::autowalk::FailedElement >&
      _internal_failed_elements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::autowalk::FailedElement >*
      _internal_mutable_failed_elements();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::autowalk::FailedElement >&
      failed_elements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::autowalk::FailedElement >*
      mutable_failed_elements();

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.autowalk.NodeIdentifier docking_node = 10;
  bool has_docking_node() const;
  private:
  bool _internal_has_docking_node() const;
  public:
  void clear_docking_node();
  const ::bosdyn::api::autowalk::NodeIdentifier& docking_node() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::NodeIdentifier* release_docking_node();
  ::bosdyn::api::autowalk::NodeIdentifier* mutable_docking_node();
  void set_allocated_docking_node(::bosdyn::api::autowalk::NodeIdentifier* docking_node);
  private:
  const ::bosdyn::api::autowalk::NodeIdentifier& _internal_docking_node() const;
  ::bosdyn::api::autowalk::NodeIdentifier* _internal_mutable_docking_node();
  public:
  void unsafe_arena_set_allocated_docking_node(
      ::bosdyn::api::autowalk::NodeIdentifier* docking_node);
  ::bosdyn::api::autowalk::NodeIdentifier* unsafe_arena_release_docking_node();

  // .bosdyn.api.autowalk.NodeIdentifier loop_node = 11;
  bool has_loop_node() const;
  private:
  bool _internal_has_loop_node() const;
  public:
  void clear_loop_node();
  const ::bosdyn::api::autowalk::NodeIdentifier& loop_node() const;
  PROTOBUF_NODISCARD ::bosdyn::api::autowalk::NodeIdentifier* release_loop_node();
  ::bosdyn::api::autowalk::NodeIdentifier* mutable_loop_node();
  void set_allocated_loop_node(::bosdyn::api::autowalk::NodeIdentifier* loop_node);
  private:
  const ::bosdyn::api::autowalk::NodeIdentifier& _internal_loop_node() const;
  ::bosdyn::api::autowalk::NodeIdentifier* _internal_mutable_loop_node();
  public:
  void unsafe_arena_set_allocated_loop_node(
      ::bosdyn::api::autowalk::NodeIdentifier* loop_node);
  ::bosdyn::api::autowalk::NodeIdentifier* unsafe_arena_release_loop_node();

  // int64 mission_id = 9;
  void clear_mission_id();
  int64_t mission_id() const;
  void set_mission_id(int64_t value);
  private:
  int64_t _internal_mission_id() const;
  void _internal_set_mission_id(int64_t value);
  public:

  // .bosdyn.api.autowalk.LoadAutowalkResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::autowalk::LoadAutowalkResponse_Status status() const;
  void set_status(::bosdyn::api::autowalk::LoadAutowalkResponse_Status value);
  private:
  ::bosdyn::api::autowalk::LoadAutowalkResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::autowalk::LoadAutowalkResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.autowalk.LoadAutowalkResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult > lease_use_results_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::FailedNode > failed_nodes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::ElementIdentifiers > element_identifiers_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LoadAutowalkResponse_FailedElementsEntry_DoNotUse,
        int32_t, ::bosdyn::api::autowalk::FailedElement,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> failed_elements_;
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::autowalk::NodeIdentifier* docking_node_;
    ::bosdyn::api::autowalk::NodeIdentifier* loop_node_;
    int64_t mission_id_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fautowalk_2fautowalk_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FailedElement

// repeated string errors = 1;
inline int FailedElement::_internal_errors_size() const {
  return _impl_.errors_.size();
}
inline int FailedElement::errors_size() const {
  return _internal_errors_size();
}
inline void FailedElement::clear_errors() {
  _impl_.errors_.Clear();
}
inline std::string* FailedElement::add_errors() {
  std::string* _s = _internal_add_errors();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.autowalk.FailedElement.errors)
  return _s;
}
inline const std::string& FailedElement::_internal_errors(int index) const {
  return _impl_.errors_.Get(index);
}
inline const std::string& FailedElement::errors(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.FailedElement.errors)
  return _internal_errors(index);
}
inline std::string* FailedElement::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.FailedElement.errors)
  return _impl_.errors_.Mutable(index);
}
inline void FailedElement::set_errors(int index, const std::string& value) {
  _impl_.errors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.FailedElement.errors)
}
inline void FailedElement::set_errors(int index, std::string&& value) {
  _impl_.errors_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.FailedElement.errors)
}
inline void FailedElement::set_errors(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.errors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.autowalk.FailedElement.errors)
}
inline void FailedElement::set_errors(int index, const char* value, size_t size) {
  _impl_.errors_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.autowalk.FailedElement.errors)
}
inline std::string* FailedElement::_internal_add_errors() {
  return _impl_.errors_.Add();
}
inline void FailedElement::add_errors(const std::string& value) {
  _impl_.errors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.autowalk.FailedElement.errors)
}
inline void FailedElement::add_errors(std::string&& value) {
  _impl_.errors_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.autowalk.FailedElement.errors)
}
inline void FailedElement::add_errors(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.errors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.autowalk.FailedElement.errors)
}
inline void FailedElement::add_errors(const char* value, size_t size) {
  _impl_.errors_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.autowalk.FailedElement.errors)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FailedElement::errors() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.autowalk.FailedElement.errors)
  return _impl_.errors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FailedElement::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.autowalk.FailedElement.errors)
  return &_impl_.errors_;
}

// repeated string warnings = 2;
inline int FailedElement::_internal_warnings_size() const {
  return _impl_.warnings_.size();
}
inline int FailedElement::warnings_size() const {
  return _internal_warnings_size();
}
inline void FailedElement::clear_warnings() {
  _impl_.warnings_.Clear();
}
inline std::string* FailedElement::add_warnings() {
  std::string* _s = _internal_add_warnings();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.autowalk.FailedElement.warnings)
  return _s;
}
inline const std::string& FailedElement::_internal_warnings(int index) const {
  return _impl_.warnings_.Get(index);
}
inline const std::string& FailedElement::warnings(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.FailedElement.warnings)
  return _internal_warnings(index);
}
inline std::string* FailedElement::mutable_warnings(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.FailedElement.warnings)
  return _impl_.warnings_.Mutable(index);
}
inline void FailedElement::set_warnings(int index, const std::string& value) {
  _impl_.warnings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.FailedElement.warnings)
}
inline void FailedElement::set_warnings(int index, std::string&& value) {
  _impl_.warnings_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.FailedElement.warnings)
}
inline void FailedElement::set_warnings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.warnings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.autowalk.FailedElement.warnings)
}
inline void FailedElement::set_warnings(int index, const char* value, size_t size) {
  _impl_.warnings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.autowalk.FailedElement.warnings)
}
inline std::string* FailedElement::_internal_add_warnings() {
  return _impl_.warnings_.Add();
}
inline void FailedElement::add_warnings(const std::string& value) {
  _impl_.warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.autowalk.FailedElement.warnings)
}
inline void FailedElement::add_warnings(std::string&& value) {
  _impl_.warnings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.autowalk.FailedElement.warnings)
}
inline void FailedElement::add_warnings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.autowalk.FailedElement.warnings)
}
inline void FailedElement::add_warnings(const char* value, size_t size) {
  _impl_.warnings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.autowalk.FailedElement.warnings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FailedElement::warnings() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.autowalk.FailedElement.warnings)
  return _impl_.warnings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FailedElement::mutable_warnings() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.autowalk.FailedElement.warnings)
  return &_impl_.warnings_;
}

// -------------------------------------------------------------------

// NodeIdentifier

// int64 node_id = 1;
inline void NodeIdentifier::clear_node_id() {
  _impl_.node_id_ = int64_t{0};
}
inline int64_t NodeIdentifier::_internal_node_id() const {
  return _impl_.node_id_;
}
inline int64_t NodeIdentifier::node_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.NodeIdentifier.node_id)
  return _internal_node_id();
}
inline void NodeIdentifier::_internal_set_node_id(int64_t value) {
  
  _impl_.node_id_ = value;
}
inline void NodeIdentifier::set_node_id(int64_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.NodeIdentifier.node_id)
}

// string user_data_id = 2;
inline void NodeIdentifier::clear_user_data_id() {
  _impl_.user_data_id_.ClearToEmpty();
}
inline const std::string& NodeIdentifier::user_data_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.NodeIdentifier.user_data_id)
  return _internal_user_data_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeIdentifier::set_user_data_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_data_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.NodeIdentifier.user_data_id)
}
inline std::string* NodeIdentifier::mutable_user_data_id() {
  std::string* _s = _internal_mutable_user_data_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.NodeIdentifier.user_data_id)
  return _s;
}
inline const std::string& NodeIdentifier::_internal_user_data_id() const {
  return _impl_.user_data_id_.Get();
}
inline void NodeIdentifier::_internal_set_user_data_id(const std::string& value) {
  
  _impl_.user_data_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeIdentifier::_internal_mutable_user_data_id() {
  
  return _impl_.user_data_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeIdentifier::release_user_data_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.NodeIdentifier.user_data_id)
  return _impl_.user_data_id_.Release();
}
inline void NodeIdentifier::set_allocated_user_data_id(std::string* user_data_id) {
  if (user_data_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_data_id_.SetAllocated(user_data_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_data_id_.IsDefault()) {
    _impl_.user_data_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.NodeIdentifier.user_data_id)
}

// -------------------------------------------------------------------

// ElementIdentifiers

// .bosdyn.api.autowalk.NodeIdentifier root_id = 1;
inline bool ElementIdentifiers::_internal_has_root_id() const {
  return this != internal_default_instance() && _impl_.root_id_ != nullptr;
}
inline bool ElementIdentifiers::has_root_id() const {
  return _internal_has_root_id();
}
inline void ElementIdentifiers::clear_root_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.root_id_ != nullptr) {
    delete _impl_.root_id_;
  }
  _impl_.root_id_ = nullptr;
}
inline const ::bosdyn::api::autowalk::NodeIdentifier& ElementIdentifiers::_internal_root_id() const {
  const ::bosdyn::api::autowalk::NodeIdentifier* p = _impl_.root_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::NodeIdentifier&>(
      ::bosdyn::api::autowalk::_NodeIdentifier_default_instance_);
}
inline const ::bosdyn::api::autowalk::NodeIdentifier& ElementIdentifiers::root_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ElementIdentifiers.root_id)
  return _internal_root_id();
}
inline void ElementIdentifiers::unsafe_arena_set_allocated_root_id(
    ::bosdyn::api::autowalk::NodeIdentifier* root_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.root_id_);
  }
  _impl_.root_id_ = root_id;
  if (root_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ElementIdentifiers.root_id)
}
inline ::bosdyn::api::autowalk::NodeIdentifier* ElementIdentifiers::release_root_id() {
  
  ::bosdyn::api::autowalk::NodeIdentifier* temp = _impl_.root_id_;
  _impl_.root_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* ElementIdentifiers::unsafe_arena_release_root_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ElementIdentifiers.root_id)
  
  ::bosdyn::api::autowalk::NodeIdentifier* temp = _impl_.root_id_;
  _impl_.root_id_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* ElementIdentifiers::_internal_mutable_root_id() {
  
  if (_impl_.root_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::NodeIdentifier>(GetArenaForAllocation());
    _impl_.root_id_ = p;
  }
  return _impl_.root_id_;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* ElementIdentifiers::mutable_root_id() {
  ::bosdyn::api::autowalk::NodeIdentifier* _msg = _internal_mutable_root_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ElementIdentifiers.root_id)
  return _msg;
}
inline void ElementIdentifiers::set_allocated_root_id(::bosdyn::api::autowalk::NodeIdentifier* root_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.root_id_;
  }
  if (root_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(root_id);
    if (message_arena != submessage_arena) {
      root_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.root_id_ = root_id;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ElementIdentifiers.root_id)
}

// .bosdyn.api.autowalk.NodeIdentifier action_id = 2;
inline bool ElementIdentifiers::_internal_has_action_id() const {
  return this != internal_default_instance() && _impl_.action_id_ != nullptr;
}
inline bool ElementIdentifiers::has_action_id() const {
  return _internal_has_action_id();
}
inline void ElementIdentifiers::clear_action_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.action_id_ != nullptr) {
    delete _impl_.action_id_;
  }
  _impl_.action_id_ = nullptr;
}
inline const ::bosdyn::api::autowalk::NodeIdentifier& ElementIdentifiers::_internal_action_id() const {
  const ::bosdyn::api::autowalk::NodeIdentifier* p = _impl_.action_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::NodeIdentifier&>(
      ::bosdyn::api::autowalk::_NodeIdentifier_default_instance_);
}
inline const ::bosdyn::api::autowalk::NodeIdentifier& ElementIdentifiers::action_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.ElementIdentifiers.action_id)
  return _internal_action_id();
}
inline void ElementIdentifiers::unsafe_arena_set_allocated_action_id(
    ::bosdyn::api::autowalk::NodeIdentifier* action_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.action_id_);
  }
  _impl_.action_id_ = action_id;
  if (action_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.ElementIdentifiers.action_id)
}
inline ::bosdyn::api::autowalk::NodeIdentifier* ElementIdentifiers::release_action_id() {
  
  ::bosdyn::api::autowalk::NodeIdentifier* temp = _impl_.action_id_;
  _impl_.action_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* ElementIdentifiers::unsafe_arena_release_action_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.ElementIdentifiers.action_id)
  
  ::bosdyn::api::autowalk::NodeIdentifier* temp = _impl_.action_id_;
  _impl_.action_id_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* ElementIdentifiers::_internal_mutable_action_id() {
  
  if (_impl_.action_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::NodeIdentifier>(GetArenaForAllocation());
    _impl_.action_id_ = p;
  }
  return _impl_.action_id_;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* ElementIdentifiers::mutable_action_id() {
  ::bosdyn::api::autowalk::NodeIdentifier* _msg = _internal_mutable_action_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.ElementIdentifiers.action_id)
  return _msg;
}
inline void ElementIdentifiers::set_allocated_action_id(::bosdyn::api::autowalk::NodeIdentifier* action_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.action_id_;
  }
  if (action_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(action_id);
    if (message_arena != submessage_arena) {
      action_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.action_id_ = action_id;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.ElementIdentifiers.action_id)
}

// -------------------------------------------------------------------

// CompileAutowalkRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool CompileAutowalkRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool CompileAutowalkRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& CompileAutowalkRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& CompileAutowalkRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.CompileAutowalkRequest.header)
  return _internal_header();
}
inline void CompileAutowalkRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.CompileAutowalkRequest.header)
}
inline ::bosdyn::api::RequestHeader* CompileAutowalkRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* CompileAutowalkRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.CompileAutowalkRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* CompileAutowalkRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* CompileAutowalkRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.CompileAutowalkRequest.header)
  return _msg;
}
inline void CompileAutowalkRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.CompileAutowalkRequest.header)
}

// .bosdyn.api.autowalk.Walk walk = 2;
inline bool CompileAutowalkRequest::_internal_has_walk() const {
  return this != internal_default_instance() && _impl_.walk_ != nullptr;
}
inline bool CompileAutowalkRequest::has_walk() const {
  return _internal_has_walk();
}
inline const ::bosdyn::api::autowalk::Walk& CompileAutowalkRequest::_internal_walk() const {
  const ::bosdyn::api::autowalk::Walk* p = _impl_.walk_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::Walk&>(
      ::bosdyn::api::autowalk::_Walk_default_instance_);
}
inline const ::bosdyn::api::autowalk::Walk& CompileAutowalkRequest::walk() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.CompileAutowalkRequest.walk)
  return _internal_walk();
}
inline void CompileAutowalkRequest::unsafe_arena_set_allocated_walk(
    ::bosdyn::api::autowalk::Walk* walk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.walk_);
  }
  _impl_.walk_ = walk;
  if (walk) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.CompileAutowalkRequest.walk)
}
inline ::bosdyn::api::autowalk::Walk* CompileAutowalkRequest::release_walk() {
  
  ::bosdyn::api::autowalk::Walk* temp = _impl_.walk_;
  _impl_.walk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::Walk* CompileAutowalkRequest::unsafe_arena_release_walk() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.CompileAutowalkRequest.walk)
  
  ::bosdyn::api::autowalk::Walk* temp = _impl_.walk_;
  _impl_.walk_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::Walk* CompileAutowalkRequest::_internal_mutable_walk() {
  
  if (_impl_.walk_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::Walk>(GetArenaForAllocation());
    _impl_.walk_ = p;
  }
  return _impl_.walk_;
}
inline ::bosdyn::api::autowalk::Walk* CompileAutowalkRequest::mutable_walk() {
  ::bosdyn::api::autowalk::Walk* _msg = _internal_mutable_walk();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.CompileAutowalkRequest.walk)
  return _msg;
}
inline void CompileAutowalkRequest::set_allocated_walk(::bosdyn::api::autowalk::Walk* walk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.walk_);
  }
  if (walk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(walk));
    if (message_arena != submessage_arena) {
      walk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, walk, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.walk_ = walk;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.CompileAutowalkRequest.walk)
}

// bool treat_warnings_as_errors = 5;
inline void CompileAutowalkRequest::clear_treat_warnings_as_errors() {
  _impl_.treat_warnings_as_errors_ = false;
}
inline bool CompileAutowalkRequest::_internal_treat_warnings_as_errors() const {
  return _impl_.treat_warnings_as_errors_;
}
inline bool CompileAutowalkRequest::treat_warnings_as_errors() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.CompileAutowalkRequest.treat_warnings_as_errors)
  return _internal_treat_warnings_as_errors();
}
inline void CompileAutowalkRequest::_internal_set_treat_warnings_as_errors(bool value) {
  
  _impl_.treat_warnings_as_errors_ = value;
}
inline void CompileAutowalkRequest::set_treat_warnings_as_errors(bool value) {
  _internal_set_treat_warnings_as_errors(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.CompileAutowalkRequest.treat_warnings_as_errors)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CompileAutowalkResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool CompileAutowalkResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool CompileAutowalkResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& CompileAutowalkResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& CompileAutowalkResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.CompileAutowalkResponse.header)
  return _internal_header();
}
inline void CompileAutowalkResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.CompileAutowalkResponse.header)
}
inline ::bosdyn::api::ResponseHeader* CompileAutowalkResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* CompileAutowalkResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.CompileAutowalkResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* CompileAutowalkResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* CompileAutowalkResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.CompileAutowalkResponse.header)
  return _msg;
}
inline void CompileAutowalkResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.CompileAutowalkResponse.header)
}

// .bosdyn.api.autowalk.CompileAutowalkResponse.Status status = 2;
inline void CompileAutowalkResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::autowalk::CompileAutowalkResponse_Status CompileAutowalkResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::autowalk::CompileAutowalkResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::autowalk::CompileAutowalkResponse_Status CompileAutowalkResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.CompileAutowalkResponse.status)
  return _internal_status();
}
inline void CompileAutowalkResponse::_internal_set_status(::bosdyn::api::autowalk::CompileAutowalkResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void CompileAutowalkResponse::set_status(::bosdyn::api::autowalk::CompileAutowalkResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.CompileAutowalkResponse.status)
}

// .bosdyn.api.mission.Node root = 4;
inline bool CompileAutowalkResponse::_internal_has_root() const {
  return this != internal_default_instance() && _impl_.root_ != nullptr;
}
inline bool CompileAutowalkResponse::has_root() const {
  return _internal_has_root();
}
inline const ::bosdyn::api::mission::Node& CompileAutowalkResponse::_internal_root() const {
  const ::bosdyn::api::mission::Node* p = _impl_.root_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::mission::Node&>(
      ::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& CompileAutowalkResponse::root() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.CompileAutowalkResponse.root)
  return _internal_root();
}
inline void CompileAutowalkResponse::unsafe_arena_set_allocated_root(
    ::bosdyn::api::mission::Node* root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.root_);
  }
  _impl_.root_ = root;
  if (root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.CompileAutowalkResponse.root)
}
inline ::bosdyn::api::mission::Node* CompileAutowalkResponse::release_root() {
  
  ::bosdyn::api::mission::Node* temp = _impl_.root_;
  _impl_.root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::mission::Node* CompileAutowalkResponse::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.CompileAutowalkResponse.root)
  
  ::bosdyn::api::mission::Node* temp = _impl_.root_;
  _impl_.root_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* CompileAutowalkResponse::_internal_mutable_root() {
  
  if (_impl_.root_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArenaForAllocation());
    _impl_.root_ = p;
  }
  return _impl_.root_;
}
inline ::bosdyn::api::mission::Node* CompileAutowalkResponse::mutable_root() {
  ::bosdyn::api::mission::Node* _msg = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.CompileAutowalkResponse.root)
  return _msg;
}
inline void CompileAutowalkResponse::set_allocated_root(::bosdyn::api::mission::Node* root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.root_);
  }
  if (root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(root));
    if (message_arena != submessage_arena) {
      root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.root_ = root;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.CompileAutowalkResponse.root)
}

// repeated .bosdyn.api.autowalk.ElementIdentifiers element_identifiers = 5;
inline int CompileAutowalkResponse::_internal_element_identifiers_size() const {
  return _impl_.element_identifiers_.size();
}
inline int CompileAutowalkResponse::element_identifiers_size() const {
  return _internal_element_identifiers_size();
}
inline void CompileAutowalkResponse::clear_element_identifiers() {
  _impl_.element_identifiers_.Clear();
}
inline ::bosdyn::api::autowalk::ElementIdentifiers* CompileAutowalkResponse::mutable_element_identifiers(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.CompileAutowalkResponse.element_identifiers)
  return _impl_.element_identifiers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::ElementIdentifiers >*
CompileAutowalkResponse::mutable_element_identifiers() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.autowalk.CompileAutowalkResponse.element_identifiers)
  return &_impl_.element_identifiers_;
}
inline const ::bosdyn::api::autowalk::ElementIdentifiers& CompileAutowalkResponse::_internal_element_identifiers(int index) const {
  return _impl_.element_identifiers_.Get(index);
}
inline const ::bosdyn::api::autowalk::ElementIdentifiers& CompileAutowalkResponse::element_identifiers(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.CompileAutowalkResponse.element_identifiers)
  return _internal_element_identifiers(index);
}
inline ::bosdyn::api::autowalk::ElementIdentifiers* CompileAutowalkResponse::_internal_add_element_identifiers() {
  return _impl_.element_identifiers_.Add();
}
inline ::bosdyn::api::autowalk::ElementIdentifiers* CompileAutowalkResponse::add_element_identifiers() {
  ::bosdyn::api::autowalk::ElementIdentifiers* _add = _internal_add_element_identifiers();
  // @@protoc_insertion_point(field_add:bosdyn.api.autowalk.CompileAutowalkResponse.element_identifiers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::ElementIdentifiers >&
CompileAutowalkResponse::element_identifiers() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.autowalk.CompileAutowalkResponse.element_identifiers)
  return _impl_.element_identifiers_;
}

// map<int32, .bosdyn.api.autowalk.FailedElement> failed_elements = 6;
inline int CompileAutowalkResponse::_internal_failed_elements_size() const {
  return _impl_.failed_elements_.size();
}
inline int CompileAutowalkResponse::failed_elements_size() const {
  return _internal_failed_elements_size();
}
inline void CompileAutowalkResponse::clear_failed_elements() {
  _impl_.failed_elements_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::autowalk::FailedElement >&
CompileAutowalkResponse::_internal_failed_elements() const {
  return _impl_.failed_elements_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::autowalk::FailedElement >&
CompileAutowalkResponse::failed_elements() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.autowalk.CompileAutowalkResponse.failed_elements)
  return _internal_failed_elements();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::autowalk::FailedElement >*
CompileAutowalkResponse::_internal_mutable_failed_elements() {
  return _impl_.failed_elements_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::autowalk::FailedElement >*
CompileAutowalkResponse::mutable_failed_elements() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.autowalk.CompileAutowalkResponse.failed_elements)
  return _internal_mutable_failed_elements();
}

// .bosdyn.api.autowalk.NodeIdentifier docking_node = 7;
inline bool CompileAutowalkResponse::_internal_has_docking_node() const {
  return this != internal_default_instance() && _impl_.docking_node_ != nullptr;
}
inline bool CompileAutowalkResponse::has_docking_node() const {
  return _internal_has_docking_node();
}
inline void CompileAutowalkResponse::clear_docking_node() {
  if (GetArenaForAllocation() == nullptr && _impl_.docking_node_ != nullptr) {
    delete _impl_.docking_node_;
  }
  _impl_.docking_node_ = nullptr;
}
inline const ::bosdyn::api::autowalk::NodeIdentifier& CompileAutowalkResponse::_internal_docking_node() const {
  const ::bosdyn::api::autowalk::NodeIdentifier* p = _impl_.docking_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::NodeIdentifier&>(
      ::bosdyn::api::autowalk::_NodeIdentifier_default_instance_);
}
inline const ::bosdyn::api::autowalk::NodeIdentifier& CompileAutowalkResponse::docking_node() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.CompileAutowalkResponse.docking_node)
  return _internal_docking_node();
}
inline void CompileAutowalkResponse::unsafe_arena_set_allocated_docking_node(
    ::bosdyn::api::autowalk::NodeIdentifier* docking_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.docking_node_);
  }
  _impl_.docking_node_ = docking_node;
  if (docking_node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.CompileAutowalkResponse.docking_node)
}
inline ::bosdyn::api::autowalk::NodeIdentifier* CompileAutowalkResponse::release_docking_node() {
  
  ::bosdyn::api::autowalk::NodeIdentifier* temp = _impl_.docking_node_;
  _impl_.docking_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* CompileAutowalkResponse::unsafe_arena_release_docking_node() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.CompileAutowalkResponse.docking_node)
  
  ::bosdyn::api::autowalk::NodeIdentifier* temp = _impl_.docking_node_;
  _impl_.docking_node_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* CompileAutowalkResponse::_internal_mutable_docking_node() {
  
  if (_impl_.docking_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::NodeIdentifier>(GetArenaForAllocation());
    _impl_.docking_node_ = p;
  }
  return _impl_.docking_node_;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* CompileAutowalkResponse::mutable_docking_node() {
  ::bosdyn::api::autowalk::NodeIdentifier* _msg = _internal_mutable_docking_node();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.CompileAutowalkResponse.docking_node)
  return _msg;
}
inline void CompileAutowalkResponse::set_allocated_docking_node(::bosdyn::api::autowalk::NodeIdentifier* docking_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.docking_node_;
  }
  if (docking_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(docking_node);
    if (message_arena != submessage_arena) {
      docking_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, docking_node, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.docking_node_ = docking_node;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.CompileAutowalkResponse.docking_node)
}

// .bosdyn.api.autowalk.NodeIdentifier loop_node = 8;
inline bool CompileAutowalkResponse::_internal_has_loop_node() const {
  return this != internal_default_instance() && _impl_.loop_node_ != nullptr;
}
inline bool CompileAutowalkResponse::has_loop_node() const {
  return _internal_has_loop_node();
}
inline void CompileAutowalkResponse::clear_loop_node() {
  if (GetArenaForAllocation() == nullptr && _impl_.loop_node_ != nullptr) {
    delete _impl_.loop_node_;
  }
  _impl_.loop_node_ = nullptr;
}
inline const ::bosdyn::api::autowalk::NodeIdentifier& CompileAutowalkResponse::_internal_loop_node() const {
  const ::bosdyn::api::autowalk::NodeIdentifier* p = _impl_.loop_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::NodeIdentifier&>(
      ::bosdyn::api::autowalk::_NodeIdentifier_default_instance_);
}
inline const ::bosdyn::api::autowalk::NodeIdentifier& CompileAutowalkResponse::loop_node() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.CompileAutowalkResponse.loop_node)
  return _internal_loop_node();
}
inline void CompileAutowalkResponse::unsafe_arena_set_allocated_loop_node(
    ::bosdyn::api::autowalk::NodeIdentifier* loop_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loop_node_);
  }
  _impl_.loop_node_ = loop_node;
  if (loop_node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.CompileAutowalkResponse.loop_node)
}
inline ::bosdyn::api::autowalk::NodeIdentifier* CompileAutowalkResponse::release_loop_node() {
  
  ::bosdyn::api::autowalk::NodeIdentifier* temp = _impl_.loop_node_;
  _impl_.loop_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* CompileAutowalkResponse::unsafe_arena_release_loop_node() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.CompileAutowalkResponse.loop_node)
  
  ::bosdyn::api::autowalk::NodeIdentifier* temp = _impl_.loop_node_;
  _impl_.loop_node_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* CompileAutowalkResponse::_internal_mutable_loop_node() {
  
  if (_impl_.loop_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::NodeIdentifier>(GetArenaForAllocation());
    _impl_.loop_node_ = p;
  }
  return _impl_.loop_node_;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* CompileAutowalkResponse::mutable_loop_node() {
  ::bosdyn::api::autowalk::NodeIdentifier* _msg = _internal_mutable_loop_node();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.CompileAutowalkResponse.loop_node)
  return _msg;
}
inline void CompileAutowalkResponse::set_allocated_loop_node(::bosdyn::api::autowalk::NodeIdentifier* loop_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loop_node_;
  }
  if (loop_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loop_node);
    if (message_arena != submessage_arena) {
      loop_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loop_node, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.loop_node_ = loop_node;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.CompileAutowalkResponse.loop_node)
}

// -------------------------------------------------------------------

// LoadAutowalkRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool LoadAutowalkRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool LoadAutowalkRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& LoadAutowalkRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& LoadAutowalkRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.LoadAutowalkRequest.header)
  return _internal_header();
}
inline void LoadAutowalkRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.LoadAutowalkRequest.header)
}
inline ::bosdyn::api::RequestHeader* LoadAutowalkRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* LoadAutowalkRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.LoadAutowalkRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* LoadAutowalkRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* LoadAutowalkRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.LoadAutowalkRequest.header)
  return _msg;
}
inline void LoadAutowalkRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.LoadAutowalkRequest.header)
}

// .bosdyn.api.autowalk.Walk walk = 2;
inline bool LoadAutowalkRequest::_internal_has_walk() const {
  return this != internal_default_instance() && _impl_.walk_ != nullptr;
}
inline bool LoadAutowalkRequest::has_walk() const {
  return _internal_has_walk();
}
inline const ::bosdyn::api::autowalk::Walk& LoadAutowalkRequest::_internal_walk() const {
  const ::bosdyn::api::autowalk::Walk* p = _impl_.walk_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::Walk&>(
      ::bosdyn::api::autowalk::_Walk_default_instance_);
}
inline const ::bosdyn::api::autowalk::Walk& LoadAutowalkRequest::walk() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.LoadAutowalkRequest.walk)
  return _internal_walk();
}
inline void LoadAutowalkRequest::unsafe_arena_set_allocated_walk(
    ::bosdyn::api::autowalk::Walk* walk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.walk_);
  }
  _impl_.walk_ = walk;
  if (walk) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.LoadAutowalkRequest.walk)
}
inline ::bosdyn::api::autowalk::Walk* LoadAutowalkRequest::release_walk() {
  
  ::bosdyn::api::autowalk::Walk* temp = _impl_.walk_;
  _impl_.walk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::Walk* LoadAutowalkRequest::unsafe_arena_release_walk() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.LoadAutowalkRequest.walk)
  
  ::bosdyn::api::autowalk::Walk* temp = _impl_.walk_;
  _impl_.walk_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::Walk* LoadAutowalkRequest::_internal_mutable_walk() {
  
  if (_impl_.walk_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::Walk>(GetArenaForAllocation());
    _impl_.walk_ = p;
  }
  return _impl_.walk_;
}
inline ::bosdyn::api::autowalk::Walk* LoadAutowalkRequest::mutable_walk() {
  ::bosdyn::api::autowalk::Walk* _msg = _internal_mutable_walk();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.LoadAutowalkRequest.walk)
  return _msg;
}
inline void LoadAutowalkRequest::set_allocated_walk(::bosdyn::api::autowalk::Walk* walk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.walk_);
  }
  if (walk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(walk));
    if (message_arena != submessage_arena) {
      walk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, walk, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.walk_ = walk;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.LoadAutowalkRequest.walk)
}

// repeated .bosdyn.api.Lease leases = 3;
inline int LoadAutowalkRequest::_internal_leases_size() const {
  return _impl_.leases_.size();
}
inline int LoadAutowalkRequest::leases_size() const {
  return _internal_leases_size();
}
inline ::bosdyn::api::Lease* LoadAutowalkRequest::mutable_leases(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.LoadAutowalkRequest.leases)
  return _impl_.leases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
LoadAutowalkRequest::mutable_leases() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.autowalk.LoadAutowalkRequest.leases)
  return &_impl_.leases_;
}
inline const ::bosdyn::api::Lease& LoadAutowalkRequest::_internal_leases(int index) const {
  return _impl_.leases_.Get(index);
}
inline const ::bosdyn::api::Lease& LoadAutowalkRequest::leases(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.LoadAutowalkRequest.leases)
  return _internal_leases(index);
}
inline ::bosdyn::api::Lease* LoadAutowalkRequest::_internal_add_leases() {
  return _impl_.leases_.Add();
}
inline ::bosdyn::api::Lease* LoadAutowalkRequest::add_leases() {
  ::bosdyn::api::Lease* _add = _internal_add_leases();
  // @@protoc_insertion_point(field_add:bosdyn.api.autowalk.LoadAutowalkRequest.leases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
LoadAutowalkRequest::leases() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.autowalk.LoadAutowalkRequest.leases)
  return _impl_.leases_;
}

// bool treat_warnings_as_errors = 5;
inline void LoadAutowalkRequest::clear_treat_warnings_as_errors() {
  _impl_.treat_warnings_as_errors_ = false;
}
inline bool LoadAutowalkRequest::_internal_treat_warnings_as_errors() const {
  return _impl_.treat_warnings_as_errors_;
}
inline bool LoadAutowalkRequest::treat_warnings_as_errors() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.LoadAutowalkRequest.treat_warnings_as_errors)
  return _internal_treat_warnings_as_errors();
}
inline void LoadAutowalkRequest::_internal_set_treat_warnings_as_errors(bool value) {
  
  _impl_.treat_warnings_as_errors_ = value;
}
inline void LoadAutowalkRequest::set_treat_warnings_as_errors(bool value) {
  _internal_set_treat_warnings_as_errors(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.LoadAutowalkRequest.treat_warnings_as_errors)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LoadAutowalkResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool LoadAutowalkResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool LoadAutowalkResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& LoadAutowalkResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& LoadAutowalkResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.LoadAutowalkResponse.header)
  return _internal_header();
}
inline void LoadAutowalkResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.LoadAutowalkResponse.header)
}
inline ::bosdyn::api::ResponseHeader* LoadAutowalkResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* LoadAutowalkResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.LoadAutowalkResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* LoadAutowalkResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* LoadAutowalkResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.LoadAutowalkResponse.header)
  return _msg;
}
inline void LoadAutowalkResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.LoadAutowalkResponse.header)
}

// .bosdyn.api.autowalk.LoadAutowalkResponse.Status status = 2;
inline void LoadAutowalkResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::autowalk::LoadAutowalkResponse_Status LoadAutowalkResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::autowalk::LoadAutowalkResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::autowalk::LoadAutowalkResponse_Status LoadAutowalkResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.LoadAutowalkResponse.status)
  return _internal_status();
}
inline void LoadAutowalkResponse::_internal_set_status(::bosdyn::api::autowalk::LoadAutowalkResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void LoadAutowalkResponse::set_status(::bosdyn::api::autowalk::LoadAutowalkResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.LoadAutowalkResponse.status)
}

// repeated .bosdyn.api.LeaseUseResult lease_use_results = 3;
inline int LoadAutowalkResponse::_internal_lease_use_results_size() const {
  return _impl_.lease_use_results_.size();
}
inline int LoadAutowalkResponse::lease_use_results_size() const {
  return _internal_lease_use_results_size();
}
inline ::bosdyn::api::LeaseUseResult* LoadAutowalkResponse::mutable_lease_use_results(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.LoadAutowalkResponse.lease_use_results)
  return _impl_.lease_use_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
LoadAutowalkResponse::mutable_lease_use_results() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.autowalk.LoadAutowalkResponse.lease_use_results)
  return &_impl_.lease_use_results_;
}
inline const ::bosdyn::api::LeaseUseResult& LoadAutowalkResponse::_internal_lease_use_results(int index) const {
  return _impl_.lease_use_results_.Get(index);
}
inline const ::bosdyn::api::LeaseUseResult& LoadAutowalkResponse::lease_use_results(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.LoadAutowalkResponse.lease_use_results)
  return _internal_lease_use_results(index);
}
inline ::bosdyn::api::LeaseUseResult* LoadAutowalkResponse::_internal_add_lease_use_results() {
  return _impl_.lease_use_results_.Add();
}
inline ::bosdyn::api::LeaseUseResult* LoadAutowalkResponse::add_lease_use_results() {
  ::bosdyn::api::LeaseUseResult* _add = _internal_add_lease_use_results();
  // @@protoc_insertion_point(field_add:bosdyn.api.autowalk.LoadAutowalkResponse.lease_use_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
LoadAutowalkResponse::lease_use_results() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.autowalk.LoadAutowalkResponse.lease_use_results)
  return _impl_.lease_use_results_;
}

// repeated .bosdyn.api.mission.FailedNode failed_nodes = 5;
inline int LoadAutowalkResponse::_internal_failed_nodes_size() const {
  return _impl_.failed_nodes_.size();
}
inline int LoadAutowalkResponse::failed_nodes_size() const {
  return _internal_failed_nodes_size();
}
inline ::bosdyn::api::mission::FailedNode* LoadAutowalkResponse::mutable_failed_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.LoadAutowalkResponse.failed_nodes)
  return _impl_.failed_nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::FailedNode >*
LoadAutowalkResponse::mutable_failed_nodes() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.autowalk.LoadAutowalkResponse.failed_nodes)
  return &_impl_.failed_nodes_;
}
inline const ::bosdyn::api::mission::FailedNode& LoadAutowalkResponse::_internal_failed_nodes(int index) const {
  return _impl_.failed_nodes_.Get(index);
}
inline const ::bosdyn::api::mission::FailedNode& LoadAutowalkResponse::failed_nodes(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.LoadAutowalkResponse.failed_nodes)
  return _internal_failed_nodes(index);
}
inline ::bosdyn::api::mission::FailedNode* LoadAutowalkResponse::_internal_add_failed_nodes() {
  return _impl_.failed_nodes_.Add();
}
inline ::bosdyn::api::mission::FailedNode* LoadAutowalkResponse::add_failed_nodes() {
  ::bosdyn::api::mission::FailedNode* _add = _internal_add_failed_nodes();
  // @@protoc_insertion_point(field_add:bosdyn.api.autowalk.LoadAutowalkResponse.failed_nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::FailedNode >&
LoadAutowalkResponse::failed_nodes() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.autowalk.LoadAutowalkResponse.failed_nodes)
  return _impl_.failed_nodes_;
}

// repeated .bosdyn.api.autowalk.ElementIdentifiers element_identifiers = 7;
inline int LoadAutowalkResponse::_internal_element_identifiers_size() const {
  return _impl_.element_identifiers_.size();
}
inline int LoadAutowalkResponse::element_identifiers_size() const {
  return _internal_element_identifiers_size();
}
inline void LoadAutowalkResponse::clear_element_identifiers() {
  _impl_.element_identifiers_.Clear();
}
inline ::bosdyn::api::autowalk::ElementIdentifiers* LoadAutowalkResponse::mutable_element_identifiers(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.LoadAutowalkResponse.element_identifiers)
  return _impl_.element_identifiers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::ElementIdentifiers >*
LoadAutowalkResponse::mutable_element_identifiers() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.autowalk.LoadAutowalkResponse.element_identifiers)
  return &_impl_.element_identifiers_;
}
inline const ::bosdyn::api::autowalk::ElementIdentifiers& LoadAutowalkResponse::_internal_element_identifiers(int index) const {
  return _impl_.element_identifiers_.Get(index);
}
inline const ::bosdyn::api::autowalk::ElementIdentifiers& LoadAutowalkResponse::element_identifiers(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.LoadAutowalkResponse.element_identifiers)
  return _internal_element_identifiers(index);
}
inline ::bosdyn::api::autowalk::ElementIdentifiers* LoadAutowalkResponse::_internal_add_element_identifiers() {
  return _impl_.element_identifiers_.Add();
}
inline ::bosdyn::api::autowalk::ElementIdentifiers* LoadAutowalkResponse::add_element_identifiers() {
  ::bosdyn::api::autowalk::ElementIdentifiers* _add = _internal_add_element_identifiers();
  // @@protoc_insertion_point(field_add:bosdyn.api.autowalk.LoadAutowalkResponse.element_identifiers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::autowalk::ElementIdentifiers >&
LoadAutowalkResponse::element_identifiers() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.autowalk.LoadAutowalkResponse.element_identifiers)
  return _impl_.element_identifiers_;
}

// map<int32, .bosdyn.api.autowalk.FailedElement> failed_elements = 8;
inline int LoadAutowalkResponse::_internal_failed_elements_size() const {
  return _impl_.failed_elements_.size();
}
inline int LoadAutowalkResponse::failed_elements_size() const {
  return _internal_failed_elements_size();
}
inline void LoadAutowalkResponse::clear_failed_elements() {
  _impl_.failed_elements_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::autowalk::FailedElement >&
LoadAutowalkResponse::_internal_failed_elements() const {
  return _impl_.failed_elements_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::autowalk::FailedElement >&
LoadAutowalkResponse::failed_elements() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.autowalk.LoadAutowalkResponse.failed_elements)
  return _internal_failed_elements();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::autowalk::FailedElement >*
LoadAutowalkResponse::_internal_mutable_failed_elements() {
  return _impl_.failed_elements_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::bosdyn::api::autowalk::FailedElement >*
LoadAutowalkResponse::mutable_failed_elements() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.autowalk.LoadAutowalkResponse.failed_elements)
  return _internal_mutable_failed_elements();
}

// int64 mission_id = 9;
inline void LoadAutowalkResponse::clear_mission_id() {
  _impl_.mission_id_ = int64_t{0};
}
inline int64_t LoadAutowalkResponse::_internal_mission_id() const {
  return _impl_.mission_id_;
}
inline int64_t LoadAutowalkResponse::mission_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.LoadAutowalkResponse.mission_id)
  return _internal_mission_id();
}
inline void LoadAutowalkResponse::_internal_set_mission_id(int64_t value) {
  
  _impl_.mission_id_ = value;
}
inline void LoadAutowalkResponse::set_mission_id(int64_t value) {
  _internal_set_mission_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.autowalk.LoadAutowalkResponse.mission_id)
}

// .bosdyn.api.autowalk.NodeIdentifier docking_node = 10;
inline bool LoadAutowalkResponse::_internal_has_docking_node() const {
  return this != internal_default_instance() && _impl_.docking_node_ != nullptr;
}
inline bool LoadAutowalkResponse::has_docking_node() const {
  return _internal_has_docking_node();
}
inline void LoadAutowalkResponse::clear_docking_node() {
  if (GetArenaForAllocation() == nullptr && _impl_.docking_node_ != nullptr) {
    delete _impl_.docking_node_;
  }
  _impl_.docking_node_ = nullptr;
}
inline const ::bosdyn::api::autowalk::NodeIdentifier& LoadAutowalkResponse::_internal_docking_node() const {
  const ::bosdyn::api::autowalk::NodeIdentifier* p = _impl_.docking_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::NodeIdentifier&>(
      ::bosdyn::api::autowalk::_NodeIdentifier_default_instance_);
}
inline const ::bosdyn::api::autowalk::NodeIdentifier& LoadAutowalkResponse::docking_node() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.LoadAutowalkResponse.docking_node)
  return _internal_docking_node();
}
inline void LoadAutowalkResponse::unsafe_arena_set_allocated_docking_node(
    ::bosdyn::api::autowalk::NodeIdentifier* docking_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.docking_node_);
  }
  _impl_.docking_node_ = docking_node;
  if (docking_node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.LoadAutowalkResponse.docking_node)
}
inline ::bosdyn::api::autowalk::NodeIdentifier* LoadAutowalkResponse::release_docking_node() {
  
  ::bosdyn::api::autowalk::NodeIdentifier* temp = _impl_.docking_node_;
  _impl_.docking_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* LoadAutowalkResponse::unsafe_arena_release_docking_node() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.LoadAutowalkResponse.docking_node)
  
  ::bosdyn::api::autowalk::NodeIdentifier* temp = _impl_.docking_node_;
  _impl_.docking_node_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* LoadAutowalkResponse::_internal_mutable_docking_node() {
  
  if (_impl_.docking_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::NodeIdentifier>(GetArenaForAllocation());
    _impl_.docking_node_ = p;
  }
  return _impl_.docking_node_;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* LoadAutowalkResponse::mutable_docking_node() {
  ::bosdyn::api::autowalk::NodeIdentifier* _msg = _internal_mutable_docking_node();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.LoadAutowalkResponse.docking_node)
  return _msg;
}
inline void LoadAutowalkResponse::set_allocated_docking_node(::bosdyn::api::autowalk::NodeIdentifier* docking_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.docking_node_;
  }
  if (docking_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(docking_node);
    if (message_arena != submessage_arena) {
      docking_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, docking_node, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.docking_node_ = docking_node;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.LoadAutowalkResponse.docking_node)
}

// .bosdyn.api.autowalk.NodeIdentifier loop_node = 11;
inline bool LoadAutowalkResponse::_internal_has_loop_node() const {
  return this != internal_default_instance() && _impl_.loop_node_ != nullptr;
}
inline bool LoadAutowalkResponse::has_loop_node() const {
  return _internal_has_loop_node();
}
inline void LoadAutowalkResponse::clear_loop_node() {
  if (GetArenaForAllocation() == nullptr && _impl_.loop_node_ != nullptr) {
    delete _impl_.loop_node_;
  }
  _impl_.loop_node_ = nullptr;
}
inline const ::bosdyn::api::autowalk::NodeIdentifier& LoadAutowalkResponse::_internal_loop_node() const {
  const ::bosdyn::api::autowalk::NodeIdentifier* p = _impl_.loop_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::autowalk::NodeIdentifier&>(
      ::bosdyn::api::autowalk::_NodeIdentifier_default_instance_);
}
inline const ::bosdyn::api::autowalk::NodeIdentifier& LoadAutowalkResponse::loop_node() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.autowalk.LoadAutowalkResponse.loop_node)
  return _internal_loop_node();
}
inline void LoadAutowalkResponse::unsafe_arena_set_allocated_loop_node(
    ::bosdyn::api::autowalk::NodeIdentifier* loop_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loop_node_);
  }
  _impl_.loop_node_ = loop_node;
  if (loop_node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.autowalk.LoadAutowalkResponse.loop_node)
}
inline ::bosdyn::api::autowalk::NodeIdentifier* LoadAutowalkResponse::release_loop_node() {
  
  ::bosdyn::api::autowalk::NodeIdentifier* temp = _impl_.loop_node_;
  _impl_.loop_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* LoadAutowalkResponse::unsafe_arena_release_loop_node() {
  // @@protoc_insertion_point(field_release:bosdyn.api.autowalk.LoadAutowalkResponse.loop_node)
  
  ::bosdyn::api::autowalk::NodeIdentifier* temp = _impl_.loop_node_;
  _impl_.loop_node_ = nullptr;
  return temp;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* LoadAutowalkResponse::_internal_mutable_loop_node() {
  
  if (_impl_.loop_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::autowalk::NodeIdentifier>(GetArenaForAllocation());
    _impl_.loop_node_ = p;
  }
  return _impl_.loop_node_;
}
inline ::bosdyn::api::autowalk::NodeIdentifier* LoadAutowalkResponse::mutable_loop_node() {
  ::bosdyn::api::autowalk::NodeIdentifier* _msg = _internal_mutable_loop_node();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.autowalk.LoadAutowalkResponse.loop_node)
  return _msg;
}
inline void LoadAutowalkResponse::set_allocated_loop_node(::bosdyn::api::autowalk::NodeIdentifier* loop_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loop_node_;
  }
  if (loop_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loop_node);
    if (message_arena != submessage_arena) {
      loop_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loop_node, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.loop_node_ = loop_node;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.autowalk.LoadAutowalkResponse.loop_node)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace autowalk
}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::autowalk::CompileAutowalkResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::autowalk::CompileAutowalkResponse_Status>() {
  return ::bosdyn::api::autowalk::CompileAutowalkResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::autowalk::LoadAutowalkResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::autowalk::LoadAutowalkResponse_Status>() {
  return ::bosdyn::api::autowalk::LoadAutowalkResponse_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fautowalk_2fautowalk_2eproto
