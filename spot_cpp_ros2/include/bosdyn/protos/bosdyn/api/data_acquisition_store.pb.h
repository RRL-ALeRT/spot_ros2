// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/data_acquisition_store.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/image.pb.h"
#include "bosdyn/api/data_acquisition.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
namespace bosdyn {
namespace api {
class ActionIdQuery;
struct ActionIdQueryDefaultTypeInternal;
extern ActionIdQueryDefaultTypeInternal _ActionIdQuery_default_instance_;
class DataQueryParams;
struct DataQueryParamsDefaultTypeInternal;
extern DataQueryParamsDefaultTypeInternal _DataQueryParams_default_instance_;
class ListCaptureActionsRequest;
struct ListCaptureActionsRequestDefaultTypeInternal;
extern ListCaptureActionsRequestDefaultTypeInternal _ListCaptureActionsRequest_default_instance_;
class ListCaptureActionsResponse;
struct ListCaptureActionsResponseDefaultTypeInternal;
extern ListCaptureActionsResponseDefaultTypeInternal _ListCaptureActionsResponse_default_instance_;
class ListStoredAlertDataRequest;
struct ListStoredAlertDataRequestDefaultTypeInternal;
extern ListStoredAlertDataRequestDefaultTypeInternal _ListStoredAlertDataRequest_default_instance_;
class ListStoredAlertDataResponse;
struct ListStoredAlertDataResponseDefaultTypeInternal;
extern ListStoredAlertDataResponseDefaultTypeInternal _ListStoredAlertDataResponse_default_instance_;
class ListStoredDataRequest;
struct ListStoredDataRequestDefaultTypeInternal;
extern ListStoredDataRequestDefaultTypeInternal _ListStoredDataRequest_default_instance_;
class ListStoredDataResponse;
struct ListStoredDataResponseDefaultTypeInternal;
extern ListStoredDataResponseDefaultTypeInternal _ListStoredDataResponse_default_instance_;
class ListStoredImagesRequest;
struct ListStoredImagesRequestDefaultTypeInternal;
extern ListStoredImagesRequestDefaultTypeInternal _ListStoredImagesRequest_default_instance_;
class ListStoredImagesResponse;
struct ListStoredImagesResponseDefaultTypeInternal;
extern ListStoredImagesResponseDefaultTypeInternal _ListStoredImagesResponse_default_instance_;
class ListStoredMetadataRequest;
struct ListStoredMetadataRequestDefaultTypeInternal;
extern ListStoredMetadataRequestDefaultTypeInternal _ListStoredMetadataRequest_default_instance_;
class ListStoredMetadataResponse;
struct ListStoredMetadataResponseDefaultTypeInternal;
extern ListStoredMetadataResponseDefaultTypeInternal _ListStoredMetadataResponse_default_instance_;
class StoreAlertDataRequest;
struct StoreAlertDataRequestDefaultTypeInternal;
extern StoreAlertDataRequestDefaultTypeInternal _StoreAlertDataRequest_default_instance_;
class StoreAlertDataResponse;
struct StoreAlertDataResponseDefaultTypeInternal;
extern StoreAlertDataResponseDefaultTypeInternal _StoreAlertDataResponse_default_instance_;
class StoreDataRequest;
struct StoreDataRequestDefaultTypeInternal;
extern StoreDataRequestDefaultTypeInternal _StoreDataRequest_default_instance_;
class StoreDataResponse;
struct StoreDataResponseDefaultTypeInternal;
extern StoreDataResponseDefaultTypeInternal _StoreDataResponse_default_instance_;
class StoreImageRequest;
struct StoreImageRequestDefaultTypeInternal;
extern StoreImageRequestDefaultTypeInternal _StoreImageRequest_default_instance_;
class StoreImageResponse;
struct StoreImageResponseDefaultTypeInternal;
extern StoreImageResponseDefaultTypeInternal _StoreImageResponse_default_instance_;
class StoreMetadataRequest;
struct StoreMetadataRequestDefaultTypeInternal;
extern StoreMetadataRequestDefaultTypeInternal _StoreMetadataRequest_default_instance_;
class StoreMetadataResponse;
struct StoreMetadataResponseDefaultTypeInternal;
extern StoreMetadataResponseDefaultTypeInternal _StoreMetadataResponse_default_instance_;
class TimeRangeQuery;
struct TimeRangeQueryDefaultTypeInternal;
extern TimeRangeQueryDefaultTypeInternal _TimeRangeQuery_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::ActionIdQuery* Arena::CreateMaybeMessage<::bosdyn::api::ActionIdQuery>(Arena*);
template<> ::bosdyn::api::DataQueryParams* Arena::CreateMaybeMessage<::bosdyn::api::DataQueryParams>(Arena*);
template<> ::bosdyn::api::ListCaptureActionsRequest* Arena::CreateMaybeMessage<::bosdyn::api::ListCaptureActionsRequest>(Arena*);
template<> ::bosdyn::api::ListCaptureActionsResponse* Arena::CreateMaybeMessage<::bosdyn::api::ListCaptureActionsResponse>(Arena*);
template<> ::bosdyn::api::ListStoredAlertDataRequest* Arena::CreateMaybeMessage<::bosdyn::api::ListStoredAlertDataRequest>(Arena*);
template<> ::bosdyn::api::ListStoredAlertDataResponse* Arena::CreateMaybeMessage<::bosdyn::api::ListStoredAlertDataResponse>(Arena*);
template<> ::bosdyn::api::ListStoredDataRequest* Arena::CreateMaybeMessage<::bosdyn::api::ListStoredDataRequest>(Arena*);
template<> ::bosdyn::api::ListStoredDataResponse* Arena::CreateMaybeMessage<::bosdyn::api::ListStoredDataResponse>(Arena*);
template<> ::bosdyn::api::ListStoredImagesRequest* Arena::CreateMaybeMessage<::bosdyn::api::ListStoredImagesRequest>(Arena*);
template<> ::bosdyn::api::ListStoredImagesResponse* Arena::CreateMaybeMessage<::bosdyn::api::ListStoredImagesResponse>(Arena*);
template<> ::bosdyn::api::ListStoredMetadataRequest* Arena::CreateMaybeMessage<::bosdyn::api::ListStoredMetadataRequest>(Arena*);
template<> ::bosdyn::api::ListStoredMetadataResponse* Arena::CreateMaybeMessage<::bosdyn::api::ListStoredMetadataResponse>(Arena*);
template<> ::bosdyn::api::StoreAlertDataRequest* Arena::CreateMaybeMessage<::bosdyn::api::StoreAlertDataRequest>(Arena*);
template<> ::bosdyn::api::StoreAlertDataResponse* Arena::CreateMaybeMessage<::bosdyn::api::StoreAlertDataResponse>(Arena*);
template<> ::bosdyn::api::StoreDataRequest* Arena::CreateMaybeMessage<::bosdyn::api::StoreDataRequest>(Arena*);
template<> ::bosdyn::api::StoreDataResponse* Arena::CreateMaybeMessage<::bosdyn::api::StoreDataResponse>(Arena*);
template<> ::bosdyn::api::StoreImageRequest* Arena::CreateMaybeMessage<::bosdyn::api::StoreImageRequest>(Arena*);
template<> ::bosdyn::api::StoreImageResponse* Arena::CreateMaybeMessage<::bosdyn::api::StoreImageResponse>(Arena*);
template<> ::bosdyn::api::StoreMetadataRequest* Arena::CreateMaybeMessage<::bosdyn::api::StoreMetadataRequest>(Arena*);
template<> ::bosdyn::api::StoreMetadataResponse* Arena::CreateMaybeMessage<::bosdyn::api::StoreMetadataResponse>(Arena*);
template<> ::bosdyn::api::TimeRangeQuery* Arena::CreateMaybeMessage<::bosdyn::api::TimeRangeQuery>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

// ===================================================================

class ActionIdQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ActionIdQuery) */ {
 public:
  inline ActionIdQuery() : ActionIdQuery(nullptr) {}
  ~ActionIdQuery() override;
  explicit PROTOBUF_CONSTEXPR ActionIdQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionIdQuery(const ActionIdQuery& from);
  ActionIdQuery(ActionIdQuery&& from) noexcept
    : ActionIdQuery() {
    *this = ::std::move(from);
  }

  inline ActionIdQuery& operator=(const ActionIdQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionIdQuery& operator=(ActionIdQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionIdQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionIdQuery* internal_default_instance() {
    return reinterpret_cast<const ActionIdQuery*>(
               &_ActionIdQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ActionIdQuery& a, ActionIdQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionIdQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionIdQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionIdQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionIdQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionIdQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionIdQuery& from) {
    ActionIdQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionIdQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ActionIdQuery";
  }
  protected:
  explicit ActionIdQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionIdsFieldNumber = 1,
  };
  // repeated .bosdyn.api.CaptureActionId action_ids = 1;
  int action_ids_size() const;
  private:
  int _internal_action_ids_size() const;
  public:
  void clear_action_ids();
  ::bosdyn::api::CaptureActionId* mutable_action_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CaptureActionId >*
      mutable_action_ids();
  private:
  const ::bosdyn::api::CaptureActionId& _internal_action_ids(int index) const;
  ::bosdyn::api::CaptureActionId* _internal_add_action_ids();
  public:
  const ::bosdyn::api::CaptureActionId& action_ids(int index) const;
  ::bosdyn::api::CaptureActionId* add_action_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CaptureActionId >&
      action_ids() const;

  // @@protoc_insertion_point(class_scope:bosdyn.api.ActionIdQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CaptureActionId > action_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class TimeRangeQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.TimeRangeQuery) */ {
 public:
  inline TimeRangeQuery() : TimeRangeQuery(nullptr) {}
  ~TimeRangeQuery() override;
  explicit PROTOBUF_CONSTEXPR TimeRangeQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeRangeQuery(const TimeRangeQuery& from);
  TimeRangeQuery(TimeRangeQuery&& from) noexcept
    : TimeRangeQuery() {
    *this = ::std::move(from);
  }

  inline TimeRangeQuery& operator=(const TimeRangeQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeRangeQuery& operator=(TimeRangeQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeRangeQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeRangeQuery* internal_default_instance() {
    return reinterpret_cast<const TimeRangeQuery*>(
               &_TimeRangeQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TimeRangeQuery& a, TimeRangeQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeRangeQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeRangeQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeRangeQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeRangeQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeRangeQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimeRangeQuery& from) {
    TimeRangeQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeRangeQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.TimeRangeQuery";
  }
  protected:
  explicit TimeRangeQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromTimestampFieldNumber = 1,
    kToTimestampFieldNumber = 2,
  };
  // .google.protobuf.Timestamp from_timestamp = 1;
  bool has_from_timestamp() const;
  private:
  bool _internal_has_from_timestamp() const;
  public:
  void clear_from_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& from_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_from_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_from_timestamp();
  void set_allocated_from_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* from_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_from_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_from_timestamp();
  public:
  void unsafe_arena_set_allocated_from_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* from_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_from_timestamp();

  // .google.protobuf.Timestamp to_timestamp = 2;
  bool has_to_timestamp() const;
  private:
  bool _internal_has_to_timestamp() const;
  public:
  void clear_to_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& to_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_to_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_to_timestamp();
  void set_allocated_to_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* to_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_to_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_to_timestamp();
  public:
  void unsafe_arena_set_allocated_to_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* to_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_to_timestamp();

  // @@protoc_insertion_point(class_scope:bosdyn.api.TimeRangeQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* from_timestamp_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* to_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class DataQueryParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DataQueryParams) */ {
 public:
  inline DataQueryParams() : DataQueryParams(nullptr) {}
  ~DataQueryParams() override;
  explicit PROTOBUF_CONSTEXPR DataQueryParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataQueryParams(const DataQueryParams& from);
  DataQueryParams(DataQueryParams&& from) noexcept
    : DataQueryParams() {
    *this = ::std::move(from);
  }

  inline DataQueryParams& operator=(const DataQueryParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataQueryParams& operator=(DataQueryParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataQueryParams& default_instance() {
    return *internal_default_instance();
  }
  enum QueryCase {
    kTimeRange = 1,
    kActionIds = 2,
    QUERY_NOT_SET = 0,
  };

  static inline const DataQueryParams* internal_default_instance() {
    return reinterpret_cast<const DataQueryParams*>(
               &_DataQueryParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DataQueryParams& a, DataQueryParams& b) {
    a.Swap(&b);
  }
  inline void Swap(DataQueryParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataQueryParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataQueryParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataQueryParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataQueryParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataQueryParams& from) {
    DataQueryParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataQueryParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DataQueryParams";
  }
  protected:
  explicit DataQueryParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeRangeFieldNumber = 1,
    kActionIdsFieldNumber = 2,
  };
  // .bosdyn.api.TimeRangeQuery time_range = 1;
  bool has_time_range() const;
  private:
  bool _internal_has_time_range() const;
  public:
  void clear_time_range();
  const ::bosdyn::api::TimeRangeQuery& time_range() const;
  PROTOBUF_NODISCARD ::bosdyn::api::TimeRangeQuery* release_time_range();
  ::bosdyn::api::TimeRangeQuery* mutable_time_range();
  void set_allocated_time_range(::bosdyn::api::TimeRangeQuery* time_range);
  private:
  const ::bosdyn::api::TimeRangeQuery& _internal_time_range() const;
  ::bosdyn::api::TimeRangeQuery* _internal_mutable_time_range();
  public:
  void unsafe_arena_set_allocated_time_range(
      ::bosdyn::api::TimeRangeQuery* time_range);
  ::bosdyn::api::TimeRangeQuery* unsafe_arena_release_time_range();

  // .bosdyn.api.ActionIdQuery action_ids = 2;
  bool has_action_ids() const;
  private:
  bool _internal_has_action_ids() const;
  public:
  void clear_action_ids();
  const ::bosdyn::api::ActionIdQuery& action_ids() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ActionIdQuery* release_action_ids();
  ::bosdyn::api::ActionIdQuery* mutable_action_ids();
  void set_allocated_action_ids(::bosdyn::api::ActionIdQuery* action_ids);
  private:
  const ::bosdyn::api::ActionIdQuery& _internal_action_ids() const;
  ::bosdyn::api::ActionIdQuery* _internal_mutable_action_ids();
  public:
  void unsafe_arena_set_allocated_action_ids(
      ::bosdyn::api::ActionIdQuery* action_ids);
  ::bosdyn::api::ActionIdQuery* unsafe_arena_release_action_ids();

  void clear_query();
  QueryCase query_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.DataQueryParams)
 private:
  class _Internal;
  void set_has_time_range();
  void set_has_action_ids();

  inline bool has_query() const;
  inline void clear_has_query();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union QueryUnion {
      constexpr QueryUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::TimeRangeQuery* time_range_;
      ::bosdyn::api::ActionIdQuery* action_ids_;
    } query_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class StoreImageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.StoreImageRequest) */ {
 public:
  inline StoreImageRequest() : StoreImageRequest(nullptr) {}
  ~StoreImageRequest() override;
  explicit PROTOBUF_CONSTEXPR StoreImageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreImageRequest(const StoreImageRequest& from);
  StoreImageRequest(StoreImageRequest&& from) noexcept
    : StoreImageRequest() {
    *this = ::std::move(from);
  }

  inline StoreImageRequest& operator=(const StoreImageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreImageRequest& operator=(StoreImageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreImageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreImageRequest* internal_default_instance() {
    return reinterpret_cast<const StoreImageRequest*>(
               &_StoreImageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StoreImageRequest& a, StoreImageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreImageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreImageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreImageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreImageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreImageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StoreImageRequest& from) {
    StoreImageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreImageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StoreImageRequest";
  }
  protected:
  explicit StoreImageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kImageFieldNumber = 2,
    kDataIdFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.ImageCapture image = 2;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::bosdyn::api::ImageCapture& image() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ImageCapture* release_image();
  ::bosdyn::api::ImageCapture* mutable_image();
  void set_allocated_image(::bosdyn::api::ImageCapture* image);
  private:
  const ::bosdyn::api::ImageCapture& _internal_image() const;
  ::bosdyn::api::ImageCapture* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::bosdyn::api::ImageCapture* image);
  ::bosdyn::api::ImageCapture* unsafe_arena_release_image();

  // .bosdyn.api.DataIdentifier data_id = 3;
  bool has_data_id() const;
  private:
  bool _internal_has_data_id() const;
  public:
  void clear_data_id();
  const ::bosdyn::api::DataIdentifier& data_id() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataIdentifier* release_data_id();
  ::bosdyn::api::DataIdentifier* mutable_data_id();
  void set_allocated_data_id(::bosdyn::api::DataIdentifier* data_id);
  private:
  const ::bosdyn::api::DataIdentifier& _internal_data_id() const;
  ::bosdyn::api::DataIdentifier* _internal_mutable_data_id();
  public:
  void unsafe_arena_set_allocated_data_id(
      ::bosdyn::api::DataIdentifier* data_id);
  ::bosdyn::api::DataIdentifier* unsafe_arena_release_data_id();

  // @@protoc_insertion_point(class_scope:bosdyn.api.StoreImageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::ImageCapture* image_;
    ::bosdyn::api::DataIdentifier* data_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class StoreImageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.StoreImageResponse) */ {
 public:
  inline StoreImageResponse() : StoreImageResponse(nullptr) {}
  ~StoreImageResponse() override;
  explicit PROTOBUF_CONSTEXPR StoreImageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreImageResponse(const StoreImageResponse& from);
  StoreImageResponse(StoreImageResponse&& from) noexcept
    : StoreImageResponse() {
    *this = ::std::move(from);
  }

  inline StoreImageResponse& operator=(const StoreImageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreImageResponse& operator=(StoreImageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreImageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreImageResponse* internal_default_instance() {
    return reinterpret_cast<const StoreImageResponse*>(
               &_StoreImageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StoreImageResponse& a, StoreImageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreImageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreImageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreImageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreImageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreImageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StoreImageResponse& from) {
    StoreImageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreImageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StoreImageResponse";
  }
  protected:
  explicit StoreImageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.StoreImageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class StoreMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.StoreMetadataRequest) */ {
 public:
  inline StoreMetadataRequest() : StoreMetadataRequest(nullptr) {}
  ~StoreMetadataRequest() override;
  explicit PROTOBUF_CONSTEXPR StoreMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreMetadataRequest(const StoreMetadataRequest& from);
  StoreMetadataRequest(StoreMetadataRequest&& from) noexcept
    : StoreMetadataRequest() {
    *this = ::std::move(from);
  }

  inline StoreMetadataRequest& operator=(const StoreMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreMetadataRequest& operator=(StoreMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const StoreMetadataRequest*>(
               &_StoreMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StoreMetadataRequest& a, StoreMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StoreMetadataRequest& from) {
    StoreMetadataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StoreMetadataRequest";
  }
  protected:
  explicit StoreMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kMetadataFieldNumber = 2,
    kDataIdFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.AssociatedMetadata metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::bosdyn::api::AssociatedMetadata& metadata() const;
  PROTOBUF_NODISCARD ::bosdyn::api::AssociatedMetadata* release_metadata();
  ::bosdyn::api::AssociatedMetadata* mutable_metadata();
  void set_allocated_metadata(::bosdyn::api::AssociatedMetadata* metadata);
  private:
  const ::bosdyn::api::AssociatedMetadata& _internal_metadata() const;
  ::bosdyn::api::AssociatedMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::bosdyn::api::AssociatedMetadata* metadata);
  ::bosdyn::api::AssociatedMetadata* unsafe_arena_release_metadata();

  // .bosdyn.api.DataIdentifier data_id = 3;
  bool has_data_id() const;
  private:
  bool _internal_has_data_id() const;
  public:
  void clear_data_id();
  const ::bosdyn::api::DataIdentifier& data_id() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataIdentifier* release_data_id();
  ::bosdyn::api::DataIdentifier* mutable_data_id();
  void set_allocated_data_id(::bosdyn::api::DataIdentifier* data_id);
  private:
  const ::bosdyn::api::DataIdentifier& _internal_data_id() const;
  ::bosdyn::api::DataIdentifier* _internal_mutable_data_id();
  public:
  void unsafe_arena_set_allocated_data_id(
      ::bosdyn::api::DataIdentifier* data_id);
  ::bosdyn::api::DataIdentifier* unsafe_arena_release_data_id();

  // @@protoc_insertion_point(class_scope:bosdyn.api.StoreMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::AssociatedMetadata* metadata_;
    ::bosdyn::api::DataIdentifier* data_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class StoreMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.StoreMetadataResponse) */ {
 public:
  inline StoreMetadataResponse() : StoreMetadataResponse(nullptr) {}
  ~StoreMetadataResponse() override;
  explicit PROTOBUF_CONSTEXPR StoreMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreMetadataResponse(const StoreMetadataResponse& from);
  StoreMetadataResponse(StoreMetadataResponse&& from) noexcept
    : StoreMetadataResponse() {
    *this = ::std::move(from);
  }

  inline StoreMetadataResponse& operator=(const StoreMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreMetadataResponse& operator=(StoreMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const StoreMetadataResponse*>(
               &_StoreMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StoreMetadataResponse& a, StoreMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreMetadataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StoreMetadataResponse& from) {
    StoreMetadataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreMetadataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StoreMetadataResponse";
  }
  protected:
  explicit StoreMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.StoreMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class StoreAlertDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.StoreAlertDataRequest) */ {
 public:
  inline StoreAlertDataRequest() : StoreAlertDataRequest(nullptr) {}
  ~StoreAlertDataRequest() override;
  explicit PROTOBUF_CONSTEXPR StoreAlertDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreAlertDataRequest(const StoreAlertDataRequest& from);
  StoreAlertDataRequest(StoreAlertDataRequest&& from) noexcept
    : StoreAlertDataRequest() {
    *this = ::std::move(from);
  }

  inline StoreAlertDataRequest& operator=(const StoreAlertDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreAlertDataRequest& operator=(StoreAlertDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreAlertDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreAlertDataRequest* internal_default_instance() {
    return reinterpret_cast<const StoreAlertDataRequest*>(
               &_StoreAlertDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StoreAlertDataRequest& a, StoreAlertDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreAlertDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreAlertDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreAlertDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreAlertDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreAlertDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StoreAlertDataRequest& from) {
    StoreAlertDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreAlertDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StoreAlertDataRequest";
  }
  protected:
  explicit StoreAlertDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kAlertDataFieldNumber = 2,
    kDataIdFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.AssociatedAlertData alert_data = 2;
  bool has_alert_data() const;
  private:
  bool _internal_has_alert_data() const;
  public:
  void clear_alert_data();
  const ::bosdyn::api::AssociatedAlertData& alert_data() const;
  PROTOBUF_NODISCARD ::bosdyn::api::AssociatedAlertData* release_alert_data();
  ::bosdyn::api::AssociatedAlertData* mutable_alert_data();
  void set_allocated_alert_data(::bosdyn::api::AssociatedAlertData* alert_data);
  private:
  const ::bosdyn::api::AssociatedAlertData& _internal_alert_data() const;
  ::bosdyn::api::AssociatedAlertData* _internal_mutable_alert_data();
  public:
  void unsafe_arena_set_allocated_alert_data(
      ::bosdyn::api::AssociatedAlertData* alert_data);
  ::bosdyn::api::AssociatedAlertData* unsafe_arena_release_alert_data();

  // .bosdyn.api.DataIdentifier data_id = 3;
  bool has_data_id() const;
  private:
  bool _internal_has_data_id() const;
  public:
  void clear_data_id();
  const ::bosdyn::api::DataIdentifier& data_id() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataIdentifier* release_data_id();
  ::bosdyn::api::DataIdentifier* mutable_data_id();
  void set_allocated_data_id(::bosdyn::api::DataIdentifier* data_id);
  private:
  const ::bosdyn::api::DataIdentifier& _internal_data_id() const;
  ::bosdyn::api::DataIdentifier* _internal_mutable_data_id();
  public:
  void unsafe_arena_set_allocated_data_id(
      ::bosdyn::api::DataIdentifier* data_id);
  ::bosdyn::api::DataIdentifier* unsafe_arena_release_data_id();

  // @@protoc_insertion_point(class_scope:bosdyn.api.StoreAlertDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::AssociatedAlertData* alert_data_;
    ::bosdyn::api::DataIdentifier* data_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class StoreAlertDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.StoreAlertDataResponse) */ {
 public:
  inline StoreAlertDataResponse() : StoreAlertDataResponse(nullptr) {}
  ~StoreAlertDataResponse() override;
  explicit PROTOBUF_CONSTEXPR StoreAlertDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreAlertDataResponse(const StoreAlertDataResponse& from);
  StoreAlertDataResponse(StoreAlertDataResponse&& from) noexcept
    : StoreAlertDataResponse() {
    *this = ::std::move(from);
  }

  inline StoreAlertDataResponse& operator=(const StoreAlertDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreAlertDataResponse& operator=(StoreAlertDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreAlertDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreAlertDataResponse* internal_default_instance() {
    return reinterpret_cast<const StoreAlertDataResponse*>(
               &_StoreAlertDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StoreAlertDataResponse& a, StoreAlertDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreAlertDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreAlertDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreAlertDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreAlertDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreAlertDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StoreAlertDataResponse& from) {
    StoreAlertDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreAlertDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StoreAlertDataResponse";
  }
  protected:
  explicit StoreAlertDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.StoreAlertDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class StoreDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.StoreDataRequest) */ {
 public:
  inline StoreDataRequest() : StoreDataRequest(nullptr) {}
  ~StoreDataRequest() override;
  explicit PROTOBUF_CONSTEXPR StoreDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreDataRequest(const StoreDataRequest& from);
  StoreDataRequest(StoreDataRequest&& from) noexcept
    : StoreDataRequest() {
    *this = ::std::move(from);
  }

  inline StoreDataRequest& operator=(const StoreDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreDataRequest& operator=(StoreDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreDataRequest* internal_default_instance() {
    return reinterpret_cast<const StoreDataRequest*>(
               &_StoreDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StoreDataRequest& a, StoreDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StoreDataRequest& from) {
    StoreDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StoreDataRequest";
  }
  protected:
  explicit StoreDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kFileExtensionFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kDataIdFieldNumber = 3,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string file_extension = 4;
  void clear_file_extension();
  const std::string& file_extension() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_extension(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_extension();
  PROTOBUF_NODISCARD std::string* release_file_extension();
  void set_allocated_file_extension(std::string* file_extension);
  private:
  const std::string& _internal_file_extension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_extension(const std::string& value);
  std::string* _internal_mutable_file_extension();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.DataIdentifier data_id = 3;
  bool has_data_id() const;
  private:
  bool _internal_has_data_id() const;
  public:
  void clear_data_id();
  const ::bosdyn::api::DataIdentifier& data_id() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataIdentifier* release_data_id();
  ::bosdyn::api::DataIdentifier* mutable_data_id();
  void set_allocated_data_id(::bosdyn::api::DataIdentifier* data_id);
  private:
  const ::bosdyn::api::DataIdentifier& _internal_data_id() const;
  ::bosdyn::api::DataIdentifier* _internal_mutable_data_id();
  public:
  void unsafe_arena_set_allocated_data_id(
      ::bosdyn::api::DataIdentifier* data_id);
  ::bosdyn::api::DataIdentifier* unsafe_arena_release_data_id();

  // @@protoc_insertion_point(class_scope:bosdyn.api.StoreDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_extension_;
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::DataIdentifier* data_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class StoreDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.StoreDataResponse) */ {
 public:
  inline StoreDataResponse() : StoreDataResponse(nullptr) {}
  ~StoreDataResponse() override;
  explicit PROTOBUF_CONSTEXPR StoreDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreDataResponse(const StoreDataResponse& from);
  StoreDataResponse(StoreDataResponse&& from) noexcept
    : StoreDataResponse() {
    *this = ::std::move(from);
  }

  inline StoreDataResponse& operator=(const StoreDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreDataResponse& operator=(StoreDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreDataResponse* internal_default_instance() {
    return reinterpret_cast<const StoreDataResponse*>(
               &_StoreDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StoreDataResponse& a, StoreDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StoreDataResponse& from) {
    StoreDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StoreDataResponse";
  }
  protected:
  explicit StoreDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.StoreDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListCaptureActionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListCaptureActionsRequest) */ {
 public:
  inline ListCaptureActionsRequest() : ListCaptureActionsRequest(nullptr) {}
  ~ListCaptureActionsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListCaptureActionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListCaptureActionsRequest(const ListCaptureActionsRequest& from);
  ListCaptureActionsRequest(ListCaptureActionsRequest&& from) noexcept
    : ListCaptureActionsRequest() {
    *this = ::std::move(from);
  }

  inline ListCaptureActionsRequest& operator=(const ListCaptureActionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListCaptureActionsRequest& operator=(ListCaptureActionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListCaptureActionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListCaptureActionsRequest* internal_default_instance() {
    return reinterpret_cast<const ListCaptureActionsRequest*>(
               &_ListCaptureActionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ListCaptureActionsRequest& a, ListCaptureActionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListCaptureActionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListCaptureActionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListCaptureActionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListCaptureActionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListCaptureActionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListCaptureActionsRequest& from) {
    ListCaptureActionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListCaptureActionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListCaptureActionsRequest";
  }
  protected:
  explicit ListCaptureActionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kQueryFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.DataQueryParams query = 2;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::bosdyn::api::DataQueryParams& query() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataQueryParams* release_query();
  ::bosdyn::api::DataQueryParams* mutable_query();
  void set_allocated_query(::bosdyn::api::DataQueryParams* query);
  private:
  const ::bosdyn::api::DataQueryParams& _internal_query() const;
  ::bosdyn::api::DataQueryParams* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::bosdyn::api::DataQueryParams* query);
  ::bosdyn::api::DataQueryParams* unsafe_arena_release_query();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListCaptureActionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::DataQueryParams* query_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListCaptureActionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListCaptureActionsResponse) */ {
 public:
  inline ListCaptureActionsResponse() : ListCaptureActionsResponse(nullptr) {}
  ~ListCaptureActionsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListCaptureActionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListCaptureActionsResponse(const ListCaptureActionsResponse& from);
  ListCaptureActionsResponse(ListCaptureActionsResponse&& from) noexcept
    : ListCaptureActionsResponse() {
    *this = ::std::move(from);
  }

  inline ListCaptureActionsResponse& operator=(const ListCaptureActionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListCaptureActionsResponse& operator=(ListCaptureActionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListCaptureActionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListCaptureActionsResponse* internal_default_instance() {
    return reinterpret_cast<const ListCaptureActionsResponse*>(
               &_ListCaptureActionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListCaptureActionsResponse& a, ListCaptureActionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListCaptureActionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListCaptureActionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListCaptureActionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListCaptureActionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListCaptureActionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListCaptureActionsResponse& from) {
    ListCaptureActionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListCaptureActionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListCaptureActionsResponse";
  }
  protected:
  explicit ListCaptureActionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionIdsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.CaptureActionId action_ids = 2;
  int action_ids_size() const;
  private:
  int _internal_action_ids_size() const;
  public:
  void clear_action_ids();
  ::bosdyn::api::CaptureActionId* mutable_action_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CaptureActionId >*
      mutable_action_ids();
  private:
  const ::bosdyn::api::CaptureActionId& _internal_action_ids(int index) const;
  ::bosdyn::api::CaptureActionId* _internal_add_action_ids();
  public:
  const ::bosdyn::api::CaptureActionId& action_ids(int index) const;
  ::bosdyn::api::CaptureActionId* add_action_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CaptureActionId >&
      action_ids() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListCaptureActionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CaptureActionId > action_ids_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListStoredImagesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListStoredImagesRequest) */ {
 public:
  inline ListStoredImagesRequest() : ListStoredImagesRequest(nullptr) {}
  ~ListStoredImagesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListStoredImagesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListStoredImagesRequest(const ListStoredImagesRequest& from);
  ListStoredImagesRequest(ListStoredImagesRequest&& from) noexcept
    : ListStoredImagesRequest() {
    *this = ::std::move(from);
  }

  inline ListStoredImagesRequest& operator=(const ListStoredImagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListStoredImagesRequest& operator=(ListStoredImagesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListStoredImagesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListStoredImagesRequest* internal_default_instance() {
    return reinterpret_cast<const ListStoredImagesRequest*>(
               &_ListStoredImagesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListStoredImagesRequest& a, ListStoredImagesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListStoredImagesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListStoredImagesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListStoredImagesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListStoredImagesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListStoredImagesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListStoredImagesRequest& from) {
    ListStoredImagesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListStoredImagesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListStoredImagesRequest";
  }
  protected:
  explicit ListStoredImagesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kQueryFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.DataQueryParams query = 2;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::bosdyn::api::DataQueryParams& query() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataQueryParams* release_query();
  ::bosdyn::api::DataQueryParams* mutable_query();
  void set_allocated_query(::bosdyn::api::DataQueryParams* query);
  private:
  const ::bosdyn::api::DataQueryParams& _internal_query() const;
  ::bosdyn::api::DataQueryParams* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::bosdyn::api::DataQueryParams* query);
  ::bosdyn::api::DataQueryParams* unsafe_arena_release_query();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListStoredImagesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::DataQueryParams* query_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListStoredImagesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListStoredImagesResponse) */ {
 public:
  inline ListStoredImagesResponse() : ListStoredImagesResponse(nullptr) {}
  ~ListStoredImagesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListStoredImagesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListStoredImagesResponse(const ListStoredImagesResponse& from);
  ListStoredImagesResponse(ListStoredImagesResponse&& from) noexcept
    : ListStoredImagesResponse() {
    *this = ::std::move(from);
  }

  inline ListStoredImagesResponse& operator=(const ListStoredImagesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListStoredImagesResponse& operator=(ListStoredImagesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListStoredImagesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListStoredImagesResponse* internal_default_instance() {
    return reinterpret_cast<const ListStoredImagesResponse*>(
               &_ListStoredImagesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ListStoredImagesResponse& a, ListStoredImagesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListStoredImagesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListStoredImagesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListStoredImagesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListStoredImagesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListStoredImagesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListStoredImagesResponse& from) {
    ListStoredImagesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListStoredImagesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListStoredImagesResponse";
  }
  protected:
  explicit ListStoredImagesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataIdsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.DataIdentifier data_ids = 2;
  int data_ids_size() const;
  private:
  int _internal_data_ids_size() const;
  public:
  void clear_data_ids();
  ::bosdyn::api::DataIdentifier* mutable_data_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >*
      mutable_data_ids();
  private:
  const ::bosdyn::api::DataIdentifier& _internal_data_ids(int index) const;
  ::bosdyn::api::DataIdentifier* _internal_add_data_ids();
  public:
  const ::bosdyn::api::DataIdentifier& data_ids(int index) const;
  ::bosdyn::api::DataIdentifier* add_data_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >&
      data_ids() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListStoredImagesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier > data_ids_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListStoredMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListStoredMetadataRequest) */ {
 public:
  inline ListStoredMetadataRequest() : ListStoredMetadataRequest(nullptr) {}
  ~ListStoredMetadataRequest() override;
  explicit PROTOBUF_CONSTEXPR ListStoredMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListStoredMetadataRequest(const ListStoredMetadataRequest& from);
  ListStoredMetadataRequest(ListStoredMetadataRequest&& from) noexcept
    : ListStoredMetadataRequest() {
    *this = ::std::move(from);
  }

  inline ListStoredMetadataRequest& operator=(const ListStoredMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListStoredMetadataRequest& operator=(ListStoredMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListStoredMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListStoredMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const ListStoredMetadataRequest*>(
               &_ListStoredMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ListStoredMetadataRequest& a, ListStoredMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListStoredMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListStoredMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListStoredMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListStoredMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListStoredMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListStoredMetadataRequest& from) {
    ListStoredMetadataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListStoredMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListStoredMetadataRequest";
  }
  protected:
  explicit ListStoredMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kQueryFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.DataQueryParams query = 2;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::bosdyn::api::DataQueryParams& query() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataQueryParams* release_query();
  ::bosdyn::api::DataQueryParams* mutable_query();
  void set_allocated_query(::bosdyn::api::DataQueryParams* query);
  private:
  const ::bosdyn::api::DataQueryParams& _internal_query() const;
  ::bosdyn::api::DataQueryParams* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::bosdyn::api::DataQueryParams* query);
  ::bosdyn::api::DataQueryParams* unsafe_arena_release_query();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListStoredMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::DataQueryParams* query_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListStoredMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListStoredMetadataResponse) */ {
 public:
  inline ListStoredMetadataResponse() : ListStoredMetadataResponse(nullptr) {}
  ~ListStoredMetadataResponse() override;
  explicit PROTOBUF_CONSTEXPR ListStoredMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListStoredMetadataResponse(const ListStoredMetadataResponse& from);
  ListStoredMetadataResponse(ListStoredMetadataResponse&& from) noexcept
    : ListStoredMetadataResponse() {
    *this = ::std::move(from);
  }

  inline ListStoredMetadataResponse& operator=(const ListStoredMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListStoredMetadataResponse& operator=(ListStoredMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListStoredMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListStoredMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const ListStoredMetadataResponse*>(
               &_ListStoredMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ListStoredMetadataResponse& a, ListStoredMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListStoredMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListStoredMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListStoredMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListStoredMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListStoredMetadataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListStoredMetadataResponse& from) {
    ListStoredMetadataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListStoredMetadataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListStoredMetadataResponse";
  }
  protected:
  explicit ListStoredMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataIdsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.DataIdentifier data_ids = 2;
  int data_ids_size() const;
  private:
  int _internal_data_ids_size() const;
  public:
  void clear_data_ids();
  ::bosdyn::api::DataIdentifier* mutable_data_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >*
      mutable_data_ids();
  private:
  const ::bosdyn::api::DataIdentifier& _internal_data_ids(int index) const;
  ::bosdyn::api::DataIdentifier* _internal_add_data_ids();
  public:
  const ::bosdyn::api::DataIdentifier& data_ids(int index) const;
  ::bosdyn::api::DataIdentifier* add_data_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >&
      data_ids() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListStoredMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier > data_ids_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListStoredAlertDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListStoredAlertDataRequest) */ {
 public:
  inline ListStoredAlertDataRequest() : ListStoredAlertDataRequest(nullptr) {}
  ~ListStoredAlertDataRequest() override;
  explicit PROTOBUF_CONSTEXPR ListStoredAlertDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListStoredAlertDataRequest(const ListStoredAlertDataRequest& from);
  ListStoredAlertDataRequest(ListStoredAlertDataRequest&& from) noexcept
    : ListStoredAlertDataRequest() {
    *this = ::std::move(from);
  }

  inline ListStoredAlertDataRequest& operator=(const ListStoredAlertDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListStoredAlertDataRequest& operator=(ListStoredAlertDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListStoredAlertDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListStoredAlertDataRequest* internal_default_instance() {
    return reinterpret_cast<const ListStoredAlertDataRequest*>(
               &_ListStoredAlertDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ListStoredAlertDataRequest& a, ListStoredAlertDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListStoredAlertDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListStoredAlertDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListStoredAlertDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListStoredAlertDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListStoredAlertDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListStoredAlertDataRequest& from) {
    ListStoredAlertDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListStoredAlertDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListStoredAlertDataRequest";
  }
  protected:
  explicit ListStoredAlertDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kQueryFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.DataQueryParams query = 2;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::bosdyn::api::DataQueryParams& query() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataQueryParams* release_query();
  ::bosdyn::api::DataQueryParams* mutable_query();
  void set_allocated_query(::bosdyn::api::DataQueryParams* query);
  private:
  const ::bosdyn::api::DataQueryParams& _internal_query() const;
  ::bosdyn::api::DataQueryParams* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::bosdyn::api::DataQueryParams* query);
  ::bosdyn::api::DataQueryParams* unsafe_arena_release_query();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListStoredAlertDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::DataQueryParams* query_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListStoredAlertDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListStoredAlertDataResponse) */ {
 public:
  inline ListStoredAlertDataResponse() : ListStoredAlertDataResponse(nullptr) {}
  ~ListStoredAlertDataResponse() override;
  explicit PROTOBUF_CONSTEXPR ListStoredAlertDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListStoredAlertDataResponse(const ListStoredAlertDataResponse& from);
  ListStoredAlertDataResponse(ListStoredAlertDataResponse&& from) noexcept
    : ListStoredAlertDataResponse() {
    *this = ::std::move(from);
  }

  inline ListStoredAlertDataResponse& operator=(const ListStoredAlertDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListStoredAlertDataResponse& operator=(ListStoredAlertDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListStoredAlertDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListStoredAlertDataResponse* internal_default_instance() {
    return reinterpret_cast<const ListStoredAlertDataResponse*>(
               &_ListStoredAlertDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ListStoredAlertDataResponse& a, ListStoredAlertDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListStoredAlertDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListStoredAlertDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListStoredAlertDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListStoredAlertDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListStoredAlertDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListStoredAlertDataResponse& from) {
    ListStoredAlertDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListStoredAlertDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListStoredAlertDataResponse";
  }
  protected:
  explicit ListStoredAlertDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataIdsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.DataIdentifier data_ids = 2;
  int data_ids_size() const;
  private:
  int _internal_data_ids_size() const;
  public:
  void clear_data_ids();
  ::bosdyn::api::DataIdentifier* mutable_data_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >*
      mutable_data_ids();
  private:
  const ::bosdyn::api::DataIdentifier& _internal_data_ids(int index) const;
  ::bosdyn::api::DataIdentifier* _internal_add_data_ids();
  public:
  const ::bosdyn::api::DataIdentifier& data_ids(int index) const;
  ::bosdyn::api::DataIdentifier* add_data_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >&
      data_ids() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListStoredAlertDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier > data_ids_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListStoredDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListStoredDataRequest) */ {
 public:
  inline ListStoredDataRequest() : ListStoredDataRequest(nullptr) {}
  ~ListStoredDataRequest() override;
  explicit PROTOBUF_CONSTEXPR ListStoredDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListStoredDataRequest(const ListStoredDataRequest& from);
  ListStoredDataRequest(ListStoredDataRequest&& from) noexcept
    : ListStoredDataRequest() {
    *this = ::std::move(from);
  }

  inline ListStoredDataRequest& operator=(const ListStoredDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListStoredDataRequest& operator=(ListStoredDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListStoredDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListStoredDataRequest* internal_default_instance() {
    return reinterpret_cast<const ListStoredDataRequest*>(
               &_ListStoredDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ListStoredDataRequest& a, ListStoredDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListStoredDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListStoredDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListStoredDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListStoredDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListStoredDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListStoredDataRequest& from) {
    ListStoredDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListStoredDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListStoredDataRequest";
  }
  protected:
  explicit ListStoredDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kQueryFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.DataQueryParams query = 2;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::bosdyn::api::DataQueryParams& query() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataQueryParams* release_query();
  ::bosdyn::api::DataQueryParams* mutable_query();
  void set_allocated_query(::bosdyn::api::DataQueryParams* query);
  private:
  const ::bosdyn::api::DataQueryParams& _internal_query() const;
  ::bosdyn::api::DataQueryParams* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::bosdyn::api::DataQueryParams* query);
  ::bosdyn::api::DataQueryParams* unsafe_arena_release_query();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListStoredDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::DataQueryParams* query_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListStoredDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListStoredDataResponse) */ {
 public:
  inline ListStoredDataResponse() : ListStoredDataResponse(nullptr) {}
  ~ListStoredDataResponse() override;
  explicit PROTOBUF_CONSTEXPR ListStoredDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListStoredDataResponse(const ListStoredDataResponse& from);
  ListStoredDataResponse(ListStoredDataResponse&& from) noexcept
    : ListStoredDataResponse() {
    *this = ::std::move(from);
  }

  inline ListStoredDataResponse& operator=(const ListStoredDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListStoredDataResponse& operator=(ListStoredDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListStoredDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListStoredDataResponse* internal_default_instance() {
    return reinterpret_cast<const ListStoredDataResponse*>(
               &_ListStoredDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ListStoredDataResponse& a, ListStoredDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListStoredDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListStoredDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListStoredDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListStoredDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListStoredDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListStoredDataResponse& from) {
    ListStoredDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListStoredDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListStoredDataResponse";
  }
  protected:
  explicit ListStoredDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataIdsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.DataIdentifier data_ids = 2;
  int data_ids_size() const;
  private:
  int _internal_data_ids_size() const;
  public:
  void clear_data_ids();
  ::bosdyn::api::DataIdentifier* mutable_data_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >*
      mutable_data_ids();
  private:
  const ::bosdyn::api::DataIdentifier& _internal_data_ids(int index) const;
  ::bosdyn::api::DataIdentifier* _internal_add_data_ids();
  public:
  const ::bosdyn::api::DataIdentifier& data_ids(int index) const;
  ::bosdyn::api::DataIdentifier* add_data_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >&
      data_ids() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListStoredDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier > data_ids_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ActionIdQuery

// repeated .bosdyn.api.CaptureActionId action_ids = 1;
inline int ActionIdQuery::_internal_action_ids_size() const {
  return _impl_.action_ids_.size();
}
inline int ActionIdQuery::action_ids_size() const {
  return _internal_action_ids_size();
}
inline ::bosdyn::api::CaptureActionId* ActionIdQuery::mutable_action_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ActionIdQuery.action_ids)
  return _impl_.action_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CaptureActionId >*
ActionIdQuery::mutable_action_ids() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ActionIdQuery.action_ids)
  return &_impl_.action_ids_;
}
inline const ::bosdyn::api::CaptureActionId& ActionIdQuery::_internal_action_ids(int index) const {
  return _impl_.action_ids_.Get(index);
}
inline const ::bosdyn::api::CaptureActionId& ActionIdQuery::action_ids(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ActionIdQuery.action_ids)
  return _internal_action_ids(index);
}
inline ::bosdyn::api::CaptureActionId* ActionIdQuery::_internal_add_action_ids() {
  return _impl_.action_ids_.Add();
}
inline ::bosdyn::api::CaptureActionId* ActionIdQuery::add_action_ids() {
  ::bosdyn::api::CaptureActionId* _add = _internal_add_action_ids();
  // @@protoc_insertion_point(field_add:bosdyn.api.ActionIdQuery.action_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CaptureActionId >&
ActionIdQuery::action_ids() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ActionIdQuery.action_ids)
  return _impl_.action_ids_;
}

// -------------------------------------------------------------------

// TimeRangeQuery

// .google.protobuf.Timestamp from_timestamp = 1;
inline bool TimeRangeQuery::_internal_has_from_timestamp() const {
  return this != internal_default_instance() && _impl_.from_timestamp_ != nullptr;
}
inline bool TimeRangeQuery::has_from_timestamp() const {
  return _internal_has_from_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TimeRangeQuery::_internal_from_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.from_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TimeRangeQuery::from_timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TimeRangeQuery.from_timestamp)
  return _internal_from_timestamp();
}
inline void TimeRangeQuery::unsafe_arena_set_allocated_from_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* from_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.from_timestamp_);
  }
  _impl_.from_timestamp_ = from_timestamp;
  if (from_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.TimeRangeQuery.from_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRangeQuery::release_from_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.from_timestamp_;
  _impl_.from_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRangeQuery::unsafe_arena_release_from_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.TimeRangeQuery.from_timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.from_timestamp_;
  _impl_.from_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRangeQuery::_internal_mutable_from_timestamp() {
  
  if (_impl_.from_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.from_timestamp_ = p;
  }
  return _impl_.from_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRangeQuery::mutable_from_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_from_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.TimeRangeQuery.from_timestamp)
  return _msg;
}
inline void TimeRangeQuery::set_allocated_from_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* from_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.from_timestamp_);
  }
  if (from_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(from_timestamp));
    if (message_arena != submessage_arena) {
      from_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.from_timestamp_ = from_timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.TimeRangeQuery.from_timestamp)
}

// .google.protobuf.Timestamp to_timestamp = 2;
inline bool TimeRangeQuery::_internal_has_to_timestamp() const {
  return this != internal_default_instance() && _impl_.to_timestamp_ != nullptr;
}
inline bool TimeRangeQuery::has_to_timestamp() const {
  return _internal_has_to_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TimeRangeQuery::_internal_to_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.to_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TimeRangeQuery::to_timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TimeRangeQuery.to_timestamp)
  return _internal_to_timestamp();
}
inline void TimeRangeQuery::unsafe_arena_set_allocated_to_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* to_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.to_timestamp_);
  }
  _impl_.to_timestamp_ = to_timestamp;
  if (to_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.TimeRangeQuery.to_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRangeQuery::release_to_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.to_timestamp_;
  _impl_.to_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRangeQuery::unsafe_arena_release_to_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.TimeRangeQuery.to_timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.to_timestamp_;
  _impl_.to_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRangeQuery::_internal_mutable_to_timestamp() {
  
  if (_impl_.to_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.to_timestamp_ = p;
  }
  return _impl_.to_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRangeQuery::mutable_to_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_to_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.TimeRangeQuery.to_timestamp)
  return _msg;
}
inline void TimeRangeQuery::set_allocated_to_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* to_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.to_timestamp_);
  }
  if (to_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(to_timestamp));
    if (message_arena != submessage_arena) {
      to_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.to_timestamp_ = to_timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.TimeRangeQuery.to_timestamp)
}

// -------------------------------------------------------------------

// DataQueryParams

// .bosdyn.api.TimeRangeQuery time_range = 1;
inline bool DataQueryParams::_internal_has_time_range() const {
  return query_case() == kTimeRange;
}
inline bool DataQueryParams::has_time_range() const {
  return _internal_has_time_range();
}
inline void DataQueryParams::set_has_time_range() {
  _impl_._oneof_case_[0] = kTimeRange;
}
inline void DataQueryParams::clear_time_range() {
  if (_internal_has_time_range()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_.time_range_;
    }
    clear_has_query();
  }
}
inline ::bosdyn::api::TimeRangeQuery* DataQueryParams::release_time_range() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataQueryParams.time_range)
  if (_internal_has_time_range()) {
    clear_has_query();
    ::bosdyn::api::TimeRangeQuery* temp = _impl_.query_.time_range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_.time_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::TimeRangeQuery& DataQueryParams::_internal_time_range() const {
  return _internal_has_time_range()
      ? *_impl_.query_.time_range_
      : reinterpret_cast< ::bosdyn::api::TimeRangeQuery&>(::bosdyn::api::_TimeRangeQuery_default_instance_);
}
inline const ::bosdyn::api::TimeRangeQuery& DataQueryParams::time_range() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataQueryParams.time_range)
  return _internal_time_range();
}
inline ::bosdyn::api::TimeRangeQuery* DataQueryParams::unsafe_arena_release_time_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.DataQueryParams.time_range)
  if (_internal_has_time_range()) {
    clear_has_query();
    ::bosdyn::api::TimeRangeQuery* temp = _impl_.query_.time_range_;
    _impl_.query_.time_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataQueryParams::unsafe_arena_set_allocated_time_range(::bosdyn::api::TimeRangeQuery* time_range) {
  clear_query();
  if (time_range) {
    set_has_time_range();
    _impl_.query_.time_range_ = time_range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DataQueryParams.time_range)
}
inline ::bosdyn::api::TimeRangeQuery* DataQueryParams::_internal_mutable_time_range() {
  if (!_internal_has_time_range()) {
    clear_query();
    set_has_time_range();
    _impl_.query_.time_range_ = CreateMaybeMessage< ::bosdyn::api::TimeRangeQuery >(GetArenaForAllocation());
  }
  return _impl_.query_.time_range_;
}
inline ::bosdyn::api::TimeRangeQuery* DataQueryParams::mutable_time_range() {
  ::bosdyn::api::TimeRangeQuery* _msg = _internal_mutable_time_range();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataQueryParams.time_range)
  return _msg;
}

// .bosdyn.api.ActionIdQuery action_ids = 2;
inline bool DataQueryParams::_internal_has_action_ids() const {
  return query_case() == kActionIds;
}
inline bool DataQueryParams::has_action_ids() const {
  return _internal_has_action_ids();
}
inline void DataQueryParams::set_has_action_ids() {
  _impl_._oneof_case_[0] = kActionIds;
}
inline void DataQueryParams::clear_action_ids() {
  if (_internal_has_action_ids()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_.action_ids_;
    }
    clear_has_query();
  }
}
inline ::bosdyn::api::ActionIdQuery* DataQueryParams::release_action_ids() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataQueryParams.action_ids)
  if (_internal_has_action_ids()) {
    clear_has_query();
    ::bosdyn::api::ActionIdQuery* temp = _impl_.query_.action_ids_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_.action_ids_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::ActionIdQuery& DataQueryParams::_internal_action_ids() const {
  return _internal_has_action_ids()
      ? *_impl_.query_.action_ids_
      : reinterpret_cast< ::bosdyn::api::ActionIdQuery&>(::bosdyn::api::_ActionIdQuery_default_instance_);
}
inline const ::bosdyn::api::ActionIdQuery& DataQueryParams::action_ids() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataQueryParams.action_ids)
  return _internal_action_ids();
}
inline ::bosdyn::api::ActionIdQuery* DataQueryParams::unsafe_arena_release_action_ids() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.DataQueryParams.action_ids)
  if (_internal_has_action_ids()) {
    clear_has_query();
    ::bosdyn::api::ActionIdQuery* temp = _impl_.query_.action_ids_;
    _impl_.query_.action_ids_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataQueryParams::unsafe_arena_set_allocated_action_ids(::bosdyn::api::ActionIdQuery* action_ids) {
  clear_query();
  if (action_ids) {
    set_has_action_ids();
    _impl_.query_.action_ids_ = action_ids;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DataQueryParams.action_ids)
}
inline ::bosdyn::api::ActionIdQuery* DataQueryParams::_internal_mutable_action_ids() {
  if (!_internal_has_action_ids()) {
    clear_query();
    set_has_action_ids();
    _impl_.query_.action_ids_ = CreateMaybeMessage< ::bosdyn::api::ActionIdQuery >(GetArenaForAllocation());
  }
  return _impl_.query_.action_ids_;
}
inline ::bosdyn::api::ActionIdQuery* DataQueryParams::mutable_action_ids() {
  ::bosdyn::api::ActionIdQuery* _msg = _internal_mutable_action_ids();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataQueryParams.action_ids)
  return _msg;
}

inline bool DataQueryParams::has_query() const {
  return query_case() != QUERY_NOT_SET;
}
inline void DataQueryParams::clear_has_query() {
  _impl_._oneof_case_[0] = QUERY_NOT_SET;
}
inline DataQueryParams::QueryCase DataQueryParams::query_case() const {
  return DataQueryParams::QueryCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StoreImageRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool StoreImageRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool StoreImageRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& StoreImageRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& StoreImageRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreImageRequest.header)
  return _internal_header();
}
inline void StoreImageRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StoreImageRequest.header)
}
inline ::bosdyn::api::RequestHeader* StoreImageRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* StoreImageRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreImageRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* StoreImageRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* StoreImageRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreImageRequest.header)
  return _msg;
}
inline void StoreImageRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreImageRequest.header)
}

// .bosdyn.api.ImageCapture image = 2;
inline bool StoreImageRequest::_internal_has_image() const {
  return this != internal_default_instance() && _impl_.image_ != nullptr;
}
inline bool StoreImageRequest::has_image() const {
  return _internal_has_image();
}
inline const ::bosdyn::api::ImageCapture& StoreImageRequest::_internal_image() const {
  const ::bosdyn::api::ImageCapture* p = _impl_.image_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ImageCapture&>(
      ::bosdyn::api::_ImageCapture_default_instance_);
}
inline const ::bosdyn::api::ImageCapture& StoreImageRequest::image() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreImageRequest.image)
  return _internal_image();
}
inline void StoreImageRequest::unsafe_arena_set_allocated_image(
    ::bosdyn::api::ImageCapture* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  _impl_.image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StoreImageRequest.image)
}
inline ::bosdyn::api::ImageCapture* StoreImageRequest::release_image() {
  
  ::bosdyn::api::ImageCapture* temp = _impl_.image_;
  _impl_.image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ImageCapture* StoreImageRequest::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreImageRequest.image)
  
  ::bosdyn::api::ImageCapture* temp = _impl_.image_;
  _impl_.image_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ImageCapture* StoreImageRequest::_internal_mutable_image() {
  
  if (_impl_.image_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ImageCapture>(GetArenaForAllocation());
    _impl_.image_ = p;
  }
  return _impl_.image_;
}
inline ::bosdyn::api::ImageCapture* StoreImageRequest::mutable_image() {
  ::bosdyn::api::ImageCapture* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreImageRequest.image)
  return _msg;
}
inline void StoreImageRequest::set_allocated_image(::bosdyn::api::ImageCapture* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image));
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_ = image;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreImageRequest.image)
}

// .bosdyn.api.DataIdentifier data_id = 3;
inline bool StoreImageRequest::_internal_has_data_id() const {
  return this != internal_default_instance() && _impl_.data_id_ != nullptr;
}
inline bool StoreImageRequest::has_data_id() const {
  return _internal_has_data_id();
}
inline const ::bosdyn::api::DataIdentifier& StoreImageRequest::_internal_data_id() const {
  const ::bosdyn::api::DataIdentifier* p = _impl_.data_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataIdentifier&>(
      ::bosdyn::api::_DataIdentifier_default_instance_);
}
inline const ::bosdyn::api::DataIdentifier& StoreImageRequest::data_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreImageRequest.data_id)
  return _internal_data_id();
}
inline void StoreImageRequest::unsafe_arena_set_allocated_data_id(
    ::bosdyn::api::DataIdentifier* data_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_id_);
  }
  _impl_.data_id_ = data_id;
  if (data_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StoreImageRequest.data_id)
}
inline ::bosdyn::api::DataIdentifier* StoreImageRequest::release_data_id() {
  
  ::bosdyn::api::DataIdentifier* temp = _impl_.data_id_;
  _impl_.data_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataIdentifier* StoreImageRequest::unsafe_arena_release_data_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreImageRequest.data_id)
  
  ::bosdyn::api::DataIdentifier* temp = _impl_.data_id_;
  _impl_.data_id_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataIdentifier* StoreImageRequest::_internal_mutable_data_id() {
  
  if (_impl_.data_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataIdentifier>(GetArenaForAllocation());
    _impl_.data_id_ = p;
  }
  return _impl_.data_id_;
}
inline ::bosdyn::api::DataIdentifier* StoreImageRequest::mutable_data_id() {
  ::bosdyn::api::DataIdentifier* _msg = _internal_mutable_data_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreImageRequest.data_id)
  return _msg;
}
inline void StoreImageRequest::set_allocated_data_id(::bosdyn::api::DataIdentifier* data_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_id_);
  }
  if (data_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_id));
    if (message_arena != submessage_arena) {
      data_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_id_ = data_id;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreImageRequest.data_id)
}

// -------------------------------------------------------------------

// StoreImageResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool StoreImageResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool StoreImageResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& StoreImageResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& StoreImageResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreImageResponse.header)
  return _internal_header();
}
inline void StoreImageResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StoreImageResponse.header)
}
inline ::bosdyn::api::ResponseHeader* StoreImageResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StoreImageResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreImageResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StoreImageResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* StoreImageResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreImageResponse.header)
  return _msg;
}
inline void StoreImageResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreImageResponse.header)
}

// -------------------------------------------------------------------

// StoreMetadataRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool StoreMetadataRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool StoreMetadataRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& StoreMetadataRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& StoreMetadataRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreMetadataRequest.header)
  return _internal_header();
}
inline void StoreMetadataRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StoreMetadataRequest.header)
}
inline ::bosdyn::api::RequestHeader* StoreMetadataRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* StoreMetadataRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreMetadataRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* StoreMetadataRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* StoreMetadataRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreMetadataRequest.header)
  return _msg;
}
inline void StoreMetadataRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreMetadataRequest.header)
}

// .bosdyn.api.AssociatedMetadata metadata = 2;
inline bool StoreMetadataRequest::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool StoreMetadataRequest::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::bosdyn::api::AssociatedMetadata& StoreMetadataRequest::_internal_metadata() const {
  const ::bosdyn::api::AssociatedMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::AssociatedMetadata&>(
      ::bosdyn::api::_AssociatedMetadata_default_instance_);
}
inline const ::bosdyn::api::AssociatedMetadata& StoreMetadataRequest::metadata() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreMetadataRequest.metadata)
  return _internal_metadata();
}
inline void StoreMetadataRequest::unsafe_arena_set_allocated_metadata(
    ::bosdyn::api::AssociatedMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StoreMetadataRequest.metadata)
}
inline ::bosdyn::api::AssociatedMetadata* StoreMetadataRequest::release_metadata() {
  
  ::bosdyn::api::AssociatedMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::AssociatedMetadata* StoreMetadataRequest::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreMetadataRequest.metadata)
  
  ::bosdyn::api::AssociatedMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::bosdyn::api::AssociatedMetadata* StoreMetadataRequest::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::AssociatedMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::bosdyn::api::AssociatedMetadata* StoreMetadataRequest::mutable_metadata() {
  ::bosdyn::api::AssociatedMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreMetadataRequest.metadata)
  return _msg;
}
inline void StoreMetadataRequest::set_allocated_metadata(::bosdyn::api::AssociatedMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreMetadataRequest.metadata)
}

// .bosdyn.api.DataIdentifier data_id = 3;
inline bool StoreMetadataRequest::_internal_has_data_id() const {
  return this != internal_default_instance() && _impl_.data_id_ != nullptr;
}
inline bool StoreMetadataRequest::has_data_id() const {
  return _internal_has_data_id();
}
inline const ::bosdyn::api::DataIdentifier& StoreMetadataRequest::_internal_data_id() const {
  const ::bosdyn::api::DataIdentifier* p = _impl_.data_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataIdentifier&>(
      ::bosdyn::api::_DataIdentifier_default_instance_);
}
inline const ::bosdyn::api::DataIdentifier& StoreMetadataRequest::data_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreMetadataRequest.data_id)
  return _internal_data_id();
}
inline void StoreMetadataRequest::unsafe_arena_set_allocated_data_id(
    ::bosdyn::api::DataIdentifier* data_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_id_);
  }
  _impl_.data_id_ = data_id;
  if (data_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StoreMetadataRequest.data_id)
}
inline ::bosdyn::api::DataIdentifier* StoreMetadataRequest::release_data_id() {
  
  ::bosdyn::api::DataIdentifier* temp = _impl_.data_id_;
  _impl_.data_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataIdentifier* StoreMetadataRequest::unsafe_arena_release_data_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreMetadataRequest.data_id)
  
  ::bosdyn::api::DataIdentifier* temp = _impl_.data_id_;
  _impl_.data_id_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataIdentifier* StoreMetadataRequest::_internal_mutable_data_id() {
  
  if (_impl_.data_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataIdentifier>(GetArenaForAllocation());
    _impl_.data_id_ = p;
  }
  return _impl_.data_id_;
}
inline ::bosdyn::api::DataIdentifier* StoreMetadataRequest::mutable_data_id() {
  ::bosdyn::api::DataIdentifier* _msg = _internal_mutable_data_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreMetadataRequest.data_id)
  return _msg;
}
inline void StoreMetadataRequest::set_allocated_data_id(::bosdyn::api::DataIdentifier* data_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_id_);
  }
  if (data_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_id));
    if (message_arena != submessage_arena) {
      data_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_id_ = data_id;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreMetadataRequest.data_id)
}

// -------------------------------------------------------------------

// StoreMetadataResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool StoreMetadataResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool StoreMetadataResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& StoreMetadataResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& StoreMetadataResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreMetadataResponse.header)
  return _internal_header();
}
inline void StoreMetadataResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StoreMetadataResponse.header)
}
inline ::bosdyn::api::ResponseHeader* StoreMetadataResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StoreMetadataResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreMetadataResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StoreMetadataResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* StoreMetadataResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreMetadataResponse.header)
  return _msg;
}
inline void StoreMetadataResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreMetadataResponse.header)
}

// -------------------------------------------------------------------

// StoreAlertDataRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool StoreAlertDataRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool StoreAlertDataRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& StoreAlertDataRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& StoreAlertDataRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreAlertDataRequest.header)
  return _internal_header();
}
inline void StoreAlertDataRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StoreAlertDataRequest.header)
}
inline ::bosdyn::api::RequestHeader* StoreAlertDataRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* StoreAlertDataRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreAlertDataRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* StoreAlertDataRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* StoreAlertDataRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreAlertDataRequest.header)
  return _msg;
}
inline void StoreAlertDataRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreAlertDataRequest.header)
}

// .bosdyn.api.AssociatedAlertData alert_data = 2;
inline bool StoreAlertDataRequest::_internal_has_alert_data() const {
  return this != internal_default_instance() && _impl_.alert_data_ != nullptr;
}
inline bool StoreAlertDataRequest::has_alert_data() const {
  return _internal_has_alert_data();
}
inline const ::bosdyn::api::AssociatedAlertData& StoreAlertDataRequest::_internal_alert_data() const {
  const ::bosdyn::api::AssociatedAlertData* p = _impl_.alert_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::AssociatedAlertData&>(
      ::bosdyn::api::_AssociatedAlertData_default_instance_);
}
inline const ::bosdyn::api::AssociatedAlertData& StoreAlertDataRequest::alert_data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreAlertDataRequest.alert_data)
  return _internal_alert_data();
}
inline void StoreAlertDataRequest::unsafe_arena_set_allocated_alert_data(
    ::bosdyn::api::AssociatedAlertData* alert_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alert_data_);
  }
  _impl_.alert_data_ = alert_data;
  if (alert_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StoreAlertDataRequest.alert_data)
}
inline ::bosdyn::api::AssociatedAlertData* StoreAlertDataRequest::release_alert_data() {
  
  ::bosdyn::api::AssociatedAlertData* temp = _impl_.alert_data_;
  _impl_.alert_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::AssociatedAlertData* StoreAlertDataRequest::unsafe_arena_release_alert_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreAlertDataRequest.alert_data)
  
  ::bosdyn::api::AssociatedAlertData* temp = _impl_.alert_data_;
  _impl_.alert_data_ = nullptr;
  return temp;
}
inline ::bosdyn::api::AssociatedAlertData* StoreAlertDataRequest::_internal_mutable_alert_data() {
  
  if (_impl_.alert_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::AssociatedAlertData>(GetArenaForAllocation());
    _impl_.alert_data_ = p;
  }
  return _impl_.alert_data_;
}
inline ::bosdyn::api::AssociatedAlertData* StoreAlertDataRequest::mutable_alert_data() {
  ::bosdyn::api::AssociatedAlertData* _msg = _internal_mutable_alert_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreAlertDataRequest.alert_data)
  return _msg;
}
inline void StoreAlertDataRequest::set_allocated_alert_data(::bosdyn::api::AssociatedAlertData* alert_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alert_data_);
  }
  if (alert_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alert_data));
    if (message_arena != submessage_arena) {
      alert_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alert_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.alert_data_ = alert_data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreAlertDataRequest.alert_data)
}

// .bosdyn.api.DataIdentifier data_id = 3;
inline bool StoreAlertDataRequest::_internal_has_data_id() const {
  return this != internal_default_instance() && _impl_.data_id_ != nullptr;
}
inline bool StoreAlertDataRequest::has_data_id() const {
  return _internal_has_data_id();
}
inline const ::bosdyn::api::DataIdentifier& StoreAlertDataRequest::_internal_data_id() const {
  const ::bosdyn::api::DataIdentifier* p = _impl_.data_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataIdentifier&>(
      ::bosdyn::api::_DataIdentifier_default_instance_);
}
inline const ::bosdyn::api::DataIdentifier& StoreAlertDataRequest::data_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreAlertDataRequest.data_id)
  return _internal_data_id();
}
inline void StoreAlertDataRequest::unsafe_arena_set_allocated_data_id(
    ::bosdyn::api::DataIdentifier* data_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_id_);
  }
  _impl_.data_id_ = data_id;
  if (data_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StoreAlertDataRequest.data_id)
}
inline ::bosdyn::api::DataIdentifier* StoreAlertDataRequest::release_data_id() {
  
  ::bosdyn::api::DataIdentifier* temp = _impl_.data_id_;
  _impl_.data_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataIdentifier* StoreAlertDataRequest::unsafe_arena_release_data_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreAlertDataRequest.data_id)
  
  ::bosdyn::api::DataIdentifier* temp = _impl_.data_id_;
  _impl_.data_id_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataIdentifier* StoreAlertDataRequest::_internal_mutable_data_id() {
  
  if (_impl_.data_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataIdentifier>(GetArenaForAllocation());
    _impl_.data_id_ = p;
  }
  return _impl_.data_id_;
}
inline ::bosdyn::api::DataIdentifier* StoreAlertDataRequest::mutable_data_id() {
  ::bosdyn::api::DataIdentifier* _msg = _internal_mutable_data_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreAlertDataRequest.data_id)
  return _msg;
}
inline void StoreAlertDataRequest::set_allocated_data_id(::bosdyn::api::DataIdentifier* data_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_id_);
  }
  if (data_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_id));
    if (message_arena != submessage_arena) {
      data_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_id_ = data_id;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreAlertDataRequest.data_id)
}

// -------------------------------------------------------------------

// StoreAlertDataResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool StoreAlertDataResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool StoreAlertDataResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& StoreAlertDataResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& StoreAlertDataResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreAlertDataResponse.header)
  return _internal_header();
}
inline void StoreAlertDataResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StoreAlertDataResponse.header)
}
inline ::bosdyn::api::ResponseHeader* StoreAlertDataResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StoreAlertDataResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreAlertDataResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StoreAlertDataResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* StoreAlertDataResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreAlertDataResponse.header)
  return _msg;
}
inline void StoreAlertDataResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreAlertDataResponse.header)
}

// -------------------------------------------------------------------

// StoreDataRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool StoreDataRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool StoreDataRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& StoreDataRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& StoreDataRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreDataRequest.header)
  return _internal_header();
}
inline void StoreDataRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StoreDataRequest.header)
}
inline ::bosdyn::api::RequestHeader* StoreDataRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* StoreDataRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreDataRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* StoreDataRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* StoreDataRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreDataRequest.header)
  return _msg;
}
inline void StoreDataRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreDataRequest.header)
}

// bytes data = 2;
inline void StoreDataRequest::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& StoreDataRequest::data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreDataRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreDataRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.StoreDataRequest.data)
}
inline std::string* StoreDataRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreDataRequest.data)
  return _s;
}
inline const std::string& StoreDataRequest::_internal_data() const {
  return _impl_.data_.Get();
}
inline void StoreDataRequest::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreDataRequest::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* StoreDataRequest::release_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreDataRequest.data)
  return _impl_.data_.Release();
}
inline void StoreDataRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreDataRequest.data)
}

// .bosdyn.api.DataIdentifier data_id = 3;
inline bool StoreDataRequest::_internal_has_data_id() const {
  return this != internal_default_instance() && _impl_.data_id_ != nullptr;
}
inline bool StoreDataRequest::has_data_id() const {
  return _internal_has_data_id();
}
inline const ::bosdyn::api::DataIdentifier& StoreDataRequest::_internal_data_id() const {
  const ::bosdyn::api::DataIdentifier* p = _impl_.data_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataIdentifier&>(
      ::bosdyn::api::_DataIdentifier_default_instance_);
}
inline const ::bosdyn::api::DataIdentifier& StoreDataRequest::data_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreDataRequest.data_id)
  return _internal_data_id();
}
inline void StoreDataRequest::unsafe_arena_set_allocated_data_id(
    ::bosdyn::api::DataIdentifier* data_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_id_);
  }
  _impl_.data_id_ = data_id;
  if (data_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StoreDataRequest.data_id)
}
inline ::bosdyn::api::DataIdentifier* StoreDataRequest::release_data_id() {
  
  ::bosdyn::api::DataIdentifier* temp = _impl_.data_id_;
  _impl_.data_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataIdentifier* StoreDataRequest::unsafe_arena_release_data_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreDataRequest.data_id)
  
  ::bosdyn::api::DataIdentifier* temp = _impl_.data_id_;
  _impl_.data_id_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataIdentifier* StoreDataRequest::_internal_mutable_data_id() {
  
  if (_impl_.data_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataIdentifier>(GetArenaForAllocation());
    _impl_.data_id_ = p;
  }
  return _impl_.data_id_;
}
inline ::bosdyn::api::DataIdentifier* StoreDataRequest::mutable_data_id() {
  ::bosdyn::api::DataIdentifier* _msg = _internal_mutable_data_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreDataRequest.data_id)
  return _msg;
}
inline void StoreDataRequest::set_allocated_data_id(::bosdyn::api::DataIdentifier* data_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_id_);
  }
  if (data_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_id));
    if (message_arena != submessage_arena) {
      data_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_id_ = data_id;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreDataRequest.data_id)
}

// string file_extension = 4;
inline void StoreDataRequest::clear_file_extension() {
  _impl_.file_extension_.ClearToEmpty();
}
inline const std::string& StoreDataRequest::file_extension() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreDataRequest.file_extension)
  return _internal_file_extension();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreDataRequest::set_file_extension(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_extension_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.StoreDataRequest.file_extension)
}
inline std::string* StoreDataRequest::mutable_file_extension() {
  std::string* _s = _internal_mutable_file_extension();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreDataRequest.file_extension)
  return _s;
}
inline const std::string& StoreDataRequest::_internal_file_extension() const {
  return _impl_.file_extension_.Get();
}
inline void StoreDataRequest::_internal_set_file_extension(const std::string& value) {
  
  _impl_.file_extension_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreDataRequest::_internal_mutable_file_extension() {
  
  return _impl_.file_extension_.Mutable(GetArenaForAllocation());
}
inline std::string* StoreDataRequest::release_file_extension() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreDataRequest.file_extension)
  return _impl_.file_extension_.Release();
}
inline void StoreDataRequest::set_allocated_file_extension(std::string* file_extension) {
  if (file_extension != nullptr) {
    
  } else {
    
  }
  _impl_.file_extension_.SetAllocated(file_extension, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_extension_.IsDefault()) {
    _impl_.file_extension_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreDataRequest.file_extension)
}

// -------------------------------------------------------------------

// StoreDataResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool StoreDataResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool StoreDataResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& StoreDataResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& StoreDataResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StoreDataResponse.header)
  return _internal_header();
}
inline void StoreDataResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StoreDataResponse.header)
}
inline ::bosdyn::api::ResponseHeader* StoreDataResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StoreDataResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StoreDataResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StoreDataResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* StoreDataResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StoreDataResponse.header)
  return _msg;
}
inline void StoreDataResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StoreDataResponse.header)
}

// -------------------------------------------------------------------

// ListCaptureActionsRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListCaptureActionsRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListCaptureActionsRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListCaptureActionsRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListCaptureActionsRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListCaptureActionsRequest.header)
  return _internal_header();
}
inline void ListCaptureActionsRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListCaptureActionsRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListCaptureActionsRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListCaptureActionsRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListCaptureActionsRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListCaptureActionsRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ListCaptureActionsRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListCaptureActionsRequest.header)
  return _msg;
}
inline void ListCaptureActionsRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListCaptureActionsRequest.header)
}

// .bosdyn.api.DataQueryParams query = 2;
inline bool ListCaptureActionsRequest::_internal_has_query() const {
  return this != internal_default_instance() && _impl_.query_ != nullptr;
}
inline bool ListCaptureActionsRequest::has_query() const {
  return _internal_has_query();
}
inline void ListCaptureActionsRequest::clear_query() {
  if (GetArenaForAllocation() == nullptr && _impl_.query_ != nullptr) {
    delete _impl_.query_;
  }
  _impl_.query_ = nullptr;
}
inline const ::bosdyn::api::DataQueryParams& ListCaptureActionsRequest::_internal_query() const {
  const ::bosdyn::api::DataQueryParams* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataQueryParams&>(
      ::bosdyn::api::_DataQueryParams_default_instance_);
}
inline const ::bosdyn::api::DataQueryParams& ListCaptureActionsRequest::query() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListCaptureActionsRequest.query)
  return _internal_query();
}
inline void ListCaptureActionsRequest::unsafe_arena_set_allocated_query(
    ::bosdyn::api::DataQueryParams* query) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = query;
  if (query) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListCaptureActionsRequest.query)
}
inline ::bosdyn::api::DataQueryParams* ListCaptureActionsRequest::release_query() {
  
  ::bosdyn::api::DataQueryParams* temp = _impl_.query_;
  _impl_.query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataQueryParams* ListCaptureActionsRequest::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListCaptureActionsRequest.query)
  
  ::bosdyn::api::DataQueryParams* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataQueryParams* ListCaptureActionsRequest::_internal_mutable_query() {
  
  if (_impl_.query_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataQueryParams>(GetArenaForAllocation());
    _impl_.query_ = p;
  }
  return _impl_.query_;
}
inline ::bosdyn::api::DataQueryParams* ListCaptureActionsRequest::mutable_query() {
  ::bosdyn::api::DataQueryParams* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListCaptureActionsRequest.query)
  return _msg;
}
inline void ListCaptureActionsRequest::set_allocated_query(::bosdyn::api::DataQueryParams* query) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.query_;
  }
  if (query) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query);
    if (message_arena != submessage_arena) {
      query = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.query_ = query;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListCaptureActionsRequest.query)
}

// -------------------------------------------------------------------

// ListCaptureActionsResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListCaptureActionsResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListCaptureActionsResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListCaptureActionsResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListCaptureActionsResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListCaptureActionsResponse.header)
  return _internal_header();
}
inline void ListCaptureActionsResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListCaptureActionsResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListCaptureActionsResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListCaptureActionsResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListCaptureActionsResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListCaptureActionsResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ListCaptureActionsResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListCaptureActionsResponse.header)
  return _msg;
}
inline void ListCaptureActionsResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListCaptureActionsResponse.header)
}

// repeated .bosdyn.api.CaptureActionId action_ids = 2;
inline int ListCaptureActionsResponse::_internal_action_ids_size() const {
  return _impl_.action_ids_.size();
}
inline int ListCaptureActionsResponse::action_ids_size() const {
  return _internal_action_ids_size();
}
inline ::bosdyn::api::CaptureActionId* ListCaptureActionsResponse::mutable_action_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListCaptureActionsResponse.action_ids)
  return _impl_.action_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CaptureActionId >*
ListCaptureActionsResponse::mutable_action_ids() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ListCaptureActionsResponse.action_ids)
  return &_impl_.action_ids_;
}
inline const ::bosdyn::api::CaptureActionId& ListCaptureActionsResponse::_internal_action_ids(int index) const {
  return _impl_.action_ids_.Get(index);
}
inline const ::bosdyn::api::CaptureActionId& ListCaptureActionsResponse::action_ids(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListCaptureActionsResponse.action_ids)
  return _internal_action_ids(index);
}
inline ::bosdyn::api::CaptureActionId* ListCaptureActionsResponse::_internal_add_action_ids() {
  return _impl_.action_ids_.Add();
}
inline ::bosdyn::api::CaptureActionId* ListCaptureActionsResponse::add_action_ids() {
  ::bosdyn::api::CaptureActionId* _add = _internal_add_action_ids();
  // @@protoc_insertion_point(field_add:bosdyn.api.ListCaptureActionsResponse.action_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CaptureActionId >&
ListCaptureActionsResponse::action_ids() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ListCaptureActionsResponse.action_ids)
  return _impl_.action_ids_;
}

// -------------------------------------------------------------------

// ListStoredImagesRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListStoredImagesRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListStoredImagesRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListStoredImagesRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListStoredImagesRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListStoredImagesRequest.header)
  return _internal_header();
}
inline void ListStoredImagesRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListStoredImagesRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListStoredImagesRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListStoredImagesRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListStoredImagesRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListStoredImagesRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ListStoredImagesRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListStoredImagesRequest.header)
  return _msg;
}
inline void ListStoredImagesRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListStoredImagesRequest.header)
}

// .bosdyn.api.DataQueryParams query = 2;
inline bool ListStoredImagesRequest::_internal_has_query() const {
  return this != internal_default_instance() && _impl_.query_ != nullptr;
}
inline bool ListStoredImagesRequest::has_query() const {
  return _internal_has_query();
}
inline void ListStoredImagesRequest::clear_query() {
  if (GetArenaForAllocation() == nullptr && _impl_.query_ != nullptr) {
    delete _impl_.query_;
  }
  _impl_.query_ = nullptr;
}
inline const ::bosdyn::api::DataQueryParams& ListStoredImagesRequest::_internal_query() const {
  const ::bosdyn::api::DataQueryParams* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataQueryParams&>(
      ::bosdyn::api::_DataQueryParams_default_instance_);
}
inline const ::bosdyn::api::DataQueryParams& ListStoredImagesRequest::query() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListStoredImagesRequest.query)
  return _internal_query();
}
inline void ListStoredImagesRequest::unsafe_arena_set_allocated_query(
    ::bosdyn::api::DataQueryParams* query) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = query;
  if (query) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListStoredImagesRequest.query)
}
inline ::bosdyn::api::DataQueryParams* ListStoredImagesRequest::release_query() {
  
  ::bosdyn::api::DataQueryParams* temp = _impl_.query_;
  _impl_.query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataQueryParams* ListStoredImagesRequest::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListStoredImagesRequest.query)
  
  ::bosdyn::api::DataQueryParams* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataQueryParams* ListStoredImagesRequest::_internal_mutable_query() {
  
  if (_impl_.query_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataQueryParams>(GetArenaForAllocation());
    _impl_.query_ = p;
  }
  return _impl_.query_;
}
inline ::bosdyn::api::DataQueryParams* ListStoredImagesRequest::mutable_query() {
  ::bosdyn::api::DataQueryParams* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListStoredImagesRequest.query)
  return _msg;
}
inline void ListStoredImagesRequest::set_allocated_query(::bosdyn::api::DataQueryParams* query) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.query_;
  }
  if (query) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query);
    if (message_arena != submessage_arena) {
      query = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.query_ = query;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListStoredImagesRequest.query)
}

// -------------------------------------------------------------------

// ListStoredImagesResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListStoredImagesResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListStoredImagesResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListStoredImagesResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListStoredImagesResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListStoredImagesResponse.header)
  return _internal_header();
}
inline void ListStoredImagesResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListStoredImagesResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListStoredImagesResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListStoredImagesResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListStoredImagesResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListStoredImagesResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ListStoredImagesResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListStoredImagesResponse.header)
  return _msg;
}
inline void ListStoredImagesResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListStoredImagesResponse.header)
}

// repeated .bosdyn.api.DataIdentifier data_ids = 2;
inline int ListStoredImagesResponse::_internal_data_ids_size() const {
  return _impl_.data_ids_.size();
}
inline int ListStoredImagesResponse::data_ids_size() const {
  return _internal_data_ids_size();
}
inline ::bosdyn::api::DataIdentifier* ListStoredImagesResponse::mutable_data_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListStoredImagesResponse.data_ids)
  return _impl_.data_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >*
ListStoredImagesResponse::mutable_data_ids() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ListStoredImagesResponse.data_ids)
  return &_impl_.data_ids_;
}
inline const ::bosdyn::api::DataIdentifier& ListStoredImagesResponse::_internal_data_ids(int index) const {
  return _impl_.data_ids_.Get(index);
}
inline const ::bosdyn::api::DataIdentifier& ListStoredImagesResponse::data_ids(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListStoredImagesResponse.data_ids)
  return _internal_data_ids(index);
}
inline ::bosdyn::api::DataIdentifier* ListStoredImagesResponse::_internal_add_data_ids() {
  return _impl_.data_ids_.Add();
}
inline ::bosdyn::api::DataIdentifier* ListStoredImagesResponse::add_data_ids() {
  ::bosdyn::api::DataIdentifier* _add = _internal_add_data_ids();
  // @@protoc_insertion_point(field_add:bosdyn.api.ListStoredImagesResponse.data_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >&
ListStoredImagesResponse::data_ids() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ListStoredImagesResponse.data_ids)
  return _impl_.data_ids_;
}

// -------------------------------------------------------------------

// ListStoredMetadataRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListStoredMetadataRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListStoredMetadataRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListStoredMetadataRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListStoredMetadataRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListStoredMetadataRequest.header)
  return _internal_header();
}
inline void ListStoredMetadataRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListStoredMetadataRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListStoredMetadataRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListStoredMetadataRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListStoredMetadataRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListStoredMetadataRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ListStoredMetadataRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListStoredMetadataRequest.header)
  return _msg;
}
inline void ListStoredMetadataRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListStoredMetadataRequest.header)
}

// .bosdyn.api.DataQueryParams query = 2;
inline bool ListStoredMetadataRequest::_internal_has_query() const {
  return this != internal_default_instance() && _impl_.query_ != nullptr;
}
inline bool ListStoredMetadataRequest::has_query() const {
  return _internal_has_query();
}
inline void ListStoredMetadataRequest::clear_query() {
  if (GetArenaForAllocation() == nullptr && _impl_.query_ != nullptr) {
    delete _impl_.query_;
  }
  _impl_.query_ = nullptr;
}
inline const ::bosdyn::api::DataQueryParams& ListStoredMetadataRequest::_internal_query() const {
  const ::bosdyn::api::DataQueryParams* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataQueryParams&>(
      ::bosdyn::api::_DataQueryParams_default_instance_);
}
inline const ::bosdyn::api::DataQueryParams& ListStoredMetadataRequest::query() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListStoredMetadataRequest.query)
  return _internal_query();
}
inline void ListStoredMetadataRequest::unsafe_arena_set_allocated_query(
    ::bosdyn::api::DataQueryParams* query) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = query;
  if (query) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListStoredMetadataRequest.query)
}
inline ::bosdyn::api::DataQueryParams* ListStoredMetadataRequest::release_query() {
  
  ::bosdyn::api::DataQueryParams* temp = _impl_.query_;
  _impl_.query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataQueryParams* ListStoredMetadataRequest::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListStoredMetadataRequest.query)
  
  ::bosdyn::api::DataQueryParams* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataQueryParams* ListStoredMetadataRequest::_internal_mutable_query() {
  
  if (_impl_.query_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataQueryParams>(GetArenaForAllocation());
    _impl_.query_ = p;
  }
  return _impl_.query_;
}
inline ::bosdyn::api::DataQueryParams* ListStoredMetadataRequest::mutable_query() {
  ::bosdyn::api::DataQueryParams* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListStoredMetadataRequest.query)
  return _msg;
}
inline void ListStoredMetadataRequest::set_allocated_query(::bosdyn::api::DataQueryParams* query) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.query_;
  }
  if (query) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query);
    if (message_arena != submessage_arena) {
      query = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.query_ = query;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListStoredMetadataRequest.query)
}

// -------------------------------------------------------------------

// ListStoredMetadataResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListStoredMetadataResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListStoredMetadataResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListStoredMetadataResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListStoredMetadataResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListStoredMetadataResponse.header)
  return _internal_header();
}
inline void ListStoredMetadataResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListStoredMetadataResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListStoredMetadataResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListStoredMetadataResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListStoredMetadataResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListStoredMetadataResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ListStoredMetadataResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListStoredMetadataResponse.header)
  return _msg;
}
inline void ListStoredMetadataResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListStoredMetadataResponse.header)
}

// repeated .bosdyn.api.DataIdentifier data_ids = 2;
inline int ListStoredMetadataResponse::_internal_data_ids_size() const {
  return _impl_.data_ids_.size();
}
inline int ListStoredMetadataResponse::data_ids_size() const {
  return _internal_data_ids_size();
}
inline ::bosdyn::api::DataIdentifier* ListStoredMetadataResponse::mutable_data_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListStoredMetadataResponse.data_ids)
  return _impl_.data_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >*
ListStoredMetadataResponse::mutable_data_ids() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ListStoredMetadataResponse.data_ids)
  return &_impl_.data_ids_;
}
inline const ::bosdyn::api::DataIdentifier& ListStoredMetadataResponse::_internal_data_ids(int index) const {
  return _impl_.data_ids_.Get(index);
}
inline const ::bosdyn::api::DataIdentifier& ListStoredMetadataResponse::data_ids(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListStoredMetadataResponse.data_ids)
  return _internal_data_ids(index);
}
inline ::bosdyn::api::DataIdentifier* ListStoredMetadataResponse::_internal_add_data_ids() {
  return _impl_.data_ids_.Add();
}
inline ::bosdyn::api::DataIdentifier* ListStoredMetadataResponse::add_data_ids() {
  ::bosdyn::api::DataIdentifier* _add = _internal_add_data_ids();
  // @@protoc_insertion_point(field_add:bosdyn.api.ListStoredMetadataResponse.data_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >&
ListStoredMetadataResponse::data_ids() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ListStoredMetadataResponse.data_ids)
  return _impl_.data_ids_;
}

// -------------------------------------------------------------------

// ListStoredAlertDataRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListStoredAlertDataRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListStoredAlertDataRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListStoredAlertDataRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListStoredAlertDataRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListStoredAlertDataRequest.header)
  return _internal_header();
}
inline void ListStoredAlertDataRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListStoredAlertDataRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListStoredAlertDataRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListStoredAlertDataRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListStoredAlertDataRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListStoredAlertDataRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ListStoredAlertDataRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListStoredAlertDataRequest.header)
  return _msg;
}
inline void ListStoredAlertDataRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListStoredAlertDataRequest.header)
}

// .bosdyn.api.DataQueryParams query = 2;
inline bool ListStoredAlertDataRequest::_internal_has_query() const {
  return this != internal_default_instance() && _impl_.query_ != nullptr;
}
inline bool ListStoredAlertDataRequest::has_query() const {
  return _internal_has_query();
}
inline void ListStoredAlertDataRequest::clear_query() {
  if (GetArenaForAllocation() == nullptr && _impl_.query_ != nullptr) {
    delete _impl_.query_;
  }
  _impl_.query_ = nullptr;
}
inline const ::bosdyn::api::DataQueryParams& ListStoredAlertDataRequest::_internal_query() const {
  const ::bosdyn::api::DataQueryParams* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataQueryParams&>(
      ::bosdyn::api::_DataQueryParams_default_instance_);
}
inline const ::bosdyn::api::DataQueryParams& ListStoredAlertDataRequest::query() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListStoredAlertDataRequest.query)
  return _internal_query();
}
inline void ListStoredAlertDataRequest::unsafe_arena_set_allocated_query(
    ::bosdyn::api::DataQueryParams* query) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = query;
  if (query) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListStoredAlertDataRequest.query)
}
inline ::bosdyn::api::DataQueryParams* ListStoredAlertDataRequest::release_query() {
  
  ::bosdyn::api::DataQueryParams* temp = _impl_.query_;
  _impl_.query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataQueryParams* ListStoredAlertDataRequest::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListStoredAlertDataRequest.query)
  
  ::bosdyn::api::DataQueryParams* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataQueryParams* ListStoredAlertDataRequest::_internal_mutable_query() {
  
  if (_impl_.query_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataQueryParams>(GetArenaForAllocation());
    _impl_.query_ = p;
  }
  return _impl_.query_;
}
inline ::bosdyn::api::DataQueryParams* ListStoredAlertDataRequest::mutable_query() {
  ::bosdyn::api::DataQueryParams* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListStoredAlertDataRequest.query)
  return _msg;
}
inline void ListStoredAlertDataRequest::set_allocated_query(::bosdyn::api::DataQueryParams* query) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.query_;
  }
  if (query) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query);
    if (message_arena != submessage_arena) {
      query = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.query_ = query;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListStoredAlertDataRequest.query)
}

// -------------------------------------------------------------------

// ListStoredAlertDataResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListStoredAlertDataResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListStoredAlertDataResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListStoredAlertDataResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListStoredAlertDataResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListStoredAlertDataResponse.header)
  return _internal_header();
}
inline void ListStoredAlertDataResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListStoredAlertDataResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListStoredAlertDataResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListStoredAlertDataResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListStoredAlertDataResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListStoredAlertDataResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ListStoredAlertDataResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListStoredAlertDataResponse.header)
  return _msg;
}
inline void ListStoredAlertDataResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListStoredAlertDataResponse.header)
}

// repeated .bosdyn.api.DataIdentifier data_ids = 2;
inline int ListStoredAlertDataResponse::_internal_data_ids_size() const {
  return _impl_.data_ids_.size();
}
inline int ListStoredAlertDataResponse::data_ids_size() const {
  return _internal_data_ids_size();
}
inline ::bosdyn::api::DataIdentifier* ListStoredAlertDataResponse::mutable_data_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListStoredAlertDataResponse.data_ids)
  return _impl_.data_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >*
ListStoredAlertDataResponse::mutable_data_ids() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ListStoredAlertDataResponse.data_ids)
  return &_impl_.data_ids_;
}
inline const ::bosdyn::api::DataIdentifier& ListStoredAlertDataResponse::_internal_data_ids(int index) const {
  return _impl_.data_ids_.Get(index);
}
inline const ::bosdyn::api::DataIdentifier& ListStoredAlertDataResponse::data_ids(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListStoredAlertDataResponse.data_ids)
  return _internal_data_ids(index);
}
inline ::bosdyn::api::DataIdentifier* ListStoredAlertDataResponse::_internal_add_data_ids() {
  return _impl_.data_ids_.Add();
}
inline ::bosdyn::api::DataIdentifier* ListStoredAlertDataResponse::add_data_ids() {
  ::bosdyn::api::DataIdentifier* _add = _internal_add_data_ids();
  // @@protoc_insertion_point(field_add:bosdyn.api.ListStoredAlertDataResponse.data_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >&
ListStoredAlertDataResponse::data_ids() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ListStoredAlertDataResponse.data_ids)
  return _impl_.data_ids_;
}

// -------------------------------------------------------------------

// ListStoredDataRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListStoredDataRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListStoredDataRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListStoredDataRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListStoredDataRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListStoredDataRequest.header)
  return _internal_header();
}
inline void ListStoredDataRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListStoredDataRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListStoredDataRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListStoredDataRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListStoredDataRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListStoredDataRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ListStoredDataRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListStoredDataRequest.header)
  return _msg;
}
inline void ListStoredDataRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListStoredDataRequest.header)
}

// .bosdyn.api.DataQueryParams query = 2;
inline bool ListStoredDataRequest::_internal_has_query() const {
  return this != internal_default_instance() && _impl_.query_ != nullptr;
}
inline bool ListStoredDataRequest::has_query() const {
  return _internal_has_query();
}
inline void ListStoredDataRequest::clear_query() {
  if (GetArenaForAllocation() == nullptr && _impl_.query_ != nullptr) {
    delete _impl_.query_;
  }
  _impl_.query_ = nullptr;
}
inline const ::bosdyn::api::DataQueryParams& ListStoredDataRequest::_internal_query() const {
  const ::bosdyn::api::DataQueryParams* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataQueryParams&>(
      ::bosdyn::api::_DataQueryParams_default_instance_);
}
inline const ::bosdyn::api::DataQueryParams& ListStoredDataRequest::query() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListStoredDataRequest.query)
  return _internal_query();
}
inline void ListStoredDataRequest::unsafe_arena_set_allocated_query(
    ::bosdyn::api::DataQueryParams* query) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = query;
  if (query) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListStoredDataRequest.query)
}
inline ::bosdyn::api::DataQueryParams* ListStoredDataRequest::release_query() {
  
  ::bosdyn::api::DataQueryParams* temp = _impl_.query_;
  _impl_.query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataQueryParams* ListStoredDataRequest::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListStoredDataRequest.query)
  
  ::bosdyn::api::DataQueryParams* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataQueryParams* ListStoredDataRequest::_internal_mutable_query() {
  
  if (_impl_.query_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataQueryParams>(GetArenaForAllocation());
    _impl_.query_ = p;
  }
  return _impl_.query_;
}
inline ::bosdyn::api::DataQueryParams* ListStoredDataRequest::mutable_query() {
  ::bosdyn::api::DataQueryParams* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListStoredDataRequest.query)
  return _msg;
}
inline void ListStoredDataRequest::set_allocated_query(::bosdyn::api::DataQueryParams* query) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.query_;
  }
  if (query) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query);
    if (message_arena != submessage_arena) {
      query = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.query_ = query;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListStoredDataRequest.query)
}

// -------------------------------------------------------------------

// ListStoredDataResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListStoredDataResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListStoredDataResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListStoredDataResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListStoredDataResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListStoredDataResponse.header)
  return _internal_header();
}
inline void ListStoredDataResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListStoredDataResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListStoredDataResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListStoredDataResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListStoredDataResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListStoredDataResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ListStoredDataResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListStoredDataResponse.header)
  return _msg;
}
inline void ListStoredDataResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListStoredDataResponse.header)
}

// repeated .bosdyn.api.DataIdentifier data_ids = 2;
inline int ListStoredDataResponse::_internal_data_ids_size() const {
  return _impl_.data_ids_.size();
}
inline int ListStoredDataResponse::data_ids_size() const {
  return _internal_data_ids_size();
}
inline ::bosdyn::api::DataIdentifier* ListStoredDataResponse::mutable_data_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListStoredDataResponse.data_ids)
  return _impl_.data_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >*
ListStoredDataResponse::mutable_data_ids() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ListStoredDataResponse.data_ids)
  return &_impl_.data_ids_;
}
inline const ::bosdyn::api::DataIdentifier& ListStoredDataResponse::_internal_data_ids(int index) const {
  return _impl_.data_ids_.Get(index);
}
inline const ::bosdyn::api::DataIdentifier& ListStoredDataResponse::data_ids(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListStoredDataResponse.data_ids)
  return _internal_data_ids(index);
}
inline ::bosdyn::api::DataIdentifier* ListStoredDataResponse::_internal_add_data_ids() {
  return _impl_.data_ids_.Add();
}
inline ::bosdyn::api::DataIdentifier* ListStoredDataResponse::add_data_ids() {
  ::bosdyn::api::DataIdentifier* _add = _internal_add_data_ids();
  // @@protoc_insertion_point(field_add:bosdyn.api.ListStoredDataResponse.data_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DataIdentifier >&
ListStoredDataResponse::data_ids() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ListStoredDataResponse.data_ids)
  return _impl_.data_ids_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fdata_5facquisition_5fstore_2eproto
