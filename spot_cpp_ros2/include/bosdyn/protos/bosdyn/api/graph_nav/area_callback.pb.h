// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/graph_nav/area_callback.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/lease.pb.h"
#include "bosdyn/api/graph_nav/nav.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
namespace bosdyn {
namespace api {
namespace graph_nav {
class AreaCallbackError;
struct AreaCallbackErrorDefaultTypeInternal;
extern AreaCallbackErrorDefaultTypeInternal _AreaCallbackError_default_instance_;
class AreaCallbackInformation;
struct AreaCallbackInformationDefaultTypeInternal;
extern AreaCallbackInformationDefaultTypeInternal _AreaCallbackInformation_default_instance_;
class AreaCallbackInformationRequest;
struct AreaCallbackInformationRequestDefaultTypeInternal;
extern AreaCallbackInformationRequestDefaultTypeInternal _AreaCallbackInformationRequest_default_instance_;
class AreaCallbackInformationResponse;
struct AreaCallbackInformationResponseDefaultTypeInternal;
extern AreaCallbackInformationResponseDefaultTypeInternal _AreaCallbackInformationResponse_default_instance_;
class BeginCallbackRequest;
struct BeginCallbackRequestDefaultTypeInternal;
extern BeginCallbackRequestDefaultTypeInternal _BeginCallbackRequest_default_instance_;
class BeginCallbackResponse;
struct BeginCallbackResponseDefaultTypeInternal;
extern BeginCallbackResponseDefaultTypeInternal _BeginCallbackResponse_default_instance_;
class BeginControlRequest;
struct BeginControlRequestDefaultTypeInternal;
extern BeginControlRequestDefaultTypeInternal _BeginControlRequest_default_instance_;
class BeginControlResponse;
struct BeginControlResponseDefaultTypeInternal;
extern BeginControlResponseDefaultTypeInternal _BeginControlResponse_default_instance_;
class EndCallbackRequest;
struct EndCallbackRequestDefaultTypeInternal;
extern EndCallbackRequestDefaultTypeInternal _EndCallbackRequest_default_instance_;
class EndCallbackResponse;
struct EndCallbackResponseDefaultTypeInternal;
extern EndCallbackResponseDefaultTypeInternal _EndCallbackResponse_default_instance_;
class RegionInformation;
struct RegionInformationDefaultTypeInternal;
extern RegionInformationDefaultTypeInternal _RegionInformation_default_instance_;
class UpdateCallbackRequest;
struct UpdateCallbackRequestDefaultTypeInternal;
extern UpdateCallbackRequestDefaultTypeInternal _UpdateCallbackRequest_default_instance_;
class UpdateCallbackResponse;
struct UpdateCallbackResponseDefaultTypeInternal;
extern UpdateCallbackResponseDefaultTypeInternal _UpdateCallbackResponse_default_instance_;
class UpdateCallbackResponse_Complete;
struct UpdateCallbackResponse_CompleteDefaultTypeInternal;
extern UpdateCallbackResponse_CompleteDefaultTypeInternal _UpdateCallbackResponse_Complete_default_instance_;
class UpdateCallbackResponse_Error;
struct UpdateCallbackResponse_ErrorDefaultTypeInternal;
extern UpdateCallbackResponse_ErrorDefaultTypeInternal _UpdateCallbackResponse_Error_default_instance_;
class UpdateCallbackResponse_NavPolicy;
struct UpdateCallbackResponse_NavPolicyDefaultTypeInternal;
extern UpdateCallbackResponse_NavPolicyDefaultTypeInternal _UpdateCallbackResponse_NavPolicy_default_instance_;
}  // namespace graph_nav
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::graph_nav::AreaCallbackError* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::AreaCallbackError>(Arena*);
template<> ::bosdyn::api::graph_nav::AreaCallbackInformation* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::AreaCallbackInformation>(Arena*);
template<> ::bosdyn::api::graph_nav::AreaCallbackInformationRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::AreaCallbackInformationRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::AreaCallbackInformationResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::AreaCallbackInformationResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::BeginCallbackRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::BeginCallbackRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::BeginCallbackResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::BeginCallbackResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::BeginControlRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::BeginControlRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::BeginControlResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::BeginControlResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::EndCallbackRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::EndCallbackRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::EndCallbackResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::EndCallbackResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::RegionInformation* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::RegionInformation>(Arena*);
template<> ::bosdyn::api::graph_nav::UpdateCallbackRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::UpdateCallbackRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::UpdateCallbackResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::UpdateCallbackResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete>(Arena*);
template<> ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::UpdateCallbackResponse_Error>(Arena*);
template<> ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {
namespace graph_nav {

enum AreaCallbackError_CallError : int {
  AreaCallbackError_CallError_ERROR_UNKNOWN = 0,
  AreaCallbackError_CallError_ERROR_TRANSPORT = 1,
  AreaCallbackError_CallError_ERROR_RESPONSE = 2,
  AreaCallbackError_CallError_ERROR_SERVICE = 3,
  AreaCallbackError_CallError_AreaCallbackError_CallError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AreaCallbackError_CallError_AreaCallbackError_CallError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AreaCallbackError_CallError_IsValid(int value);
constexpr AreaCallbackError_CallError AreaCallbackError_CallError_CallError_MIN = AreaCallbackError_CallError_ERROR_UNKNOWN;
constexpr AreaCallbackError_CallError AreaCallbackError_CallError_CallError_MAX = AreaCallbackError_CallError_ERROR_SERVICE;
constexpr int AreaCallbackError_CallError_CallError_ARRAYSIZE = AreaCallbackError_CallError_CallError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AreaCallbackError_CallError_descriptor();
template<typename T>
inline const std::string& AreaCallbackError_CallError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AreaCallbackError_CallError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AreaCallbackError_CallError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AreaCallbackError_CallError_descriptor(), enum_t_value);
}
inline bool AreaCallbackError_CallError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AreaCallbackError_CallError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AreaCallbackError_CallError>(
    AreaCallbackError_CallError_descriptor(), name, value);
}
enum BeginCallbackResponse_Status : int {
  BeginCallbackResponse_Status_STATUS_UNKNOWN = 0,
  BeginCallbackResponse_Status_STATUS_OK = 1,
  BeginCallbackResponse_Status_STATUS_INVALID_CONFIGURATION = 2,
  BeginCallbackResponse_Status_STATUS_EXPIRED_END_TIME = 3,
  BeginCallbackResponse_Status_BeginCallbackResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BeginCallbackResponse_Status_BeginCallbackResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BeginCallbackResponse_Status_IsValid(int value);
constexpr BeginCallbackResponse_Status BeginCallbackResponse_Status_Status_MIN = BeginCallbackResponse_Status_STATUS_UNKNOWN;
constexpr BeginCallbackResponse_Status BeginCallbackResponse_Status_Status_MAX = BeginCallbackResponse_Status_STATUS_EXPIRED_END_TIME;
constexpr int BeginCallbackResponse_Status_Status_ARRAYSIZE = BeginCallbackResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BeginCallbackResponse_Status_descriptor();
template<typename T>
inline const std::string& BeginCallbackResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BeginCallbackResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BeginCallbackResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BeginCallbackResponse_Status_descriptor(), enum_t_value);
}
inline bool BeginCallbackResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BeginCallbackResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BeginCallbackResponse_Status>(
    BeginCallbackResponse_Status_descriptor(), name, value);
}
enum BeginControlResponse_Status : int {
  BeginControlResponse_Status_STATUS_UNKNOWN = 0,
  BeginControlResponse_Status_STATUS_OK = 1,
  BeginControlResponse_Status_STATUS_INVALID_COMMAND_ID = 2,
  BeginControlResponse_Status_STATUS_MISSING_LEASE_RESOURCES = 3,
  BeginControlResponse_Status_STATUS_LEASE_ERROR = 4,
  BeginControlResponse_Status_BeginControlResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BeginControlResponse_Status_BeginControlResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BeginControlResponse_Status_IsValid(int value);
constexpr BeginControlResponse_Status BeginControlResponse_Status_Status_MIN = BeginControlResponse_Status_STATUS_UNKNOWN;
constexpr BeginControlResponse_Status BeginControlResponse_Status_Status_MAX = BeginControlResponse_Status_STATUS_LEASE_ERROR;
constexpr int BeginControlResponse_Status_Status_ARRAYSIZE = BeginControlResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BeginControlResponse_Status_descriptor();
template<typename T>
inline const std::string& BeginControlResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BeginControlResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BeginControlResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BeginControlResponse_Status_descriptor(), enum_t_value);
}
inline bool BeginControlResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BeginControlResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BeginControlResponse_Status>(
    BeginControlResponse_Status_descriptor(), name, value);
}
enum UpdateCallbackRequest_Stage : int {
  UpdateCallbackRequest_Stage_STAGE_UNKNOWN = 0,
  UpdateCallbackRequest_Stage_STAGE_TO_START = 1,
  UpdateCallbackRequest_Stage_STAGE_AT_START = 2,
  UpdateCallbackRequest_Stage_STAGE_TO_END = 3,
  UpdateCallbackRequest_Stage_STAGE_AT_END = 4,
  UpdateCallbackRequest_Stage_UpdateCallbackRequest_Stage_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UpdateCallbackRequest_Stage_UpdateCallbackRequest_Stage_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UpdateCallbackRequest_Stage_IsValid(int value);
constexpr UpdateCallbackRequest_Stage UpdateCallbackRequest_Stage_Stage_MIN = UpdateCallbackRequest_Stage_STAGE_UNKNOWN;
constexpr UpdateCallbackRequest_Stage UpdateCallbackRequest_Stage_Stage_MAX = UpdateCallbackRequest_Stage_STAGE_AT_END;
constexpr int UpdateCallbackRequest_Stage_Stage_ARRAYSIZE = UpdateCallbackRequest_Stage_Stage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateCallbackRequest_Stage_descriptor();
template<typename T>
inline const std::string& UpdateCallbackRequest_Stage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UpdateCallbackRequest_Stage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UpdateCallbackRequest_Stage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UpdateCallbackRequest_Stage_descriptor(), enum_t_value);
}
inline bool UpdateCallbackRequest_Stage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UpdateCallbackRequest_Stage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UpdateCallbackRequest_Stage>(
    UpdateCallbackRequest_Stage_descriptor(), name, value);
}
enum UpdateCallbackResponse_NavPolicy_Option : int {
  UpdateCallbackResponse_NavPolicy_Option_OPTION_UNKNOWN = 0,
  UpdateCallbackResponse_NavPolicy_Option_OPTION_CONTINUE = 1,
  UpdateCallbackResponse_NavPolicy_Option_OPTION_STOP = 2,
  UpdateCallbackResponse_NavPolicy_Option_OPTION_CONTROL = 3,
  UpdateCallbackResponse_NavPolicy_Option_UpdateCallbackResponse_NavPolicy_Option_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UpdateCallbackResponse_NavPolicy_Option_UpdateCallbackResponse_NavPolicy_Option_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UpdateCallbackResponse_NavPolicy_Option_IsValid(int value);
constexpr UpdateCallbackResponse_NavPolicy_Option UpdateCallbackResponse_NavPolicy_Option_Option_MIN = UpdateCallbackResponse_NavPolicy_Option_OPTION_UNKNOWN;
constexpr UpdateCallbackResponse_NavPolicy_Option UpdateCallbackResponse_NavPolicy_Option_Option_MAX = UpdateCallbackResponse_NavPolicy_Option_OPTION_CONTROL;
constexpr int UpdateCallbackResponse_NavPolicy_Option_Option_ARRAYSIZE = UpdateCallbackResponse_NavPolicy_Option_Option_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateCallbackResponse_NavPolicy_Option_descriptor();
template<typename T>
inline const std::string& UpdateCallbackResponse_NavPolicy_Option_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UpdateCallbackResponse_NavPolicy_Option>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UpdateCallbackResponse_NavPolicy_Option_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UpdateCallbackResponse_NavPolicy_Option_descriptor(), enum_t_value);
}
inline bool UpdateCallbackResponse_NavPolicy_Option_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UpdateCallbackResponse_NavPolicy_Option* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UpdateCallbackResponse_NavPolicy_Option>(
    UpdateCallbackResponse_NavPolicy_Option_descriptor(), name, value);
}
enum UpdateCallbackResponse_Error_ErrorType : int {
  UpdateCallbackResponse_Error_ErrorType_ERROR_UNKNOWN = 0,
  UpdateCallbackResponse_Error_ErrorType_ERROR_BLOCKED = 1,
  UpdateCallbackResponse_Error_ErrorType_ERROR_CALLBACK_FAILED = 2,
  UpdateCallbackResponse_Error_ErrorType_ERROR_LEASE = 3,
  UpdateCallbackResponse_Error_ErrorType_ERROR_TIMED_OUT = 4,
  UpdateCallbackResponse_Error_ErrorType_UpdateCallbackResponse_Error_ErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UpdateCallbackResponse_Error_ErrorType_UpdateCallbackResponse_Error_ErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UpdateCallbackResponse_Error_ErrorType_IsValid(int value);
constexpr UpdateCallbackResponse_Error_ErrorType UpdateCallbackResponse_Error_ErrorType_ErrorType_MIN = UpdateCallbackResponse_Error_ErrorType_ERROR_UNKNOWN;
constexpr UpdateCallbackResponse_Error_ErrorType UpdateCallbackResponse_Error_ErrorType_ErrorType_MAX = UpdateCallbackResponse_Error_ErrorType_ERROR_TIMED_OUT;
constexpr int UpdateCallbackResponse_Error_ErrorType_ErrorType_ARRAYSIZE = UpdateCallbackResponse_Error_ErrorType_ErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateCallbackResponse_Error_ErrorType_descriptor();
template<typename T>
inline const std::string& UpdateCallbackResponse_Error_ErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UpdateCallbackResponse_Error_ErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UpdateCallbackResponse_Error_ErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UpdateCallbackResponse_Error_ErrorType_descriptor(), enum_t_value);
}
inline bool UpdateCallbackResponse_Error_ErrorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UpdateCallbackResponse_Error_ErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UpdateCallbackResponse_Error_ErrorType>(
    UpdateCallbackResponse_Error_ErrorType_descriptor(), name, value);
}
enum UpdateCallbackResponse_Status : int {
  UpdateCallbackResponse_Status_STATUS_UNKNOWN = 0,
  UpdateCallbackResponse_Status_STATUS_OK = 1,
  UpdateCallbackResponse_Status_STATUS_INVALID_COMMAND_ID = 2,
  UpdateCallbackResponse_Status_STATUS_EXPIRED_END_TIME = 3,
  UpdateCallbackResponse_Status_UpdateCallbackResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UpdateCallbackResponse_Status_UpdateCallbackResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UpdateCallbackResponse_Status_IsValid(int value);
constexpr UpdateCallbackResponse_Status UpdateCallbackResponse_Status_Status_MIN = UpdateCallbackResponse_Status_STATUS_UNKNOWN;
constexpr UpdateCallbackResponse_Status UpdateCallbackResponse_Status_Status_MAX = UpdateCallbackResponse_Status_STATUS_EXPIRED_END_TIME;
constexpr int UpdateCallbackResponse_Status_Status_ARRAYSIZE = UpdateCallbackResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateCallbackResponse_Status_descriptor();
template<typename T>
inline const std::string& UpdateCallbackResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UpdateCallbackResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UpdateCallbackResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UpdateCallbackResponse_Status_descriptor(), enum_t_value);
}
inline bool UpdateCallbackResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UpdateCallbackResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UpdateCallbackResponse_Status>(
    UpdateCallbackResponse_Status_descriptor(), name, value);
}
enum EndCallbackResponse_Status : int {
  EndCallbackResponse_Status_STATUS_UNKNOWN = 0,
  EndCallbackResponse_Status_STATUS_OK = 1,
  EndCallbackResponse_Status_STATUS_INVALID_COMMAND_ID = 2,
  EndCallbackResponse_Status_STATUS_SHUTDOWN_CALLBACK_FAILED = 3,
  EndCallbackResponse_Status_EndCallbackResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EndCallbackResponse_Status_EndCallbackResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EndCallbackResponse_Status_IsValid(int value);
constexpr EndCallbackResponse_Status EndCallbackResponse_Status_Status_MIN = EndCallbackResponse_Status_STATUS_UNKNOWN;
constexpr EndCallbackResponse_Status EndCallbackResponse_Status_Status_MAX = EndCallbackResponse_Status_STATUS_SHUTDOWN_CALLBACK_FAILED;
constexpr int EndCallbackResponse_Status_Status_ARRAYSIZE = EndCallbackResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EndCallbackResponse_Status_descriptor();
template<typename T>
inline const std::string& EndCallbackResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EndCallbackResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EndCallbackResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EndCallbackResponse_Status_descriptor(), enum_t_value);
}
inline bool EndCallbackResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EndCallbackResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EndCallbackResponse_Status>(
    EndCallbackResponse_Status_descriptor(), name, value);
}
// ===================================================================

class AreaCallbackError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.AreaCallbackError) */ {
 public:
  inline AreaCallbackError() : AreaCallbackError(nullptr) {}
  ~AreaCallbackError() override;
  explicit PROTOBUF_CONSTEXPR AreaCallbackError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AreaCallbackError(const AreaCallbackError& from);
  AreaCallbackError(AreaCallbackError&& from) noexcept
    : AreaCallbackError() {
    *this = ::std::move(from);
  }

  inline AreaCallbackError& operator=(const AreaCallbackError& from) {
    CopyFrom(from);
    return *this;
  }
  inline AreaCallbackError& operator=(AreaCallbackError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AreaCallbackError& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseErrorCase {
    kBeginCallback = 3,
    kBeginControl = 4,
    kUpdateCallback = 5,
    kEndCallback = 6,
    RESPONSE_ERROR_NOT_SET = 0,
  };

  static inline const AreaCallbackError* internal_default_instance() {
    return reinterpret_cast<const AreaCallbackError*>(
               &_AreaCallbackError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AreaCallbackError& a, AreaCallbackError& b) {
    a.Swap(&b);
  }
  inline void Swap(AreaCallbackError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AreaCallbackError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AreaCallbackError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AreaCallbackError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AreaCallbackError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AreaCallbackError& from) {
    AreaCallbackError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AreaCallbackError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.AreaCallbackError";
  }
  protected:
  explicit AreaCallbackError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AreaCallbackError_CallError CallError;
  static constexpr CallError ERROR_UNKNOWN =
    AreaCallbackError_CallError_ERROR_UNKNOWN;
  static constexpr CallError ERROR_TRANSPORT =
    AreaCallbackError_CallError_ERROR_TRANSPORT;
  static constexpr CallError ERROR_RESPONSE =
    AreaCallbackError_CallError_ERROR_RESPONSE;
  static constexpr CallError ERROR_SERVICE =
    AreaCallbackError_CallError_ERROR_SERVICE;
  static inline bool CallError_IsValid(int value) {
    return AreaCallbackError_CallError_IsValid(value);
  }
  static constexpr CallError CallError_MIN =
    AreaCallbackError_CallError_CallError_MIN;
  static constexpr CallError CallError_MAX =
    AreaCallbackError_CallError_CallError_MAX;
  static constexpr int CallError_ARRAYSIZE =
    AreaCallbackError_CallError_CallError_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CallError_descriptor() {
    return AreaCallbackError_CallError_descriptor();
  }
  template<typename T>
  static inline const std::string& CallError_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CallError>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CallError_Name.");
    return AreaCallbackError_CallError_Name(enum_t_value);
  }
  static inline bool CallError_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CallError* value) {
    return AreaCallbackError_CallError_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kErrorFieldNumber = 2,
    kBeginCallbackFieldNumber = 3,
    kBeginControlFieldNumber = 4,
    kUpdateCallbackFieldNumber = 5,
    kEndCallbackFieldNumber = 6,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // .bosdyn.api.graph_nav.AreaCallbackError.CallError error = 2;
  void clear_error();
  ::bosdyn::api::graph_nav::AreaCallbackError_CallError error() const;
  void set_error(::bosdyn::api::graph_nav::AreaCallbackError_CallError value);
  private:
  ::bosdyn::api::graph_nav::AreaCallbackError_CallError _internal_error() const;
  void _internal_set_error(::bosdyn::api::graph_nav::AreaCallbackError_CallError value);
  public:

  // .bosdyn.api.graph_nav.BeginCallbackResponse begin_callback = 3;
  bool has_begin_callback() const;
  private:
  bool _internal_has_begin_callback() const;
  public:
  void clear_begin_callback();
  const ::bosdyn::api::graph_nav::BeginCallbackResponse& begin_callback() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::BeginCallbackResponse* release_begin_callback();
  ::bosdyn::api::graph_nav::BeginCallbackResponse* mutable_begin_callback();
  void set_allocated_begin_callback(::bosdyn::api::graph_nav::BeginCallbackResponse* begin_callback);
  private:
  const ::bosdyn::api::graph_nav::BeginCallbackResponse& _internal_begin_callback() const;
  ::bosdyn::api::graph_nav::BeginCallbackResponse* _internal_mutable_begin_callback();
  public:
  void unsafe_arena_set_allocated_begin_callback(
      ::bosdyn::api::graph_nav::BeginCallbackResponse* begin_callback);
  ::bosdyn::api::graph_nav::BeginCallbackResponse* unsafe_arena_release_begin_callback();

  // .bosdyn.api.graph_nav.BeginControlResponse begin_control = 4;
  bool has_begin_control() const;
  private:
  bool _internal_has_begin_control() const;
  public:
  void clear_begin_control();
  const ::bosdyn::api::graph_nav::BeginControlResponse& begin_control() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::BeginControlResponse* release_begin_control();
  ::bosdyn::api::graph_nav::BeginControlResponse* mutable_begin_control();
  void set_allocated_begin_control(::bosdyn::api::graph_nav::BeginControlResponse* begin_control);
  private:
  const ::bosdyn::api::graph_nav::BeginControlResponse& _internal_begin_control() const;
  ::bosdyn::api::graph_nav::BeginControlResponse* _internal_mutable_begin_control();
  public:
  void unsafe_arena_set_allocated_begin_control(
      ::bosdyn::api::graph_nav::BeginControlResponse* begin_control);
  ::bosdyn::api::graph_nav::BeginControlResponse* unsafe_arena_release_begin_control();

  // .bosdyn.api.graph_nav.UpdateCallbackResponse update_callback = 5;
  bool has_update_callback() const;
  private:
  bool _internal_has_update_callback() const;
  public:
  void clear_update_callback();
  const ::bosdyn::api::graph_nav::UpdateCallbackResponse& update_callback() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::UpdateCallbackResponse* release_update_callback();
  ::bosdyn::api::graph_nav::UpdateCallbackResponse* mutable_update_callback();
  void set_allocated_update_callback(::bosdyn::api::graph_nav::UpdateCallbackResponse* update_callback);
  private:
  const ::bosdyn::api::graph_nav::UpdateCallbackResponse& _internal_update_callback() const;
  ::bosdyn::api::graph_nav::UpdateCallbackResponse* _internal_mutable_update_callback();
  public:
  void unsafe_arena_set_allocated_update_callback(
      ::bosdyn::api::graph_nav::UpdateCallbackResponse* update_callback);
  ::bosdyn::api::graph_nav::UpdateCallbackResponse* unsafe_arena_release_update_callback();

  // .bosdyn.api.graph_nav.EndCallbackResponse end_callback = 6;
  bool has_end_callback() const;
  private:
  bool _internal_has_end_callback() const;
  public:
  void clear_end_callback();
  const ::bosdyn::api::graph_nav::EndCallbackResponse& end_callback() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::EndCallbackResponse* release_end_callback();
  ::bosdyn::api::graph_nav::EndCallbackResponse* mutable_end_callback();
  void set_allocated_end_callback(::bosdyn::api::graph_nav::EndCallbackResponse* end_callback);
  private:
  const ::bosdyn::api::graph_nav::EndCallbackResponse& _internal_end_callback() const;
  ::bosdyn::api::graph_nav::EndCallbackResponse* _internal_mutable_end_callback();
  public:
  void unsafe_arena_set_allocated_end_callback(
      ::bosdyn::api::graph_nav::EndCallbackResponse* end_callback);
  ::bosdyn::api::graph_nav::EndCallbackResponse* unsafe_arena_release_end_callback();

  void clear_response_error();
  ResponseErrorCase response_error_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.AreaCallbackError)
 private:
  class _Internal;
  void set_has_begin_callback();
  void set_has_begin_control();
  void set_has_update_callback();
  void set_has_end_callback();

  inline bool has_response_error() const;
  inline void clear_has_response_error();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    int error_;
    union ResponseErrorUnion {
      constexpr ResponseErrorUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::graph_nav::BeginCallbackResponse* begin_callback_;
      ::bosdyn::api::graph_nav::BeginControlResponse* begin_control_;
      ::bosdyn::api::graph_nav::UpdateCallbackResponse* update_callback_;
      ::bosdyn::api::graph_nav::EndCallbackResponse* end_callback_;
    } response_error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
};
// -------------------------------------------------------------------

class AreaCallbackInformationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.AreaCallbackInformationRequest) */ {
 public:
  inline AreaCallbackInformationRequest() : AreaCallbackInformationRequest(nullptr) {}
  ~AreaCallbackInformationRequest() override;
  explicit PROTOBUF_CONSTEXPR AreaCallbackInformationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AreaCallbackInformationRequest(const AreaCallbackInformationRequest& from);
  AreaCallbackInformationRequest(AreaCallbackInformationRequest&& from) noexcept
    : AreaCallbackInformationRequest() {
    *this = ::std::move(from);
  }

  inline AreaCallbackInformationRequest& operator=(const AreaCallbackInformationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AreaCallbackInformationRequest& operator=(AreaCallbackInformationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AreaCallbackInformationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AreaCallbackInformationRequest* internal_default_instance() {
    return reinterpret_cast<const AreaCallbackInformationRequest*>(
               &_AreaCallbackInformationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AreaCallbackInformationRequest& a, AreaCallbackInformationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AreaCallbackInformationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AreaCallbackInformationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AreaCallbackInformationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AreaCallbackInformationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AreaCallbackInformationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AreaCallbackInformationRequest& from) {
    AreaCallbackInformationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AreaCallbackInformationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.AreaCallbackInformationRequest";
  }
  protected:
  explicit AreaCallbackInformationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.AreaCallbackInformationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
};
// -------------------------------------------------------------------

class AreaCallbackInformation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.AreaCallbackInformation) */ {
 public:
  inline AreaCallbackInformation() : AreaCallbackInformation(nullptr) {}
  ~AreaCallbackInformation() override;
  explicit PROTOBUF_CONSTEXPR AreaCallbackInformation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AreaCallbackInformation(const AreaCallbackInformation& from);
  AreaCallbackInformation(AreaCallbackInformation&& from) noexcept
    : AreaCallbackInformation() {
    *this = ::std::move(from);
  }

  inline AreaCallbackInformation& operator=(const AreaCallbackInformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline AreaCallbackInformation& operator=(AreaCallbackInformation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AreaCallbackInformation& default_instance() {
    return *internal_default_instance();
  }
  static inline const AreaCallbackInformation* internal_default_instance() {
    return reinterpret_cast<const AreaCallbackInformation*>(
               &_AreaCallbackInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AreaCallbackInformation& a, AreaCallbackInformation& b) {
    a.Swap(&b);
  }
  inline void Swap(AreaCallbackInformation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AreaCallbackInformation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AreaCallbackInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AreaCallbackInformation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AreaCallbackInformation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AreaCallbackInformation& from) {
    AreaCallbackInformation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AreaCallbackInformation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.AreaCallbackInformation";
  }
  protected:
  explicit AreaCallbackInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequiredLeaseResourcesFieldNumber = 1,
  };
  // repeated string required_lease_resources = 1;
  int required_lease_resources_size() const;
  private:
  int _internal_required_lease_resources_size() const;
  public:
  void clear_required_lease_resources();
  const std::string& required_lease_resources(int index) const;
  std::string* mutable_required_lease_resources(int index);
  void set_required_lease_resources(int index, const std::string& value);
  void set_required_lease_resources(int index, std::string&& value);
  void set_required_lease_resources(int index, const char* value);
  void set_required_lease_resources(int index, const char* value, size_t size);
  std::string* add_required_lease_resources();
  void add_required_lease_resources(const std::string& value);
  void add_required_lease_resources(std::string&& value);
  void add_required_lease_resources(const char* value);
  void add_required_lease_resources(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& required_lease_resources() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_required_lease_resources();
  private:
  const std::string& _internal_required_lease_resources(int index) const;
  std::string* _internal_add_required_lease_resources();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.AreaCallbackInformation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> required_lease_resources_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
};
// -------------------------------------------------------------------

class AreaCallbackInformationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.AreaCallbackInformationResponse) */ {
 public:
  inline AreaCallbackInformationResponse() : AreaCallbackInformationResponse(nullptr) {}
  ~AreaCallbackInformationResponse() override;
  explicit PROTOBUF_CONSTEXPR AreaCallbackInformationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AreaCallbackInformationResponse(const AreaCallbackInformationResponse& from);
  AreaCallbackInformationResponse(AreaCallbackInformationResponse&& from) noexcept
    : AreaCallbackInformationResponse() {
    *this = ::std::move(from);
  }

  inline AreaCallbackInformationResponse& operator=(const AreaCallbackInformationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AreaCallbackInformationResponse& operator=(AreaCallbackInformationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AreaCallbackInformationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AreaCallbackInformationResponse* internal_default_instance() {
    return reinterpret_cast<const AreaCallbackInformationResponse*>(
               &_AreaCallbackInformationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AreaCallbackInformationResponse& a, AreaCallbackInformationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AreaCallbackInformationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AreaCallbackInformationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AreaCallbackInformationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AreaCallbackInformationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AreaCallbackInformationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AreaCallbackInformationResponse& from) {
    AreaCallbackInformationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AreaCallbackInformationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.AreaCallbackInformationResponse";
  }
  protected:
  explicit AreaCallbackInformationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.AreaCallbackInformation info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::bosdyn::api::graph_nav::AreaCallbackInformation& info() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::AreaCallbackInformation* release_info();
  ::bosdyn::api::graph_nav::AreaCallbackInformation* mutable_info();
  void set_allocated_info(::bosdyn::api::graph_nav::AreaCallbackInformation* info);
  private:
  const ::bosdyn::api::graph_nav::AreaCallbackInformation& _internal_info() const;
  ::bosdyn::api::graph_nav::AreaCallbackInformation* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::bosdyn::api::graph_nav::AreaCallbackInformation* info);
  ::bosdyn::api::graph_nav::AreaCallbackInformation* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.AreaCallbackInformationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::graph_nav::AreaCallbackInformation* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
};
// -------------------------------------------------------------------

class RegionInformation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.RegionInformation) */ {
 public:
  inline RegionInformation() : RegionInformation(nullptr) {}
  ~RegionInformation() override;
  explicit PROTOBUF_CONSTEXPR RegionInformation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionInformation(const RegionInformation& from);
  RegionInformation(RegionInformation&& from) noexcept
    : RegionInformation() {
    *this = ::std::move(from);
  }

  inline RegionInformation& operator=(const RegionInformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionInformation& operator=(RegionInformation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionInformation& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionInformation* internal_default_instance() {
    return reinterpret_cast<const RegionInformation*>(
               &_RegionInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RegionInformation& a, RegionInformation& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionInformation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionInformation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionInformation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionInformation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionInformation& from) {
    RegionInformation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionInformation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.RegionInformation";
  }
  protected:
  explicit RegionInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kRouteFieldNumber = 3,
  };
  // string region_id = 1;
  void clear_region_id();
  const std::string& region_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region_id();
  PROTOBUF_NODISCARD std::string* release_region_id();
  void set_allocated_region_id(std::string* region_id);
  private:
  const std::string& _internal_region_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region_id(const std::string& value);
  std::string* _internal_mutable_region_id();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .bosdyn.api.graph_nav.Route route = 3;
  bool has_route() const;
  private:
  bool _internal_has_route() const;
  public:
  void clear_route();
  const ::bosdyn::api::graph_nav::Route& route() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::Route* release_route();
  ::bosdyn::api::graph_nav::Route* mutable_route();
  void set_allocated_route(::bosdyn::api::graph_nav::Route* route);
  private:
  const ::bosdyn::api::graph_nav::Route& _internal_route() const;
  ::bosdyn::api::graph_nav::Route* _internal_mutable_route();
  public:
  void unsafe_arena_set_allocated_route(
      ::bosdyn::api::graph_nav::Route* route);
  ::bosdyn::api::graph_nav::Route* unsafe_arena_release_route();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.RegionInformation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::bosdyn::api::graph_nav::Route* route_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
};
// -------------------------------------------------------------------

class BeginCallbackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.BeginCallbackRequest) */ {
 public:
  inline BeginCallbackRequest() : BeginCallbackRequest(nullptr) {}
  ~BeginCallbackRequest() override;
  explicit PROTOBUF_CONSTEXPR BeginCallbackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeginCallbackRequest(const BeginCallbackRequest& from);
  BeginCallbackRequest(BeginCallbackRequest&& from) noexcept
    : BeginCallbackRequest() {
    *this = ::std::move(from);
  }

  inline BeginCallbackRequest& operator=(const BeginCallbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeginCallbackRequest& operator=(BeginCallbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeginCallbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeginCallbackRequest* internal_default_instance() {
    return reinterpret_cast<const BeginCallbackRequest*>(
               &_BeginCallbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BeginCallbackRequest& a, BeginCallbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BeginCallbackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeginCallbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeginCallbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeginCallbackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeginCallbackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeginCallbackRequest& from) {
    BeginCallbackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeginCallbackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.BeginCallbackRequest";
  }
  protected:
  explicit BeginCallbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kEndTimeFieldNumber = 3,
    kRegionInfoFieldNumber = 4,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .google.protobuf.Timestamp end_time = 3;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // .bosdyn.api.graph_nav.RegionInformation region_info = 4;
  bool has_region_info() const;
  private:
  bool _internal_has_region_info() const;
  public:
  void clear_region_info();
  const ::bosdyn::api::graph_nav::RegionInformation& region_info() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::RegionInformation* release_region_info();
  ::bosdyn::api::graph_nav::RegionInformation* mutable_region_info();
  void set_allocated_region_info(::bosdyn::api::graph_nav::RegionInformation* region_info);
  private:
  const ::bosdyn::api::graph_nav::RegionInformation& _internal_region_info() const;
  ::bosdyn::api::graph_nav::RegionInformation* _internal_mutable_region_info();
  public:
  void unsafe_arena_set_allocated_region_info(
      ::bosdyn::api::graph_nav::RegionInformation* region_info);
  ::bosdyn::api::graph_nav::RegionInformation* unsafe_arena_release_region_info();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.BeginCallbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    ::bosdyn::api::graph_nav::RegionInformation* region_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
};
// -------------------------------------------------------------------

class BeginCallbackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.BeginCallbackResponse) */ {
 public:
  inline BeginCallbackResponse() : BeginCallbackResponse(nullptr) {}
  ~BeginCallbackResponse() override;
  explicit PROTOBUF_CONSTEXPR BeginCallbackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeginCallbackResponse(const BeginCallbackResponse& from);
  BeginCallbackResponse(BeginCallbackResponse&& from) noexcept
    : BeginCallbackResponse() {
    *this = ::std::move(from);
  }

  inline BeginCallbackResponse& operator=(const BeginCallbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeginCallbackResponse& operator=(BeginCallbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeginCallbackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeginCallbackResponse* internal_default_instance() {
    return reinterpret_cast<const BeginCallbackResponse*>(
               &_BeginCallbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BeginCallbackResponse& a, BeginCallbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BeginCallbackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeginCallbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeginCallbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeginCallbackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeginCallbackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeginCallbackResponse& from) {
    BeginCallbackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeginCallbackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.BeginCallbackResponse";
  }
  protected:
  explicit BeginCallbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BeginCallbackResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    BeginCallbackResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    BeginCallbackResponse_Status_STATUS_OK;
  static constexpr Status STATUS_INVALID_CONFIGURATION =
    BeginCallbackResponse_Status_STATUS_INVALID_CONFIGURATION;
  static constexpr Status STATUS_EXPIRED_END_TIME =
    BeginCallbackResponse_Status_STATUS_EXPIRED_END_TIME;
  static inline bool Status_IsValid(int value) {
    return BeginCallbackResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    BeginCallbackResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    BeginCallbackResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    BeginCallbackResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return BeginCallbackResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return BeginCallbackResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return BeginCallbackResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
    kCommandIdFieldNumber = 3,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.BeginCallbackResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::graph_nav::BeginCallbackResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::BeginCallbackResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::BeginCallbackResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::BeginCallbackResponse_Status value);
  public:

  // uint32 command_id = 3;
  void clear_command_id();
  uint32_t command_id() const;
  void set_command_id(uint32_t value);
  private:
  uint32_t _internal_command_id() const;
  void _internal_set_command_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.BeginCallbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    uint32_t command_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
};
// -------------------------------------------------------------------

class BeginControlRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.BeginControlRequest) */ {
 public:
  inline BeginControlRequest() : BeginControlRequest(nullptr) {}
  ~BeginControlRequest() override;
  explicit PROTOBUF_CONSTEXPR BeginControlRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeginControlRequest(const BeginControlRequest& from);
  BeginControlRequest(BeginControlRequest&& from) noexcept
    : BeginControlRequest() {
    *this = ::std::move(from);
  }

  inline BeginControlRequest& operator=(const BeginControlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeginControlRequest& operator=(BeginControlRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeginControlRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeginControlRequest* internal_default_instance() {
    return reinterpret_cast<const BeginControlRequest*>(
               &_BeginControlRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BeginControlRequest& a, BeginControlRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BeginControlRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeginControlRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeginControlRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeginControlRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeginControlRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeginControlRequest& from) {
    BeginControlRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeginControlRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.BeginControlRequest";
  }
  protected:
  explicit BeginControlRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeasesFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kCommandIdFieldNumber = 3,
  };
  // repeated .bosdyn.api.Lease leases = 2;
  int leases_size() const;
  private:
  int _internal_leases_size() const;
  public:
  void clear_leases();
  ::bosdyn::api::Lease* mutable_leases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
      mutable_leases();
  private:
  const ::bosdyn::api::Lease& _internal_leases(int index) const;
  ::bosdyn::api::Lease* _internal_add_leases();
  public:
  const ::bosdyn::api::Lease& leases(int index) const;
  ::bosdyn::api::Lease* add_leases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
      leases() const;

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // uint32 command_id = 3;
  void clear_command_id();
  uint32_t command_id() const;
  void set_command_id(uint32_t value);
  private:
  uint32_t _internal_command_id() const;
  void _internal_set_command_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.BeginControlRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease > leases_;
    ::bosdyn::api::RequestHeader* header_;
    uint32_t command_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
};
// -------------------------------------------------------------------

class BeginControlResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.BeginControlResponse) */ {
 public:
  inline BeginControlResponse() : BeginControlResponse(nullptr) {}
  ~BeginControlResponse() override;
  explicit PROTOBUF_CONSTEXPR BeginControlResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeginControlResponse(const BeginControlResponse& from);
  BeginControlResponse(BeginControlResponse&& from) noexcept
    : BeginControlResponse() {
    *this = ::std::move(from);
  }

  inline BeginControlResponse& operator=(const BeginControlResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeginControlResponse& operator=(BeginControlResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeginControlResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeginControlResponse* internal_default_instance() {
    return reinterpret_cast<const BeginControlResponse*>(
               &_BeginControlResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BeginControlResponse& a, BeginControlResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BeginControlResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeginControlResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeginControlResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeginControlResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeginControlResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeginControlResponse& from) {
    BeginControlResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeginControlResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.BeginControlResponse";
  }
  protected:
  explicit BeginControlResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BeginControlResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    BeginControlResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    BeginControlResponse_Status_STATUS_OK;
  static constexpr Status STATUS_INVALID_COMMAND_ID =
    BeginControlResponse_Status_STATUS_INVALID_COMMAND_ID;
  static constexpr Status STATUS_MISSING_LEASE_RESOURCES =
    BeginControlResponse_Status_STATUS_MISSING_LEASE_RESOURCES;
  static constexpr Status STATUS_LEASE_ERROR =
    BeginControlResponse_Status_STATUS_LEASE_ERROR;
  static inline bool Status_IsValid(int value) {
    return BeginControlResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    BeginControlResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    BeginControlResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    BeginControlResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return BeginControlResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return BeginControlResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return BeginControlResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeaseUseResultsFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 3,
  };
  // repeated .bosdyn.api.LeaseUseResult lease_use_results = 2;
  int lease_use_results_size() const;
  private:
  int _internal_lease_use_results_size() const;
  public:
  void clear_lease_use_results();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
      mutable_lease_use_results();
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* _internal_add_lease_use_results();
  public:
  const ::bosdyn::api::LeaseUseResult& lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* add_lease_use_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
      lease_use_results() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.BeginControlResponse.Status status = 3;
  void clear_status();
  ::bosdyn::api::graph_nav::BeginControlResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::BeginControlResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::BeginControlResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::BeginControlResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.BeginControlResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult > lease_use_results_;
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
};
// -------------------------------------------------------------------

class UpdateCallbackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.UpdateCallbackRequest) */ {
 public:
  inline UpdateCallbackRequest() : UpdateCallbackRequest(nullptr) {}
  ~UpdateCallbackRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateCallbackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateCallbackRequest(const UpdateCallbackRequest& from);
  UpdateCallbackRequest(UpdateCallbackRequest&& from) noexcept
    : UpdateCallbackRequest() {
    *this = ::std::move(from);
  }

  inline UpdateCallbackRequest& operator=(const UpdateCallbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCallbackRequest& operator=(UpdateCallbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCallbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateCallbackRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateCallbackRequest*>(
               &_UpdateCallbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UpdateCallbackRequest& a, UpdateCallbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateCallbackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCallbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCallbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateCallbackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateCallbackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateCallbackRequest& from) {
    UpdateCallbackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateCallbackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.UpdateCallbackRequest";
  }
  protected:
  explicit UpdateCallbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdateCallbackRequest_Stage Stage;
  static constexpr Stage STAGE_UNKNOWN =
    UpdateCallbackRequest_Stage_STAGE_UNKNOWN;
  static constexpr Stage STAGE_TO_START =
    UpdateCallbackRequest_Stage_STAGE_TO_START;
  static constexpr Stage STAGE_AT_START =
    UpdateCallbackRequest_Stage_STAGE_AT_START;
  static constexpr Stage STAGE_TO_END =
    UpdateCallbackRequest_Stage_STAGE_TO_END;
  static constexpr Stage STAGE_AT_END =
    UpdateCallbackRequest_Stage_STAGE_AT_END;
  static inline bool Stage_IsValid(int value) {
    return UpdateCallbackRequest_Stage_IsValid(value);
  }
  static constexpr Stage Stage_MIN =
    UpdateCallbackRequest_Stage_Stage_MIN;
  static constexpr Stage Stage_MAX =
    UpdateCallbackRequest_Stage_Stage_MAX;
  static constexpr int Stage_ARRAYSIZE =
    UpdateCallbackRequest_Stage_Stage_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Stage_descriptor() {
    return UpdateCallbackRequest_Stage_descriptor();
  }
  template<typename T>
  static inline const std::string& Stage_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Stage>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Stage_Name.");
    return UpdateCallbackRequest_Stage_Name(enum_t_value);
  }
  static inline bool Stage_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Stage* value) {
    return UpdateCallbackRequest_Stage_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kEndTimeFieldNumber = 3,
    kCommandIdFieldNumber = 2,
    kStageFieldNumber = 4,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .google.protobuf.Timestamp end_time = 3;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // uint32 command_id = 2;
  void clear_command_id();
  uint32_t command_id() const;
  void set_command_id(uint32_t value);
  private:
  uint32_t _internal_command_id() const;
  void _internal_set_command_id(uint32_t value);
  public:

  // .bosdyn.api.graph_nav.UpdateCallbackRequest.Stage stage = 4;
  void clear_stage();
  ::bosdyn::api::graph_nav::UpdateCallbackRequest_Stage stage() const;
  void set_stage(::bosdyn::api::graph_nav::UpdateCallbackRequest_Stage value);
  private:
  ::bosdyn::api::graph_nav::UpdateCallbackRequest_Stage _internal_stage() const;
  void _internal_set_stage(::bosdyn::api::graph_nav::UpdateCallbackRequest_Stage value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.UpdateCallbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    uint32_t command_id_;
    int stage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
};
// -------------------------------------------------------------------

class UpdateCallbackResponse_NavPolicy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.UpdateCallbackResponse.NavPolicy) */ {
 public:
  inline UpdateCallbackResponse_NavPolicy() : UpdateCallbackResponse_NavPolicy(nullptr) {}
  ~UpdateCallbackResponse_NavPolicy() override;
  explicit PROTOBUF_CONSTEXPR UpdateCallbackResponse_NavPolicy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateCallbackResponse_NavPolicy(const UpdateCallbackResponse_NavPolicy& from);
  UpdateCallbackResponse_NavPolicy(UpdateCallbackResponse_NavPolicy&& from) noexcept
    : UpdateCallbackResponse_NavPolicy() {
    *this = ::std::move(from);
  }

  inline UpdateCallbackResponse_NavPolicy& operator=(const UpdateCallbackResponse_NavPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCallbackResponse_NavPolicy& operator=(UpdateCallbackResponse_NavPolicy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCallbackResponse_NavPolicy& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateCallbackResponse_NavPolicy* internal_default_instance() {
    return reinterpret_cast<const UpdateCallbackResponse_NavPolicy*>(
               &_UpdateCallbackResponse_NavPolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UpdateCallbackResponse_NavPolicy& a, UpdateCallbackResponse_NavPolicy& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateCallbackResponse_NavPolicy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCallbackResponse_NavPolicy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCallbackResponse_NavPolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateCallbackResponse_NavPolicy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateCallbackResponse_NavPolicy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateCallbackResponse_NavPolicy& from) {
    UpdateCallbackResponse_NavPolicy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateCallbackResponse_NavPolicy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.UpdateCallbackResponse.NavPolicy";
  }
  protected:
  explicit UpdateCallbackResponse_NavPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdateCallbackResponse_NavPolicy_Option Option;
  static constexpr Option OPTION_UNKNOWN =
    UpdateCallbackResponse_NavPolicy_Option_OPTION_UNKNOWN;
  static constexpr Option OPTION_CONTINUE =
    UpdateCallbackResponse_NavPolicy_Option_OPTION_CONTINUE;
  static constexpr Option OPTION_STOP =
    UpdateCallbackResponse_NavPolicy_Option_OPTION_STOP;
  static constexpr Option OPTION_CONTROL =
    UpdateCallbackResponse_NavPolicy_Option_OPTION_CONTROL;
  static inline bool Option_IsValid(int value) {
    return UpdateCallbackResponse_NavPolicy_Option_IsValid(value);
  }
  static constexpr Option Option_MIN =
    UpdateCallbackResponse_NavPolicy_Option_Option_MIN;
  static constexpr Option Option_MAX =
    UpdateCallbackResponse_NavPolicy_Option_Option_MAX;
  static constexpr int Option_ARRAYSIZE =
    UpdateCallbackResponse_NavPolicy_Option_Option_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Option_descriptor() {
    return UpdateCallbackResponse_NavPolicy_Option_descriptor();
  }
  template<typename T>
  static inline const std::string& Option_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Option>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Option_Name.");
    return UpdateCallbackResponse_NavPolicy_Option_Name(enum_t_value);
  }
  static inline bool Option_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Option* value) {
    return UpdateCallbackResponse_NavPolicy_Option_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAtStartFieldNumber = 1,
    kAtEndFieldNumber = 2,
  };
  // .bosdyn.api.graph_nav.UpdateCallbackResponse.NavPolicy.Option at_start = 1;
  void clear_at_start();
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option at_start() const;
  void set_at_start(::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option value);
  private:
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option _internal_at_start() const;
  void _internal_set_at_start(::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option value);
  public:

  // .bosdyn.api.graph_nav.UpdateCallbackResponse.NavPolicy.Option at_end = 2;
  void clear_at_end();
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option at_end() const;
  void set_at_end(::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option value);
  private:
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option _internal_at_end() const;
  void _internal_set_at_end(::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.UpdateCallbackResponse.NavPolicy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int at_start_;
    int at_end_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
};
// -------------------------------------------------------------------

class UpdateCallbackResponse_Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.UpdateCallbackResponse.Error) */ {
 public:
  inline UpdateCallbackResponse_Error() : UpdateCallbackResponse_Error(nullptr) {}
  ~UpdateCallbackResponse_Error() override;
  explicit PROTOBUF_CONSTEXPR UpdateCallbackResponse_Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateCallbackResponse_Error(const UpdateCallbackResponse_Error& from);
  UpdateCallbackResponse_Error(UpdateCallbackResponse_Error&& from) noexcept
    : UpdateCallbackResponse_Error() {
    *this = ::std::move(from);
  }

  inline UpdateCallbackResponse_Error& operator=(const UpdateCallbackResponse_Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCallbackResponse_Error& operator=(UpdateCallbackResponse_Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCallbackResponse_Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateCallbackResponse_Error* internal_default_instance() {
    return reinterpret_cast<const UpdateCallbackResponse_Error*>(
               &_UpdateCallbackResponse_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UpdateCallbackResponse_Error& a, UpdateCallbackResponse_Error& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateCallbackResponse_Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCallbackResponse_Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCallbackResponse_Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateCallbackResponse_Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateCallbackResponse_Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateCallbackResponse_Error& from) {
    UpdateCallbackResponse_Error::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateCallbackResponse_Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.UpdateCallbackResponse.Error";
  }
  protected:
  explicit UpdateCallbackResponse_Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdateCallbackResponse_Error_ErrorType ErrorType;
  static constexpr ErrorType ERROR_UNKNOWN =
    UpdateCallbackResponse_Error_ErrorType_ERROR_UNKNOWN;
  static constexpr ErrorType ERROR_BLOCKED =
    UpdateCallbackResponse_Error_ErrorType_ERROR_BLOCKED;
  static constexpr ErrorType ERROR_CALLBACK_FAILED =
    UpdateCallbackResponse_Error_ErrorType_ERROR_CALLBACK_FAILED;
  static constexpr ErrorType ERROR_LEASE =
    UpdateCallbackResponse_Error_ErrorType_ERROR_LEASE;
  static constexpr ErrorType ERROR_TIMED_OUT =
    UpdateCallbackResponse_Error_ErrorType_ERROR_TIMED_OUT;
  static inline bool ErrorType_IsValid(int value) {
    return UpdateCallbackResponse_Error_ErrorType_IsValid(value);
  }
  static constexpr ErrorType ErrorType_MIN =
    UpdateCallbackResponse_Error_ErrorType_ErrorType_MIN;
  static constexpr ErrorType ErrorType_MAX =
    UpdateCallbackResponse_Error_ErrorType_ErrorType_MAX;
  static constexpr int ErrorType_ARRAYSIZE =
    UpdateCallbackResponse_Error_ErrorType_ErrorType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ErrorType_descriptor() {
    return UpdateCallbackResponse_Error_ErrorType_descriptor();
  }
  template<typename T>
  static inline const std::string& ErrorType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorType_Name.");
    return UpdateCallbackResponse_Error_ErrorType_Name(enum_t_value);
  }
  static inline bool ErrorType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorType* value) {
    return UpdateCallbackResponse_Error_ErrorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeaseUseResultsFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // repeated .bosdyn.api.LeaseUseResult lease_use_results = 2;
  int lease_use_results_size() const;
  private:
  int _internal_lease_use_results_size() const;
  public:
  void clear_lease_use_results();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
      mutable_lease_use_results();
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* _internal_add_lease_use_results();
  public:
  const ::bosdyn::api::LeaseUseResult& lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* add_lease_use_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
      lease_use_results() const;

  // .bosdyn.api.graph_nav.UpdateCallbackResponse.Error.ErrorType error = 1;
  void clear_error();
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error_ErrorType error() const;
  void set_error(::bosdyn::api::graph_nav::UpdateCallbackResponse_Error_ErrorType value);
  private:
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error_ErrorType _internal_error() const;
  void _internal_set_error(::bosdyn::api::graph_nav::UpdateCallbackResponse_Error_ErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.UpdateCallbackResponse.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult > lease_use_results_;
    int error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
};
// -------------------------------------------------------------------

class UpdateCallbackResponse_Complete final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.UpdateCallbackResponse.Complete) */ {
 public:
  inline UpdateCallbackResponse_Complete() : UpdateCallbackResponse_Complete(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateCallbackResponse_Complete(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateCallbackResponse_Complete(const UpdateCallbackResponse_Complete& from);
  UpdateCallbackResponse_Complete(UpdateCallbackResponse_Complete&& from) noexcept
    : UpdateCallbackResponse_Complete() {
    *this = ::std::move(from);
  }

  inline UpdateCallbackResponse_Complete& operator=(const UpdateCallbackResponse_Complete& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCallbackResponse_Complete& operator=(UpdateCallbackResponse_Complete&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCallbackResponse_Complete& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateCallbackResponse_Complete* internal_default_instance() {
    return reinterpret_cast<const UpdateCallbackResponse_Complete*>(
               &_UpdateCallbackResponse_Complete_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UpdateCallbackResponse_Complete& a, UpdateCallbackResponse_Complete& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateCallbackResponse_Complete* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCallbackResponse_Complete* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCallbackResponse_Complete* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateCallbackResponse_Complete>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateCallbackResponse_Complete& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateCallbackResponse_Complete& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.UpdateCallbackResponse.Complete";
  }
  protected:
  explicit UpdateCallbackResponse_Complete(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.UpdateCallbackResponse.Complete)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
};
// -------------------------------------------------------------------

class UpdateCallbackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.UpdateCallbackResponse) */ {
 public:
  inline UpdateCallbackResponse() : UpdateCallbackResponse(nullptr) {}
  ~UpdateCallbackResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateCallbackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateCallbackResponse(const UpdateCallbackResponse& from);
  UpdateCallbackResponse(UpdateCallbackResponse&& from) noexcept
    : UpdateCallbackResponse() {
    *this = ::std::move(from);
  }

  inline UpdateCallbackResponse& operator=(const UpdateCallbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCallbackResponse& operator=(UpdateCallbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCallbackResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kPolicy = 3,
    kError = 4,
    kComplete = 5,
    RESPONSE_NOT_SET = 0,
  };

  static inline const UpdateCallbackResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateCallbackResponse*>(
               &_UpdateCallbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UpdateCallbackResponse& a, UpdateCallbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateCallbackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCallbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCallbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateCallbackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateCallbackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateCallbackResponse& from) {
    UpdateCallbackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateCallbackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.UpdateCallbackResponse";
  }
  protected:
  explicit UpdateCallbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdateCallbackResponse_NavPolicy NavPolicy;
  typedef UpdateCallbackResponse_Error Error;
  typedef UpdateCallbackResponse_Complete Complete;

  typedef UpdateCallbackResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    UpdateCallbackResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    UpdateCallbackResponse_Status_STATUS_OK;
  static constexpr Status STATUS_INVALID_COMMAND_ID =
    UpdateCallbackResponse_Status_STATUS_INVALID_COMMAND_ID;
  static constexpr Status STATUS_EXPIRED_END_TIME =
    UpdateCallbackResponse_Status_STATUS_EXPIRED_END_TIME;
  static inline bool Status_IsValid(int value) {
    return UpdateCallbackResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    UpdateCallbackResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    UpdateCallbackResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    UpdateCallbackResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return UpdateCallbackResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return UpdateCallbackResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return UpdateCallbackResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
    kPolicyFieldNumber = 3,
    kErrorFieldNumber = 4,
    kCompleteFieldNumber = 5,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.UpdateCallbackResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::UpdateCallbackResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::UpdateCallbackResponse_Status value);
  public:

  // .bosdyn.api.graph_nav.UpdateCallbackResponse.NavPolicy policy = 3;
  bool has_policy() const;
  private:
  bool _internal_has_policy() const;
  public:
  void clear_policy();
  const ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy& policy() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy* release_policy();
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy* mutable_policy();
  void set_allocated_policy(::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy* policy);
  private:
  const ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy& _internal_policy() const;
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy* _internal_mutable_policy();
  public:
  void unsafe_arena_set_allocated_policy(
      ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy* policy);
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy* unsafe_arena_release_policy();

  // .bosdyn.api.graph_nav.UpdateCallbackResponse.Error error = 4;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error& error() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error* release_error();
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error* mutable_error();
  void set_allocated_error(::bosdyn::api::graph_nav::UpdateCallbackResponse_Error* error);
  private:
  const ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error& _internal_error() const;
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error* error);
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error* unsafe_arena_release_error();

  // .bosdyn.api.graph_nav.UpdateCallbackResponse.Complete complete = 5;
  bool has_complete() const;
  private:
  bool _internal_has_complete() const;
  public:
  void clear_complete();
  const ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete& complete() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete* release_complete();
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete* mutable_complete();
  void set_allocated_complete(::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete* complete);
  private:
  const ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete& _internal_complete() const;
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete* _internal_mutable_complete();
  public:
  void unsafe_arena_set_allocated_complete(
      ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete* complete);
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete* unsafe_arena_release_complete();

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.UpdateCallbackResponse)
 private:
  class _Internal;
  void set_has_policy();
  void set_has_error();
  void set_has_complete();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy* policy_;
      ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error* error_;
      ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete* complete_;
    } response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
};
// -------------------------------------------------------------------

class EndCallbackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.EndCallbackRequest) */ {
 public:
  inline EndCallbackRequest() : EndCallbackRequest(nullptr) {}
  ~EndCallbackRequest() override;
  explicit PROTOBUF_CONSTEXPR EndCallbackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndCallbackRequest(const EndCallbackRequest& from);
  EndCallbackRequest(EndCallbackRequest&& from) noexcept
    : EndCallbackRequest() {
    *this = ::std::move(from);
  }

  inline EndCallbackRequest& operator=(const EndCallbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndCallbackRequest& operator=(EndCallbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndCallbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndCallbackRequest* internal_default_instance() {
    return reinterpret_cast<const EndCallbackRequest*>(
               &_EndCallbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(EndCallbackRequest& a, EndCallbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EndCallbackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndCallbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndCallbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndCallbackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EndCallbackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EndCallbackRequest& from) {
    EndCallbackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndCallbackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.EndCallbackRequest";
  }
  protected:
  explicit EndCallbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kCommandIdFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // uint32 command_id = 2;
  void clear_command_id();
  uint32_t command_id() const;
  void set_command_id(uint32_t value);
  private:
  uint32_t _internal_command_id() const;
  void _internal_set_command_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.EndCallbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    uint32_t command_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
};
// -------------------------------------------------------------------

class EndCallbackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.EndCallbackResponse) */ {
 public:
  inline EndCallbackResponse() : EndCallbackResponse(nullptr) {}
  ~EndCallbackResponse() override;
  explicit PROTOBUF_CONSTEXPR EndCallbackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndCallbackResponse(const EndCallbackResponse& from);
  EndCallbackResponse(EndCallbackResponse&& from) noexcept
    : EndCallbackResponse() {
    *this = ::std::move(from);
  }

  inline EndCallbackResponse& operator=(const EndCallbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndCallbackResponse& operator=(EndCallbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndCallbackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndCallbackResponse* internal_default_instance() {
    return reinterpret_cast<const EndCallbackResponse*>(
               &_EndCallbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(EndCallbackResponse& a, EndCallbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EndCallbackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndCallbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndCallbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndCallbackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EndCallbackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EndCallbackResponse& from) {
    EndCallbackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndCallbackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.EndCallbackResponse";
  }
  protected:
  explicit EndCallbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EndCallbackResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    EndCallbackResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    EndCallbackResponse_Status_STATUS_OK;
  static constexpr Status STATUS_INVALID_COMMAND_ID =
    EndCallbackResponse_Status_STATUS_INVALID_COMMAND_ID;
  static constexpr Status STATUS_SHUTDOWN_CALLBACK_FAILED =
    EndCallbackResponse_Status_STATUS_SHUTDOWN_CALLBACK_FAILED;
  static inline bool Status_IsValid(int value) {
    return EndCallbackResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    EndCallbackResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    EndCallbackResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    EndCallbackResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return EndCallbackResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return EndCallbackResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return EndCallbackResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.EndCallbackResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::graph_nav::EndCallbackResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::EndCallbackResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::EndCallbackResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::EndCallbackResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.EndCallbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AreaCallbackError

// string service_name = 1;
inline void AreaCallbackError::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& AreaCallbackError::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.AreaCallbackError.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AreaCallbackError::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.AreaCallbackError.service_name)
}
inline std::string* AreaCallbackError::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.AreaCallbackError.service_name)
  return _s;
}
inline const std::string& AreaCallbackError::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void AreaCallbackError::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AreaCallbackError::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AreaCallbackError::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.AreaCallbackError.service_name)
  return _impl_.service_name_.Release();
}
inline void AreaCallbackError::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.AreaCallbackError.service_name)
}

// .bosdyn.api.graph_nav.AreaCallbackError.CallError error = 2;
inline void AreaCallbackError::clear_error() {
  _impl_.error_ = 0;
}
inline ::bosdyn::api::graph_nav::AreaCallbackError_CallError AreaCallbackError::_internal_error() const {
  return static_cast< ::bosdyn::api::graph_nav::AreaCallbackError_CallError >(_impl_.error_);
}
inline ::bosdyn::api::graph_nav::AreaCallbackError_CallError AreaCallbackError::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.AreaCallbackError.error)
  return _internal_error();
}
inline void AreaCallbackError::_internal_set_error(::bosdyn::api::graph_nav::AreaCallbackError_CallError value) {
  
  _impl_.error_ = value;
}
inline void AreaCallbackError::set_error(::bosdyn::api::graph_nav::AreaCallbackError_CallError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.AreaCallbackError.error)
}

// .bosdyn.api.graph_nav.BeginCallbackResponse begin_callback = 3;
inline bool AreaCallbackError::_internal_has_begin_callback() const {
  return response_error_case() == kBeginCallback;
}
inline bool AreaCallbackError::has_begin_callback() const {
  return _internal_has_begin_callback();
}
inline void AreaCallbackError::set_has_begin_callback() {
  _impl_._oneof_case_[0] = kBeginCallback;
}
inline void AreaCallbackError::clear_begin_callback() {
  if (_internal_has_begin_callback()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_error_.begin_callback_;
    }
    clear_has_response_error();
  }
}
inline ::bosdyn::api::graph_nav::BeginCallbackResponse* AreaCallbackError::release_begin_callback() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.AreaCallbackError.begin_callback)
  if (_internal_has_begin_callback()) {
    clear_has_response_error();
    ::bosdyn::api::graph_nav::BeginCallbackResponse* temp = _impl_.response_error_.begin_callback_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_error_.begin_callback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::graph_nav::BeginCallbackResponse& AreaCallbackError::_internal_begin_callback() const {
  return _internal_has_begin_callback()
      ? *_impl_.response_error_.begin_callback_
      : reinterpret_cast< ::bosdyn::api::graph_nav::BeginCallbackResponse&>(::bosdyn::api::graph_nav::_BeginCallbackResponse_default_instance_);
}
inline const ::bosdyn::api::graph_nav::BeginCallbackResponse& AreaCallbackError::begin_callback() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.AreaCallbackError.begin_callback)
  return _internal_begin_callback();
}
inline ::bosdyn::api::graph_nav::BeginCallbackResponse* AreaCallbackError::unsafe_arena_release_begin_callback() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.graph_nav.AreaCallbackError.begin_callback)
  if (_internal_has_begin_callback()) {
    clear_has_response_error();
    ::bosdyn::api::graph_nav::BeginCallbackResponse* temp = _impl_.response_error_.begin_callback_;
    _impl_.response_error_.begin_callback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AreaCallbackError::unsafe_arena_set_allocated_begin_callback(::bosdyn::api::graph_nav::BeginCallbackResponse* begin_callback) {
  clear_response_error();
  if (begin_callback) {
    set_has_begin_callback();
    _impl_.response_error_.begin_callback_ = begin_callback;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.AreaCallbackError.begin_callback)
}
inline ::bosdyn::api::graph_nav::BeginCallbackResponse* AreaCallbackError::_internal_mutable_begin_callback() {
  if (!_internal_has_begin_callback()) {
    clear_response_error();
    set_has_begin_callback();
    _impl_.response_error_.begin_callback_ = CreateMaybeMessage< ::bosdyn::api::graph_nav::BeginCallbackResponse >(GetArenaForAllocation());
  }
  return _impl_.response_error_.begin_callback_;
}
inline ::bosdyn::api::graph_nav::BeginCallbackResponse* AreaCallbackError::mutable_begin_callback() {
  ::bosdyn::api::graph_nav::BeginCallbackResponse* _msg = _internal_mutable_begin_callback();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.AreaCallbackError.begin_callback)
  return _msg;
}

// .bosdyn.api.graph_nav.BeginControlResponse begin_control = 4;
inline bool AreaCallbackError::_internal_has_begin_control() const {
  return response_error_case() == kBeginControl;
}
inline bool AreaCallbackError::has_begin_control() const {
  return _internal_has_begin_control();
}
inline void AreaCallbackError::set_has_begin_control() {
  _impl_._oneof_case_[0] = kBeginControl;
}
inline void AreaCallbackError::clear_begin_control() {
  if (_internal_has_begin_control()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_error_.begin_control_;
    }
    clear_has_response_error();
  }
}
inline ::bosdyn::api::graph_nav::BeginControlResponse* AreaCallbackError::release_begin_control() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.AreaCallbackError.begin_control)
  if (_internal_has_begin_control()) {
    clear_has_response_error();
    ::bosdyn::api::graph_nav::BeginControlResponse* temp = _impl_.response_error_.begin_control_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_error_.begin_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::graph_nav::BeginControlResponse& AreaCallbackError::_internal_begin_control() const {
  return _internal_has_begin_control()
      ? *_impl_.response_error_.begin_control_
      : reinterpret_cast< ::bosdyn::api::graph_nav::BeginControlResponse&>(::bosdyn::api::graph_nav::_BeginControlResponse_default_instance_);
}
inline const ::bosdyn::api::graph_nav::BeginControlResponse& AreaCallbackError::begin_control() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.AreaCallbackError.begin_control)
  return _internal_begin_control();
}
inline ::bosdyn::api::graph_nav::BeginControlResponse* AreaCallbackError::unsafe_arena_release_begin_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.graph_nav.AreaCallbackError.begin_control)
  if (_internal_has_begin_control()) {
    clear_has_response_error();
    ::bosdyn::api::graph_nav::BeginControlResponse* temp = _impl_.response_error_.begin_control_;
    _impl_.response_error_.begin_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AreaCallbackError::unsafe_arena_set_allocated_begin_control(::bosdyn::api::graph_nav::BeginControlResponse* begin_control) {
  clear_response_error();
  if (begin_control) {
    set_has_begin_control();
    _impl_.response_error_.begin_control_ = begin_control;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.AreaCallbackError.begin_control)
}
inline ::bosdyn::api::graph_nav::BeginControlResponse* AreaCallbackError::_internal_mutable_begin_control() {
  if (!_internal_has_begin_control()) {
    clear_response_error();
    set_has_begin_control();
    _impl_.response_error_.begin_control_ = CreateMaybeMessage< ::bosdyn::api::graph_nav::BeginControlResponse >(GetArenaForAllocation());
  }
  return _impl_.response_error_.begin_control_;
}
inline ::bosdyn::api::graph_nav::BeginControlResponse* AreaCallbackError::mutable_begin_control() {
  ::bosdyn::api::graph_nav::BeginControlResponse* _msg = _internal_mutable_begin_control();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.AreaCallbackError.begin_control)
  return _msg;
}

// .bosdyn.api.graph_nav.UpdateCallbackResponse update_callback = 5;
inline bool AreaCallbackError::_internal_has_update_callback() const {
  return response_error_case() == kUpdateCallback;
}
inline bool AreaCallbackError::has_update_callback() const {
  return _internal_has_update_callback();
}
inline void AreaCallbackError::set_has_update_callback() {
  _impl_._oneof_case_[0] = kUpdateCallback;
}
inline void AreaCallbackError::clear_update_callback() {
  if (_internal_has_update_callback()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_error_.update_callback_;
    }
    clear_has_response_error();
  }
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse* AreaCallbackError::release_update_callback() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.AreaCallbackError.update_callback)
  if (_internal_has_update_callback()) {
    clear_has_response_error();
    ::bosdyn::api::graph_nav::UpdateCallbackResponse* temp = _impl_.response_error_.update_callback_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_error_.update_callback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::graph_nav::UpdateCallbackResponse& AreaCallbackError::_internal_update_callback() const {
  return _internal_has_update_callback()
      ? *_impl_.response_error_.update_callback_
      : reinterpret_cast< ::bosdyn::api::graph_nav::UpdateCallbackResponse&>(::bosdyn::api::graph_nav::_UpdateCallbackResponse_default_instance_);
}
inline const ::bosdyn::api::graph_nav::UpdateCallbackResponse& AreaCallbackError::update_callback() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.AreaCallbackError.update_callback)
  return _internal_update_callback();
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse* AreaCallbackError::unsafe_arena_release_update_callback() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.graph_nav.AreaCallbackError.update_callback)
  if (_internal_has_update_callback()) {
    clear_has_response_error();
    ::bosdyn::api::graph_nav::UpdateCallbackResponse* temp = _impl_.response_error_.update_callback_;
    _impl_.response_error_.update_callback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AreaCallbackError::unsafe_arena_set_allocated_update_callback(::bosdyn::api::graph_nav::UpdateCallbackResponse* update_callback) {
  clear_response_error();
  if (update_callback) {
    set_has_update_callback();
    _impl_.response_error_.update_callback_ = update_callback;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.AreaCallbackError.update_callback)
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse* AreaCallbackError::_internal_mutable_update_callback() {
  if (!_internal_has_update_callback()) {
    clear_response_error();
    set_has_update_callback();
    _impl_.response_error_.update_callback_ = CreateMaybeMessage< ::bosdyn::api::graph_nav::UpdateCallbackResponse >(GetArenaForAllocation());
  }
  return _impl_.response_error_.update_callback_;
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse* AreaCallbackError::mutable_update_callback() {
  ::bosdyn::api::graph_nav::UpdateCallbackResponse* _msg = _internal_mutable_update_callback();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.AreaCallbackError.update_callback)
  return _msg;
}

// .bosdyn.api.graph_nav.EndCallbackResponse end_callback = 6;
inline bool AreaCallbackError::_internal_has_end_callback() const {
  return response_error_case() == kEndCallback;
}
inline bool AreaCallbackError::has_end_callback() const {
  return _internal_has_end_callback();
}
inline void AreaCallbackError::set_has_end_callback() {
  _impl_._oneof_case_[0] = kEndCallback;
}
inline void AreaCallbackError::clear_end_callback() {
  if (_internal_has_end_callback()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_error_.end_callback_;
    }
    clear_has_response_error();
  }
}
inline ::bosdyn::api::graph_nav::EndCallbackResponse* AreaCallbackError::release_end_callback() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.AreaCallbackError.end_callback)
  if (_internal_has_end_callback()) {
    clear_has_response_error();
    ::bosdyn::api::graph_nav::EndCallbackResponse* temp = _impl_.response_error_.end_callback_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_error_.end_callback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::graph_nav::EndCallbackResponse& AreaCallbackError::_internal_end_callback() const {
  return _internal_has_end_callback()
      ? *_impl_.response_error_.end_callback_
      : reinterpret_cast< ::bosdyn::api::graph_nav::EndCallbackResponse&>(::bosdyn::api::graph_nav::_EndCallbackResponse_default_instance_);
}
inline const ::bosdyn::api::graph_nav::EndCallbackResponse& AreaCallbackError::end_callback() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.AreaCallbackError.end_callback)
  return _internal_end_callback();
}
inline ::bosdyn::api::graph_nav::EndCallbackResponse* AreaCallbackError::unsafe_arena_release_end_callback() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.graph_nav.AreaCallbackError.end_callback)
  if (_internal_has_end_callback()) {
    clear_has_response_error();
    ::bosdyn::api::graph_nav::EndCallbackResponse* temp = _impl_.response_error_.end_callback_;
    _impl_.response_error_.end_callback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AreaCallbackError::unsafe_arena_set_allocated_end_callback(::bosdyn::api::graph_nav::EndCallbackResponse* end_callback) {
  clear_response_error();
  if (end_callback) {
    set_has_end_callback();
    _impl_.response_error_.end_callback_ = end_callback;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.AreaCallbackError.end_callback)
}
inline ::bosdyn::api::graph_nav::EndCallbackResponse* AreaCallbackError::_internal_mutable_end_callback() {
  if (!_internal_has_end_callback()) {
    clear_response_error();
    set_has_end_callback();
    _impl_.response_error_.end_callback_ = CreateMaybeMessage< ::bosdyn::api::graph_nav::EndCallbackResponse >(GetArenaForAllocation());
  }
  return _impl_.response_error_.end_callback_;
}
inline ::bosdyn::api::graph_nav::EndCallbackResponse* AreaCallbackError::mutable_end_callback() {
  ::bosdyn::api::graph_nav::EndCallbackResponse* _msg = _internal_mutable_end_callback();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.AreaCallbackError.end_callback)
  return _msg;
}

inline bool AreaCallbackError::has_response_error() const {
  return response_error_case() != RESPONSE_ERROR_NOT_SET;
}
inline void AreaCallbackError::clear_has_response_error() {
  _impl_._oneof_case_[0] = RESPONSE_ERROR_NOT_SET;
}
inline AreaCallbackError::ResponseErrorCase AreaCallbackError::response_error_case() const {
  return AreaCallbackError::ResponseErrorCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AreaCallbackInformationRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool AreaCallbackInformationRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool AreaCallbackInformationRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& AreaCallbackInformationRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& AreaCallbackInformationRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.AreaCallbackInformationRequest.header)
  return _internal_header();
}
inline void AreaCallbackInformationRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.AreaCallbackInformationRequest.header)
}
inline ::bosdyn::api::RequestHeader* AreaCallbackInformationRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* AreaCallbackInformationRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.AreaCallbackInformationRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* AreaCallbackInformationRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* AreaCallbackInformationRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.AreaCallbackInformationRequest.header)
  return _msg;
}
inline void AreaCallbackInformationRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.AreaCallbackInformationRequest.header)
}

// -------------------------------------------------------------------

// AreaCallbackInformation

// repeated string required_lease_resources = 1;
inline int AreaCallbackInformation::_internal_required_lease_resources_size() const {
  return _impl_.required_lease_resources_.size();
}
inline int AreaCallbackInformation::required_lease_resources_size() const {
  return _internal_required_lease_resources_size();
}
inline void AreaCallbackInformation::clear_required_lease_resources() {
  _impl_.required_lease_resources_.Clear();
}
inline std::string* AreaCallbackInformation::add_required_lease_resources() {
  std::string* _s = _internal_add_required_lease_resources();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.graph_nav.AreaCallbackInformation.required_lease_resources)
  return _s;
}
inline const std::string& AreaCallbackInformation::_internal_required_lease_resources(int index) const {
  return _impl_.required_lease_resources_.Get(index);
}
inline const std::string& AreaCallbackInformation::required_lease_resources(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.AreaCallbackInformation.required_lease_resources)
  return _internal_required_lease_resources(index);
}
inline std::string* AreaCallbackInformation::mutable_required_lease_resources(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.AreaCallbackInformation.required_lease_resources)
  return _impl_.required_lease_resources_.Mutable(index);
}
inline void AreaCallbackInformation::set_required_lease_resources(int index, const std::string& value) {
  _impl_.required_lease_resources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.AreaCallbackInformation.required_lease_resources)
}
inline void AreaCallbackInformation::set_required_lease_resources(int index, std::string&& value) {
  _impl_.required_lease_resources_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.AreaCallbackInformation.required_lease_resources)
}
inline void AreaCallbackInformation::set_required_lease_resources(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.required_lease_resources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.graph_nav.AreaCallbackInformation.required_lease_resources)
}
inline void AreaCallbackInformation::set_required_lease_resources(int index, const char* value, size_t size) {
  _impl_.required_lease_resources_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.graph_nav.AreaCallbackInformation.required_lease_resources)
}
inline std::string* AreaCallbackInformation::_internal_add_required_lease_resources() {
  return _impl_.required_lease_resources_.Add();
}
inline void AreaCallbackInformation::add_required_lease_resources(const std::string& value) {
  _impl_.required_lease_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.AreaCallbackInformation.required_lease_resources)
}
inline void AreaCallbackInformation::add_required_lease_resources(std::string&& value) {
  _impl_.required_lease_resources_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.AreaCallbackInformation.required_lease_resources)
}
inline void AreaCallbackInformation::add_required_lease_resources(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.required_lease_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.graph_nav.AreaCallbackInformation.required_lease_resources)
}
inline void AreaCallbackInformation::add_required_lease_resources(const char* value, size_t size) {
  _impl_.required_lease_resources_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.graph_nav.AreaCallbackInformation.required_lease_resources)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AreaCallbackInformation::required_lease_resources() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.AreaCallbackInformation.required_lease_resources)
  return _impl_.required_lease_resources_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AreaCallbackInformation::mutable_required_lease_resources() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.AreaCallbackInformation.required_lease_resources)
  return &_impl_.required_lease_resources_;
}

// -------------------------------------------------------------------

// AreaCallbackInformationResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool AreaCallbackInformationResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool AreaCallbackInformationResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& AreaCallbackInformationResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& AreaCallbackInformationResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.AreaCallbackInformationResponse.header)
  return _internal_header();
}
inline void AreaCallbackInformationResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.AreaCallbackInformationResponse.header)
}
inline ::bosdyn::api::ResponseHeader* AreaCallbackInformationResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* AreaCallbackInformationResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.AreaCallbackInformationResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* AreaCallbackInformationResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* AreaCallbackInformationResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.AreaCallbackInformationResponse.header)
  return _msg;
}
inline void AreaCallbackInformationResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.AreaCallbackInformationResponse.header)
}

// .bosdyn.api.graph_nav.AreaCallbackInformation info = 2;
inline bool AreaCallbackInformationResponse::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool AreaCallbackInformationResponse::has_info() const {
  return _internal_has_info();
}
inline void AreaCallbackInformationResponse::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::AreaCallbackInformation& AreaCallbackInformationResponse::_internal_info() const {
  const ::bosdyn::api::graph_nav::AreaCallbackInformation* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::AreaCallbackInformation&>(
      ::bosdyn::api::graph_nav::_AreaCallbackInformation_default_instance_);
}
inline const ::bosdyn::api::graph_nav::AreaCallbackInformation& AreaCallbackInformationResponse::info() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.AreaCallbackInformationResponse.info)
  return _internal_info();
}
inline void AreaCallbackInformationResponse::unsafe_arena_set_allocated_info(
    ::bosdyn::api::graph_nav::AreaCallbackInformation* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.AreaCallbackInformationResponse.info)
}
inline ::bosdyn::api::graph_nav::AreaCallbackInformation* AreaCallbackInformationResponse::release_info() {
  
  ::bosdyn::api::graph_nav::AreaCallbackInformation* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::AreaCallbackInformation* AreaCallbackInformationResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.AreaCallbackInformationResponse.info)
  
  ::bosdyn::api::graph_nav::AreaCallbackInformation* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::AreaCallbackInformation* AreaCallbackInformationResponse::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::AreaCallbackInformation>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::bosdyn::api::graph_nav::AreaCallbackInformation* AreaCallbackInformationResponse::mutable_info() {
  ::bosdyn::api::graph_nav::AreaCallbackInformation* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.AreaCallbackInformationResponse.info)
  return _msg;
}
inline void AreaCallbackInformationResponse::set_allocated_info(::bosdyn::api::graph_nav::AreaCallbackInformation* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.AreaCallbackInformationResponse.info)
}

// -------------------------------------------------------------------

// RegionInformation

// string region_id = 1;
inline void RegionInformation::clear_region_id() {
  _impl_.region_id_.ClearToEmpty();
}
inline const std::string& RegionInformation::region_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.RegionInformation.region_id)
  return _internal_region_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionInformation::set_region_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.RegionInformation.region_id)
}
inline std::string* RegionInformation::mutable_region_id() {
  std::string* _s = _internal_mutable_region_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.RegionInformation.region_id)
  return _s;
}
inline const std::string& RegionInformation::_internal_region_id() const {
  return _impl_.region_id_.Get();
}
inline void RegionInformation::_internal_set_region_id(const std::string& value) {
  
  _impl_.region_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegionInformation::_internal_mutable_region_id() {
  
  return _impl_.region_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegionInformation::release_region_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.RegionInformation.region_id)
  return _impl_.region_id_.Release();
}
inline void RegionInformation::set_allocated_region_id(std::string* region_id) {
  if (region_id != nullptr) {
    
  } else {
    
  }
  _impl_.region_id_.SetAllocated(region_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_id_.IsDefault()) {
    _impl_.region_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.RegionInformation.region_id)
}

// string description = 2;
inline void RegionInformation::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& RegionInformation::description() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.RegionInformation.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionInformation::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.RegionInformation.description)
}
inline std::string* RegionInformation::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.RegionInformation.description)
  return _s;
}
inline const std::string& RegionInformation::_internal_description() const {
  return _impl_.description_.Get();
}
inline void RegionInformation::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* RegionInformation::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* RegionInformation::release_description() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.RegionInformation.description)
  return _impl_.description_.Release();
}
inline void RegionInformation::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.RegionInformation.description)
}

// .bosdyn.api.graph_nav.Route route = 3;
inline bool RegionInformation::_internal_has_route() const {
  return this != internal_default_instance() && _impl_.route_ != nullptr;
}
inline bool RegionInformation::has_route() const {
  return _internal_has_route();
}
inline const ::bosdyn::api::graph_nav::Route& RegionInformation::_internal_route() const {
  const ::bosdyn::api::graph_nav::Route* p = _impl_.route_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::Route&>(
      ::bosdyn::api::graph_nav::_Route_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Route& RegionInformation::route() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.RegionInformation.route)
  return _internal_route();
}
inline void RegionInformation::unsafe_arena_set_allocated_route(
    ::bosdyn::api::graph_nav::Route* route) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_);
  }
  _impl_.route_ = route;
  if (route) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.RegionInformation.route)
}
inline ::bosdyn::api::graph_nav::Route* RegionInformation::release_route() {
  
  ::bosdyn::api::graph_nav::Route* temp = _impl_.route_;
  _impl_.route_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::Route* RegionInformation::unsafe_arena_release_route() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.RegionInformation.route)
  
  ::bosdyn::api::graph_nav::Route* temp = _impl_.route_;
  _impl_.route_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Route* RegionInformation::_internal_mutable_route() {
  
  if (_impl_.route_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Route>(GetArenaForAllocation());
    _impl_.route_ = p;
  }
  return _impl_.route_;
}
inline ::bosdyn::api::graph_nav::Route* RegionInformation::mutable_route() {
  ::bosdyn::api::graph_nav::Route* _msg = _internal_mutable_route();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.RegionInformation.route)
  return _msg;
}
inline void RegionInformation::set_allocated_route(::bosdyn::api::graph_nav::Route* route) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_);
  }
  if (route) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(route));
    if (message_arena != submessage_arena) {
      route = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.route_ = route;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.RegionInformation.route)
}

// -------------------------------------------------------------------

// BeginCallbackRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool BeginCallbackRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool BeginCallbackRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& BeginCallbackRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& BeginCallbackRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.BeginCallbackRequest.header)
  return _internal_header();
}
inline void BeginCallbackRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.BeginCallbackRequest.header)
}
inline ::bosdyn::api::RequestHeader* BeginCallbackRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* BeginCallbackRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.BeginCallbackRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* BeginCallbackRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* BeginCallbackRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.BeginCallbackRequest.header)
  return _msg;
}
inline void BeginCallbackRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.BeginCallbackRequest.header)
}

// .bosdyn.api.graph_nav.RegionInformation region_info = 4;
inline bool BeginCallbackRequest::_internal_has_region_info() const {
  return this != internal_default_instance() && _impl_.region_info_ != nullptr;
}
inline bool BeginCallbackRequest::has_region_info() const {
  return _internal_has_region_info();
}
inline void BeginCallbackRequest::clear_region_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.region_info_ != nullptr) {
    delete _impl_.region_info_;
  }
  _impl_.region_info_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::RegionInformation& BeginCallbackRequest::_internal_region_info() const {
  const ::bosdyn::api::graph_nav::RegionInformation* p = _impl_.region_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::RegionInformation&>(
      ::bosdyn::api::graph_nav::_RegionInformation_default_instance_);
}
inline const ::bosdyn::api::graph_nav::RegionInformation& BeginCallbackRequest::region_info() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.BeginCallbackRequest.region_info)
  return _internal_region_info();
}
inline void BeginCallbackRequest::unsafe_arena_set_allocated_region_info(
    ::bosdyn::api::graph_nav::RegionInformation* region_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.region_info_);
  }
  _impl_.region_info_ = region_info;
  if (region_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.BeginCallbackRequest.region_info)
}
inline ::bosdyn::api::graph_nav::RegionInformation* BeginCallbackRequest::release_region_info() {
  
  ::bosdyn::api::graph_nav::RegionInformation* temp = _impl_.region_info_;
  _impl_.region_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::RegionInformation* BeginCallbackRequest::unsafe_arena_release_region_info() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.BeginCallbackRequest.region_info)
  
  ::bosdyn::api::graph_nav::RegionInformation* temp = _impl_.region_info_;
  _impl_.region_info_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::RegionInformation* BeginCallbackRequest::_internal_mutable_region_info() {
  
  if (_impl_.region_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::RegionInformation>(GetArenaForAllocation());
    _impl_.region_info_ = p;
  }
  return _impl_.region_info_;
}
inline ::bosdyn::api::graph_nav::RegionInformation* BeginCallbackRequest::mutable_region_info() {
  ::bosdyn::api::graph_nav::RegionInformation* _msg = _internal_mutable_region_info();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.BeginCallbackRequest.region_info)
  return _msg;
}
inline void BeginCallbackRequest::set_allocated_region_info(::bosdyn::api::graph_nav::RegionInformation* region_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.region_info_;
  }
  if (region_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(region_info);
    if (message_arena != submessage_arena) {
      region_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.region_info_ = region_info;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.BeginCallbackRequest.region_info)
}

// .google.protobuf.Timestamp end_time = 3;
inline bool BeginCallbackRequest::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool BeginCallbackRequest::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BeginCallbackRequest::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BeginCallbackRequest::end_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.BeginCallbackRequest.end_time)
  return _internal_end_time();
}
inline void BeginCallbackRequest::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.BeginCallbackRequest.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BeginCallbackRequest::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BeginCallbackRequest::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.BeginCallbackRequest.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BeginCallbackRequest::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BeginCallbackRequest::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.BeginCallbackRequest.end_time)
  return _msg;
}
inline void BeginCallbackRequest::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.BeginCallbackRequest.end_time)
}

// -------------------------------------------------------------------

// BeginCallbackResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool BeginCallbackResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool BeginCallbackResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& BeginCallbackResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& BeginCallbackResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.BeginCallbackResponse.header)
  return _internal_header();
}
inline void BeginCallbackResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.BeginCallbackResponse.header)
}
inline ::bosdyn::api::ResponseHeader* BeginCallbackResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* BeginCallbackResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.BeginCallbackResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* BeginCallbackResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* BeginCallbackResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.BeginCallbackResponse.header)
  return _msg;
}
inline void BeginCallbackResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.BeginCallbackResponse.header)
}

// .bosdyn.api.graph_nav.BeginCallbackResponse.Status status = 2;
inline void BeginCallbackResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::graph_nav::BeginCallbackResponse_Status BeginCallbackResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::BeginCallbackResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::graph_nav::BeginCallbackResponse_Status BeginCallbackResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.BeginCallbackResponse.status)
  return _internal_status();
}
inline void BeginCallbackResponse::_internal_set_status(::bosdyn::api::graph_nav::BeginCallbackResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void BeginCallbackResponse::set_status(::bosdyn::api::graph_nav::BeginCallbackResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.BeginCallbackResponse.status)
}

// uint32 command_id = 3;
inline void BeginCallbackResponse::clear_command_id() {
  _impl_.command_id_ = 0u;
}
inline uint32_t BeginCallbackResponse::_internal_command_id() const {
  return _impl_.command_id_;
}
inline uint32_t BeginCallbackResponse::command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.BeginCallbackResponse.command_id)
  return _internal_command_id();
}
inline void BeginCallbackResponse::_internal_set_command_id(uint32_t value) {
  
  _impl_.command_id_ = value;
}
inline void BeginCallbackResponse::set_command_id(uint32_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.BeginCallbackResponse.command_id)
}

// -------------------------------------------------------------------

// BeginControlRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool BeginControlRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool BeginControlRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& BeginControlRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& BeginControlRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.BeginControlRequest.header)
  return _internal_header();
}
inline void BeginControlRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.BeginControlRequest.header)
}
inline ::bosdyn::api::RequestHeader* BeginControlRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* BeginControlRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.BeginControlRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* BeginControlRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* BeginControlRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.BeginControlRequest.header)
  return _msg;
}
inline void BeginControlRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.BeginControlRequest.header)
}

// repeated .bosdyn.api.Lease leases = 2;
inline int BeginControlRequest::_internal_leases_size() const {
  return _impl_.leases_.size();
}
inline int BeginControlRequest::leases_size() const {
  return _internal_leases_size();
}
inline ::bosdyn::api::Lease* BeginControlRequest::mutable_leases(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.BeginControlRequest.leases)
  return _impl_.leases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
BeginControlRequest::mutable_leases() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.BeginControlRequest.leases)
  return &_impl_.leases_;
}
inline const ::bosdyn::api::Lease& BeginControlRequest::_internal_leases(int index) const {
  return _impl_.leases_.Get(index);
}
inline const ::bosdyn::api::Lease& BeginControlRequest::leases(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.BeginControlRequest.leases)
  return _internal_leases(index);
}
inline ::bosdyn::api::Lease* BeginControlRequest::_internal_add_leases() {
  return _impl_.leases_.Add();
}
inline ::bosdyn::api::Lease* BeginControlRequest::add_leases() {
  ::bosdyn::api::Lease* _add = _internal_add_leases();
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.BeginControlRequest.leases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
BeginControlRequest::leases() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.BeginControlRequest.leases)
  return _impl_.leases_;
}

// uint32 command_id = 3;
inline void BeginControlRequest::clear_command_id() {
  _impl_.command_id_ = 0u;
}
inline uint32_t BeginControlRequest::_internal_command_id() const {
  return _impl_.command_id_;
}
inline uint32_t BeginControlRequest::command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.BeginControlRequest.command_id)
  return _internal_command_id();
}
inline void BeginControlRequest::_internal_set_command_id(uint32_t value) {
  
  _impl_.command_id_ = value;
}
inline void BeginControlRequest::set_command_id(uint32_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.BeginControlRequest.command_id)
}

// -------------------------------------------------------------------

// BeginControlResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool BeginControlResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool BeginControlResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& BeginControlResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& BeginControlResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.BeginControlResponse.header)
  return _internal_header();
}
inline void BeginControlResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.BeginControlResponse.header)
}
inline ::bosdyn::api::ResponseHeader* BeginControlResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* BeginControlResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.BeginControlResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* BeginControlResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* BeginControlResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.BeginControlResponse.header)
  return _msg;
}
inline void BeginControlResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.BeginControlResponse.header)
}

// repeated .bosdyn.api.LeaseUseResult lease_use_results = 2;
inline int BeginControlResponse::_internal_lease_use_results_size() const {
  return _impl_.lease_use_results_.size();
}
inline int BeginControlResponse::lease_use_results_size() const {
  return _internal_lease_use_results_size();
}
inline ::bosdyn::api::LeaseUseResult* BeginControlResponse::mutable_lease_use_results(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.BeginControlResponse.lease_use_results)
  return _impl_.lease_use_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
BeginControlResponse::mutable_lease_use_results() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.BeginControlResponse.lease_use_results)
  return &_impl_.lease_use_results_;
}
inline const ::bosdyn::api::LeaseUseResult& BeginControlResponse::_internal_lease_use_results(int index) const {
  return _impl_.lease_use_results_.Get(index);
}
inline const ::bosdyn::api::LeaseUseResult& BeginControlResponse::lease_use_results(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.BeginControlResponse.lease_use_results)
  return _internal_lease_use_results(index);
}
inline ::bosdyn::api::LeaseUseResult* BeginControlResponse::_internal_add_lease_use_results() {
  return _impl_.lease_use_results_.Add();
}
inline ::bosdyn::api::LeaseUseResult* BeginControlResponse::add_lease_use_results() {
  ::bosdyn::api::LeaseUseResult* _add = _internal_add_lease_use_results();
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.BeginControlResponse.lease_use_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
BeginControlResponse::lease_use_results() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.BeginControlResponse.lease_use_results)
  return _impl_.lease_use_results_;
}

// .bosdyn.api.graph_nav.BeginControlResponse.Status status = 3;
inline void BeginControlResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::graph_nav::BeginControlResponse_Status BeginControlResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::BeginControlResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::graph_nav::BeginControlResponse_Status BeginControlResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.BeginControlResponse.status)
  return _internal_status();
}
inline void BeginControlResponse::_internal_set_status(::bosdyn::api::graph_nav::BeginControlResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void BeginControlResponse::set_status(::bosdyn::api::graph_nav::BeginControlResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.BeginControlResponse.status)
}

// -------------------------------------------------------------------

// UpdateCallbackRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool UpdateCallbackRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool UpdateCallbackRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& UpdateCallbackRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& UpdateCallbackRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UpdateCallbackRequest.header)
  return _internal_header();
}
inline void UpdateCallbackRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UpdateCallbackRequest.header)
}
inline ::bosdyn::api::RequestHeader* UpdateCallbackRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* UpdateCallbackRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UpdateCallbackRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* UpdateCallbackRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* UpdateCallbackRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UpdateCallbackRequest.header)
  return _msg;
}
inline void UpdateCallbackRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UpdateCallbackRequest.header)
}

// uint32 command_id = 2;
inline void UpdateCallbackRequest::clear_command_id() {
  _impl_.command_id_ = 0u;
}
inline uint32_t UpdateCallbackRequest::_internal_command_id() const {
  return _impl_.command_id_;
}
inline uint32_t UpdateCallbackRequest::command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UpdateCallbackRequest.command_id)
  return _internal_command_id();
}
inline void UpdateCallbackRequest::_internal_set_command_id(uint32_t value) {
  
  _impl_.command_id_ = value;
}
inline void UpdateCallbackRequest::set_command_id(uint32_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UpdateCallbackRequest.command_id)
}

// .google.protobuf.Timestamp end_time = 3;
inline bool UpdateCallbackRequest::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool UpdateCallbackRequest::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateCallbackRequest::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateCallbackRequest::end_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UpdateCallbackRequest.end_time)
  return _internal_end_time();
}
inline void UpdateCallbackRequest::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UpdateCallbackRequest.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateCallbackRequest::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateCallbackRequest::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UpdateCallbackRequest.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateCallbackRequest::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateCallbackRequest::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UpdateCallbackRequest.end_time)
  return _msg;
}
inline void UpdateCallbackRequest::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UpdateCallbackRequest.end_time)
}

// .bosdyn.api.graph_nav.UpdateCallbackRequest.Stage stage = 4;
inline void UpdateCallbackRequest::clear_stage() {
  _impl_.stage_ = 0;
}
inline ::bosdyn::api::graph_nav::UpdateCallbackRequest_Stage UpdateCallbackRequest::_internal_stage() const {
  return static_cast< ::bosdyn::api::graph_nav::UpdateCallbackRequest_Stage >(_impl_.stage_);
}
inline ::bosdyn::api::graph_nav::UpdateCallbackRequest_Stage UpdateCallbackRequest::stage() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UpdateCallbackRequest.stage)
  return _internal_stage();
}
inline void UpdateCallbackRequest::_internal_set_stage(::bosdyn::api::graph_nav::UpdateCallbackRequest_Stage value) {
  
  _impl_.stage_ = value;
}
inline void UpdateCallbackRequest::set_stage(::bosdyn::api::graph_nav::UpdateCallbackRequest_Stage value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UpdateCallbackRequest.stage)
}

// -------------------------------------------------------------------

// UpdateCallbackResponse_NavPolicy

// .bosdyn.api.graph_nav.UpdateCallbackResponse.NavPolicy.Option at_start = 1;
inline void UpdateCallbackResponse_NavPolicy::clear_at_start() {
  _impl_.at_start_ = 0;
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option UpdateCallbackResponse_NavPolicy::_internal_at_start() const {
  return static_cast< ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option >(_impl_.at_start_);
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option UpdateCallbackResponse_NavPolicy::at_start() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UpdateCallbackResponse.NavPolicy.at_start)
  return _internal_at_start();
}
inline void UpdateCallbackResponse_NavPolicy::_internal_set_at_start(::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option value) {
  
  _impl_.at_start_ = value;
}
inline void UpdateCallbackResponse_NavPolicy::set_at_start(::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option value) {
  _internal_set_at_start(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UpdateCallbackResponse.NavPolicy.at_start)
}

// .bosdyn.api.graph_nav.UpdateCallbackResponse.NavPolicy.Option at_end = 2;
inline void UpdateCallbackResponse_NavPolicy::clear_at_end() {
  _impl_.at_end_ = 0;
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option UpdateCallbackResponse_NavPolicy::_internal_at_end() const {
  return static_cast< ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option >(_impl_.at_end_);
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option UpdateCallbackResponse_NavPolicy::at_end() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UpdateCallbackResponse.NavPolicy.at_end)
  return _internal_at_end();
}
inline void UpdateCallbackResponse_NavPolicy::_internal_set_at_end(::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option value) {
  
  _impl_.at_end_ = value;
}
inline void UpdateCallbackResponse_NavPolicy::set_at_end(::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option value) {
  _internal_set_at_end(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UpdateCallbackResponse.NavPolicy.at_end)
}

// -------------------------------------------------------------------

// UpdateCallbackResponse_Error

// .bosdyn.api.graph_nav.UpdateCallbackResponse.Error.ErrorType error = 1;
inline void UpdateCallbackResponse_Error::clear_error() {
  _impl_.error_ = 0;
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error_ErrorType UpdateCallbackResponse_Error::_internal_error() const {
  return static_cast< ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error_ErrorType >(_impl_.error_);
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error_ErrorType UpdateCallbackResponse_Error::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UpdateCallbackResponse.Error.error)
  return _internal_error();
}
inline void UpdateCallbackResponse_Error::_internal_set_error(::bosdyn::api::graph_nav::UpdateCallbackResponse_Error_ErrorType value) {
  
  _impl_.error_ = value;
}
inline void UpdateCallbackResponse_Error::set_error(::bosdyn::api::graph_nav::UpdateCallbackResponse_Error_ErrorType value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UpdateCallbackResponse.Error.error)
}

// repeated .bosdyn.api.LeaseUseResult lease_use_results = 2;
inline int UpdateCallbackResponse_Error::_internal_lease_use_results_size() const {
  return _impl_.lease_use_results_.size();
}
inline int UpdateCallbackResponse_Error::lease_use_results_size() const {
  return _internal_lease_use_results_size();
}
inline ::bosdyn::api::LeaseUseResult* UpdateCallbackResponse_Error::mutable_lease_use_results(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UpdateCallbackResponse.Error.lease_use_results)
  return _impl_.lease_use_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
UpdateCallbackResponse_Error::mutable_lease_use_results() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.UpdateCallbackResponse.Error.lease_use_results)
  return &_impl_.lease_use_results_;
}
inline const ::bosdyn::api::LeaseUseResult& UpdateCallbackResponse_Error::_internal_lease_use_results(int index) const {
  return _impl_.lease_use_results_.Get(index);
}
inline const ::bosdyn::api::LeaseUseResult& UpdateCallbackResponse_Error::lease_use_results(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UpdateCallbackResponse.Error.lease_use_results)
  return _internal_lease_use_results(index);
}
inline ::bosdyn::api::LeaseUseResult* UpdateCallbackResponse_Error::_internal_add_lease_use_results() {
  return _impl_.lease_use_results_.Add();
}
inline ::bosdyn::api::LeaseUseResult* UpdateCallbackResponse_Error::add_lease_use_results() {
  ::bosdyn::api::LeaseUseResult* _add = _internal_add_lease_use_results();
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.UpdateCallbackResponse.Error.lease_use_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
UpdateCallbackResponse_Error::lease_use_results() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.UpdateCallbackResponse.Error.lease_use_results)
  return _impl_.lease_use_results_;
}

// -------------------------------------------------------------------

// UpdateCallbackResponse_Complete

// -------------------------------------------------------------------

// UpdateCallbackResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool UpdateCallbackResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool UpdateCallbackResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& UpdateCallbackResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& UpdateCallbackResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UpdateCallbackResponse.header)
  return _internal_header();
}
inline void UpdateCallbackResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UpdateCallbackResponse.header)
}
inline ::bosdyn::api::ResponseHeader* UpdateCallbackResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* UpdateCallbackResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UpdateCallbackResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* UpdateCallbackResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* UpdateCallbackResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UpdateCallbackResponse.header)
  return _msg;
}
inline void UpdateCallbackResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UpdateCallbackResponse.header)
}

// .bosdyn.api.graph_nav.UpdateCallbackResponse.Status status = 2;
inline void UpdateCallbackResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_Status UpdateCallbackResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::UpdateCallbackResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_Status UpdateCallbackResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UpdateCallbackResponse.status)
  return _internal_status();
}
inline void UpdateCallbackResponse::_internal_set_status(::bosdyn::api::graph_nav::UpdateCallbackResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void UpdateCallbackResponse::set_status(::bosdyn::api::graph_nav::UpdateCallbackResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UpdateCallbackResponse.status)
}

// .bosdyn.api.graph_nav.UpdateCallbackResponse.NavPolicy policy = 3;
inline bool UpdateCallbackResponse::_internal_has_policy() const {
  return response_case() == kPolicy;
}
inline bool UpdateCallbackResponse::has_policy() const {
  return _internal_has_policy();
}
inline void UpdateCallbackResponse::set_has_policy() {
  _impl_._oneof_case_[0] = kPolicy;
}
inline void UpdateCallbackResponse::clear_policy() {
  if (_internal_has_policy()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.policy_;
    }
    clear_has_response();
  }
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy* UpdateCallbackResponse::release_policy() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UpdateCallbackResponse.policy)
  if (_internal_has_policy()) {
    clear_has_response();
    ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy* temp = _impl_.response_.policy_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.policy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy& UpdateCallbackResponse::_internal_policy() const {
  return _internal_has_policy()
      ? *_impl_.response_.policy_
      : reinterpret_cast< ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy&>(::bosdyn::api::graph_nav::_UpdateCallbackResponse_NavPolicy_default_instance_);
}
inline const ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy& UpdateCallbackResponse::policy() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UpdateCallbackResponse.policy)
  return _internal_policy();
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy* UpdateCallbackResponse::unsafe_arena_release_policy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.graph_nav.UpdateCallbackResponse.policy)
  if (_internal_has_policy()) {
    clear_has_response();
    ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy* temp = _impl_.response_.policy_;
    _impl_.response_.policy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateCallbackResponse::unsafe_arena_set_allocated_policy(::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy* policy) {
  clear_response();
  if (policy) {
    set_has_policy();
    _impl_.response_.policy_ = policy;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UpdateCallbackResponse.policy)
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy* UpdateCallbackResponse::_internal_mutable_policy() {
  if (!_internal_has_policy()) {
    clear_response();
    set_has_policy();
    _impl_.response_.policy_ = CreateMaybeMessage< ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy >(GetArenaForAllocation());
  }
  return _impl_.response_.policy_;
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy* UpdateCallbackResponse::mutable_policy() {
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy* _msg = _internal_mutable_policy();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UpdateCallbackResponse.policy)
  return _msg;
}

// .bosdyn.api.graph_nav.UpdateCallbackResponse.Error error = 4;
inline bool UpdateCallbackResponse::_internal_has_error() const {
  return response_case() == kError;
}
inline bool UpdateCallbackResponse::has_error() const {
  return _internal_has_error();
}
inline void UpdateCallbackResponse::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void UpdateCallbackResponse::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.error_;
    }
    clear_has_response();
  }
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error* UpdateCallbackResponse::release_error() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UpdateCallbackResponse.error)
  if (_internal_has_error()) {
    clear_has_response();
    ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error* temp = _impl_.response_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error& UpdateCallbackResponse::_internal_error() const {
  return _internal_has_error()
      ? *_impl_.response_.error_
      : reinterpret_cast< ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error&>(::bosdyn::api::graph_nav::_UpdateCallbackResponse_Error_default_instance_);
}
inline const ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error& UpdateCallbackResponse::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UpdateCallbackResponse.error)
  return _internal_error();
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error* UpdateCallbackResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.graph_nav.UpdateCallbackResponse.error)
  if (_internal_has_error()) {
    clear_has_response();
    ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error* temp = _impl_.response_.error_;
    _impl_.response_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateCallbackResponse::unsafe_arena_set_allocated_error(::bosdyn::api::graph_nav::UpdateCallbackResponse_Error* error) {
  clear_response();
  if (error) {
    set_has_error();
    _impl_.response_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UpdateCallbackResponse.error)
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error* UpdateCallbackResponse::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_response();
    set_has_error();
    _impl_.response_.error_ = CreateMaybeMessage< ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error >(GetArenaForAllocation());
  }
  return _impl_.response_.error_;
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error* UpdateCallbackResponse::mutable_error() {
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UpdateCallbackResponse.error)
  return _msg;
}

// .bosdyn.api.graph_nav.UpdateCallbackResponse.Complete complete = 5;
inline bool UpdateCallbackResponse::_internal_has_complete() const {
  return response_case() == kComplete;
}
inline bool UpdateCallbackResponse::has_complete() const {
  return _internal_has_complete();
}
inline void UpdateCallbackResponse::set_has_complete() {
  _impl_._oneof_case_[0] = kComplete;
}
inline void UpdateCallbackResponse::clear_complete() {
  if (_internal_has_complete()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.complete_;
    }
    clear_has_response();
  }
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete* UpdateCallbackResponse::release_complete() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UpdateCallbackResponse.complete)
  if (_internal_has_complete()) {
    clear_has_response();
    ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete* temp = _impl_.response_.complete_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.complete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete& UpdateCallbackResponse::_internal_complete() const {
  return _internal_has_complete()
      ? *_impl_.response_.complete_
      : reinterpret_cast< ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete&>(::bosdyn::api::graph_nav::_UpdateCallbackResponse_Complete_default_instance_);
}
inline const ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete& UpdateCallbackResponse::complete() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UpdateCallbackResponse.complete)
  return _internal_complete();
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete* UpdateCallbackResponse::unsafe_arena_release_complete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.graph_nav.UpdateCallbackResponse.complete)
  if (_internal_has_complete()) {
    clear_has_response();
    ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete* temp = _impl_.response_.complete_;
    _impl_.response_.complete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateCallbackResponse::unsafe_arena_set_allocated_complete(::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete* complete) {
  clear_response();
  if (complete) {
    set_has_complete();
    _impl_.response_.complete_ = complete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UpdateCallbackResponse.complete)
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete* UpdateCallbackResponse::_internal_mutable_complete() {
  if (!_internal_has_complete()) {
    clear_response();
    set_has_complete();
    _impl_.response_.complete_ = CreateMaybeMessage< ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete >(GetArenaForAllocation());
  }
  return _impl_.response_.complete_;
}
inline ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete* UpdateCallbackResponse::mutable_complete() {
  ::bosdyn::api::graph_nav::UpdateCallbackResponse_Complete* _msg = _internal_mutable_complete();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UpdateCallbackResponse.complete)
  return _msg;
}

inline bool UpdateCallbackResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void UpdateCallbackResponse::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline UpdateCallbackResponse::ResponseCase UpdateCallbackResponse::response_case() const {
  return UpdateCallbackResponse::ResponseCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EndCallbackRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool EndCallbackRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool EndCallbackRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& EndCallbackRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& EndCallbackRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.EndCallbackRequest.header)
  return _internal_header();
}
inline void EndCallbackRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.EndCallbackRequest.header)
}
inline ::bosdyn::api::RequestHeader* EndCallbackRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* EndCallbackRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.EndCallbackRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* EndCallbackRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* EndCallbackRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.EndCallbackRequest.header)
  return _msg;
}
inline void EndCallbackRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.EndCallbackRequest.header)
}

// uint32 command_id = 2;
inline void EndCallbackRequest::clear_command_id() {
  _impl_.command_id_ = 0u;
}
inline uint32_t EndCallbackRequest::_internal_command_id() const {
  return _impl_.command_id_;
}
inline uint32_t EndCallbackRequest::command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.EndCallbackRequest.command_id)
  return _internal_command_id();
}
inline void EndCallbackRequest::_internal_set_command_id(uint32_t value) {
  
  _impl_.command_id_ = value;
}
inline void EndCallbackRequest::set_command_id(uint32_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.EndCallbackRequest.command_id)
}

// -------------------------------------------------------------------

// EndCallbackResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool EndCallbackResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool EndCallbackResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& EndCallbackResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& EndCallbackResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.EndCallbackResponse.header)
  return _internal_header();
}
inline void EndCallbackResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.EndCallbackResponse.header)
}
inline ::bosdyn::api::ResponseHeader* EndCallbackResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* EndCallbackResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.EndCallbackResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* EndCallbackResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* EndCallbackResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.EndCallbackResponse.header)
  return _msg;
}
inline void EndCallbackResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.EndCallbackResponse.header)
}

// .bosdyn.api.graph_nav.EndCallbackResponse.Status status = 2;
inline void EndCallbackResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::graph_nav::EndCallbackResponse_Status EndCallbackResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::EndCallbackResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::graph_nav::EndCallbackResponse_Status EndCallbackResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.EndCallbackResponse.status)
  return _internal_status();
}
inline void EndCallbackResponse::_internal_set_status(::bosdyn::api::graph_nav::EndCallbackResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void EndCallbackResponse::set_status(::bosdyn::api::graph_nav::EndCallbackResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.EndCallbackResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace graph_nav
}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::graph_nav::AreaCallbackError_CallError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::AreaCallbackError_CallError>() {
  return ::bosdyn::api::graph_nav::AreaCallbackError_CallError_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::BeginCallbackResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::BeginCallbackResponse_Status>() {
  return ::bosdyn::api::graph_nav::BeginCallbackResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::BeginControlResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::BeginControlResponse_Status>() {
  return ::bosdyn::api::graph_nav::BeginControlResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::UpdateCallbackRequest_Stage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::UpdateCallbackRequest_Stage>() {
  return ::bosdyn::api::graph_nav::UpdateCallbackRequest_Stage_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option>() {
  return ::bosdyn::api::graph_nav::UpdateCallbackResponse_NavPolicy_Option_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error_ErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error_ErrorType>() {
  return ::bosdyn::api::graph_nav::UpdateCallbackResponse_Error_ErrorType_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::UpdateCallbackResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::UpdateCallbackResponse_Status>() {
  return ::bosdyn::api::graph_nav::UpdateCallbackResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::EndCallbackResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::EndCallbackResponse_Status>() {
  return ::bosdyn::api::graph_nav::EndCallbackResponse_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fgraph_5fnav_2farea_5fcallback_2eproto
