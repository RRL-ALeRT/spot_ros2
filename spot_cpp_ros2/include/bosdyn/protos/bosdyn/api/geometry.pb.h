// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/geometry.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fgeometry_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fgeometry_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fgeometry_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fgeometry_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fgeometry_2eproto;
namespace bosdyn {
namespace api {
class Area;
struct AreaDefaultTypeInternal;
extern AreaDefaultTypeInternal _Area_default_instance_;
class Bounds;
struct BoundsDefaultTypeInternal;
extern BoundsDefaultTypeInternal _Bounds_default_instance_;
class Box2;
struct Box2DefaultTypeInternal;
extern Box2DefaultTypeInternal _Box2_default_instance_;
class Box2WithFrame;
struct Box2WithFrameDefaultTypeInternal;
extern Box2WithFrameDefaultTypeInternal _Box2WithFrame_default_instance_;
class Box3;
struct Box3DefaultTypeInternal;
extern Box3DefaultTypeInternal _Box3_default_instance_;
class Box3WithFrame;
struct Box3WithFrameDefaultTypeInternal;
extern Box3WithFrameDefaultTypeInternal _Box3WithFrame_default_instance_;
class Circle;
struct CircleDefaultTypeInternal;
extern CircleDefaultTypeInternal _Circle_default_instance_;
class CylindricalCoordinate;
struct CylindricalCoordinateDefaultTypeInternal;
extern CylindricalCoordinateDefaultTypeInternal _CylindricalCoordinate_default_instance_;
class FrameTreeSnapshot;
struct FrameTreeSnapshotDefaultTypeInternal;
extern FrameTreeSnapshotDefaultTypeInternal _FrameTreeSnapshot_default_instance_;
class FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse;
struct FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUseDefaultTypeInternal;
extern FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUseDefaultTypeInternal _FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse_default_instance_;
class FrameTreeSnapshot_ParentEdge;
struct FrameTreeSnapshot_ParentEdgeDefaultTypeInternal;
extern FrameTreeSnapshot_ParentEdgeDefaultTypeInternal _FrameTreeSnapshot_ParentEdge_default_instance_;
class Matrix;
struct MatrixDefaultTypeInternal;
extern MatrixDefaultTypeInternal _Matrix_default_instance_;
class MatrixInt32;
struct MatrixInt32DefaultTypeInternal;
extern MatrixInt32DefaultTypeInternal _MatrixInt32_default_instance_;
class MatrixInt64;
struct MatrixInt64DefaultTypeInternal;
extern MatrixInt64DefaultTypeInternal _MatrixInt64_default_instance_;
class Matrixf;
struct MatrixfDefaultTypeInternal;
extern MatrixfDefaultTypeInternal _Matrixf_default_instance_;
class Plane;
struct PlaneDefaultTypeInternal;
extern PlaneDefaultTypeInternal _Plane_default_instance_;
class PolyLine;
struct PolyLineDefaultTypeInternal;
extern PolyLineDefaultTypeInternal _PolyLine_default_instance_;
class Polygon;
struct PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class PolygonWithExclusions;
struct PolygonWithExclusionsDefaultTypeInternal;
extern PolygonWithExclusionsDefaultTypeInternal _PolygonWithExclusions_default_instance_;
class Quad;
struct QuadDefaultTypeInternal;
extern QuadDefaultTypeInternal _Quad_default_instance_;
class Quaternion;
struct QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class Ray;
struct RayDefaultTypeInternal;
extern RayDefaultTypeInternal _Ray_default_instance_;
class SE2Pose;
struct SE2PoseDefaultTypeInternal;
extern SE2PoseDefaultTypeInternal _SE2Pose_default_instance_;
class SE2Velocity;
struct SE2VelocityDefaultTypeInternal;
extern SE2VelocityDefaultTypeInternal _SE2Velocity_default_instance_;
class SE2VelocityLimit;
struct SE2VelocityLimitDefaultTypeInternal;
extern SE2VelocityLimitDefaultTypeInternal _SE2VelocityLimit_default_instance_;
class SE3Covariance;
struct SE3CovarianceDefaultTypeInternal;
extern SE3CovarianceDefaultTypeInternal _SE3Covariance_default_instance_;
class SE3Pose;
struct SE3PoseDefaultTypeInternal;
extern SE3PoseDefaultTypeInternal _SE3Pose_default_instance_;
class SE3Velocity;
struct SE3VelocityDefaultTypeInternal;
extern SE3VelocityDefaultTypeInternal _SE3Velocity_default_instance_;
class Vec2;
struct Vec2DefaultTypeInternal;
extern Vec2DefaultTypeInternal _Vec2_default_instance_;
class Vec2Value;
struct Vec2ValueDefaultTypeInternal;
extern Vec2ValueDefaultTypeInternal _Vec2Value_default_instance_;
class Vec3;
struct Vec3DefaultTypeInternal;
extern Vec3DefaultTypeInternal _Vec3_default_instance_;
class Vec3Value;
struct Vec3ValueDefaultTypeInternal;
extern Vec3ValueDefaultTypeInternal _Vec3Value_default_instance_;
class Vector;
struct VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
class Volume;
struct VolumeDefaultTypeInternal;
extern VolumeDefaultTypeInternal _Volume_default_instance_;
class Wrench;
struct WrenchDefaultTypeInternal;
extern WrenchDefaultTypeInternal _Wrench_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::Area* Arena::CreateMaybeMessage<::bosdyn::api::Area>(Arena*);
template<> ::bosdyn::api::Bounds* Arena::CreateMaybeMessage<::bosdyn::api::Bounds>(Arena*);
template<> ::bosdyn::api::Box2* Arena::CreateMaybeMessage<::bosdyn::api::Box2>(Arena*);
template<> ::bosdyn::api::Box2WithFrame* Arena::CreateMaybeMessage<::bosdyn::api::Box2WithFrame>(Arena*);
template<> ::bosdyn::api::Box3* Arena::CreateMaybeMessage<::bosdyn::api::Box3>(Arena*);
template<> ::bosdyn::api::Box3WithFrame* Arena::CreateMaybeMessage<::bosdyn::api::Box3WithFrame>(Arena*);
template<> ::bosdyn::api::Circle* Arena::CreateMaybeMessage<::bosdyn::api::Circle>(Arena*);
template<> ::bosdyn::api::CylindricalCoordinate* Arena::CreateMaybeMessage<::bosdyn::api::CylindricalCoordinate>(Arena*);
template<> ::bosdyn::api::FrameTreeSnapshot* Arena::CreateMaybeMessage<::bosdyn::api::FrameTreeSnapshot>(Arena*);
template<> ::bosdyn::api::FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::FrameTreeSnapshot_ParentEdge* Arena::CreateMaybeMessage<::bosdyn::api::FrameTreeSnapshot_ParentEdge>(Arena*);
template<> ::bosdyn::api::Matrix* Arena::CreateMaybeMessage<::bosdyn::api::Matrix>(Arena*);
template<> ::bosdyn::api::MatrixInt32* Arena::CreateMaybeMessage<::bosdyn::api::MatrixInt32>(Arena*);
template<> ::bosdyn::api::MatrixInt64* Arena::CreateMaybeMessage<::bosdyn::api::MatrixInt64>(Arena*);
template<> ::bosdyn::api::Matrixf* Arena::CreateMaybeMessage<::bosdyn::api::Matrixf>(Arena*);
template<> ::bosdyn::api::Plane* Arena::CreateMaybeMessage<::bosdyn::api::Plane>(Arena*);
template<> ::bosdyn::api::PolyLine* Arena::CreateMaybeMessage<::bosdyn::api::PolyLine>(Arena*);
template<> ::bosdyn::api::Polygon* Arena::CreateMaybeMessage<::bosdyn::api::Polygon>(Arena*);
template<> ::bosdyn::api::PolygonWithExclusions* Arena::CreateMaybeMessage<::bosdyn::api::PolygonWithExclusions>(Arena*);
template<> ::bosdyn::api::Quad* Arena::CreateMaybeMessage<::bosdyn::api::Quad>(Arena*);
template<> ::bosdyn::api::Quaternion* Arena::CreateMaybeMessage<::bosdyn::api::Quaternion>(Arena*);
template<> ::bosdyn::api::Ray* Arena::CreateMaybeMessage<::bosdyn::api::Ray>(Arena*);
template<> ::bosdyn::api::SE2Pose* Arena::CreateMaybeMessage<::bosdyn::api::SE2Pose>(Arena*);
template<> ::bosdyn::api::SE2Velocity* Arena::CreateMaybeMessage<::bosdyn::api::SE2Velocity>(Arena*);
template<> ::bosdyn::api::SE2VelocityLimit* Arena::CreateMaybeMessage<::bosdyn::api::SE2VelocityLimit>(Arena*);
template<> ::bosdyn::api::SE3Covariance* Arena::CreateMaybeMessage<::bosdyn::api::SE3Covariance>(Arena*);
template<> ::bosdyn::api::SE3Pose* Arena::CreateMaybeMessage<::bosdyn::api::SE3Pose>(Arena*);
template<> ::bosdyn::api::SE3Velocity* Arena::CreateMaybeMessage<::bosdyn::api::SE3Velocity>(Arena*);
template<> ::bosdyn::api::Vec2* Arena::CreateMaybeMessage<::bosdyn::api::Vec2>(Arena*);
template<> ::bosdyn::api::Vec2Value* Arena::CreateMaybeMessage<::bosdyn::api::Vec2Value>(Arena*);
template<> ::bosdyn::api::Vec3* Arena::CreateMaybeMessage<::bosdyn::api::Vec3>(Arena*);
template<> ::bosdyn::api::Vec3Value* Arena::CreateMaybeMessage<::bosdyn::api::Vec3Value>(Arena*);
template<> ::bosdyn::api::Vector* Arena::CreateMaybeMessage<::bosdyn::api::Vector>(Arena*);
template<> ::bosdyn::api::Volume* Arena::CreateMaybeMessage<::bosdyn::api::Volume>(Arena*);
template<> ::bosdyn::api::Wrench* Arena::CreateMaybeMessage<::bosdyn::api::Wrench>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

// ===================================================================

class Vec2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Vec2) */ {
 public:
  inline Vec2() : Vec2(nullptr) {}
  ~Vec2() override;
  explicit PROTOBUF_CONSTEXPR Vec2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec2(const Vec2& from);
  Vec2(Vec2&& from) noexcept
    : Vec2() {
    *this = ::std::move(from);
  }

  inline Vec2& operator=(const Vec2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2& operator=(Vec2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec2& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec2* internal_default_instance() {
    return reinterpret_cast<const Vec2*>(
               &_Vec2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vec2& a, Vec2& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vec2& from) {
    Vec2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Vec2";
  }
  protected:
  explicit Vec2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Vec2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double x_;
    double y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Vec3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Vec3) */ {
 public:
  inline Vec3() : Vec3(nullptr) {}
  ~Vec3() override;
  explicit PROTOBUF_CONSTEXPR Vec3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec3(const Vec3& from);
  Vec3(Vec3&& from) noexcept
    : Vec3() {
    *this = ::std::move(from);
  }

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3& operator=(Vec3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec3* internal_default_instance() {
    return reinterpret_cast<const Vec3*>(
               &_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vec3& a, Vec3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vec3& from) {
    Vec3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Vec3";
  }
  protected:
  explicit Vec3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Vec3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double x_;
    double y_;
    double z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class CylindricalCoordinate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.CylindricalCoordinate) */ {
 public:
  inline CylindricalCoordinate() : CylindricalCoordinate(nullptr) {}
  ~CylindricalCoordinate() override;
  explicit PROTOBUF_CONSTEXPR CylindricalCoordinate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CylindricalCoordinate(const CylindricalCoordinate& from);
  CylindricalCoordinate(CylindricalCoordinate&& from) noexcept
    : CylindricalCoordinate() {
    *this = ::std::move(from);
  }

  inline CylindricalCoordinate& operator=(const CylindricalCoordinate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CylindricalCoordinate& operator=(CylindricalCoordinate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CylindricalCoordinate& default_instance() {
    return *internal_default_instance();
  }
  static inline const CylindricalCoordinate* internal_default_instance() {
    return reinterpret_cast<const CylindricalCoordinate*>(
               &_CylindricalCoordinate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CylindricalCoordinate& a, CylindricalCoordinate& b) {
    a.Swap(&b);
  }
  inline void Swap(CylindricalCoordinate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CylindricalCoordinate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CylindricalCoordinate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CylindricalCoordinate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CylindricalCoordinate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CylindricalCoordinate& from) {
    CylindricalCoordinate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CylindricalCoordinate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.CylindricalCoordinate";
  }
  protected:
  explicit CylindricalCoordinate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kThetaFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double r = 1;
  void clear_r();
  double r() const;
  void set_r(double value);
  private:
  double _internal_r() const;
  void _internal_set_r(double value);
  public:

  // double theta = 2;
  void clear_theta();
  double theta() const;
  void set_theta(double value);
  private:
  double _internal_theta() const;
  void _internal_set_theta(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.CylindricalCoordinate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double r_;
    double theta_;
    double z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Quaternion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  ~Quaternion() override;
  explicit PROTOBUF_CONSTEXPR Quaternion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Quaternion(const Quaternion& from);
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Quaternion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Quaternion& from) {
    Quaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Quaternion";
  }
  protected:
  explicit Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // double w = 4;
  void clear_w();
  double w() const;
  void set_w(double value);
  private:
  double _internal_w() const;
  void _internal_set_w(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Quaternion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double x_;
    double y_;
    double z_;
    double w_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Plane final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Plane) */ {
 public:
  inline Plane() : Plane(nullptr) {}
  ~Plane() override;
  explicit PROTOBUF_CONSTEXPR Plane(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Plane(const Plane& from);
  Plane(Plane&& from) noexcept
    : Plane() {
    *this = ::std::move(from);
  }

  inline Plane& operator=(const Plane& from) {
    CopyFrom(from);
    return *this;
  }
  inline Plane& operator=(Plane&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Plane& default_instance() {
    return *internal_default_instance();
  }
  static inline const Plane* internal_default_instance() {
    return reinterpret_cast<const Plane*>(
               &_Plane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Plane& a, Plane& b) {
    a.Swap(&b);
  }
  inline void Swap(Plane* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Plane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Plane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Plane>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Plane& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Plane& from) {
    Plane::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Plane* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Plane";
  }
  protected:
  explicit Plane(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
    kNormalFieldNumber = 2,
  };
  // .bosdyn.api.Vec3 point = 1;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::bosdyn::api::Vec3& point() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_point();
  ::bosdyn::api::Vec3* mutable_point();
  void set_allocated_point(::bosdyn::api::Vec3* point);
  private:
  const ::bosdyn::api::Vec3& _internal_point() const;
  ::bosdyn::api::Vec3* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::bosdyn::api::Vec3* point);
  ::bosdyn::api::Vec3* unsafe_arena_release_point();

  // .bosdyn.api.Vec3 normal = 2;
  bool has_normal() const;
  private:
  bool _internal_has_normal() const;
  public:
  void clear_normal();
  const ::bosdyn::api::Vec3& normal() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_normal();
  ::bosdyn::api::Vec3* mutable_normal();
  void set_allocated_normal(::bosdyn::api::Vec3* normal);
  private:
  const ::bosdyn::api::Vec3& _internal_normal() const;
  ::bosdyn::api::Vec3* _internal_mutable_normal();
  public:
  void unsafe_arena_set_allocated_normal(
      ::bosdyn::api::Vec3* normal);
  ::bosdyn::api::Vec3* unsafe_arena_release_normal();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Plane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec3* point_;
    ::bosdyn::api::Vec3* normal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Quad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Quad) */ {
 public:
  inline Quad() : Quad(nullptr) {}
  ~Quad() override;
  explicit PROTOBUF_CONSTEXPR Quad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Quad(const Quad& from);
  Quad(Quad&& from) noexcept
    : Quad() {
    *this = ::std::move(from);
  }

  inline Quad& operator=(const Quad& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quad& operator=(Quad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quad& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quad* internal_default_instance() {
    return reinterpret_cast<const Quad*>(
               &_Quad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Quad& a, Quad& b) {
    a.Swap(&b);
  }
  inline void Swap(Quad* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Quad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Quad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Quad& from) {
    Quad::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quad* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Quad";
  }
  protected:
  explicit Quad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // .bosdyn.api.SE3Pose pose = 1;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::bosdyn::api::SE3Pose& pose() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Pose* release_pose();
  ::bosdyn::api::SE3Pose* mutable_pose();
  void set_allocated_pose(::bosdyn::api::SE3Pose* pose);
  private:
  const ::bosdyn::api::SE3Pose& _internal_pose() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::bosdyn::api::SE3Pose* pose);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_pose();

  // double size = 2;
  void clear_size();
  double size() const;
  void set_size(double value);
  private:
  double _internal_size() const;
  void _internal_set_size(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Quad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::SE3Pose* pose_;
    double size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Ray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Ray) */ {
 public:
  inline Ray() : Ray(nullptr) {}
  ~Ray() override;
  explicit PROTOBUF_CONSTEXPR Ray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ray(const Ray& from);
  Ray(Ray&& from) noexcept
    : Ray() {
    *this = ::std::move(from);
  }

  inline Ray& operator=(const Ray& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ray& operator=(Ray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ray& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ray* internal_default_instance() {
    return reinterpret_cast<const Ray*>(
               &_Ray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Ray& a, Ray& b) {
    a.Swap(&b);
  }
  inline void Swap(Ray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ray& from) {
    Ray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ray* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Ray";
  }
  protected:
  explicit Ray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginFieldNumber = 1,
    kDirectionFieldNumber = 2,
  };
  // .bosdyn.api.Vec3 origin = 1;
  bool has_origin() const;
  private:
  bool _internal_has_origin() const;
  public:
  void clear_origin();
  const ::bosdyn::api::Vec3& origin() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_origin();
  ::bosdyn::api::Vec3* mutable_origin();
  void set_allocated_origin(::bosdyn::api::Vec3* origin);
  private:
  const ::bosdyn::api::Vec3& _internal_origin() const;
  ::bosdyn::api::Vec3* _internal_mutable_origin();
  public:
  void unsafe_arena_set_allocated_origin(
      ::bosdyn::api::Vec3* origin);
  ::bosdyn::api::Vec3* unsafe_arena_release_origin();

  // .bosdyn.api.Vec3 direction = 2;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  const ::bosdyn::api::Vec3& direction() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_direction();
  ::bosdyn::api::Vec3* mutable_direction();
  void set_allocated_direction(::bosdyn::api::Vec3* direction);
  private:
  const ::bosdyn::api::Vec3& _internal_direction() const;
  ::bosdyn::api::Vec3* _internal_mutable_direction();
  public:
  void unsafe_arena_set_allocated_direction(
      ::bosdyn::api::Vec3* direction);
  ::bosdyn::api::Vec3* unsafe_arena_release_direction();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Ray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec3* origin_;
    ::bosdyn::api::Vec3* direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class SE2Pose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SE2Pose) */ {
 public:
  inline SE2Pose() : SE2Pose(nullptr) {}
  ~SE2Pose() override;
  explicit PROTOBUF_CONSTEXPR SE2Pose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE2Pose(const SE2Pose& from);
  SE2Pose(SE2Pose&& from) noexcept
    : SE2Pose() {
    *this = ::std::move(from);
  }

  inline SE2Pose& operator=(const SE2Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE2Pose& operator=(SE2Pose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE2Pose& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE2Pose* internal_default_instance() {
    return reinterpret_cast<const SE2Pose*>(
               &_SE2Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SE2Pose& a, SE2Pose& b) {
    a.Swap(&b);
  }
  inline void Swap(SE2Pose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE2Pose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SE2Pose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SE2Pose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SE2Pose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SE2Pose& from) {
    SE2Pose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE2Pose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE2Pose";
  }
  protected:
  explicit SE2Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kAngleFieldNumber = 2,
  };
  // .bosdyn.api.Vec2 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::bosdyn::api::Vec2& position() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec2* release_position();
  ::bosdyn::api::Vec2* mutable_position();
  void set_allocated_position(::bosdyn::api::Vec2* position);
  private:
  const ::bosdyn::api::Vec2& _internal_position() const;
  ::bosdyn::api::Vec2* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::bosdyn::api::Vec2* position);
  ::bosdyn::api::Vec2* unsafe_arena_release_position();

  // double angle = 2;
  void clear_angle();
  double angle() const;
  void set_angle(double value);
  private:
  double _internal_angle() const;
  void _internal_set_angle(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE2Pose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec2* position_;
    double angle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class SE2Velocity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SE2Velocity) */ {
 public:
  inline SE2Velocity() : SE2Velocity(nullptr) {}
  ~SE2Velocity() override;
  explicit PROTOBUF_CONSTEXPR SE2Velocity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE2Velocity(const SE2Velocity& from);
  SE2Velocity(SE2Velocity&& from) noexcept
    : SE2Velocity() {
    *this = ::std::move(from);
  }

  inline SE2Velocity& operator=(const SE2Velocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE2Velocity& operator=(SE2Velocity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE2Velocity& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE2Velocity* internal_default_instance() {
    return reinterpret_cast<const SE2Velocity*>(
               &_SE2Velocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SE2Velocity& a, SE2Velocity& b) {
    a.Swap(&b);
  }
  inline void Swap(SE2Velocity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE2Velocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SE2Velocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SE2Velocity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SE2Velocity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SE2Velocity& from) {
    SE2Velocity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE2Velocity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE2Velocity";
  }
  protected:
  explicit SE2Velocity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearFieldNumber = 1,
    kAngularFieldNumber = 2,
  };
  // .bosdyn.api.Vec2 linear = 1;
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;
  public:
  void clear_linear();
  const ::bosdyn::api::Vec2& linear() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec2* release_linear();
  ::bosdyn::api::Vec2* mutable_linear();
  void set_allocated_linear(::bosdyn::api::Vec2* linear);
  private:
  const ::bosdyn::api::Vec2& _internal_linear() const;
  ::bosdyn::api::Vec2* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::bosdyn::api::Vec2* linear);
  ::bosdyn::api::Vec2* unsafe_arena_release_linear();

  // double angular = 2;
  void clear_angular();
  double angular() const;
  void set_angular(double value);
  private:
  double _internal_angular() const;
  void _internal_set_angular(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE2Velocity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec2* linear_;
    double angular_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class SE2VelocityLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SE2VelocityLimit) */ {
 public:
  inline SE2VelocityLimit() : SE2VelocityLimit(nullptr) {}
  ~SE2VelocityLimit() override;
  explicit PROTOBUF_CONSTEXPR SE2VelocityLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE2VelocityLimit(const SE2VelocityLimit& from);
  SE2VelocityLimit(SE2VelocityLimit&& from) noexcept
    : SE2VelocityLimit() {
    *this = ::std::move(from);
  }

  inline SE2VelocityLimit& operator=(const SE2VelocityLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE2VelocityLimit& operator=(SE2VelocityLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE2VelocityLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE2VelocityLimit* internal_default_instance() {
    return reinterpret_cast<const SE2VelocityLimit*>(
               &_SE2VelocityLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SE2VelocityLimit& a, SE2VelocityLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(SE2VelocityLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE2VelocityLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SE2VelocityLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SE2VelocityLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SE2VelocityLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SE2VelocityLimit& from) {
    SE2VelocityLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE2VelocityLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE2VelocityLimit";
  }
  protected:
  explicit SE2VelocityLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxVelFieldNumber = 1,
    kMinVelFieldNumber = 2,
  };
  // .bosdyn.api.SE2Velocity max_vel = 1;
  bool has_max_vel() const;
  private:
  bool _internal_has_max_vel() const;
  public:
  void clear_max_vel();
  const ::bosdyn::api::SE2Velocity& max_vel() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE2Velocity* release_max_vel();
  ::bosdyn::api::SE2Velocity* mutable_max_vel();
  void set_allocated_max_vel(::bosdyn::api::SE2Velocity* max_vel);
  private:
  const ::bosdyn::api::SE2Velocity& _internal_max_vel() const;
  ::bosdyn::api::SE2Velocity* _internal_mutable_max_vel();
  public:
  void unsafe_arena_set_allocated_max_vel(
      ::bosdyn::api::SE2Velocity* max_vel);
  ::bosdyn::api::SE2Velocity* unsafe_arena_release_max_vel();

  // .bosdyn.api.SE2Velocity min_vel = 2;
  bool has_min_vel() const;
  private:
  bool _internal_has_min_vel() const;
  public:
  void clear_min_vel();
  const ::bosdyn::api::SE2Velocity& min_vel() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE2Velocity* release_min_vel();
  ::bosdyn::api::SE2Velocity* mutable_min_vel();
  void set_allocated_min_vel(::bosdyn::api::SE2Velocity* min_vel);
  private:
  const ::bosdyn::api::SE2Velocity& _internal_min_vel() const;
  ::bosdyn::api::SE2Velocity* _internal_mutable_min_vel();
  public:
  void unsafe_arena_set_allocated_min_vel(
      ::bosdyn::api::SE2Velocity* min_vel);
  ::bosdyn::api::SE2Velocity* unsafe_arena_release_min_vel();

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE2VelocityLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::SE2Velocity* max_vel_;
    ::bosdyn::api::SE2Velocity* min_vel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class SE3Pose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SE3Pose) */ {
 public:
  inline SE3Pose() : SE3Pose(nullptr) {}
  ~SE3Pose() override;
  explicit PROTOBUF_CONSTEXPR SE3Pose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE3Pose(const SE3Pose& from);
  SE3Pose(SE3Pose&& from) noexcept
    : SE3Pose() {
    *this = ::std::move(from);
  }

  inline SE3Pose& operator=(const SE3Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE3Pose& operator=(SE3Pose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE3Pose& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE3Pose* internal_default_instance() {
    return reinterpret_cast<const SE3Pose*>(
               &_SE3Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SE3Pose& a, SE3Pose& b) {
    a.Swap(&b);
  }
  inline void Swap(SE3Pose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE3Pose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SE3Pose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SE3Pose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SE3Pose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SE3Pose& from) {
    SE3Pose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE3Pose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE3Pose";
  }
  protected:
  explicit SE3Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kRotationFieldNumber = 2,
  };
  // .bosdyn.api.Vec3 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::bosdyn::api::Vec3& position() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_position();
  ::bosdyn::api::Vec3* mutable_position();
  void set_allocated_position(::bosdyn::api::Vec3* position);
  private:
  const ::bosdyn::api::Vec3& _internal_position() const;
  ::bosdyn::api::Vec3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::bosdyn::api::Vec3* position);
  ::bosdyn::api::Vec3* unsafe_arena_release_position();

  // .bosdyn.api.Quaternion rotation = 2;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::bosdyn::api::Quaternion& rotation() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Quaternion* release_rotation();
  ::bosdyn::api::Quaternion* mutable_rotation();
  void set_allocated_rotation(::bosdyn::api::Quaternion* rotation);
  private:
  const ::bosdyn::api::Quaternion& _internal_rotation() const;
  ::bosdyn::api::Quaternion* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::bosdyn::api::Quaternion* rotation);
  ::bosdyn::api::Quaternion* unsafe_arena_release_rotation();

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE3Pose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec3* position_;
    ::bosdyn::api::Quaternion* rotation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class SE3Velocity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SE3Velocity) */ {
 public:
  inline SE3Velocity() : SE3Velocity(nullptr) {}
  ~SE3Velocity() override;
  explicit PROTOBUF_CONSTEXPR SE3Velocity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE3Velocity(const SE3Velocity& from);
  SE3Velocity(SE3Velocity&& from) noexcept
    : SE3Velocity() {
    *this = ::std::move(from);
  }

  inline SE3Velocity& operator=(const SE3Velocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE3Velocity& operator=(SE3Velocity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE3Velocity& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE3Velocity* internal_default_instance() {
    return reinterpret_cast<const SE3Velocity*>(
               &_SE3Velocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SE3Velocity& a, SE3Velocity& b) {
    a.Swap(&b);
  }
  inline void Swap(SE3Velocity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE3Velocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SE3Velocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SE3Velocity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SE3Velocity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SE3Velocity& from) {
    SE3Velocity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE3Velocity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE3Velocity";
  }
  protected:
  explicit SE3Velocity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearFieldNumber = 1,
    kAngularFieldNumber = 2,
  };
  // .bosdyn.api.Vec3 linear = 1;
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;
  public:
  void clear_linear();
  const ::bosdyn::api::Vec3& linear() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_linear();
  ::bosdyn::api::Vec3* mutable_linear();
  void set_allocated_linear(::bosdyn::api::Vec3* linear);
  private:
  const ::bosdyn::api::Vec3& _internal_linear() const;
  ::bosdyn::api::Vec3* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::bosdyn::api::Vec3* linear);
  ::bosdyn::api::Vec3* unsafe_arena_release_linear();

  // .bosdyn.api.Vec3 angular = 2;
  bool has_angular() const;
  private:
  bool _internal_has_angular() const;
  public:
  void clear_angular();
  const ::bosdyn::api::Vec3& angular() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_angular();
  ::bosdyn::api::Vec3* mutable_angular();
  void set_allocated_angular(::bosdyn::api::Vec3* angular);
  private:
  const ::bosdyn::api::Vec3& _internal_angular() const;
  ::bosdyn::api::Vec3* _internal_mutable_angular();
  public:
  void unsafe_arena_set_allocated_angular(
      ::bosdyn::api::Vec3* angular);
  ::bosdyn::api::Vec3* unsafe_arena_release_angular();

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE3Velocity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec3* linear_;
    ::bosdyn::api::Vec3* angular_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Wrench final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Wrench) */ {
 public:
  inline Wrench() : Wrench(nullptr) {}
  ~Wrench() override;
  explicit PROTOBUF_CONSTEXPR Wrench(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Wrench(const Wrench& from);
  Wrench(Wrench&& from) noexcept
    : Wrench() {
    *this = ::std::move(from);
  }

  inline Wrench& operator=(const Wrench& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wrench& operator=(Wrench&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Wrench& default_instance() {
    return *internal_default_instance();
  }
  static inline const Wrench* internal_default_instance() {
    return reinterpret_cast<const Wrench*>(
               &_Wrench_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Wrench& a, Wrench& b) {
    a.Swap(&b);
  }
  inline void Swap(Wrench* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wrench* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Wrench* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Wrench>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Wrench& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Wrench& from) {
    Wrench::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wrench* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Wrench";
  }
  protected:
  explicit Wrench(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForceFieldNumber = 1,
    kTorqueFieldNumber = 2,
  };
  // .bosdyn.api.Vec3 force = 1;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  const ::bosdyn::api::Vec3& force() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_force();
  ::bosdyn::api::Vec3* mutable_force();
  void set_allocated_force(::bosdyn::api::Vec3* force);
  private:
  const ::bosdyn::api::Vec3& _internal_force() const;
  ::bosdyn::api::Vec3* _internal_mutable_force();
  public:
  void unsafe_arena_set_allocated_force(
      ::bosdyn::api::Vec3* force);
  ::bosdyn::api::Vec3* unsafe_arena_release_force();

  // .bosdyn.api.Vec3 torque = 2;
  bool has_torque() const;
  private:
  bool _internal_has_torque() const;
  public:
  void clear_torque();
  const ::bosdyn::api::Vec3& torque() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_torque();
  ::bosdyn::api::Vec3* mutable_torque();
  void set_allocated_torque(::bosdyn::api::Vec3* torque);
  private:
  const ::bosdyn::api::Vec3& _internal_torque() const;
  ::bosdyn::api::Vec3* _internal_mutable_torque();
  public:
  void unsafe_arena_set_allocated_torque(
      ::bosdyn::api::Vec3* torque);
  ::bosdyn::api::Vec3* unsafe_arena_release_torque();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Wrench)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec3* force_;
    ::bosdyn::api::Vec3* torque_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class FrameTreeSnapshot_ParentEdge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.FrameTreeSnapshot.ParentEdge) */ {
 public:
  inline FrameTreeSnapshot_ParentEdge() : FrameTreeSnapshot_ParentEdge(nullptr) {}
  ~FrameTreeSnapshot_ParentEdge() override;
  explicit PROTOBUF_CONSTEXPR FrameTreeSnapshot_ParentEdge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameTreeSnapshot_ParentEdge(const FrameTreeSnapshot_ParentEdge& from);
  FrameTreeSnapshot_ParentEdge(FrameTreeSnapshot_ParentEdge&& from) noexcept
    : FrameTreeSnapshot_ParentEdge() {
    *this = ::std::move(from);
  }

  inline FrameTreeSnapshot_ParentEdge& operator=(const FrameTreeSnapshot_ParentEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameTreeSnapshot_ParentEdge& operator=(FrameTreeSnapshot_ParentEdge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameTreeSnapshot_ParentEdge& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameTreeSnapshot_ParentEdge* internal_default_instance() {
    return reinterpret_cast<const FrameTreeSnapshot_ParentEdge*>(
               &_FrameTreeSnapshot_ParentEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(FrameTreeSnapshot_ParentEdge& a, FrameTreeSnapshot_ParentEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameTreeSnapshot_ParentEdge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameTreeSnapshot_ParentEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameTreeSnapshot_ParentEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameTreeSnapshot_ParentEdge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameTreeSnapshot_ParentEdge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrameTreeSnapshot_ParentEdge& from) {
    FrameTreeSnapshot_ParentEdge::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameTreeSnapshot_ParentEdge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FrameTreeSnapshot.ParentEdge";
  }
  protected:
  explicit FrameTreeSnapshot_ParentEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFrameNameFieldNumber = 1,
    kParentTformChildFieldNumber = 2,
  };
  // string parent_frame_name = 1;
  void clear_parent_frame_name();
  const std::string& parent_frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_frame_name();
  PROTOBUF_NODISCARD std::string* release_parent_frame_name();
  void set_allocated_parent_frame_name(std::string* parent_frame_name);
  private:
  const std::string& _internal_parent_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_frame_name(const std::string& value);
  std::string* _internal_mutable_parent_frame_name();
  public:

  // .bosdyn.api.SE3Pose parent_tform_child = 2;
  bool has_parent_tform_child() const;
  private:
  bool _internal_has_parent_tform_child() const;
  public:
  void clear_parent_tform_child();
  const ::bosdyn::api::SE3Pose& parent_tform_child() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Pose* release_parent_tform_child();
  ::bosdyn::api::SE3Pose* mutable_parent_tform_child();
  void set_allocated_parent_tform_child(::bosdyn::api::SE3Pose* parent_tform_child);
  private:
  const ::bosdyn::api::SE3Pose& _internal_parent_tform_child() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_parent_tform_child();
  public:
  void unsafe_arena_set_allocated_parent_tform_child(
      ::bosdyn::api::SE3Pose* parent_tform_child);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_parent_tform_child();

  // @@protoc_insertion_point(class_scope:bosdyn.api.FrameTreeSnapshot.ParentEdge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_frame_name_;
    ::bosdyn::api::SE3Pose* parent_tform_child_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse, 
    std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse, 
    std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse& other);
  static const FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse*>(&_FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.FrameTreeSnapshot.ChildToParentEdgeMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};

// -------------------------------------------------------------------

class FrameTreeSnapshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.FrameTreeSnapshot) */ {
 public:
  inline FrameTreeSnapshot() : FrameTreeSnapshot(nullptr) {}
  ~FrameTreeSnapshot() override;
  explicit PROTOBUF_CONSTEXPR FrameTreeSnapshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameTreeSnapshot(const FrameTreeSnapshot& from);
  FrameTreeSnapshot(FrameTreeSnapshot&& from) noexcept
    : FrameTreeSnapshot() {
    *this = ::std::move(from);
  }

  inline FrameTreeSnapshot& operator=(const FrameTreeSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameTreeSnapshot& operator=(FrameTreeSnapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameTreeSnapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameTreeSnapshot* internal_default_instance() {
    return reinterpret_cast<const FrameTreeSnapshot*>(
               &_FrameTreeSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(FrameTreeSnapshot& a, FrameTreeSnapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameTreeSnapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameTreeSnapshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameTreeSnapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameTreeSnapshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameTreeSnapshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrameTreeSnapshot& from) {
    FrameTreeSnapshot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameTreeSnapshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FrameTreeSnapshot";
  }
  protected:
  explicit FrameTreeSnapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FrameTreeSnapshot_ParentEdge ParentEdge;

  // accessors -------------------------------------------------------

  enum : int {
    kChildToParentEdgeMapFieldNumber = 1,
  };
  // map<string, .bosdyn.api.FrameTreeSnapshot.ParentEdge> child_to_parent_edge_map = 1;
  int child_to_parent_edge_map_size() const;
  private:
  int _internal_child_to_parent_edge_map_size() const;
  public:
  void clear_child_to_parent_edge_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge >&
      _internal_child_to_parent_edge_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge >*
      _internal_mutable_child_to_parent_edge_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge >&
      child_to_parent_edge_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge >*
      mutable_child_to_parent_edge_map();

  // @@protoc_insertion_point(class_scope:bosdyn.api.FrameTreeSnapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse,
        std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> child_to_parent_edge_map_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Box2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Box2) */ {
 public:
  inline Box2() : Box2(nullptr) {}
  ~Box2() override;
  explicit PROTOBUF_CONSTEXPR Box2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Box2(const Box2& from);
  Box2(Box2&& from) noexcept
    : Box2() {
    *this = ::std::move(from);
  }

  inline Box2& operator=(const Box2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Box2& operator=(Box2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Box2& default_instance() {
    return *internal_default_instance();
  }
  static inline const Box2* internal_default_instance() {
    return reinterpret_cast<const Box2*>(
               &_Box2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Box2& a, Box2& b) {
    a.Swap(&b);
  }
  inline void Swap(Box2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Box2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Box2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Box2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Box2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Box2& from) {
    Box2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Box2";
  }
  protected:
  explicit Box2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // .bosdyn.api.Vec2 size = 1;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::bosdyn::api::Vec2& size() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec2* release_size();
  ::bosdyn::api::Vec2* mutable_size();
  void set_allocated_size(::bosdyn::api::Vec2* size);
  private:
  const ::bosdyn::api::Vec2& _internal_size() const;
  ::bosdyn::api::Vec2* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::bosdyn::api::Vec2* size);
  ::bosdyn::api::Vec2* unsafe_arena_release_size();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Box2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec2* size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Box2WithFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Box2WithFrame) */ {
 public:
  inline Box2WithFrame() : Box2WithFrame(nullptr) {}
  ~Box2WithFrame() override;
  explicit PROTOBUF_CONSTEXPR Box2WithFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Box2WithFrame(const Box2WithFrame& from);
  Box2WithFrame(Box2WithFrame&& from) noexcept
    : Box2WithFrame() {
    *this = ::std::move(from);
  }

  inline Box2WithFrame& operator=(const Box2WithFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Box2WithFrame& operator=(Box2WithFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Box2WithFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const Box2WithFrame* internal_default_instance() {
    return reinterpret_cast<const Box2WithFrame*>(
               &_Box2WithFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Box2WithFrame& a, Box2WithFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(Box2WithFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Box2WithFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Box2WithFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Box2WithFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Box2WithFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Box2WithFrame& from) {
    Box2WithFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box2WithFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Box2WithFrame";
  }
  protected:
  explicit Box2WithFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFieldNumber = 2,
    kBoxFieldNumber = 1,
    kFrameNameTformBoxFieldNumber = 3,
  };
  // string frame_name = 2;
  void clear_frame_name();
  const std::string& frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name();
  PROTOBUF_NODISCARD std::string* release_frame_name();
  void set_allocated_frame_name(std::string* frame_name);
  private:
  const std::string& _internal_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name(const std::string& value);
  std::string* _internal_mutable_frame_name();
  public:

  // .bosdyn.api.Box2 box = 1;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::bosdyn::api::Box2& box() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Box2* release_box();
  ::bosdyn::api::Box2* mutable_box();
  void set_allocated_box(::bosdyn::api::Box2* box);
  private:
  const ::bosdyn::api::Box2& _internal_box() const;
  ::bosdyn::api::Box2* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::bosdyn::api::Box2* box);
  ::bosdyn::api::Box2* unsafe_arena_release_box();

  // .bosdyn.api.SE3Pose frame_name_tform_box = 3;
  bool has_frame_name_tform_box() const;
  private:
  bool _internal_has_frame_name_tform_box() const;
  public:
  void clear_frame_name_tform_box();
  const ::bosdyn::api::SE3Pose& frame_name_tform_box() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Pose* release_frame_name_tform_box();
  ::bosdyn::api::SE3Pose* mutable_frame_name_tform_box();
  void set_allocated_frame_name_tform_box(::bosdyn::api::SE3Pose* frame_name_tform_box);
  private:
  const ::bosdyn::api::SE3Pose& _internal_frame_name_tform_box() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_frame_name_tform_box();
  public:
  void unsafe_arena_set_allocated_frame_name_tform_box(
      ::bosdyn::api::SE3Pose* frame_name_tform_box);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_frame_name_tform_box();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Box2WithFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_;
    ::bosdyn::api::Box2* box_;
    ::bosdyn::api::SE3Pose* frame_name_tform_box_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Box3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Box3) */ {
 public:
  inline Box3() : Box3(nullptr) {}
  ~Box3() override;
  explicit PROTOBUF_CONSTEXPR Box3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Box3(const Box3& from);
  Box3(Box3&& from) noexcept
    : Box3() {
    *this = ::std::move(from);
  }

  inline Box3& operator=(const Box3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Box3& operator=(Box3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Box3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Box3* internal_default_instance() {
    return reinterpret_cast<const Box3*>(
               &_Box3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Box3& a, Box3& b) {
    a.Swap(&b);
  }
  inline void Swap(Box3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Box3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Box3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Box3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Box3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Box3& from) {
    Box3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Box3";
  }
  protected:
  explicit Box3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // .bosdyn.api.Vec3 size = 1;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::bosdyn::api::Vec3& size() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_size();
  ::bosdyn::api::Vec3* mutable_size();
  void set_allocated_size(::bosdyn::api::Vec3* size);
  private:
  const ::bosdyn::api::Vec3& _internal_size() const;
  ::bosdyn::api::Vec3* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::bosdyn::api::Vec3* size);
  ::bosdyn::api::Vec3* unsafe_arena_release_size();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Box3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec3* size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Box3WithFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Box3WithFrame) */ {
 public:
  inline Box3WithFrame() : Box3WithFrame(nullptr) {}
  ~Box3WithFrame() override;
  explicit PROTOBUF_CONSTEXPR Box3WithFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Box3WithFrame(const Box3WithFrame& from);
  Box3WithFrame(Box3WithFrame&& from) noexcept
    : Box3WithFrame() {
    *this = ::std::move(from);
  }

  inline Box3WithFrame& operator=(const Box3WithFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Box3WithFrame& operator=(Box3WithFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Box3WithFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const Box3WithFrame* internal_default_instance() {
    return reinterpret_cast<const Box3WithFrame*>(
               &_Box3WithFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Box3WithFrame& a, Box3WithFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(Box3WithFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Box3WithFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Box3WithFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Box3WithFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Box3WithFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Box3WithFrame& from) {
    Box3WithFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box3WithFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Box3WithFrame";
  }
  protected:
  explicit Box3WithFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFieldNumber = 2,
    kBoxFieldNumber = 1,
    kFrameNameTformBoxFieldNumber = 3,
  };
  // string frame_name = 2;
  void clear_frame_name();
  const std::string& frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name();
  PROTOBUF_NODISCARD std::string* release_frame_name();
  void set_allocated_frame_name(std::string* frame_name);
  private:
  const std::string& _internal_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name(const std::string& value);
  std::string* _internal_mutable_frame_name();
  public:

  // .bosdyn.api.Box3 box = 1;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::bosdyn::api::Box3& box() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Box3* release_box();
  ::bosdyn::api::Box3* mutable_box();
  void set_allocated_box(::bosdyn::api::Box3* box);
  private:
  const ::bosdyn::api::Box3& _internal_box() const;
  ::bosdyn::api::Box3* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::bosdyn::api::Box3* box);
  ::bosdyn::api::Box3* unsafe_arena_release_box();

  // .bosdyn.api.SE3Pose frame_name_tform_box = 3;
  bool has_frame_name_tform_box() const;
  private:
  bool _internal_has_frame_name_tform_box() const;
  public:
  void clear_frame_name_tform_box();
  const ::bosdyn::api::SE3Pose& frame_name_tform_box() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Pose* release_frame_name_tform_box();
  ::bosdyn::api::SE3Pose* mutable_frame_name_tform_box();
  void set_allocated_frame_name_tform_box(::bosdyn::api::SE3Pose* frame_name_tform_box);
  private:
  const ::bosdyn::api::SE3Pose& _internal_frame_name_tform_box() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_frame_name_tform_box();
  public:
  void unsafe_arena_set_allocated_frame_name_tform_box(
      ::bosdyn::api::SE3Pose* frame_name_tform_box);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_frame_name_tform_box();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Box3WithFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_;
    ::bosdyn::api::Box3* box_;
    ::bosdyn::api::SE3Pose* frame_name_tform_box_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Matrix final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Matrix) */ {
 public:
  inline Matrix() : Matrix(nullptr) {}
  ~Matrix() override;
  explicit PROTOBUF_CONSTEXPR Matrix(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Matrix(const Matrix& from);
  Matrix(Matrix&& from) noexcept
    : Matrix() {
    *this = ::std::move(from);
  }

  inline Matrix& operator=(const Matrix& from) {
    CopyFrom(from);
    return *this;
  }
  inline Matrix& operator=(Matrix&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Matrix& default_instance() {
    return *internal_default_instance();
  }
  static inline const Matrix* internal_default_instance() {
    return reinterpret_cast<const Matrix*>(
               &_Matrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Matrix& a, Matrix& b) {
    a.Swap(&b);
  }
  inline void Swap(Matrix* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Matrix* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Matrix* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Matrix>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Matrix& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Matrix& from) {
    Matrix::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Matrix* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Matrix";
  }
  protected:
  explicit Matrix(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 3,
    kRowsFieldNumber = 1,
    kColsFieldNumber = 2,
  };
  // repeated double values = 3;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  double _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_values() const;
  void _internal_add_values(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_values();
  public:
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_values();

  // int32 rows = 1;
  void clear_rows();
  int32_t rows() const;
  void set_rows(int32_t value);
  private:
  int32_t _internal_rows() const;
  void _internal_set_rows(int32_t value);
  public:

  // int32 cols = 2;
  void clear_cols();
  int32_t cols() const;
  void set_cols(int32_t value);
  private:
  int32_t _internal_cols() const;
  void _internal_set_cols(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Matrix)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > values_;
    int32_t rows_;
    int32_t cols_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Matrixf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Matrixf) */ {
 public:
  inline Matrixf() : Matrixf(nullptr) {}
  ~Matrixf() override;
  explicit PROTOBUF_CONSTEXPR Matrixf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Matrixf(const Matrixf& from);
  Matrixf(Matrixf&& from) noexcept
    : Matrixf() {
    *this = ::std::move(from);
  }

  inline Matrixf& operator=(const Matrixf& from) {
    CopyFrom(from);
    return *this;
  }
  inline Matrixf& operator=(Matrixf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Matrixf& default_instance() {
    return *internal_default_instance();
  }
  static inline const Matrixf* internal_default_instance() {
    return reinterpret_cast<const Matrixf*>(
               &_Matrixf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Matrixf& a, Matrixf& b) {
    a.Swap(&b);
  }
  inline void Swap(Matrixf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Matrixf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Matrixf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Matrixf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Matrixf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Matrixf& from) {
    Matrixf::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Matrixf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Matrixf";
  }
  protected:
  explicit Matrixf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 3,
    kRowsFieldNumber = 1,
    kColsFieldNumber = 2,
  };
  // repeated float values = 3;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  float _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_values() const;
  void _internal_add_values(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_values();
  public:
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_values();

  // int32 rows = 1;
  void clear_rows();
  int32_t rows() const;
  void set_rows(int32_t value);
  private:
  int32_t _internal_rows() const;
  void _internal_set_rows(int32_t value);
  public:

  // int32 cols = 2;
  void clear_cols();
  int32_t cols() const;
  void set_cols(int32_t value);
  private:
  int32_t _internal_cols() const;
  void _internal_set_cols(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Matrixf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > values_;
    int32_t rows_;
    int32_t cols_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class MatrixInt64 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.MatrixInt64) */ {
 public:
  inline MatrixInt64() : MatrixInt64(nullptr) {}
  ~MatrixInt64() override;
  explicit PROTOBUF_CONSTEXPR MatrixInt64(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatrixInt64(const MatrixInt64& from);
  MatrixInt64(MatrixInt64&& from) noexcept
    : MatrixInt64() {
    *this = ::std::move(from);
  }

  inline MatrixInt64& operator=(const MatrixInt64& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatrixInt64& operator=(MatrixInt64&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatrixInt64& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatrixInt64* internal_default_instance() {
    return reinterpret_cast<const MatrixInt64*>(
               &_MatrixInt64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(MatrixInt64& a, MatrixInt64& b) {
    a.Swap(&b);
  }
  inline void Swap(MatrixInt64* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatrixInt64* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatrixInt64* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatrixInt64>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatrixInt64& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MatrixInt64& from) {
    MatrixInt64::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatrixInt64* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.MatrixInt64";
  }
  protected:
  explicit MatrixInt64(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 3,
    kRowsFieldNumber = 1,
    kColsFieldNumber = 2,
  };
  // repeated int64 values = 3;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  int64_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_values() const;
  void _internal_add_values(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_values();
  public:
  int64_t values(int index) const;
  void set_values(int index, int64_t value);
  void add_values(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_values();

  // int32 rows = 1;
  void clear_rows();
  int32_t rows() const;
  void set_rows(int32_t value);
  private:
  int32_t _internal_rows() const;
  void _internal_set_rows(int32_t value);
  public:

  // int32 cols = 2;
  void clear_cols();
  int32_t cols() const;
  void set_cols(int32_t value);
  private:
  int32_t _internal_cols() const;
  void _internal_set_cols(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.MatrixInt64)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > values_;
    mutable std::atomic<int> _values_cached_byte_size_;
    int32_t rows_;
    int32_t cols_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class MatrixInt32 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.MatrixInt32) */ {
 public:
  inline MatrixInt32() : MatrixInt32(nullptr) {}
  ~MatrixInt32() override;
  explicit PROTOBUF_CONSTEXPR MatrixInt32(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatrixInt32(const MatrixInt32& from);
  MatrixInt32(MatrixInt32&& from) noexcept
    : MatrixInt32() {
    *this = ::std::move(from);
  }

  inline MatrixInt32& operator=(const MatrixInt32& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatrixInt32& operator=(MatrixInt32&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatrixInt32& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatrixInt32* internal_default_instance() {
    return reinterpret_cast<const MatrixInt32*>(
               &_MatrixInt32_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(MatrixInt32& a, MatrixInt32& b) {
    a.Swap(&b);
  }
  inline void Swap(MatrixInt32* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatrixInt32* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatrixInt32* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatrixInt32>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatrixInt32& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MatrixInt32& from) {
    MatrixInt32::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatrixInt32* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.MatrixInt32";
  }
  protected:
  explicit MatrixInt32(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 3,
    kRowsFieldNumber = 1,
    kColsFieldNumber = 2,
  };
  // repeated int32 values = 3;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  int32_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_values() const;
  void _internal_add_values(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_values();
  public:
  int32_t values(int index) const;
  void set_values(int index, int32_t value);
  void add_values(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_values();

  // int32 rows = 1;
  void clear_rows();
  int32_t rows() const;
  void set_rows(int32_t value);
  private:
  int32_t _internal_rows() const;
  void _internal_set_rows(int32_t value);
  public:

  // int32 cols = 2;
  void clear_cols();
  int32_t cols() const;
  void set_cols(int32_t value);
  private:
  int32_t _internal_cols() const;
  void _internal_set_cols(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.MatrixInt32)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > values_;
    mutable std::atomic<int> _values_cached_byte_size_;
    int32_t rows_;
    int32_t cols_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Vector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Vector) */ {
 public:
  inline Vector() : Vector(nullptr) {}
  ~Vector() override;
  explicit PROTOBUF_CONSTEXPR Vector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector(const Vector& from);
  Vector(Vector&& from) noexcept
    : Vector() {
    *this = ::std::move(from);
  }

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector& operator=(Vector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
               &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Vector& a, Vector& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vector& from) {
    Vector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Vector";
  }
  protected:
  explicit Vector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated double values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  double _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_values() const;
  void _internal_add_values(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_values();
  public:
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Vector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class SE3Covariance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SE3Covariance) */ {
 public:
  inline SE3Covariance() : SE3Covariance(nullptr) {}
  ~SE3Covariance() override;
  explicit PROTOBUF_CONSTEXPR SE3Covariance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE3Covariance(const SE3Covariance& from);
  SE3Covariance(SE3Covariance&& from) noexcept
    : SE3Covariance() {
    *this = ::std::move(from);
  }

  inline SE3Covariance& operator=(const SE3Covariance& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE3Covariance& operator=(SE3Covariance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE3Covariance& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE3Covariance* internal_default_instance() {
    return reinterpret_cast<const SE3Covariance*>(
               &_SE3Covariance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SE3Covariance& a, SE3Covariance& b) {
    a.Swap(&b);
  }
  inline void Swap(SE3Covariance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE3Covariance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SE3Covariance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SE3Covariance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SE3Covariance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SE3Covariance& from) {
    SE3Covariance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE3Covariance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE3Covariance";
  }
  protected:
  explicit SE3Covariance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatrixFieldNumber = 1,
    kYawVarianceFieldNumber = 2,
    kCovXxFieldNumber = 3,
    kCovXyFieldNumber = 4,
    kCovXzFieldNumber = 5,
    kCovYxFieldNumber = 6,
    kCovYyFieldNumber = 7,
    kCovYzFieldNumber = 8,
    kCovZxFieldNumber = 9,
    kCovZyFieldNumber = 10,
    kCovZzFieldNumber = 11,
  };
  // .bosdyn.api.Matrix matrix = 1;
  bool has_matrix() const;
  private:
  bool _internal_has_matrix() const;
  public:
  void clear_matrix();
  const ::bosdyn::api::Matrix& matrix() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Matrix* release_matrix();
  ::bosdyn::api::Matrix* mutable_matrix();
  void set_allocated_matrix(::bosdyn::api::Matrix* matrix);
  private:
  const ::bosdyn::api::Matrix& _internal_matrix() const;
  ::bosdyn::api::Matrix* _internal_mutable_matrix();
  public:
  void unsafe_arena_set_allocated_matrix(
      ::bosdyn::api::Matrix* matrix);
  ::bosdyn::api::Matrix* unsafe_arena_release_matrix();

  // double yaw_variance = 2 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_yaw_variance();
  PROTOBUF_DEPRECATED double yaw_variance() const;
  PROTOBUF_DEPRECATED void set_yaw_variance(double value);
  private:
  double _internal_yaw_variance() const;
  void _internal_set_yaw_variance(double value);
  public:

  // double cov_xx = 3 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_xx();
  PROTOBUF_DEPRECATED double cov_xx() const;
  PROTOBUF_DEPRECATED void set_cov_xx(double value);
  private:
  double _internal_cov_xx() const;
  void _internal_set_cov_xx(double value);
  public:

  // double cov_xy = 4 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_xy();
  PROTOBUF_DEPRECATED double cov_xy() const;
  PROTOBUF_DEPRECATED void set_cov_xy(double value);
  private:
  double _internal_cov_xy() const;
  void _internal_set_cov_xy(double value);
  public:

  // double cov_xz = 5 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_xz();
  PROTOBUF_DEPRECATED double cov_xz() const;
  PROTOBUF_DEPRECATED void set_cov_xz(double value);
  private:
  double _internal_cov_xz() const;
  void _internal_set_cov_xz(double value);
  public:

  // double cov_yx = 6 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_yx();
  PROTOBUF_DEPRECATED double cov_yx() const;
  PROTOBUF_DEPRECATED void set_cov_yx(double value);
  private:
  double _internal_cov_yx() const;
  void _internal_set_cov_yx(double value);
  public:

  // double cov_yy = 7 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_yy();
  PROTOBUF_DEPRECATED double cov_yy() const;
  PROTOBUF_DEPRECATED void set_cov_yy(double value);
  private:
  double _internal_cov_yy() const;
  void _internal_set_cov_yy(double value);
  public:

  // double cov_yz = 8 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_yz();
  PROTOBUF_DEPRECATED double cov_yz() const;
  PROTOBUF_DEPRECATED void set_cov_yz(double value);
  private:
  double _internal_cov_yz() const;
  void _internal_set_cov_yz(double value);
  public:

  // double cov_zx = 9 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_zx();
  PROTOBUF_DEPRECATED double cov_zx() const;
  PROTOBUF_DEPRECATED void set_cov_zx(double value);
  private:
  double _internal_cov_zx() const;
  void _internal_set_cov_zx(double value);
  public:

  // double cov_zy = 10 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_zy();
  PROTOBUF_DEPRECATED double cov_zy() const;
  PROTOBUF_DEPRECATED void set_cov_zy(double value);
  private:
  double _internal_cov_zy() const;
  void _internal_set_cov_zy(double value);
  public:

  // double cov_zz = 11 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_zz();
  PROTOBUF_DEPRECATED double cov_zz() const;
  PROTOBUF_DEPRECATED void set_cov_zz(double value);
  private:
  double _internal_cov_zz() const;
  void _internal_set_cov_zz(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE3Covariance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Matrix* matrix_;
    double yaw_variance_;
    double cov_xx_;
    double cov_xy_;
    double cov_xz_;
    double cov_yx_;
    double cov_yy_;
    double cov_yz_;
    double cov_zx_;
    double cov_zy_;
    double cov_zz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class PolyLine final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PolyLine) */ {
 public:
  inline PolyLine() : PolyLine(nullptr) {}
  ~PolyLine() override;
  explicit PROTOBUF_CONSTEXPR PolyLine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolyLine(const PolyLine& from);
  PolyLine(PolyLine&& from) noexcept
    : PolyLine() {
    *this = ::std::move(from);
  }

  inline PolyLine& operator=(const PolyLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolyLine& operator=(PolyLine&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolyLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolyLine* internal_default_instance() {
    return reinterpret_cast<const PolyLine*>(
               &_PolyLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(PolyLine& a, PolyLine& b) {
    a.Swap(&b);
  }
  inline void Swap(PolyLine* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolyLine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolyLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolyLine>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PolyLine& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PolyLine& from) {
    PolyLine::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolyLine* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PolyLine";
  }
  protected:
  explicit PolyLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
  };
  // repeated .bosdyn.api.Vec2 points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::bosdyn::api::Vec2* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 >*
      mutable_points();
  private:
  const ::bosdyn::api::Vec2& _internal_points(int index) const;
  ::bosdyn::api::Vec2* _internal_add_points();
  public:
  const ::bosdyn::api::Vec2& points(int index) const;
  ::bosdyn::api::Vec2* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 >&
      points() const;

  // @@protoc_insertion_point(class_scope:bosdyn.api.PolyLine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 > points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Polygon final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Polygon) */ {
 public:
  inline Polygon() : Polygon(nullptr) {}
  ~Polygon() override;
  explicit PROTOBUF_CONSTEXPR Polygon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Polygon(const Polygon& from);
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline Polygon& operator=(Polygon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Polygon& default_instance() {
    return *internal_default_instance();
  }
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }
  inline void Swap(Polygon* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Polygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Polygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Polygon>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Polygon& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Polygon& from) {
    Polygon::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polygon* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Polygon";
  }
  protected:
  explicit Polygon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVertexesFieldNumber = 1,
  };
  // repeated .bosdyn.api.Vec2 vertexes = 1;
  int vertexes_size() const;
  private:
  int _internal_vertexes_size() const;
  public:
  void clear_vertexes();
  ::bosdyn::api::Vec2* mutable_vertexes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 >*
      mutable_vertexes();
  private:
  const ::bosdyn::api::Vec2& _internal_vertexes(int index) const;
  ::bosdyn::api::Vec2* _internal_add_vertexes();
  public:
  const ::bosdyn::api::Vec2& vertexes(int index) const;
  ::bosdyn::api::Vec2* add_vertexes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 >&
      vertexes() const;

  // @@protoc_insertion_point(class_scope:bosdyn.api.Polygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 > vertexes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class PolygonWithExclusions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PolygonWithExclusions) */ {
 public:
  inline PolygonWithExclusions() : PolygonWithExclusions(nullptr) {}
  ~PolygonWithExclusions() override;
  explicit PROTOBUF_CONSTEXPR PolygonWithExclusions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolygonWithExclusions(const PolygonWithExclusions& from);
  PolygonWithExclusions(PolygonWithExclusions&& from) noexcept
    : PolygonWithExclusions() {
    *this = ::std::move(from);
  }

  inline PolygonWithExclusions& operator=(const PolygonWithExclusions& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolygonWithExclusions& operator=(PolygonWithExclusions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolygonWithExclusions& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolygonWithExclusions* internal_default_instance() {
    return reinterpret_cast<const PolygonWithExclusions*>(
               &_PolygonWithExclusions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(PolygonWithExclusions& a, PolygonWithExclusions& b) {
    a.Swap(&b);
  }
  inline void Swap(PolygonWithExclusions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolygonWithExclusions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolygonWithExclusions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolygonWithExclusions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PolygonWithExclusions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PolygonWithExclusions& from) {
    PolygonWithExclusions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolygonWithExclusions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PolygonWithExclusions";
  }
  protected:
  explicit PolygonWithExclusions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExclusionsFieldNumber = 6,
    kInclusionFieldNumber = 5,
  };
  // repeated .bosdyn.api.Polygon exclusions = 6;
  int exclusions_size() const;
  private:
  int _internal_exclusions_size() const;
  public:
  void clear_exclusions();
  ::bosdyn::api::Polygon* mutable_exclusions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Polygon >*
      mutable_exclusions();
  private:
  const ::bosdyn::api::Polygon& _internal_exclusions(int index) const;
  ::bosdyn::api::Polygon* _internal_add_exclusions();
  public:
  const ::bosdyn::api::Polygon& exclusions(int index) const;
  ::bosdyn::api::Polygon* add_exclusions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Polygon >&
      exclusions() const;

  // .bosdyn.api.Polygon inclusion = 5;
  bool has_inclusion() const;
  private:
  bool _internal_has_inclusion() const;
  public:
  void clear_inclusion();
  const ::bosdyn::api::Polygon& inclusion() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Polygon* release_inclusion();
  ::bosdyn::api::Polygon* mutable_inclusion();
  void set_allocated_inclusion(::bosdyn::api::Polygon* inclusion);
  private:
  const ::bosdyn::api::Polygon& _internal_inclusion() const;
  ::bosdyn::api::Polygon* _internal_mutable_inclusion();
  public:
  void unsafe_arena_set_allocated_inclusion(
      ::bosdyn::api::Polygon* inclusion);
  ::bosdyn::api::Polygon* unsafe_arena_release_inclusion();

  // @@protoc_insertion_point(class_scope:bosdyn.api.PolygonWithExclusions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Polygon > exclusions_;
    ::bosdyn::api::Polygon* inclusion_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Circle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Circle) */ {
 public:
  inline Circle() : Circle(nullptr) {}
  ~Circle() override;
  explicit PROTOBUF_CONSTEXPR Circle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Circle(const Circle& from);
  Circle(Circle&& from) noexcept
    : Circle() {
    *this = ::std::move(from);
  }

  inline Circle& operator=(const Circle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Circle& operator=(Circle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Circle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Circle* internal_default_instance() {
    return reinterpret_cast<const Circle*>(
               &_Circle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Circle& a, Circle& b) {
    a.Swap(&b);
  }
  inline void Swap(Circle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Circle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Circle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Circle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Circle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Circle& from) {
    Circle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Circle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Circle";
  }
  protected:
  explicit Circle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterPtFieldNumber = 1,
    kRadiusFieldNumber = 2,
  };
  // .bosdyn.api.Vec2 center_pt = 1;
  bool has_center_pt() const;
  private:
  bool _internal_has_center_pt() const;
  public:
  void clear_center_pt();
  const ::bosdyn::api::Vec2& center_pt() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec2* release_center_pt();
  ::bosdyn::api::Vec2* mutable_center_pt();
  void set_allocated_center_pt(::bosdyn::api::Vec2* center_pt);
  private:
  const ::bosdyn::api::Vec2& _internal_center_pt() const;
  ::bosdyn::api::Vec2* _internal_mutable_center_pt();
  public:
  void unsafe_arena_set_allocated_center_pt(
      ::bosdyn::api::Vec2* center_pt);
  ::bosdyn::api::Vec2* unsafe_arena_release_center_pt();

  // double radius = 2;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Circle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec2* center_pt_;
    double radius_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Area final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Area) */ {
 public:
  inline Area() : Area(nullptr) {}
  ~Area() override;
  explicit PROTOBUF_CONSTEXPR Area(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Area(const Area& from);
  Area(Area&& from) noexcept
    : Area() {
    *this = ::std::move(from);
  }

  inline Area& operator=(const Area& from) {
    CopyFrom(from);
    return *this;
  }
  inline Area& operator=(Area&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Area& default_instance() {
    return *internal_default_instance();
  }
  enum GeometryCase {
    kPolygon = 1,
    kCircle = 2,
    GEOMETRY_NOT_SET = 0,
  };

  static inline const Area* internal_default_instance() {
    return reinterpret_cast<const Area*>(
               &_Area_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Area& a, Area& b) {
    a.Swap(&b);
  }
  inline void Swap(Area* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Area* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Area* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Area>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Area& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Area& from) {
    Area::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Area* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Area";
  }
  protected:
  explicit Area(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolygonFieldNumber = 1,
    kCircleFieldNumber = 2,
  };
  // .bosdyn.api.Polygon polygon = 1;
  bool has_polygon() const;
  private:
  bool _internal_has_polygon() const;
  public:
  void clear_polygon();
  const ::bosdyn::api::Polygon& polygon() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Polygon* release_polygon();
  ::bosdyn::api::Polygon* mutable_polygon();
  void set_allocated_polygon(::bosdyn::api::Polygon* polygon);
  private:
  const ::bosdyn::api::Polygon& _internal_polygon() const;
  ::bosdyn::api::Polygon* _internal_mutable_polygon();
  public:
  void unsafe_arena_set_allocated_polygon(
      ::bosdyn::api::Polygon* polygon);
  ::bosdyn::api::Polygon* unsafe_arena_release_polygon();

  // .bosdyn.api.Circle circle = 2;
  bool has_circle() const;
  private:
  bool _internal_has_circle() const;
  public:
  void clear_circle();
  const ::bosdyn::api::Circle& circle() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Circle* release_circle();
  ::bosdyn::api::Circle* mutable_circle();
  void set_allocated_circle(::bosdyn::api::Circle* circle);
  private:
  const ::bosdyn::api::Circle& _internal_circle() const;
  ::bosdyn::api::Circle* _internal_mutable_circle();
  public:
  void unsafe_arena_set_allocated_circle(
      ::bosdyn::api::Circle* circle);
  ::bosdyn::api::Circle* unsafe_arena_release_circle();

  void clear_geometry();
  GeometryCase geometry_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.Area)
 private:
  class _Internal;
  void set_has_polygon();
  void set_has_circle();

  inline bool has_geometry() const;
  inline void clear_has_geometry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union GeometryUnion {
      constexpr GeometryUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::Polygon* polygon_;
      ::bosdyn::api::Circle* circle_;
    } geometry_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Volume final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Volume) */ {
 public:
  inline Volume() : Volume(nullptr) {}
  ~Volume() override;
  explicit PROTOBUF_CONSTEXPR Volume(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Volume(const Volume& from);
  Volume(Volume&& from) noexcept
    : Volume() {
    *this = ::std::move(from);
  }

  inline Volume& operator=(const Volume& from) {
    CopyFrom(from);
    return *this;
  }
  inline Volume& operator=(Volume&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Volume& default_instance() {
    return *internal_default_instance();
  }
  enum GeometryCase {
    kBox = 1,
    GEOMETRY_NOT_SET = 0,
  };

  static inline const Volume* internal_default_instance() {
    return reinterpret_cast<const Volume*>(
               &_Volume_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Volume& a, Volume& b) {
    a.Swap(&b);
  }
  inline void Swap(Volume* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Volume* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Volume* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Volume>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Volume& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Volume& from) {
    Volume::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Volume* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Volume";
  }
  protected:
  explicit Volume(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoxFieldNumber = 1,
  };
  // .bosdyn.api.Vec3 box = 1;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::bosdyn::api::Vec3& box() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_box();
  ::bosdyn::api::Vec3* mutable_box();
  void set_allocated_box(::bosdyn::api::Vec3* box);
  private:
  const ::bosdyn::api::Vec3& _internal_box() const;
  ::bosdyn::api::Vec3* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::bosdyn::api::Vec3* box);
  ::bosdyn::api::Vec3* unsafe_arena_release_box();

  void clear_geometry();
  GeometryCase geometry_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.Volume)
 private:
  class _Internal;
  void set_has_box();

  inline bool has_geometry() const;
  inline void clear_has_geometry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union GeometryUnion {
      constexpr GeometryUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::Vec3* box_;
    } geometry_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Bounds final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Bounds) */ {
 public:
  inline Bounds() : Bounds(nullptr) {}
  ~Bounds() override;
  explicit PROTOBUF_CONSTEXPR Bounds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bounds(const Bounds& from);
  Bounds(Bounds&& from) noexcept
    : Bounds() {
    *this = ::std::move(from);
  }

  inline Bounds& operator=(const Bounds& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bounds& operator=(Bounds&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bounds& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bounds* internal_default_instance() {
    return reinterpret_cast<const Bounds*>(
               &_Bounds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Bounds& a, Bounds& b) {
    a.Swap(&b);
  }
  inline void Swap(Bounds* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bounds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bounds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bounds>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bounds& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Bounds& from) {
    Bounds::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bounds* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Bounds";
  }
  protected:
  explicit Bounds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowerFieldNumber = 1,
    kUpperFieldNumber = 2,
  };
  // double lower = 1;
  void clear_lower();
  double lower() const;
  void set_lower(double value);
  private:
  double _internal_lower() const;
  void _internal_set_lower(double value);
  public:

  // double upper = 2;
  void clear_upper();
  double upper() const;
  void set_upper(double value);
  private:
  double _internal_upper() const;
  void _internal_set_upper(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Bounds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double lower_;
    double upper_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Vec2Value final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Vec2Value) */ {
 public:
  inline Vec2Value() : Vec2Value(nullptr) {}
  ~Vec2Value() override;
  explicit PROTOBUF_CONSTEXPR Vec2Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec2Value(const Vec2Value& from);
  Vec2Value(Vec2Value&& from) noexcept
    : Vec2Value() {
    *this = ::std::move(from);
  }

  inline Vec2Value& operator=(const Vec2Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2Value& operator=(Vec2Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec2Value& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec2Value* internal_default_instance() {
    return reinterpret_cast<const Vec2Value*>(
               &_Vec2Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Vec2Value& a, Vec2Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec2Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec2Value>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec2Value& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vec2Value& from) {
    Vec2Value::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2Value* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Vec2Value";
  }
  protected:
  explicit Vec2Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // .google.protobuf.DoubleValue x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& x() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_x();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_x();
  void set_allocated_x(::PROTOBUF_NAMESPACE_ID::DoubleValue* x);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_x() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_x();
  public:
  void unsafe_arena_set_allocated_x(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* x);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_x();

  // .google.protobuf.DoubleValue y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& y() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_y();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_y();
  void set_allocated_y(::PROTOBUF_NAMESPACE_ID::DoubleValue* y);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_y() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_y();
  public:
  void unsafe_arena_set_allocated_y(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* y);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_y();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Vec2Value)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* x_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Vec3Value final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Vec3Value) */ {
 public:
  inline Vec3Value() : Vec3Value(nullptr) {}
  ~Vec3Value() override;
  explicit PROTOBUF_CONSTEXPR Vec3Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec3Value(const Vec3Value& from);
  Vec3Value(Vec3Value&& from) noexcept
    : Vec3Value() {
    *this = ::std::move(from);
  }

  inline Vec3Value& operator=(const Vec3Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3Value& operator=(Vec3Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec3Value& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec3Value* internal_default_instance() {
    return reinterpret_cast<const Vec3Value*>(
               &_Vec3Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Vec3Value& a, Vec3Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec3Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec3Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec3Value>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec3Value& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vec3Value& from) {
    Vec3Value::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3Value* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Vec3Value";
  }
  protected:
  explicit Vec3Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // .google.protobuf.DoubleValue x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& x() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_x();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_x();
  void set_allocated_x(::PROTOBUF_NAMESPACE_ID::DoubleValue* x);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_x() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_x();
  public:
  void unsafe_arena_set_allocated_x(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* x);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_x();

  // .google.protobuf.DoubleValue y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& y() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_y();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_y();
  void set_allocated_y(::PROTOBUF_NAMESPACE_ID::DoubleValue* y);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_y() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_y();
  public:
  void unsafe_arena_set_allocated_y(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* y);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_y();

  // .google.protobuf.DoubleValue z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& z() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_z();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_z();
  void set_allocated_z(::PROTOBUF_NAMESPACE_ID::DoubleValue* z);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_z() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_z();
  public:
  void unsafe_arena_set_allocated_z(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* z);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_z();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Vec3Value)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* x_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* y_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vec2

// double x = 1;
inline void Vec2::clear_x() {
  _impl_.x_ = 0;
}
inline double Vec2::_internal_x() const {
  return _impl_.x_;
}
inline double Vec2::x() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec2.x)
  return _internal_x();
}
inline void Vec2::_internal_set_x(double value) {
  
  _impl_.x_ = value;
}
inline void Vec2::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Vec2.x)
}

// double y = 2;
inline void Vec2::clear_y() {
  _impl_.y_ = 0;
}
inline double Vec2::_internal_y() const {
  return _impl_.y_;
}
inline double Vec2::y() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec2.y)
  return _internal_y();
}
inline void Vec2::_internal_set_y(double value) {
  
  _impl_.y_ = value;
}
inline void Vec2::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Vec2.y)
}

// -------------------------------------------------------------------

// Vec3

// double x = 1;
inline void Vec3::clear_x() {
  _impl_.x_ = 0;
}
inline double Vec3::_internal_x() const {
  return _impl_.x_;
}
inline double Vec3::x() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec3.x)
  return _internal_x();
}
inline void Vec3::_internal_set_x(double value) {
  
  _impl_.x_ = value;
}
inline void Vec3::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Vec3.x)
}

// double y = 2;
inline void Vec3::clear_y() {
  _impl_.y_ = 0;
}
inline double Vec3::_internal_y() const {
  return _impl_.y_;
}
inline double Vec3::y() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec3.y)
  return _internal_y();
}
inline void Vec3::_internal_set_y(double value) {
  
  _impl_.y_ = value;
}
inline void Vec3::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Vec3.y)
}

// double z = 3;
inline void Vec3::clear_z() {
  _impl_.z_ = 0;
}
inline double Vec3::_internal_z() const {
  return _impl_.z_;
}
inline double Vec3::z() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec3.z)
  return _internal_z();
}
inline void Vec3::_internal_set_z(double value) {
  
  _impl_.z_ = value;
}
inline void Vec3::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Vec3.z)
}

// -------------------------------------------------------------------

// CylindricalCoordinate

// double r = 1;
inline void CylindricalCoordinate::clear_r() {
  _impl_.r_ = 0;
}
inline double CylindricalCoordinate::_internal_r() const {
  return _impl_.r_;
}
inline double CylindricalCoordinate::r() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CylindricalCoordinate.r)
  return _internal_r();
}
inline void CylindricalCoordinate::_internal_set_r(double value) {
  
  _impl_.r_ = value;
}
inline void CylindricalCoordinate::set_r(double value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.CylindricalCoordinate.r)
}

// double theta = 2;
inline void CylindricalCoordinate::clear_theta() {
  _impl_.theta_ = 0;
}
inline double CylindricalCoordinate::_internal_theta() const {
  return _impl_.theta_;
}
inline double CylindricalCoordinate::theta() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CylindricalCoordinate.theta)
  return _internal_theta();
}
inline void CylindricalCoordinate::_internal_set_theta(double value) {
  
  _impl_.theta_ = value;
}
inline void CylindricalCoordinate::set_theta(double value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.CylindricalCoordinate.theta)
}

// double z = 3;
inline void CylindricalCoordinate::clear_z() {
  _impl_.z_ = 0;
}
inline double CylindricalCoordinate::_internal_z() const {
  return _impl_.z_;
}
inline double CylindricalCoordinate::z() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CylindricalCoordinate.z)
  return _internal_z();
}
inline void CylindricalCoordinate::_internal_set_z(double value) {
  
  _impl_.z_ = value;
}
inline void CylindricalCoordinate::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.CylindricalCoordinate.z)
}

// -------------------------------------------------------------------

// Quaternion

// double x = 1;
inline void Quaternion::clear_x() {
  _impl_.x_ = 0;
}
inline double Quaternion::_internal_x() const {
  return _impl_.x_;
}
inline double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Quaternion.x)
  return _internal_x();
}
inline void Quaternion::_internal_set_x(double value) {
  
  _impl_.x_ = value;
}
inline void Quaternion::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Quaternion.x)
}

// double y = 2;
inline void Quaternion::clear_y() {
  _impl_.y_ = 0;
}
inline double Quaternion::_internal_y() const {
  return _impl_.y_;
}
inline double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Quaternion.y)
  return _internal_y();
}
inline void Quaternion::_internal_set_y(double value) {
  
  _impl_.y_ = value;
}
inline void Quaternion::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Quaternion.y)
}

// double z = 3;
inline void Quaternion::clear_z() {
  _impl_.z_ = 0;
}
inline double Quaternion::_internal_z() const {
  return _impl_.z_;
}
inline double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Quaternion.z)
  return _internal_z();
}
inline void Quaternion::_internal_set_z(double value) {
  
  _impl_.z_ = value;
}
inline void Quaternion::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Quaternion.z)
}

// double w = 4;
inline void Quaternion::clear_w() {
  _impl_.w_ = 0;
}
inline double Quaternion::_internal_w() const {
  return _impl_.w_;
}
inline double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Quaternion.w)
  return _internal_w();
}
inline void Quaternion::_internal_set_w(double value) {
  
  _impl_.w_ = value;
}
inline void Quaternion::set_w(double value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Quaternion.w)
}

// -------------------------------------------------------------------

// Plane

// .bosdyn.api.Vec3 point = 1;
inline bool Plane::_internal_has_point() const {
  return this != internal_default_instance() && _impl_.point_ != nullptr;
}
inline bool Plane::has_point() const {
  return _internal_has_point();
}
inline void Plane::clear_point() {
  if (GetArenaForAllocation() == nullptr && _impl_.point_ != nullptr) {
    delete _impl_.point_;
  }
  _impl_.point_ = nullptr;
}
inline const ::bosdyn::api::Vec3& Plane::_internal_point() const {
  const ::bosdyn::api::Vec3* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& Plane::point() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Plane.point)
  return _internal_point();
}
inline void Plane::unsafe_arena_set_allocated_point(
    ::bosdyn::api::Vec3* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Plane.point)
}
inline ::bosdyn::api::Vec3* Plane::release_point() {
  
  ::bosdyn::api::Vec3* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* Plane::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Plane.point)
  
  ::bosdyn::api::Vec3* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* Plane::_internal_mutable_point() {
  
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::bosdyn::api::Vec3* Plane::mutable_point() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Plane.point)
  return _msg;
}
inline void Plane::set_allocated_point(::bosdyn::api::Vec3* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Plane.point)
}

// .bosdyn.api.Vec3 normal = 2;
inline bool Plane::_internal_has_normal() const {
  return this != internal_default_instance() && _impl_.normal_ != nullptr;
}
inline bool Plane::has_normal() const {
  return _internal_has_normal();
}
inline void Plane::clear_normal() {
  if (GetArenaForAllocation() == nullptr && _impl_.normal_ != nullptr) {
    delete _impl_.normal_;
  }
  _impl_.normal_ = nullptr;
}
inline const ::bosdyn::api::Vec3& Plane::_internal_normal() const {
  const ::bosdyn::api::Vec3* p = _impl_.normal_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& Plane::normal() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Plane.normal)
  return _internal_normal();
}
inline void Plane::unsafe_arena_set_allocated_normal(
    ::bosdyn::api::Vec3* normal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.normal_);
  }
  _impl_.normal_ = normal;
  if (normal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Plane.normal)
}
inline ::bosdyn::api::Vec3* Plane::release_normal() {
  
  ::bosdyn::api::Vec3* temp = _impl_.normal_;
  _impl_.normal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* Plane::unsafe_arena_release_normal() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Plane.normal)
  
  ::bosdyn::api::Vec3* temp = _impl_.normal_;
  _impl_.normal_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* Plane::_internal_mutable_normal() {
  
  if (_impl_.normal_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.normal_ = p;
  }
  return _impl_.normal_;
}
inline ::bosdyn::api::Vec3* Plane::mutable_normal() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_normal();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Plane.normal)
  return _msg;
}
inline void Plane::set_allocated_normal(::bosdyn::api::Vec3* normal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.normal_;
  }
  if (normal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(normal);
    if (message_arena != submessage_arena) {
      normal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, normal, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.normal_ = normal;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Plane.normal)
}

// -------------------------------------------------------------------

// Quad

// .bosdyn.api.SE3Pose pose = 1;
inline bool Quad::_internal_has_pose() const {
  return this != internal_default_instance() && _impl_.pose_ != nullptr;
}
inline bool Quad::has_pose() const {
  return _internal_has_pose();
}
inline void Quad::clear_pose() {
  if (GetArenaForAllocation() == nullptr && _impl_.pose_ != nullptr) {
    delete _impl_.pose_;
  }
  _impl_.pose_ = nullptr;
}
inline const ::bosdyn::api::SE3Pose& Quad::_internal_pose() const {
  const ::bosdyn::api::SE3Pose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Pose&>(
      ::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& Quad::pose() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Quad.pose)
  return _internal_pose();
}
inline void Quad::unsafe_arena_set_allocated_pose(
    ::bosdyn::api::SE3Pose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Quad.pose)
}
inline ::bosdyn::api::SE3Pose* Quad::release_pose() {
  
  ::bosdyn::api::SE3Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Pose* Quad::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Quad.pose)
  
  ::bosdyn::api::SE3Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* Quad::_internal_mutable_pose() {
  
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArenaForAllocation());
    _impl_.pose_ = p;
  }
  return _impl_.pose_;
}
inline ::bosdyn::api::SE3Pose* Quad::mutable_pose() {
  ::bosdyn::api::SE3Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Quad.pose)
  return _msg;
}
inline void Quad::set_allocated_pose(::bosdyn::api::SE3Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Quad.pose)
}

// double size = 2;
inline void Quad::clear_size() {
  _impl_.size_ = 0;
}
inline double Quad::_internal_size() const {
  return _impl_.size_;
}
inline double Quad::size() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Quad.size)
  return _internal_size();
}
inline void Quad::_internal_set_size(double value) {
  
  _impl_.size_ = value;
}
inline void Quad::set_size(double value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Quad.size)
}

// -------------------------------------------------------------------

// Ray

// .bosdyn.api.Vec3 origin = 1;
inline bool Ray::_internal_has_origin() const {
  return this != internal_default_instance() && _impl_.origin_ != nullptr;
}
inline bool Ray::has_origin() const {
  return _internal_has_origin();
}
inline void Ray::clear_origin() {
  if (GetArenaForAllocation() == nullptr && _impl_.origin_ != nullptr) {
    delete _impl_.origin_;
  }
  _impl_.origin_ = nullptr;
}
inline const ::bosdyn::api::Vec3& Ray::_internal_origin() const {
  const ::bosdyn::api::Vec3* p = _impl_.origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& Ray::origin() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Ray.origin)
  return _internal_origin();
}
inline void Ray::unsafe_arena_set_allocated_origin(
    ::bosdyn::api::Vec3* origin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.origin_);
  }
  _impl_.origin_ = origin;
  if (origin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Ray.origin)
}
inline ::bosdyn::api::Vec3* Ray::release_origin() {
  
  ::bosdyn::api::Vec3* temp = _impl_.origin_;
  _impl_.origin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* Ray::unsafe_arena_release_origin() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Ray.origin)
  
  ::bosdyn::api::Vec3* temp = _impl_.origin_;
  _impl_.origin_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* Ray::_internal_mutable_origin() {
  
  if (_impl_.origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.origin_ = p;
  }
  return _impl_.origin_;
}
inline ::bosdyn::api::Vec3* Ray::mutable_origin() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Ray.origin)
  return _msg;
}
inline void Ray::set_allocated_origin(::bosdyn::api::Vec3* origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.origin_;
  }
  if (origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(origin);
    if (message_arena != submessage_arena) {
      origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Ray.origin)
}

// .bosdyn.api.Vec3 direction = 2;
inline bool Ray::_internal_has_direction() const {
  return this != internal_default_instance() && _impl_.direction_ != nullptr;
}
inline bool Ray::has_direction() const {
  return _internal_has_direction();
}
inline void Ray::clear_direction() {
  if (GetArenaForAllocation() == nullptr && _impl_.direction_ != nullptr) {
    delete _impl_.direction_;
  }
  _impl_.direction_ = nullptr;
}
inline const ::bosdyn::api::Vec3& Ray::_internal_direction() const {
  const ::bosdyn::api::Vec3* p = _impl_.direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& Ray::direction() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Ray.direction)
  return _internal_direction();
}
inline void Ray::unsafe_arena_set_allocated_direction(
    ::bosdyn::api::Vec3* direction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.direction_);
  }
  _impl_.direction_ = direction;
  if (direction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Ray.direction)
}
inline ::bosdyn::api::Vec3* Ray::release_direction() {
  
  ::bosdyn::api::Vec3* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* Ray::unsafe_arena_release_direction() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Ray.direction)
  
  ::bosdyn::api::Vec3* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* Ray::_internal_mutable_direction() {
  
  if (_impl_.direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.direction_ = p;
  }
  return _impl_.direction_;
}
inline ::bosdyn::api::Vec3* Ray::mutable_direction() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Ray.direction)
  return _msg;
}
inline void Ray::set_allocated_direction(::bosdyn::api::Vec3* direction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.direction_;
  }
  if (direction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(direction);
    if (message_arena != submessage_arena) {
      direction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direction, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.direction_ = direction;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Ray.direction)
}

// -------------------------------------------------------------------

// SE2Pose

// .bosdyn.api.Vec2 position = 1;
inline bool SE2Pose::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool SE2Pose::has_position() const {
  return _internal_has_position();
}
inline void SE2Pose::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::bosdyn::api::Vec2& SE2Pose::_internal_position() const {
  const ::bosdyn::api::Vec2* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec2&>(
      ::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& SE2Pose::position() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2Pose.position)
  return _internal_position();
}
inline void SE2Pose::unsafe_arena_set_allocated_position(
    ::bosdyn::api::Vec2* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE2Pose.position)
}
inline ::bosdyn::api::Vec2* SE2Pose::release_position() {
  
  ::bosdyn::api::Vec2* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec2* SE2Pose::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE2Pose.position)
  
  ::bosdyn::api::Vec2* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* SE2Pose::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::bosdyn::api::Vec2* SE2Pose::mutable_position() {
  ::bosdyn::api::Vec2* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE2Pose.position)
  return _msg;
}
inline void SE2Pose::set_allocated_position(::bosdyn::api::Vec2* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE2Pose.position)
}

// double angle = 2;
inline void SE2Pose::clear_angle() {
  _impl_.angle_ = 0;
}
inline double SE2Pose::_internal_angle() const {
  return _impl_.angle_;
}
inline double SE2Pose::angle() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2Pose.angle)
  return _internal_angle();
}
inline void SE2Pose::_internal_set_angle(double value) {
  
  _impl_.angle_ = value;
}
inline void SE2Pose::set_angle(double value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE2Pose.angle)
}

// -------------------------------------------------------------------

// SE2Velocity

// .bosdyn.api.Vec2 linear = 1;
inline bool SE2Velocity::_internal_has_linear() const {
  return this != internal_default_instance() && _impl_.linear_ != nullptr;
}
inline bool SE2Velocity::has_linear() const {
  return _internal_has_linear();
}
inline void SE2Velocity::clear_linear() {
  if (GetArenaForAllocation() == nullptr && _impl_.linear_ != nullptr) {
    delete _impl_.linear_;
  }
  _impl_.linear_ = nullptr;
}
inline const ::bosdyn::api::Vec2& SE2Velocity::_internal_linear() const {
  const ::bosdyn::api::Vec2* p = _impl_.linear_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec2&>(
      ::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& SE2Velocity::linear() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2Velocity.linear)
  return _internal_linear();
}
inline void SE2Velocity::unsafe_arena_set_allocated_linear(
    ::bosdyn::api::Vec2* linear) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_);
  }
  _impl_.linear_ = linear;
  if (linear) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE2Velocity.linear)
}
inline ::bosdyn::api::Vec2* SE2Velocity::release_linear() {
  
  ::bosdyn::api::Vec2* temp = _impl_.linear_;
  _impl_.linear_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec2* SE2Velocity::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE2Velocity.linear)
  
  ::bosdyn::api::Vec2* temp = _impl_.linear_;
  _impl_.linear_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* SE2Velocity::_internal_mutable_linear() {
  
  if (_impl_.linear_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArenaForAllocation());
    _impl_.linear_ = p;
  }
  return _impl_.linear_;
}
inline ::bosdyn::api::Vec2* SE2Velocity::mutable_linear() {
  ::bosdyn::api::Vec2* _msg = _internal_mutable_linear();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE2Velocity.linear)
  return _msg;
}
inline void SE2Velocity::set_allocated_linear(::bosdyn::api::Vec2* linear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_;
  }
  if (linear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear);
    if (message_arena != submessage_arena) {
      linear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linear_ = linear;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE2Velocity.linear)
}

// double angular = 2;
inline void SE2Velocity::clear_angular() {
  _impl_.angular_ = 0;
}
inline double SE2Velocity::_internal_angular() const {
  return _impl_.angular_;
}
inline double SE2Velocity::angular() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2Velocity.angular)
  return _internal_angular();
}
inline void SE2Velocity::_internal_set_angular(double value) {
  
  _impl_.angular_ = value;
}
inline void SE2Velocity::set_angular(double value) {
  _internal_set_angular(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE2Velocity.angular)
}

// -------------------------------------------------------------------

// SE2VelocityLimit

// .bosdyn.api.SE2Velocity max_vel = 1;
inline bool SE2VelocityLimit::_internal_has_max_vel() const {
  return this != internal_default_instance() && _impl_.max_vel_ != nullptr;
}
inline bool SE2VelocityLimit::has_max_vel() const {
  return _internal_has_max_vel();
}
inline void SE2VelocityLimit::clear_max_vel() {
  if (GetArenaForAllocation() == nullptr && _impl_.max_vel_ != nullptr) {
    delete _impl_.max_vel_;
  }
  _impl_.max_vel_ = nullptr;
}
inline const ::bosdyn::api::SE2Velocity& SE2VelocityLimit::_internal_max_vel() const {
  const ::bosdyn::api::SE2Velocity* p = _impl_.max_vel_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE2Velocity&>(
      ::bosdyn::api::_SE2Velocity_default_instance_);
}
inline const ::bosdyn::api::SE2Velocity& SE2VelocityLimit::max_vel() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2VelocityLimit.max_vel)
  return _internal_max_vel();
}
inline void SE2VelocityLimit::unsafe_arena_set_allocated_max_vel(
    ::bosdyn::api::SE2Velocity* max_vel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_vel_);
  }
  _impl_.max_vel_ = max_vel;
  if (max_vel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE2VelocityLimit.max_vel)
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityLimit::release_max_vel() {
  
  ::bosdyn::api::SE2Velocity* temp = _impl_.max_vel_;
  _impl_.max_vel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityLimit::unsafe_arena_release_max_vel() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE2VelocityLimit.max_vel)
  
  ::bosdyn::api::SE2Velocity* temp = _impl_.max_vel_;
  _impl_.max_vel_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityLimit::_internal_mutable_max_vel() {
  
  if (_impl_.max_vel_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE2Velocity>(GetArenaForAllocation());
    _impl_.max_vel_ = p;
  }
  return _impl_.max_vel_;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityLimit::mutable_max_vel() {
  ::bosdyn::api::SE2Velocity* _msg = _internal_mutable_max_vel();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE2VelocityLimit.max_vel)
  return _msg;
}
inline void SE2VelocityLimit::set_allocated_max_vel(::bosdyn::api::SE2Velocity* max_vel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.max_vel_;
  }
  if (max_vel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(max_vel);
    if (message_arena != submessage_arena) {
      max_vel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max_vel, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.max_vel_ = max_vel;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE2VelocityLimit.max_vel)
}

// .bosdyn.api.SE2Velocity min_vel = 2;
inline bool SE2VelocityLimit::_internal_has_min_vel() const {
  return this != internal_default_instance() && _impl_.min_vel_ != nullptr;
}
inline bool SE2VelocityLimit::has_min_vel() const {
  return _internal_has_min_vel();
}
inline void SE2VelocityLimit::clear_min_vel() {
  if (GetArenaForAllocation() == nullptr && _impl_.min_vel_ != nullptr) {
    delete _impl_.min_vel_;
  }
  _impl_.min_vel_ = nullptr;
}
inline const ::bosdyn::api::SE2Velocity& SE2VelocityLimit::_internal_min_vel() const {
  const ::bosdyn::api::SE2Velocity* p = _impl_.min_vel_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE2Velocity&>(
      ::bosdyn::api::_SE2Velocity_default_instance_);
}
inline const ::bosdyn::api::SE2Velocity& SE2VelocityLimit::min_vel() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2VelocityLimit.min_vel)
  return _internal_min_vel();
}
inline void SE2VelocityLimit::unsafe_arena_set_allocated_min_vel(
    ::bosdyn::api::SE2Velocity* min_vel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_vel_);
  }
  _impl_.min_vel_ = min_vel;
  if (min_vel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE2VelocityLimit.min_vel)
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityLimit::release_min_vel() {
  
  ::bosdyn::api::SE2Velocity* temp = _impl_.min_vel_;
  _impl_.min_vel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityLimit::unsafe_arena_release_min_vel() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE2VelocityLimit.min_vel)
  
  ::bosdyn::api::SE2Velocity* temp = _impl_.min_vel_;
  _impl_.min_vel_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityLimit::_internal_mutable_min_vel() {
  
  if (_impl_.min_vel_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE2Velocity>(GetArenaForAllocation());
    _impl_.min_vel_ = p;
  }
  return _impl_.min_vel_;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityLimit::mutable_min_vel() {
  ::bosdyn::api::SE2Velocity* _msg = _internal_mutable_min_vel();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE2VelocityLimit.min_vel)
  return _msg;
}
inline void SE2VelocityLimit::set_allocated_min_vel(::bosdyn::api::SE2Velocity* min_vel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.min_vel_;
  }
  if (min_vel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(min_vel);
    if (message_arena != submessage_arena) {
      min_vel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min_vel, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.min_vel_ = min_vel;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE2VelocityLimit.min_vel)
}

// -------------------------------------------------------------------

// SE3Pose

// .bosdyn.api.Vec3 position = 1;
inline bool SE3Pose::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool SE3Pose::has_position() const {
  return _internal_has_position();
}
inline void SE3Pose::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::bosdyn::api::Vec3& SE3Pose::_internal_position() const {
  const ::bosdyn::api::Vec3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& SE3Pose::position() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Pose.position)
  return _internal_position();
}
inline void SE3Pose::unsafe_arena_set_allocated_position(
    ::bosdyn::api::Vec3* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE3Pose.position)
}
inline ::bosdyn::api::Vec3* SE3Pose::release_position() {
  
  ::bosdyn::api::Vec3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* SE3Pose::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE3Pose.position)
  
  ::bosdyn::api::Vec3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* SE3Pose::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::bosdyn::api::Vec3* SE3Pose::mutable_position() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE3Pose.position)
  return _msg;
}
inline void SE3Pose::set_allocated_position(::bosdyn::api::Vec3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE3Pose.position)
}

// .bosdyn.api.Quaternion rotation = 2;
inline bool SE3Pose::_internal_has_rotation() const {
  return this != internal_default_instance() && _impl_.rotation_ != nullptr;
}
inline bool SE3Pose::has_rotation() const {
  return _internal_has_rotation();
}
inline void SE3Pose::clear_rotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.rotation_ != nullptr) {
    delete _impl_.rotation_;
  }
  _impl_.rotation_ = nullptr;
}
inline const ::bosdyn::api::Quaternion& SE3Pose::_internal_rotation() const {
  const ::bosdyn::api::Quaternion* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Quaternion&>(
      ::bosdyn::api::_Quaternion_default_instance_);
}
inline const ::bosdyn::api::Quaternion& SE3Pose::rotation() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Pose.rotation)
  return _internal_rotation();
}
inline void SE3Pose::unsafe_arena_set_allocated_rotation(
    ::bosdyn::api::Quaternion* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE3Pose.rotation)
}
inline ::bosdyn::api::Quaternion* SE3Pose::release_rotation() {
  
  ::bosdyn::api::Quaternion* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Quaternion* SE3Pose::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE3Pose.rotation)
  
  ::bosdyn::api::Quaternion* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Quaternion* SE3Pose::_internal_mutable_rotation() {
  
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Quaternion>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::bosdyn::api::Quaternion* SE3Pose::mutable_rotation() {
  ::bosdyn::api::Quaternion* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE3Pose.rotation)
  return _msg;
}
inline void SE3Pose::set_allocated_rotation(::bosdyn::api::Quaternion* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE3Pose.rotation)
}

// -------------------------------------------------------------------

// SE3Velocity

// .bosdyn.api.Vec3 linear = 1;
inline bool SE3Velocity::_internal_has_linear() const {
  return this != internal_default_instance() && _impl_.linear_ != nullptr;
}
inline bool SE3Velocity::has_linear() const {
  return _internal_has_linear();
}
inline void SE3Velocity::clear_linear() {
  if (GetArenaForAllocation() == nullptr && _impl_.linear_ != nullptr) {
    delete _impl_.linear_;
  }
  _impl_.linear_ = nullptr;
}
inline const ::bosdyn::api::Vec3& SE3Velocity::_internal_linear() const {
  const ::bosdyn::api::Vec3* p = _impl_.linear_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& SE3Velocity::linear() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Velocity.linear)
  return _internal_linear();
}
inline void SE3Velocity::unsafe_arena_set_allocated_linear(
    ::bosdyn::api::Vec3* linear) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_);
  }
  _impl_.linear_ = linear;
  if (linear) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE3Velocity.linear)
}
inline ::bosdyn::api::Vec3* SE3Velocity::release_linear() {
  
  ::bosdyn::api::Vec3* temp = _impl_.linear_;
  _impl_.linear_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* SE3Velocity::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE3Velocity.linear)
  
  ::bosdyn::api::Vec3* temp = _impl_.linear_;
  _impl_.linear_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* SE3Velocity::_internal_mutable_linear() {
  
  if (_impl_.linear_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.linear_ = p;
  }
  return _impl_.linear_;
}
inline ::bosdyn::api::Vec3* SE3Velocity::mutable_linear() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_linear();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE3Velocity.linear)
  return _msg;
}
inline void SE3Velocity::set_allocated_linear(::bosdyn::api::Vec3* linear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_;
  }
  if (linear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear);
    if (message_arena != submessage_arena) {
      linear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linear_ = linear;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE3Velocity.linear)
}

// .bosdyn.api.Vec3 angular = 2;
inline bool SE3Velocity::_internal_has_angular() const {
  return this != internal_default_instance() && _impl_.angular_ != nullptr;
}
inline bool SE3Velocity::has_angular() const {
  return _internal_has_angular();
}
inline void SE3Velocity::clear_angular() {
  if (GetArenaForAllocation() == nullptr && _impl_.angular_ != nullptr) {
    delete _impl_.angular_;
  }
  _impl_.angular_ = nullptr;
}
inline const ::bosdyn::api::Vec3& SE3Velocity::_internal_angular() const {
  const ::bosdyn::api::Vec3* p = _impl_.angular_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& SE3Velocity::angular() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Velocity.angular)
  return _internal_angular();
}
inline void SE3Velocity::unsafe_arena_set_allocated_angular(
    ::bosdyn::api::Vec3* angular) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angular_);
  }
  _impl_.angular_ = angular;
  if (angular) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE3Velocity.angular)
}
inline ::bosdyn::api::Vec3* SE3Velocity::release_angular() {
  
  ::bosdyn::api::Vec3* temp = _impl_.angular_;
  _impl_.angular_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* SE3Velocity::unsafe_arena_release_angular() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE3Velocity.angular)
  
  ::bosdyn::api::Vec3* temp = _impl_.angular_;
  _impl_.angular_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* SE3Velocity::_internal_mutable_angular() {
  
  if (_impl_.angular_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.angular_ = p;
  }
  return _impl_.angular_;
}
inline ::bosdyn::api::Vec3* SE3Velocity::mutable_angular() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_angular();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE3Velocity.angular)
  return _msg;
}
inline void SE3Velocity::set_allocated_angular(::bosdyn::api::Vec3* angular) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.angular_;
  }
  if (angular) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(angular);
    if (message_arena != submessage_arena) {
      angular = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.angular_ = angular;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE3Velocity.angular)
}

// -------------------------------------------------------------------

// Wrench

// .bosdyn.api.Vec3 force = 1;
inline bool Wrench::_internal_has_force() const {
  return this != internal_default_instance() && _impl_.force_ != nullptr;
}
inline bool Wrench::has_force() const {
  return _internal_has_force();
}
inline void Wrench::clear_force() {
  if (GetArenaForAllocation() == nullptr && _impl_.force_ != nullptr) {
    delete _impl_.force_;
  }
  _impl_.force_ = nullptr;
}
inline const ::bosdyn::api::Vec3& Wrench::_internal_force() const {
  const ::bosdyn::api::Vec3* p = _impl_.force_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& Wrench::force() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Wrench.force)
  return _internal_force();
}
inline void Wrench::unsafe_arena_set_allocated_force(
    ::bosdyn::api::Vec3* force) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.force_);
  }
  _impl_.force_ = force;
  if (force) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Wrench.force)
}
inline ::bosdyn::api::Vec3* Wrench::release_force() {
  
  ::bosdyn::api::Vec3* temp = _impl_.force_;
  _impl_.force_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* Wrench::unsafe_arena_release_force() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Wrench.force)
  
  ::bosdyn::api::Vec3* temp = _impl_.force_;
  _impl_.force_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* Wrench::_internal_mutable_force() {
  
  if (_impl_.force_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.force_ = p;
  }
  return _impl_.force_;
}
inline ::bosdyn::api::Vec3* Wrench::mutable_force() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_force();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Wrench.force)
  return _msg;
}
inline void Wrench::set_allocated_force(::bosdyn::api::Vec3* force) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.force_;
  }
  if (force) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(force);
    if (message_arena != submessage_arena) {
      force = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, force, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.force_ = force;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Wrench.force)
}

// .bosdyn.api.Vec3 torque = 2;
inline bool Wrench::_internal_has_torque() const {
  return this != internal_default_instance() && _impl_.torque_ != nullptr;
}
inline bool Wrench::has_torque() const {
  return _internal_has_torque();
}
inline void Wrench::clear_torque() {
  if (GetArenaForAllocation() == nullptr && _impl_.torque_ != nullptr) {
    delete _impl_.torque_;
  }
  _impl_.torque_ = nullptr;
}
inline const ::bosdyn::api::Vec3& Wrench::_internal_torque() const {
  const ::bosdyn::api::Vec3* p = _impl_.torque_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& Wrench::torque() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Wrench.torque)
  return _internal_torque();
}
inline void Wrench::unsafe_arena_set_allocated_torque(
    ::bosdyn::api::Vec3* torque) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.torque_);
  }
  _impl_.torque_ = torque;
  if (torque) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Wrench.torque)
}
inline ::bosdyn::api::Vec3* Wrench::release_torque() {
  
  ::bosdyn::api::Vec3* temp = _impl_.torque_;
  _impl_.torque_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* Wrench::unsafe_arena_release_torque() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Wrench.torque)
  
  ::bosdyn::api::Vec3* temp = _impl_.torque_;
  _impl_.torque_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* Wrench::_internal_mutable_torque() {
  
  if (_impl_.torque_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.torque_ = p;
  }
  return _impl_.torque_;
}
inline ::bosdyn::api::Vec3* Wrench::mutable_torque() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_torque();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Wrench.torque)
  return _msg;
}
inline void Wrench::set_allocated_torque(::bosdyn::api::Vec3* torque) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.torque_;
  }
  if (torque) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(torque);
    if (message_arena != submessage_arena) {
      torque = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, torque, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.torque_ = torque;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Wrench.torque)
}

// -------------------------------------------------------------------

// FrameTreeSnapshot_ParentEdge

// string parent_frame_name = 1;
inline void FrameTreeSnapshot_ParentEdge::clear_parent_frame_name() {
  _impl_.parent_frame_name_.ClearToEmpty();
}
inline const std::string& FrameTreeSnapshot_ParentEdge::parent_frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_frame_name)
  return _internal_parent_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FrameTreeSnapshot_ParentEdge::set_parent_frame_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_frame_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_frame_name)
}
inline std::string* FrameTreeSnapshot_ParentEdge::mutable_parent_frame_name() {
  std::string* _s = _internal_mutable_parent_frame_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_frame_name)
  return _s;
}
inline const std::string& FrameTreeSnapshot_ParentEdge::_internal_parent_frame_name() const {
  return _impl_.parent_frame_name_.Get();
}
inline void FrameTreeSnapshot_ParentEdge::_internal_set_parent_frame_name(const std::string& value) {
  
  _impl_.parent_frame_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FrameTreeSnapshot_ParentEdge::_internal_mutable_parent_frame_name() {
  
  return _impl_.parent_frame_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FrameTreeSnapshot_ParentEdge::release_parent_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_frame_name)
  return _impl_.parent_frame_name_.Release();
}
inline void FrameTreeSnapshot_ParentEdge::set_allocated_parent_frame_name(std::string* parent_frame_name) {
  if (parent_frame_name != nullptr) {
    
  } else {
    
  }
  _impl_.parent_frame_name_.SetAllocated(parent_frame_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_frame_name_.IsDefault()) {
    _impl_.parent_frame_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_frame_name)
}

// .bosdyn.api.SE3Pose parent_tform_child = 2;
inline bool FrameTreeSnapshot_ParentEdge::_internal_has_parent_tform_child() const {
  return this != internal_default_instance() && _impl_.parent_tform_child_ != nullptr;
}
inline bool FrameTreeSnapshot_ParentEdge::has_parent_tform_child() const {
  return _internal_has_parent_tform_child();
}
inline void FrameTreeSnapshot_ParentEdge::clear_parent_tform_child() {
  if (GetArenaForAllocation() == nullptr && _impl_.parent_tform_child_ != nullptr) {
    delete _impl_.parent_tform_child_;
  }
  _impl_.parent_tform_child_ = nullptr;
}
inline const ::bosdyn::api::SE3Pose& FrameTreeSnapshot_ParentEdge::_internal_parent_tform_child() const {
  const ::bosdyn::api::SE3Pose* p = _impl_.parent_tform_child_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Pose&>(
      ::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& FrameTreeSnapshot_ParentEdge::parent_tform_child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_tform_child)
  return _internal_parent_tform_child();
}
inline void FrameTreeSnapshot_ParentEdge::unsafe_arena_set_allocated_parent_tform_child(
    ::bosdyn::api::SE3Pose* parent_tform_child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_tform_child_);
  }
  _impl_.parent_tform_child_ = parent_tform_child;
  if (parent_tform_child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_tform_child)
}
inline ::bosdyn::api::SE3Pose* FrameTreeSnapshot_ParentEdge::release_parent_tform_child() {
  
  ::bosdyn::api::SE3Pose* temp = _impl_.parent_tform_child_;
  _impl_.parent_tform_child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Pose* FrameTreeSnapshot_ParentEdge::unsafe_arena_release_parent_tform_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_tform_child)
  
  ::bosdyn::api::SE3Pose* temp = _impl_.parent_tform_child_;
  _impl_.parent_tform_child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* FrameTreeSnapshot_ParentEdge::_internal_mutable_parent_tform_child() {
  
  if (_impl_.parent_tform_child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArenaForAllocation());
    _impl_.parent_tform_child_ = p;
  }
  return _impl_.parent_tform_child_;
}
inline ::bosdyn::api::SE3Pose* FrameTreeSnapshot_ParentEdge::mutable_parent_tform_child() {
  ::bosdyn::api::SE3Pose* _msg = _internal_mutable_parent_tform_child();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_tform_child)
  return _msg;
}
inline void FrameTreeSnapshot_ParentEdge::set_allocated_parent_tform_child(::bosdyn::api::SE3Pose* parent_tform_child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_tform_child_;
  }
  if (parent_tform_child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent_tform_child);
    if (message_arena != submessage_arena) {
      parent_tform_child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent_tform_child, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.parent_tform_child_ = parent_tform_child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_tform_child)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FrameTreeSnapshot

// map<string, .bosdyn.api.FrameTreeSnapshot.ParentEdge> child_to_parent_edge_map = 1;
inline int FrameTreeSnapshot::_internal_child_to_parent_edge_map_size() const {
  return _impl_.child_to_parent_edge_map_.size();
}
inline int FrameTreeSnapshot::child_to_parent_edge_map_size() const {
  return _internal_child_to_parent_edge_map_size();
}
inline void FrameTreeSnapshot::clear_child_to_parent_edge_map() {
  _impl_.child_to_parent_edge_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge >&
FrameTreeSnapshot::_internal_child_to_parent_edge_map() const {
  return _impl_.child_to_parent_edge_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge >&
FrameTreeSnapshot::child_to_parent_edge_map() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.FrameTreeSnapshot.child_to_parent_edge_map)
  return _internal_child_to_parent_edge_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge >*
FrameTreeSnapshot::_internal_mutable_child_to_parent_edge_map() {
  return _impl_.child_to_parent_edge_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge >*
FrameTreeSnapshot::mutable_child_to_parent_edge_map() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.FrameTreeSnapshot.child_to_parent_edge_map)
  return _internal_mutable_child_to_parent_edge_map();
}

// -------------------------------------------------------------------

// Box2

// .bosdyn.api.Vec2 size = 1;
inline bool Box2::_internal_has_size() const {
  return this != internal_default_instance() && _impl_.size_ != nullptr;
}
inline bool Box2::has_size() const {
  return _internal_has_size();
}
inline void Box2::clear_size() {
  if (GetArenaForAllocation() == nullptr && _impl_.size_ != nullptr) {
    delete _impl_.size_;
  }
  _impl_.size_ = nullptr;
}
inline const ::bosdyn::api::Vec2& Box2::_internal_size() const {
  const ::bosdyn::api::Vec2* p = _impl_.size_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec2&>(
      ::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& Box2::size() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Box2.size)
  return _internal_size();
}
inline void Box2::unsafe_arena_set_allocated_size(
    ::bosdyn::api::Vec2* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.size_);
  }
  _impl_.size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Box2.size)
}
inline ::bosdyn::api::Vec2* Box2::release_size() {
  
  ::bosdyn::api::Vec2* temp = _impl_.size_;
  _impl_.size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec2* Box2::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Box2.size)
  
  ::bosdyn::api::Vec2* temp = _impl_.size_;
  _impl_.size_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* Box2::_internal_mutable_size() {
  
  if (_impl_.size_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArenaForAllocation());
    _impl_.size_ = p;
  }
  return _impl_.size_;
}
inline ::bosdyn::api::Vec2* Box2::mutable_size() {
  ::bosdyn::api::Vec2* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Box2.size)
  return _msg;
}
inline void Box2::set_allocated_size(::bosdyn::api::Vec2* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.size_ = size;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Box2.size)
}

// -------------------------------------------------------------------

// Box2WithFrame

// .bosdyn.api.Box2 box = 1;
inline bool Box2WithFrame::_internal_has_box() const {
  return this != internal_default_instance() && _impl_.box_ != nullptr;
}
inline bool Box2WithFrame::has_box() const {
  return _internal_has_box();
}
inline void Box2WithFrame::clear_box() {
  if (GetArenaForAllocation() == nullptr && _impl_.box_ != nullptr) {
    delete _impl_.box_;
  }
  _impl_.box_ = nullptr;
}
inline const ::bosdyn::api::Box2& Box2WithFrame::_internal_box() const {
  const ::bosdyn::api::Box2* p = _impl_.box_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Box2&>(
      ::bosdyn::api::_Box2_default_instance_);
}
inline const ::bosdyn::api::Box2& Box2WithFrame::box() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Box2WithFrame.box)
  return _internal_box();
}
inline void Box2WithFrame::unsafe_arena_set_allocated_box(
    ::bosdyn::api::Box2* box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.box_);
  }
  _impl_.box_ = box;
  if (box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Box2WithFrame.box)
}
inline ::bosdyn::api::Box2* Box2WithFrame::release_box() {
  
  ::bosdyn::api::Box2* temp = _impl_.box_;
  _impl_.box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Box2* Box2WithFrame::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Box2WithFrame.box)
  
  ::bosdyn::api::Box2* temp = _impl_.box_;
  _impl_.box_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Box2* Box2WithFrame::_internal_mutable_box() {
  
  if (_impl_.box_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Box2>(GetArenaForAllocation());
    _impl_.box_ = p;
  }
  return _impl_.box_;
}
inline ::bosdyn::api::Box2* Box2WithFrame::mutable_box() {
  ::bosdyn::api::Box2* _msg = _internal_mutable_box();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Box2WithFrame.box)
  return _msg;
}
inline void Box2WithFrame::set_allocated_box(::bosdyn::api::Box2* box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.box_;
  }
  if (box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(box);
    if (message_arena != submessage_arena) {
      box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.box_ = box;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Box2WithFrame.box)
}

// string frame_name = 2;
inline void Box2WithFrame::clear_frame_name() {
  _impl_.frame_name_.ClearToEmpty();
}
inline const std::string& Box2WithFrame::frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Box2WithFrame.frame_name)
  return _internal_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Box2WithFrame::set_frame_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.Box2WithFrame.frame_name)
}
inline std::string* Box2WithFrame::mutable_frame_name() {
  std::string* _s = _internal_mutable_frame_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Box2WithFrame.frame_name)
  return _s;
}
inline const std::string& Box2WithFrame::_internal_frame_name() const {
  return _impl_.frame_name_.Get();
}
inline void Box2WithFrame::_internal_set_frame_name(const std::string& value) {
  
  _impl_.frame_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Box2WithFrame::_internal_mutable_frame_name() {
  
  return _impl_.frame_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Box2WithFrame::release_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Box2WithFrame.frame_name)
  return _impl_.frame_name_.Release();
}
inline void Box2WithFrame::set_allocated_frame_name(std::string* frame_name) {
  if (frame_name != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_.SetAllocated(frame_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_.IsDefault()) {
    _impl_.frame_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Box2WithFrame.frame_name)
}

// .bosdyn.api.SE3Pose frame_name_tform_box = 3;
inline bool Box2WithFrame::_internal_has_frame_name_tform_box() const {
  return this != internal_default_instance() && _impl_.frame_name_tform_box_ != nullptr;
}
inline bool Box2WithFrame::has_frame_name_tform_box() const {
  return _internal_has_frame_name_tform_box();
}
inline void Box2WithFrame::clear_frame_name_tform_box() {
  if (GetArenaForAllocation() == nullptr && _impl_.frame_name_tform_box_ != nullptr) {
    delete _impl_.frame_name_tform_box_;
  }
  _impl_.frame_name_tform_box_ = nullptr;
}
inline const ::bosdyn::api::SE3Pose& Box2WithFrame::_internal_frame_name_tform_box() const {
  const ::bosdyn::api::SE3Pose* p = _impl_.frame_name_tform_box_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Pose&>(
      ::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& Box2WithFrame::frame_name_tform_box() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Box2WithFrame.frame_name_tform_box)
  return _internal_frame_name_tform_box();
}
inline void Box2WithFrame::unsafe_arena_set_allocated_frame_name_tform_box(
    ::bosdyn::api::SE3Pose* frame_name_tform_box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frame_name_tform_box_);
  }
  _impl_.frame_name_tform_box_ = frame_name_tform_box;
  if (frame_name_tform_box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Box2WithFrame.frame_name_tform_box)
}
inline ::bosdyn::api::SE3Pose* Box2WithFrame::release_frame_name_tform_box() {
  
  ::bosdyn::api::SE3Pose* temp = _impl_.frame_name_tform_box_;
  _impl_.frame_name_tform_box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Pose* Box2WithFrame::unsafe_arena_release_frame_name_tform_box() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Box2WithFrame.frame_name_tform_box)
  
  ::bosdyn::api::SE3Pose* temp = _impl_.frame_name_tform_box_;
  _impl_.frame_name_tform_box_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* Box2WithFrame::_internal_mutable_frame_name_tform_box() {
  
  if (_impl_.frame_name_tform_box_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArenaForAllocation());
    _impl_.frame_name_tform_box_ = p;
  }
  return _impl_.frame_name_tform_box_;
}
inline ::bosdyn::api::SE3Pose* Box2WithFrame::mutable_frame_name_tform_box() {
  ::bosdyn::api::SE3Pose* _msg = _internal_mutable_frame_name_tform_box();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Box2WithFrame.frame_name_tform_box)
  return _msg;
}
inline void Box2WithFrame::set_allocated_frame_name_tform_box(::bosdyn::api::SE3Pose* frame_name_tform_box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.frame_name_tform_box_;
  }
  if (frame_name_tform_box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame_name_tform_box);
    if (message_arena != submessage_arena) {
      frame_name_tform_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_name_tform_box, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.frame_name_tform_box_ = frame_name_tform_box;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Box2WithFrame.frame_name_tform_box)
}

// -------------------------------------------------------------------

// Box3

// .bosdyn.api.Vec3 size = 1;
inline bool Box3::_internal_has_size() const {
  return this != internal_default_instance() && _impl_.size_ != nullptr;
}
inline bool Box3::has_size() const {
  return _internal_has_size();
}
inline void Box3::clear_size() {
  if (GetArenaForAllocation() == nullptr && _impl_.size_ != nullptr) {
    delete _impl_.size_;
  }
  _impl_.size_ = nullptr;
}
inline const ::bosdyn::api::Vec3& Box3::_internal_size() const {
  const ::bosdyn::api::Vec3* p = _impl_.size_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& Box3::size() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Box3.size)
  return _internal_size();
}
inline void Box3::unsafe_arena_set_allocated_size(
    ::bosdyn::api::Vec3* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.size_);
  }
  _impl_.size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Box3.size)
}
inline ::bosdyn::api::Vec3* Box3::release_size() {
  
  ::bosdyn::api::Vec3* temp = _impl_.size_;
  _impl_.size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* Box3::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Box3.size)
  
  ::bosdyn::api::Vec3* temp = _impl_.size_;
  _impl_.size_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* Box3::_internal_mutable_size() {
  
  if (_impl_.size_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.size_ = p;
  }
  return _impl_.size_;
}
inline ::bosdyn::api::Vec3* Box3::mutable_size() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Box3.size)
  return _msg;
}
inline void Box3::set_allocated_size(::bosdyn::api::Vec3* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.size_ = size;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Box3.size)
}

// -------------------------------------------------------------------

// Box3WithFrame

// .bosdyn.api.Box3 box = 1;
inline bool Box3WithFrame::_internal_has_box() const {
  return this != internal_default_instance() && _impl_.box_ != nullptr;
}
inline bool Box3WithFrame::has_box() const {
  return _internal_has_box();
}
inline void Box3WithFrame::clear_box() {
  if (GetArenaForAllocation() == nullptr && _impl_.box_ != nullptr) {
    delete _impl_.box_;
  }
  _impl_.box_ = nullptr;
}
inline const ::bosdyn::api::Box3& Box3WithFrame::_internal_box() const {
  const ::bosdyn::api::Box3* p = _impl_.box_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Box3&>(
      ::bosdyn::api::_Box3_default_instance_);
}
inline const ::bosdyn::api::Box3& Box3WithFrame::box() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Box3WithFrame.box)
  return _internal_box();
}
inline void Box3WithFrame::unsafe_arena_set_allocated_box(
    ::bosdyn::api::Box3* box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.box_);
  }
  _impl_.box_ = box;
  if (box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Box3WithFrame.box)
}
inline ::bosdyn::api::Box3* Box3WithFrame::release_box() {
  
  ::bosdyn::api::Box3* temp = _impl_.box_;
  _impl_.box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Box3* Box3WithFrame::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Box3WithFrame.box)
  
  ::bosdyn::api::Box3* temp = _impl_.box_;
  _impl_.box_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Box3* Box3WithFrame::_internal_mutable_box() {
  
  if (_impl_.box_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Box3>(GetArenaForAllocation());
    _impl_.box_ = p;
  }
  return _impl_.box_;
}
inline ::bosdyn::api::Box3* Box3WithFrame::mutable_box() {
  ::bosdyn::api::Box3* _msg = _internal_mutable_box();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Box3WithFrame.box)
  return _msg;
}
inline void Box3WithFrame::set_allocated_box(::bosdyn::api::Box3* box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.box_;
  }
  if (box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(box);
    if (message_arena != submessage_arena) {
      box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.box_ = box;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Box3WithFrame.box)
}

// string frame_name = 2;
inline void Box3WithFrame::clear_frame_name() {
  _impl_.frame_name_.ClearToEmpty();
}
inline const std::string& Box3WithFrame::frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Box3WithFrame.frame_name)
  return _internal_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Box3WithFrame::set_frame_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.Box3WithFrame.frame_name)
}
inline std::string* Box3WithFrame::mutable_frame_name() {
  std::string* _s = _internal_mutable_frame_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Box3WithFrame.frame_name)
  return _s;
}
inline const std::string& Box3WithFrame::_internal_frame_name() const {
  return _impl_.frame_name_.Get();
}
inline void Box3WithFrame::_internal_set_frame_name(const std::string& value) {
  
  _impl_.frame_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Box3WithFrame::_internal_mutable_frame_name() {
  
  return _impl_.frame_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Box3WithFrame::release_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Box3WithFrame.frame_name)
  return _impl_.frame_name_.Release();
}
inline void Box3WithFrame::set_allocated_frame_name(std::string* frame_name) {
  if (frame_name != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_.SetAllocated(frame_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_.IsDefault()) {
    _impl_.frame_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Box3WithFrame.frame_name)
}

// .bosdyn.api.SE3Pose frame_name_tform_box = 3;
inline bool Box3WithFrame::_internal_has_frame_name_tform_box() const {
  return this != internal_default_instance() && _impl_.frame_name_tform_box_ != nullptr;
}
inline bool Box3WithFrame::has_frame_name_tform_box() const {
  return _internal_has_frame_name_tform_box();
}
inline void Box3WithFrame::clear_frame_name_tform_box() {
  if (GetArenaForAllocation() == nullptr && _impl_.frame_name_tform_box_ != nullptr) {
    delete _impl_.frame_name_tform_box_;
  }
  _impl_.frame_name_tform_box_ = nullptr;
}
inline const ::bosdyn::api::SE3Pose& Box3WithFrame::_internal_frame_name_tform_box() const {
  const ::bosdyn::api::SE3Pose* p = _impl_.frame_name_tform_box_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Pose&>(
      ::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& Box3WithFrame::frame_name_tform_box() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Box3WithFrame.frame_name_tform_box)
  return _internal_frame_name_tform_box();
}
inline void Box3WithFrame::unsafe_arena_set_allocated_frame_name_tform_box(
    ::bosdyn::api::SE3Pose* frame_name_tform_box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frame_name_tform_box_);
  }
  _impl_.frame_name_tform_box_ = frame_name_tform_box;
  if (frame_name_tform_box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Box3WithFrame.frame_name_tform_box)
}
inline ::bosdyn::api::SE3Pose* Box3WithFrame::release_frame_name_tform_box() {
  
  ::bosdyn::api::SE3Pose* temp = _impl_.frame_name_tform_box_;
  _impl_.frame_name_tform_box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Pose* Box3WithFrame::unsafe_arena_release_frame_name_tform_box() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Box3WithFrame.frame_name_tform_box)
  
  ::bosdyn::api::SE3Pose* temp = _impl_.frame_name_tform_box_;
  _impl_.frame_name_tform_box_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* Box3WithFrame::_internal_mutable_frame_name_tform_box() {
  
  if (_impl_.frame_name_tform_box_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArenaForAllocation());
    _impl_.frame_name_tform_box_ = p;
  }
  return _impl_.frame_name_tform_box_;
}
inline ::bosdyn::api::SE3Pose* Box3WithFrame::mutable_frame_name_tform_box() {
  ::bosdyn::api::SE3Pose* _msg = _internal_mutable_frame_name_tform_box();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Box3WithFrame.frame_name_tform_box)
  return _msg;
}
inline void Box3WithFrame::set_allocated_frame_name_tform_box(::bosdyn::api::SE3Pose* frame_name_tform_box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.frame_name_tform_box_;
  }
  if (frame_name_tform_box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame_name_tform_box);
    if (message_arena != submessage_arena) {
      frame_name_tform_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_name_tform_box, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.frame_name_tform_box_ = frame_name_tform_box;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Box3WithFrame.frame_name_tform_box)
}

// -------------------------------------------------------------------

// Matrix

// int32 rows = 1;
inline void Matrix::clear_rows() {
  _impl_.rows_ = 0;
}
inline int32_t Matrix::_internal_rows() const {
  return _impl_.rows_;
}
inline int32_t Matrix::rows() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Matrix.rows)
  return _internal_rows();
}
inline void Matrix::_internal_set_rows(int32_t value) {
  
  _impl_.rows_ = value;
}
inline void Matrix::set_rows(int32_t value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Matrix.rows)
}

// int32 cols = 2;
inline void Matrix::clear_cols() {
  _impl_.cols_ = 0;
}
inline int32_t Matrix::_internal_cols() const {
  return _impl_.cols_;
}
inline int32_t Matrix::cols() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Matrix.cols)
  return _internal_cols();
}
inline void Matrix::_internal_set_cols(int32_t value) {
  
  _impl_.cols_ = value;
}
inline void Matrix::set_cols(int32_t value) {
  _internal_set_cols(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Matrix.cols)
}

// repeated double values = 3;
inline int Matrix::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Matrix::values_size() const {
  return _internal_values_size();
}
inline void Matrix::clear_values() {
  _impl_.values_.Clear();
}
inline double Matrix::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline double Matrix::values(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Matrix.values)
  return _internal_values(index);
}
inline void Matrix::set_values(int index, double value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Matrix.values)
}
inline void Matrix::_internal_add_values(double value) {
  _impl_.values_.Add(value);
}
inline void Matrix::add_values(double value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.Matrix.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Matrix::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Matrix::values() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.Matrix.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Matrix::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Matrix::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.Matrix.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Matrixf

// int32 rows = 1;
inline void Matrixf::clear_rows() {
  _impl_.rows_ = 0;
}
inline int32_t Matrixf::_internal_rows() const {
  return _impl_.rows_;
}
inline int32_t Matrixf::rows() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Matrixf.rows)
  return _internal_rows();
}
inline void Matrixf::_internal_set_rows(int32_t value) {
  
  _impl_.rows_ = value;
}
inline void Matrixf::set_rows(int32_t value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Matrixf.rows)
}

// int32 cols = 2;
inline void Matrixf::clear_cols() {
  _impl_.cols_ = 0;
}
inline int32_t Matrixf::_internal_cols() const {
  return _impl_.cols_;
}
inline int32_t Matrixf::cols() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Matrixf.cols)
  return _internal_cols();
}
inline void Matrixf::_internal_set_cols(int32_t value) {
  
  _impl_.cols_ = value;
}
inline void Matrixf::set_cols(int32_t value) {
  _internal_set_cols(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Matrixf.cols)
}

// repeated float values = 3;
inline int Matrixf::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Matrixf::values_size() const {
  return _internal_values_size();
}
inline void Matrixf::clear_values() {
  _impl_.values_.Clear();
}
inline float Matrixf::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline float Matrixf::values(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Matrixf.values)
  return _internal_values(index);
}
inline void Matrixf::set_values(int index, float value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Matrixf.values)
}
inline void Matrixf::_internal_add_values(float value) {
  _impl_.values_.Add(value);
}
inline void Matrixf::add_values(float value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.Matrixf.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Matrixf::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Matrixf::values() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.Matrixf.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Matrixf::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Matrixf::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.Matrixf.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// MatrixInt64

// int32 rows = 1;
inline void MatrixInt64::clear_rows() {
  _impl_.rows_ = 0;
}
inline int32_t MatrixInt64::_internal_rows() const {
  return _impl_.rows_;
}
inline int32_t MatrixInt64::rows() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MatrixInt64.rows)
  return _internal_rows();
}
inline void MatrixInt64::_internal_set_rows(int32_t value) {
  
  _impl_.rows_ = value;
}
inline void MatrixInt64::set_rows(int32_t value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MatrixInt64.rows)
}

// int32 cols = 2;
inline void MatrixInt64::clear_cols() {
  _impl_.cols_ = 0;
}
inline int32_t MatrixInt64::_internal_cols() const {
  return _impl_.cols_;
}
inline int32_t MatrixInt64::cols() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MatrixInt64.cols)
  return _internal_cols();
}
inline void MatrixInt64::_internal_set_cols(int32_t value) {
  
  _impl_.cols_ = value;
}
inline void MatrixInt64::set_cols(int32_t value) {
  _internal_set_cols(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MatrixInt64.cols)
}

// repeated int64 values = 3;
inline int MatrixInt64::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int MatrixInt64::values_size() const {
  return _internal_values_size();
}
inline void MatrixInt64::clear_values() {
  _impl_.values_.Clear();
}
inline int64_t MatrixInt64::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline int64_t MatrixInt64::values(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MatrixInt64.values)
  return _internal_values(index);
}
inline void MatrixInt64::set_values(int index, int64_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MatrixInt64.values)
}
inline void MatrixInt64::_internal_add_values(int64_t value) {
  _impl_.values_.Add(value);
}
inline void MatrixInt64::add_values(int64_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.MatrixInt64.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
MatrixInt64::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
MatrixInt64::values() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.MatrixInt64.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
MatrixInt64::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
MatrixInt64::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.MatrixInt64.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// MatrixInt32

// int32 rows = 1;
inline void MatrixInt32::clear_rows() {
  _impl_.rows_ = 0;
}
inline int32_t MatrixInt32::_internal_rows() const {
  return _impl_.rows_;
}
inline int32_t MatrixInt32::rows() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MatrixInt32.rows)
  return _internal_rows();
}
inline void MatrixInt32::_internal_set_rows(int32_t value) {
  
  _impl_.rows_ = value;
}
inline void MatrixInt32::set_rows(int32_t value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MatrixInt32.rows)
}

// int32 cols = 2;
inline void MatrixInt32::clear_cols() {
  _impl_.cols_ = 0;
}
inline int32_t MatrixInt32::_internal_cols() const {
  return _impl_.cols_;
}
inline int32_t MatrixInt32::cols() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MatrixInt32.cols)
  return _internal_cols();
}
inline void MatrixInt32::_internal_set_cols(int32_t value) {
  
  _impl_.cols_ = value;
}
inline void MatrixInt32::set_cols(int32_t value) {
  _internal_set_cols(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MatrixInt32.cols)
}

// repeated int32 values = 3;
inline int MatrixInt32::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int MatrixInt32::values_size() const {
  return _internal_values_size();
}
inline void MatrixInt32::clear_values() {
  _impl_.values_.Clear();
}
inline int32_t MatrixInt32::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline int32_t MatrixInt32::values(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MatrixInt32.values)
  return _internal_values(index);
}
inline void MatrixInt32::set_values(int index, int32_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MatrixInt32.values)
}
inline void MatrixInt32::_internal_add_values(int32_t value) {
  _impl_.values_.Add(value);
}
inline void MatrixInt32::add_values(int32_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.MatrixInt32.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
MatrixInt32::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
MatrixInt32::values() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.MatrixInt32.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
MatrixInt32::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
MatrixInt32::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.MatrixInt32.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Vector

// repeated double values = 1;
inline int Vector::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Vector::values_size() const {
  return _internal_values_size();
}
inline void Vector::clear_values() {
  _impl_.values_.Clear();
}
inline double Vector::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline double Vector::values(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vector.values)
  return _internal_values(index);
}
inline void Vector::set_values(int index, double value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Vector.values)
}
inline void Vector::_internal_add_values(double value) {
  _impl_.values_.Add(value);
}
inline void Vector::add_values(double value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.Vector.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Vector::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Vector::values() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.Vector.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Vector::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Vector::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.Vector.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// SE3Covariance

// .bosdyn.api.Matrix matrix = 1;
inline bool SE3Covariance::_internal_has_matrix() const {
  return this != internal_default_instance() && _impl_.matrix_ != nullptr;
}
inline bool SE3Covariance::has_matrix() const {
  return _internal_has_matrix();
}
inline void SE3Covariance::clear_matrix() {
  if (GetArenaForAllocation() == nullptr && _impl_.matrix_ != nullptr) {
    delete _impl_.matrix_;
  }
  _impl_.matrix_ = nullptr;
}
inline const ::bosdyn::api::Matrix& SE3Covariance::_internal_matrix() const {
  const ::bosdyn::api::Matrix* p = _impl_.matrix_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Matrix&>(
      ::bosdyn::api::_Matrix_default_instance_);
}
inline const ::bosdyn::api::Matrix& SE3Covariance::matrix() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.matrix)
  return _internal_matrix();
}
inline void SE3Covariance::unsafe_arena_set_allocated_matrix(
    ::bosdyn::api::Matrix* matrix) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.matrix_);
  }
  _impl_.matrix_ = matrix;
  if (matrix) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE3Covariance.matrix)
}
inline ::bosdyn::api::Matrix* SE3Covariance::release_matrix() {
  
  ::bosdyn::api::Matrix* temp = _impl_.matrix_;
  _impl_.matrix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Matrix* SE3Covariance::unsafe_arena_release_matrix() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE3Covariance.matrix)
  
  ::bosdyn::api::Matrix* temp = _impl_.matrix_;
  _impl_.matrix_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Matrix* SE3Covariance::_internal_mutable_matrix() {
  
  if (_impl_.matrix_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Matrix>(GetArenaForAllocation());
    _impl_.matrix_ = p;
  }
  return _impl_.matrix_;
}
inline ::bosdyn::api::Matrix* SE3Covariance::mutable_matrix() {
  ::bosdyn::api::Matrix* _msg = _internal_mutable_matrix();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE3Covariance.matrix)
  return _msg;
}
inline void SE3Covariance::set_allocated_matrix(::bosdyn::api::Matrix* matrix) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.matrix_;
  }
  if (matrix) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(matrix);
    if (message_arena != submessage_arena) {
      matrix = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, matrix, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.matrix_ = matrix;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE3Covariance.matrix)
}

// double yaw_variance = 2 [deprecated = true];
inline void SE3Covariance::clear_yaw_variance() {
  _impl_.yaw_variance_ = 0;
}
inline double SE3Covariance::_internal_yaw_variance() const {
  return _impl_.yaw_variance_;
}
inline double SE3Covariance::yaw_variance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.yaw_variance)
  return _internal_yaw_variance();
}
inline void SE3Covariance::_internal_set_yaw_variance(double value) {
  
  _impl_.yaw_variance_ = value;
}
inline void SE3Covariance::set_yaw_variance(double value) {
  _internal_set_yaw_variance(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.yaw_variance)
}

// double cov_xx = 3 [deprecated = true];
inline void SE3Covariance::clear_cov_xx() {
  _impl_.cov_xx_ = 0;
}
inline double SE3Covariance::_internal_cov_xx() const {
  return _impl_.cov_xx_;
}
inline double SE3Covariance::cov_xx() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_xx)
  return _internal_cov_xx();
}
inline void SE3Covariance::_internal_set_cov_xx(double value) {
  
  _impl_.cov_xx_ = value;
}
inline void SE3Covariance::set_cov_xx(double value) {
  _internal_set_cov_xx(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_xx)
}

// double cov_xy = 4 [deprecated = true];
inline void SE3Covariance::clear_cov_xy() {
  _impl_.cov_xy_ = 0;
}
inline double SE3Covariance::_internal_cov_xy() const {
  return _impl_.cov_xy_;
}
inline double SE3Covariance::cov_xy() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_xy)
  return _internal_cov_xy();
}
inline void SE3Covariance::_internal_set_cov_xy(double value) {
  
  _impl_.cov_xy_ = value;
}
inline void SE3Covariance::set_cov_xy(double value) {
  _internal_set_cov_xy(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_xy)
}

// double cov_xz = 5 [deprecated = true];
inline void SE3Covariance::clear_cov_xz() {
  _impl_.cov_xz_ = 0;
}
inline double SE3Covariance::_internal_cov_xz() const {
  return _impl_.cov_xz_;
}
inline double SE3Covariance::cov_xz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_xz)
  return _internal_cov_xz();
}
inline void SE3Covariance::_internal_set_cov_xz(double value) {
  
  _impl_.cov_xz_ = value;
}
inline void SE3Covariance::set_cov_xz(double value) {
  _internal_set_cov_xz(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_xz)
}

// double cov_yx = 6 [deprecated = true];
inline void SE3Covariance::clear_cov_yx() {
  _impl_.cov_yx_ = 0;
}
inline double SE3Covariance::_internal_cov_yx() const {
  return _impl_.cov_yx_;
}
inline double SE3Covariance::cov_yx() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_yx)
  return _internal_cov_yx();
}
inline void SE3Covariance::_internal_set_cov_yx(double value) {
  
  _impl_.cov_yx_ = value;
}
inline void SE3Covariance::set_cov_yx(double value) {
  _internal_set_cov_yx(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_yx)
}

// double cov_yy = 7 [deprecated = true];
inline void SE3Covariance::clear_cov_yy() {
  _impl_.cov_yy_ = 0;
}
inline double SE3Covariance::_internal_cov_yy() const {
  return _impl_.cov_yy_;
}
inline double SE3Covariance::cov_yy() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_yy)
  return _internal_cov_yy();
}
inline void SE3Covariance::_internal_set_cov_yy(double value) {
  
  _impl_.cov_yy_ = value;
}
inline void SE3Covariance::set_cov_yy(double value) {
  _internal_set_cov_yy(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_yy)
}

// double cov_yz = 8 [deprecated = true];
inline void SE3Covariance::clear_cov_yz() {
  _impl_.cov_yz_ = 0;
}
inline double SE3Covariance::_internal_cov_yz() const {
  return _impl_.cov_yz_;
}
inline double SE3Covariance::cov_yz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_yz)
  return _internal_cov_yz();
}
inline void SE3Covariance::_internal_set_cov_yz(double value) {
  
  _impl_.cov_yz_ = value;
}
inline void SE3Covariance::set_cov_yz(double value) {
  _internal_set_cov_yz(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_yz)
}

// double cov_zx = 9 [deprecated = true];
inline void SE3Covariance::clear_cov_zx() {
  _impl_.cov_zx_ = 0;
}
inline double SE3Covariance::_internal_cov_zx() const {
  return _impl_.cov_zx_;
}
inline double SE3Covariance::cov_zx() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_zx)
  return _internal_cov_zx();
}
inline void SE3Covariance::_internal_set_cov_zx(double value) {
  
  _impl_.cov_zx_ = value;
}
inline void SE3Covariance::set_cov_zx(double value) {
  _internal_set_cov_zx(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_zx)
}

// double cov_zy = 10 [deprecated = true];
inline void SE3Covariance::clear_cov_zy() {
  _impl_.cov_zy_ = 0;
}
inline double SE3Covariance::_internal_cov_zy() const {
  return _impl_.cov_zy_;
}
inline double SE3Covariance::cov_zy() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_zy)
  return _internal_cov_zy();
}
inline void SE3Covariance::_internal_set_cov_zy(double value) {
  
  _impl_.cov_zy_ = value;
}
inline void SE3Covariance::set_cov_zy(double value) {
  _internal_set_cov_zy(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_zy)
}

// double cov_zz = 11 [deprecated = true];
inline void SE3Covariance::clear_cov_zz() {
  _impl_.cov_zz_ = 0;
}
inline double SE3Covariance::_internal_cov_zz() const {
  return _impl_.cov_zz_;
}
inline double SE3Covariance::cov_zz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_zz)
  return _internal_cov_zz();
}
inline void SE3Covariance::_internal_set_cov_zz(double value) {
  
  _impl_.cov_zz_ = value;
}
inline void SE3Covariance::set_cov_zz(double value) {
  _internal_set_cov_zz(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_zz)
}

// -------------------------------------------------------------------

// PolyLine

// repeated .bosdyn.api.Vec2 points = 1;
inline int PolyLine::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int PolyLine::points_size() const {
  return _internal_points_size();
}
inline void PolyLine::clear_points() {
  _impl_.points_.Clear();
}
inline ::bosdyn::api::Vec2* PolyLine::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PolyLine.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 >*
PolyLine::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.PolyLine.points)
  return &_impl_.points_;
}
inline const ::bosdyn::api::Vec2& PolyLine::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::bosdyn::api::Vec2& PolyLine::points(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PolyLine.points)
  return _internal_points(index);
}
inline ::bosdyn::api::Vec2* PolyLine::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::bosdyn::api::Vec2* PolyLine::add_points() {
  ::bosdyn::api::Vec2* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:bosdyn.api.PolyLine.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 >&
PolyLine::points() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.PolyLine.points)
  return _impl_.points_;
}

// -------------------------------------------------------------------

// Polygon

// repeated .bosdyn.api.Vec2 vertexes = 1;
inline int Polygon::_internal_vertexes_size() const {
  return _impl_.vertexes_.size();
}
inline int Polygon::vertexes_size() const {
  return _internal_vertexes_size();
}
inline void Polygon::clear_vertexes() {
  _impl_.vertexes_.Clear();
}
inline ::bosdyn::api::Vec2* Polygon::mutable_vertexes(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Polygon.vertexes)
  return _impl_.vertexes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 >*
Polygon::mutable_vertexes() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.Polygon.vertexes)
  return &_impl_.vertexes_;
}
inline const ::bosdyn::api::Vec2& Polygon::_internal_vertexes(int index) const {
  return _impl_.vertexes_.Get(index);
}
inline const ::bosdyn::api::Vec2& Polygon::vertexes(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Polygon.vertexes)
  return _internal_vertexes(index);
}
inline ::bosdyn::api::Vec2* Polygon::_internal_add_vertexes() {
  return _impl_.vertexes_.Add();
}
inline ::bosdyn::api::Vec2* Polygon::add_vertexes() {
  ::bosdyn::api::Vec2* _add = _internal_add_vertexes();
  // @@protoc_insertion_point(field_add:bosdyn.api.Polygon.vertexes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 >&
Polygon::vertexes() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.Polygon.vertexes)
  return _impl_.vertexes_;
}

// -------------------------------------------------------------------

// PolygonWithExclusions

// .bosdyn.api.Polygon inclusion = 5;
inline bool PolygonWithExclusions::_internal_has_inclusion() const {
  return this != internal_default_instance() && _impl_.inclusion_ != nullptr;
}
inline bool PolygonWithExclusions::has_inclusion() const {
  return _internal_has_inclusion();
}
inline void PolygonWithExclusions::clear_inclusion() {
  if (GetArenaForAllocation() == nullptr && _impl_.inclusion_ != nullptr) {
    delete _impl_.inclusion_;
  }
  _impl_.inclusion_ = nullptr;
}
inline const ::bosdyn::api::Polygon& PolygonWithExclusions::_internal_inclusion() const {
  const ::bosdyn::api::Polygon* p = _impl_.inclusion_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Polygon&>(
      ::bosdyn::api::_Polygon_default_instance_);
}
inline const ::bosdyn::api::Polygon& PolygonWithExclusions::inclusion() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PolygonWithExclusions.inclusion)
  return _internal_inclusion();
}
inline void PolygonWithExclusions::unsafe_arena_set_allocated_inclusion(
    ::bosdyn::api::Polygon* inclusion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inclusion_);
  }
  _impl_.inclusion_ = inclusion;
  if (inclusion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PolygonWithExclusions.inclusion)
}
inline ::bosdyn::api::Polygon* PolygonWithExclusions::release_inclusion() {
  
  ::bosdyn::api::Polygon* temp = _impl_.inclusion_;
  _impl_.inclusion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Polygon* PolygonWithExclusions::unsafe_arena_release_inclusion() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PolygonWithExclusions.inclusion)
  
  ::bosdyn::api::Polygon* temp = _impl_.inclusion_;
  _impl_.inclusion_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Polygon* PolygonWithExclusions::_internal_mutable_inclusion() {
  
  if (_impl_.inclusion_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Polygon>(GetArenaForAllocation());
    _impl_.inclusion_ = p;
  }
  return _impl_.inclusion_;
}
inline ::bosdyn::api::Polygon* PolygonWithExclusions::mutable_inclusion() {
  ::bosdyn::api::Polygon* _msg = _internal_mutable_inclusion();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PolygonWithExclusions.inclusion)
  return _msg;
}
inline void PolygonWithExclusions::set_allocated_inclusion(::bosdyn::api::Polygon* inclusion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.inclusion_;
  }
  if (inclusion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inclusion);
    if (message_arena != submessage_arena) {
      inclusion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inclusion, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.inclusion_ = inclusion;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PolygonWithExclusions.inclusion)
}

// repeated .bosdyn.api.Polygon exclusions = 6;
inline int PolygonWithExclusions::_internal_exclusions_size() const {
  return _impl_.exclusions_.size();
}
inline int PolygonWithExclusions::exclusions_size() const {
  return _internal_exclusions_size();
}
inline void PolygonWithExclusions::clear_exclusions() {
  _impl_.exclusions_.Clear();
}
inline ::bosdyn::api::Polygon* PolygonWithExclusions::mutable_exclusions(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PolygonWithExclusions.exclusions)
  return _impl_.exclusions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Polygon >*
PolygonWithExclusions::mutable_exclusions() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.PolygonWithExclusions.exclusions)
  return &_impl_.exclusions_;
}
inline const ::bosdyn::api::Polygon& PolygonWithExclusions::_internal_exclusions(int index) const {
  return _impl_.exclusions_.Get(index);
}
inline const ::bosdyn::api::Polygon& PolygonWithExclusions::exclusions(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PolygonWithExclusions.exclusions)
  return _internal_exclusions(index);
}
inline ::bosdyn::api::Polygon* PolygonWithExclusions::_internal_add_exclusions() {
  return _impl_.exclusions_.Add();
}
inline ::bosdyn::api::Polygon* PolygonWithExclusions::add_exclusions() {
  ::bosdyn::api::Polygon* _add = _internal_add_exclusions();
  // @@protoc_insertion_point(field_add:bosdyn.api.PolygonWithExclusions.exclusions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Polygon >&
PolygonWithExclusions::exclusions() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.PolygonWithExclusions.exclusions)
  return _impl_.exclusions_;
}

// -------------------------------------------------------------------

// Circle

// .bosdyn.api.Vec2 center_pt = 1;
inline bool Circle::_internal_has_center_pt() const {
  return this != internal_default_instance() && _impl_.center_pt_ != nullptr;
}
inline bool Circle::has_center_pt() const {
  return _internal_has_center_pt();
}
inline void Circle::clear_center_pt() {
  if (GetArenaForAllocation() == nullptr && _impl_.center_pt_ != nullptr) {
    delete _impl_.center_pt_;
  }
  _impl_.center_pt_ = nullptr;
}
inline const ::bosdyn::api::Vec2& Circle::_internal_center_pt() const {
  const ::bosdyn::api::Vec2* p = _impl_.center_pt_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec2&>(
      ::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& Circle::center_pt() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Circle.center_pt)
  return _internal_center_pt();
}
inline void Circle::unsafe_arena_set_allocated_center_pt(
    ::bosdyn::api::Vec2* center_pt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.center_pt_);
  }
  _impl_.center_pt_ = center_pt;
  if (center_pt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Circle.center_pt)
}
inline ::bosdyn::api::Vec2* Circle::release_center_pt() {
  
  ::bosdyn::api::Vec2* temp = _impl_.center_pt_;
  _impl_.center_pt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec2* Circle::unsafe_arena_release_center_pt() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Circle.center_pt)
  
  ::bosdyn::api::Vec2* temp = _impl_.center_pt_;
  _impl_.center_pt_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* Circle::_internal_mutable_center_pt() {
  
  if (_impl_.center_pt_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArenaForAllocation());
    _impl_.center_pt_ = p;
  }
  return _impl_.center_pt_;
}
inline ::bosdyn::api::Vec2* Circle::mutable_center_pt() {
  ::bosdyn::api::Vec2* _msg = _internal_mutable_center_pt();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Circle.center_pt)
  return _msg;
}
inline void Circle::set_allocated_center_pt(::bosdyn::api::Vec2* center_pt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.center_pt_;
  }
  if (center_pt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(center_pt);
    if (message_arena != submessage_arena) {
      center_pt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center_pt, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.center_pt_ = center_pt;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Circle.center_pt)
}

// double radius = 2;
inline void Circle::clear_radius() {
  _impl_.radius_ = 0;
}
inline double Circle::_internal_radius() const {
  return _impl_.radius_;
}
inline double Circle::radius() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Circle.radius)
  return _internal_radius();
}
inline void Circle::_internal_set_radius(double value) {
  
  _impl_.radius_ = value;
}
inline void Circle::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Circle.radius)
}

// -------------------------------------------------------------------

// Area

// .bosdyn.api.Polygon polygon = 1;
inline bool Area::_internal_has_polygon() const {
  return geometry_case() == kPolygon;
}
inline bool Area::has_polygon() const {
  return _internal_has_polygon();
}
inline void Area::set_has_polygon() {
  _impl_._oneof_case_[0] = kPolygon;
}
inline void Area::clear_polygon() {
  if (_internal_has_polygon()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.geometry_.polygon_;
    }
    clear_has_geometry();
  }
}
inline ::bosdyn::api::Polygon* Area::release_polygon() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Area.polygon)
  if (_internal_has_polygon()) {
    clear_has_geometry();
    ::bosdyn::api::Polygon* temp = _impl_.geometry_.polygon_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geometry_.polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::Polygon& Area::_internal_polygon() const {
  return _internal_has_polygon()
      ? *_impl_.geometry_.polygon_
      : reinterpret_cast< ::bosdyn::api::Polygon&>(::bosdyn::api::_Polygon_default_instance_);
}
inline const ::bosdyn::api::Polygon& Area::polygon() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Area.polygon)
  return _internal_polygon();
}
inline ::bosdyn::api::Polygon* Area::unsafe_arena_release_polygon() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.Area.polygon)
  if (_internal_has_polygon()) {
    clear_has_geometry();
    ::bosdyn::api::Polygon* temp = _impl_.geometry_.polygon_;
    _impl_.geometry_.polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Area::unsafe_arena_set_allocated_polygon(::bosdyn::api::Polygon* polygon) {
  clear_geometry();
  if (polygon) {
    set_has_polygon();
    _impl_.geometry_.polygon_ = polygon;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Area.polygon)
}
inline ::bosdyn::api::Polygon* Area::_internal_mutable_polygon() {
  if (!_internal_has_polygon()) {
    clear_geometry();
    set_has_polygon();
    _impl_.geometry_.polygon_ = CreateMaybeMessage< ::bosdyn::api::Polygon >(GetArenaForAllocation());
  }
  return _impl_.geometry_.polygon_;
}
inline ::bosdyn::api::Polygon* Area::mutable_polygon() {
  ::bosdyn::api::Polygon* _msg = _internal_mutable_polygon();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Area.polygon)
  return _msg;
}

// .bosdyn.api.Circle circle = 2;
inline bool Area::_internal_has_circle() const {
  return geometry_case() == kCircle;
}
inline bool Area::has_circle() const {
  return _internal_has_circle();
}
inline void Area::set_has_circle() {
  _impl_._oneof_case_[0] = kCircle;
}
inline void Area::clear_circle() {
  if (_internal_has_circle()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.geometry_.circle_;
    }
    clear_has_geometry();
  }
}
inline ::bosdyn::api::Circle* Area::release_circle() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Area.circle)
  if (_internal_has_circle()) {
    clear_has_geometry();
    ::bosdyn::api::Circle* temp = _impl_.geometry_.circle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geometry_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::Circle& Area::_internal_circle() const {
  return _internal_has_circle()
      ? *_impl_.geometry_.circle_
      : reinterpret_cast< ::bosdyn::api::Circle&>(::bosdyn::api::_Circle_default_instance_);
}
inline const ::bosdyn::api::Circle& Area::circle() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Area.circle)
  return _internal_circle();
}
inline ::bosdyn::api::Circle* Area::unsafe_arena_release_circle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.Area.circle)
  if (_internal_has_circle()) {
    clear_has_geometry();
    ::bosdyn::api::Circle* temp = _impl_.geometry_.circle_;
    _impl_.geometry_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Area::unsafe_arena_set_allocated_circle(::bosdyn::api::Circle* circle) {
  clear_geometry();
  if (circle) {
    set_has_circle();
    _impl_.geometry_.circle_ = circle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Area.circle)
}
inline ::bosdyn::api::Circle* Area::_internal_mutable_circle() {
  if (!_internal_has_circle()) {
    clear_geometry();
    set_has_circle();
    _impl_.geometry_.circle_ = CreateMaybeMessage< ::bosdyn::api::Circle >(GetArenaForAllocation());
  }
  return _impl_.geometry_.circle_;
}
inline ::bosdyn::api::Circle* Area::mutable_circle() {
  ::bosdyn::api::Circle* _msg = _internal_mutable_circle();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Area.circle)
  return _msg;
}

inline bool Area::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void Area::clear_has_geometry() {
  _impl_._oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline Area::GeometryCase Area::geometry_case() const {
  return Area::GeometryCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Volume

// .bosdyn.api.Vec3 box = 1;
inline bool Volume::_internal_has_box() const {
  return geometry_case() == kBox;
}
inline bool Volume::has_box() const {
  return _internal_has_box();
}
inline void Volume::set_has_box() {
  _impl_._oneof_case_[0] = kBox;
}
inline void Volume::clear_box() {
  if (_internal_has_box()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.geometry_.box_;
    }
    clear_has_geometry();
  }
}
inline ::bosdyn::api::Vec3* Volume::release_box() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Volume.box)
  if (_internal_has_box()) {
    clear_has_geometry();
    ::bosdyn::api::Vec3* temp = _impl_.geometry_.box_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geometry_.box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::Vec3& Volume::_internal_box() const {
  return _internal_has_box()
      ? *_impl_.geometry_.box_
      : reinterpret_cast< ::bosdyn::api::Vec3&>(::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& Volume::box() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Volume.box)
  return _internal_box();
}
inline ::bosdyn::api::Vec3* Volume::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.Volume.box)
  if (_internal_has_box()) {
    clear_has_geometry();
    ::bosdyn::api::Vec3* temp = _impl_.geometry_.box_;
    _impl_.geometry_.box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Volume::unsafe_arena_set_allocated_box(::bosdyn::api::Vec3* box) {
  clear_geometry();
  if (box) {
    set_has_box();
    _impl_.geometry_.box_ = box;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Volume.box)
}
inline ::bosdyn::api::Vec3* Volume::_internal_mutable_box() {
  if (!_internal_has_box()) {
    clear_geometry();
    set_has_box();
    _impl_.geometry_.box_ = CreateMaybeMessage< ::bosdyn::api::Vec3 >(GetArenaForAllocation());
  }
  return _impl_.geometry_.box_;
}
inline ::bosdyn::api::Vec3* Volume::mutable_box() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_box();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Volume.box)
  return _msg;
}

inline bool Volume::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void Volume::clear_has_geometry() {
  _impl_._oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline Volume::GeometryCase Volume::geometry_case() const {
  return Volume::GeometryCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Bounds

// double lower = 1;
inline void Bounds::clear_lower() {
  _impl_.lower_ = 0;
}
inline double Bounds::_internal_lower() const {
  return _impl_.lower_;
}
inline double Bounds::lower() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Bounds.lower)
  return _internal_lower();
}
inline void Bounds::_internal_set_lower(double value) {
  
  _impl_.lower_ = value;
}
inline void Bounds::set_lower(double value) {
  _internal_set_lower(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Bounds.lower)
}

// double upper = 2;
inline void Bounds::clear_upper() {
  _impl_.upper_ = 0;
}
inline double Bounds::_internal_upper() const {
  return _impl_.upper_;
}
inline double Bounds::upper() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Bounds.upper)
  return _internal_upper();
}
inline void Bounds::_internal_set_upper(double value) {
  
  _impl_.upper_ = value;
}
inline void Bounds::set_upper(double value) {
  _internal_set_upper(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Bounds.upper)
}

// -------------------------------------------------------------------

// Vec2Value

// .google.protobuf.DoubleValue x = 1;
inline bool Vec2Value::_internal_has_x() const {
  return this != internal_default_instance() && _impl_.x_ != nullptr;
}
inline bool Vec2Value::has_x() const {
  return _internal_has_x();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& Vec2Value::_internal_x() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.x_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& Vec2Value::x() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec2Value.x)
  return _internal_x();
}
inline void Vec2Value::unsafe_arena_set_allocated_x(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* x) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.x_);
  }
  _impl_.x_ = x;
  if (x) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Vec2Value.x)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::release_x() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.x_;
  _impl_.x_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::unsafe_arena_release_x() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Vec2Value.x)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.x_;
  _impl_.x_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::_internal_mutable_x() {
  
  if (_impl_.x_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.x_ = p;
  }
  return _impl_.x_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::mutable_x() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Vec2Value.x)
  return _msg;
}
inline void Vec2Value::set_allocated_x(::PROTOBUF_NAMESPACE_ID::DoubleValue* x) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.x_);
  }
  if (x) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(x));
    if (message_arena != submessage_arena) {
      x = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.x_ = x;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Vec2Value.x)
}

// .google.protobuf.DoubleValue y = 2;
inline bool Vec2Value::_internal_has_y() const {
  return this != internal_default_instance() && _impl_.y_ != nullptr;
}
inline bool Vec2Value::has_y() const {
  return _internal_has_y();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& Vec2Value::_internal_y() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.y_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& Vec2Value::y() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec2Value.y)
  return _internal_y();
}
inline void Vec2Value::unsafe_arena_set_allocated_y(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* y) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.y_);
  }
  _impl_.y_ = y;
  if (y) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Vec2Value.y)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::release_y() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.y_;
  _impl_.y_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Vec2Value.y)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.y_;
  _impl_.y_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::_internal_mutable_y() {
  
  if (_impl_.y_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.y_ = p;
  }
  return _impl_.y_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::mutable_y() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Vec2Value.y)
  return _msg;
}
inline void Vec2Value::set_allocated_y(::PROTOBUF_NAMESPACE_ID::DoubleValue* y) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.y_);
  }
  if (y) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y));
    if (message_arena != submessage_arena) {
      y = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.y_ = y;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Vec2Value.y)
}

// -------------------------------------------------------------------

// Vec3Value

// .google.protobuf.DoubleValue x = 1;
inline bool Vec3Value::_internal_has_x() const {
  return this != internal_default_instance() && _impl_.x_ != nullptr;
}
inline bool Vec3Value::has_x() const {
  return _internal_has_x();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::_internal_x() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.x_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::x() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec3Value.x)
  return _internal_x();
}
inline void Vec3Value::unsafe_arena_set_allocated_x(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* x) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.x_);
  }
  _impl_.x_ = x;
  if (x) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Vec3Value.x)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::release_x() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.x_;
  _impl_.x_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::unsafe_arena_release_x() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Vec3Value.x)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.x_;
  _impl_.x_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::_internal_mutable_x() {
  
  if (_impl_.x_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.x_ = p;
  }
  return _impl_.x_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::mutable_x() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Vec3Value.x)
  return _msg;
}
inline void Vec3Value::set_allocated_x(::PROTOBUF_NAMESPACE_ID::DoubleValue* x) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.x_);
  }
  if (x) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(x));
    if (message_arena != submessage_arena) {
      x = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.x_ = x;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Vec3Value.x)
}

// .google.protobuf.DoubleValue y = 2;
inline bool Vec3Value::_internal_has_y() const {
  return this != internal_default_instance() && _impl_.y_ != nullptr;
}
inline bool Vec3Value::has_y() const {
  return _internal_has_y();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::_internal_y() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.y_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::y() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec3Value.y)
  return _internal_y();
}
inline void Vec3Value::unsafe_arena_set_allocated_y(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* y) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.y_);
  }
  _impl_.y_ = y;
  if (y) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Vec3Value.y)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::release_y() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.y_;
  _impl_.y_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Vec3Value.y)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.y_;
  _impl_.y_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::_internal_mutable_y() {
  
  if (_impl_.y_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.y_ = p;
  }
  return _impl_.y_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::mutable_y() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Vec3Value.y)
  return _msg;
}
inline void Vec3Value::set_allocated_y(::PROTOBUF_NAMESPACE_ID::DoubleValue* y) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.y_);
  }
  if (y) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y));
    if (message_arena != submessage_arena) {
      y = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.y_ = y;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Vec3Value.y)
}

// .google.protobuf.DoubleValue z = 3;
inline bool Vec3Value::_internal_has_z() const {
  return this != internal_default_instance() && _impl_.z_ != nullptr;
}
inline bool Vec3Value::has_z() const {
  return _internal_has_z();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::_internal_z() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.z_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::z() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec3Value.z)
  return _internal_z();
}
inline void Vec3Value::unsafe_arena_set_allocated_z(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* z) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.z_);
  }
  _impl_.z_ = z;
  if (z) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Vec3Value.z)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::release_z() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.z_;
  _impl_.z_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::unsafe_arena_release_z() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Vec3Value.z)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.z_;
  _impl_.z_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::_internal_mutable_z() {
  
  if (_impl_.z_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.z_ = p;
  }
  return _impl_.z_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::mutable_z() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Vec3Value.z)
  return _msg;
}
inline void Vec3Value::set_allocated_z(::PROTOBUF_NAMESPACE_ID::DoubleValue* z) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.z_);
  }
  if (z) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(z));
    if (message_arena != submessage_arena) {
      z = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, z, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.z_ = z;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Vec3Value.z)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fgeometry_2eproto
