// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/graph_nav/graph_nav.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/basic_command.pb.h"
#include "bosdyn/api/data_chunk.pb.h"
#include "bosdyn/api/geometry.pb.h"
#include "bosdyn/api/graph_nav/nav.pb.h"
#include "bosdyn/api/graph_nav/map.pb.h"
#include "bosdyn/api/graph_nav/area_callback.pb.h"
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/lease.pb.h"
#include "bosdyn/api/license.pb.h"
#include "bosdyn/api/robot_state.pb.h"
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
namespace bosdyn {
namespace api {
namespace graph_nav {
class AreaCallbackServiceError;
struct AreaCallbackServiceErrorDefaultTypeInternal;
extern AreaCallbackServiceErrorDefaultTypeInternal _AreaCallbackServiceError_default_instance_;
class ClearGraphRequest;
struct ClearGraphRequestDefaultTypeInternal;
extern ClearGraphRequestDefaultTypeInternal _ClearGraphRequest_default_instance_;
class ClearGraphResponse;
struct ClearGraphResponseDefaultTypeInternal;
extern ClearGraphResponseDefaultTypeInternal _ClearGraphResponse_default_instance_;
class DownloadEdgeSnapshotRequest;
struct DownloadEdgeSnapshotRequestDefaultTypeInternal;
extern DownloadEdgeSnapshotRequestDefaultTypeInternal _DownloadEdgeSnapshotRequest_default_instance_;
class DownloadEdgeSnapshotResponse;
struct DownloadEdgeSnapshotResponseDefaultTypeInternal;
extern DownloadEdgeSnapshotResponseDefaultTypeInternal _DownloadEdgeSnapshotResponse_default_instance_;
class DownloadGraphRequest;
struct DownloadGraphRequestDefaultTypeInternal;
extern DownloadGraphRequestDefaultTypeInternal _DownloadGraphRequest_default_instance_;
class DownloadGraphResponse;
struct DownloadGraphResponseDefaultTypeInternal;
extern DownloadGraphResponseDefaultTypeInternal _DownloadGraphResponse_default_instance_;
class DownloadWaypointSnapshotRequest;
struct DownloadWaypointSnapshotRequestDefaultTypeInternal;
extern DownloadWaypointSnapshotRequestDefaultTypeInternal _DownloadWaypointSnapshotRequest_default_instance_;
class DownloadWaypointSnapshotResponse;
struct DownloadWaypointSnapshotResponseDefaultTypeInternal;
extern DownloadWaypointSnapshotResponseDefaultTypeInternal _DownloadWaypointSnapshotResponse_default_instance_;
class GetLocalizationStateRequest;
struct GetLocalizationStateRequestDefaultTypeInternal;
extern GetLocalizationStateRequestDefaultTypeInternal _GetLocalizationStateRequest_default_instance_;
class GetLocalizationStateResponse;
struct GetLocalizationStateResponseDefaultTypeInternal;
extern GetLocalizationStateResponseDefaultTypeInternal _GetLocalizationStateResponse_default_instance_;
class LostDetectorState;
struct LostDetectorStateDefaultTypeInternal;
extern LostDetectorStateDefaultTypeInternal _LostDetectorState_default_instance_;
class NavigateRouteRequest;
struct NavigateRouteRequestDefaultTypeInternal;
extern NavigateRouteRequestDefaultTypeInternal _NavigateRouteRequest_default_instance_;
class NavigateRouteResponse;
struct NavigateRouteResponseDefaultTypeInternal;
extern NavigateRouteResponseDefaultTypeInternal _NavigateRouteResponse_default_instance_;
class NavigateToAnchorRequest;
struct NavigateToAnchorRequestDefaultTypeInternal;
extern NavigateToAnchorRequestDefaultTypeInternal _NavigateToAnchorRequest_default_instance_;
class NavigateToAnchorResponse;
struct NavigateToAnchorResponseDefaultTypeInternal;
extern NavigateToAnchorResponseDefaultTypeInternal _NavigateToAnchorResponse_default_instance_;
class NavigateToRequest;
struct NavigateToRequestDefaultTypeInternal;
extern NavigateToRequestDefaultTypeInternal _NavigateToRequest_default_instance_;
class NavigateToResponse;
struct NavigateToResponseDefaultTypeInternal;
extern NavigateToResponseDefaultTypeInternal _NavigateToResponse_default_instance_;
class NavigationFeedbackRequest;
struct NavigationFeedbackRequestDefaultTypeInternal;
extern NavigationFeedbackRequestDefaultTypeInternal _NavigationFeedbackRequest_default_instance_;
class NavigationFeedbackResponse;
struct NavigationFeedbackResponseDefaultTypeInternal;
extern NavigationFeedbackResponseDefaultTypeInternal _NavigationFeedbackResponse_default_instance_;
class NavigationFeedbackResponse_ActiveRegionInformation;
struct NavigationFeedbackResponse_ActiveRegionInformationDefaultTypeInternal;
extern NavigationFeedbackResponse_ActiveRegionInformationDefaultTypeInternal _NavigationFeedbackResponse_ActiveRegionInformation_default_instance_;
class NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUse;
struct NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUseDefaultTypeInternal;
extern NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUseDefaultTypeInternal _NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUse_default_instance_;
class NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUse;
struct NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUseDefaultTypeInternal;
extern NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUseDefaultTypeInternal _NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUse_default_instance_;
class RemotePointCloudStatus;
struct RemotePointCloudStatusDefaultTypeInternal;
extern RemotePointCloudStatusDefaultTypeInternal _RemotePointCloudStatus_default_instance_;
class RouteFollowingParams;
struct RouteFollowingParamsDefaultTypeInternal;
extern RouteFollowingParamsDefaultTypeInternal _RouteFollowingParams_default_instance_;
class RouteGenParams;
struct RouteGenParamsDefaultTypeInternal;
extern RouteGenParamsDefaultTypeInternal _RouteGenParams_default_instance_;
class SensorCompatibilityStatus;
struct SensorCompatibilityStatusDefaultTypeInternal;
extern SensorCompatibilityStatusDefaultTypeInternal _SensorCompatibilityStatus_default_instance_;
class SetLocalizationRequest;
struct SetLocalizationRequestDefaultTypeInternal;
extern SetLocalizationRequestDefaultTypeInternal _SetLocalizationRequest_default_instance_;
class SetLocalizationResponse;
struct SetLocalizationResponseDefaultTypeInternal;
extern SetLocalizationResponseDefaultTypeInternal _SetLocalizationResponse_default_instance_;
class SetLocalizationResponse_SuspectedAmbiguity;
struct SetLocalizationResponse_SuspectedAmbiguityDefaultTypeInternal;
extern SetLocalizationResponse_SuspectedAmbiguityDefaultTypeInternal _SetLocalizationResponse_SuspectedAmbiguity_default_instance_;
class TravelParams;
struct TravelParamsDefaultTypeInternal;
extern TravelParamsDefaultTypeInternal _TravelParams_default_instance_;
class UploadEdgeSnapshotRequest;
struct UploadEdgeSnapshotRequestDefaultTypeInternal;
extern UploadEdgeSnapshotRequestDefaultTypeInternal _UploadEdgeSnapshotRequest_default_instance_;
class UploadEdgeSnapshotResponse;
struct UploadEdgeSnapshotResponseDefaultTypeInternal;
extern UploadEdgeSnapshotResponseDefaultTypeInternal _UploadEdgeSnapshotResponse_default_instance_;
class UploadGraphRequest;
struct UploadGraphRequestDefaultTypeInternal;
extern UploadGraphRequestDefaultTypeInternal _UploadGraphRequest_default_instance_;
class UploadGraphResponse;
struct UploadGraphResponseDefaultTypeInternal;
extern UploadGraphResponseDefaultTypeInternal _UploadGraphResponse_default_instance_;
class UploadWaypointSnapshotRequest;
struct UploadWaypointSnapshotRequestDefaultTypeInternal;
extern UploadWaypointSnapshotRequestDefaultTypeInternal _UploadWaypointSnapshotRequest_default_instance_;
class UploadWaypointSnapshotResponse;
struct UploadWaypointSnapshotResponseDefaultTypeInternal;
extern UploadWaypointSnapshotResponseDefaultTypeInternal _UploadWaypointSnapshotResponse_default_instance_;
class ValidateGraphRequest;
struct ValidateGraphRequestDefaultTypeInternal;
extern ValidateGraphRequestDefaultTypeInternal _ValidateGraphRequest_default_instance_;
class ValidateGraphResponse;
struct ValidateGraphResponseDefaultTypeInternal;
extern ValidateGraphResponseDefaultTypeInternal _ValidateGraphResponse_default_instance_;
class VisualRefinementOptions;
struct VisualRefinementOptionsDefaultTypeInternal;
extern VisualRefinementOptionsDefaultTypeInternal _VisualRefinementOptions_default_instance_;
}  // namespace graph_nav
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::graph_nav::AreaCallbackServiceError* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::AreaCallbackServiceError>(Arena*);
template<> ::bosdyn::api::graph_nav::ClearGraphRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::ClearGraphRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::ClearGraphResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::ClearGraphResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::DownloadEdgeSnapshotRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::DownloadEdgeSnapshotRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::DownloadEdgeSnapshotResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::DownloadEdgeSnapshotResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::DownloadGraphRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::DownloadGraphRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::DownloadGraphResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::DownloadGraphResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::DownloadWaypointSnapshotRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::DownloadWaypointSnapshotRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::DownloadWaypointSnapshotResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::DownloadWaypointSnapshotResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::GetLocalizationStateRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::GetLocalizationStateRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::GetLocalizationStateResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::GetLocalizationStateResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::LostDetectorState* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::LostDetectorState>(Arena*);
template<> ::bosdyn::api::graph_nav::NavigateRouteRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::NavigateRouteRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::NavigateRouteResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::NavigateRouteResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::NavigateToAnchorRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::NavigateToAnchorRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::NavigateToAnchorResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::NavigateToAnchorResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::NavigateToRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::NavigateToRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::NavigateToResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::NavigateToResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::NavigationFeedbackRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::NavigationFeedbackRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::NavigationFeedbackResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::NavigationFeedbackResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation>(Arena*);
template<> ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::graph_nav::NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::graph_nav::RemotePointCloudStatus* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::RemotePointCloudStatus>(Arena*);
template<> ::bosdyn::api::graph_nav::RouteFollowingParams* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::RouteFollowingParams>(Arena*);
template<> ::bosdyn::api::graph_nav::RouteGenParams* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::RouteGenParams>(Arena*);
template<> ::bosdyn::api::graph_nav::SensorCompatibilityStatus* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::SensorCompatibilityStatus>(Arena*);
template<> ::bosdyn::api::graph_nav::SetLocalizationRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::SetLocalizationRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::SetLocalizationResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::SetLocalizationResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity>(Arena*);
template<> ::bosdyn::api::graph_nav::TravelParams* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::TravelParams>(Arena*);
template<> ::bosdyn::api::graph_nav::UploadEdgeSnapshotRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::UploadEdgeSnapshotRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::UploadEdgeSnapshotResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::UploadEdgeSnapshotResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::UploadGraphRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::UploadGraphRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::UploadGraphResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::UploadGraphResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::UploadWaypointSnapshotRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::UploadWaypointSnapshotRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::UploadWaypointSnapshotResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::UploadWaypointSnapshotResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::ValidateGraphRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::ValidateGraphRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::ValidateGraphResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::ValidateGraphResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::VisualRefinementOptions* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::VisualRefinementOptions>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {
namespace graph_nav {

enum SetLocalizationRequest_FiducialInit : int {
  SetLocalizationRequest_FiducialInit_FIDUCIAL_INIT_UNKNOWN = 0,
  SetLocalizationRequest_FiducialInit_FIDUCIAL_INIT_NO_FIDUCIAL = 1,
  SetLocalizationRequest_FiducialInit_FIDUCIAL_INIT_NEAREST = 2,
  SetLocalizationRequest_FiducialInit_FIDUCIAL_INIT_NEAREST_AT_TARGET = 3,
  SetLocalizationRequest_FiducialInit_FIDUCIAL_INIT_SPECIFIC = 4,
  SetLocalizationRequest_FiducialInit_SetLocalizationRequest_FiducialInit_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SetLocalizationRequest_FiducialInit_SetLocalizationRequest_FiducialInit_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SetLocalizationRequest_FiducialInit_IsValid(int value);
constexpr SetLocalizationRequest_FiducialInit SetLocalizationRequest_FiducialInit_FiducialInit_MIN = SetLocalizationRequest_FiducialInit_FIDUCIAL_INIT_UNKNOWN;
constexpr SetLocalizationRequest_FiducialInit SetLocalizationRequest_FiducialInit_FiducialInit_MAX = SetLocalizationRequest_FiducialInit_FIDUCIAL_INIT_SPECIFIC;
constexpr int SetLocalizationRequest_FiducialInit_FiducialInit_ARRAYSIZE = SetLocalizationRequest_FiducialInit_FiducialInit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SetLocalizationRequest_FiducialInit_descriptor();
template<typename T>
inline const std::string& SetLocalizationRequest_FiducialInit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SetLocalizationRequest_FiducialInit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SetLocalizationRequest_FiducialInit_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SetLocalizationRequest_FiducialInit_descriptor(), enum_t_value);
}
inline bool SetLocalizationRequest_FiducialInit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SetLocalizationRequest_FiducialInit* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SetLocalizationRequest_FiducialInit>(
    SetLocalizationRequest_FiducialInit_descriptor(), name, value);
}
enum SetLocalizationResponse_Status : int {
  SetLocalizationResponse_Status_STATUS_UNKNOWN = 0,
  SetLocalizationResponse_Status_STATUS_OK = 1,
  SetLocalizationResponse_Status_STATUS_ROBOT_IMPAIRED = 2,
  SetLocalizationResponse_Status_STATUS_UNKNOWN_WAYPOINT = 3,
  SetLocalizationResponse_Status_STATUS_ABORTED = 4,
  SetLocalizationResponse_Status_STATUS_FAILED = 5,
  SetLocalizationResponse_Status_STATUS_FIDUCIAL_TOO_FAR_AWAY = 6,
  SetLocalizationResponse_Status_STATUS_FIDUCIAL_TOO_OLD = 7,
  SetLocalizationResponse_Status_STATUS_NO_MATCHING_FIDUCIAL = 8,
  SetLocalizationResponse_Status_STATUS_FIDUCIAL_POSE_UNCERTAIN = 9,
  SetLocalizationResponse_Status_STATUS_INCOMPATIBLE_SENSORS = 10,
  SetLocalizationResponse_Status_STATUS_VISUAL_ALIGNMENT_FAILED = 11,
  SetLocalizationResponse_Status_SetLocalizationResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SetLocalizationResponse_Status_SetLocalizationResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SetLocalizationResponse_Status_IsValid(int value);
constexpr SetLocalizationResponse_Status SetLocalizationResponse_Status_Status_MIN = SetLocalizationResponse_Status_STATUS_UNKNOWN;
constexpr SetLocalizationResponse_Status SetLocalizationResponse_Status_Status_MAX = SetLocalizationResponse_Status_STATUS_VISUAL_ALIGNMENT_FAILED;
constexpr int SetLocalizationResponse_Status_Status_ARRAYSIZE = SetLocalizationResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SetLocalizationResponse_Status_descriptor();
template<typename T>
inline const std::string& SetLocalizationResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SetLocalizationResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SetLocalizationResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SetLocalizationResponse_Status_descriptor(), enum_t_value);
}
inline bool SetLocalizationResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SetLocalizationResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SetLocalizationResponse_Status>(
    SetLocalizationResponse_Status_descriptor(), name, value);
}
enum TravelParams_FeatureQualityTolerance : int {
  TravelParams_FeatureQualityTolerance_TOLERANCE_UNKNOWN = 0,
  TravelParams_FeatureQualityTolerance_TOLERANCE_DEFAULT = 1,
  TravelParams_FeatureQualityTolerance_TOLERANCE_IGNORE_POOR_FEATURE_QUALITY = 2,
  TravelParams_FeatureQualityTolerance_TravelParams_FeatureQualityTolerance_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TravelParams_FeatureQualityTolerance_TravelParams_FeatureQualityTolerance_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TravelParams_FeatureQualityTolerance_IsValid(int value);
constexpr TravelParams_FeatureQualityTolerance TravelParams_FeatureQualityTolerance_FeatureQualityTolerance_MIN = TravelParams_FeatureQualityTolerance_TOLERANCE_UNKNOWN;
constexpr TravelParams_FeatureQualityTolerance TravelParams_FeatureQualityTolerance_FeatureQualityTolerance_MAX = TravelParams_FeatureQualityTolerance_TOLERANCE_IGNORE_POOR_FEATURE_QUALITY;
constexpr int TravelParams_FeatureQualityTolerance_FeatureQualityTolerance_ARRAYSIZE = TravelParams_FeatureQualityTolerance_FeatureQualityTolerance_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TravelParams_FeatureQualityTolerance_descriptor();
template<typename T>
inline const std::string& TravelParams_FeatureQualityTolerance_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TravelParams_FeatureQualityTolerance>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TravelParams_FeatureQualityTolerance_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TravelParams_FeatureQualityTolerance_descriptor(), enum_t_value);
}
inline bool TravelParams_FeatureQualityTolerance_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TravelParams_FeatureQualityTolerance* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TravelParams_FeatureQualityTolerance>(
    TravelParams_FeatureQualityTolerance_descriptor(), name, value);
}
enum NavigateToResponse_Status : int {
  NavigateToResponse_Status_STATUS_UNKNOWN = 0,
  NavigateToResponse_Status_STATUS_OK = 1,
  NavigateToResponse_Status_STATUS_NO_TIMESYNC = 2,
  NavigateToResponse_Status_STATUS_EXPIRED = 3,
  NavigateToResponse_Status_STATUS_TOO_DISTANT = 4,
  NavigateToResponse_Status_STATUS_ROBOT_IMPAIRED = 5,
  NavigateToResponse_Status_STATUS_RECORDING = 6,
  NavigateToResponse_Status_STATUS_UNKNOWN_WAYPOINT = 7,
  NavigateToResponse_Status_STATUS_NO_PATH = 8,
  NavigateToResponse_Status_STATUS_FEATURE_DESERT = 10,
  NavigateToResponse_Status_STATUS_LOST = 11,
  NavigateToResponse_Status_STATUS_NOT_LOCALIZED_TO_MAP = 13,
  NavigateToResponse_Status_STATUS_COULD_NOT_UPDATE_ROUTE = 12,
  NavigateToResponse_Status_STATUS_STUCK = 14,
  NavigateToResponse_Status_STATUS_UNRECOGNIZED_COMMAND = 15,
  NavigateToResponse_Status_STATUS_AREA_CALLBACK_ERROR = 16,
  NavigateToResponse_Status_NavigateToResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NavigateToResponse_Status_NavigateToResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NavigateToResponse_Status_IsValid(int value);
constexpr NavigateToResponse_Status NavigateToResponse_Status_Status_MIN = NavigateToResponse_Status_STATUS_UNKNOWN;
constexpr NavigateToResponse_Status NavigateToResponse_Status_Status_MAX = NavigateToResponse_Status_STATUS_AREA_CALLBACK_ERROR;
constexpr int NavigateToResponse_Status_Status_ARRAYSIZE = NavigateToResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NavigateToResponse_Status_descriptor();
template<typename T>
inline const std::string& NavigateToResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NavigateToResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NavigateToResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NavigateToResponse_Status_descriptor(), enum_t_value);
}
inline bool NavigateToResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NavigateToResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NavigateToResponse_Status>(
    NavigateToResponse_Status_descriptor(), name, value);
}
enum RouteFollowingParams_StartRouteBehavior : int {
  RouteFollowingParams_StartRouteBehavior_START_UNKNOWN = 0,
  RouteFollowingParams_StartRouteBehavior_START_GOTO_START = 1,
  RouteFollowingParams_StartRouteBehavior_START_GOTO_ROUTE = 2,
  RouteFollowingParams_StartRouteBehavior_START_FAIL_WHEN_NOT_ON_ROUTE = 3,
  RouteFollowingParams_StartRouteBehavior_RouteFollowingParams_StartRouteBehavior_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RouteFollowingParams_StartRouteBehavior_RouteFollowingParams_StartRouteBehavior_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RouteFollowingParams_StartRouteBehavior_IsValid(int value);
constexpr RouteFollowingParams_StartRouteBehavior RouteFollowingParams_StartRouteBehavior_StartRouteBehavior_MIN = RouteFollowingParams_StartRouteBehavior_START_UNKNOWN;
constexpr RouteFollowingParams_StartRouteBehavior RouteFollowingParams_StartRouteBehavior_StartRouteBehavior_MAX = RouteFollowingParams_StartRouteBehavior_START_FAIL_WHEN_NOT_ON_ROUTE;
constexpr int RouteFollowingParams_StartRouteBehavior_StartRouteBehavior_ARRAYSIZE = RouteFollowingParams_StartRouteBehavior_StartRouteBehavior_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RouteFollowingParams_StartRouteBehavior_descriptor();
template<typename T>
inline const std::string& RouteFollowingParams_StartRouteBehavior_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RouteFollowingParams_StartRouteBehavior>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RouteFollowingParams_StartRouteBehavior_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RouteFollowingParams_StartRouteBehavior_descriptor(), enum_t_value);
}
inline bool RouteFollowingParams_StartRouteBehavior_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RouteFollowingParams_StartRouteBehavior* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RouteFollowingParams_StartRouteBehavior>(
    RouteFollowingParams_StartRouteBehavior_descriptor(), name, value);
}
enum RouteFollowingParams_ResumeBehavior : int {
  RouteFollowingParams_ResumeBehavior_RESUME_UNKNOWN = 0,
  RouteFollowingParams_ResumeBehavior_RESUME_RETURN_TO_UNFINISHED_ROUTE = 1,
  RouteFollowingParams_ResumeBehavior_RESUME_FAIL_WHEN_NOT_ON_ROUTE = 2,
  RouteFollowingParams_ResumeBehavior_RouteFollowingParams_ResumeBehavior_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RouteFollowingParams_ResumeBehavior_RouteFollowingParams_ResumeBehavior_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RouteFollowingParams_ResumeBehavior_IsValid(int value);
constexpr RouteFollowingParams_ResumeBehavior RouteFollowingParams_ResumeBehavior_ResumeBehavior_MIN = RouteFollowingParams_ResumeBehavior_RESUME_UNKNOWN;
constexpr RouteFollowingParams_ResumeBehavior RouteFollowingParams_ResumeBehavior_ResumeBehavior_MAX = RouteFollowingParams_ResumeBehavior_RESUME_FAIL_WHEN_NOT_ON_ROUTE;
constexpr int RouteFollowingParams_ResumeBehavior_ResumeBehavior_ARRAYSIZE = RouteFollowingParams_ResumeBehavior_ResumeBehavior_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RouteFollowingParams_ResumeBehavior_descriptor();
template<typename T>
inline const std::string& RouteFollowingParams_ResumeBehavior_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RouteFollowingParams_ResumeBehavior>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RouteFollowingParams_ResumeBehavior_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RouteFollowingParams_ResumeBehavior_descriptor(), enum_t_value);
}
inline bool RouteFollowingParams_ResumeBehavior_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RouteFollowingParams_ResumeBehavior* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RouteFollowingParams_ResumeBehavior>(
    RouteFollowingParams_ResumeBehavior_descriptor(), name, value);
}
enum RouteFollowingParams_RouteBlockedBehavior : int {
  RouteFollowingParams_RouteBlockedBehavior_ROUTE_BLOCKED_UNKNOWN = 0,
  RouteFollowingParams_RouteBlockedBehavior_ROUTE_BLOCKED_REROUTE = 1,
  RouteFollowingParams_RouteBlockedBehavior_ROUTE_BLOCKED_FAIL = 2,
  RouteFollowingParams_RouteBlockedBehavior_RouteFollowingParams_RouteBlockedBehavior_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RouteFollowingParams_RouteBlockedBehavior_RouteFollowingParams_RouteBlockedBehavior_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RouteFollowingParams_RouteBlockedBehavior_IsValid(int value);
constexpr RouteFollowingParams_RouteBlockedBehavior RouteFollowingParams_RouteBlockedBehavior_RouteBlockedBehavior_MIN = RouteFollowingParams_RouteBlockedBehavior_ROUTE_BLOCKED_UNKNOWN;
constexpr RouteFollowingParams_RouteBlockedBehavior RouteFollowingParams_RouteBlockedBehavior_RouteBlockedBehavior_MAX = RouteFollowingParams_RouteBlockedBehavior_ROUTE_BLOCKED_FAIL;
constexpr int RouteFollowingParams_RouteBlockedBehavior_RouteBlockedBehavior_ARRAYSIZE = RouteFollowingParams_RouteBlockedBehavior_RouteBlockedBehavior_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RouteFollowingParams_RouteBlockedBehavior_descriptor();
template<typename T>
inline const std::string& RouteFollowingParams_RouteBlockedBehavior_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RouteFollowingParams_RouteBlockedBehavior>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RouteFollowingParams_RouteBlockedBehavior_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RouteFollowingParams_RouteBlockedBehavior_descriptor(), enum_t_value);
}
inline bool RouteFollowingParams_RouteBlockedBehavior_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RouteFollowingParams_RouteBlockedBehavior* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RouteFollowingParams_RouteBlockedBehavior>(
    RouteFollowingParams_RouteBlockedBehavior_descriptor(), name, value);
}
enum NavigateRouteResponse_Status : int {
  NavigateRouteResponse_Status_STATUS_UNKNOWN = 0,
  NavigateRouteResponse_Status_STATUS_OK = 1,
  NavigateRouteResponse_Status_STATUS_NO_TIMESYNC = 2,
  NavigateRouteResponse_Status_STATUS_EXPIRED = 3,
  NavigateRouteResponse_Status_STATUS_TOO_DISTANT = 4,
  NavigateRouteResponse_Status_STATUS_ROBOT_IMPAIRED = 5,
  NavigateRouteResponse_Status_STATUS_RECORDING = 6,
  NavigateRouteResponse_Status_STATUS_UNKNOWN_ROUTE_ELEMENTS = 8,
  NavigateRouteResponse_Status_STATUS_INVALID_EDGE = 9,
  NavigateRouteResponse_Status_STATUS_NO_PATH = 20,
  NavigateRouteResponse_Status_STATUS_CONSTRAINT_FAULT = 11,
  NavigateRouteResponse_Status_STATUS_FEATURE_DESERT = 13,
  NavigateRouteResponse_Status_STATUS_LOST = 14,
  NavigateRouteResponse_Status_STATUS_NOT_LOCALIZED_TO_ROUTE = 16,
  NavigateRouteResponse_Status_STATUS_NOT_LOCALIZED_TO_MAP = 19,
  NavigateRouteResponse_Status_STATUS_COULD_NOT_UPDATE_ROUTE = 15,
  NavigateRouteResponse_Status_STATUS_STUCK = 17,
  NavigateRouteResponse_Status_STATUS_UNRECOGNIZED_COMMAND = 18,
  NavigateRouteResponse_Status_STATUS_AREA_CALLBACK_ERROR = 21,
  NavigateRouteResponse_Status_NavigateRouteResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NavigateRouteResponse_Status_NavigateRouteResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NavigateRouteResponse_Status_IsValid(int value);
constexpr NavigateRouteResponse_Status NavigateRouteResponse_Status_Status_MIN = NavigateRouteResponse_Status_STATUS_UNKNOWN;
constexpr NavigateRouteResponse_Status NavigateRouteResponse_Status_Status_MAX = NavigateRouteResponse_Status_STATUS_AREA_CALLBACK_ERROR;
constexpr int NavigateRouteResponse_Status_Status_ARRAYSIZE = NavigateRouteResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NavigateRouteResponse_Status_descriptor();
template<typename T>
inline const std::string& NavigateRouteResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NavigateRouteResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NavigateRouteResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NavigateRouteResponse_Status_descriptor(), enum_t_value);
}
inline bool NavigateRouteResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NavigateRouteResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NavigateRouteResponse_Status>(
    NavigateRouteResponse_Status_descriptor(), name, value);
}
enum NavigateToAnchorResponse_Status : int {
  NavigateToAnchorResponse_Status_STATUS_UNKNOWN = 0,
  NavigateToAnchorResponse_Status_STATUS_OK = 1,
  NavigateToAnchorResponse_Status_STATUS_NO_TIMESYNC = 2,
  NavigateToAnchorResponse_Status_STATUS_EXPIRED = 3,
  NavigateToAnchorResponse_Status_STATUS_TOO_DISTANT = 4,
  NavigateToAnchorResponse_Status_STATUS_ROBOT_IMPAIRED = 5,
  NavigateToAnchorResponse_Status_STATUS_RECORDING = 6,
  NavigateToAnchorResponse_Status_STATUS_NO_ANCHORING = 7,
  NavigateToAnchorResponse_Status_STATUS_NO_PATH = 8,
  NavigateToAnchorResponse_Status_STATUS_FEATURE_DESERT = 10,
  NavigateToAnchorResponse_Status_STATUS_LOST = 11,
  NavigateToAnchorResponse_Status_STATUS_NOT_LOCALIZED_TO_MAP = 13,
  NavigateToAnchorResponse_Status_STATUS_COULD_NOT_UPDATE_ROUTE = 12,
  NavigateToAnchorResponse_Status_STATUS_STUCK = 14,
  NavigateToAnchorResponse_Status_STATUS_UNRECOGNIZED_COMMAND = 15,
  NavigateToAnchorResponse_Status_STATUS_INVALID_POSE = 16,
  NavigateToAnchorResponse_Status_STATUS_AREA_CALLBACK_ERROR = 17,
  NavigateToAnchorResponse_Status_NavigateToAnchorResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NavigateToAnchorResponse_Status_NavigateToAnchorResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NavigateToAnchorResponse_Status_IsValid(int value);
constexpr NavigateToAnchorResponse_Status NavigateToAnchorResponse_Status_Status_MIN = NavigateToAnchorResponse_Status_STATUS_UNKNOWN;
constexpr NavigateToAnchorResponse_Status NavigateToAnchorResponse_Status_Status_MAX = NavigateToAnchorResponse_Status_STATUS_AREA_CALLBACK_ERROR;
constexpr int NavigateToAnchorResponse_Status_Status_ARRAYSIZE = NavigateToAnchorResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NavigateToAnchorResponse_Status_descriptor();
template<typename T>
inline const std::string& NavigateToAnchorResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NavigateToAnchorResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NavigateToAnchorResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NavigateToAnchorResponse_Status_descriptor(), enum_t_value);
}
inline bool NavigateToAnchorResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NavigateToAnchorResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NavigateToAnchorResponse_Status>(
    NavigateToAnchorResponse_Status_descriptor(), name, value);
}
enum NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus : int {
  NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_STATUS_UNKNOWN = 0,
  NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_STATUS_NAVIGATING = 1,
  NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_STATUS_WAITING = 2,
  NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_STATUS_CALLBACK_IN_CONTROL = 3,
  NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_IsValid(int value);
constexpr NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_AreaCallbackStatus_MIN = NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_STATUS_UNKNOWN;
constexpr NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_AreaCallbackStatus_MAX = NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_STATUS_CALLBACK_IN_CONTROL;
constexpr int NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_AreaCallbackStatus_ARRAYSIZE = NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_AreaCallbackStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_descriptor();
template<typename T>
inline const std::string& NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_descriptor(), enum_t_value);
}
inline bool NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus>(
    NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_descriptor(), name, value);
}
enum NavigationFeedbackResponse_Status : int {
  NavigationFeedbackResponse_Status_STATUS_UNKNOWN = 0,
  NavigationFeedbackResponse_Status_STATUS_FOLLOWING_ROUTE = 1,
  NavigationFeedbackResponse_Status_STATUS_REACHED_GOAL = 2,
  NavigationFeedbackResponse_Status_STATUS_NO_ROUTE = 3,
  NavigationFeedbackResponse_Status_STATUS_NO_LOCALIZATION = 4,
  NavigationFeedbackResponse_Status_STATUS_LOST = 5,
  NavigationFeedbackResponse_Status_STATUS_STUCK = 6,
  NavigationFeedbackResponse_Status_STATUS_COMMAND_TIMED_OUT = 7,
  NavigationFeedbackResponse_Status_STATUS_ROBOT_IMPAIRED = 8,
  NavigationFeedbackResponse_Status_STATUS_CONSTRAINT_FAULT = 11,
  NavigationFeedbackResponse_Status_STATUS_COMMAND_OVERRIDDEN = 12,
  NavigationFeedbackResponse_Status_STATUS_NOT_LOCALIZED_TO_ROUTE = 13,
  NavigationFeedbackResponse_Status_STATUS_LEASE_ERROR = 14,
  NavigationFeedbackResponse_Status_STATUS_AREA_CALLBACK_ERROR = 15,
  NavigationFeedbackResponse_Status_NavigationFeedbackResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NavigationFeedbackResponse_Status_NavigationFeedbackResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NavigationFeedbackResponse_Status_IsValid(int value);
constexpr NavigationFeedbackResponse_Status NavigationFeedbackResponse_Status_Status_MIN = NavigationFeedbackResponse_Status_STATUS_UNKNOWN;
constexpr NavigationFeedbackResponse_Status NavigationFeedbackResponse_Status_Status_MAX = NavigationFeedbackResponse_Status_STATUS_AREA_CALLBACK_ERROR;
constexpr int NavigationFeedbackResponse_Status_Status_ARRAYSIZE = NavigationFeedbackResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NavigationFeedbackResponse_Status_descriptor();
template<typename T>
inline const std::string& NavigationFeedbackResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NavigationFeedbackResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NavigationFeedbackResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NavigationFeedbackResponse_Status_descriptor(), enum_t_value);
}
inline bool NavigationFeedbackResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NavigationFeedbackResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NavigationFeedbackResponse_Status>(
    NavigationFeedbackResponse_Status_descriptor(), name, value);
}
enum NavigationFeedbackResponse_RouteFollowingStatus : int {
  NavigationFeedbackResponse_RouteFollowingStatus_ROUTE_FOLLOWING_STATUS_UNKNOWN = 0,
  NavigationFeedbackResponse_RouteFollowingStatus_ROUTE_FOLLOWING_STATUS_FOLLOWING_ROUTE = 1,
  NavigationFeedbackResponse_RouteFollowingStatus_ROUTE_FOLLOWING_STATUS_RETURNING_TO_ROUTE = 2,
  NavigationFeedbackResponse_RouteFollowingStatus_ROUTE_FOLLOWING_STATUS_FOLLOWING_ALTERNATE_ROUTE = 3,
  NavigationFeedbackResponse_RouteFollowingStatus_ROUTE_FOLLOWING_STATUS_EXPLORING = 4,
  NavigationFeedbackResponse_RouteFollowingStatus_NavigationFeedbackResponse_RouteFollowingStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NavigationFeedbackResponse_RouteFollowingStatus_NavigationFeedbackResponse_RouteFollowingStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NavigationFeedbackResponse_RouteFollowingStatus_IsValid(int value);
constexpr NavigationFeedbackResponse_RouteFollowingStatus NavigationFeedbackResponse_RouteFollowingStatus_RouteFollowingStatus_MIN = NavigationFeedbackResponse_RouteFollowingStatus_ROUTE_FOLLOWING_STATUS_UNKNOWN;
constexpr NavigationFeedbackResponse_RouteFollowingStatus NavigationFeedbackResponse_RouteFollowingStatus_RouteFollowingStatus_MAX = NavigationFeedbackResponse_RouteFollowingStatus_ROUTE_FOLLOWING_STATUS_EXPLORING;
constexpr int NavigationFeedbackResponse_RouteFollowingStatus_RouteFollowingStatus_ARRAYSIZE = NavigationFeedbackResponse_RouteFollowingStatus_RouteFollowingStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NavigationFeedbackResponse_RouteFollowingStatus_descriptor();
template<typename T>
inline const std::string& NavigationFeedbackResponse_RouteFollowingStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NavigationFeedbackResponse_RouteFollowingStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NavigationFeedbackResponse_RouteFollowingStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NavigationFeedbackResponse_RouteFollowingStatus_descriptor(), enum_t_value);
}
inline bool NavigationFeedbackResponse_RouteFollowingStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NavigationFeedbackResponse_RouteFollowingStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NavigationFeedbackResponse_RouteFollowingStatus>(
    NavigationFeedbackResponse_RouteFollowingStatus_descriptor(), name, value);
}
enum NavigationFeedbackResponse_BlockageStatus : int {
  NavigationFeedbackResponse_BlockageStatus_BLOCKAGE_STATUS_UNKNOWN = 0,
  NavigationFeedbackResponse_BlockageStatus_BLOCKAGE_STATUS_ROUTE_CLEAR = 1,
  NavigationFeedbackResponse_BlockageStatus_BLOCKAGE_STATUS_ROUTE_BLOCKED_TEMPORARILY = 2,
  NavigationFeedbackResponse_BlockageStatus_BLOCKAGE_STATUS_STUCK = 3,
  NavigationFeedbackResponse_BlockageStatus_NavigationFeedbackResponse_BlockageStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NavigationFeedbackResponse_BlockageStatus_NavigationFeedbackResponse_BlockageStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NavigationFeedbackResponse_BlockageStatus_IsValid(int value);
constexpr NavigationFeedbackResponse_BlockageStatus NavigationFeedbackResponse_BlockageStatus_BlockageStatus_MIN = NavigationFeedbackResponse_BlockageStatus_BLOCKAGE_STATUS_UNKNOWN;
constexpr NavigationFeedbackResponse_BlockageStatus NavigationFeedbackResponse_BlockageStatus_BlockageStatus_MAX = NavigationFeedbackResponse_BlockageStatus_BLOCKAGE_STATUS_STUCK;
constexpr int NavigationFeedbackResponse_BlockageStatus_BlockageStatus_ARRAYSIZE = NavigationFeedbackResponse_BlockageStatus_BlockageStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NavigationFeedbackResponse_BlockageStatus_descriptor();
template<typename T>
inline const std::string& NavigationFeedbackResponse_BlockageStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NavigationFeedbackResponse_BlockageStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NavigationFeedbackResponse_BlockageStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NavigationFeedbackResponse_BlockageStatus_descriptor(), enum_t_value);
}
inline bool NavigationFeedbackResponse_BlockageStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NavigationFeedbackResponse_BlockageStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NavigationFeedbackResponse_BlockageStatus>(
    NavigationFeedbackResponse_BlockageStatus_descriptor(), name, value);
}
enum ClearGraphResponse_Status : int {
  ClearGraphResponse_Status_STATUS_UNKNOWN = 0,
  ClearGraphResponse_Status_STATUS_OK = 1,
  ClearGraphResponse_Status_STATUS_RECORDING = 2,
  ClearGraphResponse_Status_ClearGraphResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ClearGraphResponse_Status_ClearGraphResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ClearGraphResponse_Status_IsValid(int value);
constexpr ClearGraphResponse_Status ClearGraphResponse_Status_Status_MIN = ClearGraphResponse_Status_STATUS_UNKNOWN;
constexpr ClearGraphResponse_Status ClearGraphResponse_Status_Status_MAX = ClearGraphResponse_Status_STATUS_RECORDING;
constexpr int ClearGraphResponse_Status_Status_ARRAYSIZE = ClearGraphResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClearGraphResponse_Status_descriptor();
template<typename T>
inline const std::string& ClearGraphResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClearGraphResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClearGraphResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClearGraphResponse_Status_descriptor(), enum_t_value);
}
inline bool ClearGraphResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClearGraphResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClearGraphResponse_Status>(
    ClearGraphResponse_Status_descriptor(), name, value);
}
enum UploadGraphResponse_Status : int {
  UploadGraphResponse_Status_STATUS_UNKNOWN = 0,
  UploadGraphResponse_Status_STATUS_OK = 1,
  UploadGraphResponse_Status_STATUS_MAP_TOO_LARGE_LICENSE = 3,
  UploadGraphResponse_Status_STATUS_INVALID_GRAPH = 4,
  UploadGraphResponse_Status_STATUS_INCOMPATIBLE_SENSORS = 5,
  UploadGraphResponse_Status_STATUS_AREA_CALLBACK_ERROR = 6,
  UploadGraphResponse_Status_UploadGraphResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UploadGraphResponse_Status_UploadGraphResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UploadGraphResponse_Status_IsValid(int value);
constexpr UploadGraphResponse_Status UploadGraphResponse_Status_Status_MIN = UploadGraphResponse_Status_STATUS_UNKNOWN;
constexpr UploadGraphResponse_Status UploadGraphResponse_Status_Status_MAX = UploadGraphResponse_Status_STATUS_AREA_CALLBACK_ERROR;
constexpr int UploadGraphResponse_Status_Status_ARRAYSIZE = UploadGraphResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UploadGraphResponse_Status_descriptor();
template<typename T>
inline const std::string& UploadGraphResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UploadGraphResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UploadGraphResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UploadGraphResponse_Status_descriptor(), enum_t_value);
}
inline bool UploadGraphResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UploadGraphResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UploadGraphResponse_Status>(
    UploadGraphResponse_Status_descriptor(), name, value);
}
enum UploadWaypointSnapshotResponse_Status : int {
  UploadWaypointSnapshotResponse_Status_STATUS_UNKNOWN = 0,
  UploadWaypointSnapshotResponse_Status_STATUS_OK = 1,
  UploadWaypointSnapshotResponse_Status_STATUS_INCOMPATIBLE_SENSORS = 2,
  UploadWaypointSnapshotResponse_Status_UploadWaypointSnapshotResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UploadWaypointSnapshotResponse_Status_UploadWaypointSnapshotResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UploadWaypointSnapshotResponse_Status_IsValid(int value);
constexpr UploadWaypointSnapshotResponse_Status UploadWaypointSnapshotResponse_Status_Status_MIN = UploadWaypointSnapshotResponse_Status_STATUS_UNKNOWN;
constexpr UploadWaypointSnapshotResponse_Status UploadWaypointSnapshotResponse_Status_Status_MAX = UploadWaypointSnapshotResponse_Status_STATUS_INCOMPATIBLE_SENSORS;
constexpr int UploadWaypointSnapshotResponse_Status_Status_ARRAYSIZE = UploadWaypointSnapshotResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UploadWaypointSnapshotResponse_Status_descriptor();
template<typename T>
inline const std::string& UploadWaypointSnapshotResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UploadWaypointSnapshotResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UploadWaypointSnapshotResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UploadWaypointSnapshotResponse_Status_descriptor(), enum_t_value);
}
inline bool UploadWaypointSnapshotResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UploadWaypointSnapshotResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UploadWaypointSnapshotResponse_Status>(
    UploadWaypointSnapshotResponse_Status_descriptor(), name, value);
}
enum DownloadWaypointSnapshotResponse_Status : int {
  DownloadWaypointSnapshotResponse_Status_STATUS_UNKNOWN = 0,
  DownloadWaypointSnapshotResponse_Status_STATUS_OK = 1,
  DownloadWaypointSnapshotResponse_Status_STATUS_SNAPSHOT_DOES_NOT_EXIST = 2,
  DownloadWaypointSnapshotResponse_Status_DownloadWaypointSnapshotResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DownloadWaypointSnapshotResponse_Status_DownloadWaypointSnapshotResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DownloadWaypointSnapshotResponse_Status_IsValid(int value);
constexpr DownloadWaypointSnapshotResponse_Status DownloadWaypointSnapshotResponse_Status_Status_MIN = DownloadWaypointSnapshotResponse_Status_STATUS_UNKNOWN;
constexpr DownloadWaypointSnapshotResponse_Status DownloadWaypointSnapshotResponse_Status_Status_MAX = DownloadWaypointSnapshotResponse_Status_STATUS_SNAPSHOT_DOES_NOT_EXIST;
constexpr int DownloadWaypointSnapshotResponse_Status_Status_ARRAYSIZE = DownloadWaypointSnapshotResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DownloadWaypointSnapshotResponse_Status_descriptor();
template<typename T>
inline const std::string& DownloadWaypointSnapshotResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DownloadWaypointSnapshotResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DownloadWaypointSnapshotResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DownloadWaypointSnapshotResponse_Status_descriptor(), enum_t_value);
}
inline bool DownloadWaypointSnapshotResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DownloadWaypointSnapshotResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DownloadWaypointSnapshotResponse_Status>(
    DownloadWaypointSnapshotResponse_Status_descriptor(), name, value);
}
enum DownloadEdgeSnapshotResponse_Status : int {
  DownloadEdgeSnapshotResponse_Status_STATUS_UNKNOWN = 0,
  DownloadEdgeSnapshotResponse_Status_STATUS_OK = 1,
  DownloadEdgeSnapshotResponse_Status_STATUS_SNAPSHOT_DOES_NOT_EXIST = 2,
  DownloadEdgeSnapshotResponse_Status_DownloadEdgeSnapshotResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DownloadEdgeSnapshotResponse_Status_DownloadEdgeSnapshotResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DownloadEdgeSnapshotResponse_Status_IsValid(int value);
constexpr DownloadEdgeSnapshotResponse_Status DownloadEdgeSnapshotResponse_Status_Status_MIN = DownloadEdgeSnapshotResponse_Status_STATUS_UNKNOWN;
constexpr DownloadEdgeSnapshotResponse_Status DownloadEdgeSnapshotResponse_Status_Status_MAX = DownloadEdgeSnapshotResponse_Status_STATUS_SNAPSHOT_DOES_NOT_EXIST;
constexpr int DownloadEdgeSnapshotResponse_Status_Status_ARRAYSIZE = DownloadEdgeSnapshotResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DownloadEdgeSnapshotResponse_Status_descriptor();
template<typename T>
inline const std::string& DownloadEdgeSnapshotResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DownloadEdgeSnapshotResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DownloadEdgeSnapshotResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DownloadEdgeSnapshotResponse_Status_descriptor(), enum_t_value);
}
inline bool DownloadEdgeSnapshotResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DownloadEdgeSnapshotResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DownloadEdgeSnapshotResponse_Status>(
    DownloadEdgeSnapshotResponse_Status_descriptor(), name, value);
}
enum ValidateGraphResponse_Status : int {
  ValidateGraphResponse_Status_STATUS_UNKNOWN = 0,
  ValidateGraphResponse_Status_STATUS_OK = 1,
  ValidateGraphResponse_Status_STATUS_INCOMPATIBLE_SENSORS = 5,
  ValidateGraphResponse_Status_STATUS_AREA_CALLBACK_ERROR = 6,
  ValidateGraphResponse_Status_ValidateGraphResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ValidateGraphResponse_Status_ValidateGraphResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ValidateGraphResponse_Status_IsValid(int value);
constexpr ValidateGraphResponse_Status ValidateGraphResponse_Status_Status_MIN = ValidateGraphResponse_Status_STATUS_UNKNOWN;
constexpr ValidateGraphResponse_Status ValidateGraphResponse_Status_Status_MAX = ValidateGraphResponse_Status_STATUS_AREA_CALLBACK_ERROR;
constexpr int ValidateGraphResponse_Status_Status_ARRAYSIZE = ValidateGraphResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ValidateGraphResponse_Status_descriptor();
template<typename T>
inline const std::string& ValidateGraphResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ValidateGraphResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ValidateGraphResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ValidateGraphResponse_Status_descriptor(), enum_t_value);
}
inline bool ValidateGraphResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ValidateGraphResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ValidateGraphResponse_Status>(
    ValidateGraphResponse_Status_descriptor(), name, value);
}
// ===================================================================

class VisualRefinementOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.VisualRefinementOptions) */ {
 public:
  inline VisualRefinementOptions() : VisualRefinementOptions(nullptr) {}
  ~VisualRefinementOptions() override;
  explicit PROTOBUF_CONSTEXPR VisualRefinementOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VisualRefinementOptions(const VisualRefinementOptions& from);
  VisualRefinementOptions(VisualRefinementOptions&& from) noexcept
    : VisualRefinementOptions() {
    *this = ::std::move(from);
  }

  inline VisualRefinementOptions& operator=(const VisualRefinementOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisualRefinementOptions& operator=(VisualRefinementOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisualRefinementOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisualRefinementOptions* internal_default_instance() {
    return reinterpret_cast<const VisualRefinementOptions*>(
               &_VisualRefinementOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VisualRefinementOptions& a, VisualRefinementOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(VisualRefinementOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisualRefinementOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisualRefinementOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisualRefinementOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VisualRefinementOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VisualRefinementOptions& from) {
    VisualRefinementOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisualRefinementOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.VisualRefinementOptions";
  }
  protected:
  explicit VisualRefinementOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerifyRefinementQualityFieldNumber = 1,
  };
  // bool verify_refinement_quality = 1;
  void clear_verify_refinement_quality();
  bool verify_refinement_quality() const;
  void set_verify_refinement_quality(bool value);
  private:
  bool _internal_verify_refinement_quality() const;
  void _internal_set_verify_refinement_quality(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.VisualRefinementOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool verify_refinement_quality_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class SetLocalizationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.SetLocalizationRequest) */ {
 public:
  inline SetLocalizationRequest() : SetLocalizationRequest(nullptr) {}
  ~SetLocalizationRequest() override;
  explicit PROTOBUF_CONSTEXPR SetLocalizationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLocalizationRequest(const SetLocalizationRequest& from);
  SetLocalizationRequest(SetLocalizationRequest&& from) noexcept
    : SetLocalizationRequest() {
    *this = ::std::move(from);
  }

  inline SetLocalizationRequest& operator=(const SetLocalizationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLocalizationRequest& operator=(SetLocalizationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLocalizationRequest& default_instance() {
    return *internal_default_instance();
  }
  enum RefinementCase {
    kRefineFiducialResultWithIcp = 9,
    kRefineWithVisualFeatures = 12,
    REFINEMENT_NOT_SET = 0,
  };

  static inline const SetLocalizationRequest* internal_default_instance() {
    return reinterpret_cast<const SetLocalizationRequest*>(
               &_SetLocalizationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SetLocalizationRequest& a, SetLocalizationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLocalizationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLocalizationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetLocalizationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetLocalizationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLocalizationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetLocalizationRequest& from) {
    SetLocalizationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLocalizationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.SetLocalizationRequest";
  }
  protected:
  explicit SetLocalizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SetLocalizationRequest_FiducialInit FiducialInit;
  static constexpr FiducialInit FIDUCIAL_INIT_UNKNOWN =
    SetLocalizationRequest_FiducialInit_FIDUCIAL_INIT_UNKNOWN;
  static constexpr FiducialInit FIDUCIAL_INIT_NO_FIDUCIAL =
    SetLocalizationRequest_FiducialInit_FIDUCIAL_INIT_NO_FIDUCIAL;
  static constexpr FiducialInit FIDUCIAL_INIT_NEAREST =
    SetLocalizationRequest_FiducialInit_FIDUCIAL_INIT_NEAREST;
  static constexpr FiducialInit FIDUCIAL_INIT_NEAREST_AT_TARGET =
    SetLocalizationRequest_FiducialInit_FIDUCIAL_INIT_NEAREST_AT_TARGET;
  static constexpr FiducialInit FIDUCIAL_INIT_SPECIFIC =
    SetLocalizationRequest_FiducialInit_FIDUCIAL_INIT_SPECIFIC;
  static inline bool FiducialInit_IsValid(int value) {
    return SetLocalizationRequest_FiducialInit_IsValid(value);
  }
  static constexpr FiducialInit FiducialInit_MIN =
    SetLocalizationRequest_FiducialInit_FiducialInit_MIN;
  static constexpr FiducialInit FiducialInit_MAX =
    SetLocalizationRequest_FiducialInit_FiducialInit_MAX;
  static constexpr int FiducialInit_ARRAYSIZE =
    SetLocalizationRequest_FiducialInit_FiducialInit_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FiducialInit_descriptor() {
    return SetLocalizationRequest_FiducialInit_descriptor();
  }
  template<typename T>
  static inline const std::string& FiducialInit_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FiducialInit>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FiducialInit_Name.");
    return SetLocalizationRequest_FiducialInit_Name(enum_t_value);
  }
  static inline bool FiducialInit_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FiducialInit* value) {
    return SetLocalizationRequest_FiducialInit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kInitialGuessFieldNumber = 3,
    kKoTformBodyFieldNumber = 4,
    kMaxDistanceFieldNumber = 5,
    kMaxYawFieldNumber = 6,
    kFiducialInitFieldNumber = 7,
    kUseFiducialIdFieldNumber = 8,
    kDoAmbiguityCheckFieldNumber = 10,
    kRestrictFiducialDetectionsToTargetWaypointFieldNumber = 11,
    kRefineFiducialResultWithIcpFieldNumber = 9,
    kRefineWithVisualFeaturesFieldNumber = 12,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.Localization initial_guess = 3;
  bool has_initial_guess() const;
  private:
  bool _internal_has_initial_guess() const;
  public:
  void clear_initial_guess();
  const ::bosdyn::api::graph_nav::Localization& initial_guess() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::Localization* release_initial_guess();
  ::bosdyn::api::graph_nav::Localization* mutable_initial_guess();
  void set_allocated_initial_guess(::bosdyn::api::graph_nav::Localization* initial_guess);
  private:
  const ::bosdyn::api::graph_nav::Localization& _internal_initial_guess() const;
  ::bosdyn::api::graph_nav::Localization* _internal_mutable_initial_guess();
  public:
  void unsafe_arena_set_allocated_initial_guess(
      ::bosdyn::api::graph_nav::Localization* initial_guess);
  ::bosdyn::api::graph_nav::Localization* unsafe_arena_release_initial_guess();

  // .bosdyn.api.SE3Pose ko_tform_body = 4;
  bool has_ko_tform_body() const;
  private:
  bool _internal_has_ko_tform_body() const;
  public:
  void clear_ko_tform_body();
  const ::bosdyn::api::SE3Pose& ko_tform_body() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Pose* release_ko_tform_body();
  ::bosdyn::api::SE3Pose* mutable_ko_tform_body();
  void set_allocated_ko_tform_body(::bosdyn::api::SE3Pose* ko_tform_body);
  private:
  const ::bosdyn::api::SE3Pose& _internal_ko_tform_body() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_ko_tform_body();
  public:
  void unsafe_arena_set_allocated_ko_tform_body(
      ::bosdyn::api::SE3Pose* ko_tform_body);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_ko_tform_body();

  // double max_distance = 5;
  void clear_max_distance();
  double max_distance() const;
  void set_max_distance(double value);
  private:
  double _internal_max_distance() const;
  void _internal_set_max_distance(double value);
  public:

  // double max_yaw = 6;
  void clear_max_yaw();
  double max_yaw() const;
  void set_max_yaw(double value);
  private:
  double _internal_max_yaw() const;
  void _internal_set_max_yaw(double value);
  public:

  // .bosdyn.api.graph_nav.SetLocalizationRequest.FiducialInit fiducial_init = 7;
  void clear_fiducial_init();
  ::bosdyn::api::graph_nav::SetLocalizationRequest_FiducialInit fiducial_init() const;
  void set_fiducial_init(::bosdyn::api::graph_nav::SetLocalizationRequest_FiducialInit value);
  private:
  ::bosdyn::api::graph_nav::SetLocalizationRequest_FiducialInit _internal_fiducial_init() const;
  void _internal_set_fiducial_init(::bosdyn::api::graph_nav::SetLocalizationRequest_FiducialInit value);
  public:

  // int32 use_fiducial_id = 8;
  void clear_use_fiducial_id();
  int32_t use_fiducial_id() const;
  void set_use_fiducial_id(int32_t value);
  private:
  int32_t _internal_use_fiducial_id() const;
  void _internal_set_use_fiducial_id(int32_t value);
  public:

  // bool do_ambiguity_check = 10;
  void clear_do_ambiguity_check();
  bool do_ambiguity_check() const;
  void set_do_ambiguity_check(bool value);
  private:
  bool _internal_do_ambiguity_check() const;
  void _internal_set_do_ambiguity_check(bool value);
  public:

  // bool restrict_fiducial_detections_to_target_waypoint = 11;
  void clear_restrict_fiducial_detections_to_target_waypoint();
  bool restrict_fiducial_detections_to_target_waypoint() const;
  void set_restrict_fiducial_detections_to_target_waypoint(bool value);
  private:
  bool _internal_restrict_fiducial_detections_to_target_waypoint() const;
  void _internal_set_restrict_fiducial_detections_to_target_waypoint(bool value);
  public:

  // bool refine_fiducial_result_with_icp = 9;
  bool has_refine_fiducial_result_with_icp() const;
  private:
  bool _internal_has_refine_fiducial_result_with_icp() const;
  public:
  void clear_refine_fiducial_result_with_icp();
  bool refine_fiducial_result_with_icp() const;
  void set_refine_fiducial_result_with_icp(bool value);
  private:
  bool _internal_refine_fiducial_result_with_icp() const;
  void _internal_set_refine_fiducial_result_with_icp(bool value);
  public:

  // .bosdyn.api.graph_nav.VisualRefinementOptions refine_with_visual_features = 12;
  bool has_refine_with_visual_features() const;
  private:
  bool _internal_has_refine_with_visual_features() const;
  public:
  void clear_refine_with_visual_features();
  const ::bosdyn::api::graph_nav::VisualRefinementOptions& refine_with_visual_features() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::VisualRefinementOptions* release_refine_with_visual_features();
  ::bosdyn::api::graph_nav::VisualRefinementOptions* mutable_refine_with_visual_features();
  void set_allocated_refine_with_visual_features(::bosdyn::api::graph_nav::VisualRefinementOptions* refine_with_visual_features);
  private:
  const ::bosdyn::api::graph_nav::VisualRefinementOptions& _internal_refine_with_visual_features() const;
  ::bosdyn::api::graph_nav::VisualRefinementOptions* _internal_mutable_refine_with_visual_features();
  public:
  void unsafe_arena_set_allocated_refine_with_visual_features(
      ::bosdyn::api::graph_nav::VisualRefinementOptions* refine_with_visual_features);
  ::bosdyn::api::graph_nav::VisualRefinementOptions* unsafe_arena_release_refine_with_visual_features();

  void clear_refinement();
  RefinementCase refinement_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.SetLocalizationRequest)
 private:
  class _Internal;
  void set_has_refine_fiducial_result_with_icp();
  void set_has_refine_with_visual_features();

  inline bool has_refinement() const;
  inline void clear_has_refinement();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::graph_nav::Localization* initial_guess_;
    ::bosdyn::api::SE3Pose* ko_tform_body_;
    double max_distance_;
    double max_yaw_;
    int fiducial_init_;
    int32_t use_fiducial_id_;
    bool do_ambiguity_check_;
    bool restrict_fiducial_detections_to_target_waypoint_;
    union RefinementUnion {
      constexpr RefinementUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool refine_fiducial_result_with_icp_;
      ::bosdyn::api::graph_nav::VisualRefinementOptions* refine_with_visual_features_;
    } refinement_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class SensorCompatibilityStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.SensorCompatibilityStatus) */ {
 public:
  inline SensorCompatibilityStatus() : SensorCompatibilityStatus(nullptr) {}
  ~SensorCompatibilityStatus() override;
  explicit PROTOBUF_CONSTEXPR SensorCompatibilityStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorCompatibilityStatus(const SensorCompatibilityStatus& from);
  SensorCompatibilityStatus(SensorCompatibilityStatus&& from) noexcept
    : SensorCompatibilityStatus() {
    *this = ::std::move(from);
  }

  inline SensorCompatibilityStatus& operator=(const SensorCompatibilityStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorCompatibilityStatus& operator=(SensorCompatibilityStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorCompatibilityStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorCompatibilityStatus* internal_default_instance() {
    return reinterpret_cast<const SensorCompatibilityStatus*>(
               &_SensorCompatibilityStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SensorCompatibilityStatus& a, SensorCompatibilityStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorCompatibilityStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorCompatibilityStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorCompatibilityStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorCompatibilityStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorCompatibilityStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorCompatibilityStatus& from) {
    SensorCompatibilityStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorCompatibilityStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.SensorCompatibilityStatus";
  }
  protected:
  explicit SensorCompatibilityStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapHasLidarDataFieldNumber = 1,
    kRobotConfiguredForLidarFieldNumber = 2,
  };
  // bool map_has_lidar_data = 1;
  void clear_map_has_lidar_data();
  bool map_has_lidar_data() const;
  void set_map_has_lidar_data(bool value);
  private:
  bool _internal_map_has_lidar_data() const;
  void _internal_set_map_has_lidar_data(bool value);
  public:

  // bool robot_configured_for_lidar = 2;
  void clear_robot_configured_for_lidar();
  bool robot_configured_for_lidar() const;
  void set_robot_configured_for_lidar(bool value);
  private:
  bool _internal_robot_configured_for_lidar() const;
  void _internal_set_robot_configured_for_lidar(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.SensorCompatibilityStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool map_has_lidar_data_;
    bool robot_configured_for_lidar_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class SetLocalizationResponse_SuspectedAmbiguity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.SetLocalizationResponse.SuspectedAmbiguity) */ {
 public:
  inline SetLocalizationResponse_SuspectedAmbiguity() : SetLocalizationResponse_SuspectedAmbiguity(nullptr) {}
  ~SetLocalizationResponse_SuspectedAmbiguity() override;
  explicit PROTOBUF_CONSTEXPR SetLocalizationResponse_SuspectedAmbiguity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLocalizationResponse_SuspectedAmbiguity(const SetLocalizationResponse_SuspectedAmbiguity& from);
  SetLocalizationResponse_SuspectedAmbiguity(SetLocalizationResponse_SuspectedAmbiguity&& from) noexcept
    : SetLocalizationResponse_SuspectedAmbiguity() {
    *this = ::std::move(from);
  }

  inline SetLocalizationResponse_SuspectedAmbiguity& operator=(const SetLocalizationResponse_SuspectedAmbiguity& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLocalizationResponse_SuspectedAmbiguity& operator=(SetLocalizationResponse_SuspectedAmbiguity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLocalizationResponse_SuspectedAmbiguity& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetLocalizationResponse_SuspectedAmbiguity* internal_default_instance() {
    return reinterpret_cast<const SetLocalizationResponse_SuspectedAmbiguity*>(
               &_SetLocalizationResponse_SuspectedAmbiguity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SetLocalizationResponse_SuspectedAmbiguity& a, SetLocalizationResponse_SuspectedAmbiguity& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLocalizationResponse_SuspectedAmbiguity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLocalizationResponse_SuspectedAmbiguity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetLocalizationResponse_SuspectedAmbiguity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetLocalizationResponse_SuspectedAmbiguity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLocalizationResponse_SuspectedAmbiguity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetLocalizationResponse_SuspectedAmbiguity& from) {
    SetLocalizationResponse_SuspectedAmbiguity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLocalizationResponse_SuspectedAmbiguity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.SetLocalizationResponse.SuspectedAmbiguity";
  }
  protected:
  explicit SetLocalizationResponse_SuspectedAmbiguity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlternateRobotTformWaypointFieldNumber = 1,
  };
  // .bosdyn.api.SE3Pose alternate_robot_tform_waypoint = 1;
  bool has_alternate_robot_tform_waypoint() const;
  private:
  bool _internal_has_alternate_robot_tform_waypoint() const;
  public:
  void clear_alternate_robot_tform_waypoint();
  const ::bosdyn::api::SE3Pose& alternate_robot_tform_waypoint() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Pose* release_alternate_robot_tform_waypoint();
  ::bosdyn::api::SE3Pose* mutable_alternate_robot_tform_waypoint();
  void set_allocated_alternate_robot_tform_waypoint(::bosdyn::api::SE3Pose* alternate_robot_tform_waypoint);
  private:
  const ::bosdyn::api::SE3Pose& _internal_alternate_robot_tform_waypoint() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_alternate_robot_tform_waypoint();
  public:
  void unsafe_arena_set_allocated_alternate_robot_tform_waypoint(
      ::bosdyn::api::SE3Pose* alternate_robot_tform_waypoint);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_alternate_robot_tform_waypoint();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.SetLocalizationResponse.SuspectedAmbiguity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::SE3Pose* alternate_robot_tform_waypoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class SetLocalizationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.SetLocalizationResponse) */ {
 public:
  inline SetLocalizationResponse() : SetLocalizationResponse(nullptr) {}
  ~SetLocalizationResponse() override;
  explicit PROTOBUF_CONSTEXPR SetLocalizationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLocalizationResponse(const SetLocalizationResponse& from);
  SetLocalizationResponse(SetLocalizationResponse&& from) noexcept
    : SetLocalizationResponse() {
    *this = ::std::move(from);
  }

  inline SetLocalizationResponse& operator=(const SetLocalizationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLocalizationResponse& operator=(SetLocalizationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLocalizationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetLocalizationResponse* internal_default_instance() {
    return reinterpret_cast<const SetLocalizationResponse*>(
               &_SetLocalizationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SetLocalizationResponse& a, SetLocalizationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLocalizationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLocalizationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetLocalizationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetLocalizationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLocalizationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetLocalizationResponse& from) {
    SetLocalizationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLocalizationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.SetLocalizationResponse";
  }
  protected:
  explicit SetLocalizationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SetLocalizationResponse_SuspectedAmbiguity SuspectedAmbiguity;

  typedef SetLocalizationResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    SetLocalizationResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    SetLocalizationResponse_Status_STATUS_OK;
  static constexpr Status STATUS_ROBOT_IMPAIRED =
    SetLocalizationResponse_Status_STATUS_ROBOT_IMPAIRED;
  static constexpr Status STATUS_UNKNOWN_WAYPOINT =
    SetLocalizationResponse_Status_STATUS_UNKNOWN_WAYPOINT;
  static constexpr Status STATUS_ABORTED =
    SetLocalizationResponse_Status_STATUS_ABORTED;
  static constexpr Status STATUS_FAILED =
    SetLocalizationResponse_Status_STATUS_FAILED;
  static constexpr Status STATUS_FIDUCIAL_TOO_FAR_AWAY =
    SetLocalizationResponse_Status_STATUS_FIDUCIAL_TOO_FAR_AWAY;
  static constexpr Status STATUS_FIDUCIAL_TOO_OLD =
    SetLocalizationResponse_Status_STATUS_FIDUCIAL_TOO_OLD;
  static constexpr Status STATUS_NO_MATCHING_FIDUCIAL =
    SetLocalizationResponse_Status_STATUS_NO_MATCHING_FIDUCIAL;
  static constexpr Status STATUS_FIDUCIAL_POSE_UNCERTAIN =
    SetLocalizationResponse_Status_STATUS_FIDUCIAL_POSE_UNCERTAIN;
  static constexpr Status STATUS_INCOMPATIBLE_SENSORS =
    SetLocalizationResponse_Status_STATUS_INCOMPATIBLE_SENSORS;
  static constexpr Status STATUS_VISUAL_ALIGNMENT_FAILED =
    SetLocalizationResponse_Status_STATUS_VISUAL_ALIGNMENT_FAILED;
  static inline bool Status_IsValid(int value) {
    return SetLocalizationResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    SetLocalizationResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    SetLocalizationResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    SetLocalizationResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return SetLocalizationResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return SetLocalizationResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return SetLocalizationResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorReportFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
    kLocalizationFieldNumber = 5,
    kSuspectedAmbiguityFieldNumber = 7,
    kImpairedStateFieldNumber = 8,
    kSensorStatusFieldNumber = 9,
    kStatusFieldNumber = 3,
  };
  // string error_report = 4;
  void clear_error_report();
  const std::string& error_report() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_report(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_report();
  PROTOBUF_NODISCARD std::string* release_error_report();
  void set_allocated_error_report(std::string* error_report);
  private:
  const std::string& _internal_error_report() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_report(const std::string& value);
  std::string* _internal_mutable_error_report();
  public:

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  PROTOBUF_NODISCARD ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // .bosdyn.api.graph_nav.Localization localization = 5;
  bool has_localization() const;
  private:
  bool _internal_has_localization() const;
  public:
  void clear_localization();
  const ::bosdyn::api::graph_nav::Localization& localization() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::Localization* release_localization();
  ::bosdyn::api::graph_nav::Localization* mutable_localization();
  void set_allocated_localization(::bosdyn::api::graph_nav::Localization* localization);
  private:
  const ::bosdyn::api::graph_nav::Localization& _internal_localization() const;
  ::bosdyn::api::graph_nav::Localization* _internal_mutable_localization();
  public:
  void unsafe_arena_set_allocated_localization(
      ::bosdyn::api::graph_nav::Localization* localization);
  ::bosdyn::api::graph_nav::Localization* unsafe_arena_release_localization();

  // .bosdyn.api.graph_nav.SetLocalizationResponse.SuspectedAmbiguity suspected_ambiguity = 7;
  bool has_suspected_ambiguity() const;
  private:
  bool _internal_has_suspected_ambiguity() const;
  public:
  void clear_suspected_ambiguity();
  const ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity& suspected_ambiguity() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* release_suspected_ambiguity();
  ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* mutable_suspected_ambiguity();
  void set_allocated_suspected_ambiguity(::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* suspected_ambiguity);
  private:
  const ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity& _internal_suspected_ambiguity() const;
  ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* _internal_mutable_suspected_ambiguity();
  public:
  void unsafe_arena_set_allocated_suspected_ambiguity(
      ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* suspected_ambiguity);
  ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* unsafe_arena_release_suspected_ambiguity();

  // .bosdyn.api.RobotImpairedState impaired_state = 8;
  bool has_impaired_state() const;
  private:
  bool _internal_has_impaired_state() const;
  public:
  void clear_impaired_state();
  const ::bosdyn::api::RobotImpairedState& impaired_state() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RobotImpairedState* release_impaired_state();
  ::bosdyn::api::RobotImpairedState* mutable_impaired_state();
  void set_allocated_impaired_state(::bosdyn::api::RobotImpairedState* impaired_state);
  private:
  const ::bosdyn::api::RobotImpairedState& _internal_impaired_state() const;
  ::bosdyn::api::RobotImpairedState* _internal_mutable_impaired_state();
  public:
  void unsafe_arena_set_allocated_impaired_state(
      ::bosdyn::api::RobotImpairedState* impaired_state);
  ::bosdyn::api::RobotImpairedState* unsafe_arena_release_impaired_state();

  // .bosdyn.api.graph_nav.SensorCompatibilityStatus sensor_status = 9;
  bool has_sensor_status() const;
  private:
  bool _internal_has_sensor_status() const;
  public:
  void clear_sensor_status();
  const ::bosdyn::api::graph_nav::SensorCompatibilityStatus& sensor_status() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::SensorCompatibilityStatus* release_sensor_status();
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* mutable_sensor_status();
  void set_allocated_sensor_status(::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status);
  private:
  const ::bosdyn::api::graph_nav::SensorCompatibilityStatus& _internal_sensor_status() const;
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* _internal_mutable_sensor_status();
  public:
  void unsafe_arena_set_allocated_sensor_status(
      ::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status);
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* unsafe_arena_release_sensor_status();

  // .bosdyn.api.graph_nav.SetLocalizationResponse.Status status = 3;
  void clear_status();
  ::bosdyn::api::graph_nav::SetLocalizationResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::SetLocalizationResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::SetLocalizationResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::SetLocalizationResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.SetLocalizationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_report_;
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::LeaseUseResult* lease_use_result_;
    ::bosdyn::api::graph_nav::Localization* localization_;
    ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* suspected_ambiguity_;
    ::bosdyn::api::RobotImpairedState* impaired_state_;
    ::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class RouteGenParams final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.RouteGenParams) */ {
 public:
  inline RouteGenParams() : RouteGenParams(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RouteGenParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteGenParams(const RouteGenParams& from);
  RouteGenParams(RouteGenParams&& from) noexcept
    : RouteGenParams() {
    *this = ::std::move(from);
  }

  inline RouteGenParams& operator=(const RouteGenParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteGenParams& operator=(RouteGenParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteGenParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteGenParams* internal_default_instance() {
    return reinterpret_cast<const RouteGenParams*>(
               &_RouteGenParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RouteGenParams& a, RouteGenParams& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteGenParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteGenParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteGenParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteGenParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RouteGenParams& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RouteGenParams& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.RouteGenParams";
  }
  protected:
  explicit RouteGenParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.RouteGenParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class TravelParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.TravelParams) */ {
 public:
  inline TravelParams() : TravelParams(nullptr) {}
  ~TravelParams() override;
  explicit PROTOBUF_CONSTEXPR TravelParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TravelParams(const TravelParams& from);
  TravelParams(TravelParams&& from) noexcept
    : TravelParams() {
    *this = ::std::move(from);
  }

  inline TravelParams& operator=(const TravelParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline TravelParams& operator=(TravelParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TravelParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const TravelParams* internal_default_instance() {
    return reinterpret_cast<const TravelParams*>(
               &_TravelParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TravelParams& a, TravelParams& b) {
    a.Swap(&b);
  }
  inline void Swap(TravelParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TravelParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TravelParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TravelParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TravelParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TravelParams& from) {
    TravelParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TravelParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.TravelParams";
  }
  protected:
  explicit TravelParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TravelParams_FeatureQualityTolerance FeatureQualityTolerance;
  static constexpr FeatureQualityTolerance TOLERANCE_UNKNOWN =
    TravelParams_FeatureQualityTolerance_TOLERANCE_UNKNOWN;
  static constexpr FeatureQualityTolerance TOLERANCE_DEFAULT =
    TravelParams_FeatureQualityTolerance_TOLERANCE_DEFAULT;
  static constexpr FeatureQualityTolerance TOLERANCE_IGNORE_POOR_FEATURE_QUALITY =
    TravelParams_FeatureQualityTolerance_TOLERANCE_IGNORE_POOR_FEATURE_QUALITY;
  static inline bool FeatureQualityTolerance_IsValid(int value) {
    return TravelParams_FeatureQualityTolerance_IsValid(value);
  }
  static constexpr FeatureQualityTolerance FeatureQualityTolerance_MIN =
    TravelParams_FeatureQualityTolerance_FeatureQualityTolerance_MIN;
  static constexpr FeatureQualityTolerance FeatureQualityTolerance_MAX =
    TravelParams_FeatureQualityTolerance_FeatureQualityTolerance_MAX;
  static constexpr int FeatureQualityTolerance_ARRAYSIZE =
    TravelParams_FeatureQualityTolerance_FeatureQualityTolerance_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FeatureQualityTolerance_descriptor() {
    return TravelParams_FeatureQualityTolerance_descriptor();
  }
  template<typename T>
  static inline const std::string& FeatureQualityTolerance_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FeatureQualityTolerance>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FeatureQualityTolerance_Name.");
    return TravelParams_FeatureQualityTolerance_Name(enum_t_value);
  }
  static inline bool FeatureQualityTolerance_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FeatureQualityTolerance* value) {
    return TravelParams_FeatureQualityTolerance_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVelocityLimitFieldNumber = 3,
    kBlockedPathWaitTimeFieldNumber = 10,
    kMaxDistanceFieldNumber = 1,
    kMaxYawFieldNumber = 2,
    kFeatureQualityToleranceFieldNumber = 5,
    kIgnoreFinalYawFieldNumber = 4,
    kDisableDirectedExplorationFieldNumber = 6,
    kDisableAlternateRouteFindingFieldNumber = 8,
    kPathFollowingModeFieldNumber = 9,
    kGroundClutterModeFieldNumber = 11,
  };
  // .bosdyn.api.SE2VelocityLimit velocity_limit = 3;
  bool has_velocity_limit() const;
  private:
  bool _internal_has_velocity_limit() const;
  public:
  void clear_velocity_limit();
  const ::bosdyn::api::SE2VelocityLimit& velocity_limit() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE2VelocityLimit* release_velocity_limit();
  ::bosdyn::api::SE2VelocityLimit* mutable_velocity_limit();
  void set_allocated_velocity_limit(::bosdyn::api::SE2VelocityLimit* velocity_limit);
  private:
  const ::bosdyn::api::SE2VelocityLimit& _internal_velocity_limit() const;
  ::bosdyn::api::SE2VelocityLimit* _internal_mutable_velocity_limit();
  public:
  void unsafe_arena_set_allocated_velocity_limit(
      ::bosdyn::api::SE2VelocityLimit* velocity_limit);
  ::bosdyn::api::SE2VelocityLimit* unsafe_arena_release_velocity_limit();

  // .google.protobuf.Duration blocked_path_wait_time = 10;
  bool has_blocked_path_wait_time() const;
  private:
  bool _internal_has_blocked_path_wait_time() const;
  public:
  void clear_blocked_path_wait_time();
  const ::PROTOBUF_NAMESPACE_ID::Duration& blocked_path_wait_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_blocked_path_wait_time();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_blocked_path_wait_time();
  void set_allocated_blocked_path_wait_time(::PROTOBUF_NAMESPACE_ID::Duration* blocked_path_wait_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_blocked_path_wait_time() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_blocked_path_wait_time();
  public:
  void unsafe_arena_set_allocated_blocked_path_wait_time(
      ::PROTOBUF_NAMESPACE_ID::Duration* blocked_path_wait_time);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_blocked_path_wait_time();

  // double max_distance = 1;
  void clear_max_distance();
  double max_distance() const;
  void set_max_distance(double value);
  private:
  double _internal_max_distance() const;
  void _internal_set_max_distance(double value);
  public:

  // double max_yaw = 2;
  void clear_max_yaw();
  double max_yaw() const;
  void set_max_yaw(double value);
  private:
  double _internal_max_yaw() const;
  void _internal_set_max_yaw(double value);
  public:

  // .bosdyn.api.graph_nav.TravelParams.FeatureQualityTolerance feature_quality_tolerance = 5;
  void clear_feature_quality_tolerance();
  ::bosdyn::api::graph_nav::TravelParams_FeatureQualityTolerance feature_quality_tolerance() const;
  void set_feature_quality_tolerance(::bosdyn::api::graph_nav::TravelParams_FeatureQualityTolerance value);
  private:
  ::bosdyn::api::graph_nav::TravelParams_FeatureQualityTolerance _internal_feature_quality_tolerance() const;
  void _internal_set_feature_quality_tolerance(::bosdyn::api::graph_nav::TravelParams_FeatureQualityTolerance value);
  public:

  // bool ignore_final_yaw = 4;
  void clear_ignore_final_yaw();
  bool ignore_final_yaw() const;
  void set_ignore_final_yaw(bool value);
  private:
  bool _internal_ignore_final_yaw() const;
  void _internal_set_ignore_final_yaw(bool value);
  public:

  // bool disable_directed_exploration = 6;
  void clear_disable_directed_exploration();
  bool disable_directed_exploration() const;
  void set_disable_directed_exploration(bool value);
  private:
  bool _internal_disable_directed_exploration() const;
  void _internal_set_disable_directed_exploration(bool value);
  public:

  // bool disable_alternate_route_finding = 8;
  void clear_disable_alternate_route_finding();
  bool disable_alternate_route_finding() const;
  void set_disable_alternate_route_finding(bool value);
  private:
  bool _internal_disable_alternate_route_finding() const;
  void _internal_set_disable_alternate_route_finding(bool value);
  public:

  // .bosdyn.api.graph_nav.Edge.Annotations.PathFollowingMode path_following_mode = 9;
  void clear_path_following_mode();
  ::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode path_following_mode() const;
  void set_path_following_mode(::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode value);
  private:
  ::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode _internal_path_following_mode() const;
  void _internal_set_path_following_mode(::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode value);
  public:

  // .bosdyn.api.graph_nav.Edge.Annotations.GroundClutterAvoidanceMode ground_clutter_mode = 11;
  void clear_ground_clutter_mode();
  ::bosdyn::api::graph_nav::Edge_Annotations_GroundClutterAvoidanceMode ground_clutter_mode() const;
  void set_ground_clutter_mode(::bosdyn::api::graph_nav::Edge_Annotations_GroundClutterAvoidanceMode value);
  private:
  ::bosdyn::api::graph_nav::Edge_Annotations_GroundClutterAvoidanceMode _internal_ground_clutter_mode() const;
  void _internal_set_ground_clutter_mode(::bosdyn::api::graph_nav::Edge_Annotations_GroundClutterAvoidanceMode value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.TravelParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::SE2VelocityLimit* velocity_limit_;
    ::PROTOBUF_NAMESPACE_ID::Duration* blocked_path_wait_time_;
    double max_distance_;
    double max_yaw_;
    int feature_quality_tolerance_;
    bool ignore_final_yaw_;
    bool disable_directed_exploration_;
    bool disable_alternate_route_finding_;
    int path_following_mode_;
    int ground_clutter_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class NavigateToRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.NavigateToRequest) */ {
 public:
  inline NavigateToRequest() : NavigateToRequest(nullptr) {}
  ~NavigateToRequest() override;
  explicit PROTOBUF_CONSTEXPR NavigateToRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigateToRequest(const NavigateToRequest& from);
  NavigateToRequest(NavigateToRequest&& from) noexcept
    : NavigateToRequest() {
    *this = ::std::move(from);
  }

  inline NavigateToRequest& operator=(const NavigateToRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigateToRequest& operator=(NavigateToRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigateToRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigateToRequest* internal_default_instance() {
    return reinterpret_cast<const NavigateToRequest*>(
               &_NavigateToRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NavigateToRequest& a, NavigateToRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigateToRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigateToRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigateToRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigateToRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NavigateToRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NavigateToRequest& from) {
    NavigateToRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigateToRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.NavigateToRequest";
  }
  protected:
  explicit NavigateToRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeasesFieldNumber = 2,
    kDestinationWaypointIdFieldNumber = 3,
    kClockIdentifierFieldNumber = 7,
    kHeaderFieldNumber = 1,
    kRouteParamsFieldNumber = 4,
    kTravelParamsFieldNumber = 5,
    kEndTimeFieldNumber = 6,
    kDestinationWaypointTformBodyGoalFieldNumber = 8,
    kCommandIdFieldNumber = 9,
  };
  // repeated .bosdyn.api.Lease leases = 2;
  int leases_size() const;
  private:
  int _internal_leases_size() const;
  public:
  void clear_leases();
  ::bosdyn::api::Lease* mutable_leases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
      mutable_leases();
  private:
  const ::bosdyn::api::Lease& _internal_leases(int index) const;
  ::bosdyn::api::Lease* _internal_add_leases();
  public:
  const ::bosdyn::api::Lease& leases(int index) const;
  ::bosdyn::api::Lease* add_leases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
      leases() const;

  // string destination_waypoint_id = 3;
  void clear_destination_waypoint_id();
  const std::string& destination_waypoint_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination_waypoint_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination_waypoint_id();
  PROTOBUF_NODISCARD std::string* release_destination_waypoint_id();
  void set_allocated_destination_waypoint_id(std::string* destination_waypoint_id);
  private:
  const std::string& _internal_destination_waypoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_waypoint_id(const std::string& value);
  std::string* _internal_mutable_destination_waypoint_id();
  public:

  // string clock_identifier = 7;
  void clear_clock_identifier();
  const std::string& clock_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clock_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clock_identifier();
  PROTOBUF_NODISCARD std::string* release_clock_identifier();
  void set_allocated_clock_identifier(std::string* clock_identifier);
  private:
  const std::string& _internal_clock_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clock_identifier(const std::string& value);
  std::string* _internal_mutable_clock_identifier();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.RouteGenParams route_params = 4;
  bool has_route_params() const;
  private:
  bool _internal_has_route_params() const;
  public:
  void clear_route_params();
  const ::bosdyn::api::graph_nav::RouteGenParams& route_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::RouteGenParams* release_route_params();
  ::bosdyn::api::graph_nav::RouteGenParams* mutable_route_params();
  void set_allocated_route_params(::bosdyn::api::graph_nav::RouteGenParams* route_params);
  private:
  const ::bosdyn::api::graph_nav::RouteGenParams& _internal_route_params() const;
  ::bosdyn::api::graph_nav::RouteGenParams* _internal_mutable_route_params();
  public:
  void unsafe_arena_set_allocated_route_params(
      ::bosdyn::api::graph_nav::RouteGenParams* route_params);
  ::bosdyn::api::graph_nav::RouteGenParams* unsafe_arena_release_route_params();

  // .bosdyn.api.graph_nav.TravelParams travel_params = 5;
  bool has_travel_params() const;
  private:
  bool _internal_has_travel_params() const;
  public:
  void clear_travel_params();
  const ::bosdyn::api::graph_nav::TravelParams& travel_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::TravelParams* release_travel_params();
  ::bosdyn::api::graph_nav::TravelParams* mutable_travel_params();
  void set_allocated_travel_params(::bosdyn::api::graph_nav::TravelParams* travel_params);
  private:
  const ::bosdyn::api::graph_nav::TravelParams& _internal_travel_params() const;
  ::bosdyn::api::graph_nav::TravelParams* _internal_mutable_travel_params();
  public:
  void unsafe_arena_set_allocated_travel_params(
      ::bosdyn::api::graph_nav::TravelParams* travel_params);
  ::bosdyn::api::graph_nav::TravelParams* unsafe_arena_release_travel_params();

  // .google.protobuf.Timestamp end_time = 6;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // .bosdyn.api.SE2Pose destination_waypoint_tform_body_goal = 8;
  bool has_destination_waypoint_tform_body_goal() const;
  private:
  bool _internal_has_destination_waypoint_tform_body_goal() const;
  public:
  void clear_destination_waypoint_tform_body_goal();
  const ::bosdyn::api::SE2Pose& destination_waypoint_tform_body_goal() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE2Pose* release_destination_waypoint_tform_body_goal();
  ::bosdyn::api::SE2Pose* mutable_destination_waypoint_tform_body_goal();
  void set_allocated_destination_waypoint_tform_body_goal(::bosdyn::api::SE2Pose* destination_waypoint_tform_body_goal);
  private:
  const ::bosdyn::api::SE2Pose& _internal_destination_waypoint_tform_body_goal() const;
  ::bosdyn::api::SE2Pose* _internal_mutable_destination_waypoint_tform_body_goal();
  public:
  void unsafe_arena_set_allocated_destination_waypoint_tform_body_goal(
      ::bosdyn::api::SE2Pose* destination_waypoint_tform_body_goal);
  ::bosdyn::api::SE2Pose* unsafe_arena_release_destination_waypoint_tform_body_goal();

  // uint32 command_id = 9;
  void clear_command_id();
  uint32_t command_id() const;
  void set_command_id(uint32_t value);
  private:
  uint32_t _internal_command_id() const;
  void _internal_set_command_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.NavigateToRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease > leases_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_waypoint_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clock_identifier_;
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::graph_nav::RouteGenParams* route_params_;
    ::bosdyn::api::graph_nav::TravelParams* travel_params_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    ::bosdyn::api::SE2Pose* destination_waypoint_tform_body_goal_;
    uint32_t command_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class NavigateToResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.NavigateToResponse) */ {
 public:
  inline NavigateToResponse() : NavigateToResponse(nullptr) {}
  ~NavigateToResponse() override;
  explicit PROTOBUF_CONSTEXPR NavigateToResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigateToResponse(const NavigateToResponse& from);
  NavigateToResponse(NavigateToResponse&& from) noexcept
    : NavigateToResponse() {
    *this = ::std::move(from);
  }

  inline NavigateToResponse& operator=(const NavigateToResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigateToResponse& operator=(NavigateToResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigateToResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigateToResponse* internal_default_instance() {
    return reinterpret_cast<const NavigateToResponse*>(
               &_NavigateToResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NavigateToResponse& a, NavigateToResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigateToResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigateToResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigateToResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigateToResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NavigateToResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NavigateToResponse& from) {
    NavigateToResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigateToResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.NavigateToResponse";
  }
  protected:
  explicit NavigateToResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NavigateToResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    NavigateToResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    NavigateToResponse_Status_STATUS_OK;
  static constexpr Status STATUS_NO_TIMESYNC =
    NavigateToResponse_Status_STATUS_NO_TIMESYNC;
  static constexpr Status STATUS_EXPIRED =
    NavigateToResponse_Status_STATUS_EXPIRED;
  static constexpr Status STATUS_TOO_DISTANT =
    NavigateToResponse_Status_STATUS_TOO_DISTANT;
  static constexpr Status STATUS_ROBOT_IMPAIRED =
    NavigateToResponse_Status_STATUS_ROBOT_IMPAIRED;
  static constexpr Status STATUS_RECORDING =
    NavigateToResponse_Status_STATUS_RECORDING;
  static constexpr Status STATUS_UNKNOWN_WAYPOINT =
    NavigateToResponse_Status_STATUS_UNKNOWN_WAYPOINT;
  static constexpr Status STATUS_NO_PATH =
    NavigateToResponse_Status_STATUS_NO_PATH;
  static constexpr Status STATUS_FEATURE_DESERT =
    NavigateToResponse_Status_STATUS_FEATURE_DESERT;
  static constexpr Status STATUS_LOST =
    NavigateToResponse_Status_STATUS_LOST;
  static constexpr Status STATUS_NOT_LOCALIZED_TO_MAP =
    NavigateToResponse_Status_STATUS_NOT_LOCALIZED_TO_MAP;
  static constexpr Status STATUS_COULD_NOT_UPDATE_ROUTE =
    NavigateToResponse_Status_STATUS_COULD_NOT_UPDATE_ROUTE;
  static constexpr Status STATUS_STUCK =
    NavigateToResponse_Status_STATUS_STUCK;
  static constexpr Status STATUS_UNRECOGNIZED_COMMAND =
    NavigateToResponse_Status_STATUS_UNRECOGNIZED_COMMAND;
  static constexpr Status STATUS_AREA_CALLBACK_ERROR =
    NavigateToResponse_Status_STATUS_AREA_CALLBACK_ERROR;
  static inline bool Status_IsValid(int value) {
    return NavigateToResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    NavigateToResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    NavigateToResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    NavigateToResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return NavigateToResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return NavigateToResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return NavigateToResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeaseUseResultsFieldNumber = 2,
    kErrorWaypointIdsFieldNumber = 5,
    kHeaderFieldNumber = 1,
    kImpairedStateFieldNumber = 6,
    kAreaCallbackErrorFieldNumber = 10,
    kStatusFieldNumber = 3,
    kCommandIdFieldNumber = 4,
  };
  // repeated .bosdyn.api.LeaseUseResult lease_use_results = 2;
  int lease_use_results_size() const;
  private:
  int _internal_lease_use_results_size() const;
  public:
  void clear_lease_use_results();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
      mutable_lease_use_results();
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* _internal_add_lease_use_results();
  public:
  const ::bosdyn::api::LeaseUseResult& lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* add_lease_use_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
      lease_use_results() const;

  // repeated string error_waypoint_ids = 5;
  int error_waypoint_ids_size() const;
  private:
  int _internal_error_waypoint_ids_size() const;
  public:
  void clear_error_waypoint_ids();
  const std::string& error_waypoint_ids(int index) const;
  std::string* mutable_error_waypoint_ids(int index);
  void set_error_waypoint_ids(int index, const std::string& value);
  void set_error_waypoint_ids(int index, std::string&& value);
  void set_error_waypoint_ids(int index, const char* value);
  void set_error_waypoint_ids(int index, const char* value, size_t size);
  std::string* add_error_waypoint_ids();
  void add_error_waypoint_ids(const std::string& value);
  void add_error_waypoint_ids(std::string&& value);
  void add_error_waypoint_ids(const char* value);
  void add_error_waypoint_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& error_waypoint_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_error_waypoint_ids();
  private:
  const std::string& _internal_error_waypoint_ids(int index) const;
  std::string* _internal_add_error_waypoint_ids();
  public:

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.RobotImpairedState impaired_state = 6;
  bool has_impaired_state() const;
  private:
  bool _internal_has_impaired_state() const;
  public:
  void clear_impaired_state();
  const ::bosdyn::api::RobotImpairedState& impaired_state() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RobotImpairedState* release_impaired_state();
  ::bosdyn::api::RobotImpairedState* mutable_impaired_state();
  void set_allocated_impaired_state(::bosdyn::api::RobotImpairedState* impaired_state);
  private:
  const ::bosdyn::api::RobotImpairedState& _internal_impaired_state() const;
  ::bosdyn::api::RobotImpairedState* _internal_mutable_impaired_state();
  public:
  void unsafe_arena_set_allocated_impaired_state(
      ::bosdyn::api::RobotImpairedState* impaired_state);
  ::bosdyn::api::RobotImpairedState* unsafe_arena_release_impaired_state();

  // .bosdyn.api.graph_nav.AreaCallbackServiceError area_callback_error = 10;
  bool has_area_callback_error() const;
  private:
  bool _internal_has_area_callback_error() const;
  public:
  void clear_area_callback_error();
  const ::bosdyn::api::graph_nav::AreaCallbackServiceError& area_callback_error() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::AreaCallbackServiceError* release_area_callback_error();
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* mutable_area_callback_error();
  void set_allocated_area_callback_error(::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error);
  private:
  const ::bosdyn::api::graph_nav::AreaCallbackServiceError& _internal_area_callback_error() const;
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* _internal_mutable_area_callback_error();
  public:
  void unsafe_arena_set_allocated_area_callback_error(
      ::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error);
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* unsafe_arena_release_area_callback_error();

  // .bosdyn.api.graph_nav.NavigateToResponse.Status status = 3;
  void clear_status();
  ::bosdyn::api::graph_nav::NavigateToResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::NavigateToResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::NavigateToResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::NavigateToResponse_Status value);
  public:

  // uint32 command_id = 4;
  void clear_command_id();
  uint32_t command_id() const;
  void set_command_id(uint32_t value);
  private:
  uint32_t _internal_command_id() const;
  void _internal_set_command_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.NavigateToResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult > lease_use_results_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> error_waypoint_ids_;
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::RobotImpairedState* impaired_state_;
    ::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error_;
    int status_;
    uint32_t command_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class RouteFollowingParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.RouteFollowingParams) */ {
 public:
  inline RouteFollowingParams() : RouteFollowingParams(nullptr) {}
  ~RouteFollowingParams() override;
  explicit PROTOBUF_CONSTEXPR RouteFollowingParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteFollowingParams(const RouteFollowingParams& from);
  RouteFollowingParams(RouteFollowingParams&& from) noexcept
    : RouteFollowingParams() {
    *this = ::std::move(from);
  }

  inline RouteFollowingParams& operator=(const RouteFollowingParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteFollowingParams& operator=(RouteFollowingParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteFollowingParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteFollowingParams* internal_default_instance() {
    return reinterpret_cast<const RouteFollowingParams*>(
               &_RouteFollowingParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RouteFollowingParams& a, RouteFollowingParams& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteFollowingParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteFollowingParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteFollowingParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteFollowingParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteFollowingParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RouteFollowingParams& from) {
    RouteFollowingParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteFollowingParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.RouteFollowingParams";
  }
  protected:
  explicit RouteFollowingParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RouteFollowingParams_StartRouteBehavior StartRouteBehavior;
  static constexpr StartRouteBehavior START_UNKNOWN =
    RouteFollowingParams_StartRouteBehavior_START_UNKNOWN;
  static constexpr StartRouteBehavior START_GOTO_START =
    RouteFollowingParams_StartRouteBehavior_START_GOTO_START;
  static constexpr StartRouteBehavior START_GOTO_ROUTE =
    RouteFollowingParams_StartRouteBehavior_START_GOTO_ROUTE;
  static constexpr StartRouteBehavior START_FAIL_WHEN_NOT_ON_ROUTE =
    RouteFollowingParams_StartRouteBehavior_START_FAIL_WHEN_NOT_ON_ROUTE;
  static inline bool StartRouteBehavior_IsValid(int value) {
    return RouteFollowingParams_StartRouteBehavior_IsValid(value);
  }
  static constexpr StartRouteBehavior StartRouteBehavior_MIN =
    RouteFollowingParams_StartRouteBehavior_StartRouteBehavior_MIN;
  static constexpr StartRouteBehavior StartRouteBehavior_MAX =
    RouteFollowingParams_StartRouteBehavior_StartRouteBehavior_MAX;
  static constexpr int StartRouteBehavior_ARRAYSIZE =
    RouteFollowingParams_StartRouteBehavior_StartRouteBehavior_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StartRouteBehavior_descriptor() {
    return RouteFollowingParams_StartRouteBehavior_descriptor();
  }
  template<typename T>
  static inline const std::string& StartRouteBehavior_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StartRouteBehavior>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StartRouteBehavior_Name.");
    return RouteFollowingParams_StartRouteBehavior_Name(enum_t_value);
  }
  static inline bool StartRouteBehavior_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StartRouteBehavior* value) {
    return RouteFollowingParams_StartRouteBehavior_Parse(name, value);
  }

  typedef RouteFollowingParams_ResumeBehavior ResumeBehavior;
  static constexpr ResumeBehavior RESUME_UNKNOWN =
    RouteFollowingParams_ResumeBehavior_RESUME_UNKNOWN;
  static constexpr ResumeBehavior RESUME_RETURN_TO_UNFINISHED_ROUTE =
    RouteFollowingParams_ResumeBehavior_RESUME_RETURN_TO_UNFINISHED_ROUTE;
  static constexpr ResumeBehavior RESUME_FAIL_WHEN_NOT_ON_ROUTE =
    RouteFollowingParams_ResumeBehavior_RESUME_FAIL_WHEN_NOT_ON_ROUTE;
  static inline bool ResumeBehavior_IsValid(int value) {
    return RouteFollowingParams_ResumeBehavior_IsValid(value);
  }
  static constexpr ResumeBehavior ResumeBehavior_MIN =
    RouteFollowingParams_ResumeBehavior_ResumeBehavior_MIN;
  static constexpr ResumeBehavior ResumeBehavior_MAX =
    RouteFollowingParams_ResumeBehavior_ResumeBehavior_MAX;
  static constexpr int ResumeBehavior_ARRAYSIZE =
    RouteFollowingParams_ResumeBehavior_ResumeBehavior_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ResumeBehavior_descriptor() {
    return RouteFollowingParams_ResumeBehavior_descriptor();
  }
  template<typename T>
  static inline const std::string& ResumeBehavior_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResumeBehavior>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResumeBehavior_Name.");
    return RouteFollowingParams_ResumeBehavior_Name(enum_t_value);
  }
  static inline bool ResumeBehavior_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResumeBehavior* value) {
    return RouteFollowingParams_ResumeBehavior_Parse(name, value);
  }

  typedef RouteFollowingParams_RouteBlockedBehavior RouteBlockedBehavior;
  static constexpr RouteBlockedBehavior ROUTE_BLOCKED_UNKNOWN =
    RouteFollowingParams_RouteBlockedBehavior_ROUTE_BLOCKED_UNKNOWN;
  static constexpr RouteBlockedBehavior ROUTE_BLOCKED_REROUTE =
    RouteFollowingParams_RouteBlockedBehavior_ROUTE_BLOCKED_REROUTE;
  static constexpr RouteBlockedBehavior ROUTE_BLOCKED_FAIL =
    RouteFollowingParams_RouteBlockedBehavior_ROUTE_BLOCKED_FAIL;
  static inline bool RouteBlockedBehavior_IsValid(int value) {
    return RouteFollowingParams_RouteBlockedBehavior_IsValid(value);
  }
  static constexpr RouteBlockedBehavior RouteBlockedBehavior_MIN =
    RouteFollowingParams_RouteBlockedBehavior_RouteBlockedBehavior_MIN;
  static constexpr RouteBlockedBehavior RouteBlockedBehavior_MAX =
    RouteFollowingParams_RouteBlockedBehavior_RouteBlockedBehavior_MAX;
  static constexpr int RouteBlockedBehavior_ARRAYSIZE =
    RouteFollowingParams_RouteBlockedBehavior_RouteBlockedBehavior_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RouteBlockedBehavior_descriptor() {
    return RouteFollowingParams_RouteBlockedBehavior_descriptor();
  }
  template<typename T>
  static inline const std::string& RouteBlockedBehavior_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RouteBlockedBehavior>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RouteBlockedBehavior_Name.");
    return RouteFollowingParams_RouteBlockedBehavior_Name(enum_t_value);
  }
  static inline bool RouteBlockedBehavior_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RouteBlockedBehavior* value) {
    return RouteFollowingParams_RouteBlockedBehavior_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNewCmdBehaviorFieldNumber = 1,
    kExistingCmdBehaviorFieldNumber = 2,
    kRouteBlockedBehaviorFieldNumber = 3,
  };
  // .bosdyn.api.graph_nav.RouteFollowingParams.StartRouteBehavior new_cmd_behavior = 1;
  void clear_new_cmd_behavior();
  ::bosdyn::api::graph_nav::RouteFollowingParams_StartRouteBehavior new_cmd_behavior() const;
  void set_new_cmd_behavior(::bosdyn::api::graph_nav::RouteFollowingParams_StartRouteBehavior value);
  private:
  ::bosdyn::api::graph_nav::RouteFollowingParams_StartRouteBehavior _internal_new_cmd_behavior() const;
  void _internal_set_new_cmd_behavior(::bosdyn::api::graph_nav::RouteFollowingParams_StartRouteBehavior value);
  public:

  // .bosdyn.api.graph_nav.RouteFollowingParams.ResumeBehavior existing_cmd_behavior = 2;
  void clear_existing_cmd_behavior();
  ::bosdyn::api::graph_nav::RouteFollowingParams_ResumeBehavior existing_cmd_behavior() const;
  void set_existing_cmd_behavior(::bosdyn::api::graph_nav::RouteFollowingParams_ResumeBehavior value);
  private:
  ::bosdyn::api::graph_nav::RouteFollowingParams_ResumeBehavior _internal_existing_cmd_behavior() const;
  void _internal_set_existing_cmd_behavior(::bosdyn::api::graph_nav::RouteFollowingParams_ResumeBehavior value);
  public:

  // .bosdyn.api.graph_nav.RouteFollowingParams.RouteBlockedBehavior route_blocked_behavior = 3;
  void clear_route_blocked_behavior();
  ::bosdyn::api::graph_nav::RouteFollowingParams_RouteBlockedBehavior route_blocked_behavior() const;
  void set_route_blocked_behavior(::bosdyn::api::graph_nav::RouteFollowingParams_RouteBlockedBehavior value);
  private:
  ::bosdyn::api::graph_nav::RouteFollowingParams_RouteBlockedBehavior _internal_route_blocked_behavior() const;
  void _internal_set_route_blocked_behavior(::bosdyn::api::graph_nav::RouteFollowingParams_RouteBlockedBehavior value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.RouteFollowingParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int new_cmd_behavior_;
    int existing_cmd_behavior_;
    int route_blocked_behavior_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class NavigateRouteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.NavigateRouteRequest) */ {
 public:
  inline NavigateRouteRequest() : NavigateRouteRequest(nullptr) {}
  ~NavigateRouteRequest() override;
  explicit PROTOBUF_CONSTEXPR NavigateRouteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigateRouteRequest(const NavigateRouteRequest& from);
  NavigateRouteRequest(NavigateRouteRequest&& from) noexcept
    : NavigateRouteRequest() {
    *this = ::std::move(from);
  }

  inline NavigateRouteRequest& operator=(const NavigateRouteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigateRouteRequest& operator=(NavigateRouteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigateRouteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigateRouteRequest* internal_default_instance() {
    return reinterpret_cast<const NavigateRouteRequest*>(
               &_NavigateRouteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(NavigateRouteRequest& a, NavigateRouteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigateRouteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigateRouteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigateRouteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigateRouteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NavigateRouteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NavigateRouteRequest& from) {
    NavigateRouteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigateRouteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.NavigateRouteRequest";
  }
  protected:
  explicit NavigateRouteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeasesFieldNumber = 2,
    kClockIdentifierFieldNumber = 6,
    kHeaderFieldNumber = 1,
    kRouteFieldNumber = 3,
    kTravelParamsFieldNumber = 4,
    kEndTimeFieldNumber = 5,
    kDestinationWaypointTformBodyGoalFieldNumber = 7,
    kRouteFollowParamsFieldNumber = 9,
    kCommandIdFieldNumber = 8,
  };
  // repeated .bosdyn.api.Lease leases = 2;
  int leases_size() const;
  private:
  int _internal_leases_size() const;
  public:
  void clear_leases();
  ::bosdyn::api::Lease* mutable_leases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
      mutable_leases();
  private:
  const ::bosdyn::api::Lease& _internal_leases(int index) const;
  ::bosdyn::api::Lease* _internal_add_leases();
  public:
  const ::bosdyn::api::Lease& leases(int index) const;
  ::bosdyn::api::Lease* add_leases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
      leases() const;

  // string clock_identifier = 6;
  void clear_clock_identifier();
  const std::string& clock_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clock_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clock_identifier();
  PROTOBUF_NODISCARD std::string* release_clock_identifier();
  void set_allocated_clock_identifier(std::string* clock_identifier);
  private:
  const std::string& _internal_clock_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clock_identifier(const std::string& value);
  std::string* _internal_mutable_clock_identifier();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.Route route = 3;
  bool has_route() const;
  private:
  bool _internal_has_route() const;
  public:
  void clear_route();
  const ::bosdyn::api::graph_nav::Route& route() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::Route* release_route();
  ::bosdyn::api::graph_nav::Route* mutable_route();
  void set_allocated_route(::bosdyn::api::graph_nav::Route* route);
  private:
  const ::bosdyn::api::graph_nav::Route& _internal_route() const;
  ::bosdyn::api::graph_nav::Route* _internal_mutable_route();
  public:
  void unsafe_arena_set_allocated_route(
      ::bosdyn::api::graph_nav::Route* route);
  ::bosdyn::api::graph_nav::Route* unsafe_arena_release_route();

  // .bosdyn.api.graph_nav.TravelParams travel_params = 4;
  bool has_travel_params() const;
  private:
  bool _internal_has_travel_params() const;
  public:
  void clear_travel_params();
  const ::bosdyn::api::graph_nav::TravelParams& travel_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::TravelParams* release_travel_params();
  ::bosdyn::api::graph_nav::TravelParams* mutable_travel_params();
  void set_allocated_travel_params(::bosdyn::api::graph_nav::TravelParams* travel_params);
  private:
  const ::bosdyn::api::graph_nav::TravelParams& _internal_travel_params() const;
  ::bosdyn::api::graph_nav::TravelParams* _internal_mutable_travel_params();
  public:
  void unsafe_arena_set_allocated_travel_params(
      ::bosdyn::api::graph_nav::TravelParams* travel_params);
  ::bosdyn::api::graph_nav::TravelParams* unsafe_arena_release_travel_params();

  // .google.protobuf.Timestamp end_time = 5;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // .bosdyn.api.SE2Pose destination_waypoint_tform_body_goal = 7;
  bool has_destination_waypoint_tform_body_goal() const;
  private:
  bool _internal_has_destination_waypoint_tform_body_goal() const;
  public:
  void clear_destination_waypoint_tform_body_goal();
  const ::bosdyn::api::SE2Pose& destination_waypoint_tform_body_goal() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE2Pose* release_destination_waypoint_tform_body_goal();
  ::bosdyn::api::SE2Pose* mutable_destination_waypoint_tform_body_goal();
  void set_allocated_destination_waypoint_tform_body_goal(::bosdyn::api::SE2Pose* destination_waypoint_tform_body_goal);
  private:
  const ::bosdyn::api::SE2Pose& _internal_destination_waypoint_tform_body_goal() const;
  ::bosdyn::api::SE2Pose* _internal_mutable_destination_waypoint_tform_body_goal();
  public:
  void unsafe_arena_set_allocated_destination_waypoint_tform_body_goal(
      ::bosdyn::api::SE2Pose* destination_waypoint_tform_body_goal);
  ::bosdyn::api::SE2Pose* unsafe_arena_release_destination_waypoint_tform_body_goal();

  // .bosdyn.api.graph_nav.RouteFollowingParams route_follow_params = 9;
  bool has_route_follow_params() const;
  private:
  bool _internal_has_route_follow_params() const;
  public:
  void clear_route_follow_params();
  const ::bosdyn::api::graph_nav::RouteFollowingParams& route_follow_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::RouteFollowingParams* release_route_follow_params();
  ::bosdyn::api::graph_nav::RouteFollowingParams* mutable_route_follow_params();
  void set_allocated_route_follow_params(::bosdyn::api::graph_nav::RouteFollowingParams* route_follow_params);
  private:
  const ::bosdyn::api::graph_nav::RouteFollowingParams& _internal_route_follow_params() const;
  ::bosdyn::api::graph_nav::RouteFollowingParams* _internal_mutable_route_follow_params();
  public:
  void unsafe_arena_set_allocated_route_follow_params(
      ::bosdyn::api::graph_nav::RouteFollowingParams* route_follow_params);
  ::bosdyn::api::graph_nav::RouteFollowingParams* unsafe_arena_release_route_follow_params();

  // uint32 command_id = 8;
  void clear_command_id();
  uint32_t command_id() const;
  void set_command_id(uint32_t value);
  private:
  uint32_t _internal_command_id() const;
  void _internal_set_command_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.NavigateRouteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease > leases_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clock_identifier_;
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::graph_nav::Route* route_;
    ::bosdyn::api::graph_nav::TravelParams* travel_params_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    ::bosdyn::api::SE2Pose* destination_waypoint_tform_body_goal_;
    ::bosdyn::api::graph_nav::RouteFollowingParams* route_follow_params_;
    uint32_t command_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class NavigateRouteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.NavigateRouteResponse) */ {
 public:
  inline NavigateRouteResponse() : NavigateRouteResponse(nullptr) {}
  ~NavigateRouteResponse() override;
  explicit PROTOBUF_CONSTEXPR NavigateRouteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigateRouteResponse(const NavigateRouteResponse& from);
  NavigateRouteResponse(NavigateRouteResponse&& from) noexcept
    : NavigateRouteResponse() {
    *this = ::std::move(from);
  }

  inline NavigateRouteResponse& operator=(const NavigateRouteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigateRouteResponse& operator=(NavigateRouteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigateRouteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigateRouteResponse* internal_default_instance() {
    return reinterpret_cast<const NavigateRouteResponse*>(
               &_NavigateRouteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NavigateRouteResponse& a, NavigateRouteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigateRouteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigateRouteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigateRouteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigateRouteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NavigateRouteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NavigateRouteResponse& from) {
    NavigateRouteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigateRouteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.NavigateRouteResponse";
  }
  protected:
  explicit NavigateRouteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NavigateRouteResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    NavigateRouteResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    NavigateRouteResponse_Status_STATUS_OK;
  static constexpr Status STATUS_NO_TIMESYNC =
    NavigateRouteResponse_Status_STATUS_NO_TIMESYNC;
  static constexpr Status STATUS_EXPIRED =
    NavigateRouteResponse_Status_STATUS_EXPIRED;
  static constexpr Status STATUS_TOO_DISTANT =
    NavigateRouteResponse_Status_STATUS_TOO_DISTANT;
  static constexpr Status STATUS_ROBOT_IMPAIRED =
    NavigateRouteResponse_Status_STATUS_ROBOT_IMPAIRED;
  static constexpr Status STATUS_RECORDING =
    NavigateRouteResponse_Status_STATUS_RECORDING;
  static constexpr Status STATUS_UNKNOWN_ROUTE_ELEMENTS =
    NavigateRouteResponse_Status_STATUS_UNKNOWN_ROUTE_ELEMENTS;
  static constexpr Status STATUS_INVALID_EDGE =
    NavigateRouteResponse_Status_STATUS_INVALID_EDGE;
  static constexpr Status STATUS_NO_PATH =
    NavigateRouteResponse_Status_STATUS_NO_PATH;
  static constexpr Status STATUS_CONSTRAINT_FAULT =
    NavigateRouteResponse_Status_STATUS_CONSTRAINT_FAULT;
  static constexpr Status STATUS_FEATURE_DESERT =
    NavigateRouteResponse_Status_STATUS_FEATURE_DESERT;
  static constexpr Status STATUS_LOST =
    NavigateRouteResponse_Status_STATUS_LOST;
  static constexpr Status STATUS_NOT_LOCALIZED_TO_ROUTE =
    NavigateRouteResponse_Status_STATUS_NOT_LOCALIZED_TO_ROUTE;
  static constexpr Status STATUS_NOT_LOCALIZED_TO_MAP =
    NavigateRouteResponse_Status_STATUS_NOT_LOCALIZED_TO_MAP;
  static constexpr Status STATUS_COULD_NOT_UPDATE_ROUTE =
    NavigateRouteResponse_Status_STATUS_COULD_NOT_UPDATE_ROUTE;
  static constexpr Status STATUS_STUCK =
    NavigateRouteResponse_Status_STATUS_STUCK;
  static constexpr Status STATUS_UNRECOGNIZED_COMMAND =
    NavigateRouteResponse_Status_STATUS_UNRECOGNIZED_COMMAND;
  static constexpr Status STATUS_AREA_CALLBACK_ERROR =
    NavigateRouteResponse_Status_STATUS_AREA_CALLBACK_ERROR;
  static inline bool Status_IsValid(int value) {
    return NavigateRouteResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    NavigateRouteResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    NavigateRouteResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    NavigateRouteResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return NavigateRouteResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return NavigateRouteResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return NavigateRouteResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeaseUseResultsFieldNumber = 2,
    kErrorWaypointIdsFieldNumber = 5,
    kErrorEdgeIdsFieldNumber = 6,
    kHeaderFieldNumber = 1,
    kImpairedStateFieldNumber = 7,
    kAreaCallbackErrorFieldNumber = 8,
    kStatusFieldNumber = 3,
    kCommandIdFieldNumber = 4,
  };
  // repeated .bosdyn.api.LeaseUseResult lease_use_results = 2;
  int lease_use_results_size() const;
  private:
  int _internal_lease_use_results_size() const;
  public:
  void clear_lease_use_results();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
      mutable_lease_use_results();
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* _internal_add_lease_use_results();
  public:
  const ::bosdyn::api::LeaseUseResult& lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* add_lease_use_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
      lease_use_results() const;

  // repeated string error_waypoint_ids = 5;
  int error_waypoint_ids_size() const;
  private:
  int _internal_error_waypoint_ids_size() const;
  public:
  void clear_error_waypoint_ids();
  const std::string& error_waypoint_ids(int index) const;
  std::string* mutable_error_waypoint_ids(int index);
  void set_error_waypoint_ids(int index, const std::string& value);
  void set_error_waypoint_ids(int index, std::string&& value);
  void set_error_waypoint_ids(int index, const char* value);
  void set_error_waypoint_ids(int index, const char* value, size_t size);
  std::string* add_error_waypoint_ids();
  void add_error_waypoint_ids(const std::string& value);
  void add_error_waypoint_ids(std::string&& value);
  void add_error_waypoint_ids(const char* value);
  void add_error_waypoint_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& error_waypoint_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_error_waypoint_ids();
  private:
  const std::string& _internal_error_waypoint_ids(int index) const;
  std::string* _internal_add_error_waypoint_ids();
  public:

  // repeated .bosdyn.api.graph_nav.Edge.Id error_edge_ids = 6;
  int error_edge_ids_size() const;
  private:
  int _internal_error_edge_ids_size() const;
  public:
  void clear_error_edge_ids();
  ::bosdyn::api::graph_nav::Edge_Id* mutable_error_edge_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::graph_nav::Edge_Id >*
      mutable_error_edge_ids();
  private:
  const ::bosdyn::api::graph_nav::Edge_Id& _internal_error_edge_ids(int index) const;
  ::bosdyn::api::graph_nav::Edge_Id* _internal_add_error_edge_ids();
  public:
  const ::bosdyn::api::graph_nav::Edge_Id& error_edge_ids(int index) const;
  ::bosdyn::api::graph_nav::Edge_Id* add_error_edge_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::graph_nav::Edge_Id >&
      error_edge_ids() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.RobotImpairedState impaired_state = 7;
  bool has_impaired_state() const;
  private:
  bool _internal_has_impaired_state() const;
  public:
  void clear_impaired_state();
  const ::bosdyn::api::RobotImpairedState& impaired_state() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RobotImpairedState* release_impaired_state();
  ::bosdyn::api::RobotImpairedState* mutable_impaired_state();
  void set_allocated_impaired_state(::bosdyn::api::RobotImpairedState* impaired_state);
  private:
  const ::bosdyn::api::RobotImpairedState& _internal_impaired_state() const;
  ::bosdyn::api::RobotImpairedState* _internal_mutable_impaired_state();
  public:
  void unsafe_arena_set_allocated_impaired_state(
      ::bosdyn::api::RobotImpairedState* impaired_state);
  ::bosdyn::api::RobotImpairedState* unsafe_arena_release_impaired_state();

  // .bosdyn.api.graph_nav.AreaCallbackServiceError area_callback_error = 8;
  bool has_area_callback_error() const;
  private:
  bool _internal_has_area_callback_error() const;
  public:
  void clear_area_callback_error();
  const ::bosdyn::api::graph_nav::AreaCallbackServiceError& area_callback_error() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::AreaCallbackServiceError* release_area_callback_error();
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* mutable_area_callback_error();
  void set_allocated_area_callback_error(::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error);
  private:
  const ::bosdyn::api::graph_nav::AreaCallbackServiceError& _internal_area_callback_error() const;
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* _internal_mutable_area_callback_error();
  public:
  void unsafe_arena_set_allocated_area_callback_error(
      ::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error);
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* unsafe_arena_release_area_callback_error();

  // .bosdyn.api.graph_nav.NavigateRouteResponse.Status status = 3;
  void clear_status();
  ::bosdyn::api::graph_nav::NavigateRouteResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::NavigateRouteResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::NavigateRouteResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::NavigateRouteResponse_Status value);
  public:

  // uint32 command_id = 4;
  void clear_command_id();
  uint32_t command_id() const;
  void set_command_id(uint32_t value);
  private:
  uint32_t _internal_command_id() const;
  void _internal_set_command_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.NavigateRouteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult > lease_use_results_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> error_waypoint_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::graph_nav::Edge_Id > error_edge_ids_;
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::RobotImpairedState* impaired_state_;
    ::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error_;
    int status_;
    uint32_t command_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class NavigateToAnchorRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.NavigateToAnchorRequest) */ {
 public:
  inline NavigateToAnchorRequest() : NavigateToAnchorRequest(nullptr) {}
  ~NavigateToAnchorRequest() override;
  explicit PROTOBUF_CONSTEXPR NavigateToAnchorRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigateToAnchorRequest(const NavigateToAnchorRequest& from);
  NavigateToAnchorRequest(NavigateToAnchorRequest&& from) noexcept
    : NavigateToAnchorRequest() {
    *this = ::std::move(from);
  }

  inline NavigateToAnchorRequest& operator=(const NavigateToAnchorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigateToAnchorRequest& operator=(NavigateToAnchorRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigateToAnchorRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigateToAnchorRequest* internal_default_instance() {
    return reinterpret_cast<const NavigateToAnchorRequest*>(
               &_NavigateToAnchorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NavigateToAnchorRequest& a, NavigateToAnchorRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigateToAnchorRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigateToAnchorRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigateToAnchorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigateToAnchorRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NavigateToAnchorRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NavigateToAnchorRequest& from) {
    NavigateToAnchorRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigateToAnchorRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.NavigateToAnchorRequest";
  }
  protected:
  explicit NavigateToAnchorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeasesFieldNumber = 2,
    kClockIdentifierFieldNumber = 9,
    kHeaderFieldNumber = 1,
    kSeedTformGoalFieldNumber = 3,
    kGoalWaypointRtSeedEwrtSeedToleranceFieldNumber = 4,
    kRouteParamsFieldNumber = 6,
    kTravelParamsFieldNumber = 7,
    kEndTimeFieldNumber = 8,
    kCommandIdFieldNumber = 10,
  };
  // repeated .bosdyn.api.Lease leases = 2;
  int leases_size() const;
  private:
  int _internal_leases_size() const;
  public:
  void clear_leases();
  ::bosdyn::api::Lease* mutable_leases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
      mutable_leases();
  private:
  const ::bosdyn::api::Lease& _internal_leases(int index) const;
  ::bosdyn::api::Lease* _internal_add_leases();
  public:
  const ::bosdyn::api::Lease& leases(int index) const;
  ::bosdyn::api::Lease* add_leases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
      leases() const;

  // string clock_identifier = 9;
  void clear_clock_identifier();
  const std::string& clock_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clock_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clock_identifier();
  PROTOBUF_NODISCARD std::string* release_clock_identifier();
  void set_allocated_clock_identifier(std::string* clock_identifier);
  private:
  const std::string& _internal_clock_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clock_identifier(const std::string& value);
  std::string* _internal_mutable_clock_identifier();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.SE3Pose seed_tform_goal = 3;
  bool has_seed_tform_goal() const;
  private:
  bool _internal_has_seed_tform_goal() const;
  public:
  void clear_seed_tform_goal();
  const ::bosdyn::api::SE3Pose& seed_tform_goal() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Pose* release_seed_tform_goal();
  ::bosdyn::api::SE3Pose* mutable_seed_tform_goal();
  void set_allocated_seed_tform_goal(::bosdyn::api::SE3Pose* seed_tform_goal);
  private:
  const ::bosdyn::api::SE3Pose& _internal_seed_tform_goal() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_seed_tform_goal();
  public:
  void unsafe_arena_set_allocated_seed_tform_goal(
      ::bosdyn::api::SE3Pose* seed_tform_goal);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_seed_tform_goal();

  // .bosdyn.api.Vec3 goal_waypoint_rt_seed_ewrt_seed_tolerance = 4;
  bool has_goal_waypoint_rt_seed_ewrt_seed_tolerance() const;
  private:
  bool _internal_has_goal_waypoint_rt_seed_ewrt_seed_tolerance() const;
  public:
  void clear_goal_waypoint_rt_seed_ewrt_seed_tolerance();
  const ::bosdyn::api::Vec3& goal_waypoint_rt_seed_ewrt_seed_tolerance() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_goal_waypoint_rt_seed_ewrt_seed_tolerance();
  ::bosdyn::api::Vec3* mutable_goal_waypoint_rt_seed_ewrt_seed_tolerance();
  void set_allocated_goal_waypoint_rt_seed_ewrt_seed_tolerance(::bosdyn::api::Vec3* goal_waypoint_rt_seed_ewrt_seed_tolerance);
  private:
  const ::bosdyn::api::Vec3& _internal_goal_waypoint_rt_seed_ewrt_seed_tolerance() const;
  ::bosdyn::api::Vec3* _internal_mutable_goal_waypoint_rt_seed_ewrt_seed_tolerance();
  public:
  void unsafe_arena_set_allocated_goal_waypoint_rt_seed_ewrt_seed_tolerance(
      ::bosdyn::api::Vec3* goal_waypoint_rt_seed_ewrt_seed_tolerance);
  ::bosdyn::api::Vec3* unsafe_arena_release_goal_waypoint_rt_seed_ewrt_seed_tolerance();

  // .bosdyn.api.graph_nav.RouteGenParams route_params = 6;
  bool has_route_params() const;
  private:
  bool _internal_has_route_params() const;
  public:
  void clear_route_params();
  const ::bosdyn::api::graph_nav::RouteGenParams& route_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::RouteGenParams* release_route_params();
  ::bosdyn::api::graph_nav::RouteGenParams* mutable_route_params();
  void set_allocated_route_params(::bosdyn::api::graph_nav::RouteGenParams* route_params);
  private:
  const ::bosdyn::api::graph_nav::RouteGenParams& _internal_route_params() const;
  ::bosdyn::api::graph_nav::RouteGenParams* _internal_mutable_route_params();
  public:
  void unsafe_arena_set_allocated_route_params(
      ::bosdyn::api::graph_nav::RouteGenParams* route_params);
  ::bosdyn::api::graph_nav::RouteGenParams* unsafe_arena_release_route_params();

  // .bosdyn.api.graph_nav.TravelParams travel_params = 7;
  bool has_travel_params() const;
  private:
  bool _internal_has_travel_params() const;
  public:
  void clear_travel_params();
  const ::bosdyn::api::graph_nav::TravelParams& travel_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::TravelParams* release_travel_params();
  ::bosdyn::api::graph_nav::TravelParams* mutable_travel_params();
  void set_allocated_travel_params(::bosdyn::api::graph_nav::TravelParams* travel_params);
  private:
  const ::bosdyn::api::graph_nav::TravelParams& _internal_travel_params() const;
  ::bosdyn::api::graph_nav::TravelParams* _internal_mutable_travel_params();
  public:
  void unsafe_arena_set_allocated_travel_params(
      ::bosdyn::api::graph_nav::TravelParams* travel_params);
  ::bosdyn::api::graph_nav::TravelParams* unsafe_arena_release_travel_params();

  // .google.protobuf.Timestamp end_time = 8;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // uint32 command_id = 10;
  void clear_command_id();
  uint32_t command_id() const;
  void set_command_id(uint32_t value);
  private:
  uint32_t _internal_command_id() const;
  void _internal_set_command_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.NavigateToAnchorRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease > leases_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clock_identifier_;
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::SE3Pose* seed_tform_goal_;
    ::bosdyn::api::Vec3* goal_waypoint_rt_seed_ewrt_seed_tolerance_;
    ::bosdyn::api::graph_nav::RouteGenParams* route_params_;
    ::bosdyn::api::graph_nav::TravelParams* travel_params_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    uint32_t command_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class NavigateToAnchorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.NavigateToAnchorResponse) */ {
 public:
  inline NavigateToAnchorResponse() : NavigateToAnchorResponse(nullptr) {}
  ~NavigateToAnchorResponse() override;
  explicit PROTOBUF_CONSTEXPR NavigateToAnchorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigateToAnchorResponse(const NavigateToAnchorResponse& from);
  NavigateToAnchorResponse(NavigateToAnchorResponse&& from) noexcept
    : NavigateToAnchorResponse() {
    *this = ::std::move(from);
  }

  inline NavigateToAnchorResponse& operator=(const NavigateToAnchorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigateToAnchorResponse& operator=(NavigateToAnchorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigateToAnchorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigateToAnchorResponse* internal_default_instance() {
    return reinterpret_cast<const NavigateToAnchorResponse*>(
               &_NavigateToAnchorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(NavigateToAnchorResponse& a, NavigateToAnchorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigateToAnchorResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigateToAnchorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigateToAnchorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigateToAnchorResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NavigateToAnchorResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NavigateToAnchorResponse& from) {
    NavigateToAnchorResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigateToAnchorResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.NavigateToAnchorResponse";
  }
  protected:
  explicit NavigateToAnchorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NavigateToAnchorResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    NavigateToAnchorResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    NavigateToAnchorResponse_Status_STATUS_OK;
  static constexpr Status STATUS_NO_TIMESYNC =
    NavigateToAnchorResponse_Status_STATUS_NO_TIMESYNC;
  static constexpr Status STATUS_EXPIRED =
    NavigateToAnchorResponse_Status_STATUS_EXPIRED;
  static constexpr Status STATUS_TOO_DISTANT =
    NavigateToAnchorResponse_Status_STATUS_TOO_DISTANT;
  static constexpr Status STATUS_ROBOT_IMPAIRED =
    NavigateToAnchorResponse_Status_STATUS_ROBOT_IMPAIRED;
  static constexpr Status STATUS_RECORDING =
    NavigateToAnchorResponse_Status_STATUS_RECORDING;
  static constexpr Status STATUS_NO_ANCHORING =
    NavigateToAnchorResponse_Status_STATUS_NO_ANCHORING;
  static constexpr Status STATUS_NO_PATH =
    NavigateToAnchorResponse_Status_STATUS_NO_PATH;
  static constexpr Status STATUS_FEATURE_DESERT =
    NavigateToAnchorResponse_Status_STATUS_FEATURE_DESERT;
  static constexpr Status STATUS_LOST =
    NavigateToAnchorResponse_Status_STATUS_LOST;
  static constexpr Status STATUS_NOT_LOCALIZED_TO_MAP =
    NavigateToAnchorResponse_Status_STATUS_NOT_LOCALIZED_TO_MAP;
  static constexpr Status STATUS_COULD_NOT_UPDATE_ROUTE =
    NavigateToAnchorResponse_Status_STATUS_COULD_NOT_UPDATE_ROUTE;
  static constexpr Status STATUS_STUCK =
    NavigateToAnchorResponse_Status_STATUS_STUCK;
  static constexpr Status STATUS_UNRECOGNIZED_COMMAND =
    NavigateToAnchorResponse_Status_STATUS_UNRECOGNIZED_COMMAND;
  static constexpr Status STATUS_INVALID_POSE =
    NavigateToAnchorResponse_Status_STATUS_INVALID_POSE;
  static constexpr Status STATUS_AREA_CALLBACK_ERROR =
    NavigateToAnchorResponse_Status_STATUS_AREA_CALLBACK_ERROR;
  static inline bool Status_IsValid(int value) {
    return NavigateToAnchorResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    NavigateToAnchorResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    NavigateToAnchorResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    NavigateToAnchorResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return NavigateToAnchorResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return NavigateToAnchorResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return NavigateToAnchorResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeaseUseResultsFieldNumber = 2,
    kErrorWaypointIdsFieldNumber = 5,
    kHeaderFieldNumber = 1,
    kImpairedStateFieldNumber = 6,
    kAreaCallbackErrorFieldNumber = 7,
    kStatusFieldNumber = 3,
    kCommandIdFieldNumber = 4,
  };
  // repeated .bosdyn.api.LeaseUseResult lease_use_results = 2;
  int lease_use_results_size() const;
  private:
  int _internal_lease_use_results_size() const;
  public:
  void clear_lease_use_results();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
      mutable_lease_use_results();
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* _internal_add_lease_use_results();
  public:
  const ::bosdyn::api::LeaseUseResult& lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* add_lease_use_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
      lease_use_results() const;

  // repeated string error_waypoint_ids = 5;
  int error_waypoint_ids_size() const;
  private:
  int _internal_error_waypoint_ids_size() const;
  public:
  void clear_error_waypoint_ids();
  const std::string& error_waypoint_ids(int index) const;
  std::string* mutable_error_waypoint_ids(int index);
  void set_error_waypoint_ids(int index, const std::string& value);
  void set_error_waypoint_ids(int index, std::string&& value);
  void set_error_waypoint_ids(int index, const char* value);
  void set_error_waypoint_ids(int index, const char* value, size_t size);
  std::string* add_error_waypoint_ids();
  void add_error_waypoint_ids(const std::string& value);
  void add_error_waypoint_ids(std::string&& value);
  void add_error_waypoint_ids(const char* value);
  void add_error_waypoint_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& error_waypoint_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_error_waypoint_ids();
  private:
  const std::string& _internal_error_waypoint_ids(int index) const;
  std::string* _internal_add_error_waypoint_ids();
  public:

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.RobotImpairedState impaired_state = 6;
  bool has_impaired_state() const;
  private:
  bool _internal_has_impaired_state() const;
  public:
  void clear_impaired_state();
  const ::bosdyn::api::RobotImpairedState& impaired_state() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RobotImpairedState* release_impaired_state();
  ::bosdyn::api::RobotImpairedState* mutable_impaired_state();
  void set_allocated_impaired_state(::bosdyn::api::RobotImpairedState* impaired_state);
  private:
  const ::bosdyn::api::RobotImpairedState& _internal_impaired_state() const;
  ::bosdyn::api::RobotImpairedState* _internal_mutable_impaired_state();
  public:
  void unsafe_arena_set_allocated_impaired_state(
      ::bosdyn::api::RobotImpairedState* impaired_state);
  ::bosdyn::api::RobotImpairedState* unsafe_arena_release_impaired_state();

  // .bosdyn.api.graph_nav.AreaCallbackServiceError area_callback_error = 7;
  bool has_area_callback_error() const;
  private:
  bool _internal_has_area_callback_error() const;
  public:
  void clear_area_callback_error();
  const ::bosdyn::api::graph_nav::AreaCallbackServiceError& area_callback_error() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::AreaCallbackServiceError* release_area_callback_error();
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* mutable_area_callback_error();
  void set_allocated_area_callback_error(::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error);
  private:
  const ::bosdyn::api::graph_nav::AreaCallbackServiceError& _internal_area_callback_error() const;
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* _internal_mutable_area_callback_error();
  public:
  void unsafe_arena_set_allocated_area_callback_error(
      ::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error);
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* unsafe_arena_release_area_callback_error();

  // .bosdyn.api.graph_nav.NavigateToAnchorResponse.Status status = 3;
  void clear_status();
  ::bosdyn::api::graph_nav::NavigateToAnchorResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::NavigateToAnchorResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::NavigateToAnchorResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::NavigateToAnchorResponse_Status value);
  public:

  // uint32 command_id = 4;
  void clear_command_id();
  uint32_t command_id() const;
  void set_command_id(uint32_t value);
  private:
  uint32_t _internal_command_id() const;
  void _internal_set_command_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.NavigateToAnchorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult > lease_use_results_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> error_waypoint_ids_;
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::RobotImpairedState* impaired_state_;
    ::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error_;
    int status_;
    uint32_t command_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class NavigationFeedbackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.NavigationFeedbackRequest) */ {
 public:
  inline NavigationFeedbackRequest() : NavigationFeedbackRequest(nullptr) {}
  ~NavigationFeedbackRequest() override;
  explicit PROTOBUF_CONSTEXPR NavigationFeedbackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigationFeedbackRequest(const NavigationFeedbackRequest& from);
  NavigationFeedbackRequest(NavigationFeedbackRequest&& from) noexcept
    : NavigationFeedbackRequest() {
    *this = ::std::move(from);
  }

  inline NavigationFeedbackRequest& operator=(const NavigationFeedbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationFeedbackRequest& operator=(NavigationFeedbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigationFeedbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigationFeedbackRequest* internal_default_instance() {
    return reinterpret_cast<const NavigationFeedbackRequest*>(
               &_NavigationFeedbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(NavigationFeedbackRequest& a, NavigationFeedbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationFeedbackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationFeedbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigationFeedbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigationFeedbackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NavigationFeedbackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NavigationFeedbackRequest& from) {
    NavigationFeedbackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationFeedbackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.NavigationFeedbackRequest";
  }
  protected:
  explicit NavigationFeedbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kCommandIdFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // uint32 command_id = 2;
  void clear_command_id();
  uint32_t command_id() const;
  void set_command_id(uint32_t value);
  private:
  uint32_t _internal_command_id() const;
  void _internal_set_command_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.NavigationFeedbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    uint32_t command_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUse, 
    std::string, ::bosdyn::api::graph_nav::AreaCallbackError,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUse, 
    std::string, ::bosdyn::api::graph_nav::AreaCallbackError,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUse& other);
  static const NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUse*>(&_NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.graph_nav.NavigationFeedbackResponse.AreaCallbackErrorsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};

// -------------------------------------------------------------------

class NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUse, 
    std::string, ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUse, 
    std::string, ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUse& other);
  static const NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUse*>(&_NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformationEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};

// -------------------------------------------------------------------

class NavigationFeedbackResponse_ActiveRegionInformation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation) */ {
 public:
  inline NavigationFeedbackResponse_ActiveRegionInformation() : NavigationFeedbackResponse_ActiveRegionInformation(nullptr) {}
  ~NavigationFeedbackResponse_ActiveRegionInformation() override;
  explicit PROTOBUF_CONSTEXPR NavigationFeedbackResponse_ActiveRegionInformation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigationFeedbackResponse_ActiveRegionInformation(const NavigationFeedbackResponse_ActiveRegionInformation& from);
  NavigationFeedbackResponse_ActiveRegionInformation(NavigationFeedbackResponse_ActiveRegionInformation&& from) noexcept
    : NavigationFeedbackResponse_ActiveRegionInformation() {
    *this = ::std::move(from);
  }

  inline NavigationFeedbackResponse_ActiveRegionInformation& operator=(const NavigationFeedbackResponse_ActiveRegionInformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationFeedbackResponse_ActiveRegionInformation& operator=(NavigationFeedbackResponse_ActiveRegionInformation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigationFeedbackResponse_ActiveRegionInformation& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigationFeedbackResponse_ActiveRegionInformation* internal_default_instance() {
    return reinterpret_cast<const NavigationFeedbackResponse_ActiveRegionInformation*>(
               &_NavigationFeedbackResponse_ActiveRegionInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(NavigationFeedbackResponse_ActiveRegionInformation& a, NavigationFeedbackResponse_ActiveRegionInformation& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationFeedbackResponse_ActiveRegionInformation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationFeedbackResponse_ActiveRegionInformation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigationFeedbackResponse_ActiveRegionInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigationFeedbackResponse_ActiveRegionInformation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NavigationFeedbackResponse_ActiveRegionInformation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NavigationFeedbackResponse_ActiveRegionInformation& from) {
    NavigationFeedbackResponse_ActiveRegionInformation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationFeedbackResponse_ActiveRegionInformation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation";
  }
  protected:
  explicit NavigationFeedbackResponse_ActiveRegionInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus AreaCallbackStatus;
  static constexpr AreaCallbackStatus STATUS_UNKNOWN =
    NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_STATUS_UNKNOWN;
  static constexpr AreaCallbackStatus STATUS_NAVIGATING =
    NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_STATUS_NAVIGATING;
  static constexpr AreaCallbackStatus STATUS_WAITING =
    NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_STATUS_WAITING;
  static constexpr AreaCallbackStatus STATUS_CALLBACK_IN_CONTROL =
    NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_STATUS_CALLBACK_IN_CONTROL;
  static inline bool AreaCallbackStatus_IsValid(int value) {
    return NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_IsValid(value);
  }
  static constexpr AreaCallbackStatus AreaCallbackStatus_MIN =
    NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_AreaCallbackStatus_MIN;
  static constexpr AreaCallbackStatus AreaCallbackStatus_MAX =
    NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_AreaCallbackStatus_MAX;
  static constexpr int AreaCallbackStatus_ARRAYSIZE =
    NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_AreaCallbackStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AreaCallbackStatus_descriptor() {
    return NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& AreaCallbackStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AreaCallbackStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AreaCallbackStatus_Name.");
    return NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_Name(enum_t_value);
  }
  static inline bool AreaCallbackStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AreaCallbackStatus* value) {
    return NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 1,
    kServiceNameFieldNumber = 2,
    kRegionStatusFieldNumber = 3,
  };
  // string description = 1;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string service_name = 2;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // .bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation.AreaCallbackStatus region_status = 3;
  void clear_region_status();
  ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus region_status() const;
  void set_region_status(::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus value);
  private:
  ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus _internal_region_status() const;
  void _internal_set_region_status(::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    int region_status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class NavigationFeedbackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.NavigationFeedbackResponse) */ {
 public:
  inline NavigationFeedbackResponse() : NavigationFeedbackResponse(nullptr) {}
  ~NavigationFeedbackResponse() override;
  explicit PROTOBUF_CONSTEXPR NavigationFeedbackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigationFeedbackResponse(const NavigationFeedbackResponse& from);
  NavigationFeedbackResponse(NavigationFeedbackResponse&& from) noexcept
    : NavigationFeedbackResponse() {
    *this = ::std::move(from);
  }

  inline NavigationFeedbackResponse& operator=(const NavigationFeedbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationFeedbackResponse& operator=(NavigationFeedbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigationFeedbackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigationFeedbackResponse* internal_default_instance() {
    return reinterpret_cast<const NavigationFeedbackResponse*>(
               &_NavigationFeedbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(NavigationFeedbackResponse& a, NavigationFeedbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationFeedbackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationFeedbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigationFeedbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigationFeedbackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NavigationFeedbackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NavigationFeedbackResponse& from) {
    NavigationFeedbackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationFeedbackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.NavigationFeedbackResponse";
  }
  protected:
  explicit NavigationFeedbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NavigationFeedbackResponse_ActiveRegionInformation ActiveRegionInformation;

  typedef NavigationFeedbackResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    NavigationFeedbackResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_FOLLOWING_ROUTE =
    NavigationFeedbackResponse_Status_STATUS_FOLLOWING_ROUTE;
  static constexpr Status STATUS_REACHED_GOAL =
    NavigationFeedbackResponse_Status_STATUS_REACHED_GOAL;
  static constexpr Status STATUS_NO_ROUTE =
    NavigationFeedbackResponse_Status_STATUS_NO_ROUTE;
  static constexpr Status STATUS_NO_LOCALIZATION =
    NavigationFeedbackResponse_Status_STATUS_NO_LOCALIZATION;
  static constexpr Status STATUS_LOST =
    NavigationFeedbackResponse_Status_STATUS_LOST;
  static constexpr Status STATUS_STUCK =
    NavigationFeedbackResponse_Status_STATUS_STUCK;
  static constexpr Status STATUS_COMMAND_TIMED_OUT =
    NavigationFeedbackResponse_Status_STATUS_COMMAND_TIMED_OUT;
  static constexpr Status STATUS_ROBOT_IMPAIRED =
    NavigationFeedbackResponse_Status_STATUS_ROBOT_IMPAIRED;
  static constexpr Status STATUS_CONSTRAINT_FAULT =
    NavigationFeedbackResponse_Status_STATUS_CONSTRAINT_FAULT;
  static constexpr Status STATUS_COMMAND_OVERRIDDEN =
    NavigationFeedbackResponse_Status_STATUS_COMMAND_OVERRIDDEN;
  static constexpr Status STATUS_NOT_LOCALIZED_TO_ROUTE =
    NavigationFeedbackResponse_Status_STATUS_NOT_LOCALIZED_TO_ROUTE;
  static constexpr Status STATUS_LEASE_ERROR =
    NavigationFeedbackResponse_Status_STATUS_LEASE_ERROR;
  static constexpr Status STATUS_AREA_CALLBACK_ERROR =
    NavigationFeedbackResponse_Status_STATUS_AREA_CALLBACK_ERROR;
  static inline bool Status_IsValid(int value) {
    return NavigationFeedbackResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    NavigationFeedbackResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    NavigationFeedbackResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    NavigationFeedbackResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return NavigationFeedbackResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return NavigationFeedbackResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return NavigationFeedbackResponse_Status_Parse(name, value);
  }

  typedef NavigationFeedbackResponse_RouteFollowingStatus RouteFollowingStatus;
  static constexpr RouteFollowingStatus ROUTE_FOLLOWING_STATUS_UNKNOWN =
    NavigationFeedbackResponse_RouteFollowingStatus_ROUTE_FOLLOWING_STATUS_UNKNOWN;
  static constexpr RouteFollowingStatus ROUTE_FOLLOWING_STATUS_FOLLOWING_ROUTE =
    NavigationFeedbackResponse_RouteFollowingStatus_ROUTE_FOLLOWING_STATUS_FOLLOWING_ROUTE;
  static constexpr RouteFollowingStatus ROUTE_FOLLOWING_STATUS_RETURNING_TO_ROUTE =
    NavigationFeedbackResponse_RouteFollowingStatus_ROUTE_FOLLOWING_STATUS_RETURNING_TO_ROUTE;
  static constexpr RouteFollowingStatus ROUTE_FOLLOWING_STATUS_FOLLOWING_ALTERNATE_ROUTE =
    NavigationFeedbackResponse_RouteFollowingStatus_ROUTE_FOLLOWING_STATUS_FOLLOWING_ALTERNATE_ROUTE;
  static constexpr RouteFollowingStatus ROUTE_FOLLOWING_STATUS_EXPLORING =
    NavigationFeedbackResponse_RouteFollowingStatus_ROUTE_FOLLOWING_STATUS_EXPLORING;
  static inline bool RouteFollowingStatus_IsValid(int value) {
    return NavigationFeedbackResponse_RouteFollowingStatus_IsValid(value);
  }
  static constexpr RouteFollowingStatus RouteFollowingStatus_MIN =
    NavigationFeedbackResponse_RouteFollowingStatus_RouteFollowingStatus_MIN;
  static constexpr RouteFollowingStatus RouteFollowingStatus_MAX =
    NavigationFeedbackResponse_RouteFollowingStatus_RouteFollowingStatus_MAX;
  static constexpr int RouteFollowingStatus_ARRAYSIZE =
    NavigationFeedbackResponse_RouteFollowingStatus_RouteFollowingStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RouteFollowingStatus_descriptor() {
    return NavigationFeedbackResponse_RouteFollowingStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& RouteFollowingStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RouteFollowingStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RouteFollowingStatus_Name.");
    return NavigationFeedbackResponse_RouteFollowingStatus_Name(enum_t_value);
  }
  static inline bool RouteFollowingStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RouteFollowingStatus* value) {
    return NavigationFeedbackResponse_RouteFollowingStatus_Parse(name, value);
  }

  typedef NavigationFeedbackResponse_BlockageStatus BlockageStatus;
  static constexpr BlockageStatus BLOCKAGE_STATUS_UNKNOWN =
    NavigationFeedbackResponse_BlockageStatus_BLOCKAGE_STATUS_UNKNOWN;
  static constexpr BlockageStatus BLOCKAGE_STATUS_ROUTE_CLEAR =
    NavigationFeedbackResponse_BlockageStatus_BLOCKAGE_STATUS_ROUTE_CLEAR;
  static constexpr BlockageStatus BLOCKAGE_STATUS_ROUTE_BLOCKED_TEMPORARILY =
    NavigationFeedbackResponse_BlockageStatus_BLOCKAGE_STATUS_ROUTE_BLOCKED_TEMPORARILY;
  static constexpr BlockageStatus BLOCKAGE_STATUS_STUCK =
    NavigationFeedbackResponse_BlockageStatus_BLOCKAGE_STATUS_STUCK;
  static inline bool BlockageStatus_IsValid(int value) {
    return NavigationFeedbackResponse_BlockageStatus_IsValid(value);
  }
  static constexpr BlockageStatus BlockageStatus_MIN =
    NavigationFeedbackResponse_BlockageStatus_BlockageStatus_MIN;
  static constexpr BlockageStatus BlockageStatus_MAX =
    NavigationFeedbackResponse_BlockageStatus_BlockageStatus_MAX;
  static constexpr int BlockageStatus_ARRAYSIZE =
    NavigationFeedbackResponse_BlockageStatus_BlockageStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BlockageStatus_descriptor() {
    return NavigationFeedbackResponse_BlockageStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& BlockageStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BlockageStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BlockageStatus_Name.");
    return NavigationFeedbackResponse_BlockageStatus_Name(enum_t_value);
  }
  static inline bool BlockageStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BlockageStatus* value) {
    return NavigationFeedbackResponse_BlockageStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAreaCallbackErrorsFieldNumber = 9,
    kActiveRegionInformationFieldNumber = 10,
    kHeaderFieldNumber = 1,
    kRemainingRouteFieldNumber = 3,
    kLastKoTformGoalFieldNumber = 5,
    kImpairedStateFieldNumber = 6,
    kStatusFieldNumber = 2,
    kCommandIdFieldNumber = 4,
    kBodyMovementStatusFieldNumber = 7,
    kPathFollowingModeFieldNumber = 8,
    kRouteFollowingStatusFieldNumber = 1000,
    kBlockageStatusFieldNumber = 1001,
  };
  // map<string, .bosdyn.api.graph_nav.AreaCallbackError> area_callback_errors = 9;
  int area_callback_errors_size() const;
  private:
  int _internal_area_callback_errors_size() const;
  public:
  void clear_area_callback_errors();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::graph_nav::AreaCallbackError >&
      _internal_area_callback_errors() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::graph_nav::AreaCallbackError >*
      _internal_mutable_area_callback_errors();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::graph_nav::AreaCallbackError >&
      area_callback_errors() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::graph_nav::AreaCallbackError >*
      mutable_area_callback_errors();

  // map<string, .bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation> active_region_information = 10;
  int active_region_information_size() const;
  private:
  int _internal_active_region_information_size() const;
  public:
  void clear_active_region_information();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation >&
      _internal_active_region_information() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation >*
      _internal_mutable_active_region_information();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation >&
      active_region_information() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation >*
      mutable_active_region_information();

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.Route remaining_route = 3;
  bool has_remaining_route() const;
  private:
  bool _internal_has_remaining_route() const;
  public:
  void clear_remaining_route();
  const ::bosdyn::api::graph_nav::Route& remaining_route() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::Route* release_remaining_route();
  ::bosdyn::api::graph_nav::Route* mutable_remaining_route();
  void set_allocated_remaining_route(::bosdyn::api::graph_nav::Route* remaining_route);
  private:
  const ::bosdyn::api::graph_nav::Route& _internal_remaining_route() const;
  ::bosdyn::api::graph_nav::Route* _internal_mutable_remaining_route();
  public:
  void unsafe_arena_set_allocated_remaining_route(
      ::bosdyn::api::graph_nav::Route* remaining_route);
  ::bosdyn::api::graph_nav::Route* unsafe_arena_release_remaining_route();

  // .bosdyn.api.SE3Pose last_ko_tform_goal = 5;
  bool has_last_ko_tform_goal() const;
  private:
  bool _internal_has_last_ko_tform_goal() const;
  public:
  void clear_last_ko_tform_goal();
  const ::bosdyn::api::SE3Pose& last_ko_tform_goal() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Pose* release_last_ko_tform_goal();
  ::bosdyn::api::SE3Pose* mutable_last_ko_tform_goal();
  void set_allocated_last_ko_tform_goal(::bosdyn::api::SE3Pose* last_ko_tform_goal);
  private:
  const ::bosdyn::api::SE3Pose& _internal_last_ko_tform_goal() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_last_ko_tform_goal();
  public:
  void unsafe_arena_set_allocated_last_ko_tform_goal(
      ::bosdyn::api::SE3Pose* last_ko_tform_goal);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_last_ko_tform_goal();

  // .bosdyn.api.RobotImpairedState impaired_state = 6;
  bool has_impaired_state() const;
  private:
  bool _internal_has_impaired_state() const;
  public:
  void clear_impaired_state();
  const ::bosdyn::api::RobotImpairedState& impaired_state() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RobotImpairedState* release_impaired_state();
  ::bosdyn::api::RobotImpairedState* mutable_impaired_state();
  void set_allocated_impaired_state(::bosdyn::api::RobotImpairedState* impaired_state);
  private:
  const ::bosdyn::api::RobotImpairedState& _internal_impaired_state() const;
  ::bosdyn::api::RobotImpairedState* _internal_mutable_impaired_state();
  public:
  void unsafe_arena_set_allocated_impaired_state(
      ::bosdyn::api::RobotImpairedState* impaired_state);
  ::bosdyn::api::RobotImpairedState* unsafe_arena_release_impaired_state();

  // .bosdyn.api.graph_nav.NavigationFeedbackResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::graph_nav::NavigationFeedbackResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::NavigationFeedbackResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::NavigationFeedbackResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::NavigationFeedbackResponse_Status value);
  public:

  // uint32 command_id = 4;
  void clear_command_id();
  uint32_t command_id() const;
  void set_command_id(uint32_t value);
  private:
  uint32_t _internal_command_id() const;
  void _internal_set_command_id(uint32_t value);
  public:

  // .bosdyn.api.SE2TrajectoryCommand.Feedback.BodyMovementStatus body_movement_status = 7;
  void clear_body_movement_status();
  ::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus body_movement_status() const;
  void set_body_movement_status(::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus value);
  private:
  ::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus _internal_body_movement_status() const;
  void _internal_set_body_movement_status(::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus value);
  public:

  // .bosdyn.api.graph_nav.Edge.Annotations.PathFollowingMode path_following_mode = 8;
  void clear_path_following_mode();
  ::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode path_following_mode() const;
  void set_path_following_mode(::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode value);
  private:
  ::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode _internal_path_following_mode() const;
  void _internal_set_path_following_mode(::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode value);
  public:

  // .bosdyn.api.graph_nav.NavigationFeedbackResponse.RouteFollowingStatus route_following_status = 1000;
  void clear_route_following_status();
  ::bosdyn::api::graph_nav::NavigationFeedbackResponse_RouteFollowingStatus route_following_status() const;
  void set_route_following_status(::bosdyn::api::graph_nav::NavigationFeedbackResponse_RouteFollowingStatus value);
  private:
  ::bosdyn::api::graph_nav::NavigationFeedbackResponse_RouteFollowingStatus _internal_route_following_status() const;
  void _internal_set_route_following_status(::bosdyn::api::graph_nav::NavigationFeedbackResponse_RouteFollowingStatus value);
  public:

  // .bosdyn.api.graph_nav.NavigationFeedbackResponse.BlockageStatus blockage_status = 1001;
  void clear_blockage_status();
  ::bosdyn::api::graph_nav::NavigationFeedbackResponse_BlockageStatus blockage_status() const;
  void set_blockage_status(::bosdyn::api::graph_nav::NavigationFeedbackResponse_BlockageStatus value);
  private:
  ::bosdyn::api::graph_nav::NavigationFeedbackResponse_BlockageStatus _internal_blockage_status() const;
  void _internal_set_blockage_status(::bosdyn::api::graph_nav::NavigationFeedbackResponse_BlockageStatus value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.NavigationFeedbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        NavigationFeedbackResponse_AreaCallbackErrorsEntry_DoNotUse,
        std::string, ::bosdyn::api::graph_nav::AreaCallbackError,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> area_callback_errors_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        NavigationFeedbackResponse_ActiveRegionInformationEntry_DoNotUse,
        std::string, ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> active_region_information_;
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::graph_nav::Route* remaining_route_;
    ::bosdyn::api::SE3Pose* last_ko_tform_goal_;
    ::bosdyn::api::RobotImpairedState* impaired_state_;
    int status_;
    uint32_t command_id_;
    int body_movement_status_;
    int path_following_mode_;
    int route_following_status_;
    int blockage_status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class GetLocalizationStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.GetLocalizationStateRequest) */ {
 public:
  inline GetLocalizationStateRequest() : GetLocalizationStateRequest(nullptr) {}
  ~GetLocalizationStateRequest() override;
  explicit PROTOBUF_CONSTEXPR GetLocalizationStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLocalizationStateRequest(const GetLocalizationStateRequest& from);
  GetLocalizationStateRequest(GetLocalizationStateRequest&& from) noexcept
    : GetLocalizationStateRequest() {
    *this = ::std::move(from);
  }

  inline GetLocalizationStateRequest& operator=(const GetLocalizationStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLocalizationStateRequest& operator=(GetLocalizationStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLocalizationStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLocalizationStateRequest* internal_default_instance() {
    return reinterpret_cast<const GetLocalizationStateRequest*>(
               &_GetLocalizationStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetLocalizationStateRequest& a, GetLocalizationStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLocalizationStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLocalizationStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLocalizationStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLocalizationStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLocalizationStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLocalizationStateRequest& from) {
    GetLocalizationStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLocalizationStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.GetLocalizationStateRequest";
  }
  protected:
  explicit GetLocalizationStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWaypointIdFieldNumber = 8,
    kHeaderFieldNumber = 1,
    kRequestLivePointCloudFieldNumber = 2,
    kRequestLiveImagesFieldNumber = 3,
    kRequestLiveTerrainMapsFieldNumber = 4,
    kRequestLiveWorldObjectsFieldNumber = 5,
    kRequestLiveRobotStateFieldNumber = 6,
    kCompressLivePointCloudFieldNumber = 7,
  };
  // string waypoint_id = 8;
  void clear_waypoint_id();
  const std::string& waypoint_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_waypoint_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_waypoint_id();
  PROTOBUF_NODISCARD std::string* release_waypoint_id();
  void set_allocated_waypoint_id(std::string* waypoint_id);
  private:
  const std::string& _internal_waypoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_waypoint_id(const std::string& value);
  std::string* _internal_mutable_waypoint_id();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // bool request_live_point_cloud = 2;
  void clear_request_live_point_cloud();
  bool request_live_point_cloud() const;
  void set_request_live_point_cloud(bool value);
  private:
  bool _internal_request_live_point_cloud() const;
  void _internal_set_request_live_point_cloud(bool value);
  public:

  // bool request_live_images = 3;
  void clear_request_live_images();
  bool request_live_images() const;
  void set_request_live_images(bool value);
  private:
  bool _internal_request_live_images() const;
  void _internal_set_request_live_images(bool value);
  public:

  // bool request_live_terrain_maps = 4;
  void clear_request_live_terrain_maps();
  bool request_live_terrain_maps() const;
  void set_request_live_terrain_maps(bool value);
  private:
  bool _internal_request_live_terrain_maps() const;
  void _internal_set_request_live_terrain_maps(bool value);
  public:

  // bool request_live_world_objects = 5;
  void clear_request_live_world_objects();
  bool request_live_world_objects() const;
  void set_request_live_world_objects(bool value);
  private:
  bool _internal_request_live_world_objects() const;
  void _internal_set_request_live_world_objects(bool value);
  public:

  // bool request_live_robot_state = 6;
  void clear_request_live_robot_state();
  bool request_live_robot_state() const;
  void set_request_live_robot_state(bool value);
  private:
  bool _internal_request_live_robot_state() const;
  void _internal_set_request_live_robot_state(bool value);
  public:

  // bool compress_live_point_cloud = 7;
  void clear_compress_live_point_cloud();
  bool compress_live_point_cloud() const;
  void set_compress_live_point_cloud(bool value);
  private:
  bool _internal_compress_live_point_cloud() const;
  void _internal_set_compress_live_point_cloud(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.GetLocalizationStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr waypoint_id_;
    ::bosdyn::api::RequestHeader* header_;
    bool request_live_point_cloud_;
    bool request_live_images_;
    bool request_live_terrain_maps_;
    bool request_live_world_objects_;
    bool request_live_robot_state_;
    bool compress_live_point_cloud_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class RemotePointCloudStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.RemotePointCloudStatus) */ {
 public:
  inline RemotePointCloudStatus() : RemotePointCloudStatus(nullptr) {}
  ~RemotePointCloudStatus() override;
  explicit PROTOBUF_CONSTEXPR RemotePointCloudStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemotePointCloudStatus(const RemotePointCloudStatus& from);
  RemotePointCloudStatus(RemotePointCloudStatus&& from) noexcept
    : RemotePointCloudStatus() {
    *this = ::std::move(from);
  }

  inline RemotePointCloudStatus& operator=(const RemotePointCloudStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemotePointCloudStatus& operator=(RemotePointCloudStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemotePointCloudStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemotePointCloudStatus* internal_default_instance() {
    return reinterpret_cast<const RemotePointCloudStatus*>(
               &_RemotePointCloudStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RemotePointCloudStatus& a, RemotePointCloudStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RemotePointCloudStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemotePointCloudStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemotePointCloudStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemotePointCloudStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemotePointCloudStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemotePointCloudStatus& from) {
    RemotePointCloudStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemotePointCloudStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.RemotePointCloudStatus";
  }
  protected:
  explicit RemotePointCloudStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kExistsInDirectoryFieldNumber = 2,
    kHasDataFieldNumber = 3,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // bool exists_in_directory = 2;
  void clear_exists_in_directory();
  bool exists_in_directory() const;
  void set_exists_in_directory(bool value);
  private:
  bool _internal_exists_in_directory() const;
  void _internal_set_exists_in_directory(bool value);
  public:

  // bool has_data = 3;
  void clear_has_data();
  bool has_data() const;
  void set_has_data(bool value);
  private:
  bool _internal_has_data() const;
  void _internal_set_has_data(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.RemotePointCloudStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    bool exists_in_directory_;
    bool has_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class LostDetectorState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.LostDetectorState) */ {
 public:
  inline LostDetectorState() : LostDetectorState(nullptr) {}
  ~LostDetectorState() override;
  explicit PROTOBUF_CONSTEXPR LostDetectorState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LostDetectorState(const LostDetectorState& from);
  LostDetectorState(LostDetectorState&& from) noexcept
    : LostDetectorState() {
    *this = ::std::move(from);
  }

  inline LostDetectorState& operator=(const LostDetectorState& from) {
    CopyFrom(from);
    return *this;
  }
  inline LostDetectorState& operator=(LostDetectorState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LostDetectorState& default_instance() {
    return *internal_default_instance();
  }
  static inline const LostDetectorState* internal_default_instance() {
    return reinterpret_cast<const LostDetectorState*>(
               &_LostDetectorState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(LostDetectorState& a, LostDetectorState& b) {
    a.Swap(&b);
  }
  inline void Swap(LostDetectorState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LostDetectorState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LostDetectorState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LostDetectorState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LostDetectorState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LostDetectorState& from) {
    LostDetectorState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LostDetectorState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.LostDetectorState";
  }
  protected:
  explicit LostDetectorState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsLostFieldNumber = 1,
  };
  // bool is_lost = 1;
  void clear_is_lost();
  bool is_lost() const;
  void set_is_lost(bool value);
  private:
  bool _internal_is_lost() const;
  void _internal_set_is_lost(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.LostDetectorState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool is_lost_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class GetLocalizationStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.GetLocalizationStateResponse) */ {
 public:
  inline GetLocalizationStateResponse() : GetLocalizationStateResponse(nullptr) {}
  ~GetLocalizationStateResponse() override;
  explicit PROTOBUF_CONSTEXPR GetLocalizationStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLocalizationStateResponse(const GetLocalizationStateResponse& from);
  GetLocalizationStateResponse(GetLocalizationStateResponse&& from) noexcept
    : GetLocalizationStateResponse() {
    *this = ::std::move(from);
  }

  inline GetLocalizationStateResponse& operator=(const GetLocalizationStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLocalizationStateResponse& operator=(GetLocalizationStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLocalizationStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLocalizationStateResponse* internal_default_instance() {
    return reinterpret_cast<const GetLocalizationStateResponse*>(
               &_GetLocalizationStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetLocalizationStateResponse& a, GetLocalizationStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLocalizationStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLocalizationStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLocalizationStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLocalizationStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLocalizationStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLocalizationStateResponse& from) {
    GetLocalizationStateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLocalizationStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.GetLocalizationStateResponse";
  }
  protected:
  explicit GetLocalizationStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteCloudStatusFieldNumber = 5,
    kHeaderFieldNumber = 1,
    kLocalizationFieldNumber = 2,
    kRobotKinematicsFieldNumber = 4,
    kLiveDataFieldNumber = 6,
    kLostDetectorStateFieldNumber = 7,
  };
  // repeated .bosdyn.api.graph_nav.RemotePointCloudStatus remote_cloud_status = 5;
  int remote_cloud_status_size() const;
  private:
  int _internal_remote_cloud_status_size() const;
  public:
  void clear_remote_cloud_status();
  ::bosdyn::api::graph_nav::RemotePointCloudStatus* mutable_remote_cloud_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::graph_nav::RemotePointCloudStatus >*
      mutable_remote_cloud_status();
  private:
  const ::bosdyn::api::graph_nav::RemotePointCloudStatus& _internal_remote_cloud_status(int index) const;
  ::bosdyn::api::graph_nav::RemotePointCloudStatus* _internal_add_remote_cloud_status();
  public:
  const ::bosdyn::api::graph_nav::RemotePointCloudStatus& remote_cloud_status(int index) const;
  ::bosdyn::api::graph_nav::RemotePointCloudStatus* add_remote_cloud_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::graph_nav::RemotePointCloudStatus >&
      remote_cloud_status() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.Localization localization = 2;
  bool has_localization() const;
  private:
  bool _internal_has_localization() const;
  public:
  void clear_localization();
  const ::bosdyn::api::graph_nav::Localization& localization() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::Localization* release_localization();
  ::bosdyn::api::graph_nav::Localization* mutable_localization();
  void set_allocated_localization(::bosdyn::api::graph_nav::Localization* localization);
  private:
  const ::bosdyn::api::graph_nav::Localization& _internal_localization() const;
  ::bosdyn::api::graph_nav::Localization* _internal_mutable_localization();
  public:
  void unsafe_arena_set_allocated_localization(
      ::bosdyn::api::graph_nav::Localization* localization);
  ::bosdyn::api::graph_nav::Localization* unsafe_arena_release_localization();

  // .bosdyn.api.KinematicState robot_kinematics = 4;
  bool has_robot_kinematics() const;
  private:
  bool _internal_has_robot_kinematics() const;
  public:
  void clear_robot_kinematics();
  const ::bosdyn::api::KinematicState& robot_kinematics() const;
  PROTOBUF_NODISCARD ::bosdyn::api::KinematicState* release_robot_kinematics();
  ::bosdyn::api::KinematicState* mutable_robot_kinematics();
  void set_allocated_robot_kinematics(::bosdyn::api::KinematicState* robot_kinematics);
  private:
  const ::bosdyn::api::KinematicState& _internal_robot_kinematics() const;
  ::bosdyn::api::KinematicState* _internal_mutable_robot_kinematics();
  public:
  void unsafe_arena_set_allocated_robot_kinematics(
      ::bosdyn::api::KinematicState* robot_kinematics);
  ::bosdyn::api::KinematicState* unsafe_arena_release_robot_kinematics();

  // .bosdyn.api.graph_nav.WaypointSnapshot live_data = 6;
  bool has_live_data() const;
  private:
  bool _internal_has_live_data() const;
  public:
  void clear_live_data();
  const ::bosdyn::api::graph_nav::WaypointSnapshot& live_data() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::WaypointSnapshot* release_live_data();
  ::bosdyn::api::graph_nav::WaypointSnapshot* mutable_live_data();
  void set_allocated_live_data(::bosdyn::api::graph_nav::WaypointSnapshot* live_data);
  private:
  const ::bosdyn::api::graph_nav::WaypointSnapshot& _internal_live_data() const;
  ::bosdyn::api::graph_nav::WaypointSnapshot* _internal_mutable_live_data();
  public:
  void unsafe_arena_set_allocated_live_data(
      ::bosdyn::api::graph_nav::WaypointSnapshot* live_data);
  ::bosdyn::api::graph_nav::WaypointSnapshot* unsafe_arena_release_live_data();

  // .bosdyn.api.graph_nav.LostDetectorState lost_detector_state = 7;
  bool has_lost_detector_state() const;
  private:
  bool _internal_has_lost_detector_state() const;
  public:
  void clear_lost_detector_state();
  const ::bosdyn::api::graph_nav::LostDetectorState& lost_detector_state() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::LostDetectorState* release_lost_detector_state();
  ::bosdyn::api::graph_nav::LostDetectorState* mutable_lost_detector_state();
  void set_allocated_lost_detector_state(::bosdyn::api::graph_nav::LostDetectorState* lost_detector_state);
  private:
  const ::bosdyn::api::graph_nav::LostDetectorState& _internal_lost_detector_state() const;
  ::bosdyn::api::graph_nav::LostDetectorState* _internal_mutable_lost_detector_state();
  public:
  void unsafe_arena_set_allocated_lost_detector_state(
      ::bosdyn::api::graph_nav::LostDetectorState* lost_detector_state);
  ::bosdyn::api::graph_nav::LostDetectorState* unsafe_arena_release_lost_detector_state();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.GetLocalizationStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::graph_nav::RemotePointCloudStatus > remote_cloud_status_;
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::graph_nav::Localization* localization_;
    ::bosdyn::api::KinematicState* robot_kinematics_;
    ::bosdyn::api::graph_nav::WaypointSnapshot* live_data_;
    ::bosdyn::api::graph_nav::LostDetectorState* lost_detector_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class ClearGraphRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.ClearGraphRequest) */ {
 public:
  inline ClearGraphRequest() : ClearGraphRequest(nullptr) {}
  ~ClearGraphRequest() override;
  explicit PROTOBUF_CONSTEXPR ClearGraphRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearGraphRequest(const ClearGraphRequest& from);
  ClearGraphRequest(ClearGraphRequest&& from) noexcept
    : ClearGraphRequest() {
    *this = ::std::move(from);
  }

  inline ClearGraphRequest& operator=(const ClearGraphRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearGraphRequest& operator=(ClearGraphRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearGraphRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearGraphRequest* internal_default_instance() {
    return reinterpret_cast<const ClearGraphRequest*>(
               &_ClearGraphRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ClearGraphRequest& a, ClearGraphRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearGraphRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearGraphRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearGraphRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearGraphRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearGraphRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearGraphRequest& from) {
    ClearGraphRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearGraphRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.ClearGraphRequest";
  }
  protected:
  explicit ClearGraphRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.ClearGraphRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::Lease* lease_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class ClearGraphResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.ClearGraphResponse) */ {
 public:
  inline ClearGraphResponse() : ClearGraphResponse(nullptr) {}
  ~ClearGraphResponse() override;
  explicit PROTOBUF_CONSTEXPR ClearGraphResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearGraphResponse(const ClearGraphResponse& from);
  ClearGraphResponse(ClearGraphResponse&& from) noexcept
    : ClearGraphResponse() {
    *this = ::std::move(from);
  }

  inline ClearGraphResponse& operator=(const ClearGraphResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearGraphResponse& operator=(ClearGraphResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearGraphResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearGraphResponse* internal_default_instance() {
    return reinterpret_cast<const ClearGraphResponse*>(
               &_ClearGraphResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ClearGraphResponse& a, ClearGraphResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearGraphResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearGraphResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearGraphResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearGraphResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearGraphResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearGraphResponse& from) {
    ClearGraphResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearGraphResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.ClearGraphResponse";
  }
  protected:
  explicit ClearGraphResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClearGraphResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    ClearGraphResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    ClearGraphResponse_Status_STATUS_OK;
  static constexpr Status STATUS_RECORDING =
    ClearGraphResponse_Status_STATUS_RECORDING;
  static inline bool Status_IsValid(int value) {
    return ClearGraphResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ClearGraphResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ClearGraphResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ClearGraphResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return ClearGraphResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ClearGraphResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return ClearGraphResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  PROTOBUF_NODISCARD ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // .bosdyn.api.graph_nav.ClearGraphResponse.Status status = 3;
  void clear_status();
  ::bosdyn::api::graph_nav::ClearGraphResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::ClearGraphResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::ClearGraphResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::ClearGraphResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.ClearGraphResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::LeaseUseResult* lease_use_result_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class UploadGraphRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.UploadGraphRequest) */ {
 public:
  inline UploadGraphRequest() : UploadGraphRequest(nullptr) {}
  ~UploadGraphRequest() override;
  explicit PROTOBUF_CONSTEXPR UploadGraphRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadGraphRequest(const UploadGraphRequest& from);
  UploadGraphRequest(UploadGraphRequest&& from) noexcept
    : UploadGraphRequest() {
    *this = ::std::move(from);
  }

  inline UploadGraphRequest& operator=(const UploadGraphRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadGraphRequest& operator=(UploadGraphRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadGraphRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadGraphRequest* internal_default_instance() {
    return reinterpret_cast<const UploadGraphRequest*>(
               &_UploadGraphRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(UploadGraphRequest& a, UploadGraphRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadGraphRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadGraphRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadGraphRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadGraphRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadGraphRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadGraphRequest& from) {
    UploadGraphRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadGraphRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.UploadGraphRequest";
  }
  protected:
  explicit UploadGraphRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kGraphFieldNumber = 2,
    kLeaseFieldNumber = 3,
    kGenerateNewAnchoringFieldNumber = 4,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.Graph graph = 2;
  bool has_graph() const;
  private:
  bool _internal_has_graph() const;
  public:
  void clear_graph();
  const ::bosdyn::api::graph_nav::Graph& graph() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::Graph* release_graph();
  ::bosdyn::api::graph_nav::Graph* mutable_graph();
  void set_allocated_graph(::bosdyn::api::graph_nav::Graph* graph);
  private:
  const ::bosdyn::api::graph_nav::Graph& _internal_graph() const;
  ::bosdyn::api::graph_nav::Graph* _internal_mutable_graph();
  public:
  void unsafe_arena_set_allocated_graph(
      ::bosdyn::api::graph_nav::Graph* graph);
  ::bosdyn::api::graph_nav::Graph* unsafe_arena_release_graph();

  // .bosdyn.api.Lease lease = 3;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // bool generate_new_anchoring = 4;
  void clear_generate_new_anchoring();
  bool generate_new_anchoring() const;
  void set_generate_new_anchoring(bool value);
  private:
  bool _internal_generate_new_anchoring() const;
  void _internal_set_generate_new_anchoring(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.UploadGraphRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::graph_nav::Graph* graph_;
    ::bosdyn::api::Lease* lease_;
    bool generate_new_anchoring_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class UploadGraphResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.UploadGraphResponse) */ {
 public:
  inline UploadGraphResponse() : UploadGraphResponse(nullptr) {}
  ~UploadGraphResponse() override;
  explicit PROTOBUF_CONSTEXPR UploadGraphResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadGraphResponse(const UploadGraphResponse& from);
  UploadGraphResponse(UploadGraphResponse&& from) noexcept
    : UploadGraphResponse() {
    *this = ::std::move(from);
  }

  inline UploadGraphResponse& operator=(const UploadGraphResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadGraphResponse& operator=(UploadGraphResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadGraphResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadGraphResponse* internal_default_instance() {
    return reinterpret_cast<const UploadGraphResponse*>(
               &_UploadGraphResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(UploadGraphResponse& a, UploadGraphResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadGraphResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadGraphResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadGraphResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadGraphResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadGraphResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadGraphResponse& from) {
    UploadGraphResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadGraphResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.UploadGraphResponse";
  }
  protected:
  explicit UploadGraphResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UploadGraphResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    UploadGraphResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    UploadGraphResponse_Status_STATUS_OK;
  static constexpr Status STATUS_MAP_TOO_LARGE_LICENSE =
    UploadGraphResponse_Status_STATUS_MAP_TOO_LARGE_LICENSE;
  static constexpr Status STATUS_INVALID_GRAPH =
    UploadGraphResponse_Status_STATUS_INVALID_GRAPH;
  static constexpr Status STATUS_INCOMPATIBLE_SENSORS =
    UploadGraphResponse_Status_STATUS_INCOMPATIBLE_SENSORS;
  static constexpr Status STATUS_AREA_CALLBACK_ERROR =
    UploadGraphResponse_Status_STATUS_AREA_CALLBACK_ERROR;
  static inline bool Status_IsValid(int value) {
    return UploadGraphResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    UploadGraphResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    UploadGraphResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    UploadGraphResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return UploadGraphResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return UploadGraphResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return UploadGraphResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLoadedWaypointSnapshotIdsFieldNumber = 3,
    kUnknownWaypointSnapshotIdsFieldNumber = 4,
    kLoadedEdgeSnapshotIdsFieldNumber = 5,
    kUnknownEdgeSnapshotIdsFieldNumber = 6,
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
    kSensorStatusFieldNumber = 9,
    kAreaCallbackErrorFieldNumber = 10,
    kLicenseStatusFieldNumber = 7,
    kStatusFieldNumber = 8,
  };
  // repeated string loaded_waypoint_snapshot_ids = 3;
  int loaded_waypoint_snapshot_ids_size() const;
  private:
  int _internal_loaded_waypoint_snapshot_ids_size() const;
  public:
  void clear_loaded_waypoint_snapshot_ids();
  const std::string& loaded_waypoint_snapshot_ids(int index) const;
  std::string* mutable_loaded_waypoint_snapshot_ids(int index);
  void set_loaded_waypoint_snapshot_ids(int index, const std::string& value);
  void set_loaded_waypoint_snapshot_ids(int index, std::string&& value);
  void set_loaded_waypoint_snapshot_ids(int index, const char* value);
  void set_loaded_waypoint_snapshot_ids(int index, const char* value, size_t size);
  std::string* add_loaded_waypoint_snapshot_ids();
  void add_loaded_waypoint_snapshot_ids(const std::string& value);
  void add_loaded_waypoint_snapshot_ids(std::string&& value);
  void add_loaded_waypoint_snapshot_ids(const char* value);
  void add_loaded_waypoint_snapshot_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& loaded_waypoint_snapshot_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_loaded_waypoint_snapshot_ids();
  private:
  const std::string& _internal_loaded_waypoint_snapshot_ids(int index) const;
  std::string* _internal_add_loaded_waypoint_snapshot_ids();
  public:

  // repeated string unknown_waypoint_snapshot_ids = 4;
  int unknown_waypoint_snapshot_ids_size() const;
  private:
  int _internal_unknown_waypoint_snapshot_ids_size() const;
  public:
  void clear_unknown_waypoint_snapshot_ids();
  const std::string& unknown_waypoint_snapshot_ids(int index) const;
  std::string* mutable_unknown_waypoint_snapshot_ids(int index);
  void set_unknown_waypoint_snapshot_ids(int index, const std::string& value);
  void set_unknown_waypoint_snapshot_ids(int index, std::string&& value);
  void set_unknown_waypoint_snapshot_ids(int index, const char* value);
  void set_unknown_waypoint_snapshot_ids(int index, const char* value, size_t size);
  std::string* add_unknown_waypoint_snapshot_ids();
  void add_unknown_waypoint_snapshot_ids(const std::string& value);
  void add_unknown_waypoint_snapshot_ids(std::string&& value);
  void add_unknown_waypoint_snapshot_ids(const char* value);
  void add_unknown_waypoint_snapshot_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& unknown_waypoint_snapshot_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_unknown_waypoint_snapshot_ids();
  private:
  const std::string& _internal_unknown_waypoint_snapshot_ids(int index) const;
  std::string* _internal_add_unknown_waypoint_snapshot_ids();
  public:

  // repeated string loaded_edge_snapshot_ids = 5;
  int loaded_edge_snapshot_ids_size() const;
  private:
  int _internal_loaded_edge_snapshot_ids_size() const;
  public:
  void clear_loaded_edge_snapshot_ids();
  const std::string& loaded_edge_snapshot_ids(int index) const;
  std::string* mutable_loaded_edge_snapshot_ids(int index);
  void set_loaded_edge_snapshot_ids(int index, const std::string& value);
  void set_loaded_edge_snapshot_ids(int index, std::string&& value);
  void set_loaded_edge_snapshot_ids(int index, const char* value);
  void set_loaded_edge_snapshot_ids(int index, const char* value, size_t size);
  std::string* add_loaded_edge_snapshot_ids();
  void add_loaded_edge_snapshot_ids(const std::string& value);
  void add_loaded_edge_snapshot_ids(std::string&& value);
  void add_loaded_edge_snapshot_ids(const char* value);
  void add_loaded_edge_snapshot_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& loaded_edge_snapshot_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_loaded_edge_snapshot_ids();
  private:
  const std::string& _internal_loaded_edge_snapshot_ids(int index) const;
  std::string* _internal_add_loaded_edge_snapshot_ids();
  public:

  // repeated string unknown_edge_snapshot_ids = 6;
  int unknown_edge_snapshot_ids_size() const;
  private:
  int _internal_unknown_edge_snapshot_ids_size() const;
  public:
  void clear_unknown_edge_snapshot_ids();
  const std::string& unknown_edge_snapshot_ids(int index) const;
  std::string* mutable_unknown_edge_snapshot_ids(int index);
  void set_unknown_edge_snapshot_ids(int index, const std::string& value);
  void set_unknown_edge_snapshot_ids(int index, std::string&& value);
  void set_unknown_edge_snapshot_ids(int index, const char* value);
  void set_unknown_edge_snapshot_ids(int index, const char* value, size_t size);
  std::string* add_unknown_edge_snapshot_ids();
  void add_unknown_edge_snapshot_ids(const std::string& value);
  void add_unknown_edge_snapshot_ids(std::string&& value);
  void add_unknown_edge_snapshot_ids(const char* value);
  void add_unknown_edge_snapshot_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& unknown_edge_snapshot_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_unknown_edge_snapshot_ids();
  private:
  const std::string& _internal_unknown_edge_snapshot_ids(int index) const;
  std::string* _internal_add_unknown_edge_snapshot_ids();
  public:

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  PROTOBUF_NODISCARD ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // .bosdyn.api.graph_nav.SensorCompatibilityStatus sensor_status = 9;
  bool has_sensor_status() const;
  private:
  bool _internal_has_sensor_status() const;
  public:
  void clear_sensor_status();
  const ::bosdyn::api::graph_nav::SensorCompatibilityStatus& sensor_status() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::SensorCompatibilityStatus* release_sensor_status();
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* mutable_sensor_status();
  void set_allocated_sensor_status(::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status);
  private:
  const ::bosdyn::api::graph_nav::SensorCompatibilityStatus& _internal_sensor_status() const;
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* _internal_mutable_sensor_status();
  public:
  void unsafe_arena_set_allocated_sensor_status(
      ::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status);
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* unsafe_arena_release_sensor_status();

  // .bosdyn.api.graph_nav.AreaCallbackServiceError area_callback_error = 10;
  bool has_area_callback_error() const;
  private:
  bool _internal_has_area_callback_error() const;
  public:
  void clear_area_callback_error();
  const ::bosdyn::api::graph_nav::AreaCallbackServiceError& area_callback_error() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::AreaCallbackServiceError* release_area_callback_error();
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* mutable_area_callback_error();
  void set_allocated_area_callback_error(::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error);
  private:
  const ::bosdyn::api::graph_nav::AreaCallbackServiceError& _internal_area_callback_error() const;
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* _internal_mutable_area_callback_error();
  public:
  void unsafe_arena_set_allocated_area_callback_error(
      ::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error);
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* unsafe_arena_release_area_callback_error();

  // .bosdyn.api.LicenseInfo.Status license_status = 7;
  void clear_license_status();
  ::bosdyn::api::LicenseInfo_Status license_status() const;
  void set_license_status(::bosdyn::api::LicenseInfo_Status value);
  private:
  ::bosdyn::api::LicenseInfo_Status _internal_license_status() const;
  void _internal_set_license_status(::bosdyn::api::LicenseInfo_Status value);
  public:

  // .bosdyn.api.graph_nav.UploadGraphResponse.Status status = 8;
  void clear_status();
  ::bosdyn::api::graph_nav::UploadGraphResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::UploadGraphResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::UploadGraphResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::UploadGraphResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.UploadGraphResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> loaded_waypoint_snapshot_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> unknown_waypoint_snapshot_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> loaded_edge_snapshot_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> unknown_edge_snapshot_ids_;
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::LeaseUseResult* lease_use_result_;
    ::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status_;
    ::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error_;
    int license_status_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class DownloadGraphRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.DownloadGraphRequest) */ {
 public:
  inline DownloadGraphRequest() : DownloadGraphRequest(nullptr) {}
  ~DownloadGraphRequest() override;
  explicit PROTOBUF_CONSTEXPR DownloadGraphRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadGraphRequest(const DownloadGraphRequest& from);
  DownloadGraphRequest(DownloadGraphRequest&& from) noexcept
    : DownloadGraphRequest() {
    *this = ::std::move(from);
  }

  inline DownloadGraphRequest& operator=(const DownloadGraphRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadGraphRequest& operator=(DownloadGraphRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadGraphRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadGraphRequest* internal_default_instance() {
    return reinterpret_cast<const DownloadGraphRequest*>(
               &_DownloadGraphRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(DownloadGraphRequest& a, DownloadGraphRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadGraphRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadGraphRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadGraphRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadGraphRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DownloadGraphRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DownloadGraphRequest& from) {
    DownloadGraphRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadGraphRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.DownloadGraphRequest";
  }
  protected:
  explicit DownloadGraphRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.DownloadGraphRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class DownloadGraphResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.DownloadGraphResponse) */ {
 public:
  inline DownloadGraphResponse() : DownloadGraphResponse(nullptr) {}
  ~DownloadGraphResponse() override;
  explicit PROTOBUF_CONSTEXPR DownloadGraphResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadGraphResponse(const DownloadGraphResponse& from);
  DownloadGraphResponse(DownloadGraphResponse&& from) noexcept
    : DownloadGraphResponse() {
    *this = ::std::move(from);
  }

  inline DownloadGraphResponse& operator=(const DownloadGraphResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadGraphResponse& operator=(DownloadGraphResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadGraphResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadGraphResponse* internal_default_instance() {
    return reinterpret_cast<const DownloadGraphResponse*>(
               &_DownloadGraphResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(DownloadGraphResponse& a, DownloadGraphResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadGraphResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadGraphResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadGraphResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadGraphResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DownloadGraphResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DownloadGraphResponse& from) {
    DownloadGraphResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadGraphResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.DownloadGraphResponse";
  }
  protected:
  explicit DownloadGraphResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kGraphFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.Graph graph = 2;
  bool has_graph() const;
  private:
  bool _internal_has_graph() const;
  public:
  void clear_graph();
  const ::bosdyn::api::graph_nav::Graph& graph() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::Graph* release_graph();
  ::bosdyn::api::graph_nav::Graph* mutable_graph();
  void set_allocated_graph(::bosdyn::api::graph_nav::Graph* graph);
  private:
  const ::bosdyn::api::graph_nav::Graph& _internal_graph() const;
  ::bosdyn::api::graph_nav::Graph* _internal_mutable_graph();
  public:
  void unsafe_arena_set_allocated_graph(
      ::bosdyn::api::graph_nav::Graph* graph);
  ::bosdyn::api::graph_nav::Graph* unsafe_arena_release_graph();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.DownloadGraphResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::graph_nav::Graph* graph_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class UploadWaypointSnapshotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest) */ {
 public:
  inline UploadWaypointSnapshotRequest() : UploadWaypointSnapshotRequest(nullptr) {}
  ~UploadWaypointSnapshotRequest() override;
  explicit PROTOBUF_CONSTEXPR UploadWaypointSnapshotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadWaypointSnapshotRequest(const UploadWaypointSnapshotRequest& from);
  UploadWaypointSnapshotRequest(UploadWaypointSnapshotRequest&& from) noexcept
    : UploadWaypointSnapshotRequest() {
    *this = ::std::move(from);
  }

  inline UploadWaypointSnapshotRequest& operator=(const UploadWaypointSnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadWaypointSnapshotRequest& operator=(UploadWaypointSnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadWaypointSnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadWaypointSnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const UploadWaypointSnapshotRequest*>(
               &_UploadWaypointSnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(UploadWaypointSnapshotRequest& a, UploadWaypointSnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadWaypointSnapshotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadWaypointSnapshotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadWaypointSnapshotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadWaypointSnapshotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadWaypointSnapshotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadWaypointSnapshotRequest& from) {
    UploadWaypointSnapshotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadWaypointSnapshotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.UploadWaypointSnapshotRequest";
  }
  protected:
  explicit UploadWaypointSnapshotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kChunkFieldNumber = 3,
    kLeaseFieldNumber = 4,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.DataChunk chunk = 3;
  bool has_chunk() const;
  private:
  bool _internal_has_chunk() const;
  public:
  void clear_chunk();
  const ::bosdyn::api::DataChunk& chunk() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataChunk* release_chunk();
  ::bosdyn::api::DataChunk* mutable_chunk();
  void set_allocated_chunk(::bosdyn::api::DataChunk* chunk);
  private:
  const ::bosdyn::api::DataChunk& _internal_chunk() const;
  ::bosdyn::api::DataChunk* _internal_mutable_chunk();
  public:
  void unsafe_arena_set_allocated_chunk(
      ::bosdyn::api::DataChunk* chunk);
  ::bosdyn::api::DataChunk* unsafe_arena_release_chunk();

  // .bosdyn.api.Lease lease = 4;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::DataChunk* chunk_;
    ::bosdyn::api::Lease* lease_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class UploadWaypointSnapshotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse) */ {
 public:
  inline UploadWaypointSnapshotResponse() : UploadWaypointSnapshotResponse(nullptr) {}
  ~UploadWaypointSnapshotResponse() override;
  explicit PROTOBUF_CONSTEXPR UploadWaypointSnapshotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadWaypointSnapshotResponse(const UploadWaypointSnapshotResponse& from);
  UploadWaypointSnapshotResponse(UploadWaypointSnapshotResponse&& from) noexcept
    : UploadWaypointSnapshotResponse() {
    *this = ::std::move(from);
  }

  inline UploadWaypointSnapshotResponse& operator=(const UploadWaypointSnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadWaypointSnapshotResponse& operator=(UploadWaypointSnapshotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadWaypointSnapshotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadWaypointSnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const UploadWaypointSnapshotResponse*>(
               &_UploadWaypointSnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(UploadWaypointSnapshotResponse& a, UploadWaypointSnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadWaypointSnapshotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadWaypointSnapshotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadWaypointSnapshotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadWaypointSnapshotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadWaypointSnapshotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadWaypointSnapshotResponse& from) {
    UploadWaypointSnapshotResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadWaypointSnapshotResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.UploadWaypointSnapshotResponse";
  }
  protected:
  explicit UploadWaypointSnapshotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UploadWaypointSnapshotResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    UploadWaypointSnapshotResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    UploadWaypointSnapshotResponse_Status_STATUS_OK;
  static constexpr Status STATUS_INCOMPATIBLE_SENSORS =
    UploadWaypointSnapshotResponse_Status_STATUS_INCOMPATIBLE_SENSORS;
  static inline bool Status_IsValid(int value) {
    return UploadWaypointSnapshotResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    UploadWaypointSnapshotResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    UploadWaypointSnapshotResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    UploadWaypointSnapshotResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return UploadWaypointSnapshotResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return UploadWaypointSnapshotResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return UploadWaypointSnapshotResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
    kSensorStatusFieldNumber = 4,
    kStatusFieldNumber = 3,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  PROTOBUF_NODISCARD ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // .bosdyn.api.graph_nav.SensorCompatibilityStatus sensor_status = 4;
  bool has_sensor_status() const;
  private:
  bool _internal_has_sensor_status() const;
  public:
  void clear_sensor_status();
  const ::bosdyn::api::graph_nav::SensorCompatibilityStatus& sensor_status() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::SensorCompatibilityStatus* release_sensor_status();
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* mutable_sensor_status();
  void set_allocated_sensor_status(::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status);
  private:
  const ::bosdyn::api::graph_nav::SensorCompatibilityStatus& _internal_sensor_status() const;
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* _internal_mutable_sensor_status();
  public:
  void unsafe_arena_set_allocated_sensor_status(
      ::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status);
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* unsafe_arena_release_sensor_status();

  // .bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.Status status = 3;
  void clear_status();
  ::bosdyn::api::graph_nav::UploadWaypointSnapshotResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::UploadWaypointSnapshotResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::UploadWaypointSnapshotResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::UploadWaypointSnapshotResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::LeaseUseResult* lease_use_result_;
    ::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class UploadEdgeSnapshotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest) */ {
 public:
  inline UploadEdgeSnapshotRequest() : UploadEdgeSnapshotRequest(nullptr) {}
  ~UploadEdgeSnapshotRequest() override;
  explicit PROTOBUF_CONSTEXPR UploadEdgeSnapshotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadEdgeSnapshotRequest(const UploadEdgeSnapshotRequest& from);
  UploadEdgeSnapshotRequest(UploadEdgeSnapshotRequest&& from) noexcept
    : UploadEdgeSnapshotRequest() {
    *this = ::std::move(from);
  }

  inline UploadEdgeSnapshotRequest& operator=(const UploadEdgeSnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadEdgeSnapshotRequest& operator=(UploadEdgeSnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadEdgeSnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadEdgeSnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const UploadEdgeSnapshotRequest*>(
               &_UploadEdgeSnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(UploadEdgeSnapshotRequest& a, UploadEdgeSnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadEdgeSnapshotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadEdgeSnapshotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadEdgeSnapshotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadEdgeSnapshotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadEdgeSnapshotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadEdgeSnapshotRequest& from) {
    UploadEdgeSnapshotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadEdgeSnapshotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.UploadEdgeSnapshotRequest";
  }
  protected:
  explicit UploadEdgeSnapshotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kChunkFieldNumber = 4,
    kLeaseFieldNumber = 5,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.DataChunk chunk = 4;
  bool has_chunk() const;
  private:
  bool _internal_has_chunk() const;
  public:
  void clear_chunk();
  const ::bosdyn::api::DataChunk& chunk() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataChunk* release_chunk();
  ::bosdyn::api::DataChunk* mutable_chunk();
  void set_allocated_chunk(::bosdyn::api::DataChunk* chunk);
  private:
  const ::bosdyn::api::DataChunk& _internal_chunk() const;
  ::bosdyn::api::DataChunk* _internal_mutable_chunk();
  public:
  void unsafe_arena_set_allocated_chunk(
      ::bosdyn::api::DataChunk* chunk);
  ::bosdyn::api::DataChunk* unsafe_arena_release_chunk();

  // .bosdyn.api.Lease lease = 5;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::DataChunk* chunk_;
    ::bosdyn::api::Lease* lease_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class UploadEdgeSnapshotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.UploadEdgeSnapshotResponse) */ {
 public:
  inline UploadEdgeSnapshotResponse() : UploadEdgeSnapshotResponse(nullptr) {}
  ~UploadEdgeSnapshotResponse() override;
  explicit PROTOBUF_CONSTEXPR UploadEdgeSnapshotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadEdgeSnapshotResponse(const UploadEdgeSnapshotResponse& from);
  UploadEdgeSnapshotResponse(UploadEdgeSnapshotResponse&& from) noexcept
    : UploadEdgeSnapshotResponse() {
    *this = ::std::move(from);
  }

  inline UploadEdgeSnapshotResponse& operator=(const UploadEdgeSnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadEdgeSnapshotResponse& operator=(UploadEdgeSnapshotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadEdgeSnapshotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadEdgeSnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const UploadEdgeSnapshotResponse*>(
               &_UploadEdgeSnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(UploadEdgeSnapshotResponse& a, UploadEdgeSnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadEdgeSnapshotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadEdgeSnapshotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadEdgeSnapshotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadEdgeSnapshotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadEdgeSnapshotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadEdgeSnapshotResponse& from) {
    UploadEdgeSnapshotResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadEdgeSnapshotResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.UploadEdgeSnapshotResponse";
  }
  protected:
  explicit UploadEdgeSnapshotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  PROTOBUF_NODISCARD ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.UploadEdgeSnapshotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::LeaseUseResult* lease_use_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class DownloadWaypointSnapshotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest) */ {
 public:
  inline DownloadWaypointSnapshotRequest() : DownloadWaypointSnapshotRequest(nullptr) {}
  ~DownloadWaypointSnapshotRequest() override;
  explicit PROTOBUF_CONSTEXPR DownloadWaypointSnapshotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadWaypointSnapshotRequest(const DownloadWaypointSnapshotRequest& from);
  DownloadWaypointSnapshotRequest(DownloadWaypointSnapshotRequest&& from) noexcept
    : DownloadWaypointSnapshotRequest() {
    *this = ::std::move(from);
  }

  inline DownloadWaypointSnapshotRequest& operator=(const DownloadWaypointSnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadWaypointSnapshotRequest& operator=(DownloadWaypointSnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadWaypointSnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadWaypointSnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const DownloadWaypointSnapshotRequest*>(
               &_DownloadWaypointSnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(DownloadWaypointSnapshotRequest& a, DownloadWaypointSnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadWaypointSnapshotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadWaypointSnapshotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadWaypointSnapshotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadWaypointSnapshotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DownloadWaypointSnapshotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DownloadWaypointSnapshotRequest& from) {
    DownloadWaypointSnapshotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadWaypointSnapshotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest";
  }
  protected:
  explicit DownloadWaypointSnapshotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWaypointSnapshotIdFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kDownloadImagesFieldNumber = 3,
    kCompressPointCloudFieldNumber = 4,
    kDoNotDownloadPointCloudFieldNumber = 5,
  };
  // string waypoint_snapshot_id = 2;
  void clear_waypoint_snapshot_id();
  const std::string& waypoint_snapshot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_waypoint_snapshot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_waypoint_snapshot_id();
  PROTOBUF_NODISCARD std::string* release_waypoint_snapshot_id();
  void set_allocated_waypoint_snapshot_id(std::string* waypoint_snapshot_id);
  private:
  const std::string& _internal_waypoint_snapshot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_waypoint_snapshot_id(const std::string& value);
  std::string* _internal_mutable_waypoint_snapshot_id();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // bool download_images = 3;
  void clear_download_images();
  bool download_images() const;
  void set_download_images(bool value);
  private:
  bool _internal_download_images() const;
  void _internal_set_download_images(bool value);
  public:

  // bool compress_point_cloud = 4;
  void clear_compress_point_cloud();
  bool compress_point_cloud() const;
  void set_compress_point_cloud(bool value);
  private:
  bool _internal_compress_point_cloud() const;
  void _internal_set_compress_point_cloud(bool value);
  public:

  // bool do_not_download_point_cloud = 5;
  void clear_do_not_download_point_cloud();
  bool do_not_download_point_cloud() const;
  void set_do_not_download_point_cloud(bool value);
  private:
  bool _internal_do_not_download_point_cloud() const;
  void _internal_set_do_not_download_point_cloud(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr waypoint_snapshot_id_;
    ::bosdyn::api::RequestHeader* header_;
    bool download_images_;
    bool compress_point_cloud_;
    bool do_not_download_point_cloud_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class DownloadWaypointSnapshotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse) */ {
 public:
  inline DownloadWaypointSnapshotResponse() : DownloadWaypointSnapshotResponse(nullptr) {}
  ~DownloadWaypointSnapshotResponse() override;
  explicit PROTOBUF_CONSTEXPR DownloadWaypointSnapshotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadWaypointSnapshotResponse(const DownloadWaypointSnapshotResponse& from);
  DownloadWaypointSnapshotResponse(DownloadWaypointSnapshotResponse&& from) noexcept
    : DownloadWaypointSnapshotResponse() {
    *this = ::std::move(from);
  }

  inline DownloadWaypointSnapshotResponse& operator=(const DownloadWaypointSnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadWaypointSnapshotResponse& operator=(DownloadWaypointSnapshotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadWaypointSnapshotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadWaypointSnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const DownloadWaypointSnapshotResponse*>(
               &_DownloadWaypointSnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(DownloadWaypointSnapshotResponse& a, DownloadWaypointSnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadWaypointSnapshotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadWaypointSnapshotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadWaypointSnapshotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadWaypointSnapshotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DownloadWaypointSnapshotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DownloadWaypointSnapshotResponse& from) {
    DownloadWaypointSnapshotResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadWaypointSnapshotResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse";
  }
  protected:
  explicit DownloadWaypointSnapshotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DownloadWaypointSnapshotResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    DownloadWaypointSnapshotResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    DownloadWaypointSnapshotResponse_Status_STATUS_OK;
  static constexpr Status STATUS_SNAPSHOT_DOES_NOT_EXIST =
    DownloadWaypointSnapshotResponse_Status_STATUS_SNAPSHOT_DOES_NOT_EXIST;
  static inline bool Status_IsValid(int value) {
    return DownloadWaypointSnapshotResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    DownloadWaypointSnapshotResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    DownloadWaypointSnapshotResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    DownloadWaypointSnapshotResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return DownloadWaypointSnapshotResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return DownloadWaypointSnapshotResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return DownloadWaypointSnapshotResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kWaypointSnapshotIdFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kChunkFieldNumber = 5,
    kStatusFieldNumber = 2,
  };
  // string waypoint_snapshot_id = 4;
  void clear_waypoint_snapshot_id();
  const std::string& waypoint_snapshot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_waypoint_snapshot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_waypoint_snapshot_id();
  PROTOBUF_NODISCARD std::string* release_waypoint_snapshot_id();
  void set_allocated_waypoint_snapshot_id(std::string* waypoint_snapshot_id);
  private:
  const std::string& _internal_waypoint_snapshot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_waypoint_snapshot_id(const std::string& value);
  std::string* _internal_mutable_waypoint_snapshot_id();
  public:

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.DataChunk chunk = 5;
  bool has_chunk() const;
  private:
  bool _internal_has_chunk() const;
  public:
  void clear_chunk();
  const ::bosdyn::api::DataChunk& chunk() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataChunk* release_chunk();
  ::bosdyn::api::DataChunk* mutable_chunk();
  void set_allocated_chunk(::bosdyn::api::DataChunk* chunk);
  private:
  const ::bosdyn::api::DataChunk& _internal_chunk() const;
  ::bosdyn::api::DataChunk* _internal_mutable_chunk();
  public:
  void unsafe_arena_set_allocated_chunk(
      ::bosdyn::api::DataChunk* chunk);
  ::bosdyn::api::DataChunk* unsafe_arena_release_chunk();

  // .bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::graph_nav::DownloadWaypointSnapshotResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::DownloadWaypointSnapshotResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::DownloadWaypointSnapshotResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::DownloadWaypointSnapshotResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr waypoint_snapshot_id_;
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::DataChunk* chunk_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class DownloadEdgeSnapshotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.DownloadEdgeSnapshotRequest) */ {
 public:
  inline DownloadEdgeSnapshotRequest() : DownloadEdgeSnapshotRequest(nullptr) {}
  ~DownloadEdgeSnapshotRequest() override;
  explicit PROTOBUF_CONSTEXPR DownloadEdgeSnapshotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadEdgeSnapshotRequest(const DownloadEdgeSnapshotRequest& from);
  DownloadEdgeSnapshotRequest(DownloadEdgeSnapshotRequest&& from) noexcept
    : DownloadEdgeSnapshotRequest() {
    *this = ::std::move(from);
  }

  inline DownloadEdgeSnapshotRequest& operator=(const DownloadEdgeSnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadEdgeSnapshotRequest& operator=(DownloadEdgeSnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadEdgeSnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadEdgeSnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const DownloadEdgeSnapshotRequest*>(
               &_DownloadEdgeSnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(DownloadEdgeSnapshotRequest& a, DownloadEdgeSnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadEdgeSnapshotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadEdgeSnapshotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadEdgeSnapshotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadEdgeSnapshotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DownloadEdgeSnapshotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DownloadEdgeSnapshotRequest& from) {
    DownloadEdgeSnapshotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadEdgeSnapshotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.DownloadEdgeSnapshotRequest";
  }
  protected:
  explicit DownloadEdgeSnapshotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEdgeSnapshotIdFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // string edge_snapshot_id = 2;
  void clear_edge_snapshot_id();
  const std::string& edge_snapshot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_edge_snapshot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_edge_snapshot_id();
  PROTOBUF_NODISCARD std::string* release_edge_snapshot_id();
  void set_allocated_edge_snapshot_id(std::string* edge_snapshot_id);
  private:
  const std::string& _internal_edge_snapshot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_edge_snapshot_id(const std::string& value);
  std::string* _internal_mutable_edge_snapshot_id();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.DownloadEdgeSnapshotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr edge_snapshot_id_;
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class DownloadEdgeSnapshotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse) */ {
 public:
  inline DownloadEdgeSnapshotResponse() : DownloadEdgeSnapshotResponse(nullptr) {}
  ~DownloadEdgeSnapshotResponse() override;
  explicit PROTOBUF_CONSTEXPR DownloadEdgeSnapshotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadEdgeSnapshotResponse(const DownloadEdgeSnapshotResponse& from);
  DownloadEdgeSnapshotResponse(DownloadEdgeSnapshotResponse&& from) noexcept
    : DownloadEdgeSnapshotResponse() {
    *this = ::std::move(from);
  }

  inline DownloadEdgeSnapshotResponse& operator=(const DownloadEdgeSnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadEdgeSnapshotResponse& operator=(DownloadEdgeSnapshotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadEdgeSnapshotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadEdgeSnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const DownloadEdgeSnapshotResponse*>(
               &_DownloadEdgeSnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(DownloadEdgeSnapshotResponse& a, DownloadEdgeSnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadEdgeSnapshotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadEdgeSnapshotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadEdgeSnapshotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadEdgeSnapshotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DownloadEdgeSnapshotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DownloadEdgeSnapshotResponse& from) {
    DownloadEdgeSnapshotResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadEdgeSnapshotResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse";
  }
  protected:
  explicit DownloadEdgeSnapshotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DownloadEdgeSnapshotResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    DownloadEdgeSnapshotResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    DownloadEdgeSnapshotResponse_Status_STATUS_OK;
  static constexpr Status STATUS_SNAPSHOT_DOES_NOT_EXIST =
    DownloadEdgeSnapshotResponse_Status_STATUS_SNAPSHOT_DOES_NOT_EXIST;
  static inline bool Status_IsValid(int value) {
    return DownloadEdgeSnapshotResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    DownloadEdgeSnapshotResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    DownloadEdgeSnapshotResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    DownloadEdgeSnapshotResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return DownloadEdgeSnapshotResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return DownloadEdgeSnapshotResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return DownloadEdgeSnapshotResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEdgeSnapshotIdFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kChunkFieldNumber = 5,
    kStatusFieldNumber = 2,
  };
  // string edge_snapshot_id = 4;
  void clear_edge_snapshot_id();
  const std::string& edge_snapshot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_edge_snapshot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_edge_snapshot_id();
  PROTOBUF_NODISCARD std::string* release_edge_snapshot_id();
  void set_allocated_edge_snapshot_id(std::string* edge_snapshot_id);
  private:
  const std::string& _internal_edge_snapshot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_edge_snapshot_id(const std::string& value);
  std::string* _internal_mutable_edge_snapshot_id();
  public:

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.DataChunk chunk = 5;
  bool has_chunk() const;
  private:
  bool _internal_has_chunk() const;
  public:
  void clear_chunk();
  const ::bosdyn::api::DataChunk& chunk() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataChunk* release_chunk();
  ::bosdyn::api::DataChunk* mutable_chunk();
  void set_allocated_chunk(::bosdyn::api::DataChunk* chunk);
  private:
  const ::bosdyn::api::DataChunk& _internal_chunk() const;
  ::bosdyn::api::DataChunk* _internal_mutable_chunk();
  public:
  void unsafe_arena_set_allocated_chunk(
      ::bosdyn::api::DataChunk* chunk);
  ::bosdyn::api::DataChunk* unsafe_arena_release_chunk();

  // .bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::graph_nav::DownloadEdgeSnapshotResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::DownloadEdgeSnapshotResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::DownloadEdgeSnapshotResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::DownloadEdgeSnapshotResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr edge_snapshot_id_;
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::DataChunk* chunk_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class AreaCallbackServiceError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.AreaCallbackServiceError) */ {
 public:
  inline AreaCallbackServiceError() : AreaCallbackServiceError(nullptr) {}
  ~AreaCallbackServiceError() override;
  explicit PROTOBUF_CONSTEXPR AreaCallbackServiceError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AreaCallbackServiceError(const AreaCallbackServiceError& from);
  AreaCallbackServiceError(AreaCallbackServiceError&& from) noexcept
    : AreaCallbackServiceError() {
    *this = ::std::move(from);
  }

  inline AreaCallbackServiceError& operator=(const AreaCallbackServiceError& from) {
    CopyFrom(from);
    return *this;
  }
  inline AreaCallbackServiceError& operator=(AreaCallbackServiceError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AreaCallbackServiceError& default_instance() {
    return *internal_default_instance();
  }
  static inline const AreaCallbackServiceError* internal_default_instance() {
    return reinterpret_cast<const AreaCallbackServiceError*>(
               &_AreaCallbackServiceError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(AreaCallbackServiceError& a, AreaCallbackServiceError& b) {
    a.Swap(&b);
  }
  inline void Swap(AreaCallbackServiceError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AreaCallbackServiceError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AreaCallbackServiceError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AreaCallbackServiceError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AreaCallbackServiceError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AreaCallbackServiceError& from) {
    AreaCallbackServiceError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AreaCallbackServiceError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.AreaCallbackServiceError";
  }
  protected:
  explicit AreaCallbackServiceError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMissingServicesFieldNumber = 1,
  };
  // repeated string missing_services = 1;
  int missing_services_size() const;
  private:
  int _internal_missing_services_size() const;
  public:
  void clear_missing_services();
  const std::string& missing_services(int index) const;
  std::string* mutable_missing_services(int index);
  void set_missing_services(int index, const std::string& value);
  void set_missing_services(int index, std::string&& value);
  void set_missing_services(int index, const char* value);
  void set_missing_services(int index, const char* value, size_t size);
  std::string* add_missing_services();
  void add_missing_services(const std::string& value);
  void add_missing_services(std::string&& value);
  void add_missing_services(const char* value);
  void add_missing_services(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& missing_services() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_missing_services();
  private:
  const std::string& _internal_missing_services(int index) const;
  std::string* _internal_add_missing_services();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.AreaCallbackServiceError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> missing_services_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class ValidateGraphRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.ValidateGraphRequest) */ {
 public:
  inline ValidateGraphRequest() : ValidateGraphRequest(nullptr) {}
  ~ValidateGraphRequest() override;
  explicit PROTOBUF_CONSTEXPR ValidateGraphRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateGraphRequest(const ValidateGraphRequest& from);
  ValidateGraphRequest(ValidateGraphRequest&& from) noexcept
    : ValidateGraphRequest() {
    *this = ::std::move(from);
  }

  inline ValidateGraphRequest& operator=(const ValidateGraphRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateGraphRequest& operator=(ValidateGraphRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateGraphRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateGraphRequest* internal_default_instance() {
    return reinterpret_cast<const ValidateGraphRequest*>(
               &_ValidateGraphRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ValidateGraphRequest& a, ValidateGraphRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateGraphRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateGraphRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateGraphRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateGraphRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateGraphRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidateGraphRequest& from) {
    ValidateGraphRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateGraphRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.ValidateGraphRequest";
  }
  protected:
  explicit ValidateGraphRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.ValidateGraphRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// -------------------------------------------------------------------

class ValidateGraphResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.ValidateGraphResponse) */ {
 public:
  inline ValidateGraphResponse() : ValidateGraphResponse(nullptr) {}
  ~ValidateGraphResponse() override;
  explicit PROTOBUF_CONSTEXPR ValidateGraphResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateGraphResponse(const ValidateGraphResponse& from);
  ValidateGraphResponse(ValidateGraphResponse&& from) noexcept
    : ValidateGraphResponse() {
    *this = ::std::move(from);
  }

  inline ValidateGraphResponse& operator=(const ValidateGraphResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateGraphResponse& operator=(ValidateGraphResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateGraphResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateGraphResponse* internal_default_instance() {
    return reinterpret_cast<const ValidateGraphResponse*>(
               &_ValidateGraphResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ValidateGraphResponse& a, ValidateGraphResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateGraphResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateGraphResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateGraphResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateGraphResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateGraphResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidateGraphResponse& from) {
    ValidateGraphResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateGraphResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.ValidateGraphResponse";
  }
  protected:
  explicit ValidateGraphResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ValidateGraphResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    ValidateGraphResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    ValidateGraphResponse_Status_STATUS_OK;
  static constexpr Status STATUS_INCOMPATIBLE_SENSORS =
    ValidateGraphResponse_Status_STATUS_INCOMPATIBLE_SENSORS;
  static constexpr Status STATUS_AREA_CALLBACK_ERROR =
    ValidateGraphResponse_Status_STATUS_AREA_CALLBACK_ERROR;
  static inline bool Status_IsValid(int value) {
    return ValidateGraphResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ValidateGraphResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ValidateGraphResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ValidateGraphResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return ValidateGraphResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ValidateGraphResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return ValidateGraphResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kSensorStatusFieldNumber = 3,
    kAreaCallbackErrorFieldNumber = 4,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.SensorCompatibilityStatus sensor_status = 3;
  bool has_sensor_status() const;
  private:
  bool _internal_has_sensor_status() const;
  public:
  void clear_sensor_status();
  const ::bosdyn::api::graph_nav::SensorCompatibilityStatus& sensor_status() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::SensorCompatibilityStatus* release_sensor_status();
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* mutable_sensor_status();
  void set_allocated_sensor_status(::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status);
  private:
  const ::bosdyn::api::graph_nav::SensorCompatibilityStatus& _internal_sensor_status() const;
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* _internal_mutable_sensor_status();
  public:
  void unsafe_arena_set_allocated_sensor_status(
      ::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status);
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* unsafe_arena_release_sensor_status();

  // .bosdyn.api.graph_nav.AreaCallbackServiceError area_callback_error = 4;
  bool has_area_callback_error() const;
  private:
  bool _internal_has_area_callback_error() const;
  public:
  void clear_area_callback_error();
  const ::bosdyn::api::graph_nav::AreaCallbackServiceError& area_callback_error() const;
  PROTOBUF_NODISCARD ::bosdyn::api::graph_nav::AreaCallbackServiceError* release_area_callback_error();
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* mutable_area_callback_error();
  void set_allocated_area_callback_error(::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error);
  private:
  const ::bosdyn::api::graph_nav::AreaCallbackServiceError& _internal_area_callback_error() const;
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* _internal_mutable_area_callback_error();
  public:
  void unsafe_arena_set_allocated_area_callback_error(
      ::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error);
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* unsafe_arena_release_area_callback_error();

  // .bosdyn.api.graph_nav.ValidateGraphResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::graph_nav::ValidateGraphResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::ValidateGraphResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::ValidateGraphResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::ValidateGraphResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.ValidateGraphResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status_;
    ::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VisualRefinementOptions

// bool verify_refinement_quality = 1;
inline void VisualRefinementOptions::clear_verify_refinement_quality() {
  _impl_.verify_refinement_quality_ = false;
}
inline bool VisualRefinementOptions::_internal_verify_refinement_quality() const {
  return _impl_.verify_refinement_quality_;
}
inline bool VisualRefinementOptions::verify_refinement_quality() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.VisualRefinementOptions.verify_refinement_quality)
  return _internal_verify_refinement_quality();
}
inline void VisualRefinementOptions::_internal_set_verify_refinement_quality(bool value) {
  
  _impl_.verify_refinement_quality_ = value;
}
inline void VisualRefinementOptions::set_verify_refinement_quality(bool value) {
  _internal_set_verify_refinement_quality(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.VisualRefinementOptions.verify_refinement_quality)
}

// -------------------------------------------------------------------

// SetLocalizationRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool SetLocalizationRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SetLocalizationRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& SetLocalizationRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& SetLocalizationRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationRequest.header)
  return _internal_header();
}
inline void SetLocalizationRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.SetLocalizationRequest.header)
}
inline ::bosdyn::api::RequestHeader* SetLocalizationRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* SetLocalizationRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetLocalizationRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* SetLocalizationRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* SetLocalizationRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetLocalizationRequest.header)
  return _msg;
}
inline void SetLocalizationRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.SetLocalizationRequest.header)
}

// .bosdyn.api.graph_nav.Localization initial_guess = 3;
inline bool SetLocalizationRequest::_internal_has_initial_guess() const {
  return this != internal_default_instance() && _impl_.initial_guess_ != nullptr;
}
inline bool SetLocalizationRequest::has_initial_guess() const {
  return _internal_has_initial_guess();
}
inline const ::bosdyn::api::graph_nav::Localization& SetLocalizationRequest::_internal_initial_guess() const {
  const ::bosdyn::api::graph_nav::Localization* p = _impl_.initial_guess_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::Localization&>(
      ::bosdyn::api::graph_nav::_Localization_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Localization& SetLocalizationRequest::initial_guess() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationRequest.initial_guess)
  return _internal_initial_guess();
}
inline void SetLocalizationRequest::unsafe_arena_set_allocated_initial_guess(
    ::bosdyn::api::graph_nav::Localization* initial_guess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.initial_guess_);
  }
  _impl_.initial_guess_ = initial_guess;
  if (initial_guess) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.SetLocalizationRequest.initial_guess)
}
inline ::bosdyn::api::graph_nav::Localization* SetLocalizationRequest::release_initial_guess() {
  
  ::bosdyn::api::graph_nav::Localization* temp = _impl_.initial_guess_;
  _impl_.initial_guess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::Localization* SetLocalizationRequest::unsafe_arena_release_initial_guess() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetLocalizationRequest.initial_guess)
  
  ::bosdyn::api::graph_nav::Localization* temp = _impl_.initial_guess_;
  _impl_.initial_guess_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Localization* SetLocalizationRequest::_internal_mutable_initial_guess() {
  
  if (_impl_.initial_guess_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Localization>(GetArenaForAllocation());
    _impl_.initial_guess_ = p;
  }
  return _impl_.initial_guess_;
}
inline ::bosdyn::api::graph_nav::Localization* SetLocalizationRequest::mutable_initial_guess() {
  ::bosdyn::api::graph_nav::Localization* _msg = _internal_mutable_initial_guess();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetLocalizationRequest.initial_guess)
  return _msg;
}
inline void SetLocalizationRequest::set_allocated_initial_guess(::bosdyn::api::graph_nav::Localization* initial_guess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.initial_guess_);
  }
  if (initial_guess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(initial_guess));
    if (message_arena != submessage_arena) {
      initial_guess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial_guess, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.initial_guess_ = initial_guess;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.SetLocalizationRequest.initial_guess)
}

// .bosdyn.api.SE3Pose ko_tform_body = 4;
inline bool SetLocalizationRequest::_internal_has_ko_tform_body() const {
  return this != internal_default_instance() && _impl_.ko_tform_body_ != nullptr;
}
inline bool SetLocalizationRequest::has_ko_tform_body() const {
  return _internal_has_ko_tform_body();
}
inline const ::bosdyn::api::SE3Pose& SetLocalizationRequest::_internal_ko_tform_body() const {
  const ::bosdyn::api::SE3Pose* p = _impl_.ko_tform_body_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Pose&>(
      ::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& SetLocalizationRequest::ko_tform_body() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationRequest.ko_tform_body)
  return _internal_ko_tform_body();
}
inline void SetLocalizationRequest::unsafe_arena_set_allocated_ko_tform_body(
    ::bosdyn::api::SE3Pose* ko_tform_body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ko_tform_body_);
  }
  _impl_.ko_tform_body_ = ko_tform_body;
  if (ko_tform_body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.SetLocalizationRequest.ko_tform_body)
}
inline ::bosdyn::api::SE3Pose* SetLocalizationRequest::release_ko_tform_body() {
  
  ::bosdyn::api::SE3Pose* temp = _impl_.ko_tform_body_;
  _impl_.ko_tform_body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Pose* SetLocalizationRequest::unsafe_arena_release_ko_tform_body() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetLocalizationRequest.ko_tform_body)
  
  ::bosdyn::api::SE3Pose* temp = _impl_.ko_tform_body_;
  _impl_.ko_tform_body_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* SetLocalizationRequest::_internal_mutable_ko_tform_body() {
  
  if (_impl_.ko_tform_body_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArenaForAllocation());
    _impl_.ko_tform_body_ = p;
  }
  return _impl_.ko_tform_body_;
}
inline ::bosdyn::api::SE3Pose* SetLocalizationRequest::mutable_ko_tform_body() {
  ::bosdyn::api::SE3Pose* _msg = _internal_mutable_ko_tform_body();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetLocalizationRequest.ko_tform_body)
  return _msg;
}
inline void SetLocalizationRequest::set_allocated_ko_tform_body(::bosdyn::api::SE3Pose* ko_tform_body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ko_tform_body_);
  }
  if (ko_tform_body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ko_tform_body));
    if (message_arena != submessage_arena) {
      ko_tform_body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ko_tform_body, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ko_tform_body_ = ko_tform_body;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.SetLocalizationRequest.ko_tform_body)
}

// double max_distance = 5;
inline void SetLocalizationRequest::clear_max_distance() {
  _impl_.max_distance_ = 0;
}
inline double SetLocalizationRequest::_internal_max_distance() const {
  return _impl_.max_distance_;
}
inline double SetLocalizationRequest::max_distance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationRequest.max_distance)
  return _internal_max_distance();
}
inline void SetLocalizationRequest::_internal_set_max_distance(double value) {
  
  _impl_.max_distance_ = value;
}
inline void SetLocalizationRequest::set_max_distance(double value) {
  _internal_set_max_distance(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.SetLocalizationRequest.max_distance)
}

// double max_yaw = 6;
inline void SetLocalizationRequest::clear_max_yaw() {
  _impl_.max_yaw_ = 0;
}
inline double SetLocalizationRequest::_internal_max_yaw() const {
  return _impl_.max_yaw_;
}
inline double SetLocalizationRequest::max_yaw() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationRequest.max_yaw)
  return _internal_max_yaw();
}
inline void SetLocalizationRequest::_internal_set_max_yaw(double value) {
  
  _impl_.max_yaw_ = value;
}
inline void SetLocalizationRequest::set_max_yaw(double value) {
  _internal_set_max_yaw(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.SetLocalizationRequest.max_yaw)
}

// .bosdyn.api.graph_nav.SetLocalizationRequest.FiducialInit fiducial_init = 7;
inline void SetLocalizationRequest::clear_fiducial_init() {
  _impl_.fiducial_init_ = 0;
}
inline ::bosdyn::api::graph_nav::SetLocalizationRequest_FiducialInit SetLocalizationRequest::_internal_fiducial_init() const {
  return static_cast< ::bosdyn::api::graph_nav::SetLocalizationRequest_FiducialInit >(_impl_.fiducial_init_);
}
inline ::bosdyn::api::graph_nav::SetLocalizationRequest_FiducialInit SetLocalizationRequest::fiducial_init() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationRequest.fiducial_init)
  return _internal_fiducial_init();
}
inline void SetLocalizationRequest::_internal_set_fiducial_init(::bosdyn::api::graph_nav::SetLocalizationRequest_FiducialInit value) {
  
  _impl_.fiducial_init_ = value;
}
inline void SetLocalizationRequest::set_fiducial_init(::bosdyn::api::graph_nav::SetLocalizationRequest_FiducialInit value) {
  _internal_set_fiducial_init(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.SetLocalizationRequest.fiducial_init)
}

// int32 use_fiducial_id = 8;
inline void SetLocalizationRequest::clear_use_fiducial_id() {
  _impl_.use_fiducial_id_ = 0;
}
inline int32_t SetLocalizationRequest::_internal_use_fiducial_id() const {
  return _impl_.use_fiducial_id_;
}
inline int32_t SetLocalizationRequest::use_fiducial_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationRequest.use_fiducial_id)
  return _internal_use_fiducial_id();
}
inline void SetLocalizationRequest::_internal_set_use_fiducial_id(int32_t value) {
  
  _impl_.use_fiducial_id_ = value;
}
inline void SetLocalizationRequest::set_use_fiducial_id(int32_t value) {
  _internal_set_use_fiducial_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.SetLocalizationRequest.use_fiducial_id)
}

// bool do_ambiguity_check = 10;
inline void SetLocalizationRequest::clear_do_ambiguity_check() {
  _impl_.do_ambiguity_check_ = false;
}
inline bool SetLocalizationRequest::_internal_do_ambiguity_check() const {
  return _impl_.do_ambiguity_check_;
}
inline bool SetLocalizationRequest::do_ambiguity_check() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationRequest.do_ambiguity_check)
  return _internal_do_ambiguity_check();
}
inline void SetLocalizationRequest::_internal_set_do_ambiguity_check(bool value) {
  
  _impl_.do_ambiguity_check_ = value;
}
inline void SetLocalizationRequest::set_do_ambiguity_check(bool value) {
  _internal_set_do_ambiguity_check(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.SetLocalizationRequest.do_ambiguity_check)
}

// bool restrict_fiducial_detections_to_target_waypoint = 11;
inline void SetLocalizationRequest::clear_restrict_fiducial_detections_to_target_waypoint() {
  _impl_.restrict_fiducial_detections_to_target_waypoint_ = false;
}
inline bool SetLocalizationRequest::_internal_restrict_fiducial_detections_to_target_waypoint() const {
  return _impl_.restrict_fiducial_detections_to_target_waypoint_;
}
inline bool SetLocalizationRequest::restrict_fiducial_detections_to_target_waypoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationRequest.restrict_fiducial_detections_to_target_waypoint)
  return _internal_restrict_fiducial_detections_to_target_waypoint();
}
inline void SetLocalizationRequest::_internal_set_restrict_fiducial_detections_to_target_waypoint(bool value) {
  
  _impl_.restrict_fiducial_detections_to_target_waypoint_ = value;
}
inline void SetLocalizationRequest::set_restrict_fiducial_detections_to_target_waypoint(bool value) {
  _internal_set_restrict_fiducial_detections_to_target_waypoint(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.SetLocalizationRequest.restrict_fiducial_detections_to_target_waypoint)
}

// bool refine_fiducial_result_with_icp = 9;
inline bool SetLocalizationRequest::_internal_has_refine_fiducial_result_with_icp() const {
  return refinement_case() == kRefineFiducialResultWithIcp;
}
inline bool SetLocalizationRequest::has_refine_fiducial_result_with_icp() const {
  return _internal_has_refine_fiducial_result_with_icp();
}
inline void SetLocalizationRequest::set_has_refine_fiducial_result_with_icp() {
  _impl_._oneof_case_[0] = kRefineFiducialResultWithIcp;
}
inline void SetLocalizationRequest::clear_refine_fiducial_result_with_icp() {
  if (_internal_has_refine_fiducial_result_with_icp()) {
    _impl_.refinement_.refine_fiducial_result_with_icp_ = false;
    clear_has_refinement();
  }
}
inline bool SetLocalizationRequest::_internal_refine_fiducial_result_with_icp() const {
  if (_internal_has_refine_fiducial_result_with_icp()) {
    return _impl_.refinement_.refine_fiducial_result_with_icp_;
  }
  return false;
}
inline void SetLocalizationRequest::_internal_set_refine_fiducial_result_with_icp(bool value) {
  if (!_internal_has_refine_fiducial_result_with_icp()) {
    clear_refinement();
    set_has_refine_fiducial_result_with_icp();
  }
  _impl_.refinement_.refine_fiducial_result_with_icp_ = value;
}
inline bool SetLocalizationRequest::refine_fiducial_result_with_icp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationRequest.refine_fiducial_result_with_icp)
  return _internal_refine_fiducial_result_with_icp();
}
inline void SetLocalizationRequest::set_refine_fiducial_result_with_icp(bool value) {
  _internal_set_refine_fiducial_result_with_icp(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.SetLocalizationRequest.refine_fiducial_result_with_icp)
}

// .bosdyn.api.graph_nav.VisualRefinementOptions refine_with_visual_features = 12;
inline bool SetLocalizationRequest::_internal_has_refine_with_visual_features() const {
  return refinement_case() == kRefineWithVisualFeatures;
}
inline bool SetLocalizationRequest::has_refine_with_visual_features() const {
  return _internal_has_refine_with_visual_features();
}
inline void SetLocalizationRequest::set_has_refine_with_visual_features() {
  _impl_._oneof_case_[0] = kRefineWithVisualFeatures;
}
inline void SetLocalizationRequest::clear_refine_with_visual_features() {
  if (_internal_has_refine_with_visual_features()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.refinement_.refine_with_visual_features_;
    }
    clear_has_refinement();
  }
}
inline ::bosdyn::api::graph_nav::VisualRefinementOptions* SetLocalizationRequest::release_refine_with_visual_features() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetLocalizationRequest.refine_with_visual_features)
  if (_internal_has_refine_with_visual_features()) {
    clear_has_refinement();
    ::bosdyn::api::graph_nav::VisualRefinementOptions* temp = _impl_.refinement_.refine_with_visual_features_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.refinement_.refine_with_visual_features_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::graph_nav::VisualRefinementOptions& SetLocalizationRequest::_internal_refine_with_visual_features() const {
  return _internal_has_refine_with_visual_features()
      ? *_impl_.refinement_.refine_with_visual_features_
      : reinterpret_cast< ::bosdyn::api::graph_nav::VisualRefinementOptions&>(::bosdyn::api::graph_nav::_VisualRefinementOptions_default_instance_);
}
inline const ::bosdyn::api::graph_nav::VisualRefinementOptions& SetLocalizationRequest::refine_with_visual_features() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationRequest.refine_with_visual_features)
  return _internal_refine_with_visual_features();
}
inline ::bosdyn::api::graph_nav::VisualRefinementOptions* SetLocalizationRequest::unsafe_arena_release_refine_with_visual_features() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.graph_nav.SetLocalizationRequest.refine_with_visual_features)
  if (_internal_has_refine_with_visual_features()) {
    clear_has_refinement();
    ::bosdyn::api::graph_nav::VisualRefinementOptions* temp = _impl_.refinement_.refine_with_visual_features_;
    _impl_.refinement_.refine_with_visual_features_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SetLocalizationRequest::unsafe_arena_set_allocated_refine_with_visual_features(::bosdyn::api::graph_nav::VisualRefinementOptions* refine_with_visual_features) {
  clear_refinement();
  if (refine_with_visual_features) {
    set_has_refine_with_visual_features();
    _impl_.refinement_.refine_with_visual_features_ = refine_with_visual_features;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.SetLocalizationRequest.refine_with_visual_features)
}
inline ::bosdyn::api::graph_nav::VisualRefinementOptions* SetLocalizationRequest::_internal_mutable_refine_with_visual_features() {
  if (!_internal_has_refine_with_visual_features()) {
    clear_refinement();
    set_has_refine_with_visual_features();
    _impl_.refinement_.refine_with_visual_features_ = CreateMaybeMessage< ::bosdyn::api::graph_nav::VisualRefinementOptions >(GetArenaForAllocation());
  }
  return _impl_.refinement_.refine_with_visual_features_;
}
inline ::bosdyn::api::graph_nav::VisualRefinementOptions* SetLocalizationRequest::mutable_refine_with_visual_features() {
  ::bosdyn::api::graph_nav::VisualRefinementOptions* _msg = _internal_mutable_refine_with_visual_features();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetLocalizationRequest.refine_with_visual_features)
  return _msg;
}

inline bool SetLocalizationRequest::has_refinement() const {
  return refinement_case() != REFINEMENT_NOT_SET;
}
inline void SetLocalizationRequest::clear_has_refinement() {
  _impl_._oneof_case_[0] = REFINEMENT_NOT_SET;
}
inline SetLocalizationRequest::RefinementCase SetLocalizationRequest::refinement_case() const {
  return SetLocalizationRequest::RefinementCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SensorCompatibilityStatus

// bool map_has_lidar_data = 1;
inline void SensorCompatibilityStatus::clear_map_has_lidar_data() {
  _impl_.map_has_lidar_data_ = false;
}
inline bool SensorCompatibilityStatus::_internal_map_has_lidar_data() const {
  return _impl_.map_has_lidar_data_;
}
inline bool SensorCompatibilityStatus::map_has_lidar_data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SensorCompatibilityStatus.map_has_lidar_data)
  return _internal_map_has_lidar_data();
}
inline void SensorCompatibilityStatus::_internal_set_map_has_lidar_data(bool value) {
  
  _impl_.map_has_lidar_data_ = value;
}
inline void SensorCompatibilityStatus::set_map_has_lidar_data(bool value) {
  _internal_set_map_has_lidar_data(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.SensorCompatibilityStatus.map_has_lidar_data)
}

// bool robot_configured_for_lidar = 2;
inline void SensorCompatibilityStatus::clear_robot_configured_for_lidar() {
  _impl_.robot_configured_for_lidar_ = false;
}
inline bool SensorCompatibilityStatus::_internal_robot_configured_for_lidar() const {
  return _impl_.robot_configured_for_lidar_;
}
inline bool SensorCompatibilityStatus::robot_configured_for_lidar() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SensorCompatibilityStatus.robot_configured_for_lidar)
  return _internal_robot_configured_for_lidar();
}
inline void SensorCompatibilityStatus::_internal_set_robot_configured_for_lidar(bool value) {
  
  _impl_.robot_configured_for_lidar_ = value;
}
inline void SensorCompatibilityStatus::set_robot_configured_for_lidar(bool value) {
  _internal_set_robot_configured_for_lidar(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.SensorCompatibilityStatus.robot_configured_for_lidar)
}

// -------------------------------------------------------------------

// SetLocalizationResponse_SuspectedAmbiguity

// .bosdyn.api.SE3Pose alternate_robot_tform_waypoint = 1;
inline bool SetLocalizationResponse_SuspectedAmbiguity::_internal_has_alternate_robot_tform_waypoint() const {
  return this != internal_default_instance() && _impl_.alternate_robot_tform_waypoint_ != nullptr;
}
inline bool SetLocalizationResponse_SuspectedAmbiguity::has_alternate_robot_tform_waypoint() const {
  return _internal_has_alternate_robot_tform_waypoint();
}
inline const ::bosdyn::api::SE3Pose& SetLocalizationResponse_SuspectedAmbiguity::_internal_alternate_robot_tform_waypoint() const {
  const ::bosdyn::api::SE3Pose* p = _impl_.alternate_robot_tform_waypoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Pose&>(
      ::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& SetLocalizationResponse_SuspectedAmbiguity::alternate_robot_tform_waypoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationResponse.SuspectedAmbiguity.alternate_robot_tform_waypoint)
  return _internal_alternate_robot_tform_waypoint();
}
inline void SetLocalizationResponse_SuspectedAmbiguity::unsafe_arena_set_allocated_alternate_robot_tform_waypoint(
    ::bosdyn::api::SE3Pose* alternate_robot_tform_waypoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alternate_robot_tform_waypoint_);
  }
  _impl_.alternate_robot_tform_waypoint_ = alternate_robot_tform_waypoint;
  if (alternate_robot_tform_waypoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.SetLocalizationResponse.SuspectedAmbiguity.alternate_robot_tform_waypoint)
}
inline ::bosdyn::api::SE3Pose* SetLocalizationResponse_SuspectedAmbiguity::release_alternate_robot_tform_waypoint() {
  
  ::bosdyn::api::SE3Pose* temp = _impl_.alternate_robot_tform_waypoint_;
  _impl_.alternate_robot_tform_waypoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Pose* SetLocalizationResponse_SuspectedAmbiguity::unsafe_arena_release_alternate_robot_tform_waypoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetLocalizationResponse.SuspectedAmbiguity.alternate_robot_tform_waypoint)
  
  ::bosdyn::api::SE3Pose* temp = _impl_.alternate_robot_tform_waypoint_;
  _impl_.alternate_robot_tform_waypoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* SetLocalizationResponse_SuspectedAmbiguity::_internal_mutable_alternate_robot_tform_waypoint() {
  
  if (_impl_.alternate_robot_tform_waypoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArenaForAllocation());
    _impl_.alternate_robot_tform_waypoint_ = p;
  }
  return _impl_.alternate_robot_tform_waypoint_;
}
inline ::bosdyn::api::SE3Pose* SetLocalizationResponse_SuspectedAmbiguity::mutable_alternate_robot_tform_waypoint() {
  ::bosdyn::api::SE3Pose* _msg = _internal_mutable_alternate_robot_tform_waypoint();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetLocalizationResponse.SuspectedAmbiguity.alternate_robot_tform_waypoint)
  return _msg;
}
inline void SetLocalizationResponse_SuspectedAmbiguity::set_allocated_alternate_robot_tform_waypoint(::bosdyn::api::SE3Pose* alternate_robot_tform_waypoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alternate_robot_tform_waypoint_);
  }
  if (alternate_robot_tform_waypoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alternate_robot_tform_waypoint));
    if (message_arena != submessage_arena) {
      alternate_robot_tform_waypoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alternate_robot_tform_waypoint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.alternate_robot_tform_waypoint_ = alternate_robot_tform_waypoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.SetLocalizationResponse.SuspectedAmbiguity.alternate_robot_tform_waypoint)
}

// -------------------------------------------------------------------

// SetLocalizationResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool SetLocalizationResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SetLocalizationResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& SetLocalizationResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& SetLocalizationResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationResponse.header)
  return _internal_header();
}
inline void SetLocalizationResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.SetLocalizationResponse.header)
}
inline ::bosdyn::api::ResponseHeader* SetLocalizationResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SetLocalizationResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetLocalizationResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SetLocalizationResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* SetLocalizationResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetLocalizationResponse.header)
  return _msg;
}
inline void SetLocalizationResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.SetLocalizationResponse.header)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool SetLocalizationResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && _impl_.lease_use_result_ != nullptr;
}
inline bool SetLocalizationResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& SetLocalizationResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = _impl_.lease_use_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::LeaseUseResult&>(
      ::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& SetLocalizationResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void SetLocalizationResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  _impl_.lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.SetLocalizationResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* SetLocalizationResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* SetLocalizationResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetLocalizationResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* SetLocalizationResponse::_internal_mutable_lease_use_result() {
  
  if (_impl_.lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArenaForAllocation());
    _impl_.lease_use_result_ = p;
  }
  return _impl_.lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* SetLocalizationResponse::mutable_lease_use_result() {
  ::bosdyn::api::LeaseUseResult* _msg = _internal_mutable_lease_use_result();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetLocalizationResponse.lease_use_result)
  return _msg;
}
inline void SetLocalizationResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result));
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.SetLocalizationResponse.lease_use_result)
}

// .bosdyn.api.graph_nav.SetLocalizationResponse.Status status = 3;
inline void SetLocalizationResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::graph_nav::SetLocalizationResponse_Status SetLocalizationResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::SetLocalizationResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::graph_nav::SetLocalizationResponse_Status SetLocalizationResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationResponse.status)
  return _internal_status();
}
inline void SetLocalizationResponse::_internal_set_status(::bosdyn::api::graph_nav::SetLocalizationResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void SetLocalizationResponse::set_status(::bosdyn::api::graph_nav::SetLocalizationResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.SetLocalizationResponse.status)
}

// string error_report = 4;
inline void SetLocalizationResponse::clear_error_report() {
  _impl_.error_report_.ClearToEmpty();
}
inline const std::string& SetLocalizationResponse::error_report() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationResponse.error_report)
  return _internal_error_report();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetLocalizationResponse::set_error_report(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_report_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.SetLocalizationResponse.error_report)
}
inline std::string* SetLocalizationResponse::mutable_error_report() {
  std::string* _s = _internal_mutable_error_report();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetLocalizationResponse.error_report)
  return _s;
}
inline const std::string& SetLocalizationResponse::_internal_error_report() const {
  return _impl_.error_report_.Get();
}
inline void SetLocalizationResponse::_internal_set_error_report(const std::string& value) {
  
  _impl_.error_report_.Set(value, GetArenaForAllocation());
}
inline std::string* SetLocalizationResponse::_internal_mutable_error_report() {
  
  return _impl_.error_report_.Mutable(GetArenaForAllocation());
}
inline std::string* SetLocalizationResponse::release_error_report() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetLocalizationResponse.error_report)
  return _impl_.error_report_.Release();
}
inline void SetLocalizationResponse::set_allocated_error_report(std::string* error_report) {
  if (error_report != nullptr) {
    
  } else {
    
  }
  _impl_.error_report_.SetAllocated(error_report, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_report_.IsDefault()) {
    _impl_.error_report_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.SetLocalizationResponse.error_report)
}

// .bosdyn.api.graph_nav.Localization localization = 5;
inline bool SetLocalizationResponse::_internal_has_localization() const {
  return this != internal_default_instance() && _impl_.localization_ != nullptr;
}
inline bool SetLocalizationResponse::has_localization() const {
  return _internal_has_localization();
}
inline const ::bosdyn::api::graph_nav::Localization& SetLocalizationResponse::_internal_localization() const {
  const ::bosdyn::api::graph_nav::Localization* p = _impl_.localization_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::Localization&>(
      ::bosdyn::api::graph_nav::_Localization_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Localization& SetLocalizationResponse::localization() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationResponse.localization)
  return _internal_localization();
}
inline void SetLocalizationResponse::unsafe_arena_set_allocated_localization(
    ::bosdyn::api::graph_nav::Localization* localization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.localization_);
  }
  _impl_.localization_ = localization;
  if (localization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.SetLocalizationResponse.localization)
}
inline ::bosdyn::api::graph_nav::Localization* SetLocalizationResponse::release_localization() {
  
  ::bosdyn::api::graph_nav::Localization* temp = _impl_.localization_;
  _impl_.localization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::Localization* SetLocalizationResponse::unsafe_arena_release_localization() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetLocalizationResponse.localization)
  
  ::bosdyn::api::graph_nav::Localization* temp = _impl_.localization_;
  _impl_.localization_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Localization* SetLocalizationResponse::_internal_mutable_localization() {
  
  if (_impl_.localization_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Localization>(GetArenaForAllocation());
    _impl_.localization_ = p;
  }
  return _impl_.localization_;
}
inline ::bosdyn::api::graph_nav::Localization* SetLocalizationResponse::mutable_localization() {
  ::bosdyn::api::graph_nav::Localization* _msg = _internal_mutable_localization();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetLocalizationResponse.localization)
  return _msg;
}
inline void SetLocalizationResponse::set_allocated_localization(::bosdyn::api::graph_nav::Localization* localization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.localization_);
  }
  if (localization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(localization));
    if (message_arena != submessage_arena) {
      localization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, localization, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.localization_ = localization;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.SetLocalizationResponse.localization)
}

// .bosdyn.api.graph_nav.SetLocalizationResponse.SuspectedAmbiguity suspected_ambiguity = 7;
inline bool SetLocalizationResponse::_internal_has_suspected_ambiguity() const {
  return this != internal_default_instance() && _impl_.suspected_ambiguity_ != nullptr;
}
inline bool SetLocalizationResponse::has_suspected_ambiguity() const {
  return _internal_has_suspected_ambiguity();
}
inline void SetLocalizationResponse::clear_suspected_ambiguity() {
  if (GetArenaForAllocation() == nullptr && _impl_.suspected_ambiguity_ != nullptr) {
    delete _impl_.suspected_ambiguity_;
  }
  _impl_.suspected_ambiguity_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity& SetLocalizationResponse::_internal_suspected_ambiguity() const {
  const ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* p = _impl_.suspected_ambiguity_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity&>(
      ::bosdyn::api::graph_nav::_SetLocalizationResponse_SuspectedAmbiguity_default_instance_);
}
inline const ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity& SetLocalizationResponse::suspected_ambiguity() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationResponse.suspected_ambiguity)
  return _internal_suspected_ambiguity();
}
inline void SetLocalizationResponse::unsafe_arena_set_allocated_suspected_ambiguity(
    ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* suspected_ambiguity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.suspected_ambiguity_);
  }
  _impl_.suspected_ambiguity_ = suspected_ambiguity;
  if (suspected_ambiguity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.SetLocalizationResponse.suspected_ambiguity)
}
inline ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* SetLocalizationResponse::release_suspected_ambiguity() {
  
  ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* temp = _impl_.suspected_ambiguity_;
  _impl_.suspected_ambiguity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* SetLocalizationResponse::unsafe_arena_release_suspected_ambiguity() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetLocalizationResponse.suspected_ambiguity)
  
  ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* temp = _impl_.suspected_ambiguity_;
  _impl_.suspected_ambiguity_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* SetLocalizationResponse::_internal_mutable_suspected_ambiguity() {
  
  if (_impl_.suspected_ambiguity_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity>(GetArenaForAllocation());
    _impl_.suspected_ambiguity_ = p;
  }
  return _impl_.suspected_ambiguity_;
}
inline ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* SetLocalizationResponse::mutable_suspected_ambiguity() {
  ::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* _msg = _internal_mutable_suspected_ambiguity();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetLocalizationResponse.suspected_ambiguity)
  return _msg;
}
inline void SetLocalizationResponse::set_allocated_suspected_ambiguity(::bosdyn::api::graph_nav::SetLocalizationResponse_SuspectedAmbiguity* suspected_ambiguity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.suspected_ambiguity_;
  }
  if (suspected_ambiguity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(suspected_ambiguity);
    if (message_arena != submessage_arena) {
      suspected_ambiguity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, suspected_ambiguity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.suspected_ambiguity_ = suspected_ambiguity;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.SetLocalizationResponse.suspected_ambiguity)
}

// .bosdyn.api.RobotImpairedState impaired_state = 8;
inline bool SetLocalizationResponse::_internal_has_impaired_state() const {
  return this != internal_default_instance() && _impl_.impaired_state_ != nullptr;
}
inline bool SetLocalizationResponse::has_impaired_state() const {
  return _internal_has_impaired_state();
}
inline const ::bosdyn::api::RobotImpairedState& SetLocalizationResponse::_internal_impaired_state() const {
  const ::bosdyn::api::RobotImpairedState* p = _impl_.impaired_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RobotImpairedState&>(
      ::bosdyn::api::_RobotImpairedState_default_instance_);
}
inline const ::bosdyn::api::RobotImpairedState& SetLocalizationResponse::impaired_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationResponse.impaired_state)
  return _internal_impaired_state();
}
inline void SetLocalizationResponse::unsafe_arena_set_allocated_impaired_state(
    ::bosdyn::api::RobotImpairedState* impaired_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.impaired_state_);
  }
  _impl_.impaired_state_ = impaired_state;
  if (impaired_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.SetLocalizationResponse.impaired_state)
}
inline ::bosdyn::api::RobotImpairedState* SetLocalizationResponse::release_impaired_state() {
  
  ::bosdyn::api::RobotImpairedState* temp = _impl_.impaired_state_;
  _impl_.impaired_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RobotImpairedState* SetLocalizationResponse::unsafe_arena_release_impaired_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetLocalizationResponse.impaired_state)
  
  ::bosdyn::api::RobotImpairedState* temp = _impl_.impaired_state_;
  _impl_.impaired_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RobotImpairedState* SetLocalizationResponse::_internal_mutable_impaired_state() {
  
  if (_impl_.impaired_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RobotImpairedState>(GetArenaForAllocation());
    _impl_.impaired_state_ = p;
  }
  return _impl_.impaired_state_;
}
inline ::bosdyn::api::RobotImpairedState* SetLocalizationResponse::mutable_impaired_state() {
  ::bosdyn::api::RobotImpairedState* _msg = _internal_mutable_impaired_state();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetLocalizationResponse.impaired_state)
  return _msg;
}
inline void SetLocalizationResponse::set_allocated_impaired_state(::bosdyn::api::RobotImpairedState* impaired_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.impaired_state_);
  }
  if (impaired_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(impaired_state));
    if (message_arena != submessage_arena) {
      impaired_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, impaired_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.impaired_state_ = impaired_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.SetLocalizationResponse.impaired_state)
}

// .bosdyn.api.graph_nav.SensorCompatibilityStatus sensor_status = 9;
inline bool SetLocalizationResponse::_internal_has_sensor_status() const {
  return this != internal_default_instance() && _impl_.sensor_status_ != nullptr;
}
inline bool SetLocalizationResponse::has_sensor_status() const {
  return _internal_has_sensor_status();
}
inline void SetLocalizationResponse::clear_sensor_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.sensor_status_ != nullptr) {
    delete _impl_.sensor_status_;
  }
  _impl_.sensor_status_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::SensorCompatibilityStatus& SetLocalizationResponse::_internal_sensor_status() const {
  const ::bosdyn::api::graph_nav::SensorCompatibilityStatus* p = _impl_.sensor_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::SensorCompatibilityStatus&>(
      ::bosdyn::api::graph_nav::_SensorCompatibilityStatus_default_instance_);
}
inline const ::bosdyn::api::graph_nav::SensorCompatibilityStatus& SetLocalizationResponse::sensor_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetLocalizationResponse.sensor_status)
  return _internal_sensor_status();
}
inline void SetLocalizationResponse::unsafe_arena_set_allocated_sensor_status(
    ::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sensor_status_);
  }
  _impl_.sensor_status_ = sensor_status;
  if (sensor_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.SetLocalizationResponse.sensor_status)
}
inline ::bosdyn::api::graph_nav::SensorCompatibilityStatus* SetLocalizationResponse::release_sensor_status() {
  
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* temp = _impl_.sensor_status_;
  _impl_.sensor_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::SensorCompatibilityStatus* SetLocalizationResponse::unsafe_arena_release_sensor_status() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetLocalizationResponse.sensor_status)
  
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* temp = _impl_.sensor_status_;
  _impl_.sensor_status_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::SensorCompatibilityStatus* SetLocalizationResponse::_internal_mutable_sensor_status() {
  
  if (_impl_.sensor_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::SensorCompatibilityStatus>(GetArenaForAllocation());
    _impl_.sensor_status_ = p;
  }
  return _impl_.sensor_status_;
}
inline ::bosdyn::api::graph_nav::SensorCompatibilityStatus* SetLocalizationResponse::mutable_sensor_status() {
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* _msg = _internal_mutable_sensor_status();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetLocalizationResponse.sensor_status)
  return _msg;
}
inline void SetLocalizationResponse::set_allocated_sensor_status(::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sensor_status_;
  }
  if (sensor_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sensor_status);
    if (message_arena != submessage_arena) {
      sensor_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sensor_status_ = sensor_status;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.SetLocalizationResponse.sensor_status)
}

// -------------------------------------------------------------------

// RouteGenParams

// -------------------------------------------------------------------

// TravelParams

// double max_distance = 1;
inline void TravelParams::clear_max_distance() {
  _impl_.max_distance_ = 0;
}
inline double TravelParams::_internal_max_distance() const {
  return _impl_.max_distance_;
}
inline double TravelParams::max_distance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.TravelParams.max_distance)
  return _internal_max_distance();
}
inline void TravelParams::_internal_set_max_distance(double value) {
  
  _impl_.max_distance_ = value;
}
inline void TravelParams::set_max_distance(double value) {
  _internal_set_max_distance(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.TravelParams.max_distance)
}

// double max_yaw = 2;
inline void TravelParams::clear_max_yaw() {
  _impl_.max_yaw_ = 0;
}
inline double TravelParams::_internal_max_yaw() const {
  return _impl_.max_yaw_;
}
inline double TravelParams::max_yaw() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.TravelParams.max_yaw)
  return _internal_max_yaw();
}
inline void TravelParams::_internal_set_max_yaw(double value) {
  
  _impl_.max_yaw_ = value;
}
inline void TravelParams::set_max_yaw(double value) {
  _internal_set_max_yaw(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.TravelParams.max_yaw)
}

// .bosdyn.api.SE2VelocityLimit velocity_limit = 3;
inline bool TravelParams::_internal_has_velocity_limit() const {
  return this != internal_default_instance() && _impl_.velocity_limit_ != nullptr;
}
inline bool TravelParams::has_velocity_limit() const {
  return _internal_has_velocity_limit();
}
inline const ::bosdyn::api::SE2VelocityLimit& TravelParams::_internal_velocity_limit() const {
  const ::bosdyn::api::SE2VelocityLimit* p = _impl_.velocity_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE2VelocityLimit&>(
      ::bosdyn::api::_SE2VelocityLimit_default_instance_);
}
inline const ::bosdyn::api::SE2VelocityLimit& TravelParams::velocity_limit() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.TravelParams.velocity_limit)
  return _internal_velocity_limit();
}
inline void TravelParams::unsafe_arena_set_allocated_velocity_limit(
    ::bosdyn::api::SE2VelocityLimit* velocity_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_limit_);
  }
  _impl_.velocity_limit_ = velocity_limit;
  if (velocity_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.TravelParams.velocity_limit)
}
inline ::bosdyn::api::SE2VelocityLimit* TravelParams::release_velocity_limit() {
  
  ::bosdyn::api::SE2VelocityLimit* temp = _impl_.velocity_limit_;
  _impl_.velocity_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE2VelocityLimit* TravelParams::unsafe_arena_release_velocity_limit() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.TravelParams.velocity_limit)
  
  ::bosdyn::api::SE2VelocityLimit* temp = _impl_.velocity_limit_;
  _impl_.velocity_limit_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE2VelocityLimit* TravelParams::_internal_mutable_velocity_limit() {
  
  if (_impl_.velocity_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE2VelocityLimit>(GetArenaForAllocation());
    _impl_.velocity_limit_ = p;
  }
  return _impl_.velocity_limit_;
}
inline ::bosdyn::api::SE2VelocityLimit* TravelParams::mutable_velocity_limit() {
  ::bosdyn::api::SE2VelocityLimit* _msg = _internal_mutable_velocity_limit();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.TravelParams.velocity_limit)
  return _msg;
}
inline void TravelParams::set_allocated_velocity_limit(::bosdyn::api::SE2VelocityLimit* velocity_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_limit_);
  }
  if (velocity_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_limit));
    if (message_arena != submessage_arena) {
      velocity_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity_limit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.velocity_limit_ = velocity_limit;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.TravelParams.velocity_limit)
}

// bool ignore_final_yaw = 4;
inline void TravelParams::clear_ignore_final_yaw() {
  _impl_.ignore_final_yaw_ = false;
}
inline bool TravelParams::_internal_ignore_final_yaw() const {
  return _impl_.ignore_final_yaw_;
}
inline bool TravelParams::ignore_final_yaw() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.TravelParams.ignore_final_yaw)
  return _internal_ignore_final_yaw();
}
inline void TravelParams::_internal_set_ignore_final_yaw(bool value) {
  
  _impl_.ignore_final_yaw_ = value;
}
inline void TravelParams::set_ignore_final_yaw(bool value) {
  _internal_set_ignore_final_yaw(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.TravelParams.ignore_final_yaw)
}

// .bosdyn.api.graph_nav.TravelParams.FeatureQualityTolerance feature_quality_tolerance = 5;
inline void TravelParams::clear_feature_quality_tolerance() {
  _impl_.feature_quality_tolerance_ = 0;
}
inline ::bosdyn::api::graph_nav::TravelParams_FeatureQualityTolerance TravelParams::_internal_feature_quality_tolerance() const {
  return static_cast< ::bosdyn::api::graph_nav::TravelParams_FeatureQualityTolerance >(_impl_.feature_quality_tolerance_);
}
inline ::bosdyn::api::graph_nav::TravelParams_FeatureQualityTolerance TravelParams::feature_quality_tolerance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.TravelParams.feature_quality_tolerance)
  return _internal_feature_quality_tolerance();
}
inline void TravelParams::_internal_set_feature_quality_tolerance(::bosdyn::api::graph_nav::TravelParams_FeatureQualityTolerance value) {
  
  _impl_.feature_quality_tolerance_ = value;
}
inline void TravelParams::set_feature_quality_tolerance(::bosdyn::api::graph_nav::TravelParams_FeatureQualityTolerance value) {
  _internal_set_feature_quality_tolerance(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.TravelParams.feature_quality_tolerance)
}

// bool disable_directed_exploration = 6;
inline void TravelParams::clear_disable_directed_exploration() {
  _impl_.disable_directed_exploration_ = false;
}
inline bool TravelParams::_internal_disable_directed_exploration() const {
  return _impl_.disable_directed_exploration_;
}
inline bool TravelParams::disable_directed_exploration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.TravelParams.disable_directed_exploration)
  return _internal_disable_directed_exploration();
}
inline void TravelParams::_internal_set_disable_directed_exploration(bool value) {
  
  _impl_.disable_directed_exploration_ = value;
}
inline void TravelParams::set_disable_directed_exploration(bool value) {
  _internal_set_disable_directed_exploration(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.TravelParams.disable_directed_exploration)
}

// bool disable_alternate_route_finding = 8;
inline void TravelParams::clear_disable_alternate_route_finding() {
  _impl_.disable_alternate_route_finding_ = false;
}
inline bool TravelParams::_internal_disable_alternate_route_finding() const {
  return _impl_.disable_alternate_route_finding_;
}
inline bool TravelParams::disable_alternate_route_finding() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.TravelParams.disable_alternate_route_finding)
  return _internal_disable_alternate_route_finding();
}
inline void TravelParams::_internal_set_disable_alternate_route_finding(bool value) {
  
  _impl_.disable_alternate_route_finding_ = value;
}
inline void TravelParams::set_disable_alternate_route_finding(bool value) {
  _internal_set_disable_alternate_route_finding(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.TravelParams.disable_alternate_route_finding)
}

// .bosdyn.api.graph_nav.Edge.Annotations.PathFollowingMode path_following_mode = 9;
inline void TravelParams::clear_path_following_mode() {
  _impl_.path_following_mode_ = 0;
}
inline ::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode TravelParams::_internal_path_following_mode() const {
  return static_cast< ::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode >(_impl_.path_following_mode_);
}
inline ::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode TravelParams::path_following_mode() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.TravelParams.path_following_mode)
  return _internal_path_following_mode();
}
inline void TravelParams::_internal_set_path_following_mode(::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode value) {
  
  _impl_.path_following_mode_ = value;
}
inline void TravelParams::set_path_following_mode(::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode value) {
  _internal_set_path_following_mode(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.TravelParams.path_following_mode)
}

// .google.protobuf.Duration blocked_path_wait_time = 10;
inline bool TravelParams::_internal_has_blocked_path_wait_time() const {
  return this != internal_default_instance() && _impl_.blocked_path_wait_time_ != nullptr;
}
inline bool TravelParams::has_blocked_path_wait_time() const {
  return _internal_has_blocked_path_wait_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& TravelParams::_internal_blocked_path_wait_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.blocked_path_wait_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& TravelParams::blocked_path_wait_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.TravelParams.blocked_path_wait_time)
  return _internal_blocked_path_wait_time();
}
inline void TravelParams::unsafe_arena_set_allocated_blocked_path_wait_time(
    ::PROTOBUF_NAMESPACE_ID::Duration* blocked_path_wait_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blocked_path_wait_time_);
  }
  _impl_.blocked_path_wait_time_ = blocked_path_wait_time;
  if (blocked_path_wait_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.TravelParams.blocked_path_wait_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TravelParams::release_blocked_path_wait_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.blocked_path_wait_time_;
  _impl_.blocked_path_wait_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TravelParams::unsafe_arena_release_blocked_path_wait_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.TravelParams.blocked_path_wait_time)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.blocked_path_wait_time_;
  _impl_.blocked_path_wait_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TravelParams::_internal_mutable_blocked_path_wait_time() {
  
  if (_impl_.blocked_path_wait_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.blocked_path_wait_time_ = p;
  }
  return _impl_.blocked_path_wait_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TravelParams::mutable_blocked_path_wait_time() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_blocked_path_wait_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.TravelParams.blocked_path_wait_time)
  return _msg;
}
inline void TravelParams::set_allocated_blocked_path_wait_time(::PROTOBUF_NAMESPACE_ID::Duration* blocked_path_wait_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blocked_path_wait_time_);
  }
  if (blocked_path_wait_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blocked_path_wait_time));
    if (message_arena != submessage_arena) {
      blocked_path_wait_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blocked_path_wait_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.blocked_path_wait_time_ = blocked_path_wait_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.TravelParams.blocked_path_wait_time)
}

// .bosdyn.api.graph_nav.Edge.Annotations.GroundClutterAvoidanceMode ground_clutter_mode = 11;
inline void TravelParams::clear_ground_clutter_mode() {
  _impl_.ground_clutter_mode_ = 0;
}
inline ::bosdyn::api::graph_nav::Edge_Annotations_GroundClutterAvoidanceMode TravelParams::_internal_ground_clutter_mode() const {
  return static_cast< ::bosdyn::api::graph_nav::Edge_Annotations_GroundClutterAvoidanceMode >(_impl_.ground_clutter_mode_);
}
inline ::bosdyn::api::graph_nav::Edge_Annotations_GroundClutterAvoidanceMode TravelParams::ground_clutter_mode() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.TravelParams.ground_clutter_mode)
  return _internal_ground_clutter_mode();
}
inline void TravelParams::_internal_set_ground_clutter_mode(::bosdyn::api::graph_nav::Edge_Annotations_GroundClutterAvoidanceMode value) {
  
  _impl_.ground_clutter_mode_ = value;
}
inline void TravelParams::set_ground_clutter_mode(::bosdyn::api::graph_nav::Edge_Annotations_GroundClutterAvoidanceMode value) {
  _internal_set_ground_clutter_mode(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.TravelParams.ground_clutter_mode)
}

// -------------------------------------------------------------------

// NavigateToRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool NavigateToRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool NavigateToRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& NavigateToRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& NavigateToRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToRequest.header)
  return _internal_header();
}
inline void NavigateToRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToRequest.header)
}
inline ::bosdyn::api::RequestHeader* NavigateToRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* NavigateToRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* NavigateToRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* NavigateToRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToRequest.header)
  return _msg;
}
inline void NavigateToRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToRequest.header)
}

// repeated .bosdyn.api.Lease leases = 2;
inline int NavigateToRequest::_internal_leases_size() const {
  return _impl_.leases_.size();
}
inline int NavigateToRequest::leases_size() const {
  return _internal_leases_size();
}
inline ::bosdyn::api::Lease* NavigateToRequest::mutable_leases(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToRequest.leases)
  return _impl_.leases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
NavigateToRequest::mutable_leases() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.NavigateToRequest.leases)
  return &_impl_.leases_;
}
inline const ::bosdyn::api::Lease& NavigateToRequest::_internal_leases(int index) const {
  return _impl_.leases_.Get(index);
}
inline const ::bosdyn::api::Lease& NavigateToRequest::leases(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToRequest.leases)
  return _internal_leases(index);
}
inline ::bosdyn::api::Lease* NavigateToRequest::_internal_add_leases() {
  return _impl_.leases_.Add();
}
inline ::bosdyn::api::Lease* NavigateToRequest::add_leases() {
  ::bosdyn::api::Lease* _add = _internal_add_leases();
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.NavigateToRequest.leases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
NavigateToRequest::leases() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.NavigateToRequest.leases)
  return _impl_.leases_;
}

// string destination_waypoint_id = 3;
inline void NavigateToRequest::clear_destination_waypoint_id() {
  _impl_.destination_waypoint_id_.ClearToEmpty();
}
inline const std::string& NavigateToRequest::destination_waypoint_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToRequest.destination_waypoint_id)
  return _internal_destination_waypoint_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NavigateToRequest::set_destination_waypoint_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.destination_waypoint_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateToRequest.destination_waypoint_id)
}
inline std::string* NavigateToRequest::mutable_destination_waypoint_id() {
  std::string* _s = _internal_mutable_destination_waypoint_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToRequest.destination_waypoint_id)
  return _s;
}
inline const std::string& NavigateToRequest::_internal_destination_waypoint_id() const {
  return _impl_.destination_waypoint_id_.Get();
}
inline void NavigateToRequest::_internal_set_destination_waypoint_id(const std::string& value) {
  
  _impl_.destination_waypoint_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NavigateToRequest::_internal_mutable_destination_waypoint_id() {
  
  return _impl_.destination_waypoint_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NavigateToRequest::release_destination_waypoint_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToRequest.destination_waypoint_id)
  return _impl_.destination_waypoint_id_.Release();
}
inline void NavigateToRequest::set_allocated_destination_waypoint_id(std::string* destination_waypoint_id) {
  if (destination_waypoint_id != nullptr) {
    
  } else {
    
  }
  _impl_.destination_waypoint_id_.SetAllocated(destination_waypoint_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destination_waypoint_id_.IsDefault()) {
    _impl_.destination_waypoint_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToRequest.destination_waypoint_id)
}

// .bosdyn.api.graph_nav.RouteGenParams route_params = 4;
inline bool NavigateToRequest::_internal_has_route_params() const {
  return this != internal_default_instance() && _impl_.route_params_ != nullptr;
}
inline bool NavigateToRequest::has_route_params() const {
  return _internal_has_route_params();
}
inline void NavigateToRequest::clear_route_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.route_params_ != nullptr) {
    delete _impl_.route_params_;
  }
  _impl_.route_params_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::RouteGenParams& NavigateToRequest::_internal_route_params() const {
  const ::bosdyn::api::graph_nav::RouteGenParams* p = _impl_.route_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::RouteGenParams&>(
      ::bosdyn::api::graph_nav::_RouteGenParams_default_instance_);
}
inline const ::bosdyn::api::graph_nav::RouteGenParams& NavigateToRequest::route_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToRequest.route_params)
  return _internal_route_params();
}
inline void NavigateToRequest::unsafe_arena_set_allocated_route_params(
    ::bosdyn::api::graph_nav::RouteGenParams* route_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_params_);
  }
  _impl_.route_params_ = route_params;
  if (route_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToRequest.route_params)
}
inline ::bosdyn::api::graph_nav::RouteGenParams* NavigateToRequest::release_route_params() {
  
  ::bosdyn::api::graph_nav::RouteGenParams* temp = _impl_.route_params_;
  _impl_.route_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::RouteGenParams* NavigateToRequest::unsafe_arena_release_route_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToRequest.route_params)
  
  ::bosdyn::api::graph_nav::RouteGenParams* temp = _impl_.route_params_;
  _impl_.route_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::RouteGenParams* NavigateToRequest::_internal_mutable_route_params() {
  
  if (_impl_.route_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::RouteGenParams>(GetArenaForAllocation());
    _impl_.route_params_ = p;
  }
  return _impl_.route_params_;
}
inline ::bosdyn::api::graph_nav::RouteGenParams* NavigateToRequest::mutable_route_params() {
  ::bosdyn::api::graph_nav::RouteGenParams* _msg = _internal_mutable_route_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToRequest.route_params)
  return _msg;
}
inline void NavigateToRequest::set_allocated_route_params(::bosdyn::api::graph_nav::RouteGenParams* route_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.route_params_;
  }
  if (route_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(route_params);
    if (message_arena != submessage_arena) {
      route_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.route_params_ = route_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToRequest.route_params)
}

// .bosdyn.api.graph_nav.TravelParams travel_params = 5;
inline bool NavigateToRequest::_internal_has_travel_params() const {
  return this != internal_default_instance() && _impl_.travel_params_ != nullptr;
}
inline bool NavigateToRequest::has_travel_params() const {
  return _internal_has_travel_params();
}
inline void NavigateToRequest::clear_travel_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.travel_params_ != nullptr) {
    delete _impl_.travel_params_;
  }
  _impl_.travel_params_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::TravelParams& NavigateToRequest::_internal_travel_params() const {
  const ::bosdyn::api::graph_nav::TravelParams* p = _impl_.travel_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::TravelParams&>(
      ::bosdyn::api::graph_nav::_TravelParams_default_instance_);
}
inline const ::bosdyn::api::graph_nav::TravelParams& NavigateToRequest::travel_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToRequest.travel_params)
  return _internal_travel_params();
}
inline void NavigateToRequest::unsafe_arena_set_allocated_travel_params(
    ::bosdyn::api::graph_nav::TravelParams* travel_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.travel_params_);
  }
  _impl_.travel_params_ = travel_params;
  if (travel_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToRequest.travel_params)
}
inline ::bosdyn::api::graph_nav::TravelParams* NavigateToRequest::release_travel_params() {
  
  ::bosdyn::api::graph_nav::TravelParams* temp = _impl_.travel_params_;
  _impl_.travel_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::TravelParams* NavigateToRequest::unsafe_arena_release_travel_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToRequest.travel_params)
  
  ::bosdyn::api::graph_nav::TravelParams* temp = _impl_.travel_params_;
  _impl_.travel_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::TravelParams* NavigateToRequest::_internal_mutable_travel_params() {
  
  if (_impl_.travel_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::TravelParams>(GetArenaForAllocation());
    _impl_.travel_params_ = p;
  }
  return _impl_.travel_params_;
}
inline ::bosdyn::api::graph_nav::TravelParams* NavigateToRequest::mutable_travel_params() {
  ::bosdyn::api::graph_nav::TravelParams* _msg = _internal_mutable_travel_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToRequest.travel_params)
  return _msg;
}
inline void NavigateToRequest::set_allocated_travel_params(::bosdyn::api::graph_nav::TravelParams* travel_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.travel_params_;
  }
  if (travel_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(travel_params);
    if (message_arena != submessage_arena) {
      travel_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, travel_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.travel_params_ = travel_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToRequest.travel_params)
}

// .google.protobuf.Timestamp end_time = 6;
inline bool NavigateToRequest::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool NavigateToRequest::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& NavigateToRequest::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& NavigateToRequest::end_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToRequest.end_time)
  return _internal_end_time();
}
inline void NavigateToRequest::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToRequest.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NavigateToRequest::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NavigateToRequest::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToRequest.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NavigateToRequest::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NavigateToRequest::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToRequest.end_time)
  return _msg;
}
inline void NavigateToRequest::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToRequest.end_time)
}

// string clock_identifier = 7;
inline void NavigateToRequest::clear_clock_identifier() {
  _impl_.clock_identifier_.ClearToEmpty();
}
inline const std::string& NavigateToRequest::clock_identifier() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToRequest.clock_identifier)
  return _internal_clock_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NavigateToRequest::set_clock_identifier(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clock_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateToRequest.clock_identifier)
}
inline std::string* NavigateToRequest::mutable_clock_identifier() {
  std::string* _s = _internal_mutable_clock_identifier();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToRequest.clock_identifier)
  return _s;
}
inline const std::string& NavigateToRequest::_internal_clock_identifier() const {
  return _impl_.clock_identifier_.Get();
}
inline void NavigateToRequest::_internal_set_clock_identifier(const std::string& value) {
  
  _impl_.clock_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* NavigateToRequest::_internal_mutable_clock_identifier() {
  
  return _impl_.clock_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* NavigateToRequest::release_clock_identifier() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToRequest.clock_identifier)
  return _impl_.clock_identifier_.Release();
}
inline void NavigateToRequest::set_allocated_clock_identifier(std::string* clock_identifier) {
  if (clock_identifier != nullptr) {
    
  } else {
    
  }
  _impl_.clock_identifier_.SetAllocated(clock_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clock_identifier_.IsDefault()) {
    _impl_.clock_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToRequest.clock_identifier)
}

// .bosdyn.api.SE2Pose destination_waypoint_tform_body_goal = 8;
inline bool NavigateToRequest::_internal_has_destination_waypoint_tform_body_goal() const {
  return this != internal_default_instance() && _impl_.destination_waypoint_tform_body_goal_ != nullptr;
}
inline bool NavigateToRequest::has_destination_waypoint_tform_body_goal() const {
  return _internal_has_destination_waypoint_tform_body_goal();
}
inline const ::bosdyn::api::SE2Pose& NavigateToRequest::_internal_destination_waypoint_tform_body_goal() const {
  const ::bosdyn::api::SE2Pose* p = _impl_.destination_waypoint_tform_body_goal_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE2Pose&>(
      ::bosdyn::api::_SE2Pose_default_instance_);
}
inline const ::bosdyn::api::SE2Pose& NavigateToRequest::destination_waypoint_tform_body_goal() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToRequest.destination_waypoint_tform_body_goal)
  return _internal_destination_waypoint_tform_body_goal();
}
inline void NavigateToRequest::unsafe_arena_set_allocated_destination_waypoint_tform_body_goal(
    ::bosdyn::api::SE2Pose* destination_waypoint_tform_body_goal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.destination_waypoint_tform_body_goal_);
  }
  _impl_.destination_waypoint_tform_body_goal_ = destination_waypoint_tform_body_goal;
  if (destination_waypoint_tform_body_goal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToRequest.destination_waypoint_tform_body_goal)
}
inline ::bosdyn::api::SE2Pose* NavigateToRequest::release_destination_waypoint_tform_body_goal() {
  
  ::bosdyn::api::SE2Pose* temp = _impl_.destination_waypoint_tform_body_goal_;
  _impl_.destination_waypoint_tform_body_goal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE2Pose* NavigateToRequest::unsafe_arena_release_destination_waypoint_tform_body_goal() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToRequest.destination_waypoint_tform_body_goal)
  
  ::bosdyn::api::SE2Pose* temp = _impl_.destination_waypoint_tform_body_goal_;
  _impl_.destination_waypoint_tform_body_goal_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE2Pose* NavigateToRequest::_internal_mutable_destination_waypoint_tform_body_goal() {
  
  if (_impl_.destination_waypoint_tform_body_goal_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE2Pose>(GetArenaForAllocation());
    _impl_.destination_waypoint_tform_body_goal_ = p;
  }
  return _impl_.destination_waypoint_tform_body_goal_;
}
inline ::bosdyn::api::SE2Pose* NavigateToRequest::mutable_destination_waypoint_tform_body_goal() {
  ::bosdyn::api::SE2Pose* _msg = _internal_mutable_destination_waypoint_tform_body_goal();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToRequest.destination_waypoint_tform_body_goal)
  return _msg;
}
inline void NavigateToRequest::set_allocated_destination_waypoint_tform_body_goal(::bosdyn::api::SE2Pose* destination_waypoint_tform_body_goal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.destination_waypoint_tform_body_goal_);
  }
  if (destination_waypoint_tform_body_goal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_waypoint_tform_body_goal));
    if (message_arena != submessage_arena) {
      destination_waypoint_tform_body_goal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination_waypoint_tform_body_goal, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.destination_waypoint_tform_body_goal_ = destination_waypoint_tform_body_goal;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToRequest.destination_waypoint_tform_body_goal)
}

// uint32 command_id = 9;
inline void NavigateToRequest::clear_command_id() {
  _impl_.command_id_ = 0u;
}
inline uint32_t NavigateToRequest::_internal_command_id() const {
  return _impl_.command_id_;
}
inline uint32_t NavigateToRequest::command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToRequest.command_id)
  return _internal_command_id();
}
inline void NavigateToRequest::_internal_set_command_id(uint32_t value) {
  
  _impl_.command_id_ = value;
}
inline void NavigateToRequest::set_command_id(uint32_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateToRequest.command_id)
}

// -------------------------------------------------------------------

// NavigateToResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool NavigateToResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool NavigateToResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& NavigateToResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& NavigateToResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToResponse.header)
  return _internal_header();
}
inline void NavigateToResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToResponse.header)
}
inline ::bosdyn::api::ResponseHeader* NavigateToResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* NavigateToResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* NavigateToResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* NavigateToResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToResponse.header)
  return _msg;
}
inline void NavigateToResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToResponse.header)
}

// repeated .bosdyn.api.LeaseUseResult lease_use_results = 2;
inline int NavigateToResponse::_internal_lease_use_results_size() const {
  return _impl_.lease_use_results_.size();
}
inline int NavigateToResponse::lease_use_results_size() const {
  return _internal_lease_use_results_size();
}
inline ::bosdyn::api::LeaseUseResult* NavigateToResponse::mutable_lease_use_results(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToResponse.lease_use_results)
  return _impl_.lease_use_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
NavigateToResponse::mutable_lease_use_results() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.NavigateToResponse.lease_use_results)
  return &_impl_.lease_use_results_;
}
inline const ::bosdyn::api::LeaseUseResult& NavigateToResponse::_internal_lease_use_results(int index) const {
  return _impl_.lease_use_results_.Get(index);
}
inline const ::bosdyn::api::LeaseUseResult& NavigateToResponse::lease_use_results(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToResponse.lease_use_results)
  return _internal_lease_use_results(index);
}
inline ::bosdyn::api::LeaseUseResult* NavigateToResponse::_internal_add_lease_use_results() {
  return _impl_.lease_use_results_.Add();
}
inline ::bosdyn::api::LeaseUseResult* NavigateToResponse::add_lease_use_results() {
  ::bosdyn::api::LeaseUseResult* _add = _internal_add_lease_use_results();
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.NavigateToResponse.lease_use_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
NavigateToResponse::lease_use_results() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.NavigateToResponse.lease_use_results)
  return _impl_.lease_use_results_;
}

// .bosdyn.api.graph_nav.NavigateToResponse.Status status = 3;
inline void NavigateToResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::graph_nav::NavigateToResponse_Status NavigateToResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::NavigateToResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::graph_nav::NavigateToResponse_Status NavigateToResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToResponse.status)
  return _internal_status();
}
inline void NavigateToResponse::_internal_set_status(::bosdyn::api::graph_nav::NavigateToResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void NavigateToResponse::set_status(::bosdyn::api::graph_nav::NavigateToResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateToResponse.status)
}

// .bosdyn.api.RobotImpairedState impaired_state = 6;
inline bool NavigateToResponse::_internal_has_impaired_state() const {
  return this != internal_default_instance() && _impl_.impaired_state_ != nullptr;
}
inline bool NavigateToResponse::has_impaired_state() const {
  return _internal_has_impaired_state();
}
inline const ::bosdyn::api::RobotImpairedState& NavigateToResponse::_internal_impaired_state() const {
  const ::bosdyn::api::RobotImpairedState* p = _impl_.impaired_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RobotImpairedState&>(
      ::bosdyn::api::_RobotImpairedState_default_instance_);
}
inline const ::bosdyn::api::RobotImpairedState& NavigateToResponse::impaired_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToResponse.impaired_state)
  return _internal_impaired_state();
}
inline void NavigateToResponse::unsafe_arena_set_allocated_impaired_state(
    ::bosdyn::api::RobotImpairedState* impaired_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.impaired_state_);
  }
  _impl_.impaired_state_ = impaired_state;
  if (impaired_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToResponse.impaired_state)
}
inline ::bosdyn::api::RobotImpairedState* NavigateToResponse::release_impaired_state() {
  
  ::bosdyn::api::RobotImpairedState* temp = _impl_.impaired_state_;
  _impl_.impaired_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RobotImpairedState* NavigateToResponse::unsafe_arena_release_impaired_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToResponse.impaired_state)
  
  ::bosdyn::api::RobotImpairedState* temp = _impl_.impaired_state_;
  _impl_.impaired_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RobotImpairedState* NavigateToResponse::_internal_mutable_impaired_state() {
  
  if (_impl_.impaired_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RobotImpairedState>(GetArenaForAllocation());
    _impl_.impaired_state_ = p;
  }
  return _impl_.impaired_state_;
}
inline ::bosdyn::api::RobotImpairedState* NavigateToResponse::mutable_impaired_state() {
  ::bosdyn::api::RobotImpairedState* _msg = _internal_mutable_impaired_state();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToResponse.impaired_state)
  return _msg;
}
inline void NavigateToResponse::set_allocated_impaired_state(::bosdyn::api::RobotImpairedState* impaired_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.impaired_state_);
  }
  if (impaired_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(impaired_state));
    if (message_arena != submessage_arena) {
      impaired_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, impaired_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.impaired_state_ = impaired_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToResponse.impaired_state)
}

// uint32 command_id = 4;
inline void NavigateToResponse::clear_command_id() {
  _impl_.command_id_ = 0u;
}
inline uint32_t NavigateToResponse::_internal_command_id() const {
  return _impl_.command_id_;
}
inline uint32_t NavigateToResponse::command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToResponse.command_id)
  return _internal_command_id();
}
inline void NavigateToResponse::_internal_set_command_id(uint32_t value) {
  
  _impl_.command_id_ = value;
}
inline void NavigateToResponse::set_command_id(uint32_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateToResponse.command_id)
}

// repeated string error_waypoint_ids = 5;
inline int NavigateToResponse::_internal_error_waypoint_ids_size() const {
  return _impl_.error_waypoint_ids_.size();
}
inline int NavigateToResponse::error_waypoint_ids_size() const {
  return _internal_error_waypoint_ids_size();
}
inline void NavigateToResponse::clear_error_waypoint_ids() {
  _impl_.error_waypoint_ids_.Clear();
}
inline std::string* NavigateToResponse::add_error_waypoint_ids() {
  std::string* _s = _internal_add_error_waypoint_ids();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.graph_nav.NavigateToResponse.error_waypoint_ids)
  return _s;
}
inline const std::string& NavigateToResponse::_internal_error_waypoint_ids(int index) const {
  return _impl_.error_waypoint_ids_.Get(index);
}
inline const std::string& NavigateToResponse::error_waypoint_ids(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToResponse.error_waypoint_ids)
  return _internal_error_waypoint_ids(index);
}
inline std::string* NavigateToResponse::mutable_error_waypoint_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToResponse.error_waypoint_ids)
  return _impl_.error_waypoint_ids_.Mutable(index);
}
inline void NavigateToResponse::set_error_waypoint_ids(int index, const std::string& value) {
  _impl_.error_waypoint_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateToResponse.error_waypoint_ids)
}
inline void NavigateToResponse::set_error_waypoint_ids(int index, std::string&& value) {
  _impl_.error_waypoint_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateToResponse.error_waypoint_ids)
}
inline void NavigateToResponse::set_error_waypoint_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.error_waypoint_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.graph_nav.NavigateToResponse.error_waypoint_ids)
}
inline void NavigateToResponse::set_error_waypoint_ids(int index, const char* value, size_t size) {
  _impl_.error_waypoint_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.graph_nav.NavigateToResponse.error_waypoint_ids)
}
inline std::string* NavigateToResponse::_internal_add_error_waypoint_ids() {
  return _impl_.error_waypoint_ids_.Add();
}
inline void NavigateToResponse::add_error_waypoint_ids(const std::string& value) {
  _impl_.error_waypoint_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.NavigateToResponse.error_waypoint_ids)
}
inline void NavigateToResponse::add_error_waypoint_ids(std::string&& value) {
  _impl_.error_waypoint_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.NavigateToResponse.error_waypoint_ids)
}
inline void NavigateToResponse::add_error_waypoint_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.error_waypoint_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.graph_nav.NavigateToResponse.error_waypoint_ids)
}
inline void NavigateToResponse::add_error_waypoint_ids(const char* value, size_t size) {
  _impl_.error_waypoint_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.graph_nav.NavigateToResponse.error_waypoint_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NavigateToResponse::error_waypoint_ids() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.NavigateToResponse.error_waypoint_ids)
  return _impl_.error_waypoint_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NavigateToResponse::mutable_error_waypoint_ids() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.NavigateToResponse.error_waypoint_ids)
  return &_impl_.error_waypoint_ids_;
}

// .bosdyn.api.graph_nav.AreaCallbackServiceError area_callback_error = 10;
inline bool NavigateToResponse::_internal_has_area_callback_error() const {
  return this != internal_default_instance() && _impl_.area_callback_error_ != nullptr;
}
inline bool NavigateToResponse::has_area_callback_error() const {
  return _internal_has_area_callback_error();
}
inline void NavigateToResponse::clear_area_callback_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.area_callback_error_ != nullptr) {
    delete _impl_.area_callback_error_;
  }
  _impl_.area_callback_error_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::AreaCallbackServiceError& NavigateToResponse::_internal_area_callback_error() const {
  const ::bosdyn::api::graph_nav::AreaCallbackServiceError* p = _impl_.area_callback_error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::AreaCallbackServiceError&>(
      ::bosdyn::api::graph_nav::_AreaCallbackServiceError_default_instance_);
}
inline const ::bosdyn::api::graph_nav::AreaCallbackServiceError& NavigateToResponse::area_callback_error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToResponse.area_callback_error)
  return _internal_area_callback_error();
}
inline void NavigateToResponse::unsafe_arena_set_allocated_area_callback_error(
    ::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.area_callback_error_);
  }
  _impl_.area_callback_error_ = area_callback_error;
  if (area_callback_error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToResponse.area_callback_error)
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* NavigateToResponse::release_area_callback_error() {
  
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* temp = _impl_.area_callback_error_;
  _impl_.area_callback_error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* NavigateToResponse::unsafe_arena_release_area_callback_error() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToResponse.area_callback_error)
  
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* temp = _impl_.area_callback_error_;
  _impl_.area_callback_error_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* NavigateToResponse::_internal_mutable_area_callback_error() {
  
  if (_impl_.area_callback_error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::AreaCallbackServiceError>(GetArenaForAllocation());
    _impl_.area_callback_error_ = p;
  }
  return _impl_.area_callback_error_;
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* NavigateToResponse::mutable_area_callback_error() {
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* _msg = _internal_mutable_area_callback_error();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToResponse.area_callback_error)
  return _msg;
}
inline void NavigateToResponse::set_allocated_area_callback_error(::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.area_callback_error_;
  }
  if (area_callback_error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(area_callback_error);
    if (message_arena != submessage_arena) {
      area_callback_error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, area_callback_error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.area_callback_error_ = area_callback_error;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToResponse.area_callback_error)
}

// -------------------------------------------------------------------

// RouteFollowingParams

// .bosdyn.api.graph_nav.RouteFollowingParams.StartRouteBehavior new_cmd_behavior = 1;
inline void RouteFollowingParams::clear_new_cmd_behavior() {
  _impl_.new_cmd_behavior_ = 0;
}
inline ::bosdyn::api::graph_nav::RouteFollowingParams_StartRouteBehavior RouteFollowingParams::_internal_new_cmd_behavior() const {
  return static_cast< ::bosdyn::api::graph_nav::RouteFollowingParams_StartRouteBehavior >(_impl_.new_cmd_behavior_);
}
inline ::bosdyn::api::graph_nav::RouteFollowingParams_StartRouteBehavior RouteFollowingParams::new_cmd_behavior() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.RouteFollowingParams.new_cmd_behavior)
  return _internal_new_cmd_behavior();
}
inline void RouteFollowingParams::_internal_set_new_cmd_behavior(::bosdyn::api::graph_nav::RouteFollowingParams_StartRouteBehavior value) {
  
  _impl_.new_cmd_behavior_ = value;
}
inline void RouteFollowingParams::set_new_cmd_behavior(::bosdyn::api::graph_nav::RouteFollowingParams_StartRouteBehavior value) {
  _internal_set_new_cmd_behavior(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.RouteFollowingParams.new_cmd_behavior)
}

// .bosdyn.api.graph_nav.RouteFollowingParams.ResumeBehavior existing_cmd_behavior = 2;
inline void RouteFollowingParams::clear_existing_cmd_behavior() {
  _impl_.existing_cmd_behavior_ = 0;
}
inline ::bosdyn::api::graph_nav::RouteFollowingParams_ResumeBehavior RouteFollowingParams::_internal_existing_cmd_behavior() const {
  return static_cast< ::bosdyn::api::graph_nav::RouteFollowingParams_ResumeBehavior >(_impl_.existing_cmd_behavior_);
}
inline ::bosdyn::api::graph_nav::RouteFollowingParams_ResumeBehavior RouteFollowingParams::existing_cmd_behavior() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.RouteFollowingParams.existing_cmd_behavior)
  return _internal_existing_cmd_behavior();
}
inline void RouteFollowingParams::_internal_set_existing_cmd_behavior(::bosdyn::api::graph_nav::RouteFollowingParams_ResumeBehavior value) {
  
  _impl_.existing_cmd_behavior_ = value;
}
inline void RouteFollowingParams::set_existing_cmd_behavior(::bosdyn::api::graph_nav::RouteFollowingParams_ResumeBehavior value) {
  _internal_set_existing_cmd_behavior(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.RouteFollowingParams.existing_cmd_behavior)
}

// .bosdyn.api.graph_nav.RouteFollowingParams.RouteBlockedBehavior route_blocked_behavior = 3;
inline void RouteFollowingParams::clear_route_blocked_behavior() {
  _impl_.route_blocked_behavior_ = 0;
}
inline ::bosdyn::api::graph_nav::RouteFollowingParams_RouteBlockedBehavior RouteFollowingParams::_internal_route_blocked_behavior() const {
  return static_cast< ::bosdyn::api::graph_nav::RouteFollowingParams_RouteBlockedBehavior >(_impl_.route_blocked_behavior_);
}
inline ::bosdyn::api::graph_nav::RouteFollowingParams_RouteBlockedBehavior RouteFollowingParams::route_blocked_behavior() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.RouteFollowingParams.route_blocked_behavior)
  return _internal_route_blocked_behavior();
}
inline void RouteFollowingParams::_internal_set_route_blocked_behavior(::bosdyn::api::graph_nav::RouteFollowingParams_RouteBlockedBehavior value) {
  
  _impl_.route_blocked_behavior_ = value;
}
inline void RouteFollowingParams::set_route_blocked_behavior(::bosdyn::api::graph_nav::RouteFollowingParams_RouteBlockedBehavior value) {
  _internal_set_route_blocked_behavior(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.RouteFollowingParams.route_blocked_behavior)
}

// -------------------------------------------------------------------

// NavigateRouteRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool NavigateRouteRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool NavigateRouteRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& NavigateRouteRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& NavigateRouteRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteRequest.header)
  return _internal_header();
}
inline void NavigateRouteRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateRouteRequest.header)
}
inline ::bosdyn::api::RequestHeader* NavigateRouteRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* NavigateRouteRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateRouteRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* NavigateRouteRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* NavigateRouteRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateRouteRequest.header)
  return _msg;
}
inline void NavigateRouteRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateRouteRequest.header)
}

// repeated .bosdyn.api.Lease leases = 2;
inline int NavigateRouteRequest::_internal_leases_size() const {
  return _impl_.leases_.size();
}
inline int NavigateRouteRequest::leases_size() const {
  return _internal_leases_size();
}
inline ::bosdyn::api::Lease* NavigateRouteRequest::mutable_leases(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateRouteRequest.leases)
  return _impl_.leases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
NavigateRouteRequest::mutable_leases() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.NavigateRouteRequest.leases)
  return &_impl_.leases_;
}
inline const ::bosdyn::api::Lease& NavigateRouteRequest::_internal_leases(int index) const {
  return _impl_.leases_.Get(index);
}
inline const ::bosdyn::api::Lease& NavigateRouteRequest::leases(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteRequest.leases)
  return _internal_leases(index);
}
inline ::bosdyn::api::Lease* NavigateRouteRequest::_internal_add_leases() {
  return _impl_.leases_.Add();
}
inline ::bosdyn::api::Lease* NavigateRouteRequest::add_leases() {
  ::bosdyn::api::Lease* _add = _internal_add_leases();
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.NavigateRouteRequest.leases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
NavigateRouteRequest::leases() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.NavigateRouteRequest.leases)
  return _impl_.leases_;
}

// .bosdyn.api.graph_nav.Route route = 3;
inline bool NavigateRouteRequest::_internal_has_route() const {
  return this != internal_default_instance() && _impl_.route_ != nullptr;
}
inline bool NavigateRouteRequest::has_route() const {
  return _internal_has_route();
}
inline const ::bosdyn::api::graph_nav::Route& NavigateRouteRequest::_internal_route() const {
  const ::bosdyn::api::graph_nav::Route* p = _impl_.route_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::Route&>(
      ::bosdyn::api::graph_nav::_Route_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Route& NavigateRouteRequest::route() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteRequest.route)
  return _internal_route();
}
inline void NavigateRouteRequest::unsafe_arena_set_allocated_route(
    ::bosdyn::api::graph_nav::Route* route) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_);
  }
  _impl_.route_ = route;
  if (route) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateRouteRequest.route)
}
inline ::bosdyn::api::graph_nav::Route* NavigateRouteRequest::release_route() {
  
  ::bosdyn::api::graph_nav::Route* temp = _impl_.route_;
  _impl_.route_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::Route* NavigateRouteRequest::unsafe_arena_release_route() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateRouteRequest.route)
  
  ::bosdyn::api::graph_nav::Route* temp = _impl_.route_;
  _impl_.route_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Route* NavigateRouteRequest::_internal_mutable_route() {
  
  if (_impl_.route_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Route>(GetArenaForAllocation());
    _impl_.route_ = p;
  }
  return _impl_.route_;
}
inline ::bosdyn::api::graph_nav::Route* NavigateRouteRequest::mutable_route() {
  ::bosdyn::api::graph_nav::Route* _msg = _internal_mutable_route();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateRouteRequest.route)
  return _msg;
}
inline void NavigateRouteRequest::set_allocated_route(::bosdyn::api::graph_nav::Route* route) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_);
  }
  if (route) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(route));
    if (message_arena != submessage_arena) {
      route = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.route_ = route;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateRouteRequest.route)
}

// .bosdyn.api.graph_nav.RouteFollowingParams route_follow_params = 9;
inline bool NavigateRouteRequest::_internal_has_route_follow_params() const {
  return this != internal_default_instance() && _impl_.route_follow_params_ != nullptr;
}
inline bool NavigateRouteRequest::has_route_follow_params() const {
  return _internal_has_route_follow_params();
}
inline void NavigateRouteRequest::clear_route_follow_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.route_follow_params_ != nullptr) {
    delete _impl_.route_follow_params_;
  }
  _impl_.route_follow_params_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::RouteFollowingParams& NavigateRouteRequest::_internal_route_follow_params() const {
  const ::bosdyn::api::graph_nav::RouteFollowingParams* p = _impl_.route_follow_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::RouteFollowingParams&>(
      ::bosdyn::api::graph_nav::_RouteFollowingParams_default_instance_);
}
inline const ::bosdyn::api::graph_nav::RouteFollowingParams& NavigateRouteRequest::route_follow_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteRequest.route_follow_params)
  return _internal_route_follow_params();
}
inline void NavigateRouteRequest::unsafe_arena_set_allocated_route_follow_params(
    ::bosdyn::api::graph_nav::RouteFollowingParams* route_follow_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_follow_params_);
  }
  _impl_.route_follow_params_ = route_follow_params;
  if (route_follow_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateRouteRequest.route_follow_params)
}
inline ::bosdyn::api::graph_nav::RouteFollowingParams* NavigateRouteRequest::release_route_follow_params() {
  
  ::bosdyn::api::graph_nav::RouteFollowingParams* temp = _impl_.route_follow_params_;
  _impl_.route_follow_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::RouteFollowingParams* NavigateRouteRequest::unsafe_arena_release_route_follow_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateRouteRequest.route_follow_params)
  
  ::bosdyn::api::graph_nav::RouteFollowingParams* temp = _impl_.route_follow_params_;
  _impl_.route_follow_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::RouteFollowingParams* NavigateRouteRequest::_internal_mutable_route_follow_params() {
  
  if (_impl_.route_follow_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::RouteFollowingParams>(GetArenaForAllocation());
    _impl_.route_follow_params_ = p;
  }
  return _impl_.route_follow_params_;
}
inline ::bosdyn::api::graph_nav::RouteFollowingParams* NavigateRouteRequest::mutable_route_follow_params() {
  ::bosdyn::api::graph_nav::RouteFollowingParams* _msg = _internal_mutable_route_follow_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateRouteRequest.route_follow_params)
  return _msg;
}
inline void NavigateRouteRequest::set_allocated_route_follow_params(::bosdyn::api::graph_nav::RouteFollowingParams* route_follow_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.route_follow_params_;
  }
  if (route_follow_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(route_follow_params);
    if (message_arena != submessage_arena) {
      route_follow_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route_follow_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.route_follow_params_ = route_follow_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateRouteRequest.route_follow_params)
}

// .bosdyn.api.graph_nav.TravelParams travel_params = 4;
inline bool NavigateRouteRequest::_internal_has_travel_params() const {
  return this != internal_default_instance() && _impl_.travel_params_ != nullptr;
}
inline bool NavigateRouteRequest::has_travel_params() const {
  return _internal_has_travel_params();
}
inline void NavigateRouteRequest::clear_travel_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.travel_params_ != nullptr) {
    delete _impl_.travel_params_;
  }
  _impl_.travel_params_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::TravelParams& NavigateRouteRequest::_internal_travel_params() const {
  const ::bosdyn::api::graph_nav::TravelParams* p = _impl_.travel_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::TravelParams&>(
      ::bosdyn::api::graph_nav::_TravelParams_default_instance_);
}
inline const ::bosdyn::api::graph_nav::TravelParams& NavigateRouteRequest::travel_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteRequest.travel_params)
  return _internal_travel_params();
}
inline void NavigateRouteRequest::unsafe_arena_set_allocated_travel_params(
    ::bosdyn::api::graph_nav::TravelParams* travel_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.travel_params_);
  }
  _impl_.travel_params_ = travel_params;
  if (travel_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateRouteRequest.travel_params)
}
inline ::bosdyn::api::graph_nav::TravelParams* NavigateRouteRequest::release_travel_params() {
  
  ::bosdyn::api::graph_nav::TravelParams* temp = _impl_.travel_params_;
  _impl_.travel_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::TravelParams* NavigateRouteRequest::unsafe_arena_release_travel_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateRouteRequest.travel_params)
  
  ::bosdyn::api::graph_nav::TravelParams* temp = _impl_.travel_params_;
  _impl_.travel_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::TravelParams* NavigateRouteRequest::_internal_mutable_travel_params() {
  
  if (_impl_.travel_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::TravelParams>(GetArenaForAllocation());
    _impl_.travel_params_ = p;
  }
  return _impl_.travel_params_;
}
inline ::bosdyn::api::graph_nav::TravelParams* NavigateRouteRequest::mutable_travel_params() {
  ::bosdyn::api::graph_nav::TravelParams* _msg = _internal_mutable_travel_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateRouteRequest.travel_params)
  return _msg;
}
inline void NavigateRouteRequest::set_allocated_travel_params(::bosdyn::api::graph_nav::TravelParams* travel_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.travel_params_;
  }
  if (travel_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(travel_params);
    if (message_arena != submessage_arena) {
      travel_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, travel_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.travel_params_ = travel_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateRouteRequest.travel_params)
}

// .google.protobuf.Timestamp end_time = 5;
inline bool NavigateRouteRequest::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool NavigateRouteRequest::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& NavigateRouteRequest::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& NavigateRouteRequest::end_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteRequest.end_time)
  return _internal_end_time();
}
inline void NavigateRouteRequest::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateRouteRequest.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NavigateRouteRequest::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NavigateRouteRequest::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateRouteRequest.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NavigateRouteRequest::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NavigateRouteRequest::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateRouteRequest.end_time)
  return _msg;
}
inline void NavigateRouteRequest::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateRouteRequest.end_time)
}

// string clock_identifier = 6;
inline void NavigateRouteRequest::clear_clock_identifier() {
  _impl_.clock_identifier_.ClearToEmpty();
}
inline const std::string& NavigateRouteRequest::clock_identifier() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteRequest.clock_identifier)
  return _internal_clock_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NavigateRouteRequest::set_clock_identifier(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clock_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateRouteRequest.clock_identifier)
}
inline std::string* NavigateRouteRequest::mutable_clock_identifier() {
  std::string* _s = _internal_mutable_clock_identifier();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateRouteRequest.clock_identifier)
  return _s;
}
inline const std::string& NavigateRouteRequest::_internal_clock_identifier() const {
  return _impl_.clock_identifier_.Get();
}
inline void NavigateRouteRequest::_internal_set_clock_identifier(const std::string& value) {
  
  _impl_.clock_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* NavigateRouteRequest::_internal_mutable_clock_identifier() {
  
  return _impl_.clock_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* NavigateRouteRequest::release_clock_identifier() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateRouteRequest.clock_identifier)
  return _impl_.clock_identifier_.Release();
}
inline void NavigateRouteRequest::set_allocated_clock_identifier(std::string* clock_identifier) {
  if (clock_identifier != nullptr) {
    
  } else {
    
  }
  _impl_.clock_identifier_.SetAllocated(clock_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clock_identifier_.IsDefault()) {
    _impl_.clock_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateRouteRequest.clock_identifier)
}

// .bosdyn.api.SE2Pose destination_waypoint_tform_body_goal = 7;
inline bool NavigateRouteRequest::_internal_has_destination_waypoint_tform_body_goal() const {
  return this != internal_default_instance() && _impl_.destination_waypoint_tform_body_goal_ != nullptr;
}
inline bool NavigateRouteRequest::has_destination_waypoint_tform_body_goal() const {
  return _internal_has_destination_waypoint_tform_body_goal();
}
inline const ::bosdyn::api::SE2Pose& NavigateRouteRequest::_internal_destination_waypoint_tform_body_goal() const {
  const ::bosdyn::api::SE2Pose* p = _impl_.destination_waypoint_tform_body_goal_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE2Pose&>(
      ::bosdyn::api::_SE2Pose_default_instance_);
}
inline const ::bosdyn::api::SE2Pose& NavigateRouteRequest::destination_waypoint_tform_body_goal() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteRequest.destination_waypoint_tform_body_goal)
  return _internal_destination_waypoint_tform_body_goal();
}
inline void NavigateRouteRequest::unsafe_arena_set_allocated_destination_waypoint_tform_body_goal(
    ::bosdyn::api::SE2Pose* destination_waypoint_tform_body_goal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.destination_waypoint_tform_body_goal_);
  }
  _impl_.destination_waypoint_tform_body_goal_ = destination_waypoint_tform_body_goal;
  if (destination_waypoint_tform_body_goal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateRouteRequest.destination_waypoint_tform_body_goal)
}
inline ::bosdyn::api::SE2Pose* NavigateRouteRequest::release_destination_waypoint_tform_body_goal() {
  
  ::bosdyn::api::SE2Pose* temp = _impl_.destination_waypoint_tform_body_goal_;
  _impl_.destination_waypoint_tform_body_goal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE2Pose* NavigateRouteRequest::unsafe_arena_release_destination_waypoint_tform_body_goal() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateRouteRequest.destination_waypoint_tform_body_goal)
  
  ::bosdyn::api::SE2Pose* temp = _impl_.destination_waypoint_tform_body_goal_;
  _impl_.destination_waypoint_tform_body_goal_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE2Pose* NavigateRouteRequest::_internal_mutable_destination_waypoint_tform_body_goal() {
  
  if (_impl_.destination_waypoint_tform_body_goal_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE2Pose>(GetArenaForAllocation());
    _impl_.destination_waypoint_tform_body_goal_ = p;
  }
  return _impl_.destination_waypoint_tform_body_goal_;
}
inline ::bosdyn::api::SE2Pose* NavigateRouteRequest::mutable_destination_waypoint_tform_body_goal() {
  ::bosdyn::api::SE2Pose* _msg = _internal_mutable_destination_waypoint_tform_body_goal();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateRouteRequest.destination_waypoint_tform_body_goal)
  return _msg;
}
inline void NavigateRouteRequest::set_allocated_destination_waypoint_tform_body_goal(::bosdyn::api::SE2Pose* destination_waypoint_tform_body_goal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.destination_waypoint_tform_body_goal_);
  }
  if (destination_waypoint_tform_body_goal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_waypoint_tform_body_goal));
    if (message_arena != submessage_arena) {
      destination_waypoint_tform_body_goal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination_waypoint_tform_body_goal, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.destination_waypoint_tform_body_goal_ = destination_waypoint_tform_body_goal;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateRouteRequest.destination_waypoint_tform_body_goal)
}

// uint32 command_id = 8;
inline void NavigateRouteRequest::clear_command_id() {
  _impl_.command_id_ = 0u;
}
inline uint32_t NavigateRouteRequest::_internal_command_id() const {
  return _impl_.command_id_;
}
inline uint32_t NavigateRouteRequest::command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteRequest.command_id)
  return _internal_command_id();
}
inline void NavigateRouteRequest::_internal_set_command_id(uint32_t value) {
  
  _impl_.command_id_ = value;
}
inline void NavigateRouteRequest::set_command_id(uint32_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateRouteRequest.command_id)
}

// -------------------------------------------------------------------

// NavigateRouteResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool NavigateRouteResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool NavigateRouteResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& NavigateRouteResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& NavigateRouteResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteResponse.header)
  return _internal_header();
}
inline void NavigateRouteResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateRouteResponse.header)
}
inline ::bosdyn::api::ResponseHeader* NavigateRouteResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* NavigateRouteResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateRouteResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* NavigateRouteResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* NavigateRouteResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateRouteResponse.header)
  return _msg;
}
inline void NavigateRouteResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateRouteResponse.header)
}

// repeated .bosdyn.api.LeaseUseResult lease_use_results = 2;
inline int NavigateRouteResponse::_internal_lease_use_results_size() const {
  return _impl_.lease_use_results_.size();
}
inline int NavigateRouteResponse::lease_use_results_size() const {
  return _internal_lease_use_results_size();
}
inline ::bosdyn::api::LeaseUseResult* NavigateRouteResponse::mutable_lease_use_results(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateRouteResponse.lease_use_results)
  return _impl_.lease_use_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
NavigateRouteResponse::mutable_lease_use_results() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.NavigateRouteResponse.lease_use_results)
  return &_impl_.lease_use_results_;
}
inline const ::bosdyn::api::LeaseUseResult& NavigateRouteResponse::_internal_lease_use_results(int index) const {
  return _impl_.lease_use_results_.Get(index);
}
inline const ::bosdyn::api::LeaseUseResult& NavigateRouteResponse::lease_use_results(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteResponse.lease_use_results)
  return _internal_lease_use_results(index);
}
inline ::bosdyn::api::LeaseUseResult* NavigateRouteResponse::_internal_add_lease_use_results() {
  return _impl_.lease_use_results_.Add();
}
inline ::bosdyn::api::LeaseUseResult* NavigateRouteResponse::add_lease_use_results() {
  ::bosdyn::api::LeaseUseResult* _add = _internal_add_lease_use_results();
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.NavigateRouteResponse.lease_use_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
NavigateRouteResponse::lease_use_results() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.NavigateRouteResponse.lease_use_results)
  return _impl_.lease_use_results_;
}

// .bosdyn.api.graph_nav.NavigateRouteResponse.Status status = 3;
inline void NavigateRouteResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::graph_nav::NavigateRouteResponse_Status NavigateRouteResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::NavigateRouteResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::graph_nav::NavigateRouteResponse_Status NavigateRouteResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteResponse.status)
  return _internal_status();
}
inline void NavigateRouteResponse::_internal_set_status(::bosdyn::api::graph_nav::NavigateRouteResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void NavigateRouteResponse::set_status(::bosdyn::api::graph_nav::NavigateRouteResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateRouteResponse.status)
}

// .bosdyn.api.RobotImpairedState impaired_state = 7;
inline bool NavigateRouteResponse::_internal_has_impaired_state() const {
  return this != internal_default_instance() && _impl_.impaired_state_ != nullptr;
}
inline bool NavigateRouteResponse::has_impaired_state() const {
  return _internal_has_impaired_state();
}
inline const ::bosdyn::api::RobotImpairedState& NavigateRouteResponse::_internal_impaired_state() const {
  const ::bosdyn::api::RobotImpairedState* p = _impl_.impaired_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RobotImpairedState&>(
      ::bosdyn::api::_RobotImpairedState_default_instance_);
}
inline const ::bosdyn::api::RobotImpairedState& NavigateRouteResponse::impaired_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteResponse.impaired_state)
  return _internal_impaired_state();
}
inline void NavigateRouteResponse::unsafe_arena_set_allocated_impaired_state(
    ::bosdyn::api::RobotImpairedState* impaired_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.impaired_state_);
  }
  _impl_.impaired_state_ = impaired_state;
  if (impaired_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateRouteResponse.impaired_state)
}
inline ::bosdyn::api::RobotImpairedState* NavigateRouteResponse::release_impaired_state() {
  
  ::bosdyn::api::RobotImpairedState* temp = _impl_.impaired_state_;
  _impl_.impaired_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RobotImpairedState* NavigateRouteResponse::unsafe_arena_release_impaired_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateRouteResponse.impaired_state)
  
  ::bosdyn::api::RobotImpairedState* temp = _impl_.impaired_state_;
  _impl_.impaired_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RobotImpairedState* NavigateRouteResponse::_internal_mutable_impaired_state() {
  
  if (_impl_.impaired_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RobotImpairedState>(GetArenaForAllocation());
    _impl_.impaired_state_ = p;
  }
  return _impl_.impaired_state_;
}
inline ::bosdyn::api::RobotImpairedState* NavigateRouteResponse::mutable_impaired_state() {
  ::bosdyn::api::RobotImpairedState* _msg = _internal_mutable_impaired_state();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateRouteResponse.impaired_state)
  return _msg;
}
inline void NavigateRouteResponse::set_allocated_impaired_state(::bosdyn::api::RobotImpairedState* impaired_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.impaired_state_);
  }
  if (impaired_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(impaired_state));
    if (message_arena != submessage_arena) {
      impaired_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, impaired_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.impaired_state_ = impaired_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateRouteResponse.impaired_state)
}

// uint32 command_id = 4;
inline void NavigateRouteResponse::clear_command_id() {
  _impl_.command_id_ = 0u;
}
inline uint32_t NavigateRouteResponse::_internal_command_id() const {
  return _impl_.command_id_;
}
inline uint32_t NavigateRouteResponse::command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteResponse.command_id)
  return _internal_command_id();
}
inline void NavigateRouteResponse::_internal_set_command_id(uint32_t value) {
  
  _impl_.command_id_ = value;
}
inline void NavigateRouteResponse::set_command_id(uint32_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateRouteResponse.command_id)
}

// repeated string error_waypoint_ids = 5;
inline int NavigateRouteResponse::_internal_error_waypoint_ids_size() const {
  return _impl_.error_waypoint_ids_.size();
}
inline int NavigateRouteResponse::error_waypoint_ids_size() const {
  return _internal_error_waypoint_ids_size();
}
inline void NavigateRouteResponse::clear_error_waypoint_ids() {
  _impl_.error_waypoint_ids_.Clear();
}
inline std::string* NavigateRouteResponse::add_error_waypoint_ids() {
  std::string* _s = _internal_add_error_waypoint_ids();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.graph_nav.NavigateRouteResponse.error_waypoint_ids)
  return _s;
}
inline const std::string& NavigateRouteResponse::_internal_error_waypoint_ids(int index) const {
  return _impl_.error_waypoint_ids_.Get(index);
}
inline const std::string& NavigateRouteResponse::error_waypoint_ids(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteResponse.error_waypoint_ids)
  return _internal_error_waypoint_ids(index);
}
inline std::string* NavigateRouteResponse::mutable_error_waypoint_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateRouteResponse.error_waypoint_ids)
  return _impl_.error_waypoint_ids_.Mutable(index);
}
inline void NavigateRouteResponse::set_error_waypoint_ids(int index, const std::string& value) {
  _impl_.error_waypoint_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateRouteResponse.error_waypoint_ids)
}
inline void NavigateRouteResponse::set_error_waypoint_ids(int index, std::string&& value) {
  _impl_.error_waypoint_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateRouteResponse.error_waypoint_ids)
}
inline void NavigateRouteResponse::set_error_waypoint_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.error_waypoint_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.graph_nav.NavigateRouteResponse.error_waypoint_ids)
}
inline void NavigateRouteResponse::set_error_waypoint_ids(int index, const char* value, size_t size) {
  _impl_.error_waypoint_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.graph_nav.NavigateRouteResponse.error_waypoint_ids)
}
inline std::string* NavigateRouteResponse::_internal_add_error_waypoint_ids() {
  return _impl_.error_waypoint_ids_.Add();
}
inline void NavigateRouteResponse::add_error_waypoint_ids(const std::string& value) {
  _impl_.error_waypoint_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.NavigateRouteResponse.error_waypoint_ids)
}
inline void NavigateRouteResponse::add_error_waypoint_ids(std::string&& value) {
  _impl_.error_waypoint_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.NavigateRouteResponse.error_waypoint_ids)
}
inline void NavigateRouteResponse::add_error_waypoint_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.error_waypoint_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.graph_nav.NavigateRouteResponse.error_waypoint_ids)
}
inline void NavigateRouteResponse::add_error_waypoint_ids(const char* value, size_t size) {
  _impl_.error_waypoint_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.graph_nav.NavigateRouteResponse.error_waypoint_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NavigateRouteResponse::error_waypoint_ids() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.NavigateRouteResponse.error_waypoint_ids)
  return _impl_.error_waypoint_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NavigateRouteResponse::mutable_error_waypoint_ids() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.NavigateRouteResponse.error_waypoint_ids)
  return &_impl_.error_waypoint_ids_;
}

// repeated .bosdyn.api.graph_nav.Edge.Id error_edge_ids = 6;
inline int NavigateRouteResponse::_internal_error_edge_ids_size() const {
  return _impl_.error_edge_ids_.size();
}
inline int NavigateRouteResponse::error_edge_ids_size() const {
  return _internal_error_edge_ids_size();
}
inline ::bosdyn::api::graph_nav::Edge_Id* NavigateRouteResponse::mutable_error_edge_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateRouteResponse.error_edge_ids)
  return _impl_.error_edge_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::graph_nav::Edge_Id >*
NavigateRouteResponse::mutable_error_edge_ids() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.NavigateRouteResponse.error_edge_ids)
  return &_impl_.error_edge_ids_;
}
inline const ::bosdyn::api::graph_nav::Edge_Id& NavigateRouteResponse::_internal_error_edge_ids(int index) const {
  return _impl_.error_edge_ids_.Get(index);
}
inline const ::bosdyn::api::graph_nav::Edge_Id& NavigateRouteResponse::error_edge_ids(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteResponse.error_edge_ids)
  return _internal_error_edge_ids(index);
}
inline ::bosdyn::api::graph_nav::Edge_Id* NavigateRouteResponse::_internal_add_error_edge_ids() {
  return _impl_.error_edge_ids_.Add();
}
inline ::bosdyn::api::graph_nav::Edge_Id* NavigateRouteResponse::add_error_edge_ids() {
  ::bosdyn::api::graph_nav::Edge_Id* _add = _internal_add_error_edge_ids();
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.NavigateRouteResponse.error_edge_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::graph_nav::Edge_Id >&
NavigateRouteResponse::error_edge_ids() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.NavigateRouteResponse.error_edge_ids)
  return _impl_.error_edge_ids_;
}

// .bosdyn.api.graph_nav.AreaCallbackServiceError area_callback_error = 8;
inline bool NavigateRouteResponse::_internal_has_area_callback_error() const {
  return this != internal_default_instance() && _impl_.area_callback_error_ != nullptr;
}
inline bool NavigateRouteResponse::has_area_callback_error() const {
  return _internal_has_area_callback_error();
}
inline void NavigateRouteResponse::clear_area_callback_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.area_callback_error_ != nullptr) {
    delete _impl_.area_callback_error_;
  }
  _impl_.area_callback_error_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::AreaCallbackServiceError& NavigateRouteResponse::_internal_area_callback_error() const {
  const ::bosdyn::api::graph_nav::AreaCallbackServiceError* p = _impl_.area_callback_error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::AreaCallbackServiceError&>(
      ::bosdyn::api::graph_nav::_AreaCallbackServiceError_default_instance_);
}
inline const ::bosdyn::api::graph_nav::AreaCallbackServiceError& NavigateRouteResponse::area_callback_error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateRouteResponse.area_callback_error)
  return _internal_area_callback_error();
}
inline void NavigateRouteResponse::unsafe_arena_set_allocated_area_callback_error(
    ::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.area_callback_error_);
  }
  _impl_.area_callback_error_ = area_callback_error;
  if (area_callback_error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateRouteResponse.area_callback_error)
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* NavigateRouteResponse::release_area_callback_error() {
  
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* temp = _impl_.area_callback_error_;
  _impl_.area_callback_error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* NavigateRouteResponse::unsafe_arena_release_area_callback_error() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateRouteResponse.area_callback_error)
  
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* temp = _impl_.area_callback_error_;
  _impl_.area_callback_error_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* NavigateRouteResponse::_internal_mutable_area_callback_error() {
  
  if (_impl_.area_callback_error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::AreaCallbackServiceError>(GetArenaForAllocation());
    _impl_.area_callback_error_ = p;
  }
  return _impl_.area_callback_error_;
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* NavigateRouteResponse::mutable_area_callback_error() {
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* _msg = _internal_mutable_area_callback_error();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateRouteResponse.area_callback_error)
  return _msg;
}
inline void NavigateRouteResponse::set_allocated_area_callback_error(::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.area_callback_error_;
  }
  if (area_callback_error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(area_callback_error);
    if (message_arena != submessage_arena) {
      area_callback_error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, area_callback_error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.area_callback_error_ = area_callback_error;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateRouteResponse.area_callback_error)
}

// -------------------------------------------------------------------

// NavigateToAnchorRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool NavigateToAnchorRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool NavigateToAnchorRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& NavigateToAnchorRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& NavigateToAnchorRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToAnchorRequest.header)
  return _internal_header();
}
inline void NavigateToAnchorRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorRequest.header)
}
inline ::bosdyn::api::RequestHeader* NavigateToAnchorRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* NavigateToAnchorRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToAnchorRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* NavigateToAnchorRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* NavigateToAnchorRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToAnchorRequest.header)
  return _msg;
}
inline void NavigateToAnchorRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorRequest.header)
}

// repeated .bosdyn.api.Lease leases = 2;
inline int NavigateToAnchorRequest::_internal_leases_size() const {
  return _impl_.leases_.size();
}
inline int NavigateToAnchorRequest::leases_size() const {
  return _internal_leases_size();
}
inline ::bosdyn::api::Lease* NavigateToAnchorRequest::mutable_leases(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToAnchorRequest.leases)
  return _impl_.leases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
NavigateToAnchorRequest::mutable_leases() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.NavigateToAnchorRequest.leases)
  return &_impl_.leases_;
}
inline const ::bosdyn::api::Lease& NavigateToAnchorRequest::_internal_leases(int index) const {
  return _impl_.leases_.Get(index);
}
inline const ::bosdyn::api::Lease& NavigateToAnchorRequest::leases(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToAnchorRequest.leases)
  return _internal_leases(index);
}
inline ::bosdyn::api::Lease* NavigateToAnchorRequest::_internal_add_leases() {
  return _impl_.leases_.Add();
}
inline ::bosdyn::api::Lease* NavigateToAnchorRequest::add_leases() {
  ::bosdyn::api::Lease* _add = _internal_add_leases();
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.NavigateToAnchorRequest.leases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
NavigateToAnchorRequest::leases() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.NavigateToAnchorRequest.leases)
  return _impl_.leases_;
}

// .bosdyn.api.SE3Pose seed_tform_goal = 3;
inline bool NavigateToAnchorRequest::_internal_has_seed_tform_goal() const {
  return this != internal_default_instance() && _impl_.seed_tform_goal_ != nullptr;
}
inline bool NavigateToAnchorRequest::has_seed_tform_goal() const {
  return _internal_has_seed_tform_goal();
}
inline const ::bosdyn::api::SE3Pose& NavigateToAnchorRequest::_internal_seed_tform_goal() const {
  const ::bosdyn::api::SE3Pose* p = _impl_.seed_tform_goal_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Pose&>(
      ::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& NavigateToAnchorRequest::seed_tform_goal() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToAnchorRequest.seed_tform_goal)
  return _internal_seed_tform_goal();
}
inline void NavigateToAnchorRequest::unsafe_arena_set_allocated_seed_tform_goal(
    ::bosdyn::api::SE3Pose* seed_tform_goal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.seed_tform_goal_);
  }
  _impl_.seed_tform_goal_ = seed_tform_goal;
  if (seed_tform_goal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorRequest.seed_tform_goal)
}
inline ::bosdyn::api::SE3Pose* NavigateToAnchorRequest::release_seed_tform_goal() {
  
  ::bosdyn::api::SE3Pose* temp = _impl_.seed_tform_goal_;
  _impl_.seed_tform_goal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Pose* NavigateToAnchorRequest::unsafe_arena_release_seed_tform_goal() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToAnchorRequest.seed_tform_goal)
  
  ::bosdyn::api::SE3Pose* temp = _impl_.seed_tform_goal_;
  _impl_.seed_tform_goal_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* NavigateToAnchorRequest::_internal_mutable_seed_tform_goal() {
  
  if (_impl_.seed_tform_goal_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArenaForAllocation());
    _impl_.seed_tform_goal_ = p;
  }
  return _impl_.seed_tform_goal_;
}
inline ::bosdyn::api::SE3Pose* NavigateToAnchorRequest::mutable_seed_tform_goal() {
  ::bosdyn::api::SE3Pose* _msg = _internal_mutable_seed_tform_goal();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToAnchorRequest.seed_tform_goal)
  return _msg;
}
inline void NavigateToAnchorRequest::set_allocated_seed_tform_goal(::bosdyn::api::SE3Pose* seed_tform_goal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.seed_tform_goal_);
  }
  if (seed_tform_goal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(seed_tform_goal));
    if (message_arena != submessage_arena) {
      seed_tform_goal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seed_tform_goal, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.seed_tform_goal_ = seed_tform_goal;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorRequest.seed_tform_goal)
}

// .bosdyn.api.Vec3 goal_waypoint_rt_seed_ewrt_seed_tolerance = 4;
inline bool NavigateToAnchorRequest::_internal_has_goal_waypoint_rt_seed_ewrt_seed_tolerance() const {
  return this != internal_default_instance() && _impl_.goal_waypoint_rt_seed_ewrt_seed_tolerance_ != nullptr;
}
inline bool NavigateToAnchorRequest::has_goal_waypoint_rt_seed_ewrt_seed_tolerance() const {
  return _internal_has_goal_waypoint_rt_seed_ewrt_seed_tolerance();
}
inline const ::bosdyn::api::Vec3& NavigateToAnchorRequest::_internal_goal_waypoint_rt_seed_ewrt_seed_tolerance() const {
  const ::bosdyn::api::Vec3* p = _impl_.goal_waypoint_rt_seed_ewrt_seed_tolerance_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& NavigateToAnchorRequest::goal_waypoint_rt_seed_ewrt_seed_tolerance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToAnchorRequest.goal_waypoint_rt_seed_ewrt_seed_tolerance)
  return _internal_goal_waypoint_rt_seed_ewrt_seed_tolerance();
}
inline void NavigateToAnchorRequest::unsafe_arena_set_allocated_goal_waypoint_rt_seed_ewrt_seed_tolerance(
    ::bosdyn::api::Vec3* goal_waypoint_rt_seed_ewrt_seed_tolerance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.goal_waypoint_rt_seed_ewrt_seed_tolerance_);
  }
  _impl_.goal_waypoint_rt_seed_ewrt_seed_tolerance_ = goal_waypoint_rt_seed_ewrt_seed_tolerance;
  if (goal_waypoint_rt_seed_ewrt_seed_tolerance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorRequest.goal_waypoint_rt_seed_ewrt_seed_tolerance)
}
inline ::bosdyn::api::Vec3* NavigateToAnchorRequest::release_goal_waypoint_rt_seed_ewrt_seed_tolerance() {
  
  ::bosdyn::api::Vec3* temp = _impl_.goal_waypoint_rt_seed_ewrt_seed_tolerance_;
  _impl_.goal_waypoint_rt_seed_ewrt_seed_tolerance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* NavigateToAnchorRequest::unsafe_arena_release_goal_waypoint_rt_seed_ewrt_seed_tolerance() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToAnchorRequest.goal_waypoint_rt_seed_ewrt_seed_tolerance)
  
  ::bosdyn::api::Vec3* temp = _impl_.goal_waypoint_rt_seed_ewrt_seed_tolerance_;
  _impl_.goal_waypoint_rt_seed_ewrt_seed_tolerance_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* NavigateToAnchorRequest::_internal_mutable_goal_waypoint_rt_seed_ewrt_seed_tolerance() {
  
  if (_impl_.goal_waypoint_rt_seed_ewrt_seed_tolerance_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.goal_waypoint_rt_seed_ewrt_seed_tolerance_ = p;
  }
  return _impl_.goal_waypoint_rt_seed_ewrt_seed_tolerance_;
}
inline ::bosdyn::api::Vec3* NavigateToAnchorRequest::mutable_goal_waypoint_rt_seed_ewrt_seed_tolerance() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_goal_waypoint_rt_seed_ewrt_seed_tolerance();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToAnchorRequest.goal_waypoint_rt_seed_ewrt_seed_tolerance)
  return _msg;
}
inline void NavigateToAnchorRequest::set_allocated_goal_waypoint_rt_seed_ewrt_seed_tolerance(::bosdyn::api::Vec3* goal_waypoint_rt_seed_ewrt_seed_tolerance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.goal_waypoint_rt_seed_ewrt_seed_tolerance_);
  }
  if (goal_waypoint_rt_seed_ewrt_seed_tolerance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(goal_waypoint_rt_seed_ewrt_seed_tolerance));
    if (message_arena != submessage_arena) {
      goal_waypoint_rt_seed_ewrt_seed_tolerance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, goal_waypoint_rt_seed_ewrt_seed_tolerance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.goal_waypoint_rt_seed_ewrt_seed_tolerance_ = goal_waypoint_rt_seed_ewrt_seed_tolerance;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorRequest.goal_waypoint_rt_seed_ewrt_seed_tolerance)
}

// .bosdyn.api.graph_nav.RouteGenParams route_params = 6;
inline bool NavigateToAnchorRequest::_internal_has_route_params() const {
  return this != internal_default_instance() && _impl_.route_params_ != nullptr;
}
inline bool NavigateToAnchorRequest::has_route_params() const {
  return _internal_has_route_params();
}
inline void NavigateToAnchorRequest::clear_route_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.route_params_ != nullptr) {
    delete _impl_.route_params_;
  }
  _impl_.route_params_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::RouteGenParams& NavigateToAnchorRequest::_internal_route_params() const {
  const ::bosdyn::api::graph_nav::RouteGenParams* p = _impl_.route_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::RouteGenParams&>(
      ::bosdyn::api::graph_nav::_RouteGenParams_default_instance_);
}
inline const ::bosdyn::api::graph_nav::RouteGenParams& NavigateToAnchorRequest::route_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToAnchorRequest.route_params)
  return _internal_route_params();
}
inline void NavigateToAnchorRequest::unsafe_arena_set_allocated_route_params(
    ::bosdyn::api::graph_nav::RouteGenParams* route_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_params_);
  }
  _impl_.route_params_ = route_params;
  if (route_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorRequest.route_params)
}
inline ::bosdyn::api::graph_nav::RouteGenParams* NavigateToAnchorRequest::release_route_params() {
  
  ::bosdyn::api::graph_nav::RouteGenParams* temp = _impl_.route_params_;
  _impl_.route_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::RouteGenParams* NavigateToAnchorRequest::unsafe_arena_release_route_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToAnchorRequest.route_params)
  
  ::bosdyn::api::graph_nav::RouteGenParams* temp = _impl_.route_params_;
  _impl_.route_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::RouteGenParams* NavigateToAnchorRequest::_internal_mutable_route_params() {
  
  if (_impl_.route_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::RouteGenParams>(GetArenaForAllocation());
    _impl_.route_params_ = p;
  }
  return _impl_.route_params_;
}
inline ::bosdyn::api::graph_nav::RouteGenParams* NavigateToAnchorRequest::mutable_route_params() {
  ::bosdyn::api::graph_nav::RouteGenParams* _msg = _internal_mutable_route_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToAnchorRequest.route_params)
  return _msg;
}
inline void NavigateToAnchorRequest::set_allocated_route_params(::bosdyn::api::graph_nav::RouteGenParams* route_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.route_params_;
  }
  if (route_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(route_params);
    if (message_arena != submessage_arena) {
      route_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.route_params_ = route_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorRequest.route_params)
}

// .bosdyn.api.graph_nav.TravelParams travel_params = 7;
inline bool NavigateToAnchorRequest::_internal_has_travel_params() const {
  return this != internal_default_instance() && _impl_.travel_params_ != nullptr;
}
inline bool NavigateToAnchorRequest::has_travel_params() const {
  return _internal_has_travel_params();
}
inline void NavigateToAnchorRequest::clear_travel_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.travel_params_ != nullptr) {
    delete _impl_.travel_params_;
  }
  _impl_.travel_params_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::TravelParams& NavigateToAnchorRequest::_internal_travel_params() const {
  const ::bosdyn::api::graph_nav::TravelParams* p = _impl_.travel_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::TravelParams&>(
      ::bosdyn::api::graph_nav::_TravelParams_default_instance_);
}
inline const ::bosdyn::api::graph_nav::TravelParams& NavigateToAnchorRequest::travel_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToAnchorRequest.travel_params)
  return _internal_travel_params();
}
inline void NavigateToAnchorRequest::unsafe_arena_set_allocated_travel_params(
    ::bosdyn::api::graph_nav::TravelParams* travel_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.travel_params_);
  }
  _impl_.travel_params_ = travel_params;
  if (travel_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorRequest.travel_params)
}
inline ::bosdyn::api::graph_nav::TravelParams* NavigateToAnchorRequest::release_travel_params() {
  
  ::bosdyn::api::graph_nav::TravelParams* temp = _impl_.travel_params_;
  _impl_.travel_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::TravelParams* NavigateToAnchorRequest::unsafe_arena_release_travel_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToAnchorRequest.travel_params)
  
  ::bosdyn::api::graph_nav::TravelParams* temp = _impl_.travel_params_;
  _impl_.travel_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::TravelParams* NavigateToAnchorRequest::_internal_mutable_travel_params() {
  
  if (_impl_.travel_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::TravelParams>(GetArenaForAllocation());
    _impl_.travel_params_ = p;
  }
  return _impl_.travel_params_;
}
inline ::bosdyn::api::graph_nav::TravelParams* NavigateToAnchorRequest::mutable_travel_params() {
  ::bosdyn::api::graph_nav::TravelParams* _msg = _internal_mutable_travel_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToAnchorRequest.travel_params)
  return _msg;
}
inline void NavigateToAnchorRequest::set_allocated_travel_params(::bosdyn::api::graph_nav::TravelParams* travel_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.travel_params_;
  }
  if (travel_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(travel_params);
    if (message_arena != submessage_arena) {
      travel_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, travel_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.travel_params_ = travel_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorRequest.travel_params)
}

// .google.protobuf.Timestamp end_time = 8;
inline bool NavigateToAnchorRequest::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool NavigateToAnchorRequest::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& NavigateToAnchorRequest::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& NavigateToAnchorRequest::end_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToAnchorRequest.end_time)
  return _internal_end_time();
}
inline void NavigateToAnchorRequest::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorRequest.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NavigateToAnchorRequest::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NavigateToAnchorRequest::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToAnchorRequest.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NavigateToAnchorRequest::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NavigateToAnchorRequest::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToAnchorRequest.end_time)
  return _msg;
}
inline void NavigateToAnchorRequest::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorRequest.end_time)
}

// string clock_identifier = 9;
inline void NavigateToAnchorRequest::clear_clock_identifier() {
  _impl_.clock_identifier_.ClearToEmpty();
}
inline const std::string& NavigateToAnchorRequest::clock_identifier() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToAnchorRequest.clock_identifier)
  return _internal_clock_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NavigateToAnchorRequest::set_clock_identifier(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clock_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateToAnchorRequest.clock_identifier)
}
inline std::string* NavigateToAnchorRequest::mutable_clock_identifier() {
  std::string* _s = _internal_mutable_clock_identifier();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToAnchorRequest.clock_identifier)
  return _s;
}
inline const std::string& NavigateToAnchorRequest::_internal_clock_identifier() const {
  return _impl_.clock_identifier_.Get();
}
inline void NavigateToAnchorRequest::_internal_set_clock_identifier(const std::string& value) {
  
  _impl_.clock_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* NavigateToAnchorRequest::_internal_mutable_clock_identifier() {
  
  return _impl_.clock_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* NavigateToAnchorRequest::release_clock_identifier() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToAnchorRequest.clock_identifier)
  return _impl_.clock_identifier_.Release();
}
inline void NavigateToAnchorRequest::set_allocated_clock_identifier(std::string* clock_identifier) {
  if (clock_identifier != nullptr) {
    
  } else {
    
  }
  _impl_.clock_identifier_.SetAllocated(clock_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clock_identifier_.IsDefault()) {
    _impl_.clock_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorRequest.clock_identifier)
}

// uint32 command_id = 10;
inline void NavigateToAnchorRequest::clear_command_id() {
  _impl_.command_id_ = 0u;
}
inline uint32_t NavigateToAnchorRequest::_internal_command_id() const {
  return _impl_.command_id_;
}
inline uint32_t NavigateToAnchorRequest::command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToAnchorRequest.command_id)
  return _internal_command_id();
}
inline void NavigateToAnchorRequest::_internal_set_command_id(uint32_t value) {
  
  _impl_.command_id_ = value;
}
inline void NavigateToAnchorRequest::set_command_id(uint32_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateToAnchorRequest.command_id)
}

// -------------------------------------------------------------------

// NavigateToAnchorResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool NavigateToAnchorResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool NavigateToAnchorResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& NavigateToAnchorResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& NavigateToAnchorResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToAnchorResponse.header)
  return _internal_header();
}
inline void NavigateToAnchorResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorResponse.header)
}
inline ::bosdyn::api::ResponseHeader* NavigateToAnchorResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* NavigateToAnchorResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToAnchorResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* NavigateToAnchorResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* NavigateToAnchorResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToAnchorResponse.header)
  return _msg;
}
inline void NavigateToAnchorResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorResponse.header)
}

// repeated .bosdyn.api.LeaseUseResult lease_use_results = 2;
inline int NavigateToAnchorResponse::_internal_lease_use_results_size() const {
  return _impl_.lease_use_results_.size();
}
inline int NavigateToAnchorResponse::lease_use_results_size() const {
  return _internal_lease_use_results_size();
}
inline ::bosdyn::api::LeaseUseResult* NavigateToAnchorResponse::mutable_lease_use_results(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToAnchorResponse.lease_use_results)
  return _impl_.lease_use_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
NavigateToAnchorResponse::mutable_lease_use_results() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.NavigateToAnchorResponse.lease_use_results)
  return &_impl_.lease_use_results_;
}
inline const ::bosdyn::api::LeaseUseResult& NavigateToAnchorResponse::_internal_lease_use_results(int index) const {
  return _impl_.lease_use_results_.Get(index);
}
inline const ::bosdyn::api::LeaseUseResult& NavigateToAnchorResponse::lease_use_results(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToAnchorResponse.lease_use_results)
  return _internal_lease_use_results(index);
}
inline ::bosdyn::api::LeaseUseResult* NavigateToAnchorResponse::_internal_add_lease_use_results() {
  return _impl_.lease_use_results_.Add();
}
inline ::bosdyn::api::LeaseUseResult* NavigateToAnchorResponse::add_lease_use_results() {
  ::bosdyn::api::LeaseUseResult* _add = _internal_add_lease_use_results();
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.NavigateToAnchorResponse.lease_use_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
NavigateToAnchorResponse::lease_use_results() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.NavigateToAnchorResponse.lease_use_results)
  return _impl_.lease_use_results_;
}

// .bosdyn.api.graph_nav.NavigateToAnchorResponse.Status status = 3;
inline void NavigateToAnchorResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::graph_nav::NavigateToAnchorResponse_Status NavigateToAnchorResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::NavigateToAnchorResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::graph_nav::NavigateToAnchorResponse_Status NavigateToAnchorResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToAnchorResponse.status)
  return _internal_status();
}
inline void NavigateToAnchorResponse::_internal_set_status(::bosdyn::api::graph_nav::NavigateToAnchorResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void NavigateToAnchorResponse::set_status(::bosdyn::api::graph_nav::NavigateToAnchorResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateToAnchorResponse.status)
}

// .bosdyn.api.RobotImpairedState impaired_state = 6;
inline bool NavigateToAnchorResponse::_internal_has_impaired_state() const {
  return this != internal_default_instance() && _impl_.impaired_state_ != nullptr;
}
inline bool NavigateToAnchorResponse::has_impaired_state() const {
  return _internal_has_impaired_state();
}
inline const ::bosdyn::api::RobotImpairedState& NavigateToAnchorResponse::_internal_impaired_state() const {
  const ::bosdyn::api::RobotImpairedState* p = _impl_.impaired_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RobotImpairedState&>(
      ::bosdyn::api::_RobotImpairedState_default_instance_);
}
inline const ::bosdyn::api::RobotImpairedState& NavigateToAnchorResponse::impaired_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToAnchorResponse.impaired_state)
  return _internal_impaired_state();
}
inline void NavigateToAnchorResponse::unsafe_arena_set_allocated_impaired_state(
    ::bosdyn::api::RobotImpairedState* impaired_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.impaired_state_);
  }
  _impl_.impaired_state_ = impaired_state;
  if (impaired_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorResponse.impaired_state)
}
inline ::bosdyn::api::RobotImpairedState* NavigateToAnchorResponse::release_impaired_state() {
  
  ::bosdyn::api::RobotImpairedState* temp = _impl_.impaired_state_;
  _impl_.impaired_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RobotImpairedState* NavigateToAnchorResponse::unsafe_arena_release_impaired_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToAnchorResponse.impaired_state)
  
  ::bosdyn::api::RobotImpairedState* temp = _impl_.impaired_state_;
  _impl_.impaired_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RobotImpairedState* NavigateToAnchorResponse::_internal_mutable_impaired_state() {
  
  if (_impl_.impaired_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RobotImpairedState>(GetArenaForAllocation());
    _impl_.impaired_state_ = p;
  }
  return _impl_.impaired_state_;
}
inline ::bosdyn::api::RobotImpairedState* NavigateToAnchorResponse::mutable_impaired_state() {
  ::bosdyn::api::RobotImpairedState* _msg = _internal_mutable_impaired_state();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToAnchorResponse.impaired_state)
  return _msg;
}
inline void NavigateToAnchorResponse::set_allocated_impaired_state(::bosdyn::api::RobotImpairedState* impaired_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.impaired_state_);
  }
  if (impaired_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(impaired_state));
    if (message_arena != submessage_arena) {
      impaired_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, impaired_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.impaired_state_ = impaired_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorResponse.impaired_state)
}

// uint32 command_id = 4;
inline void NavigateToAnchorResponse::clear_command_id() {
  _impl_.command_id_ = 0u;
}
inline uint32_t NavigateToAnchorResponse::_internal_command_id() const {
  return _impl_.command_id_;
}
inline uint32_t NavigateToAnchorResponse::command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToAnchorResponse.command_id)
  return _internal_command_id();
}
inline void NavigateToAnchorResponse::_internal_set_command_id(uint32_t value) {
  
  _impl_.command_id_ = value;
}
inline void NavigateToAnchorResponse::set_command_id(uint32_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateToAnchorResponse.command_id)
}

// repeated string error_waypoint_ids = 5;
inline int NavigateToAnchorResponse::_internal_error_waypoint_ids_size() const {
  return _impl_.error_waypoint_ids_.size();
}
inline int NavigateToAnchorResponse::error_waypoint_ids_size() const {
  return _internal_error_waypoint_ids_size();
}
inline void NavigateToAnchorResponse::clear_error_waypoint_ids() {
  _impl_.error_waypoint_ids_.Clear();
}
inline std::string* NavigateToAnchorResponse::add_error_waypoint_ids() {
  std::string* _s = _internal_add_error_waypoint_ids();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.graph_nav.NavigateToAnchorResponse.error_waypoint_ids)
  return _s;
}
inline const std::string& NavigateToAnchorResponse::_internal_error_waypoint_ids(int index) const {
  return _impl_.error_waypoint_ids_.Get(index);
}
inline const std::string& NavigateToAnchorResponse::error_waypoint_ids(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToAnchorResponse.error_waypoint_ids)
  return _internal_error_waypoint_ids(index);
}
inline std::string* NavigateToAnchorResponse::mutable_error_waypoint_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToAnchorResponse.error_waypoint_ids)
  return _impl_.error_waypoint_ids_.Mutable(index);
}
inline void NavigateToAnchorResponse::set_error_waypoint_ids(int index, const std::string& value) {
  _impl_.error_waypoint_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateToAnchorResponse.error_waypoint_ids)
}
inline void NavigateToAnchorResponse::set_error_waypoint_ids(int index, std::string&& value) {
  _impl_.error_waypoint_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigateToAnchorResponse.error_waypoint_ids)
}
inline void NavigateToAnchorResponse::set_error_waypoint_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.error_waypoint_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.graph_nav.NavigateToAnchorResponse.error_waypoint_ids)
}
inline void NavigateToAnchorResponse::set_error_waypoint_ids(int index, const char* value, size_t size) {
  _impl_.error_waypoint_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.graph_nav.NavigateToAnchorResponse.error_waypoint_ids)
}
inline std::string* NavigateToAnchorResponse::_internal_add_error_waypoint_ids() {
  return _impl_.error_waypoint_ids_.Add();
}
inline void NavigateToAnchorResponse::add_error_waypoint_ids(const std::string& value) {
  _impl_.error_waypoint_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.NavigateToAnchorResponse.error_waypoint_ids)
}
inline void NavigateToAnchorResponse::add_error_waypoint_ids(std::string&& value) {
  _impl_.error_waypoint_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.NavigateToAnchorResponse.error_waypoint_ids)
}
inline void NavigateToAnchorResponse::add_error_waypoint_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.error_waypoint_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.graph_nav.NavigateToAnchorResponse.error_waypoint_ids)
}
inline void NavigateToAnchorResponse::add_error_waypoint_ids(const char* value, size_t size) {
  _impl_.error_waypoint_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.graph_nav.NavigateToAnchorResponse.error_waypoint_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NavigateToAnchorResponse::error_waypoint_ids() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.NavigateToAnchorResponse.error_waypoint_ids)
  return _impl_.error_waypoint_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NavigateToAnchorResponse::mutable_error_waypoint_ids() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.NavigateToAnchorResponse.error_waypoint_ids)
  return &_impl_.error_waypoint_ids_;
}

// .bosdyn.api.graph_nav.AreaCallbackServiceError area_callback_error = 7;
inline bool NavigateToAnchorResponse::_internal_has_area_callback_error() const {
  return this != internal_default_instance() && _impl_.area_callback_error_ != nullptr;
}
inline bool NavigateToAnchorResponse::has_area_callback_error() const {
  return _internal_has_area_callback_error();
}
inline void NavigateToAnchorResponse::clear_area_callback_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.area_callback_error_ != nullptr) {
    delete _impl_.area_callback_error_;
  }
  _impl_.area_callback_error_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::AreaCallbackServiceError& NavigateToAnchorResponse::_internal_area_callback_error() const {
  const ::bosdyn::api::graph_nav::AreaCallbackServiceError* p = _impl_.area_callback_error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::AreaCallbackServiceError&>(
      ::bosdyn::api::graph_nav::_AreaCallbackServiceError_default_instance_);
}
inline const ::bosdyn::api::graph_nav::AreaCallbackServiceError& NavigateToAnchorResponse::area_callback_error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigateToAnchorResponse.area_callback_error)
  return _internal_area_callback_error();
}
inline void NavigateToAnchorResponse::unsafe_arena_set_allocated_area_callback_error(
    ::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.area_callback_error_);
  }
  _impl_.area_callback_error_ = area_callback_error;
  if (area_callback_error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorResponse.area_callback_error)
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* NavigateToAnchorResponse::release_area_callback_error() {
  
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* temp = _impl_.area_callback_error_;
  _impl_.area_callback_error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* NavigateToAnchorResponse::unsafe_arena_release_area_callback_error() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigateToAnchorResponse.area_callback_error)
  
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* temp = _impl_.area_callback_error_;
  _impl_.area_callback_error_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* NavigateToAnchorResponse::_internal_mutable_area_callback_error() {
  
  if (_impl_.area_callback_error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::AreaCallbackServiceError>(GetArenaForAllocation());
    _impl_.area_callback_error_ = p;
  }
  return _impl_.area_callback_error_;
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* NavigateToAnchorResponse::mutable_area_callback_error() {
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* _msg = _internal_mutable_area_callback_error();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigateToAnchorResponse.area_callback_error)
  return _msg;
}
inline void NavigateToAnchorResponse::set_allocated_area_callback_error(::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.area_callback_error_;
  }
  if (area_callback_error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(area_callback_error);
    if (message_arena != submessage_arena) {
      area_callback_error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, area_callback_error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.area_callback_error_ = area_callback_error;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigateToAnchorResponse.area_callback_error)
}

// -------------------------------------------------------------------

// NavigationFeedbackRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool NavigationFeedbackRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool NavigationFeedbackRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& NavigationFeedbackRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& NavigationFeedbackRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigationFeedbackRequest.header)
  return _internal_header();
}
inline void NavigationFeedbackRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigationFeedbackRequest.header)
}
inline ::bosdyn::api::RequestHeader* NavigationFeedbackRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* NavigationFeedbackRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigationFeedbackRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* NavigationFeedbackRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* NavigationFeedbackRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigationFeedbackRequest.header)
  return _msg;
}
inline void NavigationFeedbackRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigationFeedbackRequest.header)
}

// uint32 command_id = 2;
inline void NavigationFeedbackRequest::clear_command_id() {
  _impl_.command_id_ = 0u;
}
inline uint32_t NavigationFeedbackRequest::_internal_command_id() const {
  return _impl_.command_id_;
}
inline uint32_t NavigationFeedbackRequest::command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigationFeedbackRequest.command_id)
  return _internal_command_id();
}
inline void NavigationFeedbackRequest::_internal_set_command_id(uint32_t value) {
  
  _impl_.command_id_ = value;
}
inline void NavigationFeedbackRequest::set_command_id(uint32_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigationFeedbackRequest.command_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NavigationFeedbackResponse_ActiveRegionInformation

// string description = 1;
inline void NavigationFeedbackResponse_ActiveRegionInformation::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& NavigationFeedbackResponse_ActiveRegionInformation::description() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NavigationFeedbackResponse_ActiveRegionInformation::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation.description)
}
inline std::string* NavigationFeedbackResponse_ActiveRegionInformation::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation.description)
  return _s;
}
inline const std::string& NavigationFeedbackResponse_ActiveRegionInformation::_internal_description() const {
  return _impl_.description_.Get();
}
inline void NavigationFeedbackResponse_ActiveRegionInformation::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* NavigationFeedbackResponse_ActiveRegionInformation::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* NavigationFeedbackResponse_ActiveRegionInformation::release_description() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation.description)
  return _impl_.description_.Release();
}
inline void NavigationFeedbackResponse_ActiveRegionInformation::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation.description)
}

// string service_name = 2;
inline void NavigationFeedbackResponse_ActiveRegionInformation::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& NavigationFeedbackResponse_ActiveRegionInformation::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NavigationFeedbackResponse_ActiveRegionInformation::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation.service_name)
}
inline std::string* NavigationFeedbackResponse_ActiveRegionInformation::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation.service_name)
  return _s;
}
inline const std::string& NavigationFeedbackResponse_ActiveRegionInformation::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void NavigationFeedbackResponse_ActiveRegionInformation::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NavigationFeedbackResponse_ActiveRegionInformation::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NavigationFeedbackResponse_ActiveRegionInformation::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation.service_name)
  return _impl_.service_name_.Release();
}
inline void NavigationFeedbackResponse_ActiveRegionInformation::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation.service_name)
}

// .bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation.AreaCallbackStatus region_status = 3;
inline void NavigationFeedbackResponse_ActiveRegionInformation::clear_region_status() {
  _impl_.region_status_ = 0;
}
inline ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus NavigationFeedbackResponse_ActiveRegionInformation::_internal_region_status() const {
  return static_cast< ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus >(_impl_.region_status_);
}
inline ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus NavigationFeedbackResponse_ActiveRegionInformation::region_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation.region_status)
  return _internal_region_status();
}
inline void NavigationFeedbackResponse_ActiveRegionInformation::_internal_set_region_status(::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus value) {
  
  _impl_.region_status_ = value;
}
inline void NavigationFeedbackResponse_ActiveRegionInformation::set_region_status(::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus value) {
  _internal_set_region_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation.region_status)
}

// -------------------------------------------------------------------

// NavigationFeedbackResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool NavigationFeedbackResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool NavigationFeedbackResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& NavigationFeedbackResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& NavigationFeedbackResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigationFeedbackResponse.header)
  return _internal_header();
}
inline void NavigationFeedbackResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigationFeedbackResponse.header)
}
inline ::bosdyn::api::ResponseHeader* NavigationFeedbackResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* NavigationFeedbackResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigationFeedbackResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* NavigationFeedbackResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* NavigationFeedbackResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigationFeedbackResponse.header)
  return _msg;
}
inline void NavigationFeedbackResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigationFeedbackResponse.header)
}

// .bosdyn.api.graph_nav.NavigationFeedbackResponse.Status status = 2;
inline void NavigationFeedbackResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::graph_nav::NavigationFeedbackResponse_Status NavigationFeedbackResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::NavigationFeedbackResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::graph_nav::NavigationFeedbackResponse_Status NavigationFeedbackResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigationFeedbackResponse.status)
  return _internal_status();
}
inline void NavigationFeedbackResponse::_internal_set_status(::bosdyn::api::graph_nav::NavigationFeedbackResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void NavigationFeedbackResponse::set_status(::bosdyn::api::graph_nav::NavigationFeedbackResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigationFeedbackResponse.status)
}

// .bosdyn.api.RobotImpairedState impaired_state = 6;
inline bool NavigationFeedbackResponse::_internal_has_impaired_state() const {
  return this != internal_default_instance() && _impl_.impaired_state_ != nullptr;
}
inline bool NavigationFeedbackResponse::has_impaired_state() const {
  return _internal_has_impaired_state();
}
inline const ::bosdyn::api::RobotImpairedState& NavigationFeedbackResponse::_internal_impaired_state() const {
  const ::bosdyn::api::RobotImpairedState* p = _impl_.impaired_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RobotImpairedState&>(
      ::bosdyn::api::_RobotImpairedState_default_instance_);
}
inline const ::bosdyn::api::RobotImpairedState& NavigationFeedbackResponse::impaired_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigationFeedbackResponse.impaired_state)
  return _internal_impaired_state();
}
inline void NavigationFeedbackResponse::unsafe_arena_set_allocated_impaired_state(
    ::bosdyn::api::RobotImpairedState* impaired_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.impaired_state_);
  }
  _impl_.impaired_state_ = impaired_state;
  if (impaired_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigationFeedbackResponse.impaired_state)
}
inline ::bosdyn::api::RobotImpairedState* NavigationFeedbackResponse::release_impaired_state() {
  
  ::bosdyn::api::RobotImpairedState* temp = _impl_.impaired_state_;
  _impl_.impaired_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RobotImpairedState* NavigationFeedbackResponse::unsafe_arena_release_impaired_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigationFeedbackResponse.impaired_state)
  
  ::bosdyn::api::RobotImpairedState* temp = _impl_.impaired_state_;
  _impl_.impaired_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RobotImpairedState* NavigationFeedbackResponse::_internal_mutable_impaired_state() {
  
  if (_impl_.impaired_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RobotImpairedState>(GetArenaForAllocation());
    _impl_.impaired_state_ = p;
  }
  return _impl_.impaired_state_;
}
inline ::bosdyn::api::RobotImpairedState* NavigationFeedbackResponse::mutable_impaired_state() {
  ::bosdyn::api::RobotImpairedState* _msg = _internal_mutable_impaired_state();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigationFeedbackResponse.impaired_state)
  return _msg;
}
inline void NavigationFeedbackResponse::set_allocated_impaired_state(::bosdyn::api::RobotImpairedState* impaired_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.impaired_state_);
  }
  if (impaired_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(impaired_state));
    if (message_arena != submessage_arena) {
      impaired_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, impaired_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.impaired_state_ = impaired_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigationFeedbackResponse.impaired_state)
}

// map<string, .bosdyn.api.graph_nav.AreaCallbackError> area_callback_errors = 9;
inline int NavigationFeedbackResponse::_internal_area_callback_errors_size() const {
  return _impl_.area_callback_errors_.size();
}
inline int NavigationFeedbackResponse::area_callback_errors_size() const {
  return _internal_area_callback_errors_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::graph_nav::AreaCallbackError >&
NavigationFeedbackResponse::_internal_area_callback_errors() const {
  return _impl_.area_callback_errors_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::graph_nav::AreaCallbackError >&
NavigationFeedbackResponse::area_callback_errors() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.graph_nav.NavigationFeedbackResponse.area_callback_errors)
  return _internal_area_callback_errors();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::graph_nav::AreaCallbackError >*
NavigationFeedbackResponse::_internal_mutable_area_callback_errors() {
  return _impl_.area_callback_errors_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::graph_nav::AreaCallbackError >*
NavigationFeedbackResponse::mutable_area_callback_errors() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.graph_nav.NavigationFeedbackResponse.area_callback_errors)
  return _internal_mutable_area_callback_errors();
}

// .bosdyn.api.graph_nav.Route remaining_route = 3;
inline bool NavigationFeedbackResponse::_internal_has_remaining_route() const {
  return this != internal_default_instance() && _impl_.remaining_route_ != nullptr;
}
inline bool NavigationFeedbackResponse::has_remaining_route() const {
  return _internal_has_remaining_route();
}
inline const ::bosdyn::api::graph_nav::Route& NavigationFeedbackResponse::_internal_remaining_route() const {
  const ::bosdyn::api::graph_nav::Route* p = _impl_.remaining_route_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::Route&>(
      ::bosdyn::api::graph_nav::_Route_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Route& NavigationFeedbackResponse::remaining_route() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigationFeedbackResponse.remaining_route)
  return _internal_remaining_route();
}
inline void NavigationFeedbackResponse::unsafe_arena_set_allocated_remaining_route(
    ::bosdyn::api::graph_nav::Route* remaining_route) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remaining_route_);
  }
  _impl_.remaining_route_ = remaining_route;
  if (remaining_route) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigationFeedbackResponse.remaining_route)
}
inline ::bosdyn::api::graph_nav::Route* NavigationFeedbackResponse::release_remaining_route() {
  
  ::bosdyn::api::graph_nav::Route* temp = _impl_.remaining_route_;
  _impl_.remaining_route_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::Route* NavigationFeedbackResponse::unsafe_arena_release_remaining_route() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigationFeedbackResponse.remaining_route)
  
  ::bosdyn::api::graph_nav::Route* temp = _impl_.remaining_route_;
  _impl_.remaining_route_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Route* NavigationFeedbackResponse::_internal_mutable_remaining_route() {
  
  if (_impl_.remaining_route_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Route>(GetArenaForAllocation());
    _impl_.remaining_route_ = p;
  }
  return _impl_.remaining_route_;
}
inline ::bosdyn::api::graph_nav::Route* NavigationFeedbackResponse::mutable_remaining_route() {
  ::bosdyn::api::graph_nav::Route* _msg = _internal_mutable_remaining_route();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigationFeedbackResponse.remaining_route)
  return _msg;
}
inline void NavigationFeedbackResponse::set_allocated_remaining_route(::bosdyn::api::graph_nav::Route* remaining_route) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remaining_route_);
  }
  if (remaining_route) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(remaining_route));
    if (message_arena != submessage_arena) {
      remaining_route = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remaining_route, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remaining_route_ = remaining_route;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigationFeedbackResponse.remaining_route)
}

// uint32 command_id = 4;
inline void NavigationFeedbackResponse::clear_command_id() {
  _impl_.command_id_ = 0u;
}
inline uint32_t NavigationFeedbackResponse::_internal_command_id() const {
  return _impl_.command_id_;
}
inline uint32_t NavigationFeedbackResponse::command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigationFeedbackResponse.command_id)
  return _internal_command_id();
}
inline void NavigationFeedbackResponse::_internal_set_command_id(uint32_t value) {
  
  _impl_.command_id_ = value;
}
inline void NavigationFeedbackResponse::set_command_id(uint32_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigationFeedbackResponse.command_id)
}

// .bosdyn.api.SE3Pose last_ko_tform_goal = 5;
inline bool NavigationFeedbackResponse::_internal_has_last_ko_tform_goal() const {
  return this != internal_default_instance() && _impl_.last_ko_tform_goal_ != nullptr;
}
inline bool NavigationFeedbackResponse::has_last_ko_tform_goal() const {
  return _internal_has_last_ko_tform_goal();
}
inline const ::bosdyn::api::SE3Pose& NavigationFeedbackResponse::_internal_last_ko_tform_goal() const {
  const ::bosdyn::api::SE3Pose* p = _impl_.last_ko_tform_goal_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Pose&>(
      ::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& NavigationFeedbackResponse::last_ko_tform_goal() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigationFeedbackResponse.last_ko_tform_goal)
  return _internal_last_ko_tform_goal();
}
inline void NavigationFeedbackResponse::unsafe_arena_set_allocated_last_ko_tform_goal(
    ::bosdyn::api::SE3Pose* last_ko_tform_goal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_ko_tform_goal_);
  }
  _impl_.last_ko_tform_goal_ = last_ko_tform_goal;
  if (last_ko_tform_goal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.NavigationFeedbackResponse.last_ko_tform_goal)
}
inline ::bosdyn::api::SE3Pose* NavigationFeedbackResponse::release_last_ko_tform_goal() {
  
  ::bosdyn::api::SE3Pose* temp = _impl_.last_ko_tform_goal_;
  _impl_.last_ko_tform_goal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Pose* NavigationFeedbackResponse::unsafe_arena_release_last_ko_tform_goal() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.NavigationFeedbackResponse.last_ko_tform_goal)
  
  ::bosdyn::api::SE3Pose* temp = _impl_.last_ko_tform_goal_;
  _impl_.last_ko_tform_goal_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* NavigationFeedbackResponse::_internal_mutable_last_ko_tform_goal() {
  
  if (_impl_.last_ko_tform_goal_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArenaForAllocation());
    _impl_.last_ko_tform_goal_ = p;
  }
  return _impl_.last_ko_tform_goal_;
}
inline ::bosdyn::api::SE3Pose* NavigationFeedbackResponse::mutable_last_ko_tform_goal() {
  ::bosdyn::api::SE3Pose* _msg = _internal_mutable_last_ko_tform_goal();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.NavigationFeedbackResponse.last_ko_tform_goal)
  return _msg;
}
inline void NavigationFeedbackResponse::set_allocated_last_ko_tform_goal(::bosdyn::api::SE3Pose* last_ko_tform_goal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_ko_tform_goal_);
  }
  if (last_ko_tform_goal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_ko_tform_goal));
    if (message_arena != submessage_arena) {
      last_ko_tform_goal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_ko_tform_goal, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_ko_tform_goal_ = last_ko_tform_goal;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.NavigationFeedbackResponse.last_ko_tform_goal)
}

// .bosdyn.api.SE2TrajectoryCommand.Feedback.BodyMovementStatus body_movement_status = 7;
inline void NavigationFeedbackResponse::clear_body_movement_status() {
  _impl_.body_movement_status_ = 0;
}
inline ::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus NavigationFeedbackResponse::_internal_body_movement_status() const {
  return static_cast< ::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus >(_impl_.body_movement_status_);
}
inline ::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus NavigationFeedbackResponse::body_movement_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigationFeedbackResponse.body_movement_status)
  return _internal_body_movement_status();
}
inline void NavigationFeedbackResponse::_internal_set_body_movement_status(::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus value) {
  
  _impl_.body_movement_status_ = value;
}
inline void NavigationFeedbackResponse::set_body_movement_status(::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus value) {
  _internal_set_body_movement_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigationFeedbackResponse.body_movement_status)
}

// .bosdyn.api.graph_nav.Edge.Annotations.PathFollowingMode path_following_mode = 8;
inline void NavigationFeedbackResponse::clear_path_following_mode() {
  _impl_.path_following_mode_ = 0;
}
inline ::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode NavigationFeedbackResponse::_internal_path_following_mode() const {
  return static_cast< ::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode >(_impl_.path_following_mode_);
}
inline ::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode NavigationFeedbackResponse::path_following_mode() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigationFeedbackResponse.path_following_mode)
  return _internal_path_following_mode();
}
inline void NavigationFeedbackResponse::_internal_set_path_following_mode(::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode value) {
  
  _impl_.path_following_mode_ = value;
}
inline void NavigationFeedbackResponse::set_path_following_mode(::bosdyn::api::graph_nav::Edge_Annotations_PathFollowingMode value) {
  _internal_set_path_following_mode(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigationFeedbackResponse.path_following_mode)
}

// map<string, .bosdyn.api.graph_nav.NavigationFeedbackResponse.ActiveRegionInformation> active_region_information = 10;
inline int NavigationFeedbackResponse::_internal_active_region_information_size() const {
  return _impl_.active_region_information_.size();
}
inline int NavigationFeedbackResponse::active_region_information_size() const {
  return _internal_active_region_information_size();
}
inline void NavigationFeedbackResponse::clear_active_region_information() {
  _impl_.active_region_information_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation >&
NavigationFeedbackResponse::_internal_active_region_information() const {
  return _impl_.active_region_information_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation >&
NavigationFeedbackResponse::active_region_information() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.graph_nav.NavigationFeedbackResponse.active_region_information)
  return _internal_active_region_information();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation >*
NavigationFeedbackResponse::_internal_mutable_active_region_information() {
  return _impl_.active_region_information_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation >*
NavigationFeedbackResponse::mutable_active_region_information() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.graph_nav.NavigationFeedbackResponse.active_region_information)
  return _internal_mutable_active_region_information();
}

// .bosdyn.api.graph_nav.NavigationFeedbackResponse.RouteFollowingStatus route_following_status = 1000;
inline void NavigationFeedbackResponse::clear_route_following_status() {
  _impl_.route_following_status_ = 0;
}
inline ::bosdyn::api::graph_nav::NavigationFeedbackResponse_RouteFollowingStatus NavigationFeedbackResponse::_internal_route_following_status() const {
  return static_cast< ::bosdyn::api::graph_nav::NavigationFeedbackResponse_RouteFollowingStatus >(_impl_.route_following_status_);
}
inline ::bosdyn::api::graph_nav::NavigationFeedbackResponse_RouteFollowingStatus NavigationFeedbackResponse::route_following_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigationFeedbackResponse.route_following_status)
  return _internal_route_following_status();
}
inline void NavigationFeedbackResponse::_internal_set_route_following_status(::bosdyn::api::graph_nav::NavigationFeedbackResponse_RouteFollowingStatus value) {
  
  _impl_.route_following_status_ = value;
}
inline void NavigationFeedbackResponse::set_route_following_status(::bosdyn::api::graph_nav::NavigationFeedbackResponse_RouteFollowingStatus value) {
  _internal_set_route_following_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigationFeedbackResponse.route_following_status)
}

// .bosdyn.api.graph_nav.NavigationFeedbackResponse.BlockageStatus blockage_status = 1001;
inline void NavigationFeedbackResponse::clear_blockage_status() {
  _impl_.blockage_status_ = 0;
}
inline ::bosdyn::api::graph_nav::NavigationFeedbackResponse_BlockageStatus NavigationFeedbackResponse::_internal_blockage_status() const {
  return static_cast< ::bosdyn::api::graph_nav::NavigationFeedbackResponse_BlockageStatus >(_impl_.blockage_status_);
}
inline ::bosdyn::api::graph_nav::NavigationFeedbackResponse_BlockageStatus NavigationFeedbackResponse::blockage_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.NavigationFeedbackResponse.blockage_status)
  return _internal_blockage_status();
}
inline void NavigationFeedbackResponse::_internal_set_blockage_status(::bosdyn::api::graph_nav::NavigationFeedbackResponse_BlockageStatus value) {
  
  _impl_.blockage_status_ = value;
}
inline void NavigationFeedbackResponse::set_blockage_status(::bosdyn::api::graph_nav::NavigationFeedbackResponse_BlockageStatus value) {
  _internal_set_blockage_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.NavigationFeedbackResponse.blockage_status)
}

// -------------------------------------------------------------------

// GetLocalizationStateRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetLocalizationStateRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetLocalizationStateRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetLocalizationStateRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetLocalizationStateRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetLocalizationStateRequest.header)
  return _internal_header();
}
inline void GetLocalizationStateRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.GetLocalizationStateRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetLocalizationStateRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetLocalizationStateRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.GetLocalizationStateRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetLocalizationStateRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* GetLocalizationStateRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.GetLocalizationStateRequest.header)
  return _msg;
}
inline void GetLocalizationStateRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.GetLocalizationStateRequest.header)
}

// string waypoint_id = 8;
inline void GetLocalizationStateRequest::clear_waypoint_id() {
  _impl_.waypoint_id_.ClearToEmpty();
}
inline const std::string& GetLocalizationStateRequest::waypoint_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetLocalizationStateRequest.waypoint_id)
  return _internal_waypoint_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLocalizationStateRequest::set_waypoint_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.waypoint_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.GetLocalizationStateRequest.waypoint_id)
}
inline std::string* GetLocalizationStateRequest::mutable_waypoint_id() {
  std::string* _s = _internal_mutable_waypoint_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.GetLocalizationStateRequest.waypoint_id)
  return _s;
}
inline const std::string& GetLocalizationStateRequest::_internal_waypoint_id() const {
  return _impl_.waypoint_id_.Get();
}
inline void GetLocalizationStateRequest::_internal_set_waypoint_id(const std::string& value) {
  
  _impl_.waypoint_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLocalizationStateRequest::_internal_mutable_waypoint_id() {
  
  return _impl_.waypoint_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLocalizationStateRequest::release_waypoint_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.GetLocalizationStateRequest.waypoint_id)
  return _impl_.waypoint_id_.Release();
}
inline void GetLocalizationStateRequest::set_allocated_waypoint_id(std::string* waypoint_id) {
  if (waypoint_id != nullptr) {
    
  } else {
    
  }
  _impl_.waypoint_id_.SetAllocated(waypoint_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.waypoint_id_.IsDefault()) {
    _impl_.waypoint_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.GetLocalizationStateRequest.waypoint_id)
}

// bool request_live_point_cloud = 2;
inline void GetLocalizationStateRequest::clear_request_live_point_cloud() {
  _impl_.request_live_point_cloud_ = false;
}
inline bool GetLocalizationStateRequest::_internal_request_live_point_cloud() const {
  return _impl_.request_live_point_cloud_;
}
inline bool GetLocalizationStateRequest::request_live_point_cloud() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetLocalizationStateRequest.request_live_point_cloud)
  return _internal_request_live_point_cloud();
}
inline void GetLocalizationStateRequest::_internal_set_request_live_point_cloud(bool value) {
  
  _impl_.request_live_point_cloud_ = value;
}
inline void GetLocalizationStateRequest::set_request_live_point_cloud(bool value) {
  _internal_set_request_live_point_cloud(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.GetLocalizationStateRequest.request_live_point_cloud)
}

// bool request_live_images = 3;
inline void GetLocalizationStateRequest::clear_request_live_images() {
  _impl_.request_live_images_ = false;
}
inline bool GetLocalizationStateRequest::_internal_request_live_images() const {
  return _impl_.request_live_images_;
}
inline bool GetLocalizationStateRequest::request_live_images() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetLocalizationStateRequest.request_live_images)
  return _internal_request_live_images();
}
inline void GetLocalizationStateRequest::_internal_set_request_live_images(bool value) {
  
  _impl_.request_live_images_ = value;
}
inline void GetLocalizationStateRequest::set_request_live_images(bool value) {
  _internal_set_request_live_images(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.GetLocalizationStateRequest.request_live_images)
}

// bool request_live_terrain_maps = 4;
inline void GetLocalizationStateRequest::clear_request_live_terrain_maps() {
  _impl_.request_live_terrain_maps_ = false;
}
inline bool GetLocalizationStateRequest::_internal_request_live_terrain_maps() const {
  return _impl_.request_live_terrain_maps_;
}
inline bool GetLocalizationStateRequest::request_live_terrain_maps() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetLocalizationStateRequest.request_live_terrain_maps)
  return _internal_request_live_terrain_maps();
}
inline void GetLocalizationStateRequest::_internal_set_request_live_terrain_maps(bool value) {
  
  _impl_.request_live_terrain_maps_ = value;
}
inline void GetLocalizationStateRequest::set_request_live_terrain_maps(bool value) {
  _internal_set_request_live_terrain_maps(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.GetLocalizationStateRequest.request_live_terrain_maps)
}

// bool request_live_world_objects = 5;
inline void GetLocalizationStateRequest::clear_request_live_world_objects() {
  _impl_.request_live_world_objects_ = false;
}
inline bool GetLocalizationStateRequest::_internal_request_live_world_objects() const {
  return _impl_.request_live_world_objects_;
}
inline bool GetLocalizationStateRequest::request_live_world_objects() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetLocalizationStateRequest.request_live_world_objects)
  return _internal_request_live_world_objects();
}
inline void GetLocalizationStateRequest::_internal_set_request_live_world_objects(bool value) {
  
  _impl_.request_live_world_objects_ = value;
}
inline void GetLocalizationStateRequest::set_request_live_world_objects(bool value) {
  _internal_set_request_live_world_objects(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.GetLocalizationStateRequest.request_live_world_objects)
}

// bool request_live_robot_state = 6;
inline void GetLocalizationStateRequest::clear_request_live_robot_state() {
  _impl_.request_live_robot_state_ = false;
}
inline bool GetLocalizationStateRequest::_internal_request_live_robot_state() const {
  return _impl_.request_live_robot_state_;
}
inline bool GetLocalizationStateRequest::request_live_robot_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetLocalizationStateRequest.request_live_robot_state)
  return _internal_request_live_robot_state();
}
inline void GetLocalizationStateRequest::_internal_set_request_live_robot_state(bool value) {
  
  _impl_.request_live_robot_state_ = value;
}
inline void GetLocalizationStateRequest::set_request_live_robot_state(bool value) {
  _internal_set_request_live_robot_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.GetLocalizationStateRequest.request_live_robot_state)
}

// bool compress_live_point_cloud = 7;
inline void GetLocalizationStateRequest::clear_compress_live_point_cloud() {
  _impl_.compress_live_point_cloud_ = false;
}
inline bool GetLocalizationStateRequest::_internal_compress_live_point_cloud() const {
  return _impl_.compress_live_point_cloud_;
}
inline bool GetLocalizationStateRequest::compress_live_point_cloud() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetLocalizationStateRequest.compress_live_point_cloud)
  return _internal_compress_live_point_cloud();
}
inline void GetLocalizationStateRequest::_internal_set_compress_live_point_cloud(bool value) {
  
  _impl_.compress_live_point_cloud_ = value;
}
inline void GetLocalizationStateRequest::set_compress_live_point_cloud(bool value) {
  _internal_set_compress_live_point_cloud(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.GetLocalizationStateRequest.compress_live_point_cloud)
}

// -------------------------------------------------------------------

// RemotePointCloudStatus

// string service_name = 1;
inline void RemotePointCloudStatus::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& RemotePointCloudStatus::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.RemotePointCloudStatus.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemotePointCloudStatus::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.RemotePointCloudStatus.service_name)
}
inline std::string* RemotePointCloudStatus::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.RemotePointCloudStatus.service_name)
  return _s;
}
inline const std::string& RemotePointCloudStatus::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void RemotePointCloudStatus::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RemotePointCloudStatus::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RemotePointCloudStatus::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.RemotePointCloudStatus.service_name)
  return _impl_.service_name_.Release();
}
inline void RemotePointCloudStatus::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.RemotePointCloudStatus.service_name)
}

// bool exists_in_directory = 2;
inline void RemotePointCloudStatus::clear_exists_in_directory() {
  _impl_.exists_in_directory_ = false;
}
inline bool RemotePointCloudStatus::_internal_exists_in_directory() const {
  return _impl_.exists_in_directory_;
}
inline bool RemotePointCloudStatus::exists_in_directory() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.RemotePointCloudStatus.exists_in_directory)
  return _internal_exists_in_directory();
}
inline void RemotePointCloudStatus::_internal_set_exists_in_directory(bool value) {
  
  _impl_.exists_in_directory_ = value;
}
inline void RemotePointCloudStatus::set_exists_in_directory(bool value) {
  _internal_set_exists_in_directory(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.RemotePointCloudStatus.exists_in_directory)
}

// bool has_data = 3;
inline void RemotePointCloudStatus::clear_has_data() {
  _impl_.has_data_ = false;
}
inline bool RemotePointCloudStatus::_internal_has_data() const {
  return _impl_.has_data_;
}
inline bool RemotePointCloudStatus::has_data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.RemotePointCloudStatus.has_data)
  return _internal_has_data();
}
inline void RemotePointCloudStatus::_internal_set_has_data(bool value) {
  
  _impl_.has_data_ = value;
}
inline void RemotePointCloudStatus::set_has_data(bool value) {
  _internal_set_has_data(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.RemotePointCloudStatus.has_data)
}

// -------------------------------------------------------------------

// LostDetectorState

// bool is_lost = 1;
inline void LostDetectorState::clear_is_lost() {
  _impl_.is_lost_ = false;
}
inline bool LostDetectorState::_internal_is_lost() const {
  return _impl_.is_lost_;
}
inline bool LostDetectorState::is_lost() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.LostDetectorState.is_lost)
  return _internal_is_lost();
}
inline void LostDetectorState::_internal_set_is_lost(bool value) {
  
  _impl_.is_lost_ = value;
}
inline void LostDetectorState::set_is_lost(bool value) {
  _internal_set_is_lost(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.LostDetectorState.is_lost)
}

// -------------------------------------------------------------------

// GetLocalizationStateResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetLocalizationStateResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetLocalizationStateResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetLocalizationStateResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetLocalizationStateResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetLocalizationStateResponse.header)
  return _internal_header();
}
inline void GetLocalizationStateResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.GetLocalizationStateResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetLocalizationStateResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetLocalizationStateResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.GetLocalizationStateResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetLocalizationStateResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* GetLocalizationStateResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.GetLocalizationStateResponse.header)
  return _msg;
}
inline void GetLocalizationStateResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.GetLocalizationStateResponse.header)
}

// .bosdyn.api.graph_nav.Localization localization = 2;
inline bool GetLocalizationStateResponse::_internal_has_localization() const {
  return this != internal_default_instance() && _impl_.localization_ != nullptr;
}
inline bool GetLocalizationStateResponse::has_localization() const {
  return _internal_has_localization();
}
inline const ::bosdyn::api::graph_nav::Localization& GetLocalizationStateResponse::_internal_localization() const {
  const ::bosdyn::api::graph_nav::Localization* p = _impl_.localization_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::Localization&>(
      ::bosdyn::api::graph_nav::_Localization_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Localization& GetLocalizationStateResponse::localization() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetLocalizationStateResponse.localization)
  return _internal_localization();
}
inline void GetLocalizationStateResponse::unsafe_arena_set_allocated_localization(
    ::bosdyn::api::graph_nav::Localization* localization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.localization_);
  }
  _impl_.localization_ = localization;
  if (localization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.GetLocalizationStateResponse.localization)
}
inline ::bosdyn::api::graph_nav::Localization* GetLocalizationStateResponse::release_localization() {
  
  ::bosdyn::api::graph_nav::Localization* temp = _impl_.localization_;
  _impl_.localization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::Localization* GetLocalizationStateResponse::unsafe_arena_release_localization() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.GetLocalizationStateResponse.localization)
  
  ::bosdyn::api::graph_nav::Localization* temp = _impl_.localization_;
  _impl_.localization_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Localization* GetLocalizationStateResponse::_internal_mutable_localization() {
  
  if (_impl_.localization_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Localization>(GetArenaForAllocation());
    _impl_.localization_ = p;
  }
  return _impl_.localization_;
}
inline ::bosdyn::api::graph_nav::Localization* GetLocalizationStateResponse::mutable_localization() {
  ::bosdyn::api::graph_nav::Localization* _msg = _internal_mutable_localization();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.GetLocalizationStateResponse.localization)
  return _msg;
}
inline void GetLocalizationStateResponse::set_allocated_localization(::bosdyn::api::graph_nav::Localization* localization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.localization_);
  }
  if (localization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(localization));
    if (message_arena != submessage_arena) {
      localization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, localization, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.localization_ = localization;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.GetLocalizationStateResponse.localization)
}

// .bosdyn.api.KinematicState robot_kinematics = 4;
inline bool GetLocalizationStateResponse::_internal_has_robot_kinematics() const {
  return this != internal_default_instance() && _impl_.robot_kinematics_ != nullptr;
}
inline bool GetLocalizationStateResponse::has_robot_kinematics() const {
  return _internal_has_robot_kinematics();
}
inline const ::bosdyn::api::KinematicState& GetLocalizationStateResponse::_internal_robot_kinematics() const {
  const ::bosdyn::api::KinematicState* p = _impl_.robot_kinematics_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::KinematicState&>(
      ::bosdyn::api::_KinematicState_default_instance_);
}
inline const ::bosdyn::api::KinematicState& GetLocalizationStateResponse::robot_kinematics() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetLocalizationStateResponse.robot_kinematics)
  return _internal_robot_kinematics();
}
inline void GetLocalizationStateResponse::unsafe_arena_set_allocated_robot_kinematics(
    ::bosdyn::api::KinematicState* robot_kinematics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_kinematics_);
  }
  _impl_.robot_kinematics_ = robot_kinematics;
  if (robot_kinematics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.GetLocalizationStateResponse.robot_kinematics)
}
inline ::bosdyn::api::KinematicState* GetLocalizationStateResponse::release_robot_kinematics() {
  
  ::bosdyn::api::KinematicState* temp = _impl_.robot_kinematics_;
  _impl_.robot_kinematics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::KinematicState* GetLocalizationStateResponse::unsafe_arena_release_robot_kinematics() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.GetLocalizationStateResponse.robot_kinematics)
  
  ::bosdyn::api::KinematicState* temp = _impl_.robot_kinematics_;
  _impl_.robot_kinematics_ = nullptr;
  return temp;
}
inline ::bosdyn::api::KinematicState* GetLocalizationStateResponse::_internal_mutable_robot_kinematics() {
  
  if (_impl_.robot_kinematics_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::KinematicState>(GetArenaForAllocation());
    _impl_.robot_kinematics_ = p;
  }
  return _impl_.robot_kinematics_;
}
inline ::bosdyn::api::KinematicState* GetLocalizationStateResponse::mutable_robot_kinematics() {
  ::bosdyn::api::KinematicState* _msg = _internal_mutable_robot_kinematics();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.GetLocalizationStateResponse.robot_kinematics)
  return _msg;
}
inline void GetLocalizationStateResponse::set_allocated_robot_kinematics(::bosdyn::api::KinematicState* robot_kinematics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_kinematics_);
  }
  if (robot_kinematics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_kinematics));
    if (message_arena != submessage_arena) {
      robot_kinematics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_kinematics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.robot_kinematics_ = robot_kinematics;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.GetLocalizationStateResponse.robot_kinematics)
}

// repeated .bosdyn.api.graph_nav.RemotePointCloudStatus remote_cloud_status = 5;
inline int GetLocalizationStateResponse::_internal_remote_cloud_status_size() const {
  return _impl_.remote_cloud_status_.size();
}
inline int GetLocalizationStateResponse::remote_cloud_status_size() const {
  return _internal_remote_cloud_status_size();
}
inline void GetLocalizationStateResponse::clear_remote_cloud_status() {
  _impl_.remote_cloud_status_.Clear();
}
inline ::bosdyn::api::graph_nav::RemotePointCloudStatus* GetLocalizationStateResponse::mutable_remote_cloud_status(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.GetLocalizationStateResponse.remote_cloud_status)
  return _impl_.remote_cloud_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::graph_nav::RemotePointCloudStatus >*
GetLocalizationStateResponse::mutable_remote_cloud_status() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.GetLocalizationStateResponse.remote_cloud_status)
  return &_impl_.remote_cloud_status_;
}
inline const ::bosdyn::api::graph_nav::RemotePointCloudStatus& GetLocalizationStateResponse::_internal_remote_cloud_status(int index) const {
  return _impl_.remote_cloud_status_.Get(index);
}
inline const ::bosdyn::api::graph_nav::RemotePointCloudStatus& GetLocalizationStateResponse::remote_cloud_status(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetLocalizationStateResponse.remote_cloud_status)
  return _internal_remote_cloud_status(index);
}
inline ::bosdyn::api::graph_nav::RemotePointCloudStatus* GetLocalizationStateResponse::_internal_add_remote_cloud_status() {
  return _impl_.remote_cloud_status_.Add();
}
inline ::bosdyn::api::graph_nav::RemotePointCloudStatus* GetLocalizationStateResponse::add_remote_cloud_status() {
  ::bosdyn::api::graph_nav::RemotePointCloudStatus* _add = _internal_add_remote_cloud_status();
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.GetLocalizationStateResponse.remote_cloud_status)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::graph_nav::RemotePointCloudStatus >&
GetLocalizationStateResponse::remote_cloud_status() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.GetLocalizationStateResponse.remote_cloud_status)
  return _impl_.remote_cloud_status_;
}

// .bosdyn.api.graph_nav.WaypointSnapshot live_data = 6;
inline bool GetLocalizationStateResponse::_internal_has_live_data() const {
  return this != internal_default_instance() && _impl_.live_data_ != nullptr;
}
inline bool GetLocalizationStateResponse::has_live_data() const {
  return _internal_has_live_data();
}
inline const ::bosdyn::api::graph_nav::WaypointSnapshot& GetLocalizationStateResponse::_internal_live_data() const {
  const ::bosdyn::api::graph_nav::WaypointSnapshot* p = _impl_.live_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::WaypointSnapshot&>(
      ::bosdyn::api::graph_nav::_WaypointSnapshot_default_instance_);
}
inline const ::bosdyn::api::graph_nav::WaypointSnapshot& GetLocalizationStateResponse::live_data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetLocalizationStateResponse.live_data)
  return _internal_live_data();
}
inline void GetLocalizationStateResponse::unsafe_arena_set_allocated_live_data(
    ::bosdyn::api::graph_nav::WaypointSnapshot* live_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.live_data_);
  }
  _impl_.live_data_ = live_data;
  if (live_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.GetLocalizationStateResponse.live_data)
}
inline ::bosdyn::api::graph_nav::WaypointSnapshot* GetLocalizationStateResponse::release_live_data() {
  
  ::bosdyn::api::graph_nav::WaypointSnapshot* temp = _impl_.live_data_;
  _impl_.live_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::WaypointSnapshot* GetLocalizationStateResponse::unsafe_arena_release_live_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.GetLocalizationStateResponse.live_data)
  
  ::bosdyn::api::graph_nav::WaypointSnapshot* temp = _impl_.live_data_;
  _impl_.live_data_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::WaypointSnapshot* GetLocalizationStateResponse::_internal_mutable_live_data() {
  
  if (_impl_.live_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::WaypointSnapshot>(GetArenaForAllocation());
    _impl_.live_data_ = p;
  }
  return _impl_.live_data_;
}
inline ::bosdyn::api::graph_nav::WaypointSnapshot* GetLocalizationStateResponse::mutable_live_data() {
  ::bosdyn::api::graph_nav::WaypointSnapshot* _msg = _internal_mutable_live_data();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.GetLocalizationStateResponse.live_data)
  return _msg;
}
inline void GetLocalizationStateResponse::set_allocated_live_data(::bosdyn::api::graph_nav::WaypointSnapshot* live_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.live_data_);
  }
  if (live_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(live_data));
    if (message_arena != submessage_arena) {
      live_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, live_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.live_data_ = live_data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.GetLocalizationStateResponse.live_data)
}

// .bosdyn.api.graph_nav.LostDetectorState lost_detector_state = 7;
inline bool GetLocalizationStateResponse::_internal_has_lost_detector_state() const {
  return this != internal_default_instance() && _impl_.lost_detector_state_ != nullptr;
}
inline bool GetLocalizationStateResponse::has_lost_detector_state() const {
  return _internal_has_lost_detector_state();
}
inline void GetLocalizationStateResponse::clear_lost_detector_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.lost_detector_state_ != nullptr) {
    delete _impl_.lost_detector_state_;
  }
  _impl_.lost_detector_state_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::LostDetectorState& GetLocalizationStateResponse::_internal_lost_detector_state() const {
  const ::bosdyn::api::graph_nav::LostDetectorState* p = _impl_.lost_detector_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::LostDetectorState&>(
      ::bosdyn::api::graph_nav::_LostDetectorState_default_instance_);
}
inline const ::bosdyn::api::graph_nav::LostDetectorState& GetLocalizationStateResponse::lost_detector_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetLocalizationStateResponse.lost_detector_state)
  return _internal_lost_detector_state();
}
inline void GetLocalizationStateResponse::unsafe_arena_set_allocated_lost_detector_state(
    ::bosdyn::api::graph_nav::LostDetectorState* lost_detector_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lost_detector_state_);
  }
  _impl_.lost_detector_state_ = lost_detector_state;
  if (lost_detector_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.GetLocalizationStateResponse.lost_detector_state)
}
inline ::bosdyn::api::graph_nav::LostDetectorState* GetLocalizationStateResponse::release_lost_detector_state() {
  
  ::bosdyn::api::graph_nav::LostDetectorState* temp = _impl_.lost_detector_state_;
  _impl_.lost_detector_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::LostDetectorState* GetLocalizationStateResponse::unsafe_arena_release_lost_detector_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.GetLocalizationStateResponse.lost_detector_state)
  
  ::bosdyn::api::graph_nav::LostDetectorState* temp = _impl_.lost_detector_state_;
  _impl_.lost_detector_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::LostDetectorState* GetLocalizationStateResponse::_internal_mutable_lost_detector_state() {
  
  if (_impl_.lost_detector_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::LostDetectorState>(GetArenaForAllocation());
    _impl_.lost_detector_state_ = p;
  }
  return _impl_.lost_detector_state_;
}
inline ::bosdyn::api::graph_nav::LostDetectorState* GetLocalizationStateResponse::mutable_lost_detector_state() {
  ::bosdyn::api::graph_nav::LostDetectorState* _msg = _internal_mutable_lost_detector_state();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.GetLocalizationStateResponse.lost_detector_state)
  return _msg;
}
inline void GetLocalizationStateResponse::set_allocated_lost_detector_state(::bosdyn::api::graph_nav::LostDetectorState* lost_detector_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lost_detector_state_;
  }
  if (lost_detector_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lost_detector_state);
    if (message_arena != submessage_arena) {
      lost_detector_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lost_detector_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lost_detector_state_ = lost_detector_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.GetLocalizationStateResponse.lost_detector_state)
}

// -------------------------------------------------------------------

// ClearGraphRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ClearGraphRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ClearGraphRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ClearGraphRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ClearGraphRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.ClearGraphRequest.header)
  return _internal_header();
}
inline void ClearGraphRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.ClearGraphRequest.header)
}
inline ::bosdyn::api::RequestHeader* ClearGraphRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ClearGraphRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.ClearGraphRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ClearGraphRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ClearGraphRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.ClearGraphRequest.header)
  return _msg;
}
inline void ClearGraphRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.ClearGraphRequest.header)
}

// .bosdyn.api.Lease lease = 2;
inline bool ClearGraphRequest::_internal_has_lease() const {
  return this != internal_default_instance() && _impl_.lease_ != nullptr;
}
inline bool ClearGraphRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& ClearGraphRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = _impl_.lease_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Lease&>(
      ::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& ClearGraphRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.ClearGraphRequest.lease)
  return _internal_lease();
}
inline void ClearGraphRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  _impl_.lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.ClearGraphRequest.lease)
}
inline ::bosdyn::api::Lease* ClearGraphRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Lease* ClearGraphRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.ClearGraphRequest.lease)
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* ClearGraphRequest::_internal_mutable_lease() {
  
  if (_impl_.lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArenaForAllocation());
    _impl_.lease_ = p;
  }
  return _impl_.lease_;
}
inline ::bosdyn::api::Lease* ClearGraphRequest::mutable_lease() {
  ::bosdyn::api::Lease* _msg = _internal_mutable_lease();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.ClearGraphRequest.lease)
  return _msg;
}
inline void ClearGraphRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease));
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.ClearGraphRequest.lease)
}

// -------------------------------------------------------------------

// ClearGraphResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ClearGraphResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ClearGraphResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ClearGraphResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ClearGraphResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.ClearGraphResponse.header)
  return _internal_header();
}
inline void ClearGraphResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.ClearGraphResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ClearGraphResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ClearGraphResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.ClearGraphResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ClearGraphResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ClearGraphResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.ClearGraphResponse.header)
  return _msg;
}
inline void ClearGraphResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.ClearGraphResponse.header)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool ClearGraphResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && _impl_.lease_use_result_ != nullptr;
}
inline bool ClearGraphResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& ClearGraphResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = _impl_.lease_use_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::LeaseUseResult&>(
      ::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& ClearGraphResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.ClearGraphResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void ClearGraphResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  _impl_.lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.ClearGraphResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* ClearGraphResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* ClearGraphResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.ClearGraphResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* ClearGraphResponse::_internal_mutable_lease_use_result() {
  
  if (_impl_.lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArenaForAllocation());
    _impl_.lease_use_result_ = p;
  }
  return _impl_.lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* ClearGraphResponse::mutable_lease_use_result() {
  ::bosdyn::api::LeaseUseResult* _msg = _internal_mutable_lease_use_result();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.ClearGraphResponse.lease_use_result)
  return _msg;
}
inline void ClearGraphResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result));
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.ClearGraphResponse.lease_use_result)
}

// .bosdyn.api.graph_nav.ClearGraphResponse.Status status = 3;
inline void ClearGraphResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::graph_nav::ClearGraphResponse_Status ClearGraphResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::ClearGraphResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::graph_nav::ClearGraphResponse_Status ClearGraphResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.ClearGraphResponse.status)
  return _internal_status();
}
inline void ClearGraphResponse::_internal_set_status(::bosdyn::api::graph_nav::ClearGraphResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void ClearGraphResponse::set_status(::bosdyn::api::graph_nav::ClearGraphResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.ClearGraphResponse.status)
}

// -------------------------------------------------------------------

// UploadGraphRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool UploadGraphRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool UploadGraphRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& UploadGraphRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& UploadGraphRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadGraphRequest.header)
  return _internal_header();
}
inline void UploadGraphRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadGraphRequest.header)
}
inline ::bosdyn::api::RequestHeader* UploadGraphRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* UploadGraphRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadGraphRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* UploadGraphRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* UploadGraphRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadGraphRequest.header)
  return _msg;
}
inline void UploadGraphRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadGraphRequest.header)
}

// .bosdyn.api.graph_nav.Graph graph = 2;
inline bool UploadGraphRequest::_internal_has_graph() const {
  return this != internal_default_instance() && _impl_.graph_ != nullptr;
}
inline bool UploadGraphRequest::has_graph() const {
  return _internal_has_graph();
}
inline const ::bosdyn::api::graph_nav::Graph& UploadGraphRequest::_internal_graph() const {
  const ::bosdyn::api::graph_nav::Graph* p = _impl_.graph_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::Graph&>(
      ::bosdyn::api::graph_nav::_Graph_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Graph& UploadGraphRequest::graph() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadGraphRequest.graph)
  return _internal_graph();
}
inline void UploadGraphRequest::unsafe_arena_set_allocated_graph(
    ::bosdyn::api::graph_nav::Graph* graph) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.graph_);
  }
  _impl_.graph_ = graph;
  if (graph) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadGraphRequest.graph)
}
inline ::bosdyn::api::graph_nav::Graph* UploadGraphRequest::release_graph() {
  
  ::bosdyn::api::graph_nav::Graph* temp = _impl_.graph_;
  _impl_.graph_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::Graph* UploadGraphRequest::unsafe_arena_release_graph() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadGraphRequest.graph)
  
  ::bosdyn::api::graph_nav::Graph* temp = _impl_.graph_;
  _impl_.graph_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Graph* UploadGraphRequest::_internal_mutable_graph() {
  
  if (_impl_.graph_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Graph>(GetArenaForAllocation());
    _impl_.graph_ = p;
  }
  return _impl_.graph_;
}
inline ::bosdyn::api::graph_nav::Graph* UploadGraphRequest::mutable_graph() {
  ::bosdyn::api::graph_nav::Graph* _msg = _internal_mutable_graph();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadGraphRequest.graph)
  return _msg;
}
inline void UploadGraphRequest::set_allocated_graph(::bosdyn::api::graph_nav::Graph* graph) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.graph_);
  }
  if (graph) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(graph));
    if (message_arena != submessage_arena) {
      graph = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, graph, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.graph_ = graph;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadGraphRequest.graph)
}

// .bosdyn.api.Lease lease = 3;
inline bool UploadGraphRequest::_internal_has_lease() const {
  return this != internal_default_instance() && _impl_.lease_ != nullptr;
}
inline bool UploadGraphRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& UploadGraphRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = _impl_.lease_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Lease&>(
      ::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& UploadGraphRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadGraphRequest.lease)
  return _internal_lease();
}
inline void UploadGraphRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  _impl_.lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadGraphRequest.lease)
}
inline ::bosdyn::api::Lease* UploadGraphRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Lease* UploadGraphRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadGraphRequest.lease)
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* UploadGraphRequest::_internal_mutable_lease() {
  
  if (_impl_.lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArenaForAllocation());
    _impl_.lease_ = p;
  }
  return _impl_.lease_;
}
inline ::bosdyn::api::Lease* UploadGraphRequest::mutable_lease() {
  ::bosdyn::api::Lease* _msg = _internal_mutable_lease();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadGraphRequest.lease)
  return _msg;
}
inline void UploadGraphRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease));
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadGraphRequest.lease)
}

// bool generate_new_anchoring = 4;
inline void UploadGraphRequest::clear_generate_new_anchoring() {
  _impl_.generate_new_anchoring_ = false;
}
inline bool UploadGraphRequest::_internal_generate_new_anchoring() const {
  return _impl_.generate_new_anchoring_;
}
inline bool UploadGraphRequest::generate_new_anchoring() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadGraphRequest.generate_new_anchoring)
  return _internal_generate_new_anchoring();
}
inline void UploadGraphRequest::_internal_set_generate_new_anchoring(bool value) {
  
  _impl_.generate_new_anchoring_ = value;
}
inline void UploadGraphRequest::set_generate_new_anchoring(bool value) {
  _internal_set_generate_new_anchoring(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UploadGraphRequest.generate_new_anchoring)
}

// -------------------------------------------------------------------

// UploadGraphResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool UploadGraphResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool UploadGraphResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& UploadGraphResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& UploadGraphResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadGraphResponse.header)
  return _internal_header();
}
inline void UploadGraphResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadGraphResponse.header)
}
inline ::bosdyn::api::ResponseHeader* UploadGraphResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* UploadGraphResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadGraphResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* UploadGraphResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* UploadGraphResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadGraphResponse.header)
  return _msg;
}
inline void UploadGraphResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadGraphResponse.header)
}

// .bosdyn.api.graph_nav.UploadGraphResponse.Status status = 8;
inline void UploadGraphResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::graph_nav::UploadGraphResponse_Status UploadGraphResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::UploadGraphResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::graph_nav::UploadGraphResponse_Status UploadGraphResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadGraphResponse.status)
  return _internal_status();
}
inline void UploadGraphResponse::_internal_set_status(::bosdyn::api::graph_nav::UploadGraphResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void UploadGraphResponse::set_status(::bosdyn::api::graph_nav::UploadGraphResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UploadGraphResponse.status)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool UploadGraphResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && _impl_.lease_use_result_ != nullptr;
}
inline bool UploadGraphResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& UploadGraphResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = _impl_.lease_use_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::LeaseUseResult&>(
      ::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& UploadGraphResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadGraphResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void UploadGraphResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  _impl_.lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadGraphResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* UploadGraphResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* UploadGraphResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadGraphResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* UploadGraphResponse::_internal_mutable_lease_use_result() {
  
  if (_impl_.lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArenaForAllocation());
    _impl_.lease_use_result_ = p;
  }
  return _impl_.lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* UploadGraphResponse::mutable_lease_use_result() {
  ::bosdyn::api::LeaseUseResult* _msg = _internal_mutable_lease_use_result();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadGraphResponse.lease_use_result)
  return _msg;
}
inline void UploadGraphResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result));
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadGraphResponse.lease_use_result)
}

// repeated string loaded_waypoint_snapshot_ids = 3;
inline int UploadGraphResponse::_internal_loaded_waypoint_snapshot_ids_size() const {
  return _impl_.loaded_waypoint_snapshot_ids_.size();
}
inline int UploadGraphResponse::loaded_waypoint_snapshot_ids_size() const {
  return _internal_loaded_waypoint_snapshot_ids_size();
}
inline void UploadGraphResponse::clear_loaded_waypoint_snapshot_ids() {
  _impl_.loaded_waypoint_snapshot_ids_.Clear();
}
inline std::string* UploadGraphResponse::add_loaded_waypoint_snapshot_ids() {
  std::string* _s = _internal_add_loaded_waypoint_snapshot_ids();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.graph_nav.UploadGraphResponse.loaded_waypoint_snapshot_ids)
  return _s;
}
inline const std::string& UploadGraphResponse::_internal_loaded_waypoint_snapshot_ids(int index) const {
  return _impl_.loaded_waypoint_snapshot_ids_.Get(index);
}
inline const std::string& UploadGraphResponse::loaded_waypoint_snapshot_ids(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadGraphResponse.loaded_waypoint_snapshot_ids)
  return _internal_loaded_waypoint_snapshot_ids(index);
}
inline std::string* UploadGraphResponse::mutable_loaded_waypoint_snapshot_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadGraphResponse.loaded_waypoint_snapshot_ids)
  return _impl_.loaded_waypoint_snapshot_ids_.Mutable(index);
}
inline void UploadGraphResponse::set_loaded_waypoint_snapshot_ids(int index, const std::string& value) {
  _impl_.loaded_waypoint_snapshot_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UploadGraphResponse.loaded_waypoint_snapshot_ids)
}
inline void UploadGraphResponse::set_loaded_waypoint_snapshot_ids(int index, std::string&& value) {
  _impl_.loaded_waypoint_snapshot_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UploadGraphResponse.loaded_waypoint_snapshot_ids)
}
inline void UploadGraphResponse::set_loaded_waypoint_snapshot_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.loaded_waypoint_snapshot_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.graph_nav.UploadGraphResponse.loaded_waypoint_snapshot_ids)
}
inline void UploadGraphResponse::set_loaded_waypoint_snapshot_ids(int index, const char* value, size_t size) {
  _impl_.loaded_waypoint_snapshot_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.graph_nav.UploadGraphResponse.loaded_waypoint_snapshot_ids)
}
inline std::string* UploadGraphResponse::_internal_add_loaded_waypoint_snapshot_ids() {
  return _impl_.loaded_waypoint_snapshot_ids_.Add();
}
inline void UploadGraphResponse::add_loaded_waypoint_snapshot_ids(const std::string& value) {
  _impl_.loaded_waypoint_snapshot_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.UploadGraphResponse.loaded_waypoint_snapshot_ids)
}
inline void UploadGraphResponse::add_loaded_waypoint_snapshot_ids(std::string&& value) {
  _impl_.loaded_waypoint_snapshot_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.UploadGraphResponse.loaded_waypoint_snapshot_ids)
}
inline void UploadGraphResponse::add_loaded_waypoint_snapshot_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.loaded_waypoint_snapshot_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.graph_nav.UploadGraphResponse.loaded_waypoint_snapshot_ids)
}
inline void UploadGraphResponse::add_loaded_waypoint_snapshot_ids(const char* value, size_t size) {
  _impl_.loaded_waypoint_snapshot_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.graph_nav.UploadGraphResponse.loaded_waypoint_snapshot_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UploadGraphResponse::loaded_waypoint_snapshot_ids() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.UploadGraphResponse.loaded_waypoint_snapshot_ids)
  return _impl_.loaded_waypoint_snapshot_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UploadGraphResponse::mutable_loaded_waypoint_snapshot_ids() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.UploadGraphResponse.loaded_waypoint_snapshot_ids)
  return &_impl_.loaded_waypoint_snapshot_ids_;
}

// repeated string unknown_waypoint_snapshot_ids = 4;
inline int UploadGraphResponse::_internal_unknown_waypoint_snapshot_ids_size() const {
  return _impl_.unknown_waypoint_snapshot_ids_.size();
}
inline int UploadGraphResponse::unknown_waypoint_snapshot_ids_size() const {
  return _internal_unknown_waypoint_snapshot_ids_size();
}
inline void UploadGraphResponse::clear_unknown_waypoint_snapshot_ids() {
  _impl_.unknown_waypoint_snapshot_ids_.Clear();
}
inline std::string* UploadGraphResponse::add_unknown_waypoint_snapshot_ids() {
  std::string* _s = _internal_add_unknown_waypoint_snapshot_ids();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.graph_nav.UploadGraphResponse.unknown_waypoint_snapshot_ids)
  return _s;
}
inline const std::string& UploadGraphResponse::_internal_unknown_waypoint_snapshot_ids(int index) const {
  return _impl_.unknown_waypoint_snapshot_ids_.Get(index);
}
inline const std::string& UploadGraphResponse::unknown_waypoint_snapshot_ids(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadGraphResponse.unknown_waypoint_snapshot_ids)
  return _internal_unknown_waypoint_snapshot_ids(index);
}
inline std::string* UploadGraphResponse::mutable_unknown_waypoint_snapshot_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadGraphResponse.unknown_waypoint_snapshot_ids)
  return _impl_.unknown_waypoint_snapshot_ids_.Mutable(index);
}
inline void UploadGraphResponse::set_unknown_waypoint_snapshot_ids(int index, const std::string& value) {
  _impl_.unknown_waypoint_snapshot_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UploadGraphResponse.unknown_waypoint_snapshot_ids)
}
inline void UploadGraphResponse::set_unknown_waypoint_snapshot_ids(int index, std::string&& value) {
  _impl_.unknown_waypoint_snapshot_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UploadGraphResponse.unknown_waypoint_snapshot_ids)
}
inline void UploadGraphResponse::set_unknown_waypoint_snapshot_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.unknown_waypoint_snapshot_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.graph_nav.UploadGraphResponse.unknown_waypoint_snapshot_ids)
}
inline void UploadGraphResponse::set_unknown_waypoint_snapshot_ids(int index, const char* value, size_t size) {
  _impl_.unknown_waypoint_snapshot_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.graph_nav.UploadGraphResponse.unknown_waypoint_snapshot_ids)
}
inline std::string* UploadGraphResponse::_internal_add_unknown_waypoint_snapshot_ids() {
  return _impl_.unknown_waypoint_snapshot_ids_.Add();
}
inline void UploadGraphResponse::add_unknown_waypoint_snapshot_ids(const std::string& value) {
  _impl_.unknown_waypoint_snapshot_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.UploadGraphResponse.unknown_waypoint_snapshot_ids)
}
inline void UploadGraphResponse::add_unknown_waypoint_snapshot_ids(std::string&& value) {
  _impl_.unknown_waypoint_snapshot_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.UploadGraphResponse.unknown_waypoint_snapshot_ids)
}
inline void UploadGraphResponse::add_unknown_waypoint_snapshot_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.unknown_waypoint_snapshot_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.graph_nav.UploadGraphResponse.unknown_waypoint_snapshot_ids)
}
inline void UploadGraphResponse::add_unknown_waypoint_snapshot_ids(const char* value, size_t size) {
  _impl_.unknown_waypoint_snapshot_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.graph_nav.UploadGraphResponse.unknown_waypoint_snapshot_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UploadGraphResponse::unknown_waypoint_snapshot_ids() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.UploadGraphResponse.unknown_waypoint_snapshot_ids)
  return _impl_.unknown_waypoint_snapshot_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UploadGraphResponse::mutable_unknown_waypoint_snapshot_ids() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.UploadGraphResponse.unknown_waypoint_snapshot_ids)
  return &_impl_.unknown_waypoint_snapshot_ids_;
}

// repeated string loaded_edge_snapshot_ids = 5;
inline int UploadGraphResponse::_internal_loaded_edge_snapshot_ids_size() const {
  return _impl_.loaded_edge_snapshot_ids_.size();
}
inline int UploadGraphResponse::loaded_edge_snapshot_ids_size() const {
  return _internal_loaded_edge_snapshot_ids_size();
}
inline void UploadGraphResponse::clear_loaded_edge_snapshot_ids() {
  _impl_.loaded_edge_snapshot_ids_.Clear();
}
inline std::string* UploadGraphResponse::add_loaded_edge_snapshot_ids() {
  std::string* _s = _internal_add_loaded_edge_snapshot_ids();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.graph_nav.UploadGraphResponse.loaded_edge_snapshot_ids)
  return _s;
}
inline const std::string& UploadGraphResponse::_internal_loaded_edge_snapshot_ids(int index) const {
  return _impl_.loaded_edge_snapshot_ids_.Get(index);
}
inline const std::string& UploadGraphResponse::loaded_edge_snapshot_ids(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadGraphResponse.loaded_edge_snapshot_ids)
  return _internal_loaded_edge_snapshot_ids(index);
}
inline std::string* UploadGraphResponse::mutable_loaded_edge_snapshot_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadGraphResponse.loaded_edge_snapshot_ids)
  return _impl_.loaded_edge_snapshot_ids_.Mutable(index);
}
inline void UploadGraphResponse::set_loaded_edge_snapshot_ids(int index, const std::string& value) {
  _impl_.loaded_edge_snapshot_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UploadGraphResponse.loaded_edge_snapshot_ids)
}
inline void UploadGraphResponse::set_loaded_edge_snapshot_ids(int index, std::string&& value) {
  _impl_.loaded_edge_snapshot_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UploadGraphResponse.loaded_edge_snapshot_ids)
}
inline void UploadGraphResponse::set_loaded_edge_snapshot_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.loaded_edge_snapshot_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.graph_nav.UploadGraphResponse.loaded_edge_snapshot_ids)
}
inline void UploadGraphResponse::set_loaded_edge_snapshot_ids(int index, const char* value, size_t size) {
  _impl_.loaded_edge_snapshot_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.graph_nav.UploadGraphResponse.loaded_edge_snapshot_ids)
}
inline std::string* UploadGraphResponse::_internal_add_loaded_edge_snapshot_ids() {
  return _impl_.loaded_edge_snapshot_ids_.Add();
}
inline void UploadGraphResponse::add_loaded_edge_snapshot_ids(const std::string& value) {
  _impl_.loaded_edge_snapshot_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.UploadGraphResponse.loaded_edge_snapshot_ids)
}
inline void UploadGraphResponse::add_loaded_edge_snapshot_ids(std::string&& value) {
  _impl_.loaded_edge_snapshot_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.UploadGraphResponse.loaded_edge_snapshot_ids)
}
inline void UploadGraphResponse::add_loaded_edge_snapshot_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.loaded_edge_snapshot_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.graph_nav.UploadGraphResponse.loaded_edge_snapshot_ids)
}
inline void UploadGraphResponse::add_loaded_edge_snapshot_ids(const char* value, size_t size) {
  _impl_.loaded_edge_snapshot_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.graph_nav.UploadGraphResponse.loaded_edge_snapshot_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UploadGraphResponse::loaded_edge_snapshot_ids() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.UploadGraphResponse.loaded_edge_snapshot_ids)
  return _impl_.loaded_edge_snapshot_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UploadGraphResponse::mutable_loaded_edge_snapshot_ids() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.UploadGraphResponse.loaded_edge_snapshot_ids)
  return &_impl_.loaded_edge_snapshot_ids_;
}

// repeated string unknown_edge_snapshot_ids = 6;
inline int UploadGraphResponse::_internal_unknown_edge_snapshot_ids_size() const {
  return _impl_.unknown_edge_snapshot_ids_.size();
}
inline int UploadGraphResponse::unknown_edge_snapshot_ids_size() const {
  return _internal_unknown_edge_snapshot_ids_size();
}
inline void UploadGraphResponse::clear_unknown_edge_snapshot_ids() {
  _impl_.unknown_edge_snapshot_ids_.Clear();
}
inline std::string* UploadGraphResponse::add_unknown_edge_snapshot_ids() {
  std::string* _s = _internal_add_unknown_edge_snapshot_ids();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.graph_nav.UploadGraphResponse.unknown_edge_snapshot_ids)
  return _s;
}
inline const std::string& UploadGraphResponse::_internal_unknown_edge_snapshot_ids(int index) const {
  return _impl_.unknown_edge_snapshot_ids_.Get(index);
}
inline const std::string& UploadGraphResponse::unknown_edge_snapshot_ids(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadGraphResponse.unknown_edge_snapshot_ids)
  return _internal_unknown_edge_snapshot_ids(index);
}
inline std::string* UploadGraphResponse::mutable_unknown_edge_snapshot_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadGraphResponse.unknown_edge_snapshot_ids)
  return _impl_.unknown_edge_snapshot_ids_.Mutable(index);
}
inline void UploadGraphResponse::set_unknown_edge_snapshot_ids(int index, const std::string& value) {
  _impl_.unknown_edge_snapshot_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UploadGraphResponse.unknown_edge_snapshot_ids)
}
inline void UploadGraphResponse::set_unknown_edge_snapshot_ids(int index, std::string&& value) {
  _impl_.unknown_edge_snapshot_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UploadGraphResponse.unknown_edge_snapshot_ids)
}
inline void UploadGraphResponse::set_unknown_edge_snapshot_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.unknown_edge_snapshot_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.graph_nav.UploadGraphResponse.unknown_edge_snapshot_ids)
}
inline void UploadGraphResponse::set_unknown_edge_snapshot_ids(int index, const char* value, size_t size) {
  _impl_.unknown_edge_snapshot_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.graph_nav.UploadGraphResponse.unknown_edge_snapshot_ids)
}
inline std::string* UploadGraphResponse::_internal_add_unknown_edge_snapshot_ids() {
  return _impl_.unknown_edge_snapshot_ids_.Add();
}
inline void UploadGraphResponse::add_unknown_edge_snapshot_ids(const std::string& value) {
  _impl_.unknown_edge_snapshot_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.UploadGraphResponse.unknown_edge_snapshot_ids)
}
inline void UploadGraphResponse::add_unknown_edge_snapshot_ids(std::string&& value) {
  _impl_.unknown_edge_snapshot_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.UploadGraphResponse.unknown_edge_snapshot_ids)
}
inline void UploadGraphResponse::add_unknown_edge_snapshot_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.unknown_edge_snapshot_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.graph_nav.UploadGraphResponse.unknown_edge_snapshot_ids)
}
inline void UploadGraphResponse::add_unknown_edge_snapshot_ids(const char* value, size_t size) {
  _impl_.unknown_edge_snapshot_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.graph_nav.UploadGraphResponse.unknown_edge_snapshot_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UploadGraphResponse::unknown_edge_snapshot_ids() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.UploadGraphResponse.unknown_edge_snapshot_ids)
  return _impl_.unknown_edge_snapshot_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UploadGraphResponse::mutable_unknown_edge_snapshot_ids() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.UploadGraphResponse.unknown_edge_snapshot_ids)
  return &_impl_.unknown_edge_snapshot_ids_;
}

// .bosdyn.api.LicenseInfo.Status license_status = 7;
inline void UploadGraphResponse::clear_license_status() {
  _impl_.license_status_ = 0;
}
inline ::bosdyn::api::LicenseInfo_Status UploadGraphResponse::_internal_license_status() const {
  return static_cast< ::bosdyn::api::LicenseInfo_Status >(_impl_.license_status_);
}
inline ::bosdyn::api::LicenseInfo_Status UploadGraphResponse::license_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadGraphResponse.license_status)
  return _internal_license_status();
}
inline void UploadGraphResponse::_internal_set_license_status(::bosdyn::api::LicenseInfo_Status value) {
  
  _impl_.license_status_ = value;
}
inline void UploadGraphResponse::set_license_status(::bosdyn::api::LicenseInfo_Status value) {
  _internal_set_license_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UploadGraphResponse.license_status)
}

// .bosdyn.api.graph_nav.SensorCompatibilityStatus sensor_status = 9;
inline bool UploadGraphResponse::_internal_has_sensor_status() const {
  return this != internal_default_instance() && _impl_.sensor_status_ != nullptr;
}
inline bool UploadGraphResponse::has_sensor_status() const {
  return _internal_has_sensor_status();
}
inline void UploadGraphResponse::clear_sensor_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.sensor_status_ != nullptr) {
    delete _impl_.sensor_status_;
  }
  _impl_.sensor_status_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::SensorCompatibilityStatus& UploadGraphResponse::_internal_sensor_status() const {
  const ::bosdyn::api::graph_nav::SensorCompatibilityStatus* p = _impl_.sensor_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::SensorCompatibilityStatus&>(
      ::bosdyn::api::graph_nav::_SensorCompatibilityStatus_default_instance_);
}
inline const ::bosdyn::api::graph_nav::SensorCompatibilityStatus& UploadGraphResponse::sensor_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadGraphResponse.sensor_status)
  return _internal_sensor_status();
}
inline void UploadGraphResponse::unsafe_arena_set_allocated_sensor_status(
    ::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sensor_status_);
  }
  _impl_.sensor_status_ = sensor_status;
  if (sensor_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadGraphResponse.sensor_status)
}
inline ::bosdyn::api::graph_nav::SensorCompatibilityStatus* UploadGraphResponse::release_sensor_status() {
  
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* temp = _impl_.sensor_status_;
  _impl_.sensor_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::SensorCompatibilityStatus* UploadGraphResponse::unsafe_arena_release_sensor_status() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadGraphResponse.sensor_status)
  
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* temp = _impl_.sensor_status_;
  _impl_.sensor_status_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::SensorCompatibilityStatus* UploadGraphResponse::_internal_mutable_sensor_status() {
  
  if (_impl_.sensor_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::SensorCompatibilityStatus>(GetArenaForAllocation());
    _impl_.sensor_status_ = p;
  }
  return _impl_.sensor_status_;
}
inline ::bosdyn::api::graph_nav::SensorCompatibilityStatus* UploadGraphResponse::mutable_sensor_status() {
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* _msg = _internal_mutable_sensor_status();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadGraphResponse.sensor_status)
  return _msg;
}
inline void UploadGraphResponse::set_allocated_sensor_status(::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sensor_status_;
  }
  if (sensor_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sensor_status);
    if (message_arena != submessage_arena) {
      sensor_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sensor_status_ = sensor_status;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadGraphResponse.sensor_status)
}

// .bosdyn.api.graph_nav.AreaCallbackServiceError area_callback_error = 10;
inline bool UploadGraphResponse::_internal_has_area_callback_error() const {
  return this != internal_default_instance() && _impl_.area_callback_error_ != nullptr;
}
inline bool UploadGraphResponse::has_area_callback_error() const {
  return _internal_has_area_callback_error();
}
inline void UploadGraphResponse::clear_area_callback_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.area_callback_error_ != nullptr) {
    delete _impl_.area_callback_error_;
  }
  _impl_.area_callback_error_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::AreaCallbackServiceError& UploadGraphResponse::_internal_area_callback_error() const {
  const ::bosdyn::api::graph_nav::AreaCallbackServiceError* p = _impl_.area_callback_error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::AreaCallbackServiceError&>(
      ::bosdyn::api::graph_nav::_AreaCallbackServiceError_default_instance_);
}
inline const ::bosdyn::api::graph_nav::AreaCallbackServiceError& UploadGraphResponse::area_callback_error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadGraphResponse.area_callback_error)
  return _internal_area_callback_error();
}
inline void UploadGraphResponse::unsafe_arena_set_allocated_area_callback_error(
    ::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.area_callback_error_);
  }
  _impl_.area_callback_error_ = area_callback_error;
  if (area_callback_error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadGraphResponse.area_callback_error)
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* UploadGraphResponse::release_area_callback_error() {
  
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* temp = _impl_.area_callback_error_;
  _impl_.area_callback_error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* UploadGraphResponse::unsafe_arena_release_area_callback_error() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadGraphResponse.area_callback_error)
  
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* temp = _impl_.area_callback_error_;
  _impl_.area_callback_error_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* UploadGraphResponse::_internal_mutable_area_callback_error() {
  
  if (_impl_.area_callback_error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::AreaCallbackServiceError>(GetArenaForAllocation());
    _impl_.area_callback_error_ = p;
  }
  return _impl_.area_callback_error_;
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* UploadGraphResponse::mutable_area_callback_error() {
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* _msg = _internal_mutable_area_callback_error();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadGraphResponse.area_callback_error)
  return _msg;
}
inline void UploadGraphResponse::set_allocated_area_callback_error(::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.area_callback_error_;
  }
  if (area_callback_error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(area_callback_error);
    if (message_arena != submessage_arena) {
      area_callback_error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, area_callback_error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.area_callback_error_ = area_callback_error;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadGraphResponse.area_callback_error)
}

// -------------------------------------------------------------------

// DownloadGraphRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool DownloadGraphRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DownloadGraphRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& DownloadGraphRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& DownloadGraphRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadGraphRequest.header)
  return _internal_header();
}
inline void DownloadGraphRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.DownloadGraphRequest.header)
}
inline ::bosdyn::api::RequestHeader* DownloadGraphRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* DownloadGraphRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.DownloadGraphRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* DownloadGraphRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* DownloadGraphRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.DownloadGraphRequest.header)
  return _msg;
}
inline void DownloadGraphRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.DownloadGraphRequest.header)
}

// -------------------------------------------------------------------

// DownloadGraphResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool DownloadGraphResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DownloadGraphResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& DownloadGraphResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& DownloadGraphResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadGraphResponse.header)
  return _internal_header();
}
inline void DownloadGraphResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.DownloadGraphResponse.header)
}
inline ::bosdyn::api::ResponseHeader* DownloadGraphResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DownloadGraphResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.DownloadGraphResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DownloadGraphResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* DownloadGraphResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.DownloadGraphResponse.header)
  return _msg;
}
inline void DownloadGraphResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.DownloadGraphResponse.header)
}

// .bosdyn.api.graph_nav.Graph graph = 2;
inline bool DownloadGraphResponse::_internal_has_graph() const {
  return this != internal_default_instance() && _impl_.graph_ != nullptr;
}
inline bool DownloadGraphResponse::has_graph() const {
  return _internal_has_graph();
}
inline const ::bosdyn::api::graph_nav::Graph& DownloadGraphResponse::_internal_graph() const {
  const ::bosdyn::api::graph_nav::Graph* p = _impl_.graph_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::Graph&>(
      ::bosdyn::api::graph_nav::_Graph_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Graph& DownloadGraphResponse::graph() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadGraphResponse.graph)
  return _internal_graph();
}
inline void DownloadGraphResponse::unsafe_arena_set_allocated_graph(
    ::bosdyn::api::graph_nav::Graph* graph) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.graph_);
  }
  _impl_.graph_ = graph;
  if (graph) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.DownloadGraphResponse.graph)
}
inline ::bosdyn::api::graph_nav::Graph* DownloadGraphResponse::release_graph() {
  
  ::bosdyn::api::graph_nav::Graph* temp = _impl_.graph_;
  _impl_.graph_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::Graph* DownloadGraphResponse::unsafe_arena_release_graph() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.DownloadGraphResponse.graph)
  
  ::bosdyn::api::graph_nav::Graph* temp = _impl_.graph_;
  _impl_.graph_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Graph* DownloadGraphResponse::_internal_mutable_graph() {
  
  if (_impl_.graph_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Graph>(GetArenaForAllocation());
    _impl_.graph_ = p;
  }
  return _impl_.graph_;
}
inline ::bosdyn::api::graph_nav::Graph* DownloadGraphResponse::mutable_graph() {
  ::bosdyn::api::graph_nav::Graph* _msg = _internal_mutable_graph();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.DownloadGraphResponse.graph)
  return _msg;
}
inline void DownloadGraphResponse::set_allocated_graph(::bosdyn::api::graph_nav::Graph* graph) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.graph_);
  }
  if (graph) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(graph));
    if (message_arena != submessage_arena) {
      graph = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, graph, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.graph_ = graph;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.DownloadGraphResponse.graph)
}

// -------------------------------------------------------------------

// UploadWaypointSnapshotRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool UploadWaypointSnapshotRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool UploadWaypointSnapshotRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& UploadWaypointSnapshotRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& UploadWaypointSnapshotRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest.header)
  return _internal_header();
}
inline void UploadWaypointSnapshotRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest.header)
}
inline ::bosdyn::api::RequestHeader* UploadWaypointSnapshotRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* UploadWaypointSnapshotRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* UploadWaypointSnapshotRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* UploadWaypointSnapshotRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest.header)
  return _msg;
}
inline void UploadWaypointSnapshotRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest.header)
}

// .bosdyn.api.DataChunk chunk = 3;
inline bool UploadWaypointSnapshotRequest::_internal_has_chunk() const {
  return this != internal_default_instance() && _impl_.chunk_ != nullptr;
}
inline bool UploadWaypointSnapshotRequest::has_chunk() const {
  return _internal_has_chunk();
}
inline const ::bosdyn::api::DataChunk& UploadWaypointSnapshotRequest::_internal_chunk() const {
  const ::bosdyn::api::DataChunk* p = _impl_.chunk_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataChunk&>(
      ::bosdyn::api::_DataChunk_default_instance_);
}
inline const ::bosdyn::api::DataChunk& UploadWaypointSnapshotRequest::chunk() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest.chunk)
  return _internal_chunk();
}
inline void UploadWaypointSnapshotRequest::unsafe_arena_set_allocated_chunk(
    ::bosdyn::api::DataChunk* chunk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chunk_);
  }
  _impl_.chunk_ = chunk;
  if (chunk) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest.chunk)
}
inline ::bosdyn::api::DataChunk* UploadWaypointSnapshotRequest::release_chunk() {
  
  ::bosdyn::api::DataChunk* temp = _impl_.chunk_;
  _impl_.chunk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataChunk* UploadWaypointSnapshotRequest::unsafe_arena_release_chunk() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest.chunk)
  
  ::bosdyn::api::DataChunk* temp = _impl_.chunk_;
  _impl_.chunk_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataChunk* UploadWaypointSnapshotRequest::_internal_mutable_chunk() {
  
  if (_impl_.chunk_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataChunk>(GetArenaForAllocation());
    _impl_.chunk_ = p;
  }
  return _impl_.chunk_;
}
inline ::bosdyn::api::DataChunk* UploadWaypointSnapshotRequest::mutable_chunk() {
  ::bosdyn::api::DataChunk* _msg = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest.chunk)
  return _msg;
}
inline void UploadWaypointSnapshotRequest::set_allocated_chunk(::bosdyn::api::DataChunk* chunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chunk_);
  }
  if (chunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chunk));
    if (message_arena != submessage_arena) {
      chunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chunk, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chunk_ = chunk;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest.chunk)
}

// .bosdyn.api.Lease lease = 4;
inline bool UploadWaypointSnapshotRequest::_internal_has_lease() const {
  return this != internal_default_instance() && _impl_.lease_ != nullptr;
}
inline bool UploadWaypointSnapshotRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& UploadWaypointSnapshotRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = _impl_.lease_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Lease&>(
      ::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& UploadWaypointSnapshotRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest.lease)
  return _internal_lease();
}
inline void UploadWaypointSnapshotRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  _impl_.lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest.lease)
}
inline ::bosdyn::api::Lease* UploadWaypointSnapshotRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Lease* UploadWaypointSnapshotRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest.lease)
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* UploadWaypointSnapshotRequest::_internal_mutable_lease() {
  
  if (_impl_.lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArenaForAllocation());
    _impl_.lease_ = p;
  }
  return _impl_.lease_;
}
inline ::bosdyn::api::Lease* UploadWaypointSnapshotRequest::mutable_lease() {
  ::bosdyn::api::Lease* _msg = _internal_mutable_lease();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest.lease)
  return _msg;
}
inline void UploadWaypointSnapshotRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease));
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadWaypointSnapshotRequest.lease)
}

// -------------------------------------------------------------------

// UploadWaypointSnapshotResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool UploadWaypointSnapshotResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool UploadWaypointSnapshotResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& UploadWaypointSnapshotResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& UploadWaypointSnapshotResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.header)
  return _internal_header();
}
inline void UploadWaypointSnapshotResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.header)
}
inline ::bosdyn::api::ResponseHeader* UploadWaypointSnapshotResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* UploadWaypointSnapshotResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* UploadWaypointSnapshotResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* UploadWaypointSnapshotResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.header)
  return _msg;
}
inline void UploadWaypointSnapshotResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.header)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool UploadWaypointSnapshotResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && _impl_.lease_use_result_ != nullptr;
}
inline bool UploadWaypointSnapshotResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& UploadWaypointSnapshotResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = _impl_.lease_use_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::LeaseUseResult&>(
      ::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& UploadWaypointSnapshotResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void UploadWaypointSnapshotResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  _impl_.lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* UploadWaypointSnapshotResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* UploadWaypointSnapshotResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* UploadWaypointSnapshotResponse::_internal_mutable_lease_use_result() {
  
  if (_impl_.lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArenaForAllocation());
    _impl_.lease_use_result_ = p;
  }
  return _impl_.lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* UploadWaypointSnapshotResponse::mutable_lease_use_result() {
  ::bosdyn::api::LeaseUseResult* _msg = _internal_mutable_lease_use_result();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.lease_use_result)
  return _msg;
}
inline void UploadWaypointSnapshotResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result));
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.lease_use_result)
}

// .bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.Status status = 3;
inline void UploadWaypointSnapshotResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::graph_nav::UploadWaypointSnapshotResponse_Status UploadWaypointSnapshotResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::UploadWaypointSnapshotResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::graph_nav::UploadWaypointSnapshotResponse_Status UploadWaypointSnapshotResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.status)
  return _internal_status();
}
inline void UploadWaypointSnapshotResponse::_internal_set_status(::bosdyn::api::graph_nav::UploadWaypointSnapshotResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void UploadWaypointSnapshotResponse::set_status(::bosdyn::api::graph_nav::UploadWaypointSnapshotResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.status)
}

// .bosdyn.api.graph_nav.SensorCompatibilityStatus sensor_status = 4;
inline bool UploadWaypointSnapshotResponse::_internal_has_sensor_status() const {
  return this != internal_default_instance() && _impl_.sensor_status_ != nullptr;
}
inline bool UploadWaypointSnapshotResponse::has_sensor_status() const {
  return _internal_has_sensor_status();
}
inline void UploadWaypointSnapshotResponse::clear_sensor_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.sensor_status_ != nullptr) {
    delete _impl_.sensor_status_;
  }
  _impl_.sensor_status_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::SensorCompatibilityStatus& UploadWaypointSnapshotResponse::_internal_sensor_status() const {
  const ::bosdyn::api::graph_nav::SensorCompatibilityStatus* p = _impl_.sensor_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::SensorCompatibilityStatus&>(
      ::bosdyn::api::graph_nav::_SensorCompatibilityStatus_default_instance_);
}
inline const ::bosdyn::api::graph_nav::SensorCompatibilityStatus& UploadWaypointSnapshotResponse::sensor_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.sensor_status)
  return _internal_sensor_status();
}
inline void UploadWaypointSnapshotResponse::unsafe_arena_set_allocated_sensor_status(
    ::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sensor_status_);
  }
  _impl_.sensor_status_ = sensor_status;
  if (sensor_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.sensor_status)
}
inline ::bosdyn::api::graph_nav::SensorCompatibilityStatus* UploadWaypointSnapshotResponse::release_sensor_status() {
  
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* temp = _impl_.sensor_status_;
  _impl_.sensor_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::SensorCompatibilityStatus* UploadWaypointSnapshotResponse::unsafe_arena_release_sensor_status() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.sensor_status)
  
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* temp = _impl_.sensor_status_;
  _impl_.sensor_status_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::SensorCompatibilityStatus* UploadWaypointSnapshotResponse::_internal_mutable_sensor_status() {
  
  if (_impl_.sensor_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::SensorCompatibilityStatus>(GetArenaForAllocation());
    _impl_.sensor_status_ = p;
  }
  return _impl_.sensor_status_;
}
inline ::bosdyn::api::graph_nav::SensorCompatibilityStatus* UploadWaypointSnapshotResponse::mutable_sensor_status() {
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* _msg = _internal_mutable_sensor_status();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.sensor_status)
  return _msg;
}
inline void UploadWaypointSnapshotResponse::set_allocated_sensor_status(::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sensor_status_;
  }
  if (sensor_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sensor_status);
    if (message_arena != submessage_arena) {
      sensor_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sensor_status_ = sensor_status;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadWaypointSnapshotResponse.sensor_status)
}

// -------------------------------------------------------------------

// UploadEdgeSnapshotRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool UploadEdgeSnapshotRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool UploadEdgeSnapshotRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& UploadEdgeSnapshotRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& UploadEdgeSnapshotRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest.header)
  return _internal_header();
}
inline void UploadEdgeSnapshotRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest.header)
}
inline ::bosdyn::api::RequestHeader* UploadEdgeSnapshotRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* UploadEdgeSnapshotRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* UploadEdgeSnapshotRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* UploadEdgeSnapshotRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest.header)
  return _msg;
}
inline void UploadEdgeSnapshotRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest.header)
}

// .bosdyn.api.DataChunk chunk = 4;
inline bool UploadEdgeSnapshotRequest::_internal_has_chunk() const {
  return this != internal_default_instance() && _impl_.chunk_ != nullptr;
}
inline bool UploadEdgeSnapshotRequest::has_chunk() const {
  return _internal_has_chunk();
}
inline const ::bosdyn::api::DataChunk& UploadEdgeSnapshotRequest::_internal_chunk() const {
  const ::bosdyn::api::DataChunk* p = _impl_.chunk_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataChunk&>(
      ::bosdyn::api::_DataChunk_default_instance_);
}
inline const ::bosdyn::api::DataChunk& UploadEdgeSnapshotRequest::chunk() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest.chunk)
  return _internal_chunk();
}
inline void UploadEdgeSnapshotRequest::unsafe_arena_set_allocated_chunk(
    ::bosdyn::api::DataChunk* chunk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chunk_);
  }
  _impl_.chunk_ = chunk;
  if (chunk) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest.chunk)
}
inline ::bosdyn::api::DataChunk* UploadEdgeSnapshotRequest::release_chunk() {
  
  ::bosdyn::api::DataChunk* temp = _impl_.chunk_;
  _impl_.chunk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataChunk* UploadEdgeSnapshotRequest::unsafe_arena_release_chunk() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest.chunk)
  
  ::bosdyn::api::DataChunk* temp = _impl_.chunk_;
  _impl_.chunk_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataChunk* UploadEdgeSnapshotRequest::_internal_mutable_chunk() {
  
  if (_impl_.chunk_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataChunk>(GetArenaForAllocation());
    _impl_.chunk_ = p;
  }
  return _impl_.chunk_;
}
inline ::bosdyn::api::DataChunk* UploadEdgeSnapshotRequest::mutable_chunk() {
  ::bosdyn::api::DataChunk* _msg = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest.chunk)
  return _msg;
}
inline void UploadEdgeSnapshotRequest::set_allocated_chunk(::bosdyn::api::DataChunk* chunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chunk_);
  }
  if (chunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chunk));
    if (message_arena != submessage_arena) {
      chunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chunk, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chunk_ = chunk;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest.chunk)
}

// .bosdyn.api.Lease lease = 5;
inline bool UploadEdgeSnapshotRequest::_internal_has_lease() const {
  return this != internal_default_instance() && _impl_.lease_ != nullptr;
}
inline bool UploadEdgeSnapshotRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& UploadEdgeSnapshotRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = _impl_.lease_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Lease&>(
      ::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& UploadEdgeSnapshotRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest.lease)
  return _internal_lease();
}
inline void UploadEdgeSnapshotRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  _impl_.lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest.lease)
}
inline ::bosdyn::api::Lease* UploadEdgeSnapshotRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Lease* UploadEdgeSnapshotRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest.lease)
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* UploadEdgeSnapshotRequest::_internal_mutable_lease() {
  
  if (_impl_.lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArenaForAllocation());
    _impl_.lease_ = p;
  }
  return _impl_.lease_;
}
inline ::bosdyn::api::Lease* UploadEdgeSnapshotRequest::mutable_lease() {
  ::bosdyn::api::Lease* _msg = _internal_mutable_lease();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest.lease)
  return _msg;
}
inline void UploadEdgeSnapshotRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease));
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadEdgeSnapshotRequest.lease)
}

// -------------------------------------------------------------------

// UploadEdgeSnapshotResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool UploadEdgeSnapshotResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool UploadEdgeSnapshotResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& UploadEdgeSnapshotResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& UploadEdgeSnapshotResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadEdgeSnapshotResponse.header)
  return _internal_header();
}
inline void UploadEdgeSnapshotResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadEdgeSnapshotResponse.header)
}
inline ::bosdyn::api::ResponseHeader* UploadEdgeSnapshotResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* UploadEdgeSnapshotResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadEdgeSnapshotResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* UploadEdgeSnapshotResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* UploadEdgeSnapshotResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadEdgeSnapshotResponse.header)
  return _msg;
}
inline void UploadEdgeSnapshotResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadEdgeSnapshotResponse.header)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool UploadEdgeSnapshotResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && _impl_.lease_use_result_ != nullptr;
}
inline bool UploadEdgeSnapshotResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& UploadEdgeSnapshotResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = _impl_.lease_use_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::LeaseUseResult&>(
      ::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& UploadEdgeSnapshotResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.UploadEdgeSnapshotResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void UploadEdgeSnapshotResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  _impl_.lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.UploadEdgeSnapshotResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* UploadEdgeSnapshotResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* UploadEdgeSnapshotResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.UploadEdgeSnapshotResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* UploadEdgeSnapshotResponse::_internal_mutable_lease_use_result() {
  
  if (_impl_.lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArenaForAllocation());
    _impl_.lease_use_result_ = p;
  }
  return _impl_.lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* UploadEdgeSnapshotResponse::mutable_lease_use_result() {
  ::bosdyn::api::LeaseUseResult* _msg = _internal_mutable_lease_use_result();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.UploadEdgeSnapshotResponse.lease_use_result)
  return _msg;
}
inline void UploadEdgeSnapshotResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result));
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.UploadEdgeSnapshotResponse.lease_use_result)
}

// -------------------------------------------------------------------

// DownloadWaypointSnapshotRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool DownloadWaypointSnapshotRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DownloadWaypointSnapshotRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& DownloadWaypointSnapshotRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& DownloadWaypointSnapshotRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest.header)
  return _internal_header();
}
inline void DownloadWaypointSnapshotRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest.header)
}
inline ::bosdyn::api::RequestHeader* DownloadWaypointSnapshotRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* DownloadWaypointSnapshotRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* DownloadWaypointSnapshotRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* DownloadWaypointSnapshotRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest.header)
  return _msg;
}
inline void DownloadWaypointSnapshotRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest.header)
}

// string waypoint_snapshot_id = 2;
inline void DownloadWaypointSnapshotRequest::clear_waypoint_snapshot_id() {
  _impl_.waypoint_snapshot_id_.ClearToEmpty();
}
inline const std::string& DownloadWaypointSnapshotRequest::waypoint_snapshot_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest.waypoint_snapshot_id)
  return _internal_waypoint_snapshot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadWaypointSnapshotRequest::set_waypoint_snapshot_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.waypoint_snapshot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest.waypoint_snapshot_id)
}
inline std::string* DownloadWaypointSnapshotRequest::mutable_waypoint_snapshot_id() {
  std::string* _s = _internal_mutable_waypoint_snapshot_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest.waypoint_snapshot_id)
  return _s;
}
inline const std::string& DownloadWaypointSnapshotRequest::_internal_waypoint_snapshot_id() const {
  return _impl_.waypoint_snapshot_id_.Get();
}
inline void DownloadWaypointSnapshotRequest::_internal_set_waypoint_snapshot_id(const std::string& value) {
  
  _impl_.waypoint_snapshot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadWaypointSnapshotRequest::_internal_mutable_waypoint_snapshot_id() {
  
  return _impl_.waypoint_snapshot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DownloadWaypointSnapshotRequest::release_waypoint_snapshot_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest.waypoint_snapshot_id)
  return _impl_.waypoint_snapshot_id_.Release();
}
inline void DownloadWaypointSnapshotRequest::set_allocated_waypoint_snapshot_id(std::string* waypoint_snapshot_id) {
  if (waypoint_snapshot_id != nullptr) {
    
  } else {
    
  }
  _impl_.waypoint_snapshot_id_.SetAllocated(waypoint_snapshot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.waypoint_snapshot_id_.IsDefault()) {
    _impl_.waypoint_snapshot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest.waypoint_snapshot_id)
}

// bool download_images = 3;
inline void DownloadWaypointSnapshotRequest::clear_download_images() {
  _impl_.download_images_ = false;
}
inline bool DownloadWaypointSnapshotRequest::_internal_download_images() const {
  return _impl_.download_images_;
}
inline bool DownloadWaypointSnapshotRequest::download_images() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest.download_images)
  return _internal_download_images();
}
inline void DownloadWaypointSnapshotRequest::_internal_set_download_images(bool value) {
  
  _impl_.download_images_ = value;
}
inline void DownloadWaypointSnapshotRequest::set_download_images(bool value) {
  _internal_set_download_images(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest.download_images)
}

// bool compress_point_cloud = 4;
inline void DownloadWaypointSnapshotRequest::clear_compress_point_cloud() {
  _impl_.compress_point_cloud_ = false;
}
inline bool DownloadWaypointSnapshotRequest::_internal_compress_point_cloud() const {
  return _impl_.compress_point_cloud_;
}
inline bool DownloadWaypointSnapshotRequest::compress_point_cloud() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest.compress_point_cloud)
  return _internal_compress_point_cloud();
}
inline void DownloadWaypointSnapshotRequest::_internal_set_compress_point_cloud(bool value) {
  
  _impl_.compress_point_cloud_ = value;
}
inline void DownloadWaypointSnapshotRequest::set_compress_point_cloud(bool value) {
  _internal_set_compress_point_cloud(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest.compress_point_cloud)
}

// bool do_not_download_point_cloud = 5;
inline void DownloadWaypointSnapshotRequest::clear_do_not_download_point_cloud() {
  _impl_.do_not_download_point_cloud_ = false;
}
inline bool DownloadWaypointSnapshotRequest::_internal_do_not_download_point_cloud() const {
  return _impl_.do_not_download_point_cloud_;
}
inline bool DownloadWaypointSnapshotRequest::do_not_download_point_cloud() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest.do_not_download_point_cloud)
  return _internal_do_not_download_point_cloud();
}
inline void DownloadWaypointSnapshotRequest::_internal_set_do_not_download_point_cloud(bool value) {
  
  _impl_.do_not_download_point_cloud_ = value;
}
inline void DownloadWaypointSnapshotRequest::set_do_not_download_point_cloud(bool value) {
  _internal_set_do_not_download_point_cloud(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.DownloadWaypointSnapshotRequest.do_not_download_point_cloud)
}

// -------------------------------------------------------------------

// DownloadWaypointSnapshotResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool DownloadWaypointSnapshotResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DownloadWaypointSnapshotResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& DownloadWaypointSnapshotResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& DownloadWaypointSnapshotResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.header)
  return _internal_header();
}
inline void DownloadWaypointSnapshotResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.header)
}
inline ::bosdyn::api::ResponseHeader* DownloadWaypointSnapshotResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DownloadWaypointSnapshotResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DownloadWaypointSnapshotResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* DownloadWaypointSnapshotResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.header)
  return _msg;
}
inline void DownloadWaypointSnapshotResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.header)
}

// .bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.Status status = 2;
inline void DownloadWaypointSnapshotResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::graph_nav::DownloadWaypointSnapshotResponse_Status DownloadWaypointSnapshotResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::DownloadWaypointSnapshotResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::graph_nav::DownloadWaypointSnapshotResponse_Status DownloadWaypointSnapshotResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.status)
  return _internal_status();
}
inline void DownloadWaypointSnapshotResponse::_internal_set_status(::bosdyn::api::graph_nav::DownloadWaypointSnapshotResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void DownloadWaypointSnapshotResponse::set_status(::bosdyn::api::graph_nav::DownloadWaypointSnapshotResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.status)
}

// string waypoint_snapshot_id = 4;
inline void DownloadWaypointSnapshotResponse::clear_waypoint_snapshot_id() {
  _impl_.waypoint_snapshot_id_.ClearToEmpty();
}
inline const std::string& DownloadWaypointSnapshotResponse::waypoint_snapshot_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.waypoint_snapshot_id)
  return _internal_waypoint_snapshot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadWaypointSnapshotResponse::set_waypoint_snapshot_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.waypoint_snapshot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.waypoint_snapshot_id)
}
inline std::string* DownloadWaypointSnapshotResponse::mutable_waypoint_snapshot_id() {
  std::string* _s = _internal_mutable_waypoint_snapshot_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.waypoint_snapshot_id)
  return _s;
}
inline const std::string& DownloadWaypointSnapshotResponse::_internal_waypoint_snapshot_id() const {
  return _impl_.waypoint_snapshot_id_.Get();
}
inline void DownloadWaypointSnapshotResponse::_internal_set_waypoint_snapshot_id(const std::string& value) {
  
  _impl_.waypoint_snapshot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadWaypointSnapshotResponse::_internal_mutable_waypoint_snapshot_id() {
  
  return _impl_.waypoint_snapshot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DownloadWaypointSnapshotResponse::release_waypoint_snapshot_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.waypoint_snapshot_id)
  return _impl_.waypoint_snapshot_id_.Release();
}
inline void DownloadWaypointSnapshotResponse::set_allocated_waypoint_snapshot_id(std::string* waypoint_snapshot_id) {
  if (waypoint_snapshot_id != nullptr) {
    
  } else {
    
  }
  _impl_.waypoint_snapshot_id_.SetAllocated(waypoint_snapshot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.waypoint_snapshot_id_.IsDefault()) {
    _impl_.waypoint_snapshot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.waypoint_snapshot_id)
}

// .bosdyn.api.DataChunk chunk = 5;
inline bool DownloadWaypointSnapshotResponse::_internal_has_chunk() const {
  return this != internal_default_instance() && _impl_.chunk_ != nullptr;
}
inline bool DownloadWaypointSnapshotResponse::has_chunk() const {
  return _internal_has_chunk();
}
inline const ::bosdyn::api::DataChunk& DownloadWaypointSnapshotResponse::_internal_chunk() const {
  const ::bosdyn::api::DataChunk* p = _impl_.chunk_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataChunk&>(
      ::bosdyn::api::_DataChunk_default_instance_);
}
inline const ::bosdyn::api::DataChunk& DownloadWaypointSnapshotResponse::chunk() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.chunk)
  return _internal_chunk();
}
inline void DownloadWaypointSnapshotResponse::unsafe_arena_set_allocated_chunk(
    ::bosdyn::api::DataChunk* chunk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chunk_);
  }
  _impl_.chunk_ = chunk;
  if (chunk) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.chunk)
}
inline ::bosdyn::api::DataChunk* DownloadWaypointSnapshotResponse::release_chunk() {
  
  ::bosdyn::api::DataChunk* temp = _impl_.chunk_;
  _impl_.chunk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataChunk* DownloadWaypointSnapshotResponse::unsafe_arena_release_chunk() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.chunk)
  
  ::bosdyn::api::DataChunk* temp = _impl_.chunk_;
  _impl_.chunk_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataChunk* DownloadWaypointSnapshotResponse::_internal_mutable_chunk() {
  
  if (_impl_.chunk_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataChunk>(GetArenaForAllocation());
    _impl_.chunk_ = p;
  }
  return _impl_.chunk_;
}
inline ::bosdyn::api::DataChunk* DownloadWaypointSnapshotResponse::mutable_chunk() {
  ::bosdyn::api::DataChunk* _msg = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.chunk)
  return _msg;
}
inline void DownloadWaypointSnapshotResponse::set_allocated_chunk(::bosdyn::api::DataChunk* chunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chunk_);
  }
  if (chunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chunk));
    if (message_arena != submessage_arena) {
      chunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chunk, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chunk_ = chunk;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.DownloadWaypointSnapshotResponse.chunk)
}

// -------------------------------------------------------------------

// DownloadEdgeSnapshotRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool DownloadEdgeSnapshotRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DownloadEdgeSnapshotRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& DownloadEdgeSnapshotRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& DownloadEdgeSnapshotRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadEdgeSnapshotRequest.header)
  return _internal_header();
}
inline void DownloadEdgeSnapshotRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.DownloadEdgeSnapshotRequest.header)
}
inline ::bosdyn::api::RequestHeader* DownloadEdgeSnapshotRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* DownloadEdgeSnapshotRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.DownloadEdgeSnapshotRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* DownloadEdgeSnapshotRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* DownloadEdgeSnapshotRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.DownloadEdgeSnapshotRequest.header)
  return _msg;
}
inline void DownloadEdgeSnapshotRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.DownloadEdgeSnapshotRequest.header)
}

// string edge_snapshot_id = 2;
inline void DownloadEdgeSnapshotRequest::clear_edge_snapshot_id() {
  _impl_.edge_snapshot_id_.ClearToEmpty();
}
inline const std::string& DownloadEdgeSnapshotRequest::edge_snapshot_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadEdgeSnapshotRequest.edge_snapshot_id)
  return _internal_edge_snapshot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadEdgeSnapshotRequest::set_edge_snapshot_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.edge_snapshot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.DownloadEdgeSnapshotRequest.edge_snapshot_id)
}
inline std::string* DownloadEdgeSnapshotRequest::mutable_edge_snapshot_id() {
  std::string* _s = _internal_mutable_edge_snapshot_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.DownloadEdgeSnapshotRequest.edge_snapshot_id)
  return _s;
}
inline const std::string& DownloadEdgeSnapshotRequest::_internal_edge_snapshot_id() const {
  return _impl_.edge_snapshot_id_.Get();
}
inline void DownloadEdgeSnapshotRequest::_internal_set_edge_snapshot_id(const std::string& value) {
  
  _impl_.edge_snapshot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadEdgeSnapshotRequest::_internal_mutable_edge_snapshot_id() {
  
  return _impl_.edge_snapshot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DownloadEdgeSnapshotRequest::release_edge_snapshot_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.DownloadEdgeSnapshotRequest.edge_snapshot_id)
  return _impl_.edge_snapshot_id_.Release();
}
inline void DownloadEdgeSnapshotRequest::set_allocated_edge_snapshot_id(std::string* edge_snapshot_id) {
  if (edge_snapshot_id != nullptr) {
    
  } else {
    
  }
  _impl_.edge_snapshot_id_.SetAllocated(edge_snapshot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.edge_snapshot_id_.IsDefault()) {
    _impl_.edge_snapshot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.DownloadEdgeSnapshotRequest.edge_snapshot_id)
}

// -------------------------------------------------------------------

// DownloadEdgeSnapshotResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool DownloadEdgeSnapshotResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DownloadEdgeSnapshotResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& DownloadEdgeSnapshotResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& DownloadEdgeSnapshotResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.header)
  return _internal_header();
}
inline void DownloadEdgeSnapshotResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.header)
}
inline ::bosdyn::api::ResponseHeader* DownloadEdgeSnapshotResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DownloadEdgeSnapshotResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DownloadEdgeSnapshotResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* DownloadEdgeSnapshotResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.header)
  return _msg;
}
inline void DownloadEdgeSnapshotResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.header)
}

// .bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.Status status = 2;
inline void DownloadEdgeSnapshotResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::graph_nav::DownloadEdgeSnapshotResponse_Status DownloadEdgeSnapshotResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::DownloadEdgeSnapshotResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::graph_nav::DownloadEdgeSnapshotResponse_Status DownloadEdgeSnapshotResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.status)
  return _internal_status();
}
inline void DownloadEdgeSnapshotResponse::_internal_set_status(::bosdyn::api::graph_nav::DownloadEdgeSnapshotResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void DownloadEdgeSnapshotResponse::set_status(::bosdyn::api::graph_nav::DownloadEdgeSnapshotResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.status)
}

// string edge_snapshot_id = 4;
inline void DownloadEdgeSnapshotResponse::clear_edge_snapshot_id() {
  _impl_.edge_snapshot_id_.ClearToEmpty();
}
inline const std::string& DownloadEdgeSnapshotResponse::edge_snapshot_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.edge_snapshot_id)
  return _internal_edge_snapshot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadEdgeSnapshotResponse::set_edge_snapshot_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.edge_snapshot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.edge_snapshot_id)
}
inline std::string* DownloadEdgeSnapshotResponse::mutable_edge_snapshot_id() {
  std::string* _s = _internal_mutable_edge_snapshot_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.edge_snapshot_id)
  return _s;
}
inline const std::string& DownloadEdgeSnapshotResponse::_internal_edge_snapshot_id() const {
  return _impl_.edge_snapshot_id_.Get();
}
inline void DownloadEdgeSnapshotResponse::_internal_set_edge_snapshot_id(const std::string& value) {
  
  _impl_.edge_snapshot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadEdgeSnapshotResponse::_internal_mutable_edge_snapshot_id() {
  
  return _impl_.edge_snapshot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DownloadEdgeSnapshotResponse::release_edge_snapshot_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.edge_snapshot_id)
  return _impl_.edge_snapshot_id_.Release();
}
inline void DownloadEdgeSnapshotResponse::set_allocated_edge_snapshot_id(std::string* edge_snapshot_id) {
  if (edge_snapshot_id != nullptr) {
    
  } else {
    
  }
  _impl_.edge_snapshot_id_.SetAllocated(edge_snapshot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.edge_snapshot_id_.IsDefault()) {
    _impl_.edge_snapshot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.edge_snapshot_id)
}

// .bosdyn.api.DataChunk chunk = 5;
inline bool DownloadEdgeSnapshotResponse::_internal_has_chunk() const {
  return this != internal_default_instance() && _impl_.chunk_ != nullptr;
}
inline bool DownloadEdgeSnapshotResponse::has_chunk() const {
  return _internal_has_chunk();
}
inline const ::bosdyn::api::DataChunk& DownloadEdgeSnapshotResponse::_internal_chunk() const {
  const ::bosdyn::api::DataChunk* p = _impl_.chunk_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataChunk&>(
      ::bosdyn::api::_DataChunk_default_instance_);
}
inline const ::bosdyn::api::DataChunk& DownloadEdgeSnapshotResponse::chunk() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.chunk)
  return _internal_chunk();
}
inline void DownloadEdgeSnapshotResponse::unsafe_arena_set_allocated_chunk(
    ::bosdyn::api::DataChunk* chunk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chunk_);
  }
  _impl_.chunk_ = chunk;
  if (chunk) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.chunk)
}
inline ::bosdyn::api::DataChunk* DownloadEdgeSnapshotResponse::release_chunk() {
  
  ::bosdyn::api::DataChunk* temp = _impl_.chunk_;
  _impl_.chunk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataChunk* DownloadEdgeSnapshotResponse::unsafe_arena_release_chunk() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.chunk)
  
  ::bosdyn::api::DataChunk* temp = _impl_.chunk_;
  _impl_.chunk_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataChunk* DownloadEdgeSnapshotResponse::_internal_mutable_chunk() {
  
  if (_impl_.chunk_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataChunk>(GetArenaForAllocation());
    _impl_.chunk_ = p;
  }
  return _impl_.chunk_;
}
inline ::bosdyn::api::DataChunk* DownloadEdgeSnapshotResponse::mutable_chunk() {
  ::bosdyn::api::DataChunk* _msg = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.chunk)
  return _msg;
}
inline void DownloadEdgeSnapshotResponse::set_allocated_chunk(::bosdyn::api::DataChunk* chunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chunk_);
  }
  if (chunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chunk));
    if (message_arena != submessage_arena) {
      chunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chunk, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chunk_ = chunk;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.DownloadEdgeSnapshotResponse.chunk)
}

// -------------------------------------------------------------------

// AreaCallbackServiceError

// repeated string missing_services = 1;
inline int AreaCallbackServiceError::_internal_missing_services_size() const {
  return _impl_.missing_services_.size();
}
inline int AreaCallbackServiceError::missing_services_size() const {
  return _internal_missing_services_size();
}
inline void AreaCallbackServiceError::clear_missing_services() {
  _impl_.missing_services_.Clear();
}
inline std::string* AreaCallbackServiceError::add_missing_services() {
  std::string* _s = _internal_add_missing_services();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.graph_nav.AreaCallbackServiceError.missing_services)
  return _s;
}
inline const std::string& AreaCallbackServiceError::_internal_missing_services(int index) const {
  return _impl_.missing_services_.Get(index);
}
inline const std::string& AreaCallbackServiceError::missing_services(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.AreaCallbackServiceError.missing_services)
  return _internal_missing_services(index);
}
inline std::string* AreaCallbackServiceError::mutable_missing_services(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.AreaCallbackServiceError.missing_services)
  return _impl_.missing_services_.Mutable(index);
}
inline void AreaCallbackServiceError::set_missing_services(int index, const std::string& value) {
  _impl_.missing_services_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.AreaCallbackServiceError.missing_services)
}
inline void AreaCallbackServiceError::set_missing_services(int index, std::string&& value) {
  _impl_.missing_services_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.AreaCallbackServiceError.missing_services)
}
inline void AreaCallbackServiceError::set_missing_services(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.missing_services_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.graph_nav.AreaCallbackServiceError.missing_services)
}
inline void AreaCallbackServiceError::set_missing_services(int index, const char* value, size_t size) {
  _impl_.missing_services_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.graph_nav.AreaCallbackServiceError.missing_services)
}
inline std::string* AreaCallbackServiceError::_internal_add_missing_services() {
  return _impl_.missing_services_.Add();
}
inline void AreaCallbackServiceError::add_missing_services(const std::string& value) {
  _impl_.missing_services_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.AreaCallbackServiceError.missing_services)
}
inline void AreaCallbackServiceError::add_missing_services(std::string&& value) {
  _impl_.missing_services_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.AreaCallbackServiceError.missing_services)
}
inline void AreaCallbackServiceError::add_missing_services(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.missing_services_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.graph_nav.AreaCallbackServiceError.missing_services)
}
inline void AreaCallbackServiceError::add_missing_services(const char* value, size_t size) {
  _impl_.missing_services_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.graph_nav.AreaCallbackServiceError.missing_services)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AreaCallbackServiceError::missing_services() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.AreaCallbackServiceError.missing_services)
  return _impl_.missing_services_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AreaCallbackServiceError::mutable_missing_services() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.AreaCallbackServiceError.missing_services)
  return &_impl_.missing_services_;
}

// -------------------------------------------------------------------

// ValidateGraphRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ValidateGraphRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ValidateGraphRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ValidateGraphRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ValidateGraphRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.ValidateGraphRequest.header)
  return _internal_header();
}
inline void ValidateGraphRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.ValidateGraphRequest.header)
}
inline ::bosdyn::api::RequestHeader* ValidateGraphRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ValidateGraphRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.ValidateGraphRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ValidateGraphRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ValidateGraphRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.ValidateGraphRequest.header)
  return _msg;
}
inline void ValidateGraphRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.ValidateGraphRequest.header)
}

// -------------------------------------------------------------------

// ValidateGraphResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ValidateGraphResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ValidateGraphResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ValidateGraphResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ValidateGraphResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.ValidateGraphResponse.header)
  return _internal_header();
}
inline void ValidateGraphResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.ValidateGraphResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ValidateGraphResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ValidateGraphResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.ValidateGraphResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ValidateGraphResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ValidateGraphResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.ValidateGraphResponse.header)
  return _msg;
}
inline void ValidateGraphResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.ValidateGraphResponse.header)
}

// .bosdyn.api.graph_nav.ValidateGraphResponse.Status status = 2;
inline void ValidateGraphResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::graph_nav::ValidateGraphResponse_Status ValidateGraphResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::ValidateGraphResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::graph_nav::ValidateGraphResponse_Status ValidateGraphResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.ValidateGraphResponse.status)
  return _internal_status();
}
inline void ValidateGraphResponse::_internal_set_status(::bosdyn::api::graph_nav::ValidateGraphResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void ValidateGraphResponse::set_status(::bosdyn::api::graph_nav::ValidateGraphResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.ValidateGraphResponse.status)
}

// .bosdyn.api.graph_nav.SensorCompatibilityStatus sensor_status = 3;
inline bool ValidateGraphResponse::_internal_has_sensor_status() const {
  return this != internal_default_instance() && _impl_.sensor_status_ != nullptr;
}
inline bool ValidateGraphResponse::has_sensor_status() const {
  return _internal_has_sensor_status();
}
inline void ValidateGraphResponse::clear_sensor_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.sensor_status_ != nullptr) {
    delete _impl_.sensor_status_;
  }
  _impl_.sensor_status_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::SensorCompatibilityStatus& ValidateGraphResponse::_internal_sensor_status() const {
  const ::bosdyn::api::graph_nav::SensorCompatibilityStatus* p = _impl_.sensor_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::SensorCompatibilityStatus&>(
      ::bosdyn::api::graph_nav::_SensorCompatibilityStatus_default_instance_);
}
inline const ::bosdyn::api::graph_nav::SensorCompatibilityStatus& ValidateGraphResponse::sensor_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.ValidateGraphResponse.sensor_status)
  return _internal_sensor_status();
}
inline void ValidateGraphResponse::unsafe_arena_set_allocated_sensor_status(
    ::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sensor_status_);
  }
  _impl_.sensor_status_ = sensor_status;
  if (sensor_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.ValidateGraphResponse.sensor_status)
}
inline ::bosdyn::api::graph_nav::SensorCompatibilityStatus* ValidateGraphResponse::release_sensor_status() {
  
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* temp = _impl_.sensor_status_;
  _impl_.sensor_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::SensorCompatibilityStatus* ValidateGraphResponse::unsafe_arena_release_sensor_status() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.ValidateGraphResponse.sensor_status)
  
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* temp = _impl_.sensor_status_;
  _impl_.sensor_status_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::SensorCompatibilityStatus* ValidateGraphResponse::_internal_mutable_sensor_status() {
  
  if (_impl_.sensor_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::SensorCompatibilityStatus>(GetArenaForAllocation());
    _impl_.sensor_status_ = p;
  }
  return _impl_.sensor_status_;
}
inline ::bosdyn::api::graph_nav::SensorCompatibilityStatus* ValidateGraphResponse::mutable_sensor_status() {
  ::bosdyn::api::graph_nav::SensorCompatibilityStatus* _msg = _internal_mutable_sensor_status();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.ValidateGraphResponse.sensor_status)
  return _msg;
}
inline void ValidateGraphResponse::set_allocated_sensor_status(::bosdyn::api::graph_nav::SensorCompatibilityStatus* sensor_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sensor_status_;
  }
  if (sensor_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sensor_status);
    if (message_arena != submessage_arena) {
      sensor_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sensor_status_ = sensor_status;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.ValidateGraphResponse.sensor_status)
}

// .bosdyn.api.graph_nav.AreaCallbackServiceError area_callback_error = 4;
inline bool ValidateGraphResponse::_internal_has_area_callback_error() const {
  return this != internal_default_instance() && _impl_.area_callback_error_ != nullptr;
}
inline bool ValidateGraphResponse::has_area_callback_error() const {
  return _internal_has_area_callback_error();
}
inline void ValidateGraphResponse::clear_area_callback_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.area_callback_error_ != nullptr) {
    delete _impl_.area_callback_error_;
  }
  _impl_.area_callback_error_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::AreaCallbackServiceError& ValidateGraphResponse::_internal_area_callback_error() const {
  const ::bosdyn::api::graph_nav::AreaCallbackServiceError* p = _impl_.area_callback_error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::graph_nav::AreaCallbackServiceError&>(
      ::bosdyn::api::graph_nav::_AreaCallbackServiceError_default_instance_);
}
inline const ::bosdyn::api::graph_nav::AreaCallbackServiceError& ValidateGraphResponse::area_callback_error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.ValidateGraphResponse.area_callback_error)
  return _internal_area_callback_error();
}
inline void ValidateGraphResponse::unsafe_arena_set_allocated_area_callback_error(
    ::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.area_callback_error_);
  }
  _impl_.area_callback_error_ = area_callback_error;
  if (area_callback_error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.ValidateGraphResponse.area_callback_error)
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* ValidateGraphResponse::release_area_callback_error() {
  
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* temp = _impl_.area_callback_error_;
  _impl_.area_callback_error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* ValidateGraphResponse::unsafe_arena_release_area_callback_error() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.ValidateGraphResponse.area_callback_error)
  
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* temp = _impl_.area_callback_error_;
  _impl_.area_callback_error_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* ValidateGraphResponse::_internal_mutable_area_callback_error() {
  
  if (_impl_.area_callback_error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::AreaCallbackServiceError>(GetArenaForAllocation());
    _impl_.area_callback_error_ = p;
  }
  return _impl_.area_callback_error_;
}
inline ::bosdyn::api::graph_nav::AreaCallbackServiceError* ValidateGraphResponse::mutable_area_callback_error() {
  ::bosdyn::api::graph_nav::AreaCallbackServiceError* _msg = _internal_mutable_area_callback_error();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.ValidateGraphResponse.area_callback_error)
  return _msg;
}
inline void ValidateGraphResponse::set_allocated_area_callback_error(::bosdyn::api::graph_nav::AreaCallbackServiceError* area_callback_error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.area_callback_error_;
  }
  if (area_callback_error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(area_callback_error);
    if (message_arena != submessage_arena) {
      area_callback_error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, area_callback_error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.area_callback_error_ = area_callback_error;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.ValidateGraphResponse.area_callback_error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace graph_nav
}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::graph_nav::SetLocalizationRequest_FiducialInit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::SetLocalizationRequest_FiducialInit>() {
  return ::bosdyn::api::graph_nav::SetLocalizationRequest_FiducialInit_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::SetLocalizationResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::SetLocalizationResponse_Status>() {
  return ::bosdyn::api::graph_nav::SetLocalizationResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::TravelParams_FeatureQualityTolerance> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::TravelParams_FeatureQualityTolerance>() {
  return ::bosdyn::api::graph_nav::TravelParams_FeatureQualityTolerance_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::NavigateToResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::NavigateToResponse_Status>() {
  return ::bosdyn::api::graph_nav::NavigateToResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::RouteFollowingParams_StartRouteBehavior> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::RouteFollowingParams_StartRouteBehavior>() {
  return ::bosdyn::api::graph_nav::RouteFollowingParams_StartRouteBehavior_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::RouteFollowingParams_ResumeBehavior> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::RouteFollowingParams_ResumeBehavior>() {
  return ::bosdyn::api::graph_nav::RouteFollowingParams_ResumeBehavior_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::RouteFollowingParams_RouteBlockedBehavior> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::RouteFollowingParams_RouteBlockedBehavior>() {
  return ::bosdyn::api::graph_nav::RouteFollowingParams_RouteBlockedBehavior_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::NavigateRouteResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::NavigateRouteResponse_Status>() {
  return ::bosdyn::api::graph_nav::NavigateRouteResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::NavigateToAnchorResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::NavigateToAnchorResponse_Status>() {
  return ::bosdyn::api::graph_nav::NavigateToAnchorResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus>() {
  return ::bosdyn::api::graph_nav::NavigationFeedbackResponse_ActiveRegionInformation_AreaCallbackStatus_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::NavigationFeedbackResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::NavigationFeedbackResponse_Status>() {
  return ::bosdyn::api::graph_nav::NavigationFeedbackResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::NavigationFeedbackResponse_RouteFollowingStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::NavigationFeedbackResponse_RouteFollowingStatus>() {
  return ::bosdyn::api::graph_nav::NavigationFeedbackResponse_RouteFollowingStatus_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::NavigationFeedbackResponse_BlockageStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::NavigationFeedbackResponse_BlockageStatus>() {
  return ::bosdyn::api::graph_nav::NavigationFeedbackResponse_BlockageStatus_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::ClearGraphResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::ClearGraphResponse_Status>() {
  return ::bosdyn::api::graph_nav::ClearGraphResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::UploadGraphResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::UploadGraphResponse_Status>() {
  return ::bosdyn::api::graph_nav::UploadGraphResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::UploadWaypointSnapshotResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::UploadWaypointSnapshotResponse_Status>() {
  return ::bosdyn::api::graph_nav::UploadWaypointSnapshotResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::DownloadWaypointSnapshotResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::DownloadWaypointSnapshotResponse_Status>() {
  return ::bosdyn::api::graph_nav::DownloadWaypointSnapshotResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::DownloadEdgeSnapshotResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::DownloadEdgeSnapshotResponse_Status>() {
  return ::bosdyn::api::graph_nav::DownloadEdgeSnapshotResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::ValidateGraphResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::ValidateGraphResponse_Status>() {
  return ::bosdyn::api::graph_nav::ValidateGraphResponse_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fgraph_5fnav_2fgraph_5fnav_2eproto
