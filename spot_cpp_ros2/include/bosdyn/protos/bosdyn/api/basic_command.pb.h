// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/basic_command.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fbasic_5fcommand_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fbasic_5fcommand_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/geometry.pb.h"
#include "bosdyn/api/trajectory.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fbasic_5fcommand_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
namespace bosdyn {
namespace api {
class ArmDragCommand;
struct ArmDragCommandDefaultTypeInternal;
extern ArmDragCommandDefaultTypeInternal _ArmDragCommand_default_instance_;
class ArmDragCommand_Feedback;
struct ArmDragCommand_FeedbackDefaultTypeInternal;
extern ArmDragCommand_FeedbackDefaultTypeInternal _ArmDragCommand_Feedback_default_instance_;
class ArmDragCommand_Request;
struct ArmDragCommand_RequestDefaultTypeInternal;
extern ArmDragCommand_RequestDefaultTypeInternal _ArmDragCommand_Request_default_instance_;
class BatteryChangePoseCommand;
struct BatteryChangePoseCommandDefaultTypeInternal;
extern BatteryChangePoseCommandDefaultTypeInternal _BatteryChangePoseCommand_default_instance_;
class BatteryChangePoseCommand_Feedback;
struct BatteryChangePoseCommand_FeedbackDefaultTypeInternal;
extern BatteryChangePoseCommand_FeedbackDefaultTypeInternal _BatteryChangePoseCommand_Feedback_default_instance_;
class BatteryChangePoseCommand_Request;
struct BatteryChangePoseCommand_RequestDefaultTypeInternal;
extern BatteryChangePoseCommand_RequestDefaultTypeInternal _BatteryChangePoseCommand_Request_default_instance_;
class ConstrainedManipulationCommand;
struct ConstrainedManipulationCommandDefaultTypeInternal;
extern ConstrainedManipulationCommandDefaultTypeInternal _ConstrainedManipulationCommand_default_instance_;
class ConstrainedManipulationCommand_Feedback;
struct ConstrainedManipulationCommand_FeedbackDefaultTypeInternal;
extern ConstrainedManipulationCommand_FeedbackDefaultTypeInternal _ConstrainedManipulationCommand_Feedback_default_instance_;
class ConstrainedManipulationCommand_Request;
struct ConstrainedManipulationCommand_RequestDefaultTypeInternal;
extern ConstrainedManipulationCommand_RequestDefaultTypeInternal _ConstrainedManipulationCommand_Request_default_instance_;
class FollowArmCommand;
struct FollowArmCommandDefaultTypeInternal;
extern FollowArmCommandDefaultTypeInternal _FollowArmCommand_default_instance_;
class FollowArmCommand_Feedback;
struct FollowArmCommand_FeedbackDefaultTypeInternal;
extern FollowArmCommand_FeedbackDefaultTypeInternal _FollowArmCommand_Feedback_default_instance_;
class FollowArmCommand_Request;
struct FollowArmCommand_RequestDefaultTypeInternal;
extern FollowArmCommand_RequestDefaultTypeInternal _FollowArmCommand_Request_default_instance_;
class FreezeCommand;
struct FreezeCommandDefaultTypeInternal;
extern FreezeCommandDefaultTypeInternal _FreezeCommand_default_instance_;
class FreezeCommand_Feedback;
struct FreezeCommand_FeedbackDefaultTypeInternal;
extern FreezeCommand_FeedbackDefaultTypeInternal _FreezeCommand_Feedback_default_instance_;
class FreezeCommand_Request;
struct FreezeCommand_RequestDefaultTypeInternal;
extern FreezeCommand_RequestDefaultTypeInternal _FreezeCommand_Request_default_instance_;
class RobotCommandFeedbackStatus;
struct RobotCommandFeedbackStatusDefaultTypeInternal;
extern RobotCommandFeedbackStatusDefaultTypeInternal _RobotCommandFeedbackStatus_default_instance_;
class SE2TrajectoryCommand;
struct SE2TrajectoryCommandDefaultTypeInternal;
extern SE2TrajectoryCommandDefaultTypeInternal _SE2TrajectoryCommand_default_instance_;
class SE2TrajectoryCommand_Feedback;
struct SE2TrajectoryCommand_FeedbackDefaultTypeInternal;
extern SE2TrajectoryCommand_FeedbackDefaultTypeInternal _SE2TrajectoryCommand_Feedback_default_instance_;
class SE2TrajectoryCommand_Request;
struct SE2TrajectoryCommand_RequestDefaultTypeInternal;
extern SE2TrajectoryCommand_RequestDefaultTypeInternal _SE2TrajectoryCommand_Request_default_instance_;
class SE2VelocityCommand;
struct SE2VelocityCommandDefaultTypeInternal;
extern SE2VelocityCommandDefaultTypeInternal _SE2VelocityCommand_default_instance_;
class SE2VelocityCommand_Feedback;
struct SE2VelocityCommand_FeedbackDefaultTypeInternal;
extern SE2VelocityCommand_FeedbackDefaultTypeInternal _SE2VelocityCommand_Feedback_default_instance_;
class SE2VelocityCommand_Request;
struct SE2VelocityCommand_RequestDefaultTypeInternal;
extern SE2VelocityCommand_RequestDefaultTypeInternal _SE2VelocityCommand_Request_default_instance_;
class SafePowerOffCommand;
struct SafePowerOffCommandDefaultTypeInternal;
extern SafePowerOffCommandDefaultTypeInternal _SafePowerOffCommand_default_instance_;
class SafePowerOffCommand_Feedback;
struct SafePowerOffCommand_FeedbackDefaultTypeInternal;
extern SafePowerOffCommand_FeedbackDefaultTypeInternal _SafePowerOffCommand_Feedback_default_instance_;
class SafePowerOffCommand_Request;
struct SafePowerOffCommand_RequestDefaultTypeInternal;
extern SafePowerOffCommand_RequestDefaultTypeInternal _SafePowerOffCommand_Request_default_instance_;
class SelfRightCommand;
struct SelfRightCommandDefaultTypeInternal;
extern SelfRightCommandDefaultTypeInternal _SelfRightCommand_default_instance_;
class SelfRightCommand_Feedback;
struct SelfRightCommand_FeedbackDefaultTypeInternal;
extern SelfRightCommand_FeedbackDefaultTypeInternal _SelfRightCommand_Feedback_default_instance_;
class SelfRightCommand_Request;
struct SelfRightCommand_RequestDefaultTypeInternal;
extern SelfRightCommand_RequestDefaultTypeInternal _SelfRightCommand_Request_default_instance_;
class SitCommand;
struct SitCommandDefaultTypeInternal;
extern SitCommandDefaultTypeInternal _SitCommand_default_instance_;
class SitCommand_Feedback;
struct SitCommand_FeedbackDefaultTypeInternal;
extern SitCommand_FeedbackDefaultTypeInternal _SitCommand_Feedback_default_instance_;
class SitCommand_Request;
struct SitCommand_RequestDefaultTypeInternal;
extern SitCommand_RequestDefaultTypeInternal _SitCommand_Request_default_instance_;
class Stance;
struct StanceDefaultTypeInternal;
extern StanceDefaultTypeInternal _Stance_default_instance_;
class StanceCommand;
struct StanceCommandDefaultTypeInternal;
extern StanceCommandDefaultTypeInternal _StanceCommand_default_instance_;
class StanceCommand_Feedback;
struct StanceCommand_FeedbackDefaultTypeInternal;
extern StanceCommand_FeedbackDefaultTypeInternal _StanceCommand_Feedback_default_instance_;
class StanceCommand_Request;
struct StanceCommand_RequestDefaultTypeInternal;
extern StanceCommand_RequestDefaultTypeInternal _StanceCommand_Request_default_instance_;
class Stance_FootPositionsEntry_DoNotUse;
struct Stance_FootPositionsEntry_DoNotUseDefaultTypeInternal;
extern Stance_FootPositionsEntry_DoNotUseDefaultTypeInternal _Stance_FootPositionsEntry_DoNotUse_default_instance_;
class StandCommand;
struct StandCommandDefaultTypeInternal;
extern StandCommandDefaultTypeInternal _StandCommand_default_instance_;
class StandCommand_Feedback;
struct StandCommand_FeedbackDefaultTypeInternal;
extern StandCommand_FeedbackDefaultTypeInternal _StandCommand_Feedback_default_instance_;
class StandCommand_Request;
struct StandCommand_RequestDefaultTypeInternal;
extern StandCommand_RequestDefaultTypeInternal _StandCommand_Request_default_instance_;
class StopCommand;
struct StopCommandDefaultTypeInternal;
extern StopCommandDefaultTypeInternal _StopCommand_default_instance_;
class StopCommand_Feedback;
struct StopCommand_FeedbackDefaultTypeInternal;
extern StopCommand_FeedbackDefaultTypeInternal _StopCommand_Feedback_default_instance_;
class StopCommand_Request;
struct StopCommand_RequestDefaultTypeInternal;
extern StopCommand_RequestDefaultTypeInternal _StopCommand_Request_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::ArmDragCommand* Arena::CreateMaybeMessage<::bosdyn::api::ArmDragCommand>(Arena*);
template<> ::bosdyn::api::ArmDragCommand_Feedback* Arena::CreateMaybeMessage<::bosdyn::api::ArmDragCommand_Feedback>(Arena*);
template<> ::bosdyn::api::ArmDragCommand_Request* Arena::CreateMaybeMessage<::bosdyn::api::ArmDragCommand_Request>(Arena*);
template<> ::bosdyn::api::BatteryChangePoseCommand* Arena::CreateMaybeMessage<::bosdyn::api::BatteryChangePoseCommand>(Arena*);
template<> ::bosdyn::api::BatteryChangePoseCommand_Feedback* Arena::CreateMaybeMessage<::bosdyn::api::BatteryChangePoseCommand_Feedback>(Arena*);
template<> ::bosdyn::api::BatteryChangePoseCommand_Request* Arena::CreateMaybeMessage<::bosdyn::api::BatteryChangePoseCommand_Request>(Arena*);
template<> ::bosdyn::api::ConstrainedManipulationCommand* Arena::CreateMaybeMessage<::bosdyn::api::ConstrainedManipulationCommand>(Arena*);
template<> ::bosdyn::api::ConstrainedManipulationCommand_Feedback* Arena::CreateMaybeMessage<::bosdyn::api::ConstrainedManipulationCommand_Feedback>(Arena*);
template<> ::bosdyn::api::ConstrainedManipulationCommand_Request* Arena::CreateMaybeMessage<::bosdyn::api::ConstrainedManipulationCommand_Request>(Arena*);
template<> ::bosdyn::api::FollowArmCommand* Arena::CreateMaybeMessage<::bosdyn::api::FollowArmCommand>(Arena*);
template<> ::bosdyn::api::FollowArmCommand_Feedback* Arena::CreateMaybeMessage<::bosdyn::api::FollowArmCommand_Feedback>(Arena*);
template<> ::bosdyn::api::FollowArmCommand_Request* Arena::CreateMaybeMessage<::bosdyn::api::FollowArmCommand_Request>(Arena*);
template<> ::bosdyn::api::FreezeCommand* Arena::CreateMaybeMessage<::bosdyn::api::FreezeCommand>(Arena*);
template<> ::bosdyn::api::FreezeCommand_Feedback* Arena::CreateMaybeMessage<::bosdyn::api::FreezeCommand_Feedback>(Arena*);
template<> ::bosdyn::api::FreezeCommand_Request* Arena::CreateMaybeMessage<::bosdyn::api::FreezeCommand_Request>(Arena*);
template<> ::bosdyn::api::RobotCommandFeedbackStatus* Arena::CreateMaybeMessage<::bosdyn::api::RobotCommandFeedbackStatus>(Arena*);
template<> ::bosdyn::api::SE2TrajectoryCommand* Arena::CreateMaybeMessage<::bosdyn::api::SE2TrajectoryCommand>(Arena*);
template<> ::bosdyn::api::SE2TrajectoryCommand_Feedback* Arena::CreateMaybeMessage<::bosdyn::api::SE2TrajectoryCommand_Feedback>(Arena*);
template<> ::bosdyn::api::SE2TrajectoryCommand_Request* Arena::CreateMaybeMessage<::bosdyn::api::SE2TrajectoryCommand_Request>(Arena*);
template<> ::bosdyn::api::SE2VelocityCommand* Arena::CreateMaybeMessage<::bosdyn::api::SE2VelocityCommand>(Arena*);
template<> ::bosdyn::api::SE2VelocityCommand_Feedback* Arena::CreateMaybeMessage<::bosdyn::api::SE2VelocityCommand_Feedback>(Arena*);
template<> ::bosdyn::api::SE2VelocityCommand_Request* Arena::CreateMaybeMessage<::bosdyn::api::SE2VelocityCommand_Request>(Arena*);
template<> ::bosdyn::api::SafePowerOffCommand* Arena::CreateMaybeMessage<::bosdyn::api::SafePowerOffCommand>(Arena*);
template<> ::bosdyn::api::SafePowerOffCommand_Feedback* Arena::CreateMaybeMessage<::bosdyn::api::SafePowerOffCommand_Feedback>(Arena*);
template<> ::bosdyn::api::SafePowerOffCommand_Request* Arena::CreateMaybeMessage<::bosdyn::api::SafePowerOffCommand_Request>(Arena*);
template<> ::bosdyn::api::SelfRightCommand* Arena::CreateMaybeMessage<::bosdyn::api::SelfRightCommand>(Arena*);
template<> ::bosdyn::api::SelfRightCommand_Feedback* Arena::CreateMaybeMessage<::bosdyn::api::SelfRightCommand_Feedback>(Arena*);
template<> ::bosdyn::api::SelfRightCommand_Request* Arena::CreateMaybeMessage<::bosdyn::api::SelfRightCommand_Request>(Arena*);
template<> ::bosdyn::api::SitCommand* Arena::CreateMaybeMessage<::bosdyn::api::SitCommand>(Arena*);
template<> ::bosdyn::api::SitCommand_Feedback* Arena::CreateMaybeMessage<::bosdyn::api::SitCommand_Feedback>(Arena*);
template<> ::bosdyn::api::SitCommand_Request* Arena::CreateMaybeMessage<::bosdyn::api::SitCommand_Request>(Arena*);
template<> ::bosdyn::api::Stance* Arena::CreateMaybeMessage<::bosdyn::api::Stance>(Arena*);
template<> ::bosdyn::api::StanceCommand* Arena::CreateMaybeMessage<::bosdyn::api::StanceCommand>(Arena*);
template<> ::bosdyn::api::StanceCommand_Feedback* Arena::CreateMaybeMessage<::bosdyn::api::StanceCommand_Feedback>(Arena*);
template<> ::bosdyn::api::StanceCommand_Request* Arena::CreateMaybeMessage<::bosdyn::api::StanceCommand_Request>(Arena*);
template<> ::bosdyn::api::Stance_FootPositionsEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::Stance_FootPositionsEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::StandCommand* Arena::CreateMaybeMessage<::bosdyn::api::StandCommand>(Arena*);
template<> ::bosdyn::api::StandCommand_Feedback* Arena::CreateMaybeMessage<::bosdyn::api::StandCommand_Feedback>(Arena*);
template<> ::bosdyn::api::StandCommand_Request* Arena::CreateMaybeMessage<::bosdyn::api::StandCommand_Request>(Arena*);
template<> ::bosdyn::api::StopCommand* Arena::CreateMaybeMessage<::bosdyn::api::StopCommand>(Arena*);
template<> ::bosdyn::api::StopCommand_Feedback* Arena::CreateMaybeMessage<::bosdyn::api::StopCommand_Feedback>(Arena*);
template<> ::bosdyn::api::StopCommand_Request* Arena::CreateMaybeMessage<::bosdyn::api::StopCommand_Request>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum RobotCommandFeedbackStatus_Status : int {
  RobotCommandFeedbackStatus_Status_STATUS_UNKNOWN = 0,
  RobotCommandFeedbackStatus_Status_STATUS_PROCESSING = 1,
  RobotCommandFeedbackStatus_Status_STATUS_COMMAND_OVERRIDDEN = 2,
  RobotCommandFeedbackStatus_Status_STATUS_COMMAND_TIMED_OUT = 3,
  RobotCommandFeedbackStatus_Status_STATUS_ROBOT_FROZEN = 4,
  RobotCommandFeedbackStatus_Status_STATUS_INCOMPATIBLE_HARDWARE = 5,
  RobotCommandFeedbackStatus_Status_RobotCommandFeedbackStatus_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RobotCommandFeedbackStatus_Status_RobotCommandFeedbackStatus_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RobotCommandFeedbackStatus_Status_IsValid(int value);
constexpr RobotCommandFeedbackStatus_Status RobotCommandFeedbackStatus_Status_Status_MIN = RobotCommandFeedbackStatus_Status_STATUS_UNKNOWN;
constexpr RobotCommandFeedbackStatus_Status RobotCommandFeedbackStatus_Status_Status_MAX = RobotCommandFeedbackStatus_Status_STATUS_INCOMPATIBLE_HARDWARE;
constexpr int RobotCommandFeedbackStatus_Status_Status_ARRAYSIZE = RobotCommandFeedbackStatus_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RobotCommandFeedbackStatus_Status_descriptor();
template<typename T>
inline const std::string& RobotCommandFeedbackStatus_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RobotCommandFeedbackStatus_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RobotCommandFeedbackStatus_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RobotCommandFeedbackStatus_Status_descriptor(), enum_t_value);
}
inline bool RobotCommandFeedbackStatus_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RobotCommandFeedbackStatus_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RobotCommandFeedbackStatus_Status>(
    RobotCommandFeedbackStatus_Status_descriptor(), name, value);
}
enum BatteryChangePoseCommand_Request_DirectionHint : int {
  BatteryChangePoseCommand_Request_DirectionHint_HINT_UNKNOWN = 0,
  BatteryChangePoseCommand_Request_DirectionHint_HINT_RIGHT = 1,
  BatteryChangePoseCommand_Request_DirectionHint_HINT_LEFT = 2,
  BatteryChangePoseCommand_Request_DirectionHint_BatteryChangePoseCommand_Request_DirectionHint_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BatteryChangePoseCommand_Request_DirectionHint_BatteryChangePoseCommand_Request_DirectionHint_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BatteryChangePoseCommand_Request_DirectionHint_IsValid(int value);
constexpr BatteryChangePoseCommand_Request_DirectionHint BatteryChangePoseCommand_Request_DirectionHint_DirectionHint_MIN = BatteryChangePoseCommand_Request_DirectionHint_HINT_UNKNOWN;
constexpr BatteryChangePoseCommand_Request_DirectionHint BatteryChangePoseCommand_Request_DirectionHint_DirectionHint_MAX = BatteryChangePoseCommand_Request_DirectionHint_HINT_LEFT;
constexpr int BatteryChangePoseCommand_Request_DirectionHint_DirectionHint_ARRAYSIZE = BatteryChangePoseCommand_Request_DirectionHint_DirectionHint_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatteryChangePoseCommand_Request_DirectionHint_descriptor();
template<typename T>
inline const std::string& BatteryChangePoseCommand_Request_DirectionHint_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BatteryChangePoseCommand_Request_DirectionHint>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BatteryChangePoseCommand_Request_DirectionHint_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BatteryChangePoseCommand_Request_DirectionHint_descriptor(), enum_t_value);
}
inline bool BatteryChangePoseCommand_Request_DirectionHint_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BatteryChangePoseCommand_Request_DirectionHint* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BatteryChangePoseCommand_Request_DirectionHint>(
    BatteryChangePoseCommand_Request_DirectionHint_descriptor(), name, value);
}
enum BatteryChangePoseCommand_Feedback_Status : int {
  BatteryChangePoseCommand_Feedback_Status_STATUS_UNKNOWN = 0,
  BatteryChangePoseCommand_Feedback_Status_STATUS_COMPLETED = 1,
  BatteryChangePoseCommand_Feedback_Status_STATUS_IN_PROGRESS = 2,
  BatteryChangePoseCommand_Feedback_Status_STATUS_FAILED = 3,
  BatteryChangePoseCommand_Feedback_Status_BatteryChangePoseCommand_Feedback_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BatteryChangePoseCommand_Feedback_Status_BatteryChangePoseCommand_Feedback_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BatteryChangePoseCommand_Feedback_Status_IsValid(int value);
constexpr BatteryChangePoseCommand_Feedback_Status BatteryChangePoseCommand_Feedback_Status_Status_MIN = BatteryChangePoseCommand_Feedback_Status_STATUS_UNKNOWN;
constexpr BatteryChangePoseCommand_Feedback_Status BatteryChangePoseCommand_Feedback_Status_Status_MAX = BatteryChangePoseCommand_Feedback_Status_STATUS_FAILED;
constexpr int BatteryChangePoseCommand_Feedback_Status_Status_ARRAYSIZE = BatteryChangePoseCommand_Feedback_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatteryChangePoseCommand_Feedback_Status_descriptor();
template<typename T>
inline const std::string& BatteryChangePoseCommand_Feedback_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BatteryChangePoseCommand_Feedback_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BatteryChangePoseCommand_Feedback_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BatteryChangePoseCommand_Feedback_Status_descriptor(), enum_t_value);
}
inline bool BatteryChangePoseCommand_Feedback_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BatteryChangePoseCommand_Feedback_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BatteryChangePoseCommand_Feedback_Status>(
    BatteryChangePoseCommand_Feedback_Status_descriptor(), name, value);
}
enum SelfRightCommand_Feedback_Status : int {
  SelfRightCommand_Feedback_Status_STATUS_UNKNOWN = 0,
  SelfRightCommand_Feedback_Status_STATUS_COMPLETED = 1,
  SelfRightCommand_Feedback_Status_STATUS_IN_PROGRESS = 2,
  SelfRightCommand_Feedback_Status_SelfRightCommand_Feedback_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SelfRightCommand_Feedback_Status_SelfRightCommand_Feedback_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SelfRightCommand_Feedback_Status_IsValid(int value);
constexpr SelfRightCommand_Feedback_Status SelfRightCommand_Feedback_Status_Status_MIN = SelfRightCommand_Feedback_Status_STATUS_UNKNOWN;
constexpr SelfRightCommand_Feedback_Status SelfRightCommand_Feedback_Status_Status_MAX = SelfRightCommand_Feedback_Status_STATUS_IN_PROGRESS;
constexpr int SelfRightCommand_Feedback_Status_Status_ARRAYSIZE = SelfRightCommand_Feedback_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SelfRightCommand_Feedback_Status_descriptor();
template<typename T>
inline const std::string& SelfRightCommand_Feedback_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SelfRightCommand_Feedback_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SelfRightCommand_Feedback_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SelfRightCommand_Feedback_Status_descriptor(), enum_t_value);
}
inline bool SelfRightCommand_Feedback_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SelfRightCommand_Feedback_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SelfRightCommand_Feedback_Status>(
    SelfRightCommand_Feedback_Status_descriptor(), name, value);
}
enum SafePowerOffCommand_Request_UnsafeAction : int {
  SafePowerOffCommand_Request_UnsafeAction_UNSAFE_UNKNOWN = 0,
  SafePowerOffCommand_Request_UnsafeAction_UNSAFE_MOVE_TO_SAFE_POSITION = 1,
  SafePowerOffCommand_Request_UnsafeAction_UNSAFE_FORCE_COMMAND = 2,
  SafePowerOffCommand_Request_UnsafeAction_SafePowerOffCommand_Request_UnsafeAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SafePowerOffCommand_Request_UnsafeAction_SafePowerOffCommand_Request_UnsafeAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SafePowerOffCommand_Request_UnsafeAction_IsValid(int value);
constexpr SafePowerOffCommand_Request_UnsafeAction SafePowerOffCommand_Request_UnsafeAction_UnsafeAction_MIN = SafePowerOffCommand_Request_UnsafeAction_UNSAFE_UNKNOWN;
constexpr SafePowerOffCommand_Request_UnsafeAction SafePowerOffCommand_Request_UnsafeAction_UnsafeAction_MAX = SafePowerOffCommand_Request_UnsafeAction_UNSAFE_FORCE_COMMAND;
constexpr int SafePowerOffCommand_Request_UnsafeAction_UnsafeAction_ARRAYSIZE = SafePowerOffCommand_Request_UnsafeAction_UnsafeAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SafePowerOffCommand_Request_UnsafeAction_descriptor();
template<typename T>
inline const std::string& SafePowerOffCommand_Request_UnsafeAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SafePowerOffCommand_Request_UnsafeAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SafePowerOffCommand_Request_UnsafeAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SafePowerOffCommand_Request_UnsafeAction_descriptor(), enum_t_value);
}
inline bool SafePowerOffCommand_Request_UnsafeAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SafePowerOffCommand_Request_UnsafeAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SafePowerOffCommand_Request_UnsafeAction>(
    SafePowerOffCommand_Request_UnsafeAction_descriptor(), name, value);
}
enum SafePowerOffCommand_Feedback_Status : int {
  SafePowerOffCommand_Feedback_Status_STATUS_UNKNOWN = 0,
  SafePowerOffCommand_Feedback_Status_STATUS_POWERED_OFF = 1,
  SafePowerOffCommand_Feedback_Status_STATUS_IN_PROGRESS = 2,
  SafePowerOffCommand_Feedback_Status_SafePowerOffCommand_Feedback_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SafePowerOffCommand_Feedback_Status_SafePowerOffCommand_Feedback_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SafePowerOffCommand_Feedback_Status_IsValid(int value);
constexpr SafePowerOffCommand_Feedback_Status SafePowerOffCommand_Feedback_Status_Status_MIN = SafePowerOffCommand_Feedback_Status_STATUS_UNKNOWN;
constexpr SafePowerOffCommand_Feedback_Status SafePowerOffCommand_Feedback_Status_Status_MAX = SafePowerOffCommand_Feedback_Status_STATUS_IN_PROGRESS;
constexpr int SafePowerOffCommand_Feedback_Status_Status_ARRAYSIZE = SafePowerOffCommand_Feedback_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SafePowerOffCommand_Feedback_Status_descriptor();
template<typename T>
inline const std::string& SafePowerOffCommand_Feedback_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SafePowerOffCommand_Feedback_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SafePowerOffCommand_Feedback_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SafePowerOffCommand_Feedback_Status_descriptor(), enum_t_value);
}
inline bool SafePowerOffCommand_Feedback_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SafePowerOffCommand_Feedback_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SafePowerOffCommand_Feedback_Status>(
    SafePowerOffCommand_Feedback_Status_descriptor(), name, value);
}
enum SE2TrajectoryCommand_Feedback_Status : int {
  SE2TrajectoryCommand_Feedback_Status_STATUS_UNKNOWN = 0,
  SE2TrajectoryCommand_Feedback_Status_STATUS_AT_GOAL = 1,
  SE2TrajectoryCommand_Feedback_Status_STATUS_NEAR_GOAL = 3,
  SE2TrajectoryCommand_Feedback_Status_STATUS_GOING_TO_GOAL = 2,
  SE2TrajectoryCommand_Feedback_Status_SE2TrajectoryCommand_Feedback_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SE2TrajectoryCommand_Feedback_Status_SE2TrajectoryCommand_Feedback_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SE2TrajectoryCommand_Feedback_Status_IsValid(int value);
constexpr SE2TrajectoryCommand_Feedback_Status SE2TrajectoryCommand_Feedback_Status_Status_MIN = SE2TrajectoryCommand_Feedback_Status_STATUS_UNKNOWN;
constexpr SE2TrajectoryCommand_Feedback_Status SE2TrajectoryCommand_Feedback_Status_Status_MAX = SE2TrajectoryCommand_Feedback_Status_STATUS_NEAR_GOAL;
constexpr int SE2TrajectoryCommand_Feedback_Status_Status_ARRAYSIZE = SE2TrajectoryCommand_Feedback_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SE2TrajectoryCommand_Feedback_Status_descriptor();
template<typename T>
inline const std::string& SE2TrajectoryCommand_Feedback_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SE2TrajectoryCommand_Feedback_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SE2TrajectoryCommand_Feedback_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SE2TrajectoryCommand_Feedback_Status_descriptor(), enum_t_value);
}
inline bool SE2TrajectoryCommand_Feedback_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SE2TrajectoryCommand_Feedback_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SE2TrajectoryCommand_Feedback_Status>(
    SE2TrajectoryCommand_Feedback_Status_descriptor(), name, value);
}
enum SE2TrajectoryCommand_Feedback_BodyMovementStatus : int {
  SE2TrajectoryCommand_Feedback_BodyMovementStatus_BODY_STATUS_UNKNOWN = 0,
  SE2TrajectoryCommand_Feedback_BodyMovementStatus_BODY_STATUS_MOVING = 1,
  SE2TrajectoryCommand_Feedback_BodyMovementStatus_BODY_STATUS_SETTLED = 2,
  SE2TrajectoryCommand_Feedback_BodyMovementStatus_SE2TrajectoryCommand_Feedback_BodyMovementStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SE2TrajectoryCommand_Feedback_BodyMovementStatus_SE2TrajectoryCommand_Feedback_BodyMovementStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SE2TrajectoryCommand_Feedback_BodyMovementStatus_IsValid(int value);
constexpr SE2TrajectoryCommand_Feedback_BodyMovementStatus SE2TrajectoryCommand_Feedback_BodyMovementStatus_BodyMovementStatus_MIN = SE2TrajectoryCommand_Feedback_BodyMovementStatus_BODY_STATUS_UNKNOWN;
constexpr SE2TrajectoryCommand_Feedback_BodyMovementStatus SE2TrajectoryCommand_Feedback_BodyMovementStatus_BodyMovementStatus_MAX = SE2TrajectoryCommand_Feedback_BodyMovementStatus_BODY_STATUS_SETTLED;
constexpr int SE2TrajectoryCommand_Feedback_BodyMovementStatus_BodyMovementStatus_ARRAYSIZE = SE2TrajectoryCommand_Feedback_BodyMovementStatus_BodyMovementStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SE2TrajectoryCommand_Feedback_BodyMovementStatus_descriptor();
template<typename T>
inline const std::string& SE2TrajectoryCommand_Feedback_BodyMovementStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SE2TrajectoryCommand_Feedback_BodyMovementStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SE2TrajectoryCommand_Feedback_BodyMovementStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SE2TrajectoryCommand_Feedback_BodyMovementStatus_descriptor(), enum_t_value);
}
inline bool SE2TrajectoryCommand_Feedback_BodyMovementStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SE2TrajectoryCommand_Feedback_BodyMovementStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SE2TrajectoryCommand_Feedback_BodyMovementStatus>(
    SE2TrajectoryCommand_Feedback_BodyMovementStatus_descriptor(), name, value);
}
enum SitCommand_Feedback_Status : int {
  SitCommand_Feedback_Status_STATUS_UNKNOWN = 0,
  SitCommand_Feedback_Status_STATUS_IS_SITTING = 1,
  SitCommand_Feedback_Status_STATUS_IN_PROGRESS = 2,
  SitCommand_Feedback_Status_SitCommand_Feedback_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SitCommand_Feedback_Status_SitCommand_Feedback_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SitCommand_Feedback_Status_IsValid(int value);
constexpr SitCommand_Feedback_Status SitCommand_Feedback_Status_Status_MIN = SitCommand_Feedback_Status_STATUS_UNKNOWN;
constexpr SitCommand_Feedback_Status SitCommand_Feedback_Status_Status_MAX = SitCommand_Feedback_Status_STATUS_IN_PROGRESS;
constexpr int SitCommand_Feedback_Status_Status_ARRAYSIZE = SitCommand_Feedback_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SitCommand_Feedback_Status_descriptor();
template<typename T>
inline const std::string& SitCommand_Feedback_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SitCommand_Feedback_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SitCommand_Feedback_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SitCommand_Feedback_Status_descriptor(), enum_t_value);
}
inline bool SitCommand_Feedback_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SitCommand_Feedback_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SitCommand_Feedback_Status>(
    SitCommand_Feedback_Status_descriptor(), name, value);
}
enum StandCommand_Feedback_Status : int {
  StandCommand_Feedback_Status_STATUS_UNKNOWN = 0,
  StandCommand_Feedback_Status_STATUS_IS_STANDING = 1,
  StandCommand_Feedback_Status_STATUS_IN_PROGRESS = 2,
  StandCommand_Feedback_Status_StandCommand_Feedback_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StandCommand_Feedback_Status_StandCommand_Feedback_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StandCommand_Feedback_Status_IsValid(int value);
constexpr StandCommand_Feedback_Status StandCommand_Feedback_Status_Status_MIN = StandCommand_Feedback_Status_STATUS_UNKNOWN;
constexpr StandCommand_Feedback_Status StandCommand_Feedback_Status_Status_MAX = StandCommand_Feedback_Status_STATUS_IN_PROGRESS;
constexpr int StandCommand_Feedback_Status_Status_ARRAYSIZE = StandCommand_Feedback_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StandCommand_Feedback_Status_descriptor();
template<typename T>
inline const std::string& StandCommand_Feedback_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StandCommand_Feedback_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StandCommand_Feedback_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StandCommand_Feedback_Status_descriptor(), enum_t_value);
}
inline bool StandCommand_Feedback_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StandCommand_Feedback_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StandCommand_Feedback_Status>(
    StandCommand_Feedback_Status_descriptor(), name, value);
}
enum StandCommand_Feedback_StandingState : int {
  StandCommand_Feedback_StandingState_STANDING_UNKNOWN = 0,
  StandCommand_Feedback_StandingState_STANDING_CONTROLLED = 1,
  StandCommand_Feedback_StandingState_STANDING_FROZEN = 2,
  StandCommand_Feedback_StandingState_StandCommand_Feedback_StandingState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StandCommand_Feedback_StandingState_StandCommand_Feedback_StandingState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StandCommand_Feedback_StandingState_IsValid(int value);
constexpr StandCommand_Feedback_StandingState StandCommand_Feedback_StandingState_StandingState_MIN = StandCommand_Feedback_StandingState_STANDING_UNKNOWN;
constexpr StandCommand_Feedback_StandingState StandCommand_Feedback_StandingState_StandingState_MAX = StandCommand_Feedback_StandingState_STANDING_FROZEN;
constexpr int StandCommand_Feedback_StandingState_StandingState_ARRAYSIZE = StandCommand_Feedback_StandingState_StandingState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StandCommand_Feedback_StandingState_descriptor();
template<typename T>
inline const std::string& StandCommand_Feedback_StandingState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StandCommand_Feedback_StandingState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StandCommand_Feedback_StandingState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StandCommand_Feedback_StandingState_descriptor(), enum_t_value);
}
inline bool StandCommand_Feedback_StandingState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StandCommand_Feedback_StandingState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StandCommand_Feedback_StandingState>(
    StandCommand_Feedback_StandingState_descriptor(), name, value);
}
enum StanceCommand_Feedback_Status : int {
  StanceCommand_Feedback_Status_STATUS_UNKNOWN = 0,
  StanceCommand_Feedback_Status_STATUS_STANCED = 1,
  StanceCommand_Feedback_Status_STATUS_GOING_TO_STANCE = 2,
  StanceCommand_Feedback_Status_STATUS_TOO_FAR_AWAY = 3,
  StanceCommand_Feedback_Status_StanceCommand_Feedback_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StanceCommand_Feedback_Status_StanceCommand_Feedback_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StanceCommand_Feedback_Status_IsValid(int value);
constexpr StanceCommand_Feedback_Status StanceCommand_Feedback_Status_Status_MIN = StanceCommand_Feedback_Status_STATUS_UNKNOWN;
constexpr StanceCommand_Feedback_Status StanceCommand_Feedback_Status_Status_MAX = StanceCommand_Feedback_Status_STATUS_TOO_FAR_AWAY;
constexpr int StanceCommand_Feedback_Status_Status_ARRAYSIZE = StanceCommand_Feedback_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StanceCommand_Feedback_Status_descriptor();
template<typename T>
inline const std::string& StanceCommand_Feedback_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StanceCommand_Feedback_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StanceCommand_Feedback_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StanceCommand_Feedback_Status_descriptor(), enum_t_value);
}
inline bool StanceCommand_Feedback_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StanceCommand_Feedback_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StanceCommand_Feedback_Status>(
    StanceCommand_Feedback_Status_descriptor(), name, value);
}
enum ArmDragCommand_Feedback_Status : int {
  ArmDragCommand_Feedback_Status_STATUS_UNKNOWN = 0,
  ArmDragCommand_Feedback_Status_STATUS_DRAGGING = 1,
  ArmDragCommand_Feedback_Status_STATUS_GRASP_FAILED = 2,
  ArmDragCommand_Feedback_Status_STATUS_OTHER_FAILURE = 3,
  ArmDragCommand_Feedback_Status_ArmDragCommand_Feedback_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ArmDragCommand_Feedback_Status_ArmDragCommand_Feedback_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ArmDragCommand_Feedback_Status_IsValid(int value);
constexpr ArmDragCommand_Feedback_Status ArmDragCommand_Feedback_Status_Status_MIN = ArmDragCommand_Feedback_Status_STATUS_UNKNOWN;
constexpr ArmDragCommand_Feedback_Status ArmDragCommand_Feedback_Status_Status_MAX = ArmDragCommand_Feedback_Status_STATUS_OTHER_FAILURE;
constexpr int ArmDragCommand_Feedback_Status_Status_ARRAYSIZE = ArmDragCommand_Feedback_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArmDragCommand_Feedback_Status_descriptor();
template<typename T>
inline const std::string& ArmDragCommand_Feedback_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArmDragCommand_Feedback_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArmDragCommand_Feedback_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ArmDragCommand_Feedback_Status_descriptor(), enum_t_value);
}
inline bool ArmDragCommand_Feedback_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ArmDragCommand_Feedback_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArmDragCommand_Feedback_Status>(
    ArmDragCommand_Feedback_Status_descriptor(), name, value);
}
enum ConstrainedManipulationCommand_Request_TaskType : int {
  ConstrainedManipulationCommand_Request_TaskType_TASK_TYPE_UNKNOWN = 0,
  ConstrainedManipulationCommand_Request_TaskType_TASK_TYPE_SE3_CIRCLE_FORCE_TORQUE = 1,
  ConstrainedManipulationCommand_Request_TaskType_TASK_TYPE_R3_CIRCLE_EXTRADOF_FORCE = 2,
  ConstrainedManipulationCommand_Request_TaskType_TASK_TYPE_SE3_ROTATIONAL_TORQUE = 3,
  ConstrainedManipulationCommand_Request_TaskType_TASK_TYPE_R3_CIRCLE_FORCE = 4,
  ConstrainedManipulationCommand_Request_TaskType_TASK_TYPE_R3_LINEAR_FORCE = 5,
  ConstrainedManipulationCommand_Request_TaskType_TASK_TYPE_HOLD_POSE = 6,
  ConstrainedManipulationCommand_Request_TaskType_ConstrainedManipulationCommand_Request_TaskType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConstrainedManipulationCommand_Request_TaskType_ConstrainedManipulationCommand_Request_TaskType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConstrainedManipulationCommand_Request_TaskType_IsValid(int value);
constexpr ConstrainedManipulationCommand_Request_TaskType ConstrainedManipulationCommand_Request_TaskType_TaskType_MIN = ConstrainedManipulationCommand_Request_TaskType_TASK_TYPE_UNKNOWN;
constexpr ConstrainedManipulationCommand_Request_TaskType ConstrainedManipulationCommand_Request_TaskType_TaskType_MAX = ConstrainedManipulationCommand_Request_TaskType_TASK_TYPE_HOLD_POSE;
constexpr int ConstrainedManipulationCommand_Request_TaskType_TaskType_ARRAYSIZE = ConstrainedManipulationCommand_Request_TaskType_TaskType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConstrainedManipulationCommand_Request_TaskType_descriptor();
template<typename T>
inline const std::string& ConstrainedManipulationCommand_Request_TaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConstrainedManipulationCommand_Request_TaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConstrainedManipulationCommand_Request_TaskType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConstrainedManipulationCommand_Request_TaskType_descriptor(), enum_t_value);
}
inline bool ConstrainedManipulationCommand_Request_TaskType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConstrainedManipulationCommand_Request_TaskType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConstrainedManipulationCommand_Request_TaskType>(
    ConstrainedManipulationCommand_Request_TaskType_descriptor(), name, value);
}
enum ConstrainedManipulationCommand_Feedback_Status : int {
  ConstrainedManipulationCommand_Feedback_Status_STATUS_UNKNOWN = 0,
  ConstrainedManipulationCommand_Feedback_Status_STATUS_RUNNING = 1,
  ConstrainedManipulationCommand_Feedback_Status_STATUS_ARM_IS_STUCK = 2,
  ConstrainedManipulationCommand_Feedback_Status_STATUS_GRASP_IS_LOST = 3,
  ConstrainedManipulationCommand_Feedback_Status_ConstrainedManipulationCommand_Feedback_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConstrainedManipulationCommand_Feedback_Status_ConstrainedManipulationCommand_Feedback_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConstrainedManipulationCommand_Feedback_Status_IsValid(int value);
constexpr ConstrainedManipulationCommand_Feedback_Status ConstrainedManipulationCommand_Feedback_Status_Status_MIN = ConstrainedManipulationCommand_Feedback_Status_STATUS_UNKNOWN;
constexpr ConstrainedManipulationCommand_Feedback_Status ConstrainedManipulationCommand_Feedback_Status_Status_MAX = ConstrainedManipulationCommand_Feedback_Status_STATUS_GRASP_IS_LOST;
constexpr int ConstrainedManipulationCommand_Feedback_Status_Status_ARRAYSIZE = ConstrainedManipulationCommand_Feedback_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConstrainedManipulationCommand_Feedback_Status_descriptor();
template<typename T>
inline const std::string& ConstrainedManipulationCommand_Feedback_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConstrainedManipulationCommand_Feedback_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConstrainedManipulationCommand_Feedback_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConstrainedManipulationCommand_Feedback_Status_descriptor(), enum_t_value);
}
inline bool ConstrainedManipulationCommand_Feedback_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConstrainedManipulationCommand_Feedback_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConstrainedManipulationCommand_Feedback_Status>(
    ConstrainedManipulationCommand_Feedback_Status_descriptor(), name, value);
}
// ===================================================================

class RobotCommandFeedbackStatus final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotCommandFeedbackStatus) */ {
 public:
  inline RobotCommandFeedbackStatus() : RobotCommandFeedbackStatus(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RobotCommandFeedbackStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotCommandFeedbackStatus(const RobotCommandFeedbackStatus& from);
  RobotCommandFeedbackStatus(RobotCommandFeedbackStatus&& from) noexcept
    : RobotCommandFeedbackStatus() {
    *this = ::std::move(from);
  }

  inline RobotCommandFeedbackStatus& operator=(const RobotCommandFeedbackStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotCommandFeedbackStatus& operator=(RobotCommandFeedbackStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotCommandFeedbackStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotCommandFeedbackStatus* internal_default_instance() {
    return reinterpret_cast<const RobotCommandFeedbackStatus*>(
               &_RobotCommandFeedbackStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RobotCommandFeedbackStatus& a, RobotCommandFeedbackStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotCommandFeedbackStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotCommandFeedbackStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotCommandFeedbackStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotCommandFeedbackStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RobotCommandFeedbackStatus& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RobotCommandFeedbackStatus& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotCommandFeedbackStatus";
  }
  protected:
  explicit RobotCommandFeedbackStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RobotCommandFeedbackStatus_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    RobotCommandFeedbackStatus_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_PROCESSING =
    RobotCommandFeedbackStatus_Status_STATUS_PROCESSING;
  static constexpr Status STATUS_COMMAND_OVERRIDDEN =
    RobotCommandFeedbackStatus_Status_STATUS_COMMAND_OVERRIDDEN;
  static constexpr Status STATUS_COMMAND_TIMED_OUT =
    RobotCommandFeedbackStatus_Status_STATUS_COMMAND_TIMED_OUT;
  static constexpr Status STATUS_ROBOT_FROZEN =
    RobotCommandFeedbackStatus_Status_STATUS_ROBOT_FROZEN;
  static constexpr Status STATUS_INCOMPATIBLE_HARDWARE =
    RobotCommandFeedbackStatus_Status_STATUS_INCOMPATIBLE_HARDWARE;
  static inline bool Status_IsValid(int value) {
    return RobotCommandFeedbackStatus_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    RobotCommandFeedbackStatus_Status_Status_MIN;
  static constexpr Status Status_MAX =
    RobotCommandFeedbackStatus_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    RobotCommandFeedbackStatus_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return RobotCommandFeedbackStatus_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return RobotCommandFeedbackStatus_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return RobotCommandFeedbackStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotCommandFeedbackStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class BatteryChangePoseCommand_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.BatteryChangePoseCommand.Request) */ {
 public:
  inline BatteryChangePoseCommand_Request() : BatteryChangePoseCommand_Request(nullptr) {}
  ~BatteryChangePoseCommand_Request() override;
  explicit PROTOBUF_CONSTEXPR BatteryChangePoseCommand_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatteryChangePoseCommand_Request(const BatteryChangePoseCommand_Request& from);
  BatteryChangePoseCommand_Request(BatteryChangePoseCommand_Request&& from) noexcept
    : BatteryChangePoseCommand_Request() {
    *this = ::std::move(from);
  }

  inline BatteryChangePoseCommand_Request& operator=(const BatteryChangePoseCommand_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatteryChangePoseCommand_Request& operator=(BatteryChangePoseCommand_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatteryChangePoseCommand_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatteryChangePoseCommand_Request* internal_default_instance() {
    return reinterpret_cast<const BatteryChangePoseCommand_Request*>(
               &_BatteryChangePoseCommand_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BatteryChangePoseCommand_Request& a, BatteryChangePoseCommand_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(BatteryChangePoseCommand_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatteryChangePoseCommand_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatteryChangePoseCommand_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatteryChangePoseCommand_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatteryChangePoseCommand_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatteryChangePoseCommand_Request& from) {
    BatteryChangePoseCommand_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatteryChangePoseCommand_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.BatteryChangePoseCommand.Request";
  }
  protected:
  explicit BatteryChangePoseCommand_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BatteryChangePoseCommand_Request_DirectionHint DirectionHint;
  static constexpr DirectionHint HINT_UNKNOWN =
    BatteryChangePoseCommand_Request_DirectionHint_HINT_UNKNOWN;
  static constexpr DirectionHint HINT_RIGHT =
    BatteryChangePoseCommand_Request_DirectionHint_HINT_RIGHT;
  static constexpr DirectionHint HINT_LEFT =
    BatteryChangePoseCommand_Request_DirectionHint_HINT_LEFT;
  static inline bool DirectionHint_IsValid(int value) {
    return BatteryChangePoseCommand_Request_DirectionHint_IsValid(value);
  }
  static constexpr DirectionHint DirectionHint_MIN =
    BatteryChangePoseCommand_Request_DirectionHint_DirectionHint_MIN;
  static constexpr DirectionHint DirectionHint_MAX =
    BatteryChangePoseCommand_Request_DirectionHint_DirectionHint_MAX;
  static constexpr int DirectionHint_ARRAYSIZE =
    BatteryChangePoseCommand_Request_DirectionHint_DirectionHint_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DirectionHint_descriptor() {
    return BatteryChangePoseCommand_Request_DirectionHint_descriptor();
  }
  template<typename T>
  static inline const std::string& DirectionHint_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DirectionHint>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DirectionHint_Name.");
    return BatteryChangePoseCommand_Request_DirectionHint_Name(enum_t_value);
  }
  static inline bool DirectionHint_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DirectionHint* value) {
    return BatteryChangePoseCommand_Request_DirectionHint_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionHintFieldNumber = 1,
  };
  // .bosdyn.api.BatteryChangePoseCommand.Request.DirectionHint direction_hint = 1;
  void clear_direction_hint();
  ::bosdyn::api::BatteryChangePoseCommand_Request_DirectionHint direction_hint() const;
  void set_direction_hint(::bosdyn::api::BatteryChangePoseCommand_Request_DirectionHint value);
  private:
  ::bosdyn::api::BatteryChangePoseCommand_Request_DirectionHint _internal_direction_hint() const;
  void _internal_set_direction_hint(::bosdyn::api::BatteryChangePoseCommand_Request_DirectionHint value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.BatteryChangePoseCommand.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int direction_hint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class BatteryChangePoseCommand_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.BatteryChangePoseCommand.Feedback) */ {
 public:
  inline BatteryChangePoseCommand_Feedback() : BatteryChangePoseCommand_Feedback(nullptr) {}
  ~BatteryChangePoseCommand_Feedback() override;
  explicit PROTOBUF_CONSTEXPR BatteryChangePoseCommand_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatteryChangePoseCommand_Feedback(const BatteryChangePoseCommand_Feedback& from);
  BatteryChangePoseCommand_Feedback(BatteryChangePoseCommand_Feedback&& from) noexcept
    : BatteryChangePoseCommand_Feedback() {
    *this = ::std::move(from);
  }

  inline BatteryChangePoseCommand_Feedback& operator=(const BatteryChangePoseCommand_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatteryChangePoseCommand_Feedback& operator=(BatteryChangePoseCommand_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatteryChangePoseCommand_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatteryChangePoseCommand_Feedback* internal_default_instance() {
    return reinterpret_cast<const BatteryChangePoseCommand_Feedback*>(
               &_BatteryChangePoseCommand_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BatteryChangePoseCommand_Feedback& a, BatteryChangePoseCommand_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(BatteryChangePoseCommand_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatteryChangePoseCommand_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatteryChangePoseCommand_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatteryChangePoseCommand_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatteryChangePoseCommand_Feedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatteryChangePoseCommand_Feedback& from) {
    BatteryChangePoseCommand_Feedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatteryChangePoseCommand_Feedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.BatteryChangePoseCommand.Feedback";
  }
  protected:
  explicit BatteryChangePoseCommand_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BatteryChangePoseCommand_Feedback_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    BatteryChangePoseCommand_Feedback_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_COMPLETED =
    BatteryChangePoseCommand_Feedback_Status_STATUS_COMPLETED;
  static constexpr Status STATUS_IN_PROGRESS =
    BatteryChangePoseCommand_Feedback_Status_STATUS_IN_PROGRESS;
  static constexpr Status STATUS_FAILED =
    BatteryChangePoseCommand_Feedback_Status_STATUS_FAILED;
  static inline bool Status_IsValid(int value) {
    return BatteryChangePoseCommand_Feedback_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    BatteryChangePoseCommand_Feedback_Status_Status_MIN;
  static constexpr Status Status_MAX =
    BatteryChangePoseCommand_Feedback_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    BatteryChangePoseCommand_Feedback_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return BatteryChangePoseCommand_Feedback_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return BatteryChangePoseCommand_Feedback_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return BatteryChangePoseCommand_Feedback_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .bosdyn.api.BatteryChangePoseCommand.Feedback.Status status = 1;
  void clear_status();
  ::bosdyn::api::BatteryChangePoseCommand_Feedback_Status status() const;
  void set_status(::bosdyn::api::BatteryChangePoseCommand_Feedback_Status value);
  private:
  ::bosdyn::api::BatteryChangePoseCommand_Feedback_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::BatteryChangePoseCommand_Feedback_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.BatteryChangePoseCommand.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class BatteryChangePoseCommand final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.BatteryChangePoseCommand) */ {
 public:
  inline BatteryChangePoseCommand() : BatteryChangePoseCommand(nullptr) {}
  explicit PROTOBUF_CONSTEXPR BatteryChangePoseCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatteryChangePoseCommand(const BatteryChangePoseCommand& from);
  BatteryChangePoseCommand(BatteryChangePoseCommand&& from) noexcept
    : BatteryChangePoseCommand() {
    *this = ::std::move(from);
  }

  inline BatteryChangePoseCommand& operator=(const BatteryChangePoseCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatteryChangePoseCommand& operator=(BatteryChangePoseCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatteryChangePoseCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatteryChangePoseCommand* internal_default_instance() {
    return reinterpret_cast<const BatteryChangePoseCommand*>(
               &_BatteryChangePoseCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BatteryChangePoseCommand& a, BatteryChangePoseCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(BatteryChangePoseCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatteryChangePoseCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatteryChangePoseCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatteryChangePoseCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BatteryChangePoseCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BatteryChangePoseCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.BatteryChangePoseCommand";
  }
  protected:
  explicit BatteryChangePoseCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BatteryChangePoseCommand_Request Request;
  typedef BatteryChangePoseCommand_Feedback Feedback;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.BatteryChangePoseCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SelfRightCommand_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.SelfRightCommand.Request) */ {
 public:
  inline SelfRightCommand_Request() : SelfRightCommand_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SelfRightCommand_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelfRightCommand_Request(const SelfRightCommand_Request& from);
  SelfRightCommand_Request(SelfRightCommand_Request&& from) noexcept
    : SelfRightCommand_Request() {
    *this = ::std::move(from);
  }

  inline SelfRightCommand_Request& operator=(const SelfRightCommand_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelfRightCommand_Request& operator=(SelfRightCommand_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelfRightCommand_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelfRightCommand_Request* internal_default_instance() {
    return reinterpret_cast<const SelfRightCommand_Request*>(
               &_SelfRightCommand_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SelfRightCommand_Request& a, SelfRightCommand_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(SelfRightCommand_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelfRightCommand_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelfRightCommand_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelfRightCommand_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SelfRightCommand_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SelfRightCommand_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SelfRightCommand.Request";
  }
  protected:
  explicit SelfRightCommand_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.SelfRightCommand.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SelfRightCommand_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SelfRightCommand.Feedback) */ {
 public:
  inline SelfRightCommand_Feedback() : SelfRightCommand_Feedback(nullptr) {}
  ~SelfRightCommand_Feedback() override;
  explicit PROTOBUF_CONSTEXPR SelfRightCommand_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelfRightCommand_Feedback(const SelfRightCommand_Feedback& from);
  SelfRightCommand_Feedback(SelfRightCommand_Feedback&& from) noexcept
    : SelfRightCommand_Feedback() {
    *this = ::std::move(from);
  }

  inline SelfRightCommand_Feedback& operator=(const SelfRightCommand_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelfRightCommand_Feedback& operator=(SelfRightCommand_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelfRightCommand_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelfRightCommand_Feedback* internal_default_instance() {
    return reinterpret_cast<const SelfRightCommand_Feedback*>(
               &_SelfRightCommand_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SelfRightCommand_Feedback& a, SelfRightCommand_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(SelfRightCommand_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelfRightCommand_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelfRightCommand_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelfRightCommand_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelfRightCommand_Feedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelfRightCommand_Feedback& from) {
    SelfRightCommand_Feedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelfRightCommand_Feedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SelfRightCommand.Feedback";
  }
  protected:
  explicit SelfRightCommand_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SelfRightCommand_Feedback_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    SelfRightCommand_Feedback_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_COMPLETED =
    SelfRightCommand_Feedback_Status_STATUS_COMPLETED;
  static constexpr Status STATUS_IN_PROGRESS =
    SelfRightCommand_Feedback_Status_STATUS_IN_PROGRESS;
  static inline bool Status_IsValid(int value) {
    return SelfRightCommand_Feedback_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    SelfRightCommand_Feedback_Status_Status_MIN;
  static constexpr Status Status_MAX =
    SelfRightCommand_Feedback_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    SelfRightCommand_Feedback_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return SelfRightCommand_Feedback_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return SelfRightCommand_Feedback_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return SelfRightCommand_Feedback_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .bosdyn.api.SelfRightCommand.Feedback.Status status = 1;
  void clear_status();
  ::bosdyn::api::SelfRightCommand_Feedback_Status status() const;
  void set_status(::bosdyn::api::SelfRightCommand_Feedback_Status value);
  private:
  ::bosdyn::api::SelfRightCommand_Feedback_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::SelfRightCommand_Feedback_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SelfRightCommand.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SelfRightCommand final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.SelfRightCommand) */ {
 public:
  inline SelfRightCommand() : SelfRightCommand(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SelfRightCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelfRightCommand(const SelfRightCommand& from);
  SelfRightCommand(SelfRightCommand&& from) noexcept
    : SelfRightCommand() {
    *this = ::std::move(from);
  }

  inline SelfRightCommand& operator=(const SelfRightCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelfRightCommand& operator=(SelfRightCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelfRightCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelfRightCommand* internal_default_instance() {
    return reinterpret_cast<const SelfRightCommand*>(
               &_SelfRightCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SelfRightCommand& a, SelfRightCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SelfRightCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelfRightCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelfRightCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelfRightCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SelfRightCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SelfRightCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SelfRightCommand";
  }
  protected:
  explicit SelfRightCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SelfRightCommand_Request Request;
  typedef SelfRightCommand_Feedback Feedback;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.SelfRightCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class StopCommand_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.StopCommand.Request) */ {
 public:
  inline StopCommand_Request() : StopCommand_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR StopCommand_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopCommand_Request(const StopCommand_Request& from);
  StopCommand_Request(StopCommand_Request&& from) noexcept
    : StopCommand_Request() {
    *this = ::std::move(from);
  }

  inline StopCommand_Request& operator=(const StopCommand_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopCommand_Request& operator=(StopCommand_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopCommand_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopCommand_Request* internal_default_instance() {
    return reinterpret_cast<const StopCommand_Request*>(
               &_StopCommand_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StopCommand_Request& a, StopCommand_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(StopCommand_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopCommand_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopCommand_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopCommand_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopCommand_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopCommand_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StopCommand.Request";
  }
  protected:
  explicit StopCommand_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.StopCommand.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class StopCommand_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.StopCommand.Feedback) */ {
 public:
  inline StopCommand_Feedback() : StopCommand_Feedback(nullptr) {}
  explicit PROTOBUF_CONSTEXPR StopCommand_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopCommand_Feedback(const StopCommand_Feedback& from);
  StopCommand_Feedback(StopCommand_Feedback&& from) noexcept
    : StopCommand_Feedback() {
    *this = ::std::move(from);
  }

  inline StopCommand_Feedback& operator=(const StopCommand_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopCommand_Feedback& operator=(StopCommand_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopCommand_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopCommand_Feedback* internal_default_instance() {
    return reinterpret_cast<const StopCommand_Feedback*>(
               &_StopCommand_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StopCommand_Feedback& a, StopCommand_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(StopCommand_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopCommand_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopCommand_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopCommand_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopCommand_Feedback& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopCommand_Feedback& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StopCommand.Feedback";
  }
  protected:
  explicit StopCommand_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.StopCommand.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class StopCommand final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.StopCommand) */ {
 public:
  inline StopCommand() : StopCommand(nullptr) {}
  explicit PROTOBUF_CONSTEXPR StopCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopCommand(const StopCommand& from);
  StopCommand(StopCommand&& from) noexcept
    : StopCommand() {
    *this = ::std::move(from);
  }

  inline StopCommand& operator=(const StopCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopCommand& operator=(StopCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopCommand* internal_default_instance() {
    return reinterpret_cast<const StopCommand*>(
               &_StopCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StopCommand& a, StopCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(StopCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StopCommand";
  }
  protected:
  explicit StopCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StopCommand_Request Request;
  typedef StopCommand_Feedback Feedback;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.StopCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class FreezeCommand_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.FreezeCommand.Request) */ {
 public:
  inline FreezeCommand_Request() : FreezeCommand_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FreezeCommand_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FreezeCommand_Request(const FreezeCommand_Request& from);
  FreezeCommand_Request(FreezeCommand_Request&& from) noexcept
    : FreezeCommand_Request() {
    *this = ::std::move(from);
  }

  inline FreezeCommand_Request& operator=(const FreezeCommand_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreezeCommand_Request& operator=(FreezeCommand_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FreezeCommand_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const FreezeCommand_Request* internal_default_instance() {
    return reinterpret_cast<const FreezeCommand_Request*>(
               &_FreezeCommand_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FreezeCommand_Request& a, FreezeCommand_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(FreezeCommand_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreezeCommand_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FreezeCommand_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FreezeCommand_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FreezeCommand_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FreezeCommand_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FreezeCommand.Request";
  }
  protected:
  explicit FreezeCommand_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.FreezeCommand.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class FreezeCommand_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.FreezeCommand.Feedback) */ {
 public:
  inline FreezeCommand_Feedback() : FreezeCommand_Feedback(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FreezeCommand_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FreezeCommand_Feedback(const FreezeCommand_Feedback& from);
  FreezeCommand_Feedback(FreezeCommand_Feedback&& from) noexcept
    : FreezeCommand_Feedback() {
    *this = ::std::move(from);
  }

  inline FreezeCommand_Feedback& operator=(const FreezeCommand_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreezeCommand_Feedback& operator=(FreezeCommand_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FreezeCommand_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const FreezeCommand_Feedback* internal_default_instance() {
    return reinterpret_cast<const FreezeCommand_Feedback*>(
               &_FreezeCommand_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FreezeCommand_Feedback& a, FreezeCommand_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(FreezeCommand_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreezeCommand_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FreezeCommand_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FreezeCommand_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FreezeCommand_Feedback& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FreezeCommand_Feedback& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FreezeCommand.Feedback";
  }
  protected:
  explicit FreezeCommand_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.FreezeCommand.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class FreezeCommand final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.FreezeCommand) */ {
 public:
  inline FreezeCommand() : FreezeCommand(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FreezeCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FreezeCommand(const FreezeCommand& from);
  FreezeCommand(FreezeCommand&& from) noexcept
    : FreezeCommand() {
    *this = ::std::move(from);
  }

  inline FreezeCommand& operator=(const FreezeCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreezeCommand& operator=(FreezeCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FreezeCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const FreezeCommand* internal_default_instance() {
    return reinterpret_cast<const FreezeCommand*>(
               &_FreezeCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FreezeCommand& a, FreezeCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(FreezeCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreezeCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FreezeCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FreezeCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FreezeCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FreezeCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FreezeCommand";
  }
  protected:
  explicit FreezeCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FreezeCommand_Request Request;
  typedef FreezeCommand_Feedback Feedback;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.FreezeCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SafePowerOffCommand_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SafePowerOffCommand.Request) */ {
 public:
  inline SafePowerOffCommand_Request() : SafePowerOffCommand_Request(nullptr) {}
  ~SafePowerOffCommand_Request() override;
  explicit PROTOBUF_CONSTEXPR SafePowerOffCommand_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SafePowerOffCommand_Request(const SafePowerOffCommand_Request& from);
  SafePowerOffCommand_Request(SafePowerOffCommand_Request&& from) noexcept
    : SafePowerOffCommand_Request() {
    *this = ::std::move(from);
  }

  inline SafePowerOffCommand_Request& operator=(const SafePowerOffCommand_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline SafePowerOffCommand_Request& operator=(SafePowerOffCommand_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SafePowerOffCommand_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const SafePowerOffCommand_Request* internal_default_instance() {
    return reinterpret_cast<const SafePowerOffCommand_Request*>(
               &_SafePowerOffCommand_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SafePowerOffCommand_Request& a, SafePowerOffCommand_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(SafePowerOffCommand_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SafePowerOffCommand_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SafePowerOffCommand_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SafePowerOffCommand_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SafePowerOffCommand_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SafePowerOffCommand_Request& from) {
    SafePowerOffCommand_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SafePowerOffCommand_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SafePowerOffCommand.Request";
  }
  protected:
  explicit SafePowerOffCommand_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SafePowerOffCommand_Request_UnsafeAction UnsafeAction;
  static constexpr UnsafeAction UNSAFE_UNKNOWN =
    SafePowerOffCommand_Request_UnsafeAction_UNSAFE_UNKNOWN;
  static constexpr UnsafeAction UNSAFE_MOVE_TO_SAFE_POSITION =
    SafePowerOffCommand_Request_UnsafeAction_UNSAFE_MOVE_TO_SAFE_POSITION;
  static constexpr UnsafeAction UNSAFE_FORCE_COMMAND =
    SafePowerOffCommand_Request_UnsafeAction_UNSAFE_FORCE_COMMAND;
  static inline bool UnsafeAction_IsValid(int value) {
    return SafePowerOffCommand_Request_UnsafeAction_IsValid(value);
  }
  static constexpr UnsafeAction UnsafeAction_MIN =
    SafePowerOffCommand_Request_UnsafeAction_UnsafeAction_MIN;
  static constexpr UnsafeAction UnsafeAction_MAX =
    SafePowerOffCommand_Request_UnsafeAction_UnsafeAction_MAX;
  static constexpr int UnsafeAction_ARRAYSIZE =
    SafePowerOffCommand_Request_UnsafeAction_UnsafeAction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UnsafeAction_descriptor() {
    return SafePowerOffCommand_Request_UnsafeAction_descriptor();
  }
  template<typename T>
  static inline const std::string& UnsafeAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UnsafeAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UnsafeAction_Name.");
    return SafePowerOffCommand_Request_UnsafeAction_Name(enum_t_value);
  }
  static inline bool UnsafeAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UnsafeAction* value) {
    return SafePowerOffCommand_Request_UnsafeAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUnsafeActionFieldNumber = 1,
  };
  // .bosdyn.api.SafePowerOffCommand.Request.UnsafeAction unsafe_action = 1;
  void clear_unsafe_action();
  ::bosdyn::api::SafePowerOffCommand_Request_UnsafeAction unsafe_action() const;
  void set_unsafe_action(::bosdyn::api::SafePowerOffCommand_Request_UnsafeAction value);
  private:
  ::bosdyn::api::SafePowerOffCommand_Request_UnsafeAction _internal_unsafe_action() const;
  void _internal_set_unsafe_action(::bosdyn::api::SafePowerOffCommand_Request_UnsafeAction value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SafePowerOffCommand.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int unsafe_action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SafePowerOffCommand_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SafePowerOffCommand.Feedback) */ {
 public:
  inline SafePowerOffCommand_Feedback() : SafePowerOffCommand_Feedback(nullptr) {}
  ~SafePowerOffCommand_Feedback() override;
  explicit PROTOBUF_CONSTEXPR SafePowerOffCommand_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SafePowerOffCommand_Feedback(const SafePowerOffCommand_Feedback& from);
  SafePowerOffCommand_Feedback(SafePowerOffCommand_Feedback&& from) noexcept
    : SafePowerOffCommand_Feedback() {
    *this = ::std::move(from);
  }

  inline SafePowerOffCommand_Feedback& operator=(const SafePowerOffCommand_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline SafePowerOffCommand_Feedback& operator=(SafePowerOffCommand_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SafePowerOffCommand_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const SafePowerOffCommand_Feedback* internal_default_instance() {
    return reinterpret_cast<const SafePowerOffCommand_Feedback*>(
               &_SafePowerOffCommand_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SafePowerOffCommand_Feedback& a, SafePowerOffCommand_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(SafePowerOffCommand_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SafePowerOffCommand_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SafePowerOffCommand_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SafePowerOffCommand_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SafePowerOffCommand_Feedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SafePowerOffCommand_Feedback& from) {
    SafePowerOffCommand_Feedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SafePowerOffCommand_Feedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SafePowerOffCommand.Feedback";
  }
  protected:
  explicit SafePowerOffCommand_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SafePowerOffCommand_Feedback_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    SafePowerOffCommand_Feedback_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_POWERED_OFF =
    SafePowerOffCommand_Feedback_Status_STATUS_POWERED_OFF;
  static constexpr Status STATUS_IN_PROGRESS =
    SafePowerOffCommand_Feedback_Status_STATUS_IN_PROGRESS;
  static inline bool Status_IsValid(int value) {
    return SafePowerOffCommand_Feedback_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    SafePowerOffCommand_Feedback_Status_Status_MIN;
  static constexpr Status Status_MAX =
    SafePowerOffCommand_Feedback_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    SafePowerOffCommand_Feedback_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return SafePowerOffCommand_Feedback_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return SafePowerOffCommand_Feedback_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return SafePowerOffCommand_Feedback_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .bosdyn.api.SafePowerOffCommand.Feedback.Status status = 1;
  void clear_status();
  ::bosdyn::api::SafePowerOffCommand_Feedback_Status status() const;
  void set_status(::bosdyn::api::SafePowerOffCommand_Feedback_Status value);
  private:
  ::bosdyn::api::SafePowerOffCommand_Feedback_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::SafePowerOffCommand_Feedback_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SafePowerOffCommand.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SafePowerOffCommand final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.SafePowerOffCommand) */ {
 public:
  inline SafePowerOffCommand() : SafePowerOffCommand(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SafePowerOffCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SafePowerOffCommand(const SafePowerOffCommand& from);
  SafePowerOffCommand(SafePowerOffCommand&& from) noexcept
    : SafePowerOffCommand() {
    *this = ::std::move(from);
  }

  inline SafePowerOffCommand& operator=(const SafePowerOffCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SafePowerOffCommand& operator=(SafePowerOffCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SafePowerOffCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const SafePowerOffCommand* internal_default_instance() {
    return reinterpret_cast<const SafePowerOffCommand*>(
               &_SafePowerOffCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SafePowerOffCommand& a, SafePowerOffCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SafePowerOffCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SafePowerOffCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SafePowerOffCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SafePowerOffCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SafePowerOffCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SafePowerOffCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SafePowerOffCommand";
  }
  protected:
  explicit SafePowerOffCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SafePowerOffCommand_Request Request;
  typedef SafePowerOffCommand_Feedback Feedback;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.SafePowerOffCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SE2TrajectoryCommand_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SE2TrajectoryCommand.Request) */ {
 public:
  inline SE2TrajectoryCommand_Request() : SE2TrajectoryCommand_Request(nullptr) {}
  ~SE2TrajectoryCommand_Request() override;
  explicit PROTOBUF_CONSTEXPR SE2TrajectoryCommand_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE2TrajectoryCommand_Request(const SE2TrajectoryCommand_Request& from);
  SE2TrajectoryCommand_Request(SE2TrajectoryCommand_Request&& from) noexcept
    : SE2TrajectoryCommand_Request() {
    *this = ::std::move(from);
  }

  inline SE2TrajectoryCommand_Request& operator=(const SE2TrajectoryCommand_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE2TrajectoryCommand_Request& operator=(SE2TrajectoryCommand_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE2TrajectoryCommand_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE2TrajectoryCommand_Request* internal_default_instance() {
    return reinterpret_cast<const SE2TrajectoryCommand_Request*>(
               &_SE2TrajectoryCommand_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SE2TrajectoryCommand_Request& a, SE2TrajectoryCommand_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(SE2TrajectoryCommand_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE2TrajectoryCommand_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SE2TrajectoryCommand_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SE2TrajectoryCommand_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SE2TrajectoryCommand_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SE2TrajectoryCommand_Request& from) {
    SE2TrajectoryCommand_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE2TrajectoryCommand_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE2TrajectoryCommand.Request";
  }
  protected:
  explicit SE2TrajectoryCommand_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSe2FrameNameFieldNumber = 3,
    kEndTimeFieldNumber = 1,
    kTrajectoryFieldNumber = 2,
  };
  // string se2_frame_name = 3;
  void clear_se2_frame_name();
  const std::string& se2_frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_se2_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_se2_frame_name();
  PROTOBUF_NODISCARD std::string* release_se2_frame_name();
  void set_allocated_se2_frame_name(std::string* se2_frame_name);
  private:
  const std::string& _internal_se2_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_se2_frame_name(const std::string& value);
  std::string* _internal_mutable_se2_frame_name();
  public:

  // .google.protobuf.Timestamp end_time = 1;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // .bosdyn.api.SE2Trajectory trajectory = 2;
  bool has_trajectory() const;
  private:
  bool _internal_has_trajectory() const;
  public:
  void clear_trajectory();
  const ::bosdyn::api::SE2Trajectory& trajectory() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE2Trajectory* release_trajectory();
  ::bosdyn::api::SE2Trajectory* mutable_trajectory();
  void set_allocated_trajectory(::bosdyn::api::SE2Trajectory* trajectory);
  private:
  const ::bosdyn::api::SE2Trajectory& _internal_trajectory() const;
  ::bosdyn::api::SE2Trajectory* _internal_mutable_trajectory();
  public:
  void unsafe_arena_set_allocated_trajectory(
      ::bosdyn::api::SE2Trajectory* trajectory);
  ::bosdyn::api::SE2Trajectory* unsafe_arena_release_trajectory();

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE2TrajectoryCommand.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr se2_frame_name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    ::bosdyn::api::SE2Trajectory* trajectory_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SE2TrajectoryCommand_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SE2TrajectoryCommand.Feedback) */ {
 public:
  inline SE2TrajectoryCommand_Feedback() : SE2TrajectoryCommand_Feedback(nullptr) {}
  ~SE2TrajectoryCommand_Feedback() override;
  explicit PROTOBUF_CONSTEXPR SE2TrajectoryCommand_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE2TrajectoryCommand_Feedback(const SE2TrajectoryCommand_Feedback& from);
  SE2TrajectoryCommand_Feedback(SE2TrajectoryCommand_Feedback&& from) noexcept
    : SE2TrajectoryCommand_Feedback() {
    *this = ::std::move(from);
  }

  inline SE2TrajectoryCommand_Feedback& operator=(const SE2TrajectoryCommand_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE2TrajectoryCommand_Feedback& operator=(SE2TrajectoryCommand_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE2TrajectoryCommand_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE2TrajectoryCommand_Feedback* internal_default_instance() {
    return reinterpret_cast<const SE2TrajectoryCommand_Feedback*>(
               &_SE2TrajectoryCommand_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SE2TrajectoryCommand_Feedback& a, SE2TrajectoryCommand_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(SE2TrajectoryCommand_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE2TrajectoryCommand_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SE2TrajectoryCommand_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SE2TrajectoryCommand_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SE2TrajectoryCommand_Feedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SE2TrajectoryCommand_Feedback& from) {
    SE2TrajectoryCommand_Feedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE2TrajectoryCommand_Feedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE2TrajectoryCommand.Feedback";
  }
  protected:
  explicit SE2TrajectoryCommand_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SE2TrajectoryCommand_Feedback_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    SE2TrajectoryCommand_Feedback_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_AT_GOAL =
    SE2TrajectoryCommand_Feedback_Status_STATUS_AT_GOAL;
  static constexpr Status STATUS_NEAR_GOAL =
    SE2TrajectoryCommand_Feedback_Status_STATUS_NEAR_GOAL;
  static constexpr Status STATUS_GOING_TO_GOAL =
    SE2TrajectoryCommand_Feedback_Status_STATUS_GOING_TO_GOAL;
  static inline bool Status_IsValid(int value) {
    return SE2TrajectoryCommand_Feedback_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    SE2TrajectoryCommand_Feedback_Status_Status_MIN;
  static constexpr Status Status_MAX =
    SE2TrajectoryCommand_Feedback_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    SE2TrajectoryCommand_Feedback_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return SE2TrajectoryCommand_Feedback_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return SE2TrajectoryCommand_Feedback_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return SE2TrajectoryCommand_Feedback_Status_Parse(name, value);
  }

  typedef SE2TrajectoryCommand_Feedback_BodyMovementStatus BodyMovementStatus;
  static constexpr BodyMovementStatus BODY_STATUS_UNKNOWN =
    SE2TrajectoryCommand_Feedback_BodyMovementStatus_BODY_STATUS_UNKNOWN;
  static constexpr BodyMovementStatus BODY_STATUS_MOVING =
    SE2TrajectoryCommand_Feedback_BodyMovementStatus_BODY_STATUS_MOVING;
  static constexpr BodyMovementStatus BODY_STATUS_SETTLED =
    SE2TrajectoryCommand_Feedback_BodyMovementStatus_BODY_STATUS_SETTLED;
  static inline bool BodyMovementStatus_IsValid(int value) {
    return SE2TrajectoryCommand_Feedback_BodyMovementStatus_IsValid(value);
  }
  static constexpr BodyMovementStatus BodyMovementStatus_MIN =
    SE2TrajectoryCommand_Feedback_BodyMovementStatus_BodyMovementStatus_MIN;
  static constexpr BodyMovementStatus BodyMovementStatus_MAX =
    SE2TrajectoryCommand_Feedback_BodyMovementStatus_BodyMovementStatus_MAX;
  static constexpr int BodyMovementStatus_ARRAYSIZE =
    SE2TrajectoryCommand_Feedback_BodyMovementStatus_BodyMovementStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BodyMovementStatus_descriptor() {
    return SE2TrajectoryCommand_Feedback_BodyMovementStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& BodyMovementStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BodyMovementStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BodyMovementStatus_Name.");
    return SE2TrajectoryCommand_Feedback_BodyMovementStatus_Name(enum_t_value);
  }
  static inline bool BodyMovementStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BodyMovementStatus* value) {
    return SE2TrajectoryCommand_Feedback_BodyMovementStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kBodyMovementStatusFieldNumber = 2,
  };
  // .bosdyn.api.SE2TrajectoryCommand.Feedback.Status status = 1;
  void clear_status();
  ::bosdyn::api::SE2TrajectoryCommand_Feedback_Status status() const;
  void set_status(::bosdyn::api::SE2TrajectoryCommand_Feedback_Status value);
  private:
  ::bosdyn::api::SE2TrajectoryCommand_Feedback_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::SE2TrajectoryCommand_Feedback_Status value);
  public:

  // .bosdyn.api.SE2TrajectoryCommand.Feedback.BodyMovementStatus body_movement_status = 2;
  void clear_body_movement_status();
  ::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus body_movement_status() const;
  void set_body_movement_status(::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus value);
  private:
  ::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus _internal_body_movement_status() const;
  void _internal_set_body_movement_status(::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE2TrajectoryCommand.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int status_;
    int body_movement_status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SE2TrajectoryCommand final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.SE2TrajectoryCommand) */ {
 public:
  inline SE2TrajectoryCommand() : SE2TrajectoryCommand(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SE2TrajectoryCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE2TrajectoryCommand(const SE2TrajectoryCommand& from);
  SE2TrajectoryCommand(SE2TrajectoryCommand&& from) noexcept
    : SE2TrajectoryCommand() {
    *this = ::std::move(from);
  }

  inline SE2TrajectoryCommand& operator=(const SE2TrajectoryCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE2TrajectoryCommand& operator=(SE2TrajectoryCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE2TrajectoryCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE2TrajectoryCommand* internal_default_instance() {
    return reinterpret_cast<const SE2TrajectoryCommand*>(
               &_SE2TrajectoryCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SE2TrajectoryCommand& a, SE2TrajectoryCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SE2TrajectoryCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE2TrajectoryCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SE2TrajectoryCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SE2TrajectoryCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SE2TrajectoryCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SE2TrajectoryCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE2TrajectoryCommand";
  }
  protected:
  explicit SE2TrajectoryCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SE2TrajectoryCommand_Request Request;
  typedef SE2TrajectoryCommand_Feedback Feedback;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE2TrajectoryCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SE2VelocityCommand_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SE2VelocityCommand.Request) */ {
 public:
  inline SE2VelocityCommand_Request() : SE2VelocityCommand_Request(nullptr) {}
  ~SE2VelocityCommand_Request() override;
  explicit PROTOBUF_CONSTEXPR SE2VelocityCommand_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE2VelocityCommand_Request(const SE2VelocityCommand_Request& from);
  SE2VelocityCommand_Request(SE2VelocityCommand_Request&& from) noexcept
    : SE2VelocityCommand_Request() {
    *this = ::std::move(from);
  }

  inline SE2VelocityCommand_Request& operator=(const SE2VelocityCommand_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE2VelocityCommand_Request& operator=(SE2VelocityCommand_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE2VelocityCommand_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE2VelocityCommand_Request* internal_default_instance() {
    return reinterpret_cast<const SE2VelocityCommand_Request*>(
               &_SE2VelocityCommand_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SE2VelocityCommand_Request& a, SE2VelocityCommand_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(SE2VelocityCommand_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE2VelocityCommand_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SE2VelocityCommand_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SE2VelocityCommand_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SE2VelocityCommand_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SE2VelocityCommand_Request& from) {
    SE2VelocityCommand_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE2VelocityCommand_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE2VelocityCommand.Request";
  }
  protected:
  explicit SE2VelocityCommand_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSe2FrameNameFieldNumber = 5,
    kEndTimeFieldNumber = 1,
    kVelocityFieldNumber = 2,
    kSlewRateLimitFieldNumber = 4,
  };
  // string se2_frame_name = 5;
  void clear_se2_frame_name();
  const std::string& se2_frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_se2_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_se2_frame_name();
  PROTOBUF_NODISCARD std::string* release_se2_frame_name();
  void set_allocated_se2_frame_name(std::string* se2_frame_name);
  private:
  const std::string& _internal_se2_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_se2_frame_name(const std::string& value);
  std::string* _internal_mutable_se2_frame_name();
  public:

  // .google.protobuf.Timestamp end_time = 1;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // .bosdyn.api.SE2Velocity velocity = 2;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::bosdyn::api::SE2Velocity& velocity() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE2Velocity* release_velocity();
  ::bosdyn::api::SE2Velocity* mutable_velocity();
  void set_allocated_velocity(::bosdyn::api::SE2Velocity* velocity);
  private:
  const ::bosdyn::api::SE2Velocity& _internal_velocity() const;
  ::bosdyn::api::SE2Velocity* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::bosdyn::api::SE2Velocity* velocity);
  ::bosdyn::api::SE2Velocity* unsafe_arena_release_velocity();

  // .bosdyn.api.SE2Velocity slew_rate_limit = 4;
  bool has_slew_rate_limit() const;
  private:
  bool _internal_has_slew_rate_limit() const;
  public:
  void clear_slew_rate_limit();
  const ::bosdyn::api::SE2Velocity& slew_rate_limit() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE2Velocity* release_slew_rate_limit();
  ::bosdyn::api::SE2Velocity* mutable_slew_rate_limit();
  void set_allocated_slew_rate_limit(::bosdyn::api::SE2Velocity* slew_rate_limit);
  private:
  const ::bosdyn::api::SE2Velocity& _internal_slew_rate_limit() const;
  ::bosdyn::api::SE2Velocity* _internal_mutable_slew_rate_limit();
  public:
  void unsafe_arena_set_allocated_slew_rate_limit(
      ::bosdyn::api::SE2Velocity* slew_rate_limit);
  ::bosdyn::api::SE2Velocity* unsafe_arena_release_slew_rate_limit();

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE2VelocityCommand.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr se2_frame_name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    ::bosdyn::api::SE2Velocity* velocity_;
    ::bosdyn::api::SE2Velocity* slew_rate_limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SE2VelocityCommand_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.SE2VelocityCommand.Feedback) */ {
 public:
  inline SE2VelocityCommand_Feedback() : SE2VelocityCommand_Feedback(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SE2VelocityCommand_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE2VelocityCommand_Feedback(const SE2VelocityCommand_Feedback& from);
  SE2VelocityCommand_Feedback(SE2VelocityCommand_Feedback&& from) noexcept
    : SE2VelocityCommand_Feedback() {
    *this = ::std::move(from);
  }

  inline SE2VelocityCommand_Feedback& operator=(const SE2VelocityCommand_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE2VelocityCommand_Feedback& operator=(SE2VelocityCommand_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE2VelocityCommand_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE2VelocityCommand_Feedback* internal_default_instance() {
    return reinterpret_cast<const SE2VelocityCommand_Feedback*>(
               &_SE2VelocityCommand_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SE2VelocityCommand_Feedback& a, SE2VelocityCommand_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(SE2VelocityCommand_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE2VelocityCommand_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SE2VelocityCommand_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SE2VelocityCommand_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SE2VelocityCommand_Feedback& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SE2VelocityCommand_Feedback& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE2VelocityCommand.Feedback";
  }
  protected:
  explicit SE2VelocityCommand_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE2VelocityCommand.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SE2VelocityCommand final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.SE2VelocityCommand) */ {
 public:
  inline SE2VelocityCommand() : SE2VelocityCommand(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SE2VelocityCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE2VelocityCommand(const SE2VelocityCommand& from);
  SE2VelocityCommand(SE2VelocityCommand&& from) noexcept
    : SE2VelocityCommand() {
    *this = ::std::move(from);
  }

  inline SE2VelocityCommand& operator=(const SE2VelocityCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE2VelocityCommand& operator=(SE2VelocityCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE2VelocityCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE2VelocityCommand* internal_default_instance() {
    return reinterpret_cast<const SE2VelocityCommand*>(
               &_SE2VelocityCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SE2VelocityCommand& a, SE2VelocityCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SE2VelocityCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE2VelocityCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SE2VelocityCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SE2VelocityCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SE2VelocityCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SE2VelocityCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE2VelocityCommand";
  }
  protected:
  explicit SE2VelocityCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SE2VelocityCommand_Request Request;
  typedef SE2VelocityCommand_Feedback Feedback;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE2VelocityCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SitCommand_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.SitCommand.Request) */ {
 public:
  inline SitCommand_Request() : SitCommand_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SitCommand_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SitCommand_Request(const SitCommand_Request& from);
  SitCommand_Request(SitCommand_Request&& from) noexcept
    : SitCommand_Request() {
    *this = ::std::move(from);
  }

  inline SitCommand_Request& operator=(const SitCommand_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline SitCommand_Request& operator=(SitCommand_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SitCommand_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const SitCommand_Request* internal_default_instance() {
    return reinterpret_cast<const SitCommand_Request*>(
               &_SitCommand_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SitCommand_Request& a, SitCommand_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(SitCommand_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SitCommand_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SitCommand_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SitCommand_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SitCommand_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SitCommand_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SitCommand.Request";
  }
  protected:
  explicit SitCommand_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.SitCommand.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SitCommand_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SitCommand.Feedback) */ {
 public:
  inline SitCommand_Feedback() : SitCommand_Feedback(nullptr) {}
  ~SitCommand_Feedback() override;
  explicit PROTOBUF_CONSTEXPR SitCommand_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SitCommand_Feedback(const SitCommand_Feedback& from);
  SitCommand_Feedback(SitCommand_Feedback&& from) noexcept
    : SitCommand_Feedback() {
    *this = ::std::move(from);
  }

  inline SitCommand_Feedback& operator=(const SitCommand_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline SitCommand_Feedback& operator=(SitCommand_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SitCommand_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const SitCommand_Feedback* internal_default_instance() {
    return reinterpret_cast<const SitCommand_Feedback*>(
               &_SitCommand_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SitCommand_Feedback& a, SitCommand_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(SitCommand_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SitCommand_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SitCommand_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SitCommand_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SitCommand_Feedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SitCommand_Feedback& from) {
    SitCommand_Feedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SitCommand_Feedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SitCommand.Feedback";
  }
  protected:
  explicit SitCommand_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SitCommand_Feedback_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    SitCommand_Feedback_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_IS_SITTING =
    SitCommand_Feedback_Status_STATUS_IS_SITTING;
  static constexpr Status STATUS_IN_PROGRESS =
    SitCommand_Feedback_Status_STATUS_IN_PROGRESS;
  static inline bool Status_IsValid(int value) {
    return SitCommand_Feedback_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    SitCommand_Feedback_Status_Status_MIN;
  static constexpr Status Status_MAX =
    SitCommand_Feedback_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    SitCommand_Feedback_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return SitCommand_Feedback_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return SitCommand_Feedback_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return SitCommand_Feedback_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.SitCommand.Feedback.Status status = 2;
  void clear_status();
  ::bosdyn::api::SitCommand_Feedback_Status status() const;
  void set_status(::bosdyn::api::SitCommand_Feedback_Status value);
  private:
  ::bosdyn::api::SitCommand_Feedback_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::SitCommand_Feedback_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SitCommand.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SitCommand final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.SitCommand) */ {
 public:
  inline SitCommand() : SitCommand(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SitCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SitCommand(const SitCommand& from);
  SitCommand(SitCommand&& from) noexcept
    : SitCommand() {
    *this = ::std::move(from);
  }

  inline SitCommand& operator=(const SitCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SitCommand& operator=(SitCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SitCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const SitCommand* internal_default_instance() {
    return reinterpret_cast<const SitCommand*>(
               &_SitCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SitCommand& a, SitCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SitCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SitCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SitCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SitCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SitCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SitCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SitCommand";
  }
  protected:
  explicit SitCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SitCommand_Request Request;
  typedef SitCommand_Feedback Feedback;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.SitCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class StandCommand_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.StandCommand.Request) */ {
 public:
  inline StandCommand_Request() : StandCommand_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR StandCommand_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StandCommand_Request(const StandCommand_Request& from);
  StandCommand_Request(StandCommand_Request&& from) noexcept
    : StandCommand_Request() {
    *this = ::std::move(from);
  }

  inline StandCommand_Request& operator=(const StandCommand_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline StandCommand_Request& operator=(StandCommand_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StandCommand_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const StandCommand_Request* internal_default_instance() {
    return reinterpret_cast<const StandCommand_Request*>(
               &_StandCommand_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(StandCommand_Request& a, StandCommand_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(StandCommand_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StandCommand_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StandCommand_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StandCommand_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StandCommand_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StandCommand_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StandCommand.Request";
  }
  protected:
  explicit StandCommand_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.StandCommand.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class StandCommand_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.StandCommand.Feedback) */ {
 public:
  inline StandCommand_Feedback() : StandCommand_Feedback(nullptr) {}
  ~StandCommand_Feedback() override;
  explicit PROTOBUF_CONSTEXPR StandCommand_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StandCommand_Feedback(const StandCommand_Feedback& from);
  StandCommand_Feedback(StandCommand_Feedback&& from) noexcept
    : StandCommand_Feedback() {
    *this = ::std::move(from);
  }

  inline StandCommand_Feedback& operator=(const StandCommand_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline StandCommand_Feedback& operator=(StandCommand_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StandCommand_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const StandCommand_Feedback* internal_default_instance() {
    return reinterpret_cast<const StandCommand_Feedback*>(
               &_StandCommand_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(StandCommand_Feedback& a, StandCommand_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(StandCommand_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StandCommand_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StandCommand_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StandCommand_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StandCommand_Feedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StandCommand_Feedback& from) {
    StandCommand_Feedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StandCommand_Feedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StandCommand.Feedback";
  }
  protected:
  explicit StandCommand_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StandCommand_Feedback_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    StandCommand_Feedback_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_IS_STANDING =
    StandCommand_Feedback_Status_STATUS_IS_STANDING;
  static constexpr Status STATUS_IN_PROGRESS =
    StandCommand_Feedback_Status_STATUS_IN_PROGRESS;
  static inline bool Status_IsValid(int value) {
    return StandCommand_Feedback_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    StandCommand_Feedback_Status_Status_MIN;
  static constexpr Status Status_MAX =
    StandCommand_Feedback_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    StandCommand_Feedback_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return StandCommand_Feedback_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return StandCommand_Feedback_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return StandCommand_Feedback_Status_Parse(name, value);
  }

  typedef StandCommand_Feedback_StandingState StandingState;
  static constexpr StandingState STANDING_UNKNOWN =
    StandCommand_Feedback_StandingState_STANDING_UNKNOWN;
  static constexpr StandingState STANDING_CONTROLLED =
    StandCommand_Feedback_StandingState_STANDING_CONTROLLED;
  static constexpr StandingState STANDING_FROZEN =
    StandCommand_Feedback_StandingState_STANDING_FROZEN;
  static inline bool StandingState_IsValid(int value) {
    return StandCommand_Feedback_StandingState_IsValid(value);
  }
  static constexpr StandingState StandingState_MIN =
    StandCommand_Feedback_StandingState_StandingState_MIN;
  static constexpr StandingState StandingState_MAX =
    StandCommand_Feedback_StandingState_StandingState_MAX;
  static constexpr int StandingState_ARRAYSIZE =
    StandCommand_Feedback_StandingState_StandingState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StandingState_descriptor() {
    return StandCommand_Feedback_StandingState_descriptor();
  }
  template<typename T>
  static inline const std::string& StandingState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StandingState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StandingState_Name.");
    return StandCommand_Feedback_StandingState_Name(enum_t_value);
  }
  static inline bool StandingState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StandingState* value) {
    return StandCommand_Feedback_StandingState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kStandingStateFieldNumber = 2,
  };
  // .bosdyn.api.StandCommand.Feedback.Status status = 1;
  void clear_status();
  ::bosdyn::api::StandCommand_Feedback_Status status() const;
  void set_status(::bosdyn::api::StandCommand_Feedback_Status value);
  private:
  ::bosdyn::api::StandCommand_Feedback_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::StandCommand_Feedback_Status value);
  public:

  // .bosdyn.api.StandCommand.Feedback.StandingState standing_state = 2;
  void clear_standing_state();
  ::bosdyn::api::StandCommand_Feedback_StandingState standing_state() const;
  void set_standing_state(::bosdyn::api::StandCommand_Feedback_StandingState value);
  private:
  ::bosdyn::api::StandCommand_Feedback_StandingState _internal_standing_state() const;
  void _internal_set_standing_state(::bosdyn::api::StandCommand_Feedback_StandingState value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.StandCommand.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int status_;
    int standing_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class StandCommand final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.StandCommand) */ {
 public:
  inline StandCommand() : StandCommand(nullptr) {}
  explicit PROTOBUF_CONSTEXPR StandCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StandCommand(const StandCommand& from);
  StandCommand(StandCommand&& from) noexcept
    : StandCommand() {
    *this = ::std::move(from);
  }

  inline StandCommand& operator=(const StandCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline StandCommand& operator=(StandCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StandCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const StandCommand* internal_default_instance() {
    return reinterpret_cast<const StandCommand*>(
               &_StandCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(StandCommand& a, StandCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(StandCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StandCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StandCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StandCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StandCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StandCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StandCommand";
  }
  protected:
  explicit StandCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StandCommand_Request Request;
  typedef StandCommand_Feedback Feedback;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.StandCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class StanceCommand_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.StanceCommand.Request) */ {
 public:
  inline StanceCommand_Request() : StanceCommand_Request(nullptr) {}
  ~StanceCommand_Request() override;
  explicit PROTOBUF_CONSTEXPR StanceCommand_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StanceCommand_Request(const StanceCommand_Request& from);
  StanceCommand_Request(StanceCommand_Request&& from) noexcept
    : StanceCommand_Request() {
    *this = ::std::move(from);
  }

  inline StanceCommand_Request& operator=(const StanceCommand_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline StanceCommand_Request& operator=(StanceCommand_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StanceCommand_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const StanceCommand_Request* internal_default_instance() {
    return reinterpret_cast<const StanceCommand_Request*>(
               &_StanceCommand_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(StanceCommand_Request& a, StanceCommand_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(StanceCommand_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StanceCommand_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StanceCommand_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StanceCommand_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StanceCommand_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StanceCommand_Request& from) {
    StanceCommand_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StanceCommand_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StanceCommand.Request";
  }
  protected:
  explicit StanceCommand_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndTimeFieldNumber = 1,
    kStanceFieldNumber = 2,
  };
  // .google.protobuf.Timestamp end_time = 1;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // .bosdyn.api.Stance stance = 2;
  bool has_stance() const;
  private:
  bool _internal_has_stance() const;
  public:
  void clear_stance();
  const ::bosdyn::api::Stance& stance() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Stance* release_stance();
  ::bosdyn::api::Stance* mutable_stance();
  void set_allocated_stance(::bosdyn::api::Stance* stance);
  private:
  const ::bosdyn::api::Stance& _internal_stance() const;
  ::bosdyn::api::Stance* _internal_mutable_stance();
  public:
  void unsafe_arena_set_allocated_stance(
      ::bosdyn::api::Stance* stance);
  ::bosdyn::api::Stance* unsafe_arena_release_stance();

  // @@protoc_insertion_point(class_scope:bosdyn.api.StanceCommand.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    ::bosdyn::api::Stance* stance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class StanceCommand_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.StanceCommand.Feedback) */ {
 public:
  inline StanceCommand_Feedback() : StanceCommand_Feedback(nullptr) {}
  ~StanceCommand_Feedback() override;
  explicit PROTOBUF_CONSTEXPR StanceCommand_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StanceCommand_Feedback(const StanceCommand_Feedback& from);
  StanceCommand_Feedback(StanceCommand_Feedback&& from) noexcept
    : StanceCommand_Feedback() {
    *this = ::std::move(from);
  }

  inline StanceCommand_Feedback& operator=(const StanceCommand_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline StanceCommand_Feedback& operator=(StanceCommand_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StanceCommand_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const StanceCommand_Feedback* internal_default_instance() {
    return reinterpret_cast<const StanceCommand_Feedback*>(
               &_StanceCommand_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(StanceCommand_Feedback& a, StanceCommand_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(StanceCommand_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StanceCommand_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StanceCommand_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StanceCommand_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StanceCommand_Feedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StanceCommand_Feedback& from) {
    StanceCommand_Feedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StanceCommand_Feedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StanceCommand.Feedback";
  }
  protected:
  explicit StanceCommand_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StanceCommand_Feedback_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    StanceCommand_Feedback_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_STANCED =
    StanceCommand_Feedback_Status_STATUS_STANCED;
  static constexpr Status STATUS_GOING_TO_STANCE =
    StanceCommand_Feedback_Status_STATUS_GOING_TO_STANCE;
  static constexpr Status STATUS_TOO_FAR_AWAY =
    StanceCommand_Feedback_Status_STATUS_TOO_FAR_AWAY;
  static inline bool Status_IsValid(int value) {
    return StanceCommand_Feedback_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    StanceCommand_Feedback_Status_Status_MIN;
  static constexpr Status Status_MAX =
    StanceCommand_Feedback_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    StanceCommand_Feedback_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return StanceCommand_Feedback_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return StanceCommand_Feedback_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return StanceCommand_Feedback_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .bosdyn.api.StanceCommand.Feedback.Status status = 1;
  void clear_status();
  ::bosdyn::api::StanceCommand_Feedback_Status status() const;
  void set_status(::bosdyn::api::StanceCommand_Feedback_Status value);
  private:
  ::bosdyn::api::StanceCommand_Feedback_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::StanceCommand_Feedback_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.StanceCommand.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class StanceCommand final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.StanceCommand) */ {
 public:
  inline StanceCommand() : StanceCommand(nullptr) {}
  explicit PROTOBUF_CONSTEXPR StanceCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StanceCommand(const StanceCommand& from);
  StanceCommand(StanceCommand&& from) noexcept
    : StanceCommand() {
    *this = ::std::move(from);
  }

  inline StanceCommand& operator=(const StanceCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline StanceCommand& operator=(StanceCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StanceCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const StanceCommand* internal_default_instance() {
    return reinterpret_cast<const StanceCommand*>(
               &_StanceCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(StanceCommand& a, StanceCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(StanceCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StanceCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StanceCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StanceCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StanceCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StanceCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.StanceCommand";
  }
  protected:
  explicit StanceCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StanceCommand_Request Request;
  typedef StanceCommand_Feedback Feedback;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.StanceCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class Stance_FootPositionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Stance_FootPositionsEntry_DoNotUse, 
    std::string, ::bosdyn::api::Vec2,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Stance_FootPositionsEntry_DoNotUse, 
    std::string, ::bosdyn::api::Vec2,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Stance_FootPositionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Stance_FootPositionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Stance_FootPositionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Stance_FootPositionsEntry_DoNotUse& other);
  static const Stance_FootPositionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Stance_FootPositionsEntry_DoNotUse*>(&_Stance_FootPositionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.Stance.FootPositionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};

// -------------------------------------------------------------------

class Stance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Stance) */ {
 public:
  inline Stance() : Stance(nullptr) {}
  ~Stance() override;
  explicit PROTOBUF_CONSTEXPR Stance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stance(const Stance& from);
  Stance(Stance&& from) noexcept
    : Stance() {
    *this = ::std::move(from);
  }

  inline Stance& operator=(const Stance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stance& operator=(Stance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stance* internal_default_instance() {
    return reinterpret_cast<const Stance*>(
               &_Stance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Stance& a, Stance& b) {
    a.Swap(&b);
  }
  inline void Swap(Stance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Stance& from) {
    Stance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Stance";
  }
  protected:
  explicit Stance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFootPositionsFieldNumber = 2,
    kSe2FrameNameFieldNumber = 3,
    kAccuracyFieldNumber = 4,
  };
  // map<string, .bosdyn.api.Vec2> foot_positions = 2;
  int foot_positions_size() const;
  private:
  int _internal_foot_positions_size() const;
  public:
  void clear_foot_positions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::Vec2 >&
      _internal_foot_positions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::Vec2 >*
      _internal_mutable_foot_positions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::Vec2 >&
      foot_positions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::Vec2 >*
      mutable_foot_positions();

  // string se2_frame_name = 3;
  void clear_se2_frame_name();
  const std::string& se2_frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_se2_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_se2_frame_name();
  PROTOBUF_NODISCARD std::string* release_se2_frame_name();
  void set_allocated_se2_frame_name(std::string* se2_frame_name);
  private:
  const std::string& _internal_se2_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_se2_frame_name(const std::string& value);
  std::string* _internal_mutable_se2_frame_name();
  public:

  // float accuracy = 4;
  void clear_accuracy();
  float accuracy() const;
  void set_accuracy(float value);
  private:
  float _internal_accuracy() const;
  void _internal_set_accuracy(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Stance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Stance_FootPositionsEntry_DoNotUse,
        std::string, ::bosdyn::api::Vec2,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> foot_positions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr se2_frame_name_;
    float accuracy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class FollowArmCommand_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.FollowArmCommand.Request) */ {
 public:
  inline FollowArmCommand_Request() : FollowArmCommand_Request(nullptr) {}
  ~FollowArmCommand_Request() override;
  explicit PROTOBUF_CONSTEXPR FollowArmCommand_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FollowArmCommand_Request(const FollowArmCommand_Request& from);
  FollowArmCommand_Request(FollowArmCommand_Request&& from) noexcept
    : FollowArmCommand_Request() {
    *this = ::std::move(from);
  }

  inline FollowArmCommand_Request& operator=(const FollowArmCommand_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline FollowArmCommand_Request& operator=(FollowArmCommand_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FollowArmCommand_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const FollowArmCommand_Request* internal_default_instance() {
    return reinterpret_cast<const FollowArmCommand_Request*>(
               &_FollowArmCommand_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(FollowArmCommand_Request& a, FollowArmCommand_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(FollowArmCommand_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FollowArmCommand_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FollowArmCommand_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FollowArmCommand_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FollowArmCommand_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FollowArmCommand_Request& from) {
    FollowArmCommand_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowArmCommand_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FollowArmCommand.Request";
  }
  protected:
  explicit FollowArmCommand_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBodyOffsetFromHandFieldNumber = 1,
    kDisableWalkingFieldNumber = 2,
  };
  // .bosdyn.api.Vec3 body_offset_from_hand = 1;
  bool has_body_offset_from_hand() const;
  private:
  bool _internal_has_body_offset_from_hand() const;
  public:
  void clear_body_offset_from_hand();
  const ::bosdyn::api::Vec3& body_offset_from_hand() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_body_offset_from_hand();
  ::bosdyn::api::Vec3* mutable_body_offset_from_hand();
  void set_allocated_body_offset_from_hand(::bosdyn::api::Vec3* body_offset_from_hand);
  private:
  const ::bosdyn::api::Vec3& _internal_body_offset_from_hand() const;
  ::bosdyn::api::Vec3* _internal_mutable_body_offset_from_hand();
  public:
  void unsafe_arena_set_allocated_body_offset_from_hand(
      ::bosdyn::api::Vec3* body_offset_from_hand);
  ::bosdyn::api::Vec3* unsafe_arena_release_body_offset_from_hand();

  // bool disable_walking = 2 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_disable_walking();
  PROTOBUF_DEPRECATED bool disable_walking() const;
  PROTOBUF_DEPRECATED void set_disable_walking(bool value);
  private:
  bool _internal_disable_walking() const;
  void _internal_set_disable_walking(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.FollowArmCommand.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec3* body_offset_from_hand_;
    bool disable_walking_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class FollowArmCommand_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.FollowArmCommand.Feedback) */ {
 public:
  inline FollowArmCommand_Feedback() : FollowArmCommand_Feedback(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FollowArmCommand_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FollowArmCommand_Feedback(const FollowArmCommand_Feedback& from);
  FollowArmCommand_Feedback(FollowArmCommand_Feedback&& from) noexcept
    : FollowArmCommand_Feedback() {
    *this = ::std::move(from);
  }

  inline FollowArmCommand_Feedback& operator=(const FollowArmCommand_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline FollowArmCommand_Feedback& operator=(FollowArmCommand_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FollowArmCommand_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const FollowArmCommand_Feedback* internal_default_instance() {
    return reinterpret_cast<const FollowArmCommand_Feedback*>(
               &_FollowArmCommand_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(FollowArmCommand_Feedback& a, FollowArmCommand_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(FollowArmCommand_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FollowArmCommand_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FollowArmCommand_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FollowArmCommand_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FollowArmCommand_Feedback& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FollowArmCommand_Feedback& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FollowArmCommand.Feedback";
  }
  protected:
  explicit FollowArmCommand_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.FollowArmCommand.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class FollowArmCommand final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.FollowArmCommand) */ {
 public:
  inline FollowArmCommand() : FollowArmCommand(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FollowArmCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FollowArmCommand(const FollowArmCommand& from);
  FollowArmCommand(FollowArmCommand&& from) noexcept
    : FollowArmCommand() {
    *this = ::std::move(from);
  }

  inline FollowArmCommand& operator=(const FollowArmCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline FollowArmCommand& operator=(FollowArmCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FollowArmCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const FollowArmCommand* internal_default_instance() {
    return reinterpret_cast<const FollowArmCommand*>(
               &_FollowArmCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(FollowArmCommand& a, FollowArmCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(FollowArmCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FollowArmCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FollowArmCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FollowArmCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FollowArmCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FollowArmCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FollowArmCommand";
  }
  protected:
  explicit FollowArmCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FollowArmCommand_Request Request;
  typedef FollowArmCommand_Feedback Feedback;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.FollowArmCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class ArmDragCommand_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.ArmDragCommand.Request) */ {
 public:
  inline ArmDragCommand_Request() : ArmDragCommand_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ArmDragCommand_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArmDragCommand_Request(const ArmDragCommand_Request& from);
  ArmDragCommand_Request(ArmDragCommand_Request&& from) noexcept
    : ArmDragCommand_Request() {
    *this = ::std::move(from);
  }

  inline ArmDragCommand_Request& operator=(const ArmDragCommand_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArmDragCommand_Request& operator=(ArmDragCommand_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArmDragCommand_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArmDragCommand_Request* internal_default_instance() {
    return reinterpret_cast<const ArmDragCommand_Request*>(
               &_ArmDragCommand_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ArmDragCommand_Request& a, ArmDragCommand_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(ArmDragCommand_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArmDragCommand_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArmDragCommand_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArmDragCommand_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ArmDragCommand_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ArmDragCommand_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ArmDragCommand.Request";
  }
  protected:
  explicit ArmDragCommand_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.ArmDragCommand.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class ArmDragCommand_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ArmDragCommand.Feedback) */ {
 public:
  inline ArmDragCommand_Feedback() : ArmDragCommand_Feedback(nullptr) {}
  ~ArmDragCommand_Feedback() override;
  explicit PROTOBUF_CONSTEXPR ArmDragCommand_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArmDragCommand_Feedback(const ArmDragCommand_Feedback& from);
  ArmDragCommand_Feedback(ArmDragCommand_Feedback&& from) noexcept
    : ArmDragCommand_Feedback() {
    *this = ::std::move(from);
  }

  inline ArmDragCommand_Feedback& operator=(const ArmDragCommand_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArmDragCommand_Feedback& operator=(ArmDragCommand_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArmDragCommand_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArmDragCommand_Feedback* internal_default_instance() {
    return reinterpret_cast<const ArmDragCommand_Feedback*>(
               &_ArmDragCommand_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ArmDragCommand_Feedback& a, ArmDragCommand_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(ArmDragCommand_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArmDragCommand_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArmDragCommand_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArmDragCommand_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArmDragCommand_Feedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArmDragCommand_Feedback& from) {
    ArmDragCommand_Feedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArmDragCommand_Feedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ArmDragCommand.Feedback";
  }
  protected:
  explicit ArmDragCommand_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ArmDragCommand_Feedback_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    ArmDragCommand_Feedback_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_DRAGGING =
    ArmDragCommand_Feedback_Status_STATUS_DRAGGING;
  static constexpr Status STATUS_GRASP_FAILED =
    ArmDragCommand_Feedback_Status_STATUS_GRASP_FAILED;
  static constexpr Status STATUS_OTHER_FAILURE =
    ArmDragCommand_Feedback_Status_STATUS_OTHER_FAILURE;
  static inline bool Status_IsValid(int value) {
    return ArmDragCommand_Feedback_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ArmDragCommand_Feedback_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ArmDragCommand_Feedback_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ArmDragCommand_Feedback_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return ArmDragCommand_Feedback_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ArmDragCommand_Feedback_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return ArmDragCommand_Feedback_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .bosdyn.api.ArmDragCommand.Feedback.Status status = 1;
  void clear_status();
  ::bosdyn::api::ArmDragCommand_Feedback_Status status() const;
  void set_status(::bosdyn::api::ArmDragCommand_Feedback_Status value);
  private:
  ::bosdyn::api::ArmDragCommand_Feedback_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::ArmDragCommand_Feedback_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ArmDragCommand.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class ArmDragCommand final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.ArmDragCommand) */ {
 public:
  inline ArmDragCommand() : ArmDragCommand(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ArmDragCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArmDragCommand(const ArmDragCommand& from);
  ArmDragCommand(ArmDragCommand&& from) noexcept
    : ArmDragCommand() {
    *this = ::std::move(from);
  }

  inline ArmDragCommand& operator=(const ArmDragCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArmDragCommand& operator=(ArmDragCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArmDragCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArmDragCommand* internal_default_instance() {
    return reinterpret_cast<const ArmDragCommand*>(
               &_ArmDragCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ArmDragCommand& a, ArmDragCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ArmDragCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArmDragCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArmDragCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArmDragCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ArmDragCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ArmDragCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ArmDragCommand";
  }
  protected:
  explicit ArmDragCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ArmDragCommand_Request Request;
  typedef ArmDragCommand_Feedback Feedback;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.ArmDragCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class ConstrainedManipulationCommand_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ConstrainedManipulationCommand.Request) */ {
 public:
  inline ConstrainedManipulationCommand_Request() : ConstrainedManipulationCommand_Request(nullptr) {}
  ~ConstrainedManipulationCommand_Request() override;
  explicit PROTOBUF_CONSTEXPR ConstrainedManipulationCommand_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConstrainedManipulationCommand_Request(const ConstrainedManipulationCommand_Request& from);
  ConstrainedManipulationCommand_Request(ConstrainedManipulationCommand_Request&& from) noexcept
    : ConstrainedManipulationCommand_Request() {
    *this = ::std::move(from);
  }

  inline ConstrainedManipulationCommand_Request& operator=(const ConstrainedManipulationCommand_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstrainedManipulationCommand_Request& operator=(ConstrainedManipulationCommand_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstrainedManipulationCommand_Request& default_instance() {
    return *internal_default_instance();
  }
  enum TaskSpeedCase {
    kTangentialSpeed = 3,
    kRotationalSpeed = 4,
    TASK_SPEED_NOT_SET = 0,
  };

  static inline const ConstrainedManipulationCommand_Request* internal_default_instance() {
    return reinterpret_cast<const ConstrainedManipulationCommand_Request*>(
               &_ConstrainedManipulationCommand_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ConstrainedManipulationCommand_Request& a, ConstrainedManipulationCommand_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(ConstrainedManipulationCommand_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstrainedManipulationCommand_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstrainedManipulationCommand_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConstrainedManipulationCommand_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConstrainedManipulationCommand_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConstrainedManipulationCommand_Request& from) {
    ConstrainedManipulationCommand_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConstrainedManipulationCommand_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ConstrainedManipulationCommand.Request";
  }
  protected:
  explicit ConstrainedManipulationCommand_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConstrainedManipulationCommand_Request_TaskType TaskType;
  static constexpr TaskType TASK_TYPE_UNKNOWN =
    ConstrainedManipulationCommand_Request_TaskType_TASK_TYPE_UNKNOWN;
  static constexpr TaskType TASK_TYPE_SE3_CIRCLE_FORCE_TORQUE =
    ConstrainedManipulationCommand_Request_TaskType_TASK_TYPE_SE3_CIRCLE_FORCE_TORQUE;
  static constexpr TaskType TASK_TYPE_R3_CIRCLE_EXTRADOF_FORCE =
    ConstrainedManipulationCommand_Request_TaskType_TASK_TYPE_R3_CIRCLE_EXTRADOF_FORCE;
  static constexpr TaskType TASK_TYPE_SE3_ROTATIONAL_TORQUE =
    ConstrainedManipulationCommand_Request_TaskType_TASK_TYPE_SE3_ROTATIONAL_TORQUE;
  static constexpr TaskType TASK_TYPE_R3_CIRCLE_FORCE =
    ConstrainedManipulationCommand_Request_TaskType_TASK_TYPE_R3_CIRCLE_FORCE;
  static constexpr TaskType TASK_TYPE_R3_LINEAR_FORCE =
    ConstrainedManipulationCommand_Request_TaskType_TASK_TYPE_R3_LINEAR_FORCE;
  static constexpr TaskType TASK_TYPE_HOLD_POSE =
    ConstrainedManipulationCommand_Request_TaskType_TASK_TYPE_HOLD_POSE;
  static inline bool TaskType_IsValid(int value) {
    return ConstrainedManipulationCommand_Request_TaskType_IsValid(value);
  }
  static constexpr TaskType TaskType_MIN =
    ConstrainedManipulationCommand_Request_TaskType_TaskType_MIN;
  static constexpr TaskType TaskType_MAX =
    ConstrainedManipulationCommand_Request_TaskType_TaskType_MAX;
  static constexpr int TaskType_ARRAYSIZE =
    ConstrainedManipulationCommand_Request_TaskType_TaskType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TaskType_descriptor() {
    return ConstrainedManipulationCommand_Request_TaskType_descriptor();
  }
  template<typename T>
  static inline const std::string& TaskType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TaskType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TaskType_Name.");
    return ConstrainedManipulationCommand_Request_TaskType_Name(enum_t_value);
  }
  static inline bool TaskType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TaskType* value) {
    return ConstrainedManipulationCommand_Request_TaskType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFieldNumber = 1,
    kInitWrenchDirectionInFrameNameFieldNumber = 2,
    kForceLimitFieldNumber = 5,
    kTorqueLimitFieldNumber = 6,
    kEndTimeFieldNumber = 8,
    kEnableRobotLocomotionFieldNumber = 9,
    kTaskTypeFieldNumber = 7,
    kTangentialSpeedFieldNumber = 3,
    kRotationalSpeedFieldNumber = 4,
  };
  // string frame_name = 1;
  void clear_frame_name();
  const std::string& frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name();
  PROTOBUF_NODISCARD std::string* release_frame_name();
  void set_allocated_frame_name(std::string* frame_name);
  private:
  const std::string& _internal_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name(const std::string& value);
  std::string* _internal_mutable_frame_name();
  public:

  // .bosdyn.api.Wrench init_wrench_direction_in_frame_name = 2;
  bool has_init_wrench_direction_in_frame_name() const;
  private:
  bool _internal_has_init_wrench_direction_in_frame_name() const;
  public:
  void clear_init_wrench_direction_in_frame_name();
  const ::bosdyn::api::Wrench& init_wrench_direction_in_frame_name() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Wrench* release_init_wrench_direction_in_frame_name();
  ::bosdyn::api::Wrench* mutable_init_wrench_direction_in_frame_name();
  void set_allocated_init_wrench_direction_in_frame_name(::bosdyn::api::Wrench* init_wrench_direction_in_frame_name);
  private:
  const ::bosdyn::api::Wrench& _internal_init_wrench_direction_in_frame_name() const;
  ::bosdyn::api::Wrench* _internal_mutable_init_wrench_direction_in_frame_name();
  public:
  void unsafe_arena_set_allocated_init_wrench_direction_in_frame_name(
      ::bosdyn::api::Wrench* init_wrench_direction_in_frame_name);
  ::bosdyn::api::Wrench* unsafe_arena_release_init_wrench_direction_in_frame_name();

  // .google.protobuf.DoubleValue force_limit = 5;
  bool has_force_limit() const;
  private:
  bool _internal_has_force_limit() const;
  public:
  void clear_force_limit();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& force_limit() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_force_limit();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_force_limit();
  void set_allocated_force_limit(::PROTOBUF_NAMESPACE_ID::DoubleValue* force_limit);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_force_limit() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_force_limit();
  public:
  void unsafe_arena_set_allocated_force_limit(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* force_limit);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_force_limit();

  // .google.protobuf.DoubleValue torque_limit = 6;
  bool has_torque_limit() const;
  private:
  bool _internal_has_torque_limit() const;
  public:
  void clear_torque_limit();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& torque_limit() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_torque_limit();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_torque_limit();
  void set_allocated_torque_limit(::PROTOBUF_NAMESPACE_ID::DoubleValue* torque_limit);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_torque_limit() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_torque_limit();
  public:
  void unsafe_arena_set_allocated_torque_limit(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* torque_limit);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_torque_limit();

  // .google.protobuf.Timestamp end_time = 8;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // .google.protobuf.BoolValue enable_robot_locomotion = 9;
  bool has_enable_robot_locomotion() const;
  private:
  bool _internal_has_enable_robot_locomotion() const;
  public:
  void clear_enable_robot_locomotion();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& enable_robot_locomotion() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_enable_robot_locomotion();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_enable_robot_locomotion();
  void set_allocated_enable_robot_locomotion(::PROTOBUF_NAMESPACE_ID::BoolValue* enable_robot_locomotion);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_enable_robot_locomotion() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_enable_robot_locomotion();
  public:
  void unsafe_arena_set_allocated_enable_robot_locomotion(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* enable_robot_locomotion);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_enable_robot_locomotion();

  // .bosdyn.api.ConstrainedManipulationCommand.Request.TaskType task_type = 7;
  void clear_task_type();
  ::bosdyn::api::ConstrainedManipulationCommand_Request_TaskType task_type() const;
  void set_task_type(::bosdyn::api::ConstrainedManipulationCommand_Request_TaskType value);
  private:
  ::bosdyn::api::ConstrainedManipulationCommand_Request_TaskType _internal_task_type() const;
  void _internal_set_task_type(::bosdyn::api::ConstrainedManipulationCommand_Request_TaskType value);
  public:

  // double tangential_speed = 3;
  bool has_tangential_speed() const;
  private:
  bool _internal_has_tangential_speed() const;
  public:
  void clear_tangential_speed();
  double tangential_speed() const;
  void set_tangential_speed(double value);
  private:
  double _internal_tangential_speed() const;
  void _internal_set_tangential_speed(double value);
  public:

  // double rotational_speed = 4;
  bool has_rotational_speed() const;
  private:
  bool _internal_has_rotational_speed() const;
  public:
  void clear_rotational_speed();
  double rotational_speed() const;
  void set_rotational_speed(double value);
  private:
  double _internal_rotational_speed() const;
  void _internal_set_rotational_speed(double value);
  public:

  void clear_task_speed();
  TaskSpeedCase task_speed_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.ConstrainedManipulationCommand.Request)
 private:
  class _Internal;
  void set_has_tangential_speed();
  void set_has_rotational_speed();

  inline bool has_task_speed() const;
  inline void clear_has_task_speed();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_;
    ::bosdyn::api::Wrench* init_wrench_direction_in_frame_name_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* force_limit_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* torque_limit_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* enable_robot_locomotion_;
    int task_type_;
    union TaskSpeedUnion {
      constexpr TaskSpeedUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      double tangential_speed_;
      double rotational_speed_;
    } task_speed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class ConstrainedManipulationCommand_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ConstrainedManipulationCommand.Feedback) */ {
 public:
  inline ConstrainedManipulationCommand_Feedback() : ConstrainedManipulationCommand_Feedback(nullptr) {}
  ~ConstrainedManipulationCommand_Feedback() override;
  explicit PROTOBUF_CONSTEXPR ConstrainedManipulationCommand_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConstrainedManipulationCommand_Feedback(const ConstrainedManipulationCommand_Feedback& from);
  ConstrainedManipulationCommand_Feedback(ConstrainedManipulationCommand_Feedback&& from) noexcept
    : ConstrainedManipulationCommand_Feedback() {
    *this = ::std::move(from);
  }

  inline ConstrainedManipulationCommand_Feedback& operator=(const ConstrainedManipulationCommand_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstrainedManipulationCommand_Feedback& operator=(ConstrainedManipulationCommand_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstrainedManipulationCommand_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConstrainedManipulationCommand_Feedback* internal_default_instance() {
    return reinterpret_cast<const ConstrainedManipulationCommand_Feedback*>(
               &_ConstrainedManipulationCommand_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ConstrainedManipulationCommand_Feedback& a, ConstrainedManipulationCommand_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(ConstrainedManipulationCommand_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstrainedManipulationCommand_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstrainedManipulationCommand_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConstrainedManipulationCommand_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConstrainedManipulationCommand_Feedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConstrainedManipulationCommand_Feedback& from) {
    ConstrainedManipulationCommand_Feedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConstrainedManipulationCommand_Feedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ConstrainedManipulationCommand.Feedback";
  }
  protected:
  explicit ConstrainedManipulationCommand_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConstrainedManipulationCommand_Feedback_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    ConstrainedManipulationCommand_Feedback_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_RUNNING =
    ConstrainedManipulationCommand_Feedback_Status_STATUS_RUNNING;
  static constexpr Status STATUS_ARM_IS_STUCK =
    ConstrainedManipulationCommand_Feedback_Status_STATUS_ARM_IS_STUCK;
  static constexpr Status STATUS_GRASP_IS_LOST =
    ConstrainedManipulationCommand_Feedback_Status_STATUS_GRASP_IS_LOST;
  static inline bool Status_IsValid(int value) {
    return ConstrainedManipulationCommand_Feedback_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ConstrainedManipulationCommand_Feedback_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ConstrainedManipulationCommand_Feedback_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ConstrainedManipulationCommand_Feedback_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return ConstrainedManipulationCommand_Feedback_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ConstrainedManipulationCommand_Feedback_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return ConstrainedManipulationCommand_Feedback_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDesiredWrenchOdomFrameFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // .bosdyn.api.Wrench desired_wrench_odom_frame = 2;
  bool has_desired_wrench_odom_frame() const;
  private:
  bool _internal_has_desired_wrench_odom_frame() const;
  public:
  void clear_desired_wrench_odom_frame();
  const ::bosdyn::api::Wrench& desired_wrench_odom_frame() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Wrench* release_desired_wrench_odom_frame();
  ::bosdyn::api::Wrench* mutable_desired_wrench_odom_frame();
  void set_allocated_desired_wrench_odom_frame(::bosdyn::api::Wrench* desired_wrench_odom_frame);
  private:
  const ::bosdyn::api::Wrench& _internal_desired_wrench_odom_frame() const;
  ::bosdyn::api::Wrench* _internal_mutable_desired_wrench_odom_frame();
  public:
  void unsafe_arena_set_allocated_desired_wrench_odom_frame(
      ::bosdyn::api::Wrench* desired_wrench_odom_frame);
  ::bosdyn::api::Wrench* unsafe_arena_release_desired_wrench_odom_frame();

  // .bosdyn.api.ConstrainedManipulationCommand.Feedback.Status status = 1;
  void clear_status();
  ::bosdyn::api::ConstrainedManipulationCommand_Feedback_Status status() const;
  void set_status(::bosdyn::api::ConstrainedManipulationCommand_Feedback_Status value);
  private:
  ::bosdyn::api::ConstrainedManipulationCommand_Feedback_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::ConstrainedManipulationCommand_Feedback_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ConstrainedManipulationCommand.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Wrench* desired_wrench_odom_frame_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class ConstrainedManipulationCommand final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bosdyn.api.ConstrainedManipulationCommand) */ {
 public:
  inline ConstrainedManipulationCommand() : ConstrainedManipulationCommand(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ConstrainedManipulationCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConstrainedManipulationCommand(const ConstrainedManipulationCommand& from);
  ConstrainedManipulationCommand(ConstrainedManipulationCommand&& from) noexcept
    : ConstrainedManipulationCommand() {
    *this = ::std::move(from);
  }

  inline ConstrainedManipulationCommand& operator=(const ConstrainedManipulationCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstrainedManipulationCommand& operator=(ConstrainedManipulationCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstrainedManipulationCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConstrainedManipulationCommand* internal_default_instance() {
    return reinterpret_cast<const ConstrainedManipulationCommand*>(
               &_ConstrainedManipulationCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ConstrainedManipulationCommand& a, ConstrainedManipulationCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ConstrainedManipulationCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstrainedManipulationCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstrainedManipulationCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConstrainedManipulationCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ConstrainedManipulationCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ConstrainedManipulationCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ConstrainedManipulationCommand";
  }
  protected:
  explicit ConstrainedManipulationCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConstrainedManipulationCommand_Request Request;
  typedef ConstrainedManipulationCommand_Feedback Feedback;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bosdyn.api.ConstrainedManipulationCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bosdyn_2fapi_2fbasic_5fcommand_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RobotCommandFeedbackStatus

// -------------------------------------------------------------------

// BatteryChangePoseCommand_Request

// .bosdyn.api.BatteryChangePoseCommand.Request.DirectionHint direction_hint = 1;
inline void BatteryChangePoseCommand_Request::clear_direction_hint() {
  _impl_.direction_hint_ = 0;
}
inline ::bosdyn::api::BatteryChangePoseCommand_Request_DirectionHint BatteryChangePoseCommand_Request::_internal_direction_hint() const {
  return static_cast< ::bosdyn::api::BatteryChangePoseCommand_Request_DirectionHint >(_impl_.direction_hint_);
}
inline ::bosdyn::api::BatteryChangePoseCommand_Request_DirectionHint BatteryChangePoseCommand_Request::direction_hint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryChangePoseCommand.Request.direction_hint)
  return _internal_direction_hint();
}
inline void BatteryChangePoseCommand_Request::_internal_set_direction_hint(::bosdyn::api::BatteryChangePoseCommand_Request_DirectionHint value) {
  
  _impl_.direction_hint_ = value;
}
inline void BatteryChangePoseCommand_Request::set_direction_hint(::bosdyn::api::BatteryChangePoseCommand_Request_DirectionHint value) {
  _internal_set_direction_hint(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.BatteryChangePoseCommand.Request.direction_hint)
}

// -------------------------------------------------------------------

// BatteryChangePoseCommand_Feedback

// .bosdyn.api.BatteryChangePoseCommand.Feedback.Status status = 1;
inline void BatteryChangePoseCommand_Feedback::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::BatteryChangePoseCommand_Feedback_Status BatteryChangePoseCommand_Feedback::_internal_status() const {
  return static_cast< ::bosdyn::api::BatteryChangePoseCommand_Feedback_Status >(_impl_.status_);
}
inline ::bosdyn::api::BatteryChangePoseCommand_Feedback_Status BatteryChangePoseCommand_Feedback::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryChangePoseCommand.Feedback.status)
  return _internal_status();
}
inline void BatteryChangePoseCommand_Feedback::_internal_set_status(::bosdyn::api::BatteryChangePoseCommand_Feedback_Status value) {
  
  _impl_.status_ = value;
}
inline void BatteryChangePoseCommand_Feedback::set_status(::bosdyn::api::BatteryChangePoseCommand_Feedback_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.BatteryChangePoseCommand.Feedback.status)
}

// -------------------------------------------------------------------

// BatteryChangePoseCommand

// -------------------------------------------------------------------

// SelfRightCommand_Request

// -------------------------------------------------------------------

// SelfRightCommand_Feedback

// .bosdyn.api.SelfRightCommand.Feedback.Status status = 1;
inline void SelfRightCommand_Feedback::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::SelfRightCommand_Feedback_Status SelfRightCommand_Feedback::_internal_status() const {
  return static_cast< ::bosdyn::api::SelfRightCommand_Feedback_Status >(_impl_.status_);
}
inline ::bosdyn::api::SelfRightCommand_Feedback_Status SelfRightCommand_Feedback::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SelfRightCommand.Feedback.status)
  return _internal_status();
}
inline void SelfRightCommand_Feedback::_internal_set_status(::bosdyn::api::SelfRightCommand_Feedback_Status value) {
  
  _impl_.status_ = value;
}
inline void SelfRightCommand_Feedback::set_status(::bosdyn::api::SelfRightCommand_Feedback_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SelfRightCommand.Feedback.status)
}

// -------------------------------------------------------------------

// SelfRightCommand

// -------------------------------------------------------------------

// StopCommand_Request

// -------------------------------------------------------------------

// StopCommand_Feedback

// -------------------------------------------------------------------

// StopCommand

// -------------------------------------------------------------------

// FreezeCommand_Request

// -------------------------------------------------------------------

// FreezeCommand_Feedback

// -------------------------------------------------------------------

// FreezeCommand

// -------------------------------------------------------------------

// SafePowerOffCommand_Request

// .bosdyn.api.SafePowerOffCommand.Request.UnsafeAction unsafe_action = 1;
inline void SafePowerOffCommand_Request::clear_unsafe_action() {
  _impl_.unsafe_action_ = 0;
}
inline ::bosdyn::api::SafePowerOffCommand_Request_UnsafeAction SafePowerOffCommand_Request::_internal_unsafe_action() const {
  return static_cast< ::bosdyn::api::SafePowerOffCommand_Request_UnsafeAction >(_impl_.unsafe_action_);
}
inline ::bosdyn::api::SafePowerOffCommand_Request_UnsafeAction SafePowerOffCommand_Request::unsafe_action() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SafePowerOffCommand.Request.unsafe_action)
  return _internal_unsafe_action();
}
inline void SafePowerOffCommand_Request::_internal_set_unsafe_action(::bosdyn::api::SafePowerOffCommand_Request_UnsafeAction value) {
  
  _impl_.unsafe_action_ = value;
}
inline void SafePowerOffCommand_Request::set_unsafe_action(::bosdyn::api::SafePowerOffCommand_Request_UnsafeAction value) {
  _internal_set_unsafe_action(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SafePowerOffCommand.Request.unsafe_action)
}

// -------------------------------------------------------------------

// SafePowerOffCommand_Feedback

// .bosdyn.api.SafePowerOffCommand.Feedback.Status status = 1;
inline void SafePowerOffCommand_Feedback::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::SafePowerOffCommand_Feedback_Status SafePowerOffCommand_Feedback::_internal_status() const {
  return static_cast< ::bosdyn::api::SafePowerOffCommand_Feedback_Status >(_impl_.status_);
}
inline ::bosdyn::api::SafePowerOffCommand_Feedback_Status SafePowerOffCommand_Feedback::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SafePowerOffCommand.Feedback.status)
  return _internal_status();
}
inline void SafePowerOffCommand_Feedback::_internal_set_status(::bosdyn::api::SafePowerOffCommand_Feedback_Status value) {
  
  _impl_.status_ = value;
}
inline void SafePowerOffCommand_Feedback::set_status(::bosdyn::api::SafePowerOffCommand_Feedback_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SafePowerOffCommand.Feedback.status)
}

// -------------------------------------------------------------------

// SafePowerOffCommand

// -------------------------------------------------------------------

// SE2TrajectoryCommand_Request

// .google.protobuf.Timestamp end_time = 1;
inline bool SE2TrajectoryCommand_Request::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool SE2TrajectoryCommand_Request::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SE2TrajectoryCommand_Request::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SE2TrajectoryCommand_Request::end_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2TrajectoryCommand.Request.end_time)
  return _internal_end_time();
}
inline void SE2TrajectoryCommand_Request::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE2TrajectoryCommand.Request.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SE2TrajectoryCommand_Request::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SE2TrajectoryCommand_Request::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE2TrajectoryCommand.Request.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SE2TrajectoryCommand_Request::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SE2TrajectoryCommand_Request::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE2TrajectoryCommand.Request.end_time)
  return _msg;
}
inline void SE2TrajectoryCommand_Request::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE2TrajectoryCommand.Request.end_time)
}

// string se2_frame_name = 3;
inline void SE2TrajectoryCommand_Request::clear_se2_frame_name() {
  _impl_.se2_frame_name_.ClearToEmpty();
}
inline const std::string& SE2TrajectoryCommand_Request::se2_frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2TrajectoryCommand.Request.se2_frame_name)
  return _internal_se2_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SE2TrajectoryCommand_Request::set_se2_frame_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.se2_frame_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.SE2TrajectoryCommand.Request.se2_frame_name)
}
inline std::string* SE2TrajectoryCommand_Request::mutable_se2_frame_name() {
  std::string* _s = _internal_mutable_se2_frame_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE2TrajectoryCommand.Request.se2_frame_name)
  return _s;
}
inline const std::string& SE2TrajectoryCommand_Request::_internal_se2_frame_name() const {
  return _impl_.se2_frame_name_.Get();
}
inline void SE2TrajectoryCommand_Request::_internal_set_se2_frame_name(const std::string& value) {
  
  _impl_.se2_frame_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SE2TrajectoryCommand_Request::_internal_mutable_se2_frame_name() {
  
  return _impl_.se2_frame_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SE2TrajectoryCommand_Request::release_se2_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE2TrajectoryCommand.Request.se2_frame_name)
  return _impl_.se2_frame_name_.Release();
}
inline void SE2TrajectoryCommand_Request::set_allocated_se2_frame_name(std::string* se2_frame_name) {
  if (se2_frame_name != nullptr) {
    
  } else {
    
  }
  _impl_.se2_frame_name_.SetAllocated(se2_frame_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.se2_frame_name_.IsDefault()) {
    _impl_.se2_frame_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE2TrajectoryCommand.Request.se2_frame_name)
}

// .bosdyn.api.SE2Trajectory trajectory = 2;
inline bool SE2TrajectoryCommand_Request::_internal_has_trajectory() const {
  return this != internal_default_instance() && _impl_.trajectory_ != nullptr;
}
inline bool SE2TrajectoryCommand_Request::has_trajectory() const {
  return _internal_has_trajectory();
}
inline const ::bosdyn::api::SE2Trajectory& SE2TrajectoryCommand_Request::_internal_trajectory() const {
  const ::bosdyn::api::SE2Trajectory* p = _impl_.trajectory_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE2Trajectory&>(
      ::bosdyn::api::_SE2Trajectory_default_instance_);
}
inline const ::bosdyn::api::SE2Trajectory& SE2TrajectoryCommand_Request::trajectory() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2TrajectoryCommand.Request.trajectory)
  return _internal_trajectory();
}
inline void SE2TrajectoryCommand_Request::unsafe_arena_set_allocated_trajectory(
    ::bosdyn::api::SE2Trajectory* trajectory) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trajectory_);
  }
  _impl_.trajectory_ = trajectory;
  if (trajectory) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE2TrajectoryCommand.Request.trajectory)
}
inline ::bosdyn::api::SE2Trajectory* SE2TrajectoryCommand_Request::release_trajectory() {
  
  ::bosdyn::api::SE2Trajectory* temp = _impl_.trajectory_;
  _impl_.trajectory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE2Trajectory* SE2TrajectoryCommand_Request::unsafe_arena_release_trajectory() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE2TrajectoryCommand.Request.trajectory)
  
  ::bosdyn::api::SE2Trajectory* temp = _impl_.trajectory_;
  _impl_.trajectory_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE2Trajectory* SE2TrajectoryCommand_Request::_internal_mutable_trajectory() {
  
  if (_impl_.trajectory_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE2Trajectory>(GetArenaForAllocation());
    _impl_.trajectory_ = p;
  }
  return _impl_.trajectory_;
}
inline ::bosdyn::api::SE2Trajectory* SE2TrajectoryCommand_Request::mutable_trajectory() {
  ::bosdyn::api::SE2Trajectory* _msg = _internal_mutable_trajectory();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE2TrajectoryCommand.Request.trajectory)
  return _msg;
}
inline void SE2TrajectoryCommand_Request::set_allocated_trajectory(::bosdyn::api::SE2Trajectory* trajectory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trajectory_);
  }
  if (trajectory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trajectory));
    if (message_arena != submessage_arena) {
      trajectory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trajectory, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trajectory_ = trajectory;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE2TrajectoryCommand.Request.trajectory)
}

// -------------------------------------------------------------------

// SE2TrajectoryCommand_Feedback

// .bosdyn.api.SE2TrajectoryCommand.Feedback.Status status = 1;
inline void SE2TrajectoryCommand_Feedback::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::SE2TrajectoryCommand_Feedback_Status SE2TrajectoryCommand_Feedback::_internal_status() const {
  return static_cast< ::bosdyn::api::SE2TrajectoryCommand_Feedback_Status >(_impl_.status_);
}
inline ::bosdyn::api::SE2TrajectoryCommand_Feedback_Status SE2TrajectoryCommand_Feedback::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2TrajectoryCommand.Feedback.status)
  return _internal_status();
}
inline void SE2TrajectoryCommand_Feedback::_internal_set_status(::bosdyn::api::SE2TrajectoryCommand_Feedback_Status value) {
  
  _impl_.status_ = value;
}
inline void SE2TrajectoryCommand_Feedback::set_status(::bosdyn::api::SE2TrajectoryCommand_Feedback_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE2TrajectoryCommand.Feedback.status)
}

// .bosdyn.api.SE2TrajectoryCommand.Feedback.BodyMovementStatus body_movement_status = 2;
inline void SE2TrajectoryCommand_Feedback::clear_body_movement_status() {
  _impl_.body_movement_status_ = 0;
}
inline ::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus SE2TrajectoryCommand_Feedback::_internal_body_movement_status() const {
  return static_cast< ::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus >(_impl_.body_movement_status_);
}
inline ::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus SE2TrajectoryCommand_Feedback::body_movement_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2TrajectoryCommand.Feedback.body_movement_status)
  return _internal_body_movement_status();
}
inline void SE2TrajectoryCommand_Feedback::_internal_set_body_movement_status(::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus value) {
  
  _impl_.body_movement_status_ = value;
}
inline void SE2TrajectoryCommand_Feedback::set_body_movement_status(::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus value) {
  _internal_set_body_movement_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE2TrajectoryCommand.Feedback.body_movement_status)
}

// -------------------------------------------------------------------

// SE2TrajectoryCommand

// -------------------------------------------------------------------

// SE2VelocityCommand_Request

// .google.protobuf.Timestamp end_time = 1;
inline bool SE2VelocityCommand_Request::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool SE2VelocityCommand_Request::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SE2VelocityCommand_Request::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SE2VelocityCommand_Request::end_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2VelocityCommand.Request.end_time)
  return _internal_end_time();
}
inline void SE2VelocityCommand_Request::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE2VelocityCommand.Request.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SE2VelocityCommand_Request::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SE2VelocityCommand_Request::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE2VelocityCommand.Request.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SE2VelocityCommand_Request::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SE2VelocityCommand_Request::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE2VelocityCommand.Request.end_time)
  return _msg;
}
inline void SE2VelocityCommand_Request::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE2VelocityCommand.Request.end_time)
}

// string se2_frame_name = 5;
inline void SE2VelocityCommand_Request::clear_se2_frame_name() {
  _impl_.se2_frame_name_.ClearToEmpty();
}
inline const std::string& SE2VelocityCommand_Request::se2_frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2VelocityCommand.Request.se2_frame_name)
  return _internal_se2_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SE2VelocityCommand_Request::set_se2_frame_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.se2_frame_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.SE2VelocityCommand.Request.se2_frame_name)
}
inline std::string* SE2VelocityCommand_Request::mutable_se2_frame_name() {
  std::string* _s = _internal_mutable_se2_frame_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE2VelocityCommand.Request.se2_frame_name)
  return _s;
}
inline const std::string& SE2VelocityCommand_Request::_internal_se2_frame_name() const {
  return _impl_.se2_frame_name_.Get();
}
inline void SE2VelocityCommand_Request::_internal_set_se2_frame_name(const std::string& value) {
  
  _impl_.se2_frame_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SE2VelocityCommand_Request::_internal_mutable_se2_frame_name() {
  
  return _impl_.se2_frame_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SE2VelocityCommand_Request::release_se2_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE2VelocityCommand.Request.se2_frame_name)
  return _impl_.se2_frame_name_.Release();
}
inline void SE2VelocityCommand_Request::set_allocated_se2_frame_name(std::string* se2_frame_name) {
  if (se2_frame_name != nullptr) {
    
  } else {
    
  }
  _impl_.se2_frame_name_.SetAllocated(se2_frame_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.se2_frame_name_.IsDefault()) {
    _impl_.se2_frame_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE2VelocityCommand.Request.se2_frame_name)
}

// .bosdyn.api.SE2Velocity velocity = 2;
inline bool SE2VelocityCommand_Request::_internal_has_velocity() const {
  return this != internal_default_instance() && _impl_.velocity_ != nullptr;
}
inline bool SE2VelocityCommand_Request::has_velocity() const {
  return _internal_has_velocity();
}
inline const ::bosdyn::api::SE2Velocity& SE2VelocityCommand_Request::_internal_velocity() const {
  const ::bosdyn::api::SE2Velocity* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE2Velocity&>(
      ::bosdyn::api::_SE2Velocity_default_instance_);
}
inline const ::bosdyn::api::SE2Velocity& SE2VelocityCommand_Request::velocity() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2VelocityCommand.Request.velocity)
  return _internal_velocity();
}
inline void SE2VelocityCommand_Request::unsafe_arena_set_allocated_velocity(
    ::bosdyn::api::SE2Velocity* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE2VelocityCommand.Request.velocity)
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityCommand_Request::release_velocity() {
  
  ::bosdyn::api::SE2Velocity* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityCommand_Request::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE2VelocityCommand.Request.velocity)
  
  ::bosdyn::api::SE2Velocity* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityCommand_Request::_internal_mutable_velocity() {
  
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE2Velocity>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityCommand_Request::mutable_velocity() {
  ::bosdyn::api::SE2Velocity* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE2VelocityCommand.Request.velocity)
  return _msg;
}
inline void SE2VelocityCommand_Request::set_allocated_velocity(::bosdyn::api::SE2Velocity* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity));
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE2VelocityCommand.Request.velocity)
}

// .bosdyn.api.SE2Velocity slew_rate_limit = 4;
inline bool SE2VelocityCommand_Request::_internal_has_slew_rate_limit() const {
  return this != internal_default_instance() && _impl_.slew_rate_limit_ != nullptr;
}
inline bool SE2VelocityCommand_Request::has_slew_rate_limit() const {
  return _internal_has_slew_rate_limit();
}
inline const ::bosdyn::api::SE2Velocity& SE2VelocityCommand_Request::_internal_slew_rate_limit() const {
  const ::bosdyn::api::SE2Velocity* p = _impl_.slew_rate_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE2Velocity&>(
      ::bosdyn::api::_SE2Velocity_default_instance_);
}
inline const ::bosdyn::api::SE2Velocity& SE2VelocityCommand_Request::slew_rate_limit() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2VelocityCommand.Request.slew_rate_limit)
  return _internal_slew_rate_limit();
}
inline void SE2VelocityCommand_Request::unsafe_arena_set_allocated_slew_rate_limit(
    ::bosdyn::api::SE2Velocity* slew_rate_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.slew_rate_limit_);
  }
  _impl_.slew_rate_limit_ = slew_rate_limit;
  if (slew_rate_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE2VelocityCommand.Request.slew_rate_limit)
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityCommand_Request::release_slew_rate_limit() {
  
  ::bosdyn::api::SE2Velocity* temp = _impl_.slew_rate_limit_;
  _impl_.slew_rate_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityCommand_Request::unsafe_arena_release_slew_rate_limit() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE2VelocityCommand.Request.slew_rate_limit)
  
  ::bosdyn::api::SE2Velocity* temp = _impl_.slew_rate_limit_;
  _impl_.slew_rate_limit_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityCommand_Request::_internal_mutable_slew_rate_limit() {
  
  if (_impl_.slew_rate_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE2Velocity>(GetArenaForAllocation());
    _impl_.slew_rate_limit_ = p;
  }
  return _impl_.slew_rate_limit_;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityCommand_Request::mutable_slew_rate_limit() {
  ::bosdyn::api::SE2Velocity* _msg = _internal_mutable_slew_rate_limit();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE2VelocityCommand.Request.slew_rate_limit)
  return _msg;
}
inline void SE2VelocityCommand_Request::set_allocated_slew_rate_limit(::bosdyn::api::SE2Velocity* slew_rate_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.slew_rate_limit_);
  }
  if (slew_rate_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(slew_rate_limit));
    if (message_arena != submessage_arena) {
      slew_rate_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slew_rate_limit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.slew_rate_limit_ = slew_rate_limit;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE2VelocityCommand.Request.slew_rate_limit)
}

// -------------------------------------------------------------------

// SE2VelocityCommand_Feedback

// -------------------------------------------------------------------

// SE2VelocityCommand

// -------------------------------------------------------------------

// SitCommand_Request

// -------------------------------------------------------------------

// SitCommand_Feedback

// .bosdyn.api.SitCommand.Feedback.Status status = 2;
inline void SitCommand_Feedback::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::SitCommand_Feedback_Status SitCommand_Feedback::_internal_status() const {
  return static_cast< ::bosdyn::api::SitCommand_Feedback_Status >(_impl_.status_);
}
inline ::bosdyn::api::SitCommand_Feedback_Status SitCommand_Feedback::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SitCommand.Feedback.status)
  return _internal_status();
}
inline void SitCommand_Feedback::_internal_set_status(::bosdyn::api::SitCommand_Feedback_Status value) {
  
  _impl_.status_ = value;
}
inline void SitCommand_Feedback::set_status(::bosdyn::api::SitCommand_Feedback_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SitCommand.Feedback.status)
}

// -------------------------------------------------------------------

// SitCommand

// -------------------------------------------------------------------

// StandCommand_Request

// -------------------------------------------------------------------

// StandCommand_Feedback

// .bosdyn.api.StandCommand.Feedback.Status status = 1;
inline void StandCommand_Feedback::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::StandCommand_Feedback_Status StandCommand_Feedback::_internal_status() const {
  return static_cast< ::bosdyn::api::StandCommand_Feedback_Status >(_impl_.status_);
}
inline ::bosdyn::api::StandCommand_Feedback_Status StandCommand_Feedback::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StandCommand.Feedback.status)
  return _internal_status();
}
inline void StandCommand_Feedback::_internal_set_status(::bosdyn::api::StandCommand_Feedback_Status value) {
  
  _impl_.status_ = value;
}
inline void StandCommand_Feedback::set_status(::bosdyn::api::StandCommand_Feedback_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.StandCommand.Feedback.status)
}

// .bosdyn.api.StandCommand.Feedback.StandingState standing_state = 2;
inline void StandCommand_Feedback::clear_standing_state() {
  _impl_.standing_state_ = 0;
}
inline ::bosdyn::api::StandCommand_Feedback_StandingState StandCommand_Feedback::_internal_standing_state() const {
  return static_cast< ::bosdyn::api::StandCommand_Feedback_StandingState >(_impl_.standing_state_);
}
inline ::bosdyn::api::StandCommand_Feedback_StandingState StandCommand_Feedback::standing_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StandCommand.Feedback.standing_state)
  return _internal_standing_state();
}
inline void StandCommand_Feedback::_internal_set_standing_state(::bosdyn::api::StandCommand_Feedback_StandingState value) {
  
  _impl_.standing_state_ = value;
}
inline void StandCommand_Feedback::set_standing_state(::bosdyn::api::StandCommand_Feedback_StandingState value) {
  _internal_set_standing_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.StandCommand.Feedback.standing_state)
}

// -------------------------------------------------------------------

// StandCommand

// -------------------------------------------------------------------

// StanceCommand_Request

// .google.protobuf.Timestamp end_time = 1;
inline bool StanceCommand_Request::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool StanceCommand_Request::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StanceCommand_Request::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StanceCommand_Request::end_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StanceCommand.Request.end_time)
  return _internal_end_time();
}
inline void StanceCommand_Request::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StanceCommand.Request.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StanceCommand_Request::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StanceCommand_Request::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StanceCommand.Request.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StanceCommand_Request::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StanceCommand_Request::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StanceCommand.Request.end_time)
  return _msg;
}
inline void StanceCommand_Request::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StanceCommand.Request.end_time)
}

// .bosdyn.api.Stance stance = 2;
inline bool StanceCommand_Request::_internal_has_stance() const {
  return this != internal_default_instance() && _impl_.stance_ != nullptr;
}
inline bool StanceCommand_Request::has_stance() const {
  return _internal_has_stance();
}
inline void StanceCommand_Request::clear_stance() {
  if (GetArenaForAllocation() == nullptr && _impl_.stance_ != nullptr) {
    delete _impl_.stance_;
  }
  _impl_.stance_ = nullptr;
}
inline const ::bosdyn::api::Stance& StanceCommand_Request::_internal_stance() const {
  const ::bosdyn::api::Stance* p = _impl_.stance_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Stance&>(
      ::bosdyn::api::_Stance_default_instance_);
}
inline const ::bosdyn::api::Stance& StanceCommand_Request::stance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StanceCommand.Request.stance)
  return _internal_stance();
}
inline void StanceCommand_Request::unsafe_arena_set_allocated_stance(
    ::bosdyn::api::Stance* stance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stance_);
  }
  _impl_.stance_ = stance;
  if (stance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.StanceCommand.Request.stance)
}
inline ::bosdyn::api::Stance* StanceCommand_Request::release_stance() {
  
  ::bosdyn::api::Stance* temp = _impl_.stance_;
  _impl_.stance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Stance* StanceCommand_Request::unsafe_arena_release_stance() {
  // @@protoc_insertion_point(field_release:bosdyn.api.StanceCommand.Request.stance)
  
  ::bosdyn::api::Stance* temp = _impl_.stance_;
  _impl_.stance_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Stance* StanceCommand_Request::_internal_mutable_stance() {
  
  if (_impl_.stance_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Stance>(GetArenaForAllocation());
    _impl_.stance_ = p;
  }
  return _impl_.stance_;
}
inline ::bosdyn::api::Stance* StanceCommand_Request::mutable_stance() {
  ::bosdyn::api::Stance* _msg = _internal_mutable_stance();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.StanceCommand.Request.stance)
  return _msg;
}
inline void StanceCommand_Request::set_allocated_stance(::bosdyn::api::Stance* stance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stance_;
  }
  if (stance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stance);
    if (message_arena != submessage_arena) {
      stance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stance_ = stance;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.StanceCommand.Request.stance)
}

// -------------------------------------------------------------------

// StanceCommand_Feedback

// .bosdyn.api.StanceCommand.Feedback.Status status = 1;
inline void StanceCommand_Feedback::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::StanceCommand_Feedback_Status StanceCommand_Feedback::_internal_status() const {
  return static_cast< ::bosdyn::api::StanceCommand_Feedback_Status >(_impl_.status_);
}
inline ::bosdyn::api::StanceCommand_Feedback_Status StanceCommand_Feedback::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.StanceCommand.Feedback.status)
  return _internal_status();
}
inline void StanceCommand_Feedback::_internal_set_status(::bosdyn::api::StanceCommand_Feedback_Status value) {
  
  _impl_.status_ = value;
}
inline void StanceCommand_Feedback::set_status(::bosdyn::api::StanceCommand_Feedback_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.StanceCommand.Feedback.status)
}

// -------------------------------------------------------------------

// StanceCommand

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Stance

// string se2_frame_name = 3;
inline void Stance::clear_se2_frame_name() {
  _impl_.se2_frame_name_.ClearToEmpty();
}
inline const std::string& Stance::se2_frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Stance.se2_frame_name)
  return _internal_se2_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stance::set_se2_frame_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.se2_frame_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.Stance.se2_frame_name)
}
inline std::string* Stance::mutable_se2_frame_name() {
  std::string* _s = _internal_mutable_se2_frame_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Stance.se2_frame_name)
  return _s;
}
inline const std::string& Stance::_internal_se2_frame_name() const {
  return _impl_.se2_frame_name_.Get();
}
inline void Stance::_internal_set_se2_frame_name(const std::string& value) {
  
  _impl_.se2_frame_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Stance::_internal_mutable_se2_frame_name() {
  
  return _impl_.se2_frame_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Stance::release_se2_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Stance.se2_frame_name)
  return _impl_.se2_frame_name_.Release();
}
inline void Stance::set_allocated_se2_frame_name(std::string* se2_frame_name) {
  if (se2_frame_name != nullptr) {
    
  } else {
    
  }
  _impl_.se2_frame_name_.SetAllocated(se2_frame_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.se2_frame_name_.IsDefault()) {
    _impl_.se2_frame_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Stance.se2_frame_name)
}

// map<string, .bosdyn.api.Vec2> foot_positions = 2;
inline int Stance::_internal_foot_positions_size() const {
  return _impl_.foot_positions_.size();
}
inline int Stance::foot_positions_size() const {
  return _internal_foot_positions_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::Vec2 >&
Stance::_internal_foot_positions() const {
  return _impl_.foot_positions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::Vec2 >&
Stance::foot_positions() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.Stance.foot_positions)
  return _internal_foot_positions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::Vec2 >*
Stance::_internal_mutable_foot_positions() {
  return _impl_.foot_positions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::Vec2 >*
Stance::mutable_foot_positions() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.Stance.foot_positions)
  return _internal_mutable_foot_positions();
}

// float accuracy = 4;
inline void Stance::clear_accuracy() {
  _impl_.accuracy_ = 0;
}
inline float Stance::_internal_accuracy() const {
  return _impl_.accuracy_;
}
inline float Stance::accuracy() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Stance.accuracy)
  return _internal_accuracy();
}
inline void Stance::_internal_set_accuracy(float value) {
  
  _impl_.accuracy_ = value;
}
inline void Stance::set_accuracy(float value) {
  _internal_set_accuracy(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Stance.accuracy)
}

// -------------------------------------------------------------------

// FollowArmCommand_Request

// .bosdyn.api.Vec3 body_offset_from_hand = 1;
inline bool FollowArmCommand_Request::_internal_has_body_offset_from_hand() const {
  return this != internal_default_instance() && _impl_.body_offset_from_hand_ != nullptr;
}
inline bool FollowArmCommand_Request::has_body_offset_from_hand() const {
  return _internal_has_body_offset_from_hand();
}
inline const ::bosdyn::api::Vec3& FollowArmCommand_Request::_internal_body_offset_from_hand() const {
  const ::bosdyn::api::Vec3* p = _impl_.body_offset_from_hand_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& FollowArmCommand_Request::body_offset_from_hand() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FollowArmCommand.Request.body_offset_from_hand)
  return _internal_body_offset_from_hand();
}
inline void FollowArmCommand_Request::unsafe_arena_set_allocated_body_offset_from_hand(
    ::bosdyn::api::Vec3* body_offset_from_hand) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_offset_from_hand_);
  }
  _impl_.body_offset_from_hand_ = body_offset_from_hand;
  if (body_offset_from_hand) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FollowArmCommand.Request.body_offset_from_hand)
}
inline ::bosdyn::api::Vec3* FollowArmCommand_Request::release_body_offset_from_hand() {
  
  ::bosdyn::api::Vec3* temp = _impl_.body_offset_from_hand_;
  _impl_.body_offset_from_hand_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* FollowArmCommand_Request::unsafe_arena_release_body_offset_from_hand() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FollowArmCommand.Request.body_offset_from_hand)
  
  ::bosdyn::api::Vec3* temp = _impl_.body_offset_from_hand_;
  _impl_.body_offset_from_hand_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* FollowArmCommand_Request::_internal_mutable_body_offset_from_hand() {
  
  if (_impl_.body_offset_from_hand_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.body_offset_from_hand_ = p;
  }
  return _impl_.body_offset_from_hand_;
}
inline ::bosdyn::api::Vec3* FollowArmCommand_Request::mutable_body_offset_from_hand() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_body_offset_from_hand();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FollowArmCommand.Request.body_offset_from_hand)
  return _msg;
}
inline void FollowArmCommand_Request::set_allocated_body_offset_from_hand(::bosdyn::api::Vec3* body_offset_from_hand) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_offset_from_hand_);
  }
  if (body_offset_from_hand) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(body_offset_from_hand));
    if (message_arena != submessage_arena) {
      body_offset_from_hand = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_offset_from_hand, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.body_offset_from_hand_ = body_offset_from_hand;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FollowArmCommand.Request.body_offset_from_hand)
}

// bool disable_walking = 2 [deprecated = true];
inline void FollowArmCommand_Request::clear_disable_walking() {
  _impl_.disable_walking_ = false;
}
inline bool FollowArmCommand_Request::_internal_disable_walking() const {
  return _impl_.disable_walking_;
}
inline bool FollowArmCommand_Request::disable_walking() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FollowArmCommand.Request.disable_walking)
  return _internal_disable_walking();
}
inline void FollowArmCommand_Request::_internal_set_disable_walking(bool value) {
  
  _impl_.disable_walking_ = value;
}
inline void FollowArmCommand_Request::set_disable_walking(bool value) {
  _internal_set_disable_walking(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.FollowArmCommand.Request.disable_walking)
}

// -------------------------------------------------------------------

// FollowArmCommand_Feedback

// -------------------------------------------------------------------

// FollowArmCommand

// -------------------------------------------------------------------

// ArmDragCommand_Request

// -------------------------------------------------------------------

// ArmDragCommand_Feedback

// .bosdyn.api.ArmDragCommand.Feedback.Status status = 1;
inline void ArmDragCommand_Feedback::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::ArmDragCommand_Feedback_Status ArmDragCommand_Feedback::_internal_status() const {
  return static_cast< ::bosdyn::api::ArmDragCommand_Feedback_Status >(_impl_.status_);
}
inline ::bosdyn::api::ArmDragCommand_Feedback_Status ArmDragCommand_Feedback::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ArmDragCommand.Feedback.status)
  return _internal_status();
}
inline void ArmDragCommand_Feedback::_internal_set_status(::bosdyn::api::ArmDragCommand_Feedback_Status value) {
  
  _impl_.status_ = value;
}
inline void ArmDragCommand_Feedback::set_status(::bosdyn::api::ArmDragCommand_Feedback_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ArmDragCommand.Feedback.status)
}

// -------------------------------------------------------------------

// ArmDragCommand

// -------------------------------------------------------------------

// ConstrainedManipulationCommand_Request

// string frame_name = 1;
inline void ConstrainedManipulationCommand_Request::clear_frame_name() {
  _impl_.frame_name_.ClearToEmpty();
}
inline const std::string& ConstrainedManipulationCommand_Request::frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ConstrainedManipulationCommand.Request.frame_name)
  return _internal_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConstrainedManipulationCommand_Request::set_frame_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.ConstrainedManipulationCommand.Request.frame_name)
}
inline std::string* ConstrainedManipulationCommand_Request::mutable_frame_name() {
  std::string* _s = _internal_mutable_frame_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ConstrainedManipulationCommand.Request.frame_name)
  return _s;
}
inline const std::string& ConstrainedManipulationCommand_Request::_internal_frame_name() const {
  return _impl_.frame_name_.Get();
}
inline void ConstrainedManipulationCommand_Request::_internal_set_frame_name(const std::string& value) {
  
  _impl_.frame_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ConstrainedManipulationCommand_Request::_internal_mutable_frame_name() {
  
  return _impl_.frame_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ConstrainedManipulationCommand_Request::release_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ConstrainedManipulationCommand.Request.frame_name)
  return _impl_.frame_name_.Release();
}
inline void ConstrainedManipulationCommand_Request::set_allocated_frame_name(std::string* frame_name) {
  if (frame_name != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_.SetAllocated(frame_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_.IsDefault()) {
    _impl_.frame_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ConstrainedManipulationCommand.Request.frame_name)
}

// .bosdyn.api.Wrench init_wrench_direction_in_frame_name = 2;
inline bool ConstrainedManipulationCommand_Request::_internal_has_init_wrench_direction_in_frame_name() const {
  return this != internal_default_instance() && _impl_.init_wrench_direction_in_frame_name_ != nullptr;
}
inline bool ConstrainedManipulationCommand_Request::has_init_wrench_direction_in_frame_name() const {
  return _internal_has_init_wrench_direction_in_frame_name();
}
inline const ::bosdyn::api::Wrench& ConstrainedManipulationCommand_Request::_internal_init_wrench_direction_in_frame_name() const {
  const ::bosdyn::api::Wrench* p = _impl_.init_wrench_direction_in_frame_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Wrench&>(
      ::bosdyn::api::_Wrench_default_instance_);
}
inline const ::bosdyn::api::Wrench& ConstrainedManipulationCommand_Request::init_wrench_direction_in_frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ConstrainedManipulationCommand.Request.init_wrench_direction_in_frame_name)
  return _internal_init_wrench_direction_in_frame_name();
}
inline void ConstrainedManipulationCommand_Request::unsafe_arena_set_allocated_init_wrench_direction_in_frame_name(
    ::bosdyn::api::Wrench* init_wrench_direction_in_frame_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.init_wrench_direction_in_frame_name_);
  }
  _impl_.init_wrench_direction_in_frame_name_ = init_wrench_direction_in_frame_name;
  if (init_wrench_direction_in_frame_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ConstrainedManipulationCommand.Request.init_wrench_direction_in_frame_name)
}
inline ::bosdyn::api::Wrench* ConstrainedManipulationCommand_Request::release_init_wrench_direction_in_frame_name() {
  
  ::bosdyn::api::Wrench* temp = _impl_.init_wrench_direction_in_frame_name_;
  _impl_.init_wrench_direction_in_frame_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Wrench* ConstrainedManipulationCommand_Request::unsafe_arena_release_init_wrench_direction_in_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ConstrainedManipulationCommand.Request.init_wrench_direction_in_frame_name)
  
  ::bosdyn::api::Wrench* temp = _impl_.init_wrench_direction_in_frame_name_;
  _impl_.init_wrench_direction_in_frame_name_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Wrench* ConstrainedManipulationCommand_Request::_internal_mutable_init_wrench_direction_in_frame_name() {
  
  if (_impl_.init_wrench_direction_in_frame_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Wrench>(GetArenaForAllocation());
    _impl_.init_wrench_direction_in_frame_name_ = p;
  }
  return _impl_.init_wrench_direction_in_frame_name_;
}
inline ::bosdyn::api::Wrench* ConstrainedManipulationCommand_Request::mutable_init_wrench_direction_in_frame_name() {
  ::bosdyn::api::Wrench* _msg = _internal_mutable_init_wrench_direction_in_frame_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ConstrainedManipulationCommand.Request.init_wrench_direction_in_frame_name)
  return _msg;
}
inline void ConstrainedManipulationCommand_Request::set_allocated_init_wrench_direction_in_frame_name(::bosdyn::api::Wrench* init_wrench_direction_in_frame_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.init_wrench_direction_in_frame_name_);
  }
  if (init_wrench_direction_in_frame_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(init_wrench_direction_in_frame_name));
    if (message_arena != submessage_arena) {
      init_wrench_direction_in_frame_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, init_wrench_direction_in_frame_name, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.init_wrench_direction_in_frame_name_ = init_wrench_direction_in_frame_name;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ConstrainedManipulationCommand.Request.init_wrench_direction_in_frame_name)
}

// double tangential_speed = 3;
inline bool ConstrainedManipulationCommand_Request::_internal_has_tangential_speed() const {
  return task_speed_case() == kTangentialSpeed;
}
inline bool ConstrainedManipulationCommand_Request::has_tangential_speed() const {
  return _internal_has_tangential_speed();
}
inline void ConstrainedManipulationCommand_Request::set_has_tangential_speed() {
  _impl_._oneof_case_[0] = kTangentialSpeed;
}
inline void ConstrainedManipulationCommand_Request::clear_tangential_speed() {
  if (_internal_has_tangential_speed()) {
    _impl_.task_speed_.tangential_speed_ = 0;
    clear_has_task_speed();
  }
}
inline double ConstrainedManipulationCommand_Request::_internal_tangential_speed() const {
  if (_internal_has_tangential_speed()) {
    return _impl_.task_speed_.tangential_speed_;
  }
  return 0;
}
inline void ConstrainedManipulationCommand_Request::_internal_set_tangential_speed(double value) {
  if (!_internal_has_tangential_speed()) {
    clear_task_speed();
    set_has_tangential_speed();
  }
  _impl_.task_speed_.tangential_speed_ = value;
}
inline double ConstrainedManipulationCommand_Request::tangential_speed() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ConstrainedManipulationCommand.Request.tangential_speed)
  return _internal_tangential_speed();
}
inline void ConstrainedManipulationCommand_Request::set_tangential_speed(double value) {
  _internal_set_tangential_speed(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ConstrainedManipulationCommand.Request.tangential_speed)
}

// double rotational_speed = 4;
inline bool ConstrainedManipulationCommand_Request::_internal_has_rotational_speed() const {
  return task_speed_case() == kRotationalSpeed;
}
inline bool ConstrainedManipulationCommand_Request::has_rotational_speed() const {
  return _internal_has_rotational_speed();
}
inline void ConstrainedManipulationCommand_Request::set_has_rotational_speed() {
  _impl_._oneof_case_[0] = kRotationalSpeed;
}
inline void ConstrainedManipulationCommand_Request::clear_rotational_speed() {
  if (_internal_has_rotational_speed()) {
    _impl_.task_speed_.rotational_speed_ = 0;
    clear_has_task_speed();
  }
}
inline double ConstrainedManipulationCommand_Request::_internal_rotational_speed() const {
  if (_internal_has_rotational_speed()) {
    return _impl_.task_speed_.rotational_speed_;
  }
  return 0;
}
inline void ConstrainedManipulationCommand_Request::_internal_set_rotational_speed(double value) {
  if (!_internal_has_rotational_speed()) {
    clear_task_speed();
    set_has_rotational_speed();
  }
  _impl_.task_speed_.rotational_speed_ = value;
}
inline double ConstrainedManipulationCommand_Request::rotational_speed() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ConstrainedManipulationCommand.Request.rotational_speed)
  return _internal_rotational_speed();
}
inline void ConstrainedManipulationCommand_Request::set_rotational_speed(double value) {
  _internal_set_rotational_speed(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ConstrainedManipulationCommand.Request.rotational_speed)
}

// .google.protobuf.DoubleValue force_limit = 5;
inline bool ConstrainedManipulationCommand_Request::_internal_has_force_limit() const {
  return this != internal_default_instance() && _impl_.force_limit_ != nullptr;
}
inline bool ConstrainedManipulationCommand_Request::has_force_limit() const {
  return _internal_has_force_limit();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ConstrainedManipulationCommand_Request::_internal_force_limit() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.force_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ConstrainedManipulationCommand_Request::force_limit() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ConstrainedManipulationCommand.Request.force_limit)
  return _internal_force_limit();
}
inline void ConstrainedManipulationCommand_Request::unsafe_arena_set_allocated_force_limit(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* force_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.force_limit_);
  }
  _impl_.force_limit_ = force_limit;
  if (force_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ConstrainedManipulationCommand.Request.force_limit)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ConstrainedManipulationCommand_Request::release_force_limit() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.force_limit_;
  _impl_.force_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ConstrainedManipulationCommand_Request::unsafe_arena_release_force_limit() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ConstrainedManipulationCommand.Request.force_limit)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.force_limit_;
  _impl_.force_limit_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ConstrainedManipulationCommand_Request::_internal_mutable_force_limit() {
  
  if (_impl_.force_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.force_limit_ = p;
  }
  return _impl_.force_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ConstrainedManipulationCommand_Request::mutable_force_limit() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_force_limit();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ConstrainedManipulationCommand.Request.force_limit)
  return _msg;
}
inline void ConstrainedManipulationCommand_Request::set_allocated_force_limit(::PROTOBUF_NAMESPACE_ID::DoubleValue* force_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.force_limit_);
  }
  if (force_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(force_limit));
    if (message_arena != submessage_arena) {
      force_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, force_limit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.force_limit_ = force_limit;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ConstrainedManipulationCommand.Request.force_limit)
}

// .google.protobuf.DoubleValue torque_limit = 6;
inline bool ConstrainedManipulationCommand_Request::_internal_has_torque_limit() const {
  return this != internal_default_instance() && _impl_.torque_limit_ != nullptr;
}
inline bool ConstrainedManipulationCommand_Request::has_torque_limit() const {
  return _internal_has_torque_limit();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ConstrainedManipulationCommand_Request::_internal_torque_limit() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.torque_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ConstrainedManipulationCommand_Request::torque_limit() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ConstrainedManipulationCommand.Request.torque_limit)
  return _internal_torque_limit();
}
inline void ConstrainedManipulationCommand_Request::unsafe_arena_set_allocated_torque_limit(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* torque_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.torque_limit_);
  }
  _impl_.torque_limit_ = torque_limit;
  if (torque_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ConstrainedManipulationCommand.Request.torque_limit)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ConstrainedManipulationCommand_Request::release_torque_limit() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.torque_limit_;
  _impl_.torque_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ConstrainedManipulationCommand_Request::unsafe_arena_release_torque_limit() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ConstrainedManipulationCommand.Request.torque_limit)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.torque_limit_;
  _impl_.torque_limit_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ConstrainedManipulationCommand_Request::_internal_mutable_torque_limit() {
  
  if (_impl_.torque_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.torque_limit_ = p;
  }
  return _impl_.torque_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ConstrainedManipulationCommand_Request::mutable_torque_limit() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_torque_limit();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ConstrainedManipulationCommand.Request.torque_limit)
  return _msg;
}
inline void ConstrainedManipulationCommand_Request::set_allocated_torque_limit(::PROTOBUF_NAMESPACE_ID::DoubleValue* torque_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.torque_limit_);
  }
  if (torque_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(torque_limit));
    if (message_arena != submessage_arena) {
      torque_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, torque_limit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.torque_limit_ = torque_limit;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ConstrainedManipulationCommand.Request.torque_limit)
}

// .bosdyn.api.ConstrainedManipulationCommand.Request.TaskType task_type = 7;
inline void ConstrainedManipulationCommand_Request::clear_task_type() {
  _impl_.task_type_ = 0;
}
inline ::bosdyn::api::ConstrainedManipulationCommand_Request_TaskType ConstrainedManipulationCommand_Request::_internal_task_type() const {
  return static_cast< ::bosdyn::api::ConstrainedManipulationCommand_Request_TaskType >(_impl_.task_type_);
}
inline ::bosdyn::api::ConstrainedManipulationCommand_Request_TaskType ConstrainedManipulationCommand_Request::task_type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ConstrainedManipulationCommand.Request.task_type)
  return _internal_task_type();
}
inline void ConstrainedManipulationCommand_Request::_internal_set_task_type(::bosdyn::api::ConstrainedManipulationCommand_Request_TaskType value) {
  
  _impl_.task_type_ = value;
}
inline void ConstrainedManipulationCommand_Request::set_task_type(::bosdyn::api::ConstrainedManipulationCommand_Request_TaskType value) {
  _internal_set_task_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ConstrainedManipulationCommand.Request.task_type)
}

// .google.protobuf.Timestamp end_time = 8;
inline bool ConstrainedManipulationCommand_Request::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool ConstrainedManipulationCommand_Request::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ConstrainedManipulationCommand_Request::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ConstrainedManipulationCommand_Request::end_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ConstrainedManipulationCommand.Request.end_time)
  return _internal_end_time();
}
inline void ConstrainedManipulationCommand_Request::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ConstrainedManipulationCommand.Request.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ConstrainedManipulationCommand_Request::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ConstrainedManipulationCommand_Request::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ConstrainedManipulationCommand.Request.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ConstrainedManipulationCommand_Request::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ConstrainedManipulationCommand_Request::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ConstrainedManipulationCommand.Request.end_time)
  return _msg;
}
inline void ConstrainedManipulationCommand_Request::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ConstrainedManipulationCommand.Request.end_time)
}

// .google.protobuf.BoolValue enable_robot_locomotion = 9;
inline bool ConstrainedManipulationCommand_Request::_internal_has_enable_robot_locomotion() const {
  return this != internal_default_instance() && _impl_.enable_robot_locomotion_ != nullptr;
}
inline bool ConstrainedManipulationCommand_Request::has_enable_robot_locomotion() const {
  return _internal_has_enable_robot_locomotion();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ConstrainedManipulationCommand_Request::_internal_enable_robot_locomotion() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.enable_robot_locomotion_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ConstrainedManipulationCommand_Request::enable_robot_locomotion() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ConstrainedManipulationCommand.Request.enable_robot_locomotion)
  return _internal_enable_robot_locomotion();
}
inline void ConstrainedManipulationCommand_Request::unsafe_arena_set_allocated_enable_robot_locomotion(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* enable_robot_locomotion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enable_robot_locomotion_);
  }
  _impl_.enable_robot_locomotion_ = enable_robot_locomotion;
  if (enable_robot_locomotion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ConstrainedManipulationCommand.Request.enable_robot_locomotion)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ConstrainedManipulationCommand_Request::release_enable_robot_locomotion() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.enable_robot_locomotion_;
  _impl_.enable_robot_locomotion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ConstrainedManipulationCommand_Request::unsafe_arena_release_enable_robot_locomotion() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ConstrainedManipulationCommand.Request.enable_robot_locomotion)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.enable_robot_locomotion_;
  _impl_.enable_robot_locomotion_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ConstrainedManipulationCommand_Request::_internal_mutable_enable_robot_locomotion() {
  
  if (_impl_.enable_robot_locomotion_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.enable_robot_locomotion_ = p;
  }
  return _impl_.enable_robot_locomotion_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ConstrainedManipulationCommand_Request::mutable_enable_robot_locomotion() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_enable_robot_locomotion();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ConstrainedManipulationCommand.Request.enable_robot_locomotion)
  return _msg;
}
inline void ConstrainedManipulationCommand_Request::set_allocated_enable_robot_locomotion(::PROTOBUF_NAMESPACE_ID::BoolValue* enable_robot_locomotion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enable_robot_locomotion_);
  }
  if (enable_robot_locomotion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enable_robot_locomotion));
    if (message_arena != submessage_arena) {
      enable_robot_locomotion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enable_robot_locomotion, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.enable_robot_locomotion_ = enable_robot_locomotion;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ConstrainedManipulationCommand.Request.enable_robot_locomotion)
}

inline bool ConstrainedManipulationCommand_Request::has_task_speed() const {
  return task_speed_case() != TASK_SPEED_NOT_SET;
}
inline void ConstrainedManipulationCommand_Request::clear_has_task_speed() {
  _impl_._oneof_case_[0] = TASK_SPEED_NOT_SET;
}
inline ConstrainedManipulationCommand_Request::TaskSpeedCase ConstrainedManipulationCommand_Request::task_speed_case() const {
  return ConstrainedManipulationCommand_Request::TaskSpeedCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConstrainedManipulationCommand_Feedback

// .bosdyn.api.ConstrainedManipulationCommand.Feedback.Status status = 1;
inline void ConstrainedManipulationCommand_Feedback::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::ConstrainedManipulationCommand_Feedback_Status ConstrainedManipulationCommand_Feedback::_internal_status() const {
  return static_cast< ::bosdyn::api::ConstrainedManipulationCommand_Feedback_Status >(_impl_.status_);
}
inline ::bosdyn::api::ConstrainedManipulationCommand_Feedback_Status ConstrainedManipulationCommand_Feedback::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ConstrainedManipulationCommand.Feedback.status)
  return _internal_status();
}
inline void ConstrainedManipulationCommand_Feedback::_internal_set_status(::bosdyn::api::ConstrainedManipulationCommand_Feedback_Status value) {
  
  _impl_.status_ = value;
}
inline void ConstrainedManipulationCommand_Feedback::set_status(::bosdyn::api::ConstrainedManipulationCommand_Feedback_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ConstrainedManipulationCommand.Feedback.status)
}

// .bosdyn.api.Wrench desired_wrench_odom_frame = 2;
inline bool ConstrainedManipulationCommand_Feedback::_internal_has_desired_wrench_odom_frame() const {
  return this != internal_default_instance() && _impl_.desired_wrench_odom_frame_ != nullptr;
}
inline bool ConstrainedManipulationCommand_Feedback::has_desired_wrench_odom_frame() const {
  return _internal_has_desired_wrench_odom_frame();
}
inline const ::bosdyn::api::Wrench& ConstrainedManipulationCommand_Feedback::_internal_desired_wrench_odom_frame() const {
  const ::bosdyn::api::Wrench* p = _impl_.desired_wrench_odom_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Wrench&>(
      ::bosdyn::api::_Wrench_default_instance_);
}
inline const ::bosdyn::api::Wrench& ConstrainedManipulationCommand_Feedback::desired_wrench_odom_frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ConstrainedManipulationCommand.Feedback.desired_wrench_odom_frame)
  return _internal_desired_wrench_odom_frame();
}
inline void ConstrainedManipulationCommand_Feedback::unsafe_arena_set_allocated_desired_wrench_odom_frame(
    ::bosdyn::api::Wrench* desired_wrench_odom_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.desired_wrench_odom_frame_);
  }
  _impl_.desired_wrench_odom_frame_ = desired_wrench_odom_frame;
  if (desired_wrench_odom_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ConstrainedManipulationCommand.Feedback.desired_wrench_odom_frame)
}
inline ::bosdyn::api::Wrench* ConstrainedManipulationCommand_Feedback::release_desired_wrench_odom_frame() {
  
  ::bosdyn::api::Wrench* temp = _impl_.desired_wrench_odom_frame_;
  _impl_.desired_wrench_odom_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Wrench* ConstrainedManipulationCommand_Feedback::unsafe_arena_release_desired_wrench_odom_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ConstrainedManipulationCommand.Feedback.desired_wrench_odom_frame)
  
  ::bosdyn::api::Wrench* temp = _impl_.desired_wrench_odom_frame_;
  _impl_.desired_wrench_odom_frame_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Wrench* ConstrainedManipulationCommand_Feedback::_internal_mutable_desired_wrench_odom_frame() {
  
  if (_impl_.desired_wrench_odom_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Wrench>(GetArenaForAllocation());
    _impl_.desired_wrench_odom_frame_ = p;
  }
  return _impl_.desired_wrench_odom_frame_;
}
inline ::bosdyn::api::Wrench* ConstrainedManipulationCommand_Feedback::mutable_desired_wrench_odom_frame() {
  ::bosdyn::api::Wrench* _msg = _internal_mutable_desired_wrench_odom_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ConstrainedManipulationCommand.Feedback.desired_wrench_odom_frame)
  return _msg;
}
inline void ConstrainedManipulationCommand_Feedback::set_allocated_desired_wrench_odom_frame(::bosdyn::api::Wrench* desired_wrench_odom_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.desired_wrench_odom_frame_);
  }
  if (desired_wrench_odom_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(desired_wrench_odom_frame));
    if (message_arena != submessage_arena) {
      desired_wrench_odom_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, desired_wrench_odom_frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.desired_wrench_odom_frame_ = desired_wrench_odom_frame;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ConstrainedManipulationCommand.Feedback.desired_wrench_odom_frame)
}

// -------------------------------------------------------------------

// ConstrainedManipulationCommand

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::RobotCommandFeedbackStatus_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::RobotCommandFeedbackStatus_Status>() {
  return ::bosdyn::api::RobotCommandFeedbackStatus_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::BatteryChangePoseCommand_Request_DirectionHint> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::BatteryChangePoseCommand_Request_DirectionHint>() {
  return ::bosdyn::api::BatteryChangePoseCommand_Request_DirectionHint_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::BatteryChangePoseCommand_Feedback_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::BatteryChangePoseCommand_Feedback_Status>() {
  return ::bosdyn::api::BatteryChangePoseCommand_Feedback_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::SelfRightCommand_Feedback_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::SelfRightCommand_Feedback_Status>() {
  return ::bosdyn::api::SelfRightCommand_Feedback_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::SafePowerOffCommand_Request_UnsafeAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::SafePowerOffCommand_Request_UnsafeAction>() {
  return ::bosdyn::api::SafePowerOffCommand_Request_UnsafeAction_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::SafePowerOffCommand_Feedback_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::SafePowerOffCommand_Feedback_Status>() {
  return ::bosdyn::api::SafePowerOffCommand_Feedback_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::SE2TrajectoryCommand_Feedback_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::SE2TrajectoryCommand_Feedback_Status>() {
  return ::bosdyn::api::SE2TrajectoryCommand_Feedback_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus>() {
  return ::bosdyn::api::SE2TrajectoryCommand_Feedback_BodyMovementStatus_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::SitCommand_Feedback_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::SitCommand_Feedback_Status>() {
  return ::bosdyn::api::SitCommand_Feedback_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::StandCommand_Feedback_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::StandCommand_Feedback_Status>() {
  return ::bosdyn::api::StandCommand_Feedback_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::StandCommand_Feedback_StandingState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::StandCommand_Feedback_StandingState>() {
  return ::bosdyn::api::StandCommand_Feedback_StandingState_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::StanceCommand_Feedback_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::StanceCommand_Feedback_Status>() {
  return ::bosdyn::api::StanceCommand_Feedback_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::ArmDragCommand_Feedback_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ArmDragCommand_Feedback_Status>() {
  return ::bosdyn::api::ArmDragCommand_Feedback_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::ConstrainedManipulationCommand_Request_TaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ConstrainedManipulationCommand_Request_TaskType>() {
  return ::bosdyn::api::ConstrainedManipulationCommand_Request_TaskType_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::ConstrainedManipulationCommand_Feedback_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ConstrainedManipulationCommand_Feedback_Status>() {
  return ::bosdyn::api::ConstrainedManipulationCommand_Feedback_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fbasic_5fcommand_2eproto
