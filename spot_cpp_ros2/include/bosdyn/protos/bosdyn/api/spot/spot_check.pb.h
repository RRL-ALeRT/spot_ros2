// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/spot/spot_check.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/lease.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
namespace bosdyn {
namespace api {
namespace spot {
class CameraCalibrationCommandRequest;
struct CameraCalibrationCommandRequestDefaultTypeInternal;
extern CameraCalibrationCommandRequestDefaultTypeInternal _CameraCalibrationCommandRequest_default_instance_;
class CameraCalibrationCommandResponse;
struct CameraCalibrationCommandResponseDefaultTypeInternal;
extern CameraCalibrationCommandResponseDefaultTypeInternal _CameraCalibrationCommandResponse_default_instance_;
class CameraCalibrationFeedbackRequest;
struct CameraCalibrationFeedbackRequestDefaultTypeInternal;
extern CameraCalibrationFeedbackRequestDefaultTypeInternal _CameraCalibrationFeedbackRequest_default_instance_;
class CameraCalibrationFeedbackResponse;
struct CameraCalibrationFeedbackResponseDefaultTypeInternal;
extern CameraCalibrationFeedbackResponseDefaultTypeInternal _CameraCalibrationFeedbackResponse_default_instance_;
class DepthPlaneSpotCheckResult;
struct DepthPlaneSpotCheckResultDefaultTypeInternal;
extern DepthPlaneSpotCheckResultDefaultTypeInternal _DepthPlaneSpotCheckResult_default_instance_;
class FootHeightCheckResult;
struct FootHeightCheckResultDefaultTypeInternal;
extern FootHeightCheckResultDefaultTypeInternal _FootHeightCheckResult_default_instance_;
class HipRangeOfMotionResult;
struct HipRangeOfMotionResultDefaultTypeInternal;
extern HipRangeOfMotionResultDefaultTypeInternal _HipRangeOfMotionResult_default_instance_;
class JointKinematicCheckResult;
struct JointKinematicCheckResultDefaultTypeInternal;
extern JointKinematicCheckResultDefaultTypeInternal _JointKinematicCheckResult_default_instance_;
class LegPairCheckResult;
struct LegPairCheckResultDefaultTypeInternal;
extern LegPairCheckResultDefaultTypeInternal _LegPairCheckResult_default_instance_;
class LoadCellSpotCheckResult;
struct LoadCellSpotCheckResultDefaultTypeInternal;
extern LoadCellSpotCheckResultDefaultTypeInternal _LoadCellSpotCheckResult_default_instance_;
class PayloadCheckResult;
struct PayloadCheckResultDefaultTypeInternal;
extern PayloadCheckResultDefaultTypeInternal _PayloadCheckResult_default_instance_;
class SpotCheckCommandRequest;
struct SpotCheckCommandRequestDefaultTypeInternal;
extern SpotCheckCommandRequestDefaultTypeInternal _SpotCheckCommandRequest_default_instance_;
class SpotCheckCommandResponse;
struct SpotCheckCommandResponseDefaultTypeInternal;
extern SpotCheckCommandResponseDefaultTypeInternal _SpotCheckCommandResponse_default_instance_;
class SpotCheckFeedbackRequest;
struct SpotCheckFeedbackRequestDefaultTypeInternal;
extern SpotCheckFeedbackRequestDefaultTypeInternal _SpotCheckFeedbackRequest_default_instance_;
class SpotCheckFeedbackResponse;
struct SpotCheckFeedbackResponseDefaultTypeInternal;
extern SpotCheckFeedbackResponseDefaultTypeInternal _SpotCheckFeedbackResponse_default_instance_;
class SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse;
struct SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUseDefaultTypeInternal;
extern SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUseDefaultTypeInternal _SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse_default_instance_;
class SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse;
struct SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUseDefaultTypeInternal;
extern SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUseDefaultTypeInternal _SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse_default_instance_;
class SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUse;
struct SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUseDefaultTypeInternal;
extern SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUseDefaultTypeInternal _SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUse_default_instance_;
class SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse;
struct SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUseDefaultTypeInternal;
extern SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUseDefaultTypeInternal _SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse_default_instance_;
class SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse;
struct SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUseDefaultTypeInternal;
extern SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUseDefaultTypeInternal _SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse_default_instance_;
class SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse;
struct SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUseDefaultTypeInternal;
extern SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUseDefaultTypeInternal _SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse_default_instance_;
}  // namespace spot
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::spot::CameraCalibrationCommandRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::CameraCalibrationCommandRequest>(Arena*);
template<> ::bosdyn::api::spot::CameraCalibrationCommandResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::CameraCalibrationCommandResponse>(Arena*);
template<> ::bosdyn::api::spot::CameraCalibrationFeedbackRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::CameraCalibrationFeedbackRequest>(Arena*);
template<> ::bosdyn::api::spot::CameraCalibrationFeedbackResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::CameraCalibrationFeedbackResponse>(Arena*);
template<> ::bosdyn::api::spot::DepthPlaneSpotCheckResult* Arena::CreateMaybeMessage<::bosdyn::api::spot::DepthPlaneSpotCheckResult>(Arena*);
template<> ::bosdyn::api::spot::FootHeightCheckResult* Arena::CreateMaybeMessage<::bosdyn::api::spot::FootHeightCheckResult>(Arena*);
template<> ::bosdyn::api::spot::HipRangeOfMotionResult* Arena::CreateMaybeMessage<::bosdyn::api::spot::HipRangeOfMotionResult>(Arena*);
template<> ::bosdyn::api::spot::JointKinematicCheckResult* Arena::CreateMaybeMessage<::bosdyn::api::spot::JointKinematicCheckResult>(Arena*);
template<> ::bosdyn::api::spot::LegPairCheckResult* Arena::CreateMaybeMessage<::bosdyn::api::spot::LegPairCheckResult>(Arena*);
template<> ::bosdyn::api::spot::LoadCellSpotCheckResult* Arena::CreateMaybeMessage<::bosdyn::api::spot::LoadCellSpotCheckResult>(Arena*);
template<> ::bosdyn::api::spot::PayloadCheckResult* Arena::CreateMaybeMessage<::bosdyn::api::spot::PayloadCheckResult>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckCommandRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckCommandRequest>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckCommandResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckCommandResponse>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckFeedbackRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckFeedbackRequest>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckFeedbackResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckFeedbackResponse>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {
namespace spot {

enum SpotCheckCommandRequest_Command : int {
  SpotCheckCommandRequest_Command_COMMAND_UNKNOWN = 0,
  SpotCheckCommandRequest_Command_COMMAND_START = 1,
  SpotCheckCommandRequest_Command_COMMAND_ABORT = 2,
  SpotCheckCommandRequest_Command_COMMAND_REVERT_CAL = 3,
  SpotCheckCommandRequest_Command_SpotCheckCommandRequest_Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SpotCheckCommandRequest_Command_SpotCheckCommandRequest_Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SpotCheckCommandRequest_Command_IsValid(int value);
constexpr SpotCheckCommandRequest_Command SpotCheckCommandRequest_Command_Command_MIN = SpotCheckCommandRequest_Command_COMMAND_UNKNOWN;
constexpr SpotCheckCommandRequest_Command SpotCheckCommandRequest_Command_Command_MAX = SpotCheckCommandRequest_Command_COMMAND_REVERT_CAL;
constexpr int SpotCheckCommandRequest_Command_Command_ARRAYSIZE = SpotCheckCommandRequest_Command_Command_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpotCheckCommandRequest_Command_descriptor();
template<typename T>
inline const std::string& SpotCheckCommandRequest_Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpotCheckCommandRequest_Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpotCheckCommandRequest_Command_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpotCheckCommandRequest_Command_descriptor(), enum_t_value);
}
inline bool SpotCheckCommandRequest_Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpotCheckCommandRequest_Command* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpotCheckCommandRequest_Command>(
    SpotCheckCommandRequest_Command_descriptor(), name, value);
}
enum SpotCheckCommandResponse_Status : int {
  SpotCheckCommandResponse_Status_STATUS_UNKNOWN = 0,
  SpotCheckCommandResponse_Status_STATUS_OK = 1,
  SpotCheckCommandResponse_Status_STATUS_ERROR = 2,
  SpotCheckCommandResponse_Status_SpotCheckCommandResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SpotCheckCommandResponse_Status_SpotCheckCommandResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SpotCheckCommandResponse_Status_IsValid(int value);
constexpr SpotCheckCommandResponse_Status SpotCheckCommandResponse_Status_Status_MIN = SpotCheckCommandResponse_Status_STATUS_UNKNOWN;
constexpr SpotCheckCommandResponse_Status SpotCheckCommandResponse_Status_Status_MAX = SpotCheckCommandResponse_Status_STATUS_ERROR;
constexpr int SpotCheckCommandResponse_Status_Status_ARRAYSIZE = SpotCheckCommandResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpotCheckCommandResponse_Status_descriptor();
template<typename T>
inline const std::string& SpotCheckCommandResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpotCheckCommandResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpotCheckCommandResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpotCheckCommandResponse_Status_descriptor(), enum_t_value);
}
inline bool SpotCheckCommandResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpotCheckCommandResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpotCheckCommandResponse_Status>(
    SpotCheckCommandResponse_Status_descriptor(), name, value);
}
enum SpotCheckFeedbackResponse_State : int {
  SpotCheckFeedbackResponse_State_STATE_UNKNOWN = 0,
  SpotCheckFeedbackResponse_State_STATE_USER_ABORTED = 1,
  SpotCheckFeedbackResponse_State_STATE_STARTING = 2,
  SpotCheckFeedbackResponse_State_STATE_LOADCELL_CAL = 3,
  SpotCheckFeedbackResponse_State_STATE_ENDSTOP_CAL = 4,
  SpotCheckFeedbackResponse_State_STATE_CAMERA_CHECK = 5,
  SpotCheckFeedbackResponse_State_STATE_BODY_POSING = 6,
  SpotCheckFeedbackResponse_State_STATE_FINISHED = 7,
  SpotCheckFeedbackResponse_State_STATE_REVERTING_CAL = 8,
  SpotCheckFeedbackResponse_State_STATE_ERROR = 9,
  SpotCheckFeedbackResponse_State_STATE_WAITING_FOR_COMMAND = 10,
  SpotCheckFeedbackResponse_State_STATE_HIP_RANGE_OF_MOTION_CHECK = 11,
  SpotCheckFeedbackResponse_State_STATE_GRIPPER_CAL = 12,
  SpotCheckFeedbackResponse_State_STATE_SIT_DOWN_AFTER_RUN = 13,
  SpotCheckFeedbackResponse_State_STATE_ARM_JOINT_CHECK = 14,
  SpotCheckFeedbackResponse_State_SpotCheckFeedbackResponse_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SpotCheckFeedbackResponse_State_SpotCheckFeedbackResponse_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SpotCheckFeedbackResponse_State_IsValid(int value);
constexpr SpotCheckFeedbackResponse_State SpotCheckFeedbackResponse_State_State_MIN = SpotCheckFeedbackResponse_State_STATE_UNKNOWN;
constexpr SpotCheckFeedbackResponse_State SpotCheckFeedbackResponse_State_State_MAX = SpotCheckFeedbackResponse_State_STATE_ARM_JOINT_CHECK;
constexpr int SpotCheckFeedbackResponse_State_State_ARRAYSIZE = SpotCheckFeedbackResponse_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpotCheckFeedbackResponse_State_descriptor();
template<typename T>
inline const std::string& SpotCheckFeedbackResponse_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpotCheckFeedbackResponse_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpotCheckFeedbackResponse_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpotCheckFeedbackResponse_State_descriptor(), enum_t_value);
}
inline bool SpotCheckFeedbackResponse_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpotCheckFeedbackResponse_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpotCheckFeedbackResponse_State>(
    SpotCheckFeedbackResponse_State_descriptor(), name, value);
}
enum SpotCheckFeedbackResponse_Error : int {
  SpotCheckFeedbackResponse_Error_ERROR_UNKNOWN = 0,
  SpotCheckFeedbackResponse_Error_ERROR_NONE = 1,
  SpotCheckFeedbackResponse_Error_ERROR_UNEXPECTED_POWER_CHANGE = 2,
  SpotCheckFeedbackResponse_Error_ERROR_INIT_IMU_CHECK = 3,
  SpotCheckFeedbackResponse_Error_ERROR_INIT_NOT_SITTING = 4,
  SpotCheckFeedbackResponse_Error_ERROR_LOADCELL_TIMEOUT = 5,
  SpotCheckFeedbackResponse_Error_ERROR_POWER_ON_FAILURE = 6,
  SpotCheckFeedbackResponse_Error_ERROR_ENDSTOP_TIMEOUT = 7,
  SpotCheckFeedbackResponse_Error_ERROR_FAILED_STAND = 8,
  SpotCheckFeedbackResponse_Error_ERROR_CAMERA_TIMEOUT = 9,
  SpotCheckFeedbackResponse_Error_ERROR_GROUND_CHECK = 10,
  SpotCheckFeedbackResponse_Error_ERROR_POWER_OFF_FAILURE = 11,
  SpotCheckFeedbackResponse_Error_ERROR_REVERT_FAILURE = 12,
  SpotCheckFeedbackResponse_Error_ERROR_FGKC_FAILURE = 13,
  SpotCheckFeedbackResponse_Error_ERROR_GRIPPER_CAL_TIMEOUT = 14,
  SpotCheckFeedbackResponse_Error_ERROR_ARM_CHECK_COLLISION = 15,
  SpotCheckFeedbackResponse_Error_ERROR_ARM_CHECK_TIMEOUT = 16,
  SpotCheckFeedbackResponse_Error_SpotCheckFeedbackResponse_Error_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SpotCheckFeedbackResponse_Error_SpotCheckFeedbackResponse_Error_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SpotCheckFeedbackResponse_Error_IsValid(int value);
constexpr SpotCheckFeedbackResponse_Error SpotCheckFeedbackResponse_Error_Error_MIN = SpotCheckFeedbackResponse_Error_ERROR_UNKNOWN;
constexpr SpotCheckFeedbackResponse_Error SpotCheckFeedbackResponse_Error_Error_MAX = SpotCheckFeedbackResponse_Error_ERROR_ARM_CHECK_TIMEOUT;
constexpr int SpotCheckFeedbackResponse_Error_Error_ARRAYSIZE = SpotCheckFeedbackResponse_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpotCheckFeedbackResponse_Error_descriptor();
template<typename T>
inline const std::string& SpotCheckFeedbackResponse_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpotCheckFeedbackResponse_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpotCheckFeedbackResponse_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpotCheckFeedbackResponse_Error_descriptor(), enum_t_value);
}
inline bool SpotCheckFeedbackResponse_Error_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpotCheckFeedbackResponse_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpotCheckFeedbackResponse_Error>(
    SpotCheckFeedbackResponse_Error_descriptor(), name, value);
}
enum DepthPlaneSpotCheckResult_Status : int {
  DepthPlaneSpotCheckResult_Status_STATUS_UNKNOWN = 0,
  DepthPlaneSpotCheckResult_Status_STATUS_OK = 1,
  DepthPlaneSpotCheckResult_Status_STATUS_WARNING = 2,
  DepthPlaneSpotCheckResult_Status_STATUS_ERROR = 3,
  DepthPlaneSpotCheckResult_Status_DepthPlaneSpotCheckResult_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DepthPlaneSpotCheckResult_Status_DepthPlaneSpotCheckResult_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DepthPlaneSpotCheckResult_Status_IsValid(int value);
constexpr DepthPlaneSpotCheckResult_Status DepthPlaneSpotCheckResult_Status_Status_MIN = DepthPlaneSpotCheckResult_Status_STATUS_UNKNOWN;
constexpr DepthPlaneSpotCheckResult_Status DepthPlaneSpotCheckResult_Status_Status_MAX = DepthPlaneSpotCheckResult_Status_STATUS_ERROR;
constexpr int DepthPlaneSpotCheckResult_Status_Status_ARRAYSIZE = DepthPlaneSpotCheckResult_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DepthPlaneSpotCheckResult_Status_descriptor();
template<typename T>
inline const std::string& DepthPlaneSpotCheckResult_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DepthPlaneSpotCheckResult_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DepthPlaneSpotCheckResult_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DepthPlaneSpotCheckResult_Status_descriptor(), enum_t_value);
}
inline bool DepthPlaneSpotCheckResult_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DepthPlaneSpotCheckResult_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DepthPlaneSpotCheckResult_Status>(
    DepthPlaneSpotCheckResult_Status_descriptor(), name, value);
}
enum PayloadCheckResult_Error : int {
  PayloadCheckResult_Error_ERROR_UNKNOWN = 0,
  PayloadCheckResult_Error_ERROR_NONE = 1,
  PayloadCheckResult_Error_ERROR_MASS_DISCREPANCY = 2,
  PayloadCheckResult_Error_PayloadCheckResult_Error_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PayloadCheckResult_Error_PayloadCheckResult_Error_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PayloadCheckResult_Error_IsValid(int value);
constexpr PayloadCheckResult_Error PayloadCheckResult_Error_Error_MIN = PayloadCheckResult_Error_ERROR_UNKNOWN;
constexpr PayloadCheckResult_Error PayloadCheckResult_Error_Error_MAX = PayloadCheckResult_Error_ERROR_MASS_DISCREPANCY;
constexpr int PayloadCheckResult_Error_Error_ARRAYSIZE = PayloadCheckResult_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PayloadCheckResult_Error_descriptor();
template<typename T>
inline const std::string& PayloadCheckResult_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PayloadCheckResult_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PayloadCheckResult_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PayloadCheckResult_Error_descriptor(), enum_t_value);
}
inline bool PayloadCheckResult_Error_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadCheckResult_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PayloadCheckResult_Error>(
    PayloadCheckResult_Error_descriptor(), name, value);
}
enum LoadCellSpotCheckResult_Error : int {
  LoadCellSpotCheckResult_Error_ERROR_UNKNOWN = 0,
  LoadCellSpotCheckResult_Error_ERROR_NONE = 1,
  LoadCellSpotCheckResult_Error_ERROR_ZERO_OUT_OF_RANGE = 2,
  LoadCellSpotCheckResult_Error_LoadCellSpotCheckResult_Error_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LoadCellSpotCheckResult_Error_LoadCellSpotCheckResult_Error_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LoadCellSpotCheckResult_Error_IsValid(int value);
constexpr LoadCellSpotCheckResult_Error LoadCellSpotCheckResult_Error_Error_MIN = LoadCellSpotCheckResult_Error_ERROR_UNKNOWN;
constexpr LoadCellSpotCheckResult_Error LoadCellSpotCheckResult_Error_Error_MAX = LoadCellSpotCheckResult_Error_ERROR_ZERO_OUT_OF_RANGE;
constexpr int LoadCellSpotCheckResult_Error_Error_ARRAYSIZE = LoadCellSpotCheckResult_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoadCellSpotCheckResult_Error_descriptor();
template<typename T>
inline const std::string& LoadCellSpotCheckResult_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoadCellSpotCheckResult_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoadCellSpotCheckResult_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoadCellSpotCheckResult_Error_descriptor(), enum_t_value);
}
inline bool LoadCellSpotCheckResult_Error_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoadCellSpotCheckResult_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoadCellSpotCheckResult_Error>(
    LoadCellSpotCheckResult_Error_descriptor(), name, value);
}
enum JointKinematicCheckResult_Error : int {
  JointKinematicCheckResult_Error_ERROR_UNKNOWN = 0,
  JointKinematicCheckResult_Error_ERROR_NONE = 1,
  JointKinematicCheckResult_Error_ERROR_CLUTCH_SLIP = 2,
  JointKinematicCheckResult_Error_ERROR_INVALID_RANGE_OF_MOTION = 3,
  JointKinematicCheckResult_Error_ERROR_ENCODER_SHIFTED = 4,
  JointKinematicCheckResult_Error_ERROR_COLLISION = 5,
  JointKinematicCheckResult_Error_JointKinematicCheckResult_Error_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  JointKinematicCheckResult_Error_JointKinematicCheckResult_Error_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool JointKinematicCheckResult_Error_IsValid(int value);
constexpr JointKinematicCheckResult_Error JointKinematicCheckResult_Error_Error_MIN = JointKinematicCheckResult_Error_ERROR_UNKNOWN;
constexpr JointKinematicCheckResult_Error JointKinematicCheckResult_Error_Error_MAX = JointKinematicCheckResult_Error_ERROR_COLLISION;
constexpr int JointKinematicCheckResult_Error_Error_ARRAYSIZE = JointKinematicCheckResult_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JointKinematicCheckResult_Error_descriptor();
template<typename T>
inline const std::string& JointKinematicCheckResult_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JointKinematicCheckResult_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JointKinematicCheckResult_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JointKinematicCheckResult_Error_descriptor(), enum_t_value);
}
inline bool JointKinematicCheckResult_Error_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JointKinematicCheckResult_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JointKinematicCheckResult_Error>(
    JointKinematicCheckResult_Error_descriptor(), name, value);
}
enum FootHeightCheckResult_Status : int {
  FootHeightCheckResult_Status_STATUS_UNKNOWN = 0,
  FootHeightCheckResult_Status_STATUS_OK = 1,
  FootHeightCheckResult_Status_STATUS_WARNING = 2,
  FootHeightCheckResult_Status_STATUS_ERROR = 3,
  FootHeightCheckResult_Status_FootHeightCheckResult_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FootHeightCheckResult_Status_FootHeightCheckResult_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FootHeightCheckResult_Status_IsValid(int value);
constexpr FootHeightCheckResult_Status FootHeightCheckResult_Status_Status_MIN = FootHeightCheckResult_Status_STATUS_UNKNOWN;
constexpr FootHeightCheckResult_Status FootHeightCheckResult_Status_Status_MAX = FootHeightCheckResult_Status_STATUS_ERROR;
constexpr int FootHeightCheckResult_Status_Status_ARRAYSIZE = FootHeightCheckResult_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FootHeightCheckResult_Status_descriptor();
template<typename T>
inline const std::string& FootHeightCheckResult_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FootHeightCheckResult_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FootHeightCheckResult_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FootHeightCheckResult_Status_descriptor(), enum_t_value);
}
inline bool FootHeightCheckResult_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FootHeightCheckResult_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FootHeightCheckResult_Status>(
    FootHeightCheckResult_Status_descriptor(), name, value);
}
enum LegPairCheckResult_Status : int {
  LegPairCheckResult_Status_STATUS_UNKNOWN = 0,
  LegPairCheckResult_Status_STATUS_OK = 1,
  LegPairCheckResult_Status_STATUS_WARNING = 2,
  LegPairCheckResult_Status_STATUS_ERROR = 3,
  LegPairCheckResult_Status_LegPairCheckResult_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LegPairCheckResult_Status_LegPairCheckResult_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LegPairCheckResult_Status_IsValid(int value);
constexpr LegPairCheckResult_Status LegPairCheckResult_Status_Status_MIN = LegPairCheckResult_Status_STATUS_UNKNOWN;
constexpr LegPairCheckResult_Status LegPairCheckResult_Status_Status_MAX = LegPairCheckResult_Status_STATUS_ERROR;
constexpr int LegPairCheckResult_Status_Status_ARRAYSIZE = LegPairCheckResult_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LegPairCheckResult_Status_descriptor();
template<typename T>
inline const std::string& LegPairCheckResult_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LegPairCheckResult_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LegPairCheckResult_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LegPairCheckResult_Status_descriptor(), enum_t_value);
}
inline bool LegPairCheckResult_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LegPairCheckResult_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LegPairCheckResult_Status>(
    LegPairCheckResult_Status_descriptor(), name, value);
}
enum HipRangeOfMotionResult_Error : int {
  HipRangeOfMotionResult_Error_ERROR_UNKNOWN = 0,
  HipRangeOfMotionResult_Error_ERROR_NONE = 1,
  HipRangeOfMotionResult_Error_ERROR_OBSTRUCTED = 2,
  HipRangeOfMotionResult_Error_HipRangeOfMotionResult_Error_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HipRangeOfMotionResult_Error_HipRangeOfMotionResult_Error_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool HipRangeOfMotionResult_Error_IsValid(int value);
constexpr HipRangeOfMotionResult_Error HipRangeOfMotionResult_Error_Error_MIN = HipRangeOfMotionResult_Error_ERROR_UNKNOWN;
constexpr HipRangeOfMotionResult_Error HipRangeOfMotionResult_Error_Error_MAX = HipRangeOfMotionResult_Error_ERROR_OBSTRUCTED;
constexpr int HipRangeOfMotionResult_Error_Error_ARRAYSIZE = HipRangeOfMotionResult_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HipRangeOfMotionResult_Error_descriptor();
template<typename T>
inline const std::string& HipRangeOfMotionResult_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HipRangeOfMotionResult_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HipRangeOfMotionResult_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HipRangeOfMotionResult_Error_descriptor(), enum_t_value);
}
inline bool HipRangeOfMotionResult_Error_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HipRangeOfMotionResult_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HipRangeOfMotionResult_Error>(
    HipRangeOfMotionResult_Error_descriptor(), name, value);
}
enum CameraCalibrationCommandRequest_Command : int {
  CameraCalibrationCommandRequest_Command_COMMAND_UNKNOWN = 0,
  CameraCalibrationCommandRequest_Command_COMMAND_START = 1,
  CameraCalibrationCommandRequest_Command_COMMAND_CANCEL = 2,
  CameraCalibrationCommandRequest_Command_CameraCalibrationCommandRequest_Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CameraCalibrationCommandRequest_Command_CameraCalibrationCommandRequest_Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CameraCalibrationCommandRequest_Command_IsValid(int value);
constexpr CameraCalibrationCommandRequest_Command CameraCalibrationCommandRequest_Command_Command_MIN = CameraCalibrationCommandRequest_Command_COMMAND_UNKNOWN;
constexpr CameraCalibrationCommandRequest_Command CameraCalibrationCommandRequest_Command_Command_MAX = CameraCalibrationCommandRequest_Command_COMMAND_CANCEL;
constexpr int CameraCalibrationCommandRequest_Command_Command_ARRAYSIZE = CameraCalibrationCommandRequest_Command_Command_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraCalibrationCommandRequest_Command_descriptor();
template<typename T>
inline const std::string& CameraCalibrationCommandRequest_Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CameraCalibrationCommandRequest_Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CameraCalibrationCommandRequest_Command_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CameraCalibrationCommandRequest_Command_descriptor(), enum_t_value);
}
inline bool CameraCalibrationCommandRequest_Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CameraCalibrationCommandRequest_Command* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CameraCalibrationCommandRequest_Command>(
    CameraCalibrationCommandRequest_Command_descriptor(), name, value);
}
enum CameraCalibrationFeedbackResponse_Status : int {
  CameraCalibrationFeedbackResponse_Status_STATUS_UNKNOWN = 0,
  CameraCalibrationFeedbackResponse_Status_STATUS_PROCESSING = 1,
  CameraCalibrationFeedbackResponse_Status_STATUS_SUCCESS = 2,
  CameraCalibrationFeedbackResponse_Status_STATUS_USER_CANCELED = 3,
  CameraCalibrationFeedbackResponse_Status_STATUS_POWER_ERROR = 4,
  CameraCalibrationFeedbackResponse_Status_STATUS_LEASE_ERROR = 5,
  CameraCalibrationFeedbackResponse_Status_STATUS_ROBOT_COMMAND_ERROR = 7,
  CameraCalibrationFeedbackResponse_Status_STATUS_CALIBRATION_ERROR = 8,
  CameraCalibrationFeedbackResponse_Status_STATUS_INTERNAL_ERROR = 9,
  CameraCalibrationFeedbackResponse_Status_STATUS_CAMERA_FOCUS_ERROR = 14,
  CameraCalibrationFeedbackResponse_Status_STATUS_TARGET_NOT_CENTERED = 6,
  CameraCalibrationFeedbackResponse_Status_STATUS_TARGET_NOT_IN_VIEW = 11,
  CameraCalibrationFeedbackResponse_Status_STATUS_TARGET_NOT_GRAVITY_ALIGNED = 12,
  CameraCalibrationFeedbackResponse_Status_STATUS_TARGET_UPSIDE_DOWN = 13,
  CameraCalibrationFeedbackResponse_Status_STATUS_NEVER_RUN = 10,
  CameraCalibrationFeedbackResponse_Status_STATUS_CAMERA_NOT_DETECTED = 15,
  CameraCalibrationFeedbackResponse_Status_STATUS_INTRINSIC_WRITE_FAILED = 16,
  CameraCalibrationFeedbackResponse_Status_STATUS_EXTRINSIC_WRITE_FAILED = 17,
  CameraCalibrationFeedbackResponse_Status_STATUS_CALIBRATION_VERIFICATION_FAILED = 18,
  CameraCalibrationFeedbackResponse_Status_CameraCalibrationFeedbackResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CameraCalibrationFeedbackResponse_Status_CameraCalibrationFeedbackResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CameraCalibrationFeedbackResponse_Status_IsValid(int value);
constexpr CameraCalibrationFeedbackResponse_Status CameraCalibrationFeedbackResponse_Status_Status_MIN = CameraCalibrationFeedbackResponse_Status_STATUS_UNKNOWN;
constexpr CameraCalibrationFeedbackResponse_Status CameraCalibrationFeedbackResponse_Status_Status_MAX = CameraCalibrationFeedbackResponse_Status_STATUS_CALIBRATION_VERIFICATION_FAILED;
constexpr int CameraCalibrationFeedbackResponse_Status_Status_ARRAYSIZE = CameraCalibrationFeedbackResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraCalibrationFeedbackResponse_Status_descriptor();
template<typename T>
inline const std::string& CameraCalibrationFeedbackResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CameraCalibrationFeedbackResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CameraCalibrationFeedbackResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CameraCalibrationFeedbackResponse_Status_descriptor(), enum_t_value);
}
inline bool CameraCalibrationFeedbackResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CameraCalibrationFeedbackResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CameraCalibrationFeedbackResponse_Status>(
    CameraCalibrationFeedbackResponse_Status_descriptor(), name, value);
}
// ===================================================================

class SpotCheckCommandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.SpotCheckCommandRequest) */ {
 public:
  inline SpotCheckCommandRequest() : SpotCheckCommandRequest(nullptr) {}
  ~SpotCheckCommandRequest() override;
  explicit PROTOBUF_CONSTEXPR SpotCheckCommandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotCheckCommandRequest(const SpotCheckCommandRequest& from);
  SpotCheckCommandRequest(SpotCheckCommandRequest&& from) noexcept
    : SpotCheckCommandRequest() {
    *this = ::std::move(from);
  }

  inline SpotCheckCommandRequest& operator=(const SpotCheckCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotCheckCommandRequest& operator=(SpotCheckCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotCheckCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotCheckCommandRequest* internal_default_instance() {
    return reinterpret_cast<const SpotCheckCommandRequest*>(
               &_SpotCheckCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SpotCheckCommandRequest& a, SpotCheckCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotCheckCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotCheckCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotCheckCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotCheckCommandRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotCheckCommandRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotCheckCommandRequest& from) {
    SpotCheckCommandRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotCheckCommandRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.SpotCheckCommandRequest";
  }
  protected:
  explicit SpotCheckCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SpotCheckCommandRequest_Command Command;
  static constexpr Command COMMAND_UNKNOWN =
    SpotCheckCommandRequest_Command_COMMAND_UNKNOWN;
  static constexpr Command COMMAND_START =
    SpotCheckCommandRequest_Command_COMMAND_START;
  static constexpr Command COMMAND_ABORT =
    SpotCheckCommandRequest_Command_COMMAND_ABORT;
  static constexpr Command COMMAND_REVERT_CAL =
    SpotCheckCommandRequest_Command_COMMAND_REVERT_CAL;
  static inline bool Command_IsValid(int value) {
    return SpotCheckCommandRequest_Command_IsValid(value);
  }
  static constexpr Command Command_MIN =
    SpotCheckCommandRequest_Command_Command_MIN;
  static constexpr Command Command_MAX =
    SpotCheckCommandRequest_Command_Command_MAX;
  static constexpr int Command_ARRAYSIZE =
    SpotCheckCommandRequest_Command_Command_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Command_descriptor() {
    return SpotCheckCommandRequest_Command_descriptor();
  }
  template<typename T>
  static inline const std::string& Command_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Command>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Command_Name.");
    return SpotCheckCommandRequest_Command_Name(enum_t_value);
  }
  static inline bool Command_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Command* value) {
    return SpotCheckCommandRequest_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 2,
    kCommandFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // .bosdyn.api.spot.SpotCheckCommandRequest.Command command = 3;
  void clear_command();
  ::bosdyn::api::spot::SpotCheckCommandRequest_Command command() const;
  void set_command(::bosdyn::api::spot::SpotCheckCommandRequest_Command value);
  private:
  ::bosdyn::api::spot::SpotCheckCommandRequest_Command _internal_command() const;
  void _internal_set_command(::bosdyn::api::spot::SpotCheckCommandRequest_Command value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.SpotCheckCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::Lease* lease_;
    int command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class SpotCheckCommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.SpotCheckCommandResponse) */ {
 public:
  inline SpotCheckCommandResponse() : SpotCheckCommandResponse(nullptr) {}
  ~SpotCheckCommandResponse() override;
  explicit PROTOBUF_CONSTEXPR SpotCheckCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotCheckCommandResponse(const SpotCheckCommandResponse& from);
  SpotCheckCommandResponse(SpotCheckCommandResponse&& from) noexcept
    : SpotCheckCommandResponse() {
    *this = ::std::move(from);
  }

  inline SpotCheckCommandResponse& operator=(const SpotCheckCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotCheckCommandResponse& operator=(SpotCheckCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotCheckCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotCheckCommandResponse* internal_default_instance() {
    return reinterpret_cast<const SpotCheckCommandResponse*>(
               &_SpotCheckCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SpotCheckCommandResponse& a, SpotCheckCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotCheckCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotCheckCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotCheckCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotCheckCommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotCheckCommandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotCheckCommandResponse& from) {
    SpotCheckCommandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotCheckCommandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.SpotCheckCommandResponse";
  }
  protected:
  explicit SpotCheckCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SpotCheckCommandResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    SpotCheckCommandResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    SpotCheckCommandResponse_Status_STATUS_OK;
  static constexpr Status STATUS_ERROR =
    SpotCheckCommandResponse_Status_STATUS_ERROR;
  static inline bool Status_IsValid(int value) {
    return SpotCheckCommandResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    SpotCheckCommandResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    SpotCheckCommandResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    SpotCheckCommandResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return SpotCheckCommandResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return SpotCheckCommandResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return SpotCheckCommandResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string message = 4;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  PROTOBUF_NODISCARD ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // .bosdyn.api.spot.SpotCheckCommandResponse.Status status = 3;
  void clear_status();
  ::bosdyn::api::spot::SpotCheckCommandResponse_Status status() const;
  void set_status(::bosdyn::api::spot::SpotCheckCommandResponse_Status value);
  private:
  ::bosdyn::api::spot::SpotCheckCommandResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::SpotCheckCommandResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.SpotCheckCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::LeaseUseResult* lease_use_result_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class SpotCheckFeedbackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.SpotCheckFeedbackRequest) */ {
 public:
  inline SpotCheckFeedbackRequest() : SpotCheckFeedbackRequest(nullptr) {}
  ~SpotCheckFeedbackRequest() override;
  explicit PROTOBUF_CONSTEXPR SpotCheckFeedbackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotCheckFeedbackRequest(const SpotCheckFeedbackRequest& from);
  SpotCheckFeedbackRequest(SpotCheckFeedbackRequest&& from) noexcept
    : SpotCheckFeedbackRequest() {
    *this = ::std::move(from);
  }

  inline SpotCheckFeedbackRequest& operator=(const SpotCheckFeedbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotCheckFeedbackRequest& operator=(SpotCheckFeedbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotCheckFeedbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotCheckFeedbackRequest* internal_default_instance() {
    return reinterpret_cast<const SpotCheckFeedbackRequest*>(
               &_SpotCheckFeedbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SpotCheckFeedbackRequest& a, SpotCheckFeedbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotCheckFeedbackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotCheckFeedbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotCheckFeedbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotCheckFeedbackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotCheckFeedbackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotCheckFeedbackRequest& from) {
    SpotCheckFeedbackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotCheckFeedbackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.SpotCheckFeedbackRequest";
  }
  protected:
  explicit SpotCheckFeedbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.SpotCheckFeedbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse& other);
  static const SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse*>(&_SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.spot.SpotCheckFeedbackResponse.CameraResultsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};

// -------------------------------------------------------------------

class SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse& other);
  static const SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse*>(&_SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.spot.SpotCheckFeedbackResponse.LoadCellResultsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};

// -------------------------------------------------------------------

class SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::JointKinematicCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::JointKinematicCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse& other);
  static const SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse*>(&_SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.spot.SpotCheckFeedbackResponse.KinematicCalResultsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};

// -------------------------------------------------------------------

class SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::FootHeightCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::FootHeightCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse& other);
  static const SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse*>(&_SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.spot.SpotCheckFeedbackResponse.FootHeightResultsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};

// -------------------------------------------------------------------

class SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::LegPairCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::LegPairCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse& other);
  static const SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse*>(&_SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.spot.SpotCheckFeedbackResponse.LegPairResultsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};

// -------------------------------------------------------------------

class SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::HipRangeOfMotionResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::HipRangeOfMotionResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUse& other);
  static const SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUse*>(&_SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.spot.SpotCheckFeedbackResponse.HipRangeOfMotionResultsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};

// -------------------------------------------------------------------

class SpotCheckFeedbackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.SpotCheckFeedbackResponse) */ {
 public:
  inline SpotCheckFeedbackResponse() : SpotCheckFeedbackResponse(nullptr) {}
  ~SpotCheckFeedbackResponse() override;
  explicit PROTOBUF_CONSTEXPR SpotCheckFeedbackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotCheckFeedbackResponse(const SpotCheckFeedbackResponse& from);
  SpotCheckFeedbackResponse(SpotCheckFeedbackResponse&& from) noexcept
    : SpotCheckFeedbackResponse() {
    *this = ::std::move(from);
  }

  inline SpotCheckFeedbackResponse& operator=(const SpotCheckFeedbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotCheckFeedbackResponse& operator=(SpotCheckFeedbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotCheckFeedbackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotCheckFeedbackResponse* internal_default_instance() {
    return reinterpret_cast<const SpotCheckFeedbackResponse*>(
               &_SpotCheckFeedbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SpotCheckFeedbackResponse& a, SpotCheckFeedbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotCheckFeedbackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotCheckFeedbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotCheckFeedbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotCheckFeedbackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotCheckFeedbackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotCheckFeedbackResponse& from) {
    SpotCheckFeedbackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotCheckFeedbackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.SpotCheckFeedbackResponse";
  }
  protected:
  explicit SpotCheckFeedbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef SpotCheckFeedbackResponse_State State;
  static constexpr State STATE_UNKNOWN =
    SpotCheckFeedbackResponse_State_STATE_UNKNOWN;
  static constexpr State STATE_USER_ABORTED =
    SpotCheckFeedbackResponse_State_STATE_USER_ABORTED;
  static constexpr State STATE_STARTING =
    SpotCheckFeedbackResponse_State_STATE_STARTING;
  static constexpr State STATE_LOADCELL_CAL =
    SpotCheckFeedbackResponse_State_STATE_LOADCELL_CAL;
  static constexpr State STATE_ENDSTOP_CAL =
    SpotCheckFeedbackResponse_State_STATE_ENDSTOP_CAL;
  static constexpr State STATE_CAMERA_CHECK =
    SpotCheckFeedbackResponse_State_STATE_CAMERA_CHECK;
  static constexpr State STATE_BODY_POSING =
    SpotCheckFeedbackResponse_State_STATE_BODY_POSING;
  static constexpr State STATE_FINISHED =
    SpotCheckFeedbackResponse_State_STATE_FINISHED;
  static constexpr State STATE_REVERTING_CAL =
    SpotCheckFeedbackResponse_State_STATE_REVERTING_CAL;
  static constexpr State STATE_ERROR =
    SpotCheckFeedbackResponse_State_STATE_ERROR;
  static constexpr State STATE_WAITING_FOR_COMMAND =
    SpotCheckFeedbackResponse_State_STATE_WAITING_FOR_COMMAND;
  static constexpr State STATE_HIP_RANGE_OF_MOTION_CHECK =
    SpotCheckFeedbackResponse_State_STATE_HIP_RANGE_OF_MOTION_CHECK;
  static constexpr State STATE_GRIPPER_CAL =
    SpotCheckFeedbackResponse_State_STATE_GRIPPER_CAL;
  static constexpr State STATE_SIT_DOWN_AFTER_RUN =
    SpotCheckFeedbackResponse_State_STATE_SIT_DOWN_AFTER_RUN;
  static constexpr State STATE_ARM_JOINT_CHECK =
    SpotCheckFeedbackResponse_State_STATE_ARM_JOINT_CHECK;
  static inline bool State_IsValid(int value) {
    return SpotCheckFeedbackResponse_State_IsValid(value);
  }
  static constexpr State State_MIN =
    SpotCheckFeedbackResponse_State_State_MIN;
  static constexpr State State_MAX =
    SpotCheckFeedbackResponse_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    SpotCheckFeedbackResponse_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return SpotCheckFeedbackResponse_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return SpotCheckFeedbackResponse_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return SpotCheckFeedbackResponse_State_Parse(name, value);
  }

  typedef SpotCheckFeedbackResponse_Error Error;
  static constexpr Error ERROR_UNKNOWN =
    SpotCheckFeedbackResponse_Error_ERROR_UNKNOWN;
  static constexpr Error ERROR_NONE =
    SpotCheckFeedbackResponse_Error_ERROR_NONE;
  static constexpr Error ERROR_UNEXPECTED_POWER_CHANGE =
    SpotCheckFeedbackResponse_Error_ERROR_UNEXPECTED_POWER_CHANGE;
  static constexpr Error ERROR_INIT_IMU_CHECK =
    SpotCheckFeedbackResponse_Error_ERROR_INIT_IMU_CHECK;
  static constexpr Error ERROR_INIT_NOT_SITTING =
    SpotCheckFeedbackResponse_Error_ERROR_INIT_NOT_SITTING;
  static constexpr Error ERROR_LOADCELL_TIMEOUT =
    SpotCheckFeedbackResponse_Error_ERROR_LOADCELL_TIMEOUT;
  static constexpr Error ERROR_POWER_ON_FAILURE =
    SpotCheckFeedbackResponse_Error_ERROR_POWER_ON_FAILURE;
  static constexpr Error ERROR_ENDSTOP_TIMEOUT =
    SpotCheckFeedbackResponse_Error_ERROR_ENDSTOP_TIMEOUT;
  static constexpr Error ERROR_FAILED_STAND =
    SpotCheckFeedbackResponse_Error_ERROR_FAILED_STAND;
  static constexpr Error ERROR_CAMERA_TIMEOUT =
    SpotCheckFeedbackResponse_Error_ERROR_CAMERA_TIMEOUT;
  static constexpr Error ERROR_GROUND_CHECK =
    SpotCheckFeedbackResponse_Error_ERROR_GROUND_CHECK;
  static constexpr Error ERROR_POWER_OFF_FAILURE =
    SpotCheckFeedbackResponse_Error_ERROR_POWER_OFF_FAILURE;
  static constexpr Error ERROR_REVERT_FAILURE =
    SpotCheckFeedbackResponse_Error_ERROR_REVERT_FAILURE;
  static constexpr Error ERROR_FGKC_FAILURE =
    SpotCheckFeedbackResponse_Error_ERROR_FGKC_FAILURE;
  static constexpr Error ERROR_GRIPPER_CAL_TIMEOUT =
    SpotCheckFeedbackResponse_Error_ERROR_GRIPPER_CAL_TIMEOUT;
  static constexpr Error ERROR_ARM_CHECK_COLLISION =
    SpotCheckFeedbackResponse_Error_ERROR_ARM_CHECK_COLLISION;
  static constexpr Error ERROR_ARM_CHECK_TIMEOUT =
    SpotCheckFeedbackResponse_Error_ERROR_ARM_CHECK_TIMEOUT;
  static inline bool Error_IsValid(int value) {
    return SpotCheckFeedbackResponse_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    SpotCheckFeedbackResponse_Error_Error_MIN;
  static constexpr Error Error_MAX =
    SpotCheckFeedbackResponse_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    SpotCheckFeedbackResponse_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return SpotCheckFeedbackResponse_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return SpotCheckFeedbackResponse_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Error* value) {
    return SpotCheckFeedbackResponse_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCameraResultsFieldNumber = 3,
    kLoadCellResultsFieldNumber = 4,
    kKinematicCalResultsFieldNumber = 5,
    kFootHeightResultsFieldNumber = 10,
    kLegPairResultsFieldNumber = 11,
    kHipRangeOfMotionResultsFieldNumber = 13,
    kHeaderFieldNumber = 1,
    kPayloadResultFieldNumber = 8,
    kLastCalTimestampFieldNumber = 9,
    kStateFieldNumber = 2,
    kErrorFieldNumber = 6,
    kProgressFieldNumber = 7,
    kLastCommandFieldNumber = 12,
  };
  // map<string, .bosdyn.api.spot.DepthPlaneSpotCheckResult> camera_results = 3;
  int camera_results_size() const;
  private:
  int _internal_camera_results_size() const;
  public:
  void clear_camera_results();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult >&
      _internal_camera_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult >*
      _internal_mutable_camera_results();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult >&
      camera_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult >*
      mutable_camera_results();

  // map<string, .bosdyn.api.spot.LoadCellSpotCheckResult> load_cell_results = 4;
  int load_cell_results_size() const;
  private:
  int _internal_load_cell_results_size() const;
  public:
  void clear_load_cell_results();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult >&
      _internal_load_cell_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult >*
      _internal_mutable_load_cell_results();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult >&
      load_cell_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult >*
      mutable_load_cell_results();

  // map<string, .bosdyn.api.spot.JointKinematicCheckResult> kinematic_cal_results = 5;
  int kinematic_cal_results_size() const;
  private:
  int _internal_kinematic_cal_results_size() const;
  public:
  void clear_kinematic_cal_results();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::JointKinematicCheckResult >&
      _internal_kinematic_cal_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::JointKinematicCheckResult >*
      _internal_mutable_kinematic_cal_results();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::JointKinematicCheckResult >&
      kinematic_cal_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::JointKinematicCheckResult >*
      mutable_kinematic_cal_results();

  // map<string, .bosdyn.api.spot.FootHeightCheckResult> foot_height_results = 10 [deprecated = true];
  PROTOBUF_DEPRECATED int foot_height_results_size() const;
  private:
  int _internal_foot_height_results_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_foot_height_results();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::FootHeightCheckResult >&
      _internal_foot_height_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::FootHeightCheckResult >*
      _internal_mutable_foot_height_results();
  public:
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::FootHeightCheckResult >&
      foot_height_results() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::FootHeightCheckResult >*
      mutable_foot_height_results();

  // map<string, .bosdyn.api.spot.LegPairCheckResult> leg_pair_results = 11 [deprecated = true];
  PROTOBUF_DEPRECATED int leg_pair_results_size() const;
  private:
  int _internal_leg_pair_results_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_leg_pair_results();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LegPairCheckResult >&
      _internal_leg_pair_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LegPairCheckResult >*
      _internal_mutable_leg_pair_results();
  public:
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LegPairCheckResult >&
      leg_pair_results() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LegPairCheckResult >*
      mutable_leg_pair_results();

  // map<string, .bosdyn.api.spot.HipRangeOfMotionResult> hip_range_of_motion_results = 13;
  int hip_range_of_motion_results_size() const;
  private:
  int _internal_hip_range_of_motion_results_size() const;
  public:
  void clear_hip_range_of_motion_results();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::HipRangeOfMotionResult >&
      _internal_hip_range_of_motion_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::HipRangeOfMotionResult >*
      _internal_mutable_hip_range_of_motion_results();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::HipRangeOfMotionResult >&
      hip_range_of_motion_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::HipRangeOfMotionResult >*
      mutable_hip_range_of_motion_results();

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot.PayloadCheckResult payload_result = 8;
  bool has_payload_result() const;
  private:
  bool _internal_has_payload_result() const;
  public:
  void clear_payload_result();
  const ::bosdyn::api::spot::PayloadCheckResult& payload_result() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::PayloadCheckResult* release_payload_result();
  ::bosdyn::api::spot::PayloadCheckResult* mutable_payload_result();
  void set_allocated_payload_result(::bosdyn::api::spot::PayloadCheckResult* payload_result);
  private:
  const ::bosdyn::api::spot::PayloadCheckResult& _internal_payload_result() const;
  ::bosdyn::api::spot::PayloadCheckResult* _internal_mutable_payload_result();
  public:
  void unsafe_arena_set_allocated_payload_result(
      ::bosdyn::api::spot::PayloadCheckResult* payload_result);
  ::bosdyn::api::spot::PayloadCheckResult* unsafe_arena_release_payload_result();

  // .google.protobuf.Timestamp last_cal_timestamp = 9;
  bool has_last_cal_timestamp() const;
  private:
  bool _internal_has_last_cal_timestamp() const;
  public:
  void clear_last_cal_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_cal_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_cal_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_cal_timestamp();
  void set_allocated_last_cal_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* last_cal_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_cal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_cal_timestamp();
  public:
  void unsafe_arena_set_allocated_last_cal_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_cal_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_cal_timestamp();

  // .bosdyn.api.spot.SpotCheckFeedbackResponse.State state = 2;
  void clear_state();
  ::bosdyn::api::spot::SpotCheckFeedbackResponse_State state() const;
  void set_state(::bosdyn::api::spot::SpotCheckFeedbackResponse_State value);
  private:
  ::bosdyn::api::spot::SpotCheckFeedbackResponse_State _internal_state() const;
  void _internal_set_state(::bosdyn::api::spot::SpotCheckFeedbackResponse_State value);
  public:

  // .bosdyn.api.spot.SpotCheckFeedbackResponse.Error error = 6;
  void clear_error();
  ::bosdyn::api::spot::SpotCheckFeedbackResponse_Error error() const;
  void set_error(::bosdyn::api::spot::SpotCheckFeedbackResponse_Error value);
  private:
  ::bosdyn::api::spot::SpotCheckFeedbackResponse_Error _internal_error() const;
  void _internal_set_error(::bosdyn::api::spot::SpotCheckFeedbackResponse_Error value);
  public:

  // float progress = 7;
  void clear_progress();
  float progress() const;
  void set_progress(float value);
  private:
  float _internal_progress() const;
  void _internal_set_progress(float value);
  public:

  // .bosdyn.api.spot.SpotCheckCommandRequest.Command last_command = 12;
  void clear_last_command();
  ::bosdyn::api::spot::SpotCheckCommandRequest_Command last_command() const;
  void set_last_command(::bosdyn::api::spot::SpotCheckCommandRequest_Command value);
  private:
  ::bosdyn::api::spot::SpotCheckCommandRequest_Command _internal_last_command() const;
  void _internal_set_last_command(::bosdyn::api::spot::SpotCheckCommandRequest_Command value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.SpotCheckFeedbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse,
        std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> camera_results_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse,
        std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> load_cell_results_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse,
        std::string, ::bosdyn::api::spot::JointKinematicCheckResult,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> kinematic_cal_results_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse,
        std::string, ::bosdyn::api::spot::FootHeightCheckResult,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> foot_height_results_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse,
        std::string, ::bosdyn::api::spot::LegPairCheckResult,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> leg_pair_results_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SpotCheckFeedbackResponse_HipRangeOfMotionResultsEntry_DoNotUse,
        std::string, ::bosdyn::api::spot::HipRangeOfMotionResult,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> hip_range_of_motion_results_;
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::spot::PayloadCheckResult* payload_result_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_cal_timestamp_;
    int state_;
    int error_;
    float progress_;
    int last_command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class DepthPlaneSpotCheckResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.DepthPlaneSpotCheckResult) */ {
 public:
  inline DepthPlaneSpotCheckResult() : DepthPlaneSpotCheckResult(nullptr) {}
  ~DepthPlaneSpotCheckResult() override;
  explicit PROTOBUF_CONSTEXPR DepthPlaneSpotCheckResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DepthPlaneSpotCheckResult(const DepthPlaneSpotCheckResult& from);
  DepthPlaneSpotCheckResult(DepthPlaneSpotCheckResult&& from) noexcept
    : DepthPlaneSpotCheckResult() {
    *this = ::std::move(from);
  }

  inline DepthPlaneSpotCheckResult& operator=(const DepthPlaneSpotCheckResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline DepthPlaneSpotCheckResult& operator=(DepthPlaneSpotCheckResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DepthPlaneSpotCheckResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const DepthPlaneSpotCheckResult* internal_default_instance() {
    return reinterpret_cast<const DepthPlaneSpotCheckResult*>(
               &_DepthPlaneSpotCheckResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DepthPlaneSpotCheckResult& a, DepthPlaneSpotCheckResult& b) {
    a.Swap(&b);
  }
  inline void Swap(DepthPlaneSpotCheckResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DepthPlaneSpotCheckResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DepthPlaneSpotCheckResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DepthPlaneSpotCheckResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DepthPlaneSpotCheckResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DepthPlaneSpotCheckResult& from) {
    DepthPlaneSpotCheckResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DepthPlaneSpotCheckResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.DepthPlaneSpotCheckResult";
  }
  protected:
  explicit DepthPlaneSpotCheckResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DepthPlaneSpotCheckResult_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    DepthPlaneSpotCheckResult_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    DepthPlaneSpotCheckResult_Status_STATUS_OK;
  static constexpr Status STATUS_WARNING =
    DepthPlaneSpotCheckResult_Status_STATUS_WARNING;
  static constexpr Status STATUS_ERROR =
    DepthPlaneSpotCheckResult_Status_STATUS_ERROR;
  static inline bool Status_IsValid(int value) {
    return DepthPlaneSpotCheckResult_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    DepthPlaneSpotCheckResult_Status_Status_MIN;
  static constexpr Status Status_MAX =
    DepthPlaneSpotCheckResult_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    DepthPlaneSpotCheckResult_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return DepthPlaneSpotCheckResult_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return DepthPlaneSpotCheckResult_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return DepthPlaneSpotCheckResult_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kSeverityScoreFieldNumber = 2,
  };
  // .bosdyn.api.spot.DepthPlaneSpotCheckResult.Status status = 1;
  void clear_status();
  ::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status status() const;
  void set_status(::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status value);
  private:
  ::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status value);
  public:

  // float severity_score = 2;
  void clear_severity_score();
  float severity_score() const;
  void set_severity_score(float value);
  private:
  float _internal_severity_score() const;
  void _internal_set_severity_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.DepthPlaneSpotCheckResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int status_;
    float severity_score_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class PayloadCheckResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.PayloadCheckResult) */ {
 public:
  inline PayloadCheckResult() : PayloadCheckResult(nullptr) {}
  ~PayloadCheckResult() override;
  explicit PROTOBUF_CONSTEXPR PayloadCheckResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PayloadCheckResult(const PayloadCheckResult& from);
  PayloadCheckResult(PayloadCheckResult&& from) noexcept
    : PayloadCheckResult() {
    *this = ::std::move(from);
  }

  inline PayloadCheckResult& operator=(const PayloadCheckResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadCheckResult& operator=(PayloadCheckResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PayloadCheckResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const PayloadCheckResult* internal_default_instance() {
    return reinterpret_cast<const PayloadCheckResult*>(
               &_PayloadCheckResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PayloadCheckResult& a, PayloadCheckResult& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadCheckResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadCheckResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadCheckResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PayloadCheckResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PayloadCheckResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PayloadCheckResult& from) {
    PayloadCheckResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PayloadCheckResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.PayloadCheckResult";
  }
  protected:
  explicit PayloadCheckResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PayloadCheckResult_Error Error;
  static constexpr Error ERROR_UNKNOWN =
    PayloadCheckResult_Error_ERROR_UNKNOWN;
  static constexpr Error ERROR_NONE =
    PayloadCheckResult_Error_ERROR_NONE;
  static constexpr Error ERROR_MASS_DISCREPANCY =
    PayloadCheckResult_Error_ERROR_MASS_DISCREPANCY;
  static inline bool Error_IsValid(int value) {
    return PayloadCheckResult_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    PayloadCheckResult_Error_Error_MIN;
  static constexpr Error Error_MAX =
    PayloadCheckResult_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    PayloadCheckResult_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return PayloadCheckResult_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return PayloadCheckResult_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Error* value) {
    return PayloadCheckResult_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kExtraPayloadFieldNumber = 2,
  };
  // .bosdyn.api.spot.PayloadCheckResult.Error error = 1;
  void clear_error();
  ::bosdyn::api::spot::PayloadCheckResult_Error error() const;
  void set_error(::bosdyn::api::spot::PayloadCheckResult_Error value);
  private:
  ::bosdyn::api::spot::PayloadCheckResult_Error _internal_error() const;
  void _internal_set_error(::bosdyn::api::spot::PayloadCheckResult_Error value);
  public:

  // float extra_payload = 2;
  void clear_extra_payload();
  float extra_payload() const;
  void set_extra_payload(float value);
  private:
  float _internal_extra_payload() const;
  void _internal_set_extra_payload(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.PayloadCheckResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int error_;
    float extra_payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class LoadCellSpotCheckResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.LoadCellSpotCheckResult) */ {
 public:
  inline LoadCellSpotCheckResult() : LoadCellSpotCheckResult(nullptr) {}
  ~LoadCellSpotCheckResult() override;
  explicit PROTOBUF_CONSTEXPR LoadCellSpotCheckResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadCellSpotCheckResult(const LoadCellSpotCheckResult& from);
  LoadCellSpotCheckResult(LoadCellSpotCheckResult&& from) noexcept
    : LoadCellSpotCheckResult() {
    *this = ::std::move(from);
  }

  inline LoadCellSpotCheckResult& operator=(const LoadCellSpotCheckResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadCellSpotCheckResult& operator=(LoadCellSpotCheckResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadCellSpotCheckResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadCellSpotCheckResult* internal_default_instance() {
    return reinterpret_cast<const LoadCellSpotCheckResult*>(
               &_LoadCellSpotCheckResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LoadCellSpotCheckResult& a, LoadCellSpotCheckResult& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadCellSpotCheckResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadCellSpotCheckResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadCellSpotCheckResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadCellSpotCheckResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadCellSpotCheckResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadCellSpotCheckResult& from) {
    LoadCellSpotCheckResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadCellSpotCheckResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.LoadCellSpotCheckResult";
  }
  protected:
  explicit LoadCellSpotCheckResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LoadCellSpotCheckResult_Error Error;
  static constexpr Error ERROR_UNKNOWN =
    LoadCellSpotCheckResult_Error_ERROR_UNKNOWN;
  static constexpr Error ERROR_NONE =
    LoadCellSpotCheckResult_Error_ERROR_NONE;
  static constexpr Error ERROR_ZERO_OUT_OF_RANGE =
    LoadCellSpotCheckResult_Error_ERROR_ZERO_OUT_OF_RANGE;
  static inline bool Error_IsValid(int value) {
    return LoadCellSpotCheckResult_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    LoadCellSpotCheckResult_Error_Error_MIN;
  static constexpr Error Error_MAX =
    LoadCellSpotCheckResult_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    LoadCellSpotCheckResult_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return LoadCellSpotCheckResult_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return LoadCellSpotCheckResult_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Error* value) {
    return LoadCellSpotCheckResult_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kZeroFieldNumber = 3,
    kOldZeroFieldNumber = 4,
  };
  // .bosdyn.api.spot.LoadCellSpotCheckResult.Error error = 2;
  void clear_error();
  ::bosdyn::api::spot::LoadCellSpotCheckResult_Error error() const;
  void set_error(::bosdyn::api::spot::LoadCellSpotCheckResult_Error value);
  private:
  ::bosdyn::api::spot::LoadCellSpotCheckResult_Error _internal_error() const;
  void _internal_set_error(::bosdyn::api::spot::LoadCellSpotCheckResult_Error value);
  public:

  // float zero = 3;
  void clear_zero();
  float zero() const;
  void set_zero(float value);
  private:
  float _internal_zero() const;
  void _internal_set_zero(float value);
  public:

  // float old_zero = 4;
  void clear_old_zero();
  float old_zero() const;
  void set_old_zero(float value);
  private:
  float _internal_old_zero() const;
  void _internal_set_old_zero(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.LoadCellSpotCheckResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int error_;
    float zero_;
    float old_zero_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class JointKinematicCheckResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.JointKinematicCheckResult) */ {
 public:
  inline JointKinematicCheckResult() : JointKinematicCheckResult(nullptr) {}
  ~JointKinematicCheckResult() override;
  explicit PROTOBUF_CONSTEXPR JointKinematicCheckResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JointKinematicCheckResult(const JointKinematicCheckResult& from);
  JointKinematicCheckResult(JointKinematicCheckResult&& from) noexcept
    : JointKinematicCheckResult() {
    *this = ::std::move(from);
  }

  inline JointKinematicCheckResult& operator=(const JointKinematicCheckResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointKinematicCheckResult& operator=(JointKinematicCheckResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JointKinematicCheckResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const JointKinematicCheckResult* internal_default_instance() {
    return reinterpret_cast<const JointKinematicCheckResult*>(
               &_JointKinematicCheckResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(JointKinematicCheckResult& a, JointKinematicCheckResult& b) {
    a.Swap(&b);
  }
  inline void Swap(JointKinematicCheckResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointKinematicCheckResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JointKinematicCheckResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JointKinematicCheckResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JointKinematicCheckResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JointKinematicCheckResult& from) {
    JointKinematicCheckResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointKinematicCheckResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.JointKinematicCheckResult";
  }
  protected:
  explicit JointKinematicCheckResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef JointKinematicCheckResult_Error Error;
  static constexpr Error ERROR_UNKNOWN =
    JointKinematicCheckResult_Error_ERROR_UNKNOWN;
  static constexpr Error ERROR_NONE =
    JointKinematicCheckResult_Error_ERROR_NONE;
  static constexpr Error ERROR_CLUTCH_SLIP =
    JointKinematicCheckResult_Error_ERROR_CLUTCH_SLIP;
  static constexpr Error ERROR_INVALID_RANGE_OF_MOTION =
    JointKinematicCheckResult_Error_ERROR_INVALID_RANGE_OF_MOTION;
  static constexpr Error ERROR_ENCODER_SHIFTED =
    JointKinematicCheckResult_Error_ERROR_ENCODER_SHIFTED;
  static constexpr Error ERROR_COLLISION =
    JointKinematicCheckResult_Error_ERROR_COLLISION;
  static inline bool Error_IsValid(int value) {
    return JointKinematicCheckResult_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    JointKinematicCheckResult_Error_Error_MIN;
  static constexpr Error Error_MAX =
    JointKinematicCheckResult_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    JointKinematicCheckResult_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return JointKinematicCheckResult_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return JointKinematicCheckResult_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Error* value) {
    return JointKinematicCheckResult_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kOldOffsetFieldNumber = 4,
    kHealthScoreFieldNumber = 5,
  };
  // .bosdyn.api.spot.JointKinematicCheckResult.Error error = 2;
  void clear_error();
  ::bosdyn::api::spot::JointKinematicCheckResult_Error error() const;
  void set_error(::bosdyn::api::spot::JointKinematicCheckResult_Error value);
  private:
  ::bosdyn::api::spot::JointKinematicCheckResult_Error _internal_error() const;
  void _internal_set_error(::bosdyn::api::spot::JointKinematicCheckResult_Error value);
  public:

  // float offset = 3;
  void clear_offset();
  float offset() const;
  void set_offset(float value);
  private:
  float _internal_offset() const;
  void _internal_set_offset(float value);
  public:

  // float old_offset = 4;
  void clear_old_offset();
  float old_offset() const;
  void set_old_offset(float value);
  private:
  float _internal_old_offset() const;
  void _internal_set_old_offset(float value);
  public:

  // float health_score = 5;
  void clear_health_score();
  float health_score() const;
  void set_health_score(float value);
  private:
  float _internal_health_score() const;
  void _internal_set_health_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.JointKinematicCheckResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int error_;
    float offset_;
    float old_offset_;
    float health_score_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class FootHeightCheckResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.FootHeightCheckResult) */ {
 public:
  inline FootHeightCheckResult() : FootHeightCheckResult(nullptr) {}
  ~FootHeightCheckResult() override;
  explicit PROTOBUF_CONSTEXPR FootHeightCheckResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FootHeightCheckResult(const FootHeightCheckResult& from);
  FootHeightCheckResult(FootHeightCheckResult&& from) noexcept
    : FootHeightCheckResult() {
    *this = ::std::move(from);
  }

  inline FootHeightCheckResult& operator=(const FootHeightCheckResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline FootHeightCheckResult& operator=(FootHeightCheckResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FootHeightCheckResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const FootHeightCheckResult* internal_default_instance() {
    return reinterpret_cast<const FootHeightCheckResult*>(
               &_FootHeightCheckResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(FootHeightCheckResult& a, FootHeightCheckResult& b) {
    a.Swap(&b);
  }
  inline void Swap(FootHeightCheckResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FootHeightCheckResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FootHeightCheckResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FootHeightCheckResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FootHeightCheckResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FootHeightCheckResult& from) {
    FootHeightCheckResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FootHeightCheckResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.FootHeightCheckResult";
  }
  protected:
  explicit FootHeightCheckResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FootHeightCheckResult_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    FootHeightCheckResult_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    FootHeightCheckResult_Status_STATUS_OK;
  static constexpr Status STATUS_WARNING =
    FootHeightCheckResult_Status_STATUS_WARNING;
  static constexpr Status STATUS_ERROR =
    FootHeightCheckResult_Status_STATUS_ERROR;
  static inline bool Status_IsValid(int value) {
    return FootHeightCheckResult_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    FootHeightCheckResult_Status_Status_MIN;
  static constexpr Status Status_MAX =
    FootHeightCheckResult_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    FootHeightCheckResult_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return FootHeightCheckResult_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return FootHeightCheckResult_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return FootHeightCheckResult_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kFootHeightErrorFromMeanFieldNumber = 3,
  };
  // .bosdyn.api.spot.FootHeightCheckResult.Status status = 2;
  void clear_status();
  ::bosdyn::api::spot::FootHeightCheckResult_Status status() const;
  void set_status(::bosdyn::api::spot::FootHeightCheckResult_Status value);
  private:
  ::bosdyn::api::spot::FootHeightCheckResult_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::FootHeightCheckResult_Status value);
  public:

  // float foot_height_error_from_mean = 3;
  void clear_foot_height_error_from_mean();
  float foot_height_error_from_mean() const;
  void set_foot_height_error_from_mean(float value);
  private:
  float _internal_foot_height_error_from_mean() const;
  void _internal_set_foot_height_error_from_mean(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.FootHeightCheckResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int status_;
    float foot_height_error_from_mean_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class LegPairCheckResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.LegPairCheckResult) */ {
 public:
  inline LegPairCheckResult() : LegPairCheckResult(nullptr) {}
  ~LegPairCheckResult() override;
  explicit PROTOBUF_CONSTEXPR LegPairCheckResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LegPairCheckResult(const LegPairCheckResult& from);
  LegPairCheckResult(LegPairCheckResult&& from) noexcept
    : LegPairCheckResult() {
    *this = ::std::move(from);
  }

  inline LegPairCheckResult& operator=(const LegPairCheckResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline LegPairCheckResult& operator=(LegPairCheckResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LegPairCheckResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const LegPairCheckResult* internal_default_instance() {
    return reinterpret_cast<const LegPairCheckResult*>(
               &_LegPairCheckResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LegPairCheckResult& a, LegPairCheckResult& b) {
    a.Swap(&b);
  }
  inline void Swap(LegPairCheckResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LegPairCheckResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LegPairCheckResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LegPairCheckResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LegPairCheckResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LegPairCheckResult& from) {
    LegPairCheckResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LegPairCheckResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.LegPairCheckResult";
  }
  protected:
  explicit LegPairCheckResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LegPairCheckResult_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    LegPairCheckResult_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    LegPairCheckResult_Status_STATUS_OK;
  static constexpr Status STATUS_WARNING =
    LegPairCheckResult_Status_STATUS_WARNING;
  static constexpr Status STATUS_ERROR =
    LegPairCheckResult_Status_STATUS_ERROR;
  static inline bool Status_IsValid(int value) {
    return LegPairCheckResult_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    LegPairCheckResult_Status_Status_MIN;
  static constexpr Status Status_MAX =
    LegPairCheckResult_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    LegPairCheckResult_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return LegPairCheckResult_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return LegPairCheckResult_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return LegPairCheckResult_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kLegPairDistanceChangeFieldNumber = 3,
  };
  // .bosdyn.api.spot.LegPairCheckResult.Status status = 2;
  void clear_status();
  ::bosdyn::api::spot::LegPairCheckResult_Status status() const;
  void set_status(::bosdyn::api::spot::LegPairCheckResult_Status value);
  private:
  ::bosdyn::api::spot::LegPairCheckResult_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::LegPairCheckResult_Status value);
  public:

  // float leg_pair_distance_change = 3;
  void clear_leg_pair_distance_change();
  float leg_pair_distance_change() const;
  void set_leg_pair_distance_change(float value);
  private:
  float _internal_leg_pair_distance_change() const;
  void _internal_set_leg_pair_distance_change(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.LegPairCheckResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int status_;
    float leg_pair_distance_change_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class HipRangeOfMotionResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.HipRangeOfMotionResult) */ {
 public:
  inline HipRangeOfMotionResult() : HipRangeOfMotionResult(nullptr) {}
  ~HipRangeOfMotionResult() override;
  explicit PROTOBUF_CONSTEXPR HipRangeOfMotionResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HipRangeOfMotionResult(const HipRangeOfMotionResult& from);
  HipRangeOfMotionResult(HipRangeOfMotionResult&& from) noexcept
    : HipRangeOfMotionResult() {
    *this = ::std::move(from);
  }

  inline HipRangeOfMotionResult& operator=(const HipRangeOfMotionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline HipRangeOfMotionResult& operator=(HipRangeOfMotionResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HipRangeOfMotionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const HipRangeOfMotionResult* internal_default_instance() {
    return reinterpret_cast<const HipRangeOfMotionResult*>(
               &_HipRangeOfMotionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(HipRangeOfMotionResult& a, HipRangeOfMotionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(HipRangeOfMotionResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HipRangeOfMotionResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HipRangeOfMotionResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HipRangeOfMotionResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HipRangeOfMotionResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HipRangeOfMotionResult& from) {
    HipRangeOfMotionResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HipRangeOfMotionResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.HipRangeOfMotionResult";
  }
  protected:
  explicit HipRangeOfMotionResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HipRangeOfMotionResult_Error Error;
  static constexpr Error ERROR_UNKNOWN =
    HipRangeOfMotionResult_Error_ERROR_UNKNOWN;
  static constexpr Error ERROR_NONE =
    HipRangeOfMotionResult_Error_ERROR_NONE;
  static constexpr Error ERROR_OBSTRUCTED =
    HipRangeOfMotionResult_Error_ERROR_OBSTRUCTED;
  static inline bool Error_IsValid(int value) {
    return HipRangeOfMotionResult_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    HipRangeOfMotionResult_Error_Error_MIN;
  static constexpr Error Error_MAX =
    HipRangeOfMotionResult_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    HipRangeOfMotionResult_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return HipRangeOfMotionResult_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return HipRangeOfMotionResult_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Error* value) {
    return HipRangeOfMotionResult_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHxFieldNumber = 2,
    kHyFieldNumber = 3,
    kErrorFieldNumber = 1,
  };
  // repeated float hx = 2;
  int hx_size() const;
  private:
  int _internal_hx_size() const;
  public:
  void clear_hx();
  private:
  float _internal_hx(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_hx() const;
  void _internal_add_hx(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_hx();
  public:
  float hx(int index) const;
  void set_hx(int index, float value);
  void add_hx(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      hx() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_hx();

  // repeated float hy = 3;
  int hy_size() const;
  private:
  int _internal_hy_size() const;
  public:
  void clear_hy();
  private:
  float _internal_hy(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_hy() const;
  void _internal_add_hy(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_hy();
  public:
  float hy(int index) const;
  void set_hy(int index, float value);
  void add_hy(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      hy() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_hy();

  // .bosdyn.api.spot.HipRangeOfMotionResult.Error error = 1;
  void clear_error();
  ::bosdyn::api::spot::HipRangeOfMotionResult_Error error() const;
  void set_error(::bosdyn::api::spot::HipRangeOfMotionResult_Error value);
  private:
  ::bosdyn::api::spot::HipRangeOfMotionResult_Error _internal_error() const;
  void _internal_set_error(::bosdyn::api::spot::HipRangeOfMotionResult_Error value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.HipRangeOfMotionResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > hx_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > hy_;
    int error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class CameraCalibrationCommandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.CameraCalibrationCommandRequest) */ {
 public:
  inline CameraCalibrationCommandRequest() : CameraCalibrationCommandRequest(nullptr) {}
  ~CameraCalibrationCommandRequest() override;
  explicit PROTOBUF_CONSTEXPR CameraCalibrationCommandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CameraCalibrationCommandRequest(const CameraCalibrationCommandRequest& from);
  CameraCalibrationCommandRequest(CameraCalibrationCommandRequest&& from) noexcept
    : CameraCalibrationCommandRequest() {
    *this = ::std::move(from);
  }

  inline CameraCalibrationCommandRequest& operator=(const CameraCalibrationCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraCalibrationCommandRequest& operator=(CameraCalibrationCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraCalibrationCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraCalibrationCommandRequest* internal_default_instance() {
    return reinterpret_cast<const CameraCalibrationCommandRequest*>(
               &_CameraCalibrationCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CameraCalibrationCommandRequest& a, CameraCalibrationCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraCalibrationCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraCalibrationCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraCalibrationCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CameraCalibrationCommandRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CameraCalibrationCommandRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CameraCalibrationCommandRequest& from) {
    CameraCalibrationCommandRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraCalibrationCommandRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.CameraCalibrationCommandRequest";
  }
  protected:
  explicit CameraCalibrationCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CameraCalibrationCommandRequest_Command Command;
  static constexpr Command COMMAND_UNKNOWN =
    CameraCalibrationCommandRequest_Command_COMMAND_UNKNOWN;
  static constexpr Command COMMAND_START =
    CameraCalibrationCommandRequest_Command_COMMAND_START;
  static constexpr Command COMMAND_CANCEL =
    CameraCalibrationCommandRequest_Command_COMMAND_CANCEL;
  static inline bool Command_IsValid(int value) {
    return CameraCalibrationCommandRequest_Command_IsValid(value);
  }
  static constexpr Command Command_MIN =
    CameraCalibrationCommandRequest_Command_Command_MIN;
  static constexpr Command Command_MAX =
    CameraCalibrationCommandRequest_Command_Command_MAX;
  static constexpr int Command_ARRAYSIZE =
    CameraCalibrationCommandRequest_Command_Command_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Command_descriptor() {
    return CameraCalibrationCommandRequest_Command_descriptor();
  }
  template<typename T>
  static inline const std::string& Command_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Command>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Command_Name.");
    return CameraCalibrationCommandRequest_Command_Name(enum_t_value);
  }
  static inline bool Command_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Command* value) {
    return CameraCalibrationCommandRequest_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 2,
    kCommandFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // .bosdyn.api.spot.CameraCalibrationCommandRequest.Command command = 3;
  void clear_command();
  ::bosdyn::api::spot::CameraCalibrationCommandRequest_Command command() const;
  void set_command(::bosdyn::api::spot::CameraCalibrationCommandRequest_Command value);
  private:
  ::bosdyn::api::spot::CameraCalibrationCommandRequest_Command _internal_command() const;
  void _internal_set_command(::bosdyn::api::spot::CameraCalibrationCommandRequest_Command value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.CameraCalibrationCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::Lease* lease_;
    int command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class CameraCalibrationCommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.CameraCalibrationCommandResponse) */ {
 public:
  inline CameraCalibrationCommandResponse() : CameraCalibrationCommandResponse(nullptr) {}
  ~CameraCalibrationCommandResponse() override;
  explicit PROTOBUF_CONSTEXPR CameraCalibrationCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CameraCalibrationCommandResponse(const CameraCalibrationCommandResponse& from);
  CameraCalibrationCommandResponse(CameraCalibrationCommandResponse&& from) noexcept
    : CameraCalibrationCommandResponse() {
    *this = ::std::move(from);
  }

  inline CameraCalibrationCommandResponse& operator=(const CameraCalibrationCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraCalibrationCommandResponse& operator=(CameraCalibrationCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraCalibrationCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraCalibrationCommandResponse* internal_default_instance() {
    return reinterpret_cast<const CameraCalibrationCommandResponse*>(
               &_CameraCalibrationCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CameraCalibrationCommandResponse& a, CameraCalibrationCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraCalibrationCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraCalibrationCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraCalibrationCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CameraCalibrationCommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CameraCalibrationCommandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CameraCalibrationCommandResponse& from) {
    CameraCalibrationCommandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraCalibrationCommandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.CameraCalibrationCommandResponse";
  }
  protected:
  explicit CameraCalibrationCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  PROTOBUF_NODISCARD ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.CameraCalibrationCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::LeaseUseResult* lease_use_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class CameraCalibrationFeedbackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.CameraCalibrationFeedbackRequest) */ {
 public:
  inline CameraCalibrationFeedbackRequest() : CameraCalibrationFeedbackRequest(nullptr) {}
  ~CameraCalibrationFeedbackRequest() override;
  explicit PROTOBUF_CONSTEXPR CameraCalibrationFeedbackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CameraCalibrationFeedbackRequest(const CameraCalibrationFeedbackRequest& from);
  CameraCalibrationFeedbackRequest(CameraCalibrationFeedbackRequest&& from) noexcept
    : CameraCalibrationFeedbackRequest() {
    *this = ::std::move(from);
  }

  inline CameraCalibrationFeedbackRequest& operator=(const CameraCalibrationFeedbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraCalibrationFeedbackRequest& operator=(CameraCalibrationFeedbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraCalibrationFeedbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraCalibrationFeedbackRequest* internal_default_instance() {
    return reinterpret_cast<const CameraCalibrationFeedbackRequest*>(
               &_CameraCalibrationFeedbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CameraCalibrationFeedbackRequest& a, CameraCalibrationFeedbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraCalibrationFeedbackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraCalibrationFeedbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraCalibrationFeedbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CameraCalibrationFeedbackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CameraCalibrationFeedbackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CameraCalibrationFeedbackRequest& from) {
    CameraCalibrationFeedbackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraCalibrationFeedbackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.CameraCalibrationFeedbackRequest";
  }
  protected:
  explicit CameraCalibrationFeedbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.CameraCalibrationFeedbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class CameraCalibrationFeedbackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.CameraCalibrationFeedbackResponse) */ {
 public:
  inline CameraCalibrationFeedbackResponse() : CameraCalibrationFeedbackResponse(nullptr) {}
  ~CameraCalibrationFeedbackResponse() override;
  explicit PROTOBUF_CONSTEXPR CameraCalibrationFeedbackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CameraCalibrationFeedbackResponse(const CameraCalibrationFeedbackResponse& from);
  CameraCalibrationFeedbackResponse(CameraCalibrationFeedbackResponse&& from) noexcept
    : CameraCalibrationFeedbackResponse() {
    *this = ::std::move(from);
  }

  inline CameraCalibrationFeedbackResponse& operator=(const CameraCalibrationFeedbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraCalibrationFeedbackResponse& operator=(CameraCalibrationFeedbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraCalibrationFeedbackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraCalibrationFeedbackResponse* internal_default_instance() {
    return reinterpret_cast<const CameraCalibrationFeedbackResponse*>(
               &_CameraCalibrationFeedbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CameraCalibrationFeedbackResponse& a, CameraCalibrationFeedbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraCalibrationFeedbackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraCalibrationFeedbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraCalibrationFeedbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CameraCalibrationFeedbackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CameraCalibrationFeedbackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CameraCalibrationFeedbackResponse& from) {
    CameraCalibrationFeedbackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraCalibrationFeedbackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.CameraCalibrationFeedbackResponse";
  }
  protected:
  explicit CameraCalibrationFeedbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CameraCalibrationFeedbackResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    CameraCalibrationFeedbackResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_PROCESSING =
    CameraCalibrationFeedbackResponse_Status_STATUS_PROCESSING;
  static constexpr Status STATUS_SUCCESS =
    CameraCalibrationFeedbackResponse_Status_STATUS_SUCCESS;
  static constexpr Status STATUS_USER_CANCELED =
    CameraCalibrationFeedbackResponse_Status_STATUS_USER_CANCELED;
  static constexpr Status STATUS_POWER_ERROR =
    CameraCalibrationFeedbackResponse_Status_STATUS_POWER_ERROR;
  static constexpr Status STATUS_LEASE_ERROR =
    CameraCalibrationFeedbackResponse_Status_STATUS_LEASE_ERROR;
  static constexpr Status STATUS_ROBOT_COMMAND_ERROR =
    CameraCalibrationFeedbackResponse_Status_STATUS_ROBOT_COMMAND_ERROR;
  static constexpr Status STATUS_CALIBRATION_ERROR =
    CameraCalibrationFeedbackResponse_Status_STATUS_CALIBRATION_ERROR;
  static constexpr Status STATUS_INTERNAL_ERROR =
    CameraCalibrationFeedbackResponse_Status_STATUS_INTERNAL_ERROR;
  static constexpr Status STATUS_CAMERA_FOCUS_ERROR =
    CameraCalibrationFeedbackResponse_Status_STATUS_CAMERA_FOCUS_ERROR;
  static constexpr Status STATUS_TARGET_NOT_CENTERED =
    CameraCalibrationFeedbackResponse_Status_STATUS_TARGET_NOT_CENTERED;
  static constexpr Status STATUS_TARGET_NOT_IN_VIEW =
    CameraCalibrationFeedbackResponse_Status_STATUS_TARGET_NOT_IN_VIEW;
  static constexpr Status STATUS_TARGET_NOT_GRAVITY_ALIGNED =
    CameraCalibrationFeedbackResponse_Status_STATUS_TARGET_NOT_GRAVITY_ALIGNED;
  static constexpr Status STATUS_TARGET_UPSIDE_DOWN =
    CameraCalibrationFeedbackResponse_Status_STATUS_TARGET_UPSIDE_DOWN;
  static constexpr Status STATUS_NEVER_RUN =
    CameraCalibrationFeedbackResponse_Status_STATUS_NEVER_RUN;
  static constexpr Status STATUS_CAMERA_NOT_DETECTED =
    CameraCalibrationFeedbackResponse_Status_STATUS_CAMERA_NOT_DETECTED;
  static constexpr Status STATUS_INTRINSIC_WRITE_FAILED =
    CameraCalibrationFeedbackResponse_Status_STATUS_INTRINSIC_WRITE_FAILED;
  static constexpr Status STATUS_EXTRINSIC_WRITE_FAILED =
    CameraCalibrationFeedbackResponse_Status_STATUS_EXTRINSIC_WRITE_FAILED;
  static constexpr Status STATUS_CALIBRATION_VERIFICATION_FAILED =
    CameraCalibrationFeedbackResponse_Status_STATUS_CALIBRATION_VERIFICATION_FAILED;
  static inline bool Status_IsValid(int value) {
    return CameraCalibrationFeedbackResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    CameraCalibrationFeedbackResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    CameraCalibrationFeedbackResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    CameraCalibrationFeedbackResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return CameraCalibrationFeedbackResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return CameraCalibrationFeedbackResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return CameraCalibrationFeedbackResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
    kProgressFieldNumber = 3,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot.CameraCalibrationFeedbackResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status status() const;
  void set_status(::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status value);
  private:
  ::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status value);
  public:

  // float progress = 3;
  void clear_progress();
  float progress() const;
  void set_progress(float value);
  private:
  float _internal_progress() const;
  void _internal_set_progress(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.CameraCalibrationFeedbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    float progress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SpotCheckCommandRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool SpotCheckCommandRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SpotCheckCommandRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& SpotCheckCommandRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& SpotCheckCommandRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckCommandRequest.header)
  return _internal_header();
}
inline void SpotCheckCommandRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SpotCheckCommandRequest.header)
}
inline ::bosdyn::api::RequestHeader* SpotCheckCommandRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* SpotCheckCommandRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckCommandRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* SpotCheckCommandRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* SpotCheckCommandRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckCommandRequest.header)
  return _msg;
}
inline void SpotCheckCommandRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckCommandRequest.header)
}

// .bosdyn.api.Lease lease = 2;
inline bool SpotCheckCommandRequest::_internal_has_lease() const {
  return this != internal_default_instance() && _impl_.lease_ != nullptr;
}
inline bool SpotCheckCommandRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& SpotCheckCommandRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = _impl_.lease_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Lease&>(
      ::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& SpotCheckCommandRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckCommandRequest.lease)
  return _internal_lease();
}
inline void SpotCheckCommandRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  _impl_.lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SpotCheckCommandRequest.lease)
}
inline ::bosdyn::api::Lease* SpotCheckCommandRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Lease* SpotCheckCommandRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckCommandRequest.lease)
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* SpotCheckCommandRequest::_internal_mutable_lease() {
  
  if (_impl_.lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArenaForAllocation());
    _impl_.lease_ = p;
  }
  return _impl_.lease_;
}
inline ::bosdyn::api::Lease* SpotCheckCommandRequest::mutable_lease() {
  ::bosdyn::api::Lease* _msg = _internal_mutable_lease();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckCommandRequest.lease)
  return _msg;
}
inline void SpotCheckCommandRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease));
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckCommandRequest.lease)
}

// .bosdyn.api.spot.SpotCheckCommandRequest.Command command = 3;
inline void SpotCheckCommandRequest::clear_command() {
  _impl_.command_ = 0;
}
inline ::bosdyn::api::spot::SpotCheckCommandRequest_Command SpotCheckCommandRequest::_internal_command() const {
  return static_cast< ::bosdyn::api::spot::SpotCheckCommandRequest_Command >(_impl_.command_);
}
inline ::bosdyn::api::spot::SpotCheckCommandRequest_Command SpotCheckCommandRequest::command() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckCommandRequest.command)
  return _internal_command();
}
inline void SpotCheckCommandRequest::_internal_set_command(::bosdyn::api::spot::SpotCheckCommandRequest_Command value) {
  
  _impl_.command_ = value;
}
inline void SpotCheckCommandRequest::set_command(::bosdyn::api::spot::SpotCheckCommandRequest_Command value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SpotCheckCommandRequest.command)
}

// -------------------------------------------------------------------

// SpotCheckCommandResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool SpotCheckCommandResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SpotCheckCommandResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& SpotCheckCommandResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& SpotCheckCommandResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckCommandResponse.header)
  return _internal_header();
}
inline void SpotCheckCommandResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SpotCheckCommandResponse.header)
}
inline ::bosdyn::api::ResponseHeader* SpotCheckCommandResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SpotCheckCommandResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckCommandResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SpotCheckCommandResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* SpotCheckCommandResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckCommandResponse.header)
  return _msg;
}
inline void SpotCheckCommandResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckCommandResponse.header)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool SpotCheckCommandResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && _impl_.lease_use_result_ != nullptr;
}
inline bool SpotCheckCommandResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& SpotCheckCommandResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = _impl_.lease_use_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::LeaseUseResult&>(
      ::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& SpotCheckCommandResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckCommandResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void SpotCheckCommandResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  _impl_.lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SpotCheckCommandResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* SpotCheckCommandResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* SpotCheckCommandResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckCommandResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* SpotCheckCommandResponse::_internal_mutable_lease_use_result() {
  
  if (_impl_.lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArenaForAllocation());
    _impl_.lease_use_result_ = p;
  }
  return _impl_.lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* SpotCheckCommandResponse::mutable_lease_use_result() {
  ::bosdyn::api::LeaseUseResult* _msg = _internal_mutable_lease_use_result();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckCommandResponse.lease_use_result)
  return _msg;
}
inline void SpotCheckCommandResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result));
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckCommandResponse.lease_use_result)
}

// .bosdyn.api.spot.SpotCheckCommandResponse.Status status = 3;
inline void SpotCheckCommandResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::spot::SpotCheckCommandResponse_Status SpotCheckCommandResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::SpotCheckCommandResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::spot::SpotCheckCommandResponse_Status SpotCheckCommandResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckCommandResponse.status)
  return _internal_status();
}
inline void SpotCheckCommandResponse::_internal_set_status(::bosdyn::api::spot::SpotCheckCommandResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void SpotCheckCommandResponse::set_status(::bosdyn::api::spot::SpotCheckCommandResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SpotCheckCommandResponse.status)
}

// string message = 4;
inline void SpotCheckCommandResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& SpotCheckCommandResponse::message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckCommandResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpotCheckCommandResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SpotCheckCommandResponse.message)
}
inline std::string* SpotCheckCommandResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckCommandResponse.message)
  return _s;
}
inline const std::string& SpotCheckCommandResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void SpotCheckCommandResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotCheckCommandResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* SpotCheckCommandResponse::release_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckCommandResponse.message)
  return _impl_.message_.Release();
}
inline void SpotCheckCommandResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckCommandResponse.message)
}

// -------------------------------------------------------------------

// SpotCheckFeedbackRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool SpotCheckFeedbackRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SpotCheckFeedbackRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& SpotCheckFeedbackRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& SpotCheckFeedbackRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckFeedbackRequest.header)
  return _internal_header();
}
inline void SpotCheckFeedbackRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SpotCheckFeedbackRequest.header)
}
inline ::bosdyn::api::RequestHeader* SpotCheckFeedbackRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* SpotCheckFeedbackRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckFeedbackRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* SpotCheckFeedbackRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* SpotCheckFeedbackRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckFeedbackRequest.header)
  return _msg;
}
inline void SpotCheckFeedbackRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckFeedbackRequest.header)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SpotCheckFeedbackResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool SpotCheckFeedbackResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SpotCheckFeedbackResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& SpotCheckFeedbackResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& SpotCheckFeedbackResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckFeedbackResponse.header)
  return _internal_header();
}
inline void SpotCheckFeedbackResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SpotCheckFeedbackResponse.header)
}
inline ::bosdyn::api::ResponseHeader* SpotCheckFeedbackResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SpotCheckFeedbackResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckFeedbackResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SpotCheckFeedbackResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* SpotCheckFeedbackResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckFeedbackResponse.header)
  return _msg;
}
inline void SpotCheckFeedbackResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckFeedbackResponse.header)
}

// .bosdyn.api.spot.SpotCheckFeedbackResponse.State state = 2;
inline void SpotCheckFeedbackResponse::clear_state() {
  _impl_.state_ = 0;
}
inline ::bosdyn::api::spot::SpotCheckFeedbackResponse_State SpotCheckFeedbackResponse::_internal_state() const {
  return static_cast< ::bosdyn::api::spot::SpotCheckFeedbackResponse_State >(_impl_.state_);
}
inline ::bosdyn::api::spot::SpotCheckFeedbackResponse_State SpotCheckFeedbackResponse::state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckFeedbackResponse.state)
  return _internal_state();
}
inline void SpotCheckFeedbackResponse::_internal_set_state(::bosdyn::api::spot::SpotCheckFeedbackResponse_State value) {
  
  _impl_.state_ = value;
}
inline void SpotCheckFeedbackResponse::set_state(::bosdyn::api::spot::SpotCheckFeedbackResponse_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SpotCheckFeedbackResponse.state)
}

// .bosdyn.api.spot.SpotCheckCommandRequest.Command last_command = 12;
inline void SpotCheckFeedbackResponse::clear_last_command() {
  _impl_.last_command_ = 0;
}
inline ::bosdyn::api::spot::SpotCheckCommandRequest_Command SpotCheckFeedbackResponse::_internal_last_command() const {
  return static_cast< ::bosdyn::api::spot::SpotCheckCommandRequest_Command >(_impl_.last_command_);
}
inline ::bosdyn::api::spot::SpotCheckCommandRequest_Command SpotCheckFeedbackResponse::last_command() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckFeedbackResponse.last_command)
  return _internal_last_command();
}
inline void SpotCheckFeedbackResponse::_internal_set_last_command(::bosdyn::api::spot::SpotCheckCommandRequest_Command value) {
  
  _impl_.last_command_ = value;
}
inline void SpotCheckFeedbackResponse::set_last_command(::bosdyn::api::spot::SpotCheckCommandRequest_Command value) {
  _internal_set_last_command(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SpotCheckFeedbackResponse.last_command)
}

// .bosdyn.api.spot.SpotCheckFeedbackResponse.Error error = 6;
inline void SpotCheckFeedbackResponse::clear_error() {
  _impl_.error_ = 0;
}
inline ::bosdyn::api::spot::SpotCheckFeedbackResponse_Error SpotCheckFeedbackResponse::_internal_error() const {
  return static_cast< ::bosdyn::api::spot::SpotCheckFeedbackResponse_Error >(_impl_.error_);
}
inline ::bosdyn::api::spot::SpotCheckFeedbackResponse_Error SpotCheckFeedbackResponse::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckFeedbackResponse.error)
  return _internal_error();
}
inline void SpotCheckFeedbackResponse::_internal_set_error(::bosdyn::api::spot::SpotCheckFeedbackResponse_Error value) {
  
  _impl_.error_ = value;
}
inline void SpotCheckFeedbackResponse::set_error(::bosdyn::api::spot::SpotCheckFeedbackResponse_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SpotCheckFeedbackResponse.error)
}

// map<string, .bosdyn.api.spot.DepthPlaneSpotCheckResult> camera_results = 3;
inline int SpotCheckFeedbackResponse::_internal_camera_results_size() const {
  return _impl_.camera_results_.size();
}
inline int SpotCheckFeedbackResponse::camera_results_size() const {
  return _internal_camera_results_size();
}
inline void SpotCheckFeedbackResponse::clear_camera_results() {
  _impl_.camera_results_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult >&
SpotCheckFeedbackResponse::_internal_camera_results() const {
  return _impl_.camera_results_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult >&
SpotCheckFeedbackResponse::camera_results() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.spot.SpotCheckFeedbackResponse.camera_results)
  return _internal_camera_results();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult >*
SpotCheckFeedbackResponse::_internal_mutable_camera_results() {
  return _impl_.camera_results_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult >*
SpotCheckFeedbackResponse::mutable_camera_results() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.spot.SpotCheckFeedbackResponse.camera_results)
  return _internal_mutable_camera_results();
}

// map<string, .bosdyn.api.spot.LoadCellSpotCheckResult> load_cell_results = 4;
inline int SpotCheckFeedbackResponse::_internal_load_cell_results_size() const {
  return _impl_.load_cell_results_.size();
}
inline int SpotCheckFeedbackResponse::load_cell_results_size() const {
  return _internal_load_cell_results_size();
}
inline void SpotCheckFeedbackResponse::clear_load_cell_results() {
  _impl_.load_cell_results_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult >&
SpotCheckFeedbackResponse::_internal_load_cell_results() const {
  return _impl_.load_cell_results_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult >&
SpotCheckFeedbackResponse::load_cell_results() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.spot.SpotCheckFeedbackResponse.load_cell_results)
  return _internal_load_cell_results();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult >*
SpotCheckFeedbackResponse::_internal_mutable_load_cell_results() {
  return _impl_.load_cell_results_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult >*
SpotCheckFeedbackResponse::mutable_load_cell_results() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.spot.SpotCheckFeedbackResponse.load_cell_results)
  return _internal_mutable_load_cell_results();
}

// map<string, .bosdyn.api.spot.JointKinematicCheckResult> kinematic_cal_results = 5;
inline int SpotCheckFeedbackResponse::_internal_kinematic_cal_results_size() const {
  return _impl_.kinematic_cal_results_.size();
}
inline int SpotCheckFeedbackResponse::kinematic_cal_results_size() const {
  return _internal_kinematic_cal_results_size();
}
inline void SpotCheckFeedbackResponse::clear_kinematic_cal_results() {
  _impl_.kinematic_cal_results_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::JointKinematicCheckResult >&
SpotCheckFeedbackResponse::_internal_kinematic_cal_results() const {
  return _impl_.kinematic_cal_results_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::JointKinematicCheckResult >&
SpotCheckFeedbackResponse::kinematic_cal_results() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.spot.SpotCheckFeedbackResponse.kinematic_cal_results)
  return _internal_kinematic_cal_results();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::JointKinematicCheckResult >*
SpotCheckFeedbackResponse::_internal_mutable_kinematic_cal_results() {
  return _impl_.kinematic_cal_results_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::JointKinematicCheckResult >*
SpotCheckFeedbackResponse::mutable_kinematic_cal_results() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.spot.SpotCheckFeedbackResponse.kinematic_cal_results)
  return _internal_mutable_kinematic_cal_results();
}

// .bosdyn.api.spot.PayloadCheckResult payload_result = 8;
inline bool SpotCheckFeedbackResponse::_internal_has_payload_result() const {
  return this != internal_default_instance() && _impl_.payload_result_ != nullptr;
}
inline bool SpotCheckFeedbackResponse::has_payload_result() const {
  return _internal_has_payload_result();
}
inline void SpotCheckFeedbackResponse::clear_payload_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.payload_result_ != nullptr) {
    delete _impl_.payload_result_;
  }
  _impl_.payload_result_ = nullptr;
}
inline const ::bosdyn::api::spot::PayloadCheckResult& SpotCheckFeedbackResponse::_internal_payload_result() const {
  const ::bosdyn::api::spot::PayloadCheckResult* p = _impl_.payload_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::PayloadCheckResult&>(
      ::bosdyn::api::spot::_PayloadCheckResult_default_instance_);
}
inline const ::bosdyn::api::spot::PayloadCheckResult& SpotCheckFeedbackResponse::payload_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckFeedbackResponse.payload_result)
  return _internal_payload_result();
}
inline void SpotCheckFeedbackResponse::unsafe_arena_set_allocated_payload_result(
    ::bosdyn::api::spot::PayloadCheckResult* payload_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_result_);
  }
  _impl_.payload_result_ = payload_result;
  if (payload_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SpotCheckFeedbackResponse.payload_result)
}
inline ::bosdyn::api::spot::PayloadCheckResult* SpotCheckFeedbackResponse::release_payload_result() {
  
  ::bosdyn::api::spot::PayloadCheckResult* temp = _impl_.payload_result_;
  _impl_.payload_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::PayloadCheckResult* SpotCheckFeedbackResponse::unsafe_arena_release_payload_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckFeedbackResponse.payload_result)
  
  ::bosdyn::api::spot::PayloadCheckResult* temp = _impl_.payload_result_;
  _impl_.payload_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::PayloadCheckResult* SpotCheckFeedbackResponse::_internal_mutable_payload_result() {
  
  if (_impl_.payload_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::PayloadCheckResult>(GetArenaForAllocation());
    _impl_.payload_result_ = p;
  }
  return _impl_.payload_result_;
}
inline ::bosdyn::api::spot::PayloadCheckResult* SpotCheckFeedbackResponse::mutable_payload_result() {
  ::bosdyn::api::spot::PayloadCheckResult* _msg = _internal_mutable_payload_result();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckFeedbackResponse.payload_result)
  return _msg;
}
inline void SpotCheckFeedbackResponse::set_allocated_payload_result(::bosdyn::api::spot::PayloadCheckResult* payload_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_result_;
  }
  if (payload_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload_result);
    if (message_arena != submessage_arena) {
      payload_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.payload_result_ = payload_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckFeedbackResponse.payload_result)
}

// map<string, .bosdyn.api.spot.FootHeightCheckResult> foot_height_results = 10 [deprecated = true];
inline int SpotCheckFeedbackResponse::_internal_foot_height_results_size() const {
  return _impl_.foot_height_results_.size();
}
inline int SpotCheckFeedbackResponse::foot_height_results_size() const {
  return _internal_foot_height_results_size();
}
inline void SpotCheckFeedbackResponse::clear_foot_height_results() {
  _impl_.foot_height_results_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::FootHeightCheckResult >&
SpotCheckFeedbackResponse::_internal_foot_height_results() const {
  return _impl_.foot_height_results_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::FootHeightCheckResult >&
SpotCheckFeedbackResponse::foot_height_results() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.spot.SpotCheckFeedbackResponse.foot_height_results)
  return _internal_foot_height_results();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::FootHeightCheckResult >*
SpotCheckFeedbackResponse::_internal_mutable_foot_height_results() {
  return _impl_.foot_height_results_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::FootHeightCheckResult >*
SpotCheckFeedbackResponse::mutable_foot_height_results() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.spot.SpotCheckFeedbackResponse.foot_height_results)
  return _internal_mutable_foot_height_results();
}

// map<string, .bosdyn.api.spot.LegPairCheckResult> leg_pair_results = 11 [deprecated = true];
inline int SpotCheckFeedbackResponse::_internal_leg_pair_results_size() const {
  return _impl_.leg_pair_results_.size();
}
inline int SpotCheckFeedbackResponse::leg_pair_results_size() const {
  return _internal_leg_pair_results_size();
}
inline void SpotCheckFeedbackResponse::clear_leg_pair_results() {
  _impl_.leg_pair_results_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LegPairCheckResult >&
SpotCheckFeedbackResponse::_internal_leg_pair_results() const {
  return _impl_.leg_pair_results_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LegPairCheckResult >&
SpotCheckFeedbackResponse::leg_pair_results() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.spot.SpotCheckFeedbackResponse.leg_pair_results)
  return _internal_leg_pair_results();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LegPairCheckResult >*
SpotCheckFeedbackResponse::_internal_mutable_leg_pair_results() {
  return _impl_.leg_pair_results_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LegPairCheckResult >*
SpotCheckFeedbackResponse::mutable_leg_pair_results() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.spot.SpotCheckFeedbackResponse.leg_pair_results)
  return _internal_mutable_leg_pair_results();
}

// map<string, .bosdyn.api.spot.HipRangeOfMotionResult> hip_range_of_motion_results = 13;
inline int SpotCheckFeedbackResponse::_internal_hip_range_of_motion_results_size() const {
  return _impl_.hip_range_of_motion_results_.size();
}
inline int SpotCheckFeedbackResponse::hip_range_of_motion_results_size() const {
  return _internal_hip_range_of_motion_results_size();
}
inline void SpotCheckFeedbackResponse::clear_hip_range_of_motion_results() {
  _impl_.hip_range_of_motion_results_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::HipRangeOfMotionResult >&
SpotCheckFeedbackResponse::_internal_hip_range_of_motion_results() const {
  return _impl_.hip_range_of_motion_results_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::HipRangeOfMotionResult >&
SpotCheckFeedbackResponse::hip_range_of_motion_results() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.spot.SpotCheckFeedbackResponse.hip_range_of_motion_results)
  return _internal_hip_range_of_motion_results();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::HipRangeOfMotionResult >*
SpotCheckFeedbackResponse::_internal_mutable_hip_range_of_motion_results() {
  return _impl_.hip_range_of_motion_results_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::HipRangeOfMotionResult >*
SpotCheckFeedbackResponse::mutable_hip_range_of_motion_results() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.spot.SpotCheckFeedbackResponse.hip_range_of_motion_results)
  return _internal_mutable_hip_range_of_motion_results();
}

// float progress = 7;
inline void SpotCheckFeedbackResponse::clear_progress() {
  _impl_.progress_ = 0;
}
inline float SpotCheckFeedbackResponse::_internal_progress() const {
  return _impl_.progress_;
}
inline float SpotCheckFeedbackResponse::progress() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckFeedbackResponse.progress)
  return _internal_progress();
}
inline void SpotCheckFeedbackResponse::_internal_set_progress(float value) {
  
  _impl_.progress_ = value;
}
inline void SpotCheckFeedbackResponse::set_progress(float value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SpotCheckFeedbackResponse.progress)
}

// .google.protobuf.Timestamp last_cal_timestamp = 9;
inline bool SpotCheckFeedbackResponse::_internal_has_last_cal_timestamp() const {
  return this != internal_default_instance() && _impl_.last_cal_timestamp_ != nullptr;
}
inline bool SpotCheckFeedbackResponse::has_last_cal_timestamp() const {
  return _internal_has_last_cal_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SpotCheckFeedbackResponse::_internal_last_cal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_cal_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SpotCheckFeedbackResponse::last_cal_timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckFeedbackResponse.last_cal_timestamp)
  return _internal_last_cal_timestamp();
}
inline void SpotCheckFeedbackResponse::unsafe_arena_set_allocated_last_cal_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_cal_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_cal_timestamp_);
  }
  _impl_.last_cal_timestamp_ = last_cal_timestamp;
  if (last_cal_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SpotCheckFeedbackResponse.last_cal_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpotCheckFeedbackResponse::release_last_cal_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_cal_timestamp_;
  _impl_.last_cal_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpotCheckFeedbackResponse::unsafe_arena_release_last_cal_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckFeedbackResponse.last_cal_timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_cal_timestamp_;
  _impl_.last_cal_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpotCheckFeedbackResponse::_internal_mutable_last_cal_timestamp() {
  
  if (_impl_.last_cal_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_cal_timestamp_ = p;
  }
  return _impl_.last_cal_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpotCheckFeedbackResponse::mutable_last_cal_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_cal_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckFeedbackResponse.last_cal_timestamp)
  return _msg;
}
inline void SpotCheckFeedbackResponse::set_allocated_last_cal_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* last_cal_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_cal_timestamp_);
  }
  if (last_cal_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_cal_timestamp));
    if (message_arena != submessage_arena) {
      last_cal_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_cal_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_cal_timestamp_ = last_cal_timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckFeedbackResponse.last_cal_timestamp)
}

// -------------------------------------------------------------------

// DepthPlaneSpotCheckResult

// .bosdyn.api.spot.DepthPlaneSpotCheckResult.Status status = 1;
inline void DepthPlaneSpotCheckResult::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status DepthPlaneSpotCheckResult::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status >(_impl_.status_);
}
inline ::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status DepthPlaneSpotCheckResult::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DepthPlaneSpotCheckResult.status)
  return _internal_status();
}
inline void DepthPlaneSpotCheckResult::_internal_set_status(::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status value) {
  
  _impl_.status_ = value;
}
inline void DepthPlaneSpotCheckResult::set_status(::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DepthPlaneSpotCheckResult.status)
}

// float severity_score = 2;
inline void DepthPlaneSpotCheckResult::clear_severity_score() {
  _impl_.severity_score_ = 0;
}
inline float DepthPlaneSpotCheckResult::_internal_severity_score() const {
  return _impl_.severity_score_;
}
inline float DepthPlaneSpotCheckResult::severity_score() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DepthPlaneSpotCheckResult.severity_score)
  return _internal_severity_score();
}
inline void DepthPlaneSpotCheckResult::_internal_set_severity_score(float value) {
  
  _impl_.severity_score_ = value;
}
inline void DepthPlaneSpotCheckResult::set_severity_score(float value) {
  _internal_set_severity_score(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DepthPlaneSpotCheckResult.severity_score)
}

// -------------------------------------------------------------------

// PayloadCheckResult

// .bosdyn.api.spot.PayloadCheckResult.Error error = 1;
inline void PayloadCheckResult::clear_error() {
  _impl_.error_ = 0;
}
inline ::bosdyn::api::spot::PayloadCheckResult_Error PayloadCheckResult::_internal_error() const {
  return static_cast< ::bosdyn::api::spot::PayloadCheckResult_Error >(_impl_.error_);
}
inline ::bosdyn::api::spot::PayloadCheckResult_Error PayloadCheckResult::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.PayloadCheckResult.error)
  return _internal_error();
}
inline void PayloadCheckResult::_internal_set_error(::bosdyn::api::spot::PayloadCheckResult_Error value) {
  
  _impl_.error_ = value;
}
inline void PayloadCheckResult::set_error(::bosdyn::api::spot::PayloadCheckResult_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.PayloadCheckResult.error)
}

// float extra_payload = 2;
inline void PayloadCheckResult::clear_extra_payload() {
  _impl_.extra_payload_ = 0;
}
inline float PayloadCheckResult::_internal_extra_payload() const {
  return _impl_.extra_payload_;
}
inline float PayloadCheckResult::extra_payload() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.PayloadCheckResult.extra_payload)
  return _internal_extra_payload();
}
inline void PayloadCheckResult::_internal_set_extra_payload(float value) {
  
  _impl_.extra_payload_ = value;
}
inline void PayloadCheckResult::set_extra_payload(float value) {
  _internal_set_extra_payload(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.PayloadCheckResult.extra_payload)
}

// -------------------------------------------------------------------

// LoadCellSpotCheckResult

// .bosdyn.api.spot.LoadCellSpotCheckResult.Error error = 2;
inline void LoadCellSpotCheckResult::clear_error() {
  _impl_.error_ = 0;
}
inline ::bosdyn::api::spot::LoadCellSpotCheckResult_Error LoadCellSpotCheckResult::_internal_error() const {
  return static_cast< ::bosdyn::api::spot::LoadCellSpotCheckResult_Error >(_impl_.error_);
}
inline ::bosdyn::api::spot::LoadCellSpotCheckResult_Error LoadCellSpotCheckResult::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoadCellSpotCheckResult.error)
  return _internal_error();
}
inline void LoadCellSpotCheckResult::_internal_set_error(::bosdyn::api::spot::LoadCellSpotCheckResult_Error value) {
  
  _impl_.error_ = value;
}
inline void LoadCellSpotCheckResult::set_error(::bosdyn::api::spot::LoadCellSpotCheckResult_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LoadCellSpotCheckResult.error)
}

// float zero = 3;
inline void LoadCellSpotCheckResult::clear_zero() {
  _impl_.zero_ = 0;
}
inline float LoadCellSpotCheckResult::_internal_zero() const {
  return _impl_.zero_;
}
inline float LoadCellSpotCheckResult::zero() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoadCellSpotCheckResult.zero)
  return _internal_zero();
}
inline void LoadCellSpotCheckResult::_internal_set_zero(float value) {
  
  _impl_.zero_ = value;
}
inline void LoadCellSpotCheckResult::set_zero(float value) {
  _internal_set_zero(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LoadCellSpotCheckResult.zero)
}

// float old_zero = 4;
inline void LoadCellSpotCheckResult::clear_old_zero() {
  _impl_.old_zero_ = 0;
}
inline float LoadCellSpotCheckResult::_internal_old_zero() const {
  return _impl_.old_zero_;
}
inline float LoadCellSpotCheckResult::old_zero() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoadCellSpotCheckResult.old_zero)
  return _internal_old_zero();
}
inline void LoadCellSpotCheckResult::_internal_set_old_zero(float value) {
  
  _impl_.old_zero_ = value;
}
inline void LoadCellSpotCheckResult::set_old_zero(float value) {
  _internal_set_old_zero(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LoadCellSpotCheckResult.old_zero)
}

// -------------------------------------------------------------------

// JointKinematicCheckResult

// .bosdyn.api.spot.JointKinematicCheckResult.Error error = 2;
inline void JointKinematicCheckResult::clear_error() {
  _impl_.error_ = 0;
}
inline ::bosdyn::api::spot::JointKinematicCheckResult_Error JointKinematicCheckResult::_internal_error() const {
  return static_cast< ::bosdyn::api::spot::JointKinematicCheckResult_Error >(_impl_.error_);
}
inline ::bosdyn::api::spot::JointKinematicCheckResult_Error JointKinematicCheckResult::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.JointKinematicCheckResult.error)
  return _internal_error();
}
inline void JointKinematicCheckResult::_internal_set_error(::bosdyn::api::spot::JointKinematicCheckResult_Error value) {
  
  _impl_.error_ = value;
}
inline void JointKinematicCheckResult::set_error(::bosdyn::api::spot::JointKinematicCheckResult_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.JointKinematicCheckResult.error)
}

// float offset = 3;
inline void JointKinematicCheckResult::clear_offset() {
  _impl_.offset_ = 0;
}
inline float JointKinematicCheckResult::_internal_offset() const {
  return _impl_.offset_;
}
inline float JointKinematicCheckResult::offset() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.JointKinematicCheckResult.offset)
  return _internal_offset();
}
inline void JointKinematicCheckResult::_internal_set_offset(float value) {
  
  _impl_.offset_ = value;
}
inline void JointKinematicCheckResult::set_offset(float value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.JointKinematicCheckResult.offset)
}

// float old_offset = 4;
inline void JointKinematicCheckResult::clear_old_offset() {
  _impl_.old_offset_ = 0;
}
inline float JointKinematicCheckResult::_internal_old_offset() const {
  return _impl_.old_offset_;
}
inline float JointKinematicCheckResult::old_offset() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.JointKinematicCheckResult.old_offset)
  return _internal_old_offset();
}
inline void JointKinematicCheckResult::_internal_set_old_offset(float value) {
  
  _impl_.old_offset_ = value;
}
inline void JointKinematicCheckResult::set_old_offset(float value) {
  _internal_set_old_offset(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.JointKinematicCheckResult.old_offset)
}

// float health_score = 5;
inline void JointKinematicCheckResult::clear_health_score() {
  _impl_.health_score_ = 0;
}
inline float JointKinematicCheckResult::_internal_health_score() const {
  return _impl_.health_score_;
}
inline float JointKinematicCheckResult::health_score() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.JointKinematicCheckResult.health_score)
  return _internal_health_score();
}
inline void JointKinematicCheckResult::_internal_set_health_score(float value) {
  
  _impl_.health_score_ = value;
}
inline void JointKinematicCheckResult::set_health_score(float value) {
  _internal_set_health_score(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.JointKinematicCheckResult.health_score)
}

// -------------------------------------------------------------------

// FootHeightCheckResult

// .bosdyn.api.spot.FootHeightCheckResult.Status status = 2;
inline void FootHeightCheckResult::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::spot::FootHeightCheckResult_Status FootHeightCheckResult::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::FootHeightCheckResult_Status >(_impl_.status_);
}
inline ::bosdyn::api::spot::FootHeightCheckResult_Status FootHeightCheckResult::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.FootHeightCheckResult.status)
  return _internal_status();
}
inline void FootHeightCheckResult::_internal_set_status(::bosdyn::api::spot::FootHeightCheckResult_Status value) {
  
  _impl_.status_ = value;
}
inline void FootHeightCheckResult::set_status(::bosdyn::api::spot::FootHeightCheckResult_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.FootHeightCheckResult.status)
}

// float foot_height_error_from_mean = 3;
inline void FootHeightCheckResult::clear_foot_height_error_from_mean() {
  _impl_.foot_height_error_from_mean_ = 0;
}
inline float FootHeightCheckResult::_internal_foot_height_error_from_mean() const {
  return _impl_.foot_height_error_from_mean_;
}
inline float FootHeightCheckResult::foot_height_error_from_mean() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.FootHeightCheckResult.foot_height_error_from_mean)
  return _internal_foot_height_error_from_mean();
}
inline void FootHeightCheckResult::_internal_set_foot_height_error_from_mean(float value) {
  
  _impl_.foot_height_error_from_mean_ = value;
}
inline void FootHeightCheckResult::set_foot_height_error_from_mean(float value) {
  _internal_set_foot_height_error_from_mean(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.FootHeightCheckResult.foot_height_error_from_mean)
}

// -------------------------------------------------------------------

// LegPairCheckResult

// .bosdyn.api.spot.LegPairCheckResult.Status status = 2;
inline void LegPairCheckResult::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::spot::LegPairCheckResult_Status LegPairCheckResult::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::LegPairCheckResult_Status >(_impl_.status_);
}
inline ::bosdyn::api::spot::LegPairCheckResult_Status LegPairCheckResult::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LegPairCheckResult.status)
  return _internal_status();
}
inline void LegPairCheckResult::_internal_set_status(::bosdyn::api::spot::LegPairCheckResult_Status value) {
  
  _impl_.status_ = value;
}
inline void LegPairCheckResult::set_status(::bosdyn::api::spot::LegPairCheckResult_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LegPairCheckResult.status)
}

// float leg_pair_distance_change = 3;
inline void LegPairCheckResult::clear_leg_pair_distance_change() {
  _impl_.leg_pair_distance_change_ = 0;
}
inline float LegPairCheckResult::_internal_leg_pair_distance_change() const {
  return _impl_.leg_pair_distance_change_;
}
inline float LegPairCheckResult::leg_pair_distance_change() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LegPairCheckResult.leg_pair_distance_change)
  return _internal_leg_pair_distance_change();
}
inline void LegPairCheckResult::_internal_set_leg_pair_distance_change(float value) {
  
  _impl_.leg_pair_distance_change_ = value;
}
inline void LegPairCheckResult::set_leg_pair_distance_change(float value) {
  _internal_set_leg_pair_distance_change(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LegPairCheckResult.leg_pair_distance_change)
}

// -------------------------------------------------------------------

// HipRangeOfMotionResult

// .bosdyn.api.spot.HipRangeOfMotionResult.Error error = 1;
inline void HipRangeOfMotionResult::clear_error() {
  _impl_.error_ = 0;
}
inline ::bosdyn::api::spot::HipRangeOfMotionResult_Error HipRangeOfMotionResult::_internal_error() const {
  return static_cast< ::bosdyn::api::spot::HipRangeOfMotionResult_Error >(_impl_.error_);
}
inline ::bosdyn::api::spot::HipRangeOfMotionResult_Error HipRangeOfMotionResult::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.HipRangeOfMotionResult.error)
  return _internal_error();
}
inline void HipRangeOfMotionResult::_internal_set_error(::bosdyn::api::spot::HipRangeOfMotionResult_Error value) {
  
  _impl_.error_ = value;
}
inline void HipRangeOfMotionResult::set_error(::bosdyn::api::spot::HipRangeOfMotionResult_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.HipRangeOfMotionResult.error)
}

// repeated float hx = 2;
inline int HipRangeOfMotionResult::_internal_hx_size() const {
  return _impl_.hx_.size();
}
inline int HipRangeOfMotionResult::hx_size() const {
  return _internal_hx_size();
}
inline void HipRangeOfMotionResult::clear_hx() {
  _impl_.hx_.Clear();
}
inline float HipRangeOfMotionResult::_internal_hx(int index) const {
  return _impl_.hx_.Get(index);
}
inline float HipRangeOfMotionResult::hx(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.HipRangeOfMotionResult.hx)
  return _internal_hx(index);
}
inline void HipRangeOfMotionResult::set_hx(int index, float value) {
  _impl_.hx_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.HipRangeOfMotionResult.hx)
}
inline void HipRangeOfMotionResult::_internal_add_hx(float value) {
  _impl_.hx_.Add(value);
}
inline void HipRangeOfMotionResult::add_hx(float value) {
  _internal_add_hx(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.HipRangeOfMotionResult.hx)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
HipRangeOfMotionResult::_internal_hx() const {
  return _impl_.hx_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
HipRangeOfMotionResult::hx() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.HipRangeOfMotionResult.hx)
  return _internal_hx();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
HipRangeOfMotionResult::_internal_mutable_hx() {
  return &_impl_.hx_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
HipRangeOfMotionResult::mutable_hx() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.HipRangeOfMotionResult.hx)
  return _internal_mutable_hx();
}

// repeated float hy = 3;
inline int HipRangeOfMotionResult::_internal_hy_size() const {
  return _impl_.hy_.size();
}
inline int HipRangeOfMotionResult::hy_size() const {
  return _internal_hy_size();
}
inline void HipRangeOfMotionResult::clear_hy() {
  _impl_.hy_.Clear();
}
inline float HipRangeOfMotionResult::_internal_hy(int index) const {
  return _impl_.hy_.Get(index);
}
inline float HipRangeOfMotionResult::hy(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.HipRangeOfMotionResult.hy)
  return _internal_hy(index);
}
inline void HipRangeOfMotionResult::set_hy(int index, float value) {
  _impl_.hy_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.HipRangeOfMotionResult.hy)
}
inline void HipRangeOfMotionResult::_internal_add_hy(float value) {
  _impl_.hy_.Add(value);
}
inline void HipRangeOfMotionResult::add_hy(float value) {
  _internal_add_hy(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.HipRangeOfMotionResult.hy)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
HipRangeOfMotionResult::_internal_hy() const {
  return _impl_.hy_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
HipRangeOfMotionResult::hy() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.HipRangeOfMotionResult.hy)
  return _internal_hy();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
HipRangeOfMotionResult::_internal_mutable_hy() {
  return &_impl_.hy_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
HipRangeOfMotionResult::mutable_hy() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.HipRangeOfMotionResult.hy)
  return _internal_mutable_hy();
}

// -------------------------------------------------------------------

// CameraCalibrationCommandRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool CameraCalibrationCommandRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool CameraCalibrationCommandRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& CameraCalibrationCommandRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& CameraCalibrationCommandRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationCommandRequest.header)
  return _internal_header();
}
inline void CameraCalibrationCommandRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.CameraCalibrationCommandRequest.header)
}
inline ::bosdyn::api::RequestHeader* CameraCalibrationCommandRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* CameraCalibrationCommandRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.CameraCalibrationCommandRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* CameraCalibrationCommandRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* CameraCalibrationCommandRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.CameraCalibrationCommandRequest.header)
  return _msg;
}
inline void CameraCalibrationCommandRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.CameraCalibrationCommandRequest.header)
}

// .bosdyn.api.Lease lease = 2;
inline bool CameraCalibrationCommandRequest::_internal_has_lease() const {
  return this != internal_default_instance() && _impl_.lease_ != nullptr;
}
inline bool CameraCalibrationCommandRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& CameraCalibrationCommandRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = _impl_.lease_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Lease&>(
      ::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& CameraCalibrationCommandRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationCommandRequest.lease)
  return _internal_lease();
}
inline void CameraCalibrationCommandRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  _impl_.lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.CameraCalibrationCommandRequest.lease)
}
inline ::bosdyn::api::Lease* CameraCalibrationCommandRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Lease* CameraCalibrationCommandRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.CameraCalibrationCommandRequest.lease)
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* CameraCalibrationCommandRequest::_internal_mutable_lease() {
  
  if (_impl_.lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArenaForAllocation());
    _impl_.lease_ = p;
  }
  return _impl_.lease_;
}
inline ::bosdyn::api::Lease* CameraCalibrationCommandRequest::mutable_lease() {
  ::bosdyn::api::Lease* _msg = _internal_mutable_lease();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.CameraCalibrationCommandRequest.lease)
  return _msg;
}
inline void CameraCalibrationCommandRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease));
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.CameraCalibrationCommandRequest.lease)
}

// .bosdyn.api.spot.CameraCalibrationCommandRequest.Command command = 3;
inline void CameraCalibrationCommandRequest::clear_command() {
  _impl_.command_ = 0;
}
inline ::bosdyn::api::spot::CameraCalibrationCommandRequest_Command CameraCalibrationCommandRequest::_internal_command() const {
  return static_cast< ::bosdyn::api::spot::CameraCalibrationCommandRequest_Command >(_impl_.command_);
}
inline ::bosdyn::api::spot::CameraCalibrationCommandRequest_Command CameraCalibrationCommandRequest::command() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationCommandRequest.command)
  return _internal_command();
}
inline void CameraCalibrationCommandRequest::_internal_set_command(::bosdyn::api::spot::CameraCalibrationCommandRequest_Command value) {
  
  _impl_.command_ = value;
}
inline void CameraCalibrationCommandRequest::set_command(::bosdyn::api::spot::CameraCalibrationCommandRequest_Command value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.CameraCalibrationCommandRequest.command)
}

// -------------------------------------------------------------------

// CameraCalibrationCommandResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool CameraCalibrationCommandResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool CameraCalibrationCommandResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& CameraCalibrationCommandResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& CameraCalibrationCommandResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationCommandResponse.header)
  return _internal_header();
}
inline void CameraCalibrationCommandResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.CameraCalibrationCommandResponse.header)
}
inline ::bosdyn::api::ResponseHeader* CameraCalibrationCommandResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* CameraCalibrationCommandResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.CameraCalibrationCommandResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* CameraCalibrationCommandResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* CameraCalibrationCommandResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.CameraCalibrationCommandResponse.header)
  return _msg;
}
inline void CameraCalibrationCommandResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.CameraCalibrationCommandResponse.header)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool CameraCalibrationCommandResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && _impl_.lease_use_result_ != nullptr;
}
inline bool CameraCalibrationCommandResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& CameraCalibrationCommandResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = _impl_.lease_use_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::LeaseUseResult&>(
      ::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& CameraCalibrationCommandResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationCommandResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void CameraCalibrationCommandResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  _impl_.lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.CameraCalibrationCommandResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* CameraCalibrationCommandResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* CameraCalibrationCommandResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.CameraCalibrationCommandResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* CameraCalibrationCommandResponse::_internal_mutable_lease_use_result() {
  
  if (_impl_.lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArenaForAllocation());
    _impl_.lease_use_result_ = p;
  }
  return _impl_.lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* CameraCalibrationCommandResponse::mutable_lease_use_result() {
  ::bosdyn::api::LeaseUseResult* _msg = _internal_mutable_lease_use_result();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.CameraCalibrationCommandResponse.lease_use_result)
  return _msg;
}
inline void CameraCalibrationCommandResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result));
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.CameraCalibrationCommandResponse.lease_use_result)
}

// -------------------------------------------------------------------

// CameraCalibrationFeedbackRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool CameraCalibrationFeedbackRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool CameraCalibrationFeedbackRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& CameraCalibrationFeedbackRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& CameraCalibrationFeedbackRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationFeedbackRequest.header)
  return _internal_header();
}
inline void CameraCalibrationFeedbackRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.CameraCalibrationFeedbackRequest.header)
}
inline ::bosdyn::api::RequestHeader* CameraCalibrationFeedbackRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* CameraCalibrationFeedbackRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.CameraCalibrationFeedbackRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* CameraCalibrationFeedbackRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* CameraCalibrationFeedbackRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.CameraCalibrationFeedbackRequest.header)
  return _msg;
}
inline void CameraCalibrationFeedbackRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.CameraCalibrationFeedbackRequest.header)
}

// -------------------------------------------------------------------

// CameraCalibrationFeedbackResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool CameraCalibrationFeedbackResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool CameraCalibrationFeedbackResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& CameraCalibrationFeedbackResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& CameraCalibrationFeedbackResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationFeedbackResponse.header)
  return _internal_header();
}
inline void CameraCalibrationFeedbackResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.CameraCalibrationFeedbackResponse.header)
}
inline ::bosdyn::api::ResponseHeader* CameraCalibrationFeedbackResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* CameraCalibrationFeedbackResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.CameraCalibrationFeedbackResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* CameraCalibrationFeedbackResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* CameraCalibrationFeedbackResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.CameraCalibrationFeedbackResponse.header)
  return _msg;
}
inline void CameraCalibrationFeedbackResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.CameraCalibrationFeedbackResponse.header)
}

// .bosdyn.api.spot.CameraCalibrationFeedbackResponse.Status status = 2;
inline void CameraCalibrationFeedbackResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status CameraCalibrationFeedbackResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status CameraCalibrationFeedbackResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationFeedbackResponse.status)
  return _internal_status();
}
inline void CameraCalibrationFeedbackResponse::_internal_set_status(::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void CameraCalibrationFeedbackResponse::set_status(::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.CameraCalibrationFeedbackResponse.status)
}

// float progress = 3;
inline void CameraCalibrationFeedbackResponse::clear_progress() {
  _impl_.progress_ = 0;
}
inline float CameraCalibrationFeedbackResponse::_internal_progress() const {
  return _impl_.progress_;
}
inline float CameraCalibrationFeedbackResponse::progress() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationFeedbackResponse.progress)
  return _internal_progress();
}
inline void CameraCalibrationFeedbackResponse::_internal_set_progress(float value) {
  
  _impl_.progress_ = value;
}
inline void CameraCalibrationFeedbackResponse::set_progress(float value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.CameraCalibrationFeedbackResponse.progress)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace spot
}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::spot::SpotCheckCommandRequest_Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::SpotCheckCommandRequest_Command>() {
  return ::bosdyn::api::spot::SpotCheckCommandRequest_Command_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::SpotCheckCommandResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::SpotCheckCommandResponse_Status>() {
  return ::bosdyn::api::spot::SpotCheckCommandResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::SpotCheckFeedbackResponse_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::SpotCheckFeedbackResponse_State>() {
  return ::bosdyn::api::spot::SpotCheckFeedbackResponse_State_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::SpotCheckFeedbackResponse_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::SpotCheckFeedbackResponse_Error>() {
  return ::bosdyn::api::spot::SpotCheckFeedbackResponse_Error_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status>() {
  return ::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::PayloadCheckResult_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::PayloadCheckResult_Error>() {
  return ::bosdyn::api::spot::PayloadCheckResult_Error_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::LoadCellSpotCheckResult_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::LoadCellSpotCheckResult_Error>() {
  return ::bosdyn::api::spot::LoadCellSpotCheckResult_Error_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::JointKinematicCheckResult_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::JointKinematicCheckResult_Error>() {
  return ::bosdyn::api::spot::JointKinematicCheckResult_Error_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::FootHeightCheckResult_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::FootHeightCheckResult_Status>() {
  return ::bosdyn::api::spot::FootHeightCheckResult_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::LegPairCheckResult_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::LegPairCheckResult_Status>() {
  return ::bosdyn::api::spot::LegPairCheckResult_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::HipRangeOfMotionResult_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::HipRangeOfMotionResult_Error>() {
  return ::bosdyn::api::spot::HipRangeOfMotionResult_Error_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::CameraCalibrationCommandRequest_Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::CameraCalibrationCommandRequest_Command>() {
  return ::bosdyn::api::spot::CameraCalibrationCommandRequest_Command_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status>() {
  return ::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto
