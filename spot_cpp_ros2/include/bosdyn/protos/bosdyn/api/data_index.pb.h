// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/data_index.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fdata_5findex_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fdata_5findex_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/data_buffer.pb.h"
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/time_range.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fdata_5findex_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fdata_5findex_2eproto;
namespace bosdyn {
namespace api {
class BlobPage;
struct BlobPageDefaultTypeInternal;
extern BlobPageDefaultTypeInternal _BlobPage_default_instance_;
class BlobPages;
struct BlobPagesDefaultTypeInternal;
extern BlobPagesDefaultTypeInternal _BlobPages_default_instance_;
class BlobSpec;
struct BlobSpecDefaultTypeInternal;
extern BlobSpecDefaultTypeInternal _BlobSpec_default_instance_;
class DataBufferStatus;
struct DataBufferStatusDefaultTypeInternal;
extern DataBufferStatusDefaultTypeInternal _DataBufferStatus_default_instance_;
class DataIndex;
struct DataIndexDefaultTypeInternal;
extern DataIndexDefaultTypeInternal _DataIndex_default_instance_;
class DataQuery;
struct DataQueryDefaultTypeInternal;
extern DataQueryDefaultTypeInternal _DataQuery_default_instance_;
class DeleteDataPagesRequest;
struct DeleteDataPagesRequestDefaultTypeInternal;
extern DeleteDataPagesRequestDefaultTypeInternal _DeleteDataPagesRequest_default_instance_;
class DeleteDataPagesResponse;
struct DeleteDataPagesResponseDefaultTypeInternal;
extern DeleteDataPagesResponseDefaultTypeInternal _DeleteDataPagesResponse_default_instance_;
class DeletePageStatus;
struct DeletePageStatusDefaultTypeInternal;
extern DeletePageStatusDefaultTypeInternal _DeletePageStatus_default_instance_;
class EventSpec;
struct EventSpecDefaultTypeInternal;
extern EventSpecDefaultTypeInternal _EventSpec_default_instance_;
class EventsComments;
struct EventsCommentsDefaultTypeInternal;
extern EventsCommentsDefaultTypeInternal _EventsComments_default_instance_;
class EventsCommentsSpec;
struct EventsCommentsSpecDefaultTypeInternal;
extern EventsCommentsSpecDefaultTypeInternal _EventsCommentsSpec_default_instance_;
class GetDataBufferStatusRequest;
struct GetDataBufferStatusRequestDefaultTypeInternal;
extern GetDataBufferStatusRequestDefaultTypeInternal _GetDataBufferStatusRequest_default_instance_;
class GetDataBufferStatusResponse;
struct GetDataBufferStatusResponseDefaultTypeInternal;
extern GetDataBufferStatusResponseDefaultTypeInternal _GetDataBufferStatusResponse_default_instance_;
class GetDataIndexRequest;
struct GetDataIndexRequestDefaultTypeInternal;
extern GetDataIndexRequestDefaultTypeInternal _GetDataIndexRequest_default_instance_;
class GetDataIndexResponse;
struct GetDataIndexResponseDefaultTypeInternal;
extern GetDataIndexResponseDefaultTypeInternal _GetDataIndexResponse_default_instance_;
class GetDataPagesRequest;
struct GetDataPagesRequestDefaultTypeInternal;
extern GetDataPagesRequestDefaultTypeInternal _GetDataPagesRequest_default_instance_;
class GetDataPagesResponse;
struct GetDataPagesResponseDefaultTypeInternal;
extern GetDataPagesResponseDefaultTypeInternal _GetDataPagesResponse_default_instance_;
class GetEventsCommentsRequest;
struct GetEventsCommentsRequestDefaultTypeInternal;
extern GetEventsCommentsRequestDefaultTypeInternal _GetEventsCommentsRequest_default_instance_;
class GetEventsCommentsResponse;
struct GetEventsCommentsResponseDefaultTypeInternal;
extern GetEventsCommentsResponseDefaultTypeInternal _GetEventsCommentsResponse_default_instance_;
class GrpcPages;
struct GrpcPagesDefaultTypeInternal;
extern GrpcPagesDefaultTypeInternal _GrpcPages_default_instance_;
class GrpcSpec;
struct GrpcSpecDefaultTypeInternal;
extern GrpcSpecDefaultTypeInternal _GrpcSpec_default_instance_;
class PageInfo;
struct PageInfoDefaultTypeInternal;
extern PageInfoDefaultTypeInternal _PageInfo_default_instance_;
class PagesAndTimestamp;
struct PagesAndTimestampDefaultTypeInternal;
extern PagesAndTimestampDefaultTypeInternal _PagesAndTimestamp_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::BlobPage* Arena::CreateMaybeMessage<::bosdyn::api::BlobPage>(Arena*);
template<> ::bosdyn::api::BlobPages* Arena::CreateMaybeMessage<::bosdyn::api::BlobPages>(Arena*);
template<> ::bosdyn::api::BlobSpec* Arena::CreateMaybeMessage<::bosdyn::api::BlobSpec>(Arena*);
template<> ::bosdyn::api::DataBufferStatus* Arena::CreateMaybeMessage<::bosdyn::api::DataBufferStatus>(Arena*);
template<> ::bosdyn::api::DataIndex* Arena::CreateMaybeMessage<::bosdyn::api::DataIndex>(Arena*);
template<> ::bosdyn::api::DataQuery* Arena::CreateMaybeMessage<::bosdyn::api::DataQuery>(Arena*);
template<> ::bosdyn::api::DeleteDataPagesRequest* Arena::CreateMaybeMessage<::bosdyn::api::DeleteDataPagesRequest>(Arena*);
template<> ::bosdyn::api::DeleteDataPagesResponse* Arena::CreateMaybeMessage<::bosdyn::api::DeleteDataPagesResponse>(Arena*);
template<> ::bosdyn::api::DeletePageStatus* Arena::CreateMaybeMessage<::bosdyn::api::DeletePageStatus>(Arena*);
template<> ::bosdyn::api::EventSpec* Arena::CreateMaybeMessage<::bosdyn::api::EventSpec>(Arena*);
template<> ::bosdyn::api::EventsComments* Arena::CreateMaybeMessage<::bosdyn::api::EventsComments>(Arena*);
template<> ::bosdyn::api::EventsCommentsSpec* Arena::CreateMaybeMessage<::bosdyn::api::EventsCommentsSpec>(Arena*);
template<> ::bosdyn::api::GetDataBufferStatusRequest* Arena::CreateMaybeMessage<::bosdyn::api::GetDataBufferStatusRequest>(Arena*);
template<> ::bosdyn::api::GetDataBufferStatusResponse* Arena::CreateMaybeMessage<::bosdyn::api::GetDataBufferStatusResponse>(Arena*);
template<> ::bosdyn::api::GetDataIndexRequest* Arena::CreateMaybeMessage<::bosdyn::api::GetDataIndexRequest>(Arena*);
template<> ::bosdyn::api::GetDataIndexResponse* Arena::CreateMaybeMessage<::bosdyn::api::GetDataIndexResponse>(Arena*);
template<> ::bosdyn::api::GetDataPagesRequest* Arena::CreateMaybeMessage<::bosdyn::api::GetDataPagesRequest>(Arena*);
template<> ::bosdyn::api::GetDataPagesResponse* Arena::CreateMaybeMessage<::bosdyn::api::GetDataPagesResponse>(Arena*);
template<> ::bosdyn::api::GetEventsCommentsRequest* Arena::CreateMaybeMessage<::bosdyn::api::GetEventsCommentsRequest>(Arena*);
template<> ::bosdyn::api::GetEventsCommentsResponse* Arena::CreateMaybeMessage<::bosdyn::api::GetEventsCommentsResponse>(Arena*);
template<> ::bosdyn::api::GrpcPages* Arena::CreateMaybeMessage<::bosdyn::api::GrpcPages>(Arena*);
template<> ::bosdyn::api::GrpcSpec* Arena::CreateMaybeMessage<::bosdyn::api::GrpcSpec>(Arena*);
template<> ::bosdyn::api::PageInfo* Arena::CreateMaybeMessage<::bosdyn::api::PageInfo>(Arena*);
template<> ::bosdyn::api::PagesAndTimestamp* Arena::CreateMaybeMessage<::bosdyn::api::PagesAndTimestamp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum PageInfo_PageFormat : int {
  PageInfo_PageFormat_FORMAT_UNKNOWN = 0,
  PageInfo_PageFormat_FORMAT_BDDF_FILE = 1,
  PageInfo_PageFormat_PageInfo_PageFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PageInfo_PageFormat_PageInfo_PageFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PageInfo_PageFormat_IsValid(int value);
constexpr PageInfo_PageFormat PageInfo_PageFormat_PageFormat_MIN = PageInfo_PageFormat_FORMAT_UNKNOWN;
constexpr PageInfo_PageFormat PageInfo_PageFormat_PageFormat_MAX = PageInfo_PageFormat_FORMAT_BDDF_FILE;
constexpr int PageInfo_PageFormat_PageFormat_ARRAYSIZE = PageInfo_PageFormat_PageFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PageInfo_PageFormat_descriptor();
template<typename T>
inline const std::string& PageInfo_PageFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PageInfo_PageFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PageInfo_PageFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PageInfo_PageFormat_descriptor(), enum_t_value);
}
inline bool PageInfo_PageFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PageInfo_PageFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PageInfo_PageFormat>(
    PageInfo_PageFormat_descriptor(), name, value);
}
enum PageInfo_Compression : int {
  PageInfo_Compression_COMPRESSION_UNKNOWN = 0,
  PageInfo_Compression_COMPRESSION_NONE = 1,
  PageInfo_Compression_COMPRESSION_GZIP = 2,
  PageInfo_Compression_COMPRESSION_ZSTD = 3,
  PageInfo_Compression_PageInfo_Compression_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PageInfo_Compression_PageInfo_Compression_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PageInfo_Compression_IsValid(int value);
constexpr PageInfo_Compression PageInfo_Compression_Compression_MIN = PageInfo_Compression_COMPRESSION_UNKNOWN;
constexpr PageInfo_Compression PageInfo_Compression_Compression_MAX = PageInfo_Compression_COMPRESSION_ZSTD;
constexpr int PageInfo_Compression_Compression_ARRAYSIZE = PageInfo_Compression_Compression_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PageInfo_Compression_descriptor();
template<typename T>
inline const std::string& PageInfo_Compression_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PageInfo_Compression>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PageInfo_Compression_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PageInfo_Compression_descriptor(), enum_t_value);
}
inline bool PageInfo_Compression_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PageInfo_Compression* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PageInfo_Compression>(
    PageInfo_Compression_descriptor(), name, value);
}
enum DeletePageStatus_Status : int {
  DeletePageStatus_Status_STATUS_UNKNOWN = 0,
  DeletePageStatus_Status_STATUS_DELETED = 1,
  DeletePageStatus_Status_STATUS_DELETION_FAILED = 2,
  DeletePageStatus_Status_STATUS_NOT_FOUND = 3,
  DeletePageStatus_Status_DeletePageStatus_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DeletePageStatus_Status_DeletePageStatus_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DeletePageStatus_Status_IsValid(int value);
constexpr DeletePageStatus_Status DeletePageStatus_Status_Status_MIN = DeletePageStatus_Status_STATUS_UNKNOWN;
constexpr DeletePageStatus_Status DeletePageStatus_Status_Status_MAX = DeletePageStatus_Status_STATUS_NOT_FOUND;
constexpr int DeletePageStatus_Status_Status_ARRAYSIZE = DeletePageStatus_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeletePageStatus_Status_descriptor();
template<typename T>
inline const std::string& DeletePageStatus_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeletePageStatus_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeletePageStatus_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeletePageStatus_Status_descriptor(), enum_t_value);
}
inline bool DeletePageStatus_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeletePageStatus_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeletePageStatus_Status>(
    DeletePageStatus_Status_descriptor(), name, value);
}
// ===================================================================

class GrpcSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GrpcSpec) */ {
 public:
  inline GrpcSpec() : GrpcSpec(nullptr) {}
  ~GrpcSpec() override;
  explicit PROTOBUF_CONSTEXPR GrpcSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GrpcSpec(const GrpcSpec& from);
  GrpcSpec(GrpcSpec&& from) noexcept
    : GrpcSpec() {
    *this = ::std::move(from);
  }

  inline GrpcSpec& operator=(const GrpcSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrpcSpec& operator=(GrpcSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GrpcSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const GrpcSpec* internal_default_instance() {
    return reinterpret_cast<const GrpcSpec*>(
               &_GrpcSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GrpcSpec& a, GrpcSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(GrpcSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GrpcSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GrpcSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GrpcSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GrpcSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GrpcSpec& from) {
    GrpcSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrpcSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GrpcSpec";
  }
  protected:
  explicit GrpcSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.GrpcSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class BlobSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.BlobSpec) */ {
 public:
  inline BlobSpec() : BlobSpec(nullptr) {}
  ~BlobSpec() override;
  explicit PROTOBUF_CONSTEXPR BlobSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlobSpec(const BlobSpec& from);
  BlobSpec(BlobSpec&& from) noexcept
    : BlobSpec() {
    *this = ::std::move(from);
  }

  inline BlobSpec& operator=(const BlobSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlobSpec& operator=(BlobSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlobSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlobSpec* internal_default_instance() {
    return reinterpret_cast<const BlobSpec*>(
               &_BlobSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BlobSpec& a, BlobSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(BlobSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlobSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlobSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlobSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlobSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlobSpec& from) {
    BlobSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlobSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.BlobSpec";
  }
  protected:
  explicit BlobSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
    kMessageTypeFieldNumber = 2,
    kChannelFieldNumber = 3,
    kChannelGlobFieldNumber = 4,
  };
  // string source = 1;
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // string message_type = 2;
  void clear_message_type();
  const std::string& message_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_type();
  PROTOBUF_NODISCARD std::string* release_message_type();
  void set_allocated_message_type(std::string* message_type);
  private:
  const std::string& _internal_message_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_type(const std::string& value);
  std::string* _internal_mutable_message_type();
  public:

  // string channel = 3;
  void clear_channel();
  const std::string& channel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_channel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_channel();
  PROTOBUF_NODISCARD std::string* release_channel();
  void set_allocated_channel(std::string* channel);
  private:
  const std::string& _internal_channel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel(const std::string& value);
  std::string* _internal_mutable_channel();
  public:

  // string channel_glob = 4;
  void clear_channel_glob();
  const std::string& channel_glob() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_channel_glob(ArgT0&& arg0, ArgT... args);
  std::string* mutable_channel_glob();
  PROTOBUF_NODISCARD std::string* release_channel_glob();
  void set_allocated_channel_glob(std::string* channel_glob);
  private:
  const std::string& _internal_channel_glob() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_glob(const std::string& value);
  std::string* _internal_mutable_channel_glob();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.BlobSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_glob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class EventSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EventSpec) */ {
 public:
  inline EventSpec() : EventSpec(nullptr) {}
  ~EventSpec() override;
  explicit PROTOBUF_CONSTEXPR EventSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventSpec(const EventSpec& from);
  EventSpec(EventSpec&& from) noexcept
    : EventSpec() {
    *this = ::std::move(from);
  }

  inline EventSpec& operator=(const EventSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventSpec& operator=(EventSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventSpec* internal_default_instance() {
    return reinterpret_cast<const EventSpec*>(
               &_EventSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EventSpec& a, EventSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(EventSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventSpec& from) {
    EventSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EventSpec";
  }
  protected:
  explicit EventSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
    kTypeFieldNumber = 2,
    kLevelFieldNumber = 3,
    kLogPreserveHintFieldNumber = 4,
  };
  // string source = 1;
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // .google.protobuf.Int32Value level = 3;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  const ::PROTOBUF_NAMESPACE_ID::Int32Value& level() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Int32Value* release_level();
  ::PROTOBUF_NAMESPACE_ID::Int32Value* mutable_level();
  void set_allocated_level(::PROTOBUF_NAMESPACE_ID::Int32Value* level);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Int32Value& _internal_level() const;
  ::PROTOBUF_NAMESPACE_ID::Int32Value* _internal_mutable_level();
  public:
  void unsafe_arena_set_allocated_level(
      ::PROTOBUF_NAMESPACE_ID::Int32Value* level);
  ::PROTOBUF_NAMESPACE_ID::Int32Value* unsafe_arena_release_level();

  // .bosdyn.api.Event.LogPreserveHint log_preserve_hint = 4;
  void clear_log_preserve_hint();
  ::bosdyn::api::Event_LogPreserveHint log_preserve_hint() const;
  void set_log_preserve_hint(::bosdyn::api::Event_LogPreserveHint value);
  private:
  ::bosdyn::api::Event_LogPreserveHint _internal_log_preserve_hint() const;
  void _internal_set_log_preserve_hint(::bosdyn::api::Event_LogPreserveHint value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.EventSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::Int32Value* level_;
    int log_preserve_hint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class PageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PageInfo) */ {
 public:
  inline PageInfo() : PageInfo(nullptr) {}
  ~PageInfo() override;
  explicit PROTOBUF_CONSTEXPR PageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PageInfo(const PageInfo& from);
  PageInfo(PageInfo&& from) noexcept
    : PageInfo() {
    *this = ::std::move(from);
  }

  inline PageInfo& operator=(const PageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PageInfo& operator=(PageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PageInfo* internal_default_instance() {
    return reinterpret_cast<const PageInfo*>(
               &_PageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PageInfo& a, PageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PageInfo& from) {
    PageInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PageInfo";
  }
  protected:
  explicit PageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PageInfo_PageFormat PageFormat;
  static constexpr PageFormat FORMAT_UNKNOWN =
    PageInfo_PageFormat_FORMAT_UNKNOWN;
  static constexpr PageFormat FORMAT_BDDF_FILE =
    PageInfo_PageFormat_FORMAT_BDDF_FILE;
  static inline bool PageFormat_IsValid(int value) {
    return PageInfo_PageFormat_IsValid(value);
  }
  static constexpr PageFormat PageFormat_MIN =
    PageInfo_PageFormat_PageFormat_MIN;
  static constexpr PageFormat PageFormat_MAX =
    PageInfo_PageFormat_PageFormat_MAX;
  static constexpr int PageFormat_ARRAYSIZE =
    PageInfo_PageFormat_PageFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PageFormat_descriptor() {
    return PageInfo_PageFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& PageFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PageFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PageFormat_Name.");
    return PageInfo_PageFormat_Name(enum_t_value);
  }
  static inline bool PageFormat_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PageFormat* value) {
    return PageInfo_PageFormat_Parse(name, value);
  }

  typedef PageInfo_Compression Compression;
  static constexpr Compression COMPRESSION_UNKNOWN =
    PageInfo_Compression_COMPRESSION_UNKNOWN;
  static constexpr Compression COMPRESSION_NONE =
    PageInfo_Compression_COMPRESSION_NONE;
  static constexpr Compression COMPRESSION_GZIP =
    PageInfo_Compression_COMPRESSION_GZIP;
  static constexpr Compression COMPRESSION_ZSTD =
    PageInfo_Compression_COMPRESSION_ZSTD;
  static inline bool Compression_IsValid(int value) {
    return PageInfo_Compression_IsValid(value);
  }
  static constexpr Compression Compression_MIN =
    PageInfo_Compression_Compression_MIN;
  static constexpr Compression Compression_MAX =
    PageInfo_Compression_Compression_MAX;
  static constexpr int Compression_ARRAYSIZE =
    PageInfo_Compression_Compression_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Compression_descriptor() {
    return PageInfo_Compression_descriptor();
  }
  template<typename T>
  static inline const std::string& Compression_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Compression>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Compression_Name.");
    return PageInfo_Compression_Name(enum_t_value);
  }
  static inline bool Compression_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Compression* value) {
    return PageInfo_Compression_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPathFieldNumber = 2,
    kSourceFieldNumber = 3,
    kTimeRangeFieldNumber = 4,
    kDeletedTimestampFieldNumber = 11,
    kDownloadStartedTimestampFieldNumber = 12,
    kNumTicksFieldNumber = 5,
    kTotalBytesFieldNumber = 6,
    kFormatFieldNumber = 7,
    kCompressionFieldNumber = 8,
    kIsOpenFieldNumber = 9,
    kIsDownloadedFieldNumber = 10,
    kRequestPreserveFieldNumber = 13,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string source = 3;
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // .bosdyn.api.TimeRange time_range = 4;
  bool has_time_range() const;
  private:
  bool _internal_has_time_range() const;
  public:
  void clear_time_range();
  const ::bosdyn::api::TimeRange& time_range() const;
  PROTOBUF_NODISCARD ::bosdyn::api::TimeRange* release_time_range();
  ::bosdyn::api::TimeRange* mutable_time_range();
  void set_allocated_time_range(::bosdyn::api::TimeRange* time_range);
  private:
  const ::bosdyn::api::TimeRange& _internal_time_range() const;
  ::bosdyn::api::TimeRange* _internal_mutable_time_range();
  public:
  void unsafe_arena_set_allocated_time_range(
      ::bosdyn::api::TimeRange* time_range);
  ::bosdyn::api::TimeRange* unsafe_arena_release_time_range();

  // .google.protobuf.Timestamp deleted_timestamp = 11;
  bool has_deleted_timestamp() const;
  private:
  bool _internal_has_deleted_timestamp() const;
  public:
  void clear_deleted_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& deleted_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_deleted_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_deleted_timestamp();
  void set_allocated_deleted_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_deleted_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_deleted_timestamp();
  public:
  void unsafe_arena_set_allocated_deleted_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_deleted_timestamp();

  // .google.protobuf.Timestamp download_started_timestamp = 12;
  bool has_download_started_timestamp() const;
  private:
  bool _internal_has_download_started_timestamp() const;
  public:
  void clear_download_started_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& download_started_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_download_started_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_download_started_timestamp();
  void set_allocated_download_started_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* download_started_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_download_started_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_download_started_timestamp();
  public:
  void unsafe_arena_set_allocated_download_started_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* download_started_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_download_started_timestamp();

  // int64 num_ticks = 5;
  void clear_num_ticks();
  int64_t num_ticks() const;
  void set_num_ticks(int64_t value);
  private:
  int64_t _internal_num_ticks() const;
  void _internal_set_num_ticks(int64_t value);
  public:

  // int64 total_bytes = 6;
  void clear_total_bytes();
  int64_t total_bytes() const;
  void set_total_bytes(int64_t value);
  private:
  int64_t _internal_total_bytes() const;
  void _internal_set_total_bytes(int64_t value);
  public:

  // .bosdyn.api.PageInfo.PageFormat format = 7;
  void clear_format();
  ::bosdyn::api::PageInfo_PageFormat format() const;
  void set_format(::bosdyn::api::PageInfo_PageFormat value);
  private:
  ::bosdyn::api::PageInfo_PageFormat _internal_format() const;
  void _internal_set_format(::bosdyn::api::PageInfo_PageFormat value);
  public:

  // .bosdyn.api.PageInfo.Compression compression = 8;
  void clear_compression();
  ::bosdyn::api::PageInfo_Compression compression() const;
  void set_compression(::bosdyn::api::PageInfo_Compression value);
  private:
  ::bosdyn::api::PageInfo_Compression _internal_compression() const;
  void _internal_set_compression(::bosdyn::api::PageInfo_Compression value);
  public:

  // bool is_open = 9;
  void clear_is_open();
  bool is_open() const;
  void set_is_open(bool value);
  private:
  bool _internal_is_open() const;
  void _internal_set_is_open(bool value);
  public:

  // bool is_downloaded = 10;
  void clear_is_downloaded();
  bool is_downloaded() const;
  void set_is_downloaded(bool value);
  private:
  bool _internal_is_downloaded() const;
  void _internal_set_is_downloaded(bool value);
  public:

  // bool request_preserve = 13;
  void clear_request_preserve();
  bool request_preserve() const;
  void set_request_preserve(bool value);
  private:
  bool _internal_request_preserve() const;
  void _internal_set_request_preserve(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.PageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    ::bosdyn::api::TimeRange* time_range_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_timestamp_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* download_started_timestamp_;
    int64_t num_ticks_;
    int64_t total_bytes_;
    int format_;
    int compression_;
    bool is_open_;
    bool is_downloaded_;
    bool request_preserve_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class GrpcPages final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GrpcPages) */ {
 public:
  inline GrpcPages() : GrpcPages(nullptr) {}
  ~GrpcPages() override;
  explicit PROTOBUF_CONSTEXPR GrpcPages(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GrpcPages(const GrpcPages& from);
  GrpcPages(GrpcPages&& from) noexcept
    : GrpcPages() {
    *this = ::std::move(from);
  }

  inline GrpcPages& operator=(const GrpcPages& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrpcPages& operator=(GrpcPages&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GrpcPages& default_instance() {
    return *internal_default_instance();
  }
  static inline const GrpcPages* internal_default_instance() {
    return reinterpret_cast<const GrpcPages*>(
               &_GrpcPages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GrpcPages& a, GrpcPages& b) {
    a.Swap(&b);
  }
  inline void Swap(GrpcPages* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GrpcPages* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GrpcPages* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GrpcPages>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GrpcPages& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GrpcPages& from) {
    GrpcPages::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrpcPages* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GrpcPages";
  }
  protected:
  explicit GrpcPages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPagesFieldNumber = 3,
    kTimeRangeFieldNumber = 1,
    kSpecFieldNumber = 2,
  };
  // repeated .bosdyn.api.PageInfo pages = 3;
  int pages_size() const;
  private:
  int _internal_pages_size() const;
  public:
  void clear_pages();
  ::bosdyn::api::PageInfo* mutable_pages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PageInfo >*
      mutable_pages();
  private:
  const ::bosdyn::api::PageInfo& _internal_pages(int index) const;
  ::bosdyn::api::PageInfo* _internal_add_pages();
  public:
  const ::bosdyn::api::PageInfo& pages(int index) const;
  ::bosdyn::api::PageInfo* add_pages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PageInfo >&
      pages() const;

  // .bosdyn.api.TimeRange time_range = 1;
  bool has_time_range() const;
  private:
  bool _internal_has_time_range() const;
  public:
  void clear_time_range();
  const ::bosdyn::api::TimeRange& time_range() const;
  PROTOBUF_NODISCARD ::bosdyn::api::TimeRange* release_time_range();
  ::bosdyn::api::TimeRange* mutable_time_range();
  void set_allocated_time_range(::bosdyn::api::TimeRange* time_range);
  private:
  const ::bosdyn::api::TimeRange& _internal_time_range() const;
  ::bosdyn::api::TimeRange* _internal_mutable_time_range();
  public:
  void unsafe_arena_set_allocated_time_range(
      ::bosdyn::api::TimeRange* time_range);
  ::bosdyn::api::TimeRange* unsafe_arena_release_time_range();

  // .bosdyn.api.GrpcSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::bosdyn::api::GrpcSpec& spec() const;
  PROTOBUF_NODISCARD ::bosdyn::api::GrpcSpec* release_spec();
  ::bosdyn::api::GrpcSpec* mutable_spec();
  void set_allocated_spec(::bosdyn::api::GrpcSpec* spec);
  private:
  const ::bosdyn::api::GrpcSpec& _internal_spec() const;
  ::bosdyn::api::GrpcSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::bosdyn::api::GrpcSpec* spec);
  ::bosdyn::api::GrpcSpec* unsafe_arena_release_spec();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GrpcPages)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PageInfo > pages_;
    ::bosdyn::api::TimeRange* time_range_;
    ::bosdyn::api::GrpcSpec* spec_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class BlobPage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.BlobPage) */ {
 public:
  inline BlobPage() : BlobPage(nullptr) {}
  ~BlobPage() override;
  explicit PROTOBUF_CONSTEXPR BlobPage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlobPage(const BlobPage& from);
  BlobPage(BlobPage&& from) noexcept
    : BlobPage() {
    *this = ::std::move(from);
  }

  inline BlobPage& operator=(const BlobPage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlobPage& operator=(BlobPage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlobPage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlobPage* internal_default_instance() {
    return reinterpret_cast<const BlobPage*>(
               &_BlobPage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BlobPage& a, BlobPage& b) {
    a.Swap(&b);
  }
  inline void Swap(BlobPage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlobPage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlobPage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlobPage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlobPage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlobPage& from) {
    BlobPage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlobPage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.BlobPage";
  }
  protected:
  explicit BlobPage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecFieldNumber = 1,
    kPageFieldNumber = 2,
  };
  // .bosdyn.api.BlobSpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::bosdyn::api::BlobSpec& spec() const;
  PROTOBUF_NODISCARD ::bosdyn::api::BlobSpec* release_spec();
  ::bosdyn::api::BlobSpec* mutable_spec();
  void set_allocated_spec(::bosdyn::api::BlobSpec* spec);
  private:
  const ::bosdyn::api::BlobSpec& _internal_spec() const;
  ::bosdyn::api::BlobSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::bosdyn::api::BlobSpec* spec);
  ::bosdyn::api::BlobSpec* unsafe_arena_release_spec();

  // .bosdyn.api.PageInfo page = 2;
  bool has_page() const;
  private:
  bool _internal_has_page() const;
  public:
  void clear_page();
  const ::bosdyn::api::PageInfo& page() const;
  PROTOBUF_NODISCARD ::bosdyn::api::PageInfo* release_page();
  ::bosdyn::api::PageInfo* mutable_page();
  void set_allocated_page(::bosdyn::api::PageInfo* page);
  private:
  const ::bosdyn::api::PageInfo& _internal_page() const;
  ::bosdyn::api::PageInfo* _internal_mutable_page();
  public:
  void unsafe_arena_set_allocated_page(
      ::bosdyn::api::PageInfo* page);
  ::bosdyn::api::PageInfo* unsafe_arena_release_page();

  // @@protoc_insertion_point(class_scope:bosdyn.api.BlobPage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::BlobSpec* spec_;
    ::bosdyn::api::PageInfo* page_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class BlobPages final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.BlobPages) */ {
 public:
  inline BlobPages() : BlobPages(nullptr) {}
  ~BlobPages() override;
  explicit PROTOBUF_CONSTEXPR BlobPages(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlobPages(const BlobPages& from);
  BlobPages(BlobPages&& from) noexcept
    : BlobPages() {
    *this = ::std::move(from);
  }

  inline BlobPages& operator=(const BlobPages& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlobPages& operator=(BlobPages&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlobPages& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlobPages* internal_default_instance() {
    return reinterpret_cast<const BlobPages*>(
               &_BlobPages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BlobPages& a, BlobPages& b) {
    a.Swap(&b);
  }
  inline void Swap(BlobPages* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlobPages* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlobPages* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlobPages>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlobPages& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlobPages& from) {
    BlobPages::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlobPages* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.BlobPages";
  }
  protected:
  explicit BlobPages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPagesFieldNumber = 3,
    kTimeRangeFieldNumber = 1,
  };
  // repeated .bosdyn.api.BlobPage pages = 3;
  int pages_size() const;
  private:
  int _internal_pages_size() const;
  public:
  void clear_pages();
  ::bosdyn::api::BlobPage* mutable_pages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobPage >*
      mutable_pages();
  private:
  const ::bosdyn::api::BlobPage& _internal_pages(int index) const;
  ::bosdyn::api::BlobPage* _internal_add_pages();
  public:
  const ::bosdyn::api::BlobPage& pages(int index) const;
  ::bosdyn::api::BlobPage* add_pages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobPage >&
      pages() const;

  // .bosdyn.api.TimeRange time_range = 1;
  bool has_time_range() const;
  private:
  bool _internal_has_time_range() const;
  public:
  void clear_time_range();
  const ::bosdyn::api::TimeRange& time_range() const;
  PROTOBUF_NODISCARD ::bosdyn::api::TimeRange* release_time_range();
  ::bosdyn::api::TimeRange* mutable_time_range();
  void set_allocated_time_range(::bosdyn::api::TimeRange* time_range);
  private:
  const ::bosdyn::api::TimeRange& _internal_time_range() const;
  ::bosdyn::api::TimeRange* _internal_mutable_time_range();
  public:
  void unsafe_arena_set_allocated_time_range(
      ::bosdyn::api::TimeRange* time_range);
  ::bosdyn::api::TimeRange* unsafe_arena_release_time_range();

  // @@protoc_insertion_point(class_scope:bosdyn.api.BlobPages)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobPage > pages_;
    ::bosdyn::api::TimeRange* time_range_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class PagesAndTimestamp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PagesAndTimestamp) */ {
 public:
  inline PagesAndTimestamp() : PagesAndTimestamp(nullptr) {}
  ~PagesAndTimestamp() override;
  explicit PROTOBUF_CONSTEXPR PagesAndTimestamp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PagesAndTimestamp(const PagesAndTimestamp& from);
  PagesAndTimestamp(PagesAndTimestamp&& from) noexcept
    : PagesAndTimestamp() {
    *this = ::std::move(from);
  }

  inline PagesAndTimestamp& operator=(const PagesAndTimestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline PagesAndTimestamp& operator=(PagesAndTimestamp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PagesAndTimestamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const PagesAndTimestamp* internal_default_instance() {
    return reinterpret_cast<const PagesAndTimestamp*>(
               &_PagesAndTimestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PagesAndTimestamp& a, PagesAndTimestamp& b) {
    a.Swap(&b);
  }
  inline void Swap(PagesAndTimestamp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PagesAndTimestamp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PagesAndTimestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PagesAndTimestamp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PagesAndTimestamp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PagesAndTimestamp& from) {
    PagesAndTimestamp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PagesAndTimestamp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PagesAndTimestamp";
  }
  protected:
  explicit PagesAndTimestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPagesFieldNumber = 2,
    kTimeRangeFieldNumber = 1,
  };
  // repeated .bosdyn.api.PageInfo pages = 2;
  int pages_size() const;
  private:
  int _internal_pages_size() const;
  public:
  void clear_pages();
  ::bosdyn::api::PageInfo* mutable_pages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PageInfo >*
      mutable_pages();
  private:
  const ::bosdyn::api::PageInfo& _internal_pages(int index) const;
  ::bosdyn::api::PageInfo* _internal_add_pages();
  public:
  const ::bosdyn::api::PageInfo& pages(int index) const;
  ::bosdyn::api::PageInfo* add_pages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PageInfo >&
      pages() const;

  // .bosdyn.api.TimeRange time_range = 1;
  bool has_time_range() const;
  private:
  bool _internal_has_time_range() const;
  public:
  void clear_time_range();
  const ::bosdyn::api::TimeRange& time_range() const;
  PROTOBUF_NODISCARD ::bosdyn::api::TimeRange* release_time_range();
  ::bosdyn::api::TimeRange* mutable_time_range();
  void set_allocated_time_range(::bosdyn::api::TimeRange* time_range);
  private:
  const ::bosdyn::api::TimeRange& _internal_time_range() const;
  ::bosdyn::api::TimeRange* _internal_mutable_time_range();
  public:
  void unsafe_arena_set_allocated_time_range(
      ::bosdyn::api::TimeRange* time_range);
  ::bosdyn::api::TimeRange* unsafe_arena_release_time_range();

  // @@protoc_insertion_point(class_scope:bosdyn.api.PagesAndTimestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PageInfo > pages_;
    ::bosdyn::api::TimeRange* time_range_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class DataQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DataQuery) */ {
 public:
  inline DataQuery() : DataQuery(nullptr) {}
  ~DataQuery() override;
  explicit PROTOBUF_CONSTEXPR DataQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataQuery(const DataQuery& from);
  DataQuery(DataQuery&& from) noexcept
    : DataQuery() {
    *this = ::std::move(from);
  }

  inline DataQuery& operator=(const DataQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataQuery& operator=(DataQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataQuery* internal_default_instance() {
    return reinterpret_cast<const DataQuery*>(
               &_DataQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DataQuery& a, DataQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(DataQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataQuery& from) {
    DataQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DataQuery";
  }
  protected:
  explicit DataQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobsFieldNumber = 2,
    kTimeRangeFieldNumber = 1,
    kTextMessagesFieldNumber = 3,
    kEventsFieldNumber = 4,
    kCommentsFieldNumber = 6,
  };
  // repeated .bosdyn.api.BlobSpec blobs = 2;
  int blobs_size() const;
  private:
  int _internal_blobs_size() const;
  public:
  void clear_blobs();
  ::bosdyn::api::BlobSpec* mutable_blobs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobSpec >*
      mutable_blobs();
  private:
  const ::bosdyn::api::BlobSpec& _internal_blobs(int index) const;
  ::bosdyn::api::BlobSpec* _internal_add_blobs();
  public:
  const ::bosdyn::api::BlobSpec& blobs(int index) const;
  ::bosdyn::api::BlobSpec* add_blobs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobSpec >&
      blobs() const;

  // .bosdyn.api.TimeRange time_range = 1;
  bool has_time_range() const;
  private:
  bool _internal_has_time_range() const;
  public:
  void clear_time_range();
  const ::bosdyn::api::TimeRange& time_range() const;
  PROTOBUF_NODISCARD ::bosdyn::api::TimeRange* release_time_range();
  ::bosdyn::api::TimeRange* mutable_time_range();
  void set_allocated_time_range(::bosdyn::api::TimeRange* time_range);
  private:
  const ::bosdyn::api::TimeRange& _internal_time_range() const;
  ::bosdyn::api::TimeRange* _internal_mutable_time_range();
  public:
  void unsafe_arena_set_allocated_time_range(
      ::bosdyn::api::TimeRange* time_range);
  ::bosdyn::api::TimeRange* unsafe_arena_release_time_range();

  // bool text_messages = 3;
  void clear_text_messages();
  bool text_messages() const;
  void set_text_messages(bool value);
  private:
  bool _internal_text_messages() const;
  void _internal_set_text_messages(bool value);
  public:

  // bool events = 4;
  void clear_events();
  bool events() const;
  void set_events(bool value);
  private:
  bool _internal_events() const;
  void _internal_set_events(bool value);
  public:

  // bool comments = 6;
  void clear_comments();
  bool comments() const;
  void set_comments(bool value);
  private:
  bool _internal_comments() const;
  void _internal_set_comments(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.DataQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobSpec > blobs_;
    ::bosdyn::api::TimeRange* time_range_;
    bool text_messages_;
    bool events_;
    bool comments_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class DataIndex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DataIndex) */ {
 public:
  inline DataIndex() : DataIndex(nullptr) {}
  ~DataIndex() override;
  explicit PROTOBUF_CONSTEXPR DataIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataIndex(const DataIndex& from);
  DataIndex(DataIndex&& from) noexcept
    : DataIndex() {
    *this = ::std::move(from);
  }

  inline DataIndex& operator=(const DataIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataIndex& operator=(DataIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataIndex* internal_default_instance() {
    return reinterpret_cast<const DataIndex*>(
               &_DataIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DataIndex& a, DataIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(DataIndex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataIndex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataIndex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataIndex& from) {
    DataIndex::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataIndex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DataIndex";
  }
  protected:
  explicit DataIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobsFieldNumber = 2,
    kTimeRangeFieldNumber = 1,
    kTextMessagesFieldNumber = 3,
    kEventsFieldNumber = 4,
    kCommentsFieldNumber = 6,
  };
  // repeated .bosdyn.api.BlobPages blobs = 2;
  int blobs_size() const;
  private:
  int _internal_blobs_size() const;
  public:
  void clear_blobs();
  ::bosdyn::api::BlobPages* mutable_blobs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobPages >*
      mutable_blobs();
  private:
  const ::bosdyn::api::BlobPages& _internal_blobs(int index) const;
  ::bosdyn::api::BlobPages* _internal_add_blobs();
  public:
  const ::bosdyn::api::BlobPages& blobs(int index) const;
  ::bosdyn::api::BlobPages* add_blobs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobPages >&
      blobs() const;

  // .bosdyn.api.TimeRange time_range = 1;
  bool has_time_range() const;
  private:
  bool _internal_has_time_range() const;
  public:
  void clear_time_range();
  const ::bosdyn::api::TimeRange& time_range() const;
  PROTOBUF_NODISCARD ::bosdyn::api::TimeRange* release_time_range();
  ::bosdyn::api::TimeRange* mutable_time_range();
  void set_allocated_time_range(::bosdyn::api::TimeRange* time_range);
  private:
  const ::bosdyn::api::TimeRange& _internal_time_range() const;
  ::bosdyn::api::TimeRange* _internal_mutable_time_range();
  public:
  void unsafe_arena_set_allocated_time_range(
      ::bosdyn::api::TimeRange* time_range);
  ::bosdyn::api::TimeRange* unsafe_arena_release_time_range();

  // .bosdyn.api.PagesAndTimestamp text_messages = 3;
  bool has_text_messages() const;
  private:
  bool _internal_has_text_messages() const;
  public:
  void clear_text_messages();
  const ::bosdyn::api::PagesAndTimestamp& text_messages() const;
  PROTOBUF_NODISCARD ::bosdyn::api::PagesAndTimestamp* release_text_messages();
  ::bosdyn::api::PagesAndTimestamp* mutable_text_messages();
  void set_allocated_text_messages(::bosdyn::api::PagesAndTimestamp* text_messages);
  private:
  const ::bosdyn::api::PagesAndTimestamp& _internal_text_messages() const;
  ::bosdyn::api::PagesAndTimestamp* _internal_mutable_text_messages();
  public:
  void unsafe_arena_set_allocated_text_messages(
      ::bosdyn::api::PagesAndTimestamp* text_messages);
  ::bosdyn::api::PagesAndTimestamp* unsafe_arena_release_text_messages();

  // .bosdyn.api.PagesAndTimestamp events = 4;
  bool has_events() const;
  private:
  bool _internal_has_events() const;
  public:
  void clear_events();
  const ::bosdyn::api::PagesAndTimestamp& events() const;
  PROTOBUF_NODISCARD ::bosdyn::api::PagesAndTimestamp* release_events();
  ::bosdyn::api::PagesAndTimestamp* mutable_events();
  void set_allocated_events(::bosdyn::api::PagesAndTimestamp* events);
  private:
  const ::bosdyn::api::PagesAndTimestamp& _internal_events() const;
  ::bosdyn::api::PagesAndTimestamp* _internal_mutable_events();
  public:
  void unsafe_arena_set_allocated_events(
      ::bosdyn::api::PagesAndTimestamp* events);
  ::bosdyn::api::PagesAndTimestamp* unsafe_arena_release_events();

  // .bosdyn.api.PagesAndTimestamp comments = 6;
  bool has_comments() const;
  private:
  bool _internal_has_comments() const;
  public:
  void clear_comments();
  const ::bosdyn::api::PagesAndTimestamp& comments() const;
  PROTOBUF_NODISCARD ::bosdyn::api::PagesAndTimestamp* release_comments();
  ::bosdyn::api::PagesAndTimestamp* mutable_comments();
  void set_allocated_comments(::bosdyn::api::PagesAndTimestamp* comments);
  private:
  const ::bosdyn::api::PagesAndTimestamp& _internal_comments() const;
  ::bosdyn::api::PagesAndTimestamp* _internal_mutable_comments();
  public:
  void unsafe_arena_set_allocated_comments(
      ::bosdyn::api::PagesAndTimestamp* comments);
  ::bosdyn::api::PagesAndTimestamp* unsafe_arena_release_comments();

  // @@protoc_insertion_point(class_scope:bosdyn.api.DataIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobPages > blobs_;
    ::bosdyn::api::TimeRange* time_range_;
    ::bosdyn::api::PagesAndTimestamp* text_messages_;
    ::bosdyn::api::PagesAndTimestamp* events_;
    ::bosdyn::api::PagesAndTimestamp* comments_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class EventsCommentsSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EventsCommentsSpec) */ {
 public:
  inline EventsCommentsSpec() : EventsCommentsSpec(nullptr) {}
  ~EventsCommentsSpec() override;
  explicit PROTOBUF_CONSTEXPR EventsCommentsSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventsCommentsSpec(const EventsCommentsSpec& from);
  EventsCommentsSpec(EventsCommentsSpec&& from) noexcept
    : EventsCommentsSpec() {
    *this = ::std::move(from);
  }

  inline EventsCommentsSpec& operator=(const EventsCommentsSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventsCommentsSpec& operator=(EventsCommentsSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventsCommentsSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventsCommentsSpec* internal_default_instance() {
    return reinterpret_cast<const EventsCommentsSpec*>(
               &_EventsCommentsSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EventsCommentsSpec& a, EventsCommentsSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(EventsCommentsSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventsCommentsSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventsCommentsSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventsCommentsSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventsCommentsSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventsCommentsSpec& from) {
    EventsCommentsSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventsCommentsSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EventsCommentsSpec";
  }
  protected:
  explicit EventsCommentsSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 2,
    kTimeRangeFieldNumber = 1,
    kCommentsFieldNumber = 3,
    kMaxEventsFieldNumber = 4,
    kMaxCommentsFieldNumber = 5,
  };
  // repeated .bosdyn.api.EventSpec events = 2;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::bosdyn::api::EventSpec* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EventSpec >*
      mutable_events();
  private:
  const ::bosdyn::api::EventSpec& _internal_events(int index) const;
  ::bosdyn::api::EventSpec* _internal_add_events();
  public:
  const ::bosdyn::api::EventSpec& events(int index) const;
  ::bosdyn::api::EventSpec* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EventSpec >&
      events() const;

  // .bosdyn.api.TimeRange time_range = 1;
  bool has_time_range() const;
  private:
  bool _internal_has_time_range() const;
  public:
  void clear_time_range();
  const ::bosdyn::api::TimeRange& time_range() const;
  PROTOBUF_NODISCARD ::bosdyn::api::TimeRange* release_time_range();
  ::bosdyn::api::TimeRange* mutable_time_range();
  void set_allocated_time_range(::bosdyn::api::TimeRange* time_range);
  private:
  const ::bosdyn::api::TimeRange& _internal_time_range() const;
  ::bosdyn::api::TimeRange* _internal_mutable_time_range();
  public:
  void unsafe_arena_set_allocated_time_range(
      ::bosdyn::api::TimeRange* time_range);
  ::bosdyn::api::TimeRange* unsafe_arena_release_time_range();

  // bool comments = 3;
  void clear_comments();
  bool comments() const;
  void set_comments(bool value);
  private:
  bool _internal_comments() const;
  void _internal_set_comments(bool value);
  public:

  // uint32 max_events = 4;
  void clear_max_events();
  uint32_t max_events() const;
  void set_max_events(uint32_t value);
  private:
  uint32_t _internal_max_events() const;
  void _internal_set_max_events(uint32_t value);
  public:

  // uint32 max_comments = 5;
  void clear_max_comments();
  uint32_t max_comments() const;
  void set_max_comments(uint32_t value);
  private:
  uint32_t _internal_max_comments() const;
  void _internal_set_max_comments(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.EventsCommentsSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EventSpec > events_;
    ::bosdyn::api::TimeRange* time_range_;
    bool comments_;
    uint32_t max_events_;
    uint32_t max_comments_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class EventsComments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EventsComments) */ {
 public:
  inline EventsComments() : EventsComments(nullptr) {}
  ~EventsComments() override;
  explicit PROTOBUF_CONSTEXPR EventsComments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventsComments(const EventsComments& from);
  EventsComments(EventsComments&& from) noexcept
    : EventsComments() {
    *this = ::std::move(from);
  }

  inline EventsComments& operator=(const EventsComments& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventsComments& operator=(EventsComments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventsComments& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventsComments* internal_default_instance() {
    return reinterpret_cast<const EventsComments*>(
               &_EventsComments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EventsComments& a, EventsComments& b) {
    a.Swap(&b);
  }
  inline void Swap(EventsComments* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventsComments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventsComments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventsComments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventsComments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventsComments& from) {
    EventsComments::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventsComments* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EventsComments";
  }
  protected:
  explicit EventsComments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 2,
    kOperatorCommentsFieldNumber = 3,
    kTimeRangeFieldNumber = 1,
    kEventsLimitedFieldNumber = 4,
    kOperatorCommentsLimitedFieldNumber = 5,
  };
  // repeated .bosdyn.api.Event events = 2;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::bosdyn::api::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Event >*
      mutable_events();
  private:
  const ::bosdyn::api::Event& _internal_events(int index) const;
  ::bosdyn::api::Event* _internal_add_events();
  public:
  const ::bosdyn::api::Event& events(int index) const;
  ::bosdyn::api::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Event >&
      events() const;

  // repeated .bosdyn.api.OperatorComment operator_comments = 3;
  int operator_comments_size() const;
  private:
  int _internal_operator_comments_size() const;
  public:
  void clear_operator_comments();
  ::bosdyn::api::OperatorComment* mutable_operator_comments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::OperatorComment >*
      mutable_operator_comments();
  private:
  const ::bosdyn::api::OperatorComment& _internal_operator_comments(int index) const;
  ::bosdyn::api::OperatorComment* _internal_add_operator_comments();
  public:
  const ::bosdyn::api::OperatorComment& operator_comments(int index) const;
  ::bosdyn::api::OperatorComment* add_operator_comments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::OperatorComment >&
      operator_comments() const;

  // .bosdyn.api.TimeRange time_range = 1;
  bool has_time_range() const;
  private:
  bool _internal_has_time_range() const;
  public:
  void clear_time_range();
  const ::bosdyn::api::TimeRange& time_range() const;
  PROTOBUF_NODISCARD ::bosdyn::api::TimeRange* release_time_range();
  ::bosdyn::api::TimeRange* mutable_time_range();
  void set_allocated_time_range(::bosdyn::api::TimeRange* time_range);
  private:
  const ::bosdyn::api::TimeRange& _internal_time_range() const;
  ::bosdyn::api::TimeRange* _internal_mutable_time_range();
  public:
  void unsafe_arena_set_allocated_time_range(
      ::bosdyn::api::TimeRange* time_range);
  ::bosdyn::api::TimeRange* unsafe_arena_release_time_range();

  // bool events_limited = 4;
  void clear_events_limited();
  bool events_limited() const;
  void set_events_limited(bool value);
  private:
  bool _internal_events_limited() const;
  void _internal_set_events_limited(bool value);
  public:

  // bool operator_comments_limited = 5;
  void clear_operator_comments_limited();
  bool operator_comments_limited() const;
  void set_operator_comments_limited(bool value);
  private:
  bool _internal_operator_comments_limited() const;
  void _internal_set_operator_comments_limited(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.EventsComments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Event > events_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::OperatorComment > operator_comments_;
    ::bosdyn::api::TimeRange* time_range_;
    bool events_limited_;
    bool operator_comments_limited_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class DataBufferStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DataBufferStatus) */ {
 public:
  inline DataBufferStatus() : DataBufferStatus(nullptr) {}
  ~DataBufferStatus() override;
  explicit PROTOBUF_CONSTEXPR DataBufferStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataBufferStatus(const DataBufferStatus& from);
  DataBufferStatus(DataBufferStatus&& from) noexcept
    : DataBufferStatus() {
    *this = ::std::move(from);
  }

  inline DataBufferStatus& operator=(const DataBufferStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataBufferStatus& operator=(DataBufferStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataBufferStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataBufferStatus* internal_default_instance() {
    return reinterpret_cast<const DataBufferStatus*>(
               &_DataBufferStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DataBufferStatus& a, DataBufferStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(DataBufferStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataBufferStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataBufferStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataBufferStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataBufferStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataBufferStatus& from) {
    DataBufferStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataBufferStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DataBufferStatus";
  }
  protected:
  explicit DataBufferStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobSpecsFieldNumber = 5,
    kNumDataBufferPagesFieldNumber = 1,
    kDataBufferTotalBytesFieldNumber = 2,
    kNumCommentsFieldNumber = 3,
    kNumEventsFieldNumber = 4,
  };
  // repeated .bosdyn.api.BlobSpec blob_specs = 5;
  int blob_specs_size() const;
  private:
  int _internal_blob_specs_size() const;
  public:
  void clear_blob_specs();
  ::bosdyn::api::BlobSpec* mutable_blob_specs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobSpec >*
      mutable_blob_specs();
  private:
  const ::bosdyn::api::BlobSpec& _internal_blob_specs(int index) const;
  ::bosdyn::api::BlobSpec* _internal_add_blob_specs();
  public:
  const ::bosdyn::api::BlobSpec& blob_specs(int index) const;
  ::bosdyn::api::BlobSpec* add_blob_specs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobSpec >&
      blob_specs() const;

  // int64 num_data_buffer_pages = 1;
  void clear_num_data_buffer_pages();
  int64_t num_data_buffer_pages() const;
  void set_num_data_buffer_pages(int64_t value);
  private:
  int64_t _internal_num_data_buffer_pages() const;
  void _internal_set_num_data_buffer_pages(int64_t value);
  public:

  // int64 data_buffer_total_bytes = 2;
  void clear_data_buffer_total_bytes();
  int64_t data_buffer_total_bytes() const;
  void set_data_buffer_total_bytes(int64_t value);
  private:
  int64_t _internal_data_buffer_total_bytes() const;
  void _internal_set_data_buffer_total_bytes(int64_t value);
  public:

  // int64 num_comments = 3;
  void clear_num_comments();
  int64_t num_comments() const;
  void set_num_comments(int64_t value);
  private:
  int64_t _internal_num_comments() const;
  void _internal_set_num_comments(int64_t value);
  public:

  // int64 num_events = 4;
  void clear_num_events();
  int64_t num_events() const;
  void set_num_events(int64_t value);
  private:
  int64_t _internal_num_events() const;
  void _internal_set_num_events(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.DataBufferStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobSpec > blob_specs_;
    int64_t num_data_buffer_pages_;
    int64_t data_buffer_total_bytes_;
    int64_t num_comments_;
    int64_t num_events_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class GetDataIndexResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetDataIndexResponse) */ {
 public:
  inline GetDataIndexResponse() : GetDataIndexResponse(nullptr) {}
  ~GetDataIndexResponse() override;
  explicit PROTOBUF_CONSTEXPR GetDataIndexResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDataIndexResponse(const GetDataIndexResponse& from);
  GetDataIndexResponse(GetDataIndexResponse&& from) noexcept
    : GetDataIndexResponse() {
    *this = ::std::move(from);
  }

  inline GetDataIndexResponse& operator=(const GetDataIndexResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDataIndexResponse& operator=(GetDataIndexResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDataIndexResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDataIndexResponse* internal_default_instance() {
    return reinterpret_cast<const GetDataIndexResponse*>(
               &_GetDataIndexResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetDataIndexResponse& a, GetDataIndexResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDataIndexResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDataIndexResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDataIndexResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDataIndexResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDataIndexResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDataIndexResponse& from) {
    GetDataIndexResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDataIndexResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetDataIndexResponse";
  }
  protected:
  explicit GetDataIndexResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kDataIndexFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.DataIndex data_index = 2;
  bool has_data_index() const;
  private:
  bool _internal_has_data_index() const;
  public:
  void clear_data_index();
  const ::bosdyn::api::DataIndex& data_index() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataIndex* release_data_index();
  ::bosdyn::api::DataIndex* mutable_data_index();
  void set_allocated_data_index(::bosdyn::api::DataIndex* data_index);
  private:
  const ::bosdyn::api::DataIndex& _internal_data_index() const;
  ::bosdyn::api::DataIndex* _internal_mutable_data_index();
  public:
  void unsafe_arena_set_allocated_data_index(
      ::bosdyn::api::DataIndex* data_index);
  ::bosdyn::api::DataIndex* unsafe_arena_release_data_index();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetDataIndexResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::DataIndex* data_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class GetDataIndexRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetDataIndexRequest) */ {
 public:
  inline GetDataIndexRequest() : GetDataIndexRequest(nullptr) {}
  ~GetDataIndexRequest() override;
  explicit PROTOBUF_CONSTEXPR GetDataIndexRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDataIndexRequest(const GetDataIndexRequest& from);
  GetDataIndexRequest(GetDataIndexRequest&& from) noexcept
    : GetDataIndexRequest() {
    *this = ::std::move(from);
  }

  inline GetDataIndexRequest& operator=(const GetDataIndexRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDataIndexRequest& operator=(GetDataIndexRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDataIndexRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDataIndexRequest* internal_default_instance() {
    return reinterpret_cast<const GetDataIndexRequest*>(
               &_GetDataIndexRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetDataIndexRequest& a, GetDataIndexRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDataIndexRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDataIndexRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDataIndexRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDataIndexRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDataIndexRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDataIndexRequest& from) {
    GetDataIndexRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDataIndexRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetDataIndexRequest";
  }
  protected:
  explicit GetDataIndexRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kDataQueryFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.DataQuery data_query = 2;
  bool has_data_query() const;
  private:
  bool _internal_has_data_query() const;
  public:
  void clear_data_query();
  const ::bosdyn::api::DataQuery& data_query() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataQuery* release_data_query();
  ::bosdyn::api::DataQuery* mutable_data_query();
  void set_allocated_data_query(::bosdyn::api::DataQuery* data_query);
  private:
  const ::bosdyn::api::DataQuery& _internal_data_query() const;
  ::bosdyn::api::DataQuery* _internal_mutable_data_query();
  public:
  void unsafe_arena_set_allocated_data_query(
      ::bosdyn::api::DataQuery* data_query);
  ::bosdyn::api::DataQuery* unsafe_arena_release_data_query();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetDataIndexRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::DataQuery* data_query_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class GetEventsCommentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetEventsCommentsRequest) */ {
 public:
  inline GetEventsCommentsRequest() : GetEventsCommentsRequest(nullptr) {}
  ~GetEventsCommentsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetEventsCommentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEventsCommentsRequest(const GetEventsCommentsRequest& from);
  GetEventsCommentsRequest(GetEventsCommentsRequest&& from) noexcept
    : GetEventsCommentsRequest() {
    *this = ::std::move(from);
  }

  inline GetEventsCommentsRequest& operator=(const GetEventsCommentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEventsCommentsRequest& operator=(GetEventsCommentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEventsCommentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEventsCommentsRequest* internal_default_instance() {
    return reinterpret_cast<const GetEventsCommentsRequest*>(
               &_GetEventsCommentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetEventsCommentsRequest& a, GetEventsCommentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEventsCommentsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEventsCommentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEventsCommentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEventsCommentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEventsCommentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetEventsCommentsRequest& from) {
    GetEventsCommentsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEventsCommentsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetEventsCommentsRequest";
  }
  protected:
  explicit GetEventsCommentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kEventCommentRequestFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.EventsCommentsSpec event_comment_request = 2;
  bool has_event_comment_request() const;
  private:
  bool _internal_has_event_comment_request() const;
  public:
  void clear_event_comment_request();
  const ::bosdyn::api::EventsCommentsSpec& event_comment_request() const;
  PROTOBUF_NODISCARD ::bosdyn::api::EventsCommentsSpec* release_event_comment_request();
  ::bosdyn::api::EventsCommentsSpec* mutable_event_comment_request();
  void set_allocated_event_comment_request(::bosdyn::api::EventsCommentsSpec* event_comment_request);
  private:
  const ::bosdyn::api::EventsCommentsSpec& _internal_event_comment_request() const;
  ::bosdyn::api::EventsCommentsSpec* _internal_mutable_event_comment_request();
  public:
  void unsafe_arena_set_allocated_event_comment_request(
      ::bosdyn::api::EventsCommentsSpec* event_comment_request);
  ::bosdyn::api::EventsCommentsSpec* unsafe_arena_release_event_comment_request();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetEventsCommentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::EventsCommentsSpec* event_comment_request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class GetEventsCommentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetEventsCommentsResponse) */ {
 public:
  inline GetEventsCommentsResponse() : GetEventsCommentsResponse(nullptr) {}
  ~GetEventsCommentsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetEventsCommentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEventsCommentsResponse(const GetEventsCommentsResponse& from);
  GetEventsCommentsResponse(GetEventsCommentsResponse&& from) noexcept
    : GetEventsCommentsResponse() {
    *this = ::std::move(from);
  }

  inline GetEventsCommentsResponse& operator=(const GetEventsCommentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEventsCommentsResponse& operator=(GetEventsCommentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEventsCommentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEventsCommentsResponse* internal_default_instance() {
    return reinterpret_cast<const GetEventsCommentsResponse*>(
               &_GetEventsCommentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetEventsCommentsResponse& a, GetEventsCommentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEventsCommentsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEventsCommentsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEventsCommentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEventsCommentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEventsCommentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetEventsCommentsResponse& from) {
    GetEventsCommentsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEventsCommentsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetEventsCommentsResponse";
  }
  protected:
  explicit GetEventsCommentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kEventsCommentsFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.EventsComments events_comments = 2;
  bool has_events_comments() const;
  private:
  bool _internal_has_events_comments() const;
  public:
  void clear_events_comments();
  const ::bosdyn::api::EventsComments& events_comments() const;
  PROTOBUF_NODISCARD ::bosdyn::api::EventsComments* release_events_comments();
  ::bosdyn::api::EventsComments* mutable_events_comments();
  void set_allocated_events_comments(::bosdyn::api::EventsComments* events_comments);
  private:
  const ::bosdyn::api::EventsComments& _internal_events_comments() const;
  ::bosdyn::api::EventsComments* _internal_mutable_events_comments();
  public:
  void unsafe_arena_set_allocated_events_comments(
      ::bosdyn::api::EventsComments* events_comments);
  ::bosdyn::api::EventsComments* unsafe_arena_release_events_comments();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetEventsCommentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::EventsComments* events_comments_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class GetDataBufferStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetDataBufferStatusRequest) */ {
 public:
  inline GetDataBufferStatusRequest() : GetDataBufferStatusRequest(nullptr) {}
  ~GetDataBufferStatusRequest() override;
  explicit PROTOBUF_CONSTEXPR GetDataBufferStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDataBufferStatusRequest(const GetDataBufferStatusRequest& from);
  GetDataBufferStatusRequest(GetDataBufferStatusRequest&& from) noexcept
    : GetDataBufferStatusRequest() {
    *this = ::std::move(from);
  }

  inline GetDataBufferStatusRequest& operator=(const GetDataBufferStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDataBufferStatusRequest& operator=(GetDataBufferStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDataBufferStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDataBufferStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GetDataBufferStatusRequest*>(
               &_GetDataBufferStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetDataBufferStatusRequest& a, GetDataBufferStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDataBufferStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDataBufferStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDataBufferStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDataBufferStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDataBufferStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDataBufferStatusRequest& from) {
    GetDataBufferStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDataBufferStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetDataBufferStatusRequest";
  }
  protected:
  explicit GetDataBufferStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kGetBlobSpecsFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // bool get_blob_specs = 2;
  void clear_get_blob_specs();
  bool get_blob_specs() const;
  void set_get_blob_specs(bool value);
  private:
  bool _internal_get_blob_specs() const;
  void _internal_set_get_blob_specs(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetDataBufferStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    bool get_blob_specs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class GetDataBufferStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetDataBufferStatusResponse) */ {
 public:
  inline GetDataBufferStatusResponse() : GetDataBufferStatusResponse(nullptr) {}
  ~GetDataBufferStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR GetDataBufferStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDataBufferStatusResponse(const GetDataBufferStatusResponse& from);
  GetDataBufferStatusResponse(GetDataBufferStatusResponse&& from) noexcept
    : GetDataBufferStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetDataBufferStatusResponse& operator=(const GetDataBufferStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDataBufferStatusResponse& operator=(GetDataBufferStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDataBufferStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDataBufferStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetDataBufferStatusResponse*>(
               &_GetDataBufferStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetDataBufferStatusResponse& a, GetDataBufferStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDataBufferStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDataBufferStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDataBufferStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDataBufferStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDataBufferStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDataBufferStatusResponse& from) {
    GetDataBufferStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDataBufferStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetDataBufferStatusResponse";
  }
  protected:
  explicit GetDataBufferStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kDataBufferStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.DataBufferStatus data_buffer_status = 2;
  bool has_data_buffer_status() const;
  private:
  bool _internal_has_data_buffer_status() const;
  public:
  void clear_data_buffer_status();
  const ::bosdyn::api::DataBufferStatus& data_buffer_status() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataBufferStatus* release_data_buffer_status();
  ::bosdyn::api::DataBufferStatus* mutable_data_buffer_status();
  void set_allocated_data_buffer_status(::bosdyn::api::DataBufferStatus* data_buffer_status);
  private:
  const ::bosdyn::api::DataBufferStatus& _internal_data_buffer_status() const;
  ::bosdyn::api::DataBufferStatus* _internal_mutable_data_buffer_status();
  public:
  void unsafe_arena_set_allocated_data_buffer_status(
      ::bosdyn::api::DataBufferStatus* data_buffer_status);
  ::bosdyn::api::DataBufferStatus* unsafe_arena_release_data_buffer_status();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetDataBufferStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::DataBufferStatus* data_buffer_status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class GetDataPagesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetDataPagesRequest) */ {
 public:
  inline GetDataPagesRequest() : GetDataPagesRequest(nullptr) {}
  ~GetDataPagesRequest() override;
  explicit PROTOBUF_CONSTEXPR GetDataPagesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDataPagesRequest(const GetDataPagesRequest& from);
  GetDataPagesRequest(GetDataPagesRequest&& from) noexcept
    : GetDataPagesRequest() {
    *this = ::std::move(from);
  }

  inline GetDataPagesRequest& operator=(const GetDataPagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDataPagesRequest& operator=(GetDataPagesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDataPagesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDataPagesRequest* internal_default_instance() {
    return reinterpret_cast<const GetDataPagesRequest*>(
               &_GetDataPagesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetDataPagesRequest& a, GetDataPagesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDataPagesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDataPagesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDataPagesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDataPagesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDataPagesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDataPagesRequest& from) {
    GetDataPagesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDataPagesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetDataPagesRequest";
  }
  protected:
  explicit GetDataPagesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kTimeRangeFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.TimeRange time_range = 2;
  bool has_time_range() const;
  private:
  bool _internal_has_time_range() const;
  public:
  void clear_time_range();
  const ::bosdyn::api::TimeRange& time_range() const;
  PROTOBUF_NODISCARD ::bosdyn::api::TimeRange* release_time_range();
  ::bosdyn::api::TimeRange* mutable_time_range();
  void set_allocated_time_range(::bosdyn::api::TimeRange* time_range);
  private:
  const ::bosdyn::api::TimeRange& _internal_time_range() const;
  ::bosdyn::api::TimeRange* _internal_mutable_time_range();
  public:
  void unsafe_arena_set_allocated_time_range(
      ::bosdyn::api::TimeRange* time_range);
  ::bosdyn::api::TimeRange* unsafe_arena_release_time_range();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetDataPagesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::TimeRange* time_range_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class GetDataPagesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetDataPagesResponse) */ {
 public:
  inline GetDataPagesResponse() : GetDataPagesResponse(nullptr) {}
  ~GetDataPagesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetDataPagesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDataPagesResponse(const GetDataPagesResponse& from);
  GetDataPagesResponse(GetDataPagesResponse&& from) noexcept
    : GetDataPagesResponse() {
    *this = ::std::move(from);
  }

  inline GetDataPagesResponse& operator=(const GetDataPagesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDataPagesResponse& operator=(GetDataPagesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDataPagesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDataPagesResponse* internal_default_instance() {
    return reinterpret_cast<const GetDataPagesResponse*>(
               &_GetDataPagesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetDataPagesResponse& a, GetDataPagesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDataPagesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDataPagesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDataPagesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDataPagesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDataPagesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDataPagesResponse& from) {
    GetDataPagesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDataPagesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetDataPagesResponse";
  }
  protected:
  explicit GetDataPagesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPagesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.PageInfo pages = 2;
  int pages_size() const;
  private:
  int _internal_pages_size() const;
  public:
  void clear_pages();
  ::bosdyn::api::PageInfo* mutable_pages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PageInfo >*
      mutable_pages();
  private:
  const ::bosdyn::api::PageInfo& _internal_pages(int index) const;
  ::bosdyn::api::PageInfo* _internal_add_pages();
  public:
  const ::bosdyn::api::PageInfo& pages(int index) const;
  ::bosdyn::api::PageInfo* add_pages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PageInfo >&
      pages() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetDataPagesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PageInfo > pages_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class DeleteDataPagesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DeleteDataPagesRequest) */ {
 public:
  inline DeleteDataPagesRequest() : DeleteDataPagesRequest(nullptr) {}
  ~DeleteDataPagesRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteDataPagesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteDataPagesRequest(const DeleteDataPagesRequest& from);
  DeleteDataPagesRequest(DeleteDataPagesRequest&& from) noexcept
    : DeleteDataPagesRequest() {
    *this = ::std::move(from);
  }

  inline DeleteDataPagesRequest& operator=(const DeleteDataPagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteDataPagesRequest& operator=(DeleteDataPagesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteDataPagesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteDataPagesRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteDataPagesRequest*>(
               &_DeleteDataPagesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DeleteDataPagesRequest& a, DeleteDataPagesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteDataPagesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteDataPagesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteDataPagesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteDataPagesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteDataPagesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteDataPagesRequest& from) {
    DeleteDataPagesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteDataPagesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DeleteDataPagesRequest";
  }
  protected:
  explicit DeleteDataPagesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageIdsFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kTimeRangeFieldNumber = 2,
  };
  // repeated string page_ids = 3;
  int page_ids_size() const;
  private:
  int _internal_page_ids_size() const;
  public:
  void clear_page_ids();
  const std::string& page_ids(int index) const;
  std::string* mutable_page_ids(int index);
  void set_page_ids(int index, const std::string& value);
  void set_page_ids(int index, std::string&& value);
  void set_page_ids(int index, const char* value);
  void set_page_ids(int index, const char* value, size_t size);
  std::string* add_page_ids();
  void add_page_ids(const std::string& value);
  void add_page_ids(std::string&& value);
  void add_page_ids(const char* value);
  void add_page_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& page_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_page_ids();
  private:
  const std::string& _internal_page_ids(int index) const;
  std::string* _internal_add_page_ids();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.TimeRange time_range = 2;
  bool has_time_range() const;
  private:
  bool _internal_has_time_range() const;
  public:
  void clear_time_range();
  const ::bosdyn::api::TimeRange& time_range() const;
  PROTOBUF_NODISCARD ::bosdyn::api::TimeRange* release_time_range();
  ::bosdyn::api::TimeRange* mutable_time_range();
  void set_allocated_time_range(::bosdyn::api::TimeRange* time_range);
  private:
  const ::bosdyn::api::TimeRange& _internal_time_range() const;
  ::bosdyn::api::TimeRange* _internal_mutable_time_range();
  public:
  void unsafe_arena_set_allocated_time_range(
      ::bosdyn::api::TimeRange* time_range);
  ::bosdyn::api::TimeRange* unsafe_arena_release_time_range();

  // @@protoc_insertion_point(class_scope:bosdyn.api.DeleteDataPagesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> page_ids_;
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::TimeRange* time_range_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class DeletePageStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DeletePageStatus) */ {
 public:
  inline DeletePageStatus() : DeletePageStatus(nullptr) {}
  ~DeletePageStatus() override;
  explicit PROTOBUF_CONSTEXPR DeletePageStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeletePageStatus(const DeletePageStatus& from);
  DeletePageStatus(DeletePageStatus&& from) noexcept
    : DeletePageStatus() {
    *this = ::std::move(from);
  }

  inline DeletePageStatus& operator=(const DeletePageStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePageStatus& operator=(DeletePageStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePageStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePageStatus* internal_default_instance() {
    return reinterpret_cast<const DeletePageStatus*>(
               &_DeletePageStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DeletePageStatus& a, DeletePageStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletePageStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePageStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeletePageStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeletePageStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeletePageStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeletePageStatus& from) {
    DeletePageStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePageStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DeletePageStatus";
  }
  protected:
  explicit DeletePageStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DeletePageStatus_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    DeletePageStatus_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_DELETED =
    DeletePageStatus_Status_STATUS_DELETED;
  static constexpr Status STATUS_DELETION_FAILED =
    DeletePageStatus_Status_STATUS_DELETION_FAILED;
  static constexpr Status STATUS_NOT_FOUND =
    DeletePageStatus_Status_STATUS_NOT_FOUND;
  static inline bool Status_IsValid(int value) {
    return DeletePageStatus_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    DeletePageStatus_Status_Status_MIN;
  static constexpr Status Status_MAX =
    DeletePageStatus_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    DeletePageStatus_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return DeletePageStatus_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return DeletePageStatus_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return DeletePageStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPageIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string page_id = 1;
  void clear_page_id();
  const std::string& page_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_id();
  PROTOBUF_NODISCARD std::string* release_page_id();
  void set_allocated_page_id(std::string* page_id);
  private:
  const std::string& _internal_page_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_id(const std::string& value);
  std::string* _internal_mutable_page_id();
  public:

  // .bosdyn.api.DeletePageStatus.Status status = 2;
  void clear_status();
  ::bosdyn::api::DeletePageStatus_Status status() const;
  void set_status(::bosdyn::api::DeletePageStatus_Status value);
  private:
  ::bosdyn::api::DeletePageStatus_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::DeletePageStatus_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.DeletePageStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_id_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// -------------------------------------------------------------------

class DeleteDataPagesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DeleteDataPagesResponse) */ {
 public:
  inline DeleteDataPagesResponse() : DeleteDataPagesResponse(nullptr) {}
  ~DeleteDataPagesResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteDataPagesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteDataPagesResponse(const DeleteDataPagesResponse& from);
  DeleteDataPagesResponse(DeleteDataPagesResponse&& from) noexcept
    : DeleteDataPagesResponse() {
    *this = ::std::move(from);
  }

  inline DeleteDataPagesResponse& operator=(const DeleteDataPagesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteDataPagesResponse& operator=(DeleteDataPagesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteDataPagesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteDataPagesResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteDataPagesResponse*>(
               &_DeleteDataPagesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(DeleteDataPagesResponse& a, DeleteDataPagesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteDataPagesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteDataPagesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteDataPagesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteDataPagesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteDataPagesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteDataPagesResponse& from) {
    DeleteDataPagesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteDataPagesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DeleteDataPagesResponse";
  }
  protected:
  explicit DeleteDataPagesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kBytesDeletedFieldNumber = 2,
  };
  // repeated .bosdyn.api.DeletePageStatus status = 3;
  int status_size() const;
  private:
  int _internal_status_size() const;
  public:
  void clear_status();
  ::bosdyn::api::DeletePageStatus* mutable_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DeletePageStatus >*
      mutable_status();
  private:
  const ::bosdyn::api::DeletePageStatus& _internal_status(int index) const;
  ::bosdyn::api::DeletePageStatus* _internal_add_status();
  public:
  const ::bosdyn::api::DeletePageStatus& status(int index) const;
  ::bosdyn::api::DeletePageStatus* add_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DeletePageStatus >&
      status() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // int64 bytes_deleted = 2;
  void clear_bytes_deleted();
  int64_t bytes_deleted() const;
  void set_bytes_deleted(int64_t value);
  private:
  int64_t _internal_bytes_deleted() const;
  void _internal_set_bytes_deleted(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.DeleteDataPagesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DeletePageStatus > status_;
    ::bosdyn::api::ResponseHeader* header_;
    int64_t bytes_deleted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fdata_5findex_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GrpcSpec

// string service_name = 1;
inline void GrpcSpec::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& GrpcSpec::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GrpcSpec.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GrpcSpec::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.GrpcSpec.service_name)
}
inline std::string* GrpcSpec::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GrpcSpec.service_name)
  return _s;
}
inline const std::string& GrpcSpec::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void GrpcSpec::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GrpcSpec::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GrpcSpec::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GrpcSpec.service_name)
  return _impl_.service_name_.Release();
}
inline void GrpcSpec::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GrpcSpec.service_name)
}

// -------------------------------------------------------------------

// BlobSpec

// string source = 1;
inline void BlobSpec::clear_source() {
  _impl_.source_.ClearToEmpty();
}
inline const std::string& BlobSpec::source() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BlobSpec.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlobSpec::set_source(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.BlobSpec.source)
}
inline std::string* BlobSpec::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BlobSpec.source)
  return _s;
}
inline const std::string& BlobSpec::_internal_source() const {
  return _impl_.source_.Get();
}
inline void BlobSpec::_internal_set_source(const std::string& value) {
  
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* BlobSpec::_internal_mutable_source() {
  
  return _impl_.source_.Mutable(GetArenaForAllocation());
}
inline std::string* BlobSpec::release_source() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BlobSpec.source)
  return _impl_.source_.Release();
}
inline void BlobSpec::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  _impl_.source_.SetAllocated(source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BlobSpec.source)
}

// string message_type = 2;
inline void BlobSpec::clear_message_type() {
  _impl_.message_type_.ClearToEmpty();
}
inline const std::string& BlobSpec::message_type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BlobSpec.message_type)
  return _internal_message_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlobSpec::set_message_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.BlobSpec.message_type)
}
inline std::string* BlobSpec::mutable_message_type() {
  std::string* _s = _internal_mutable_message_type();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BlobSpec.message_type)
  return _s;
}
inline const std::string& BlobSpec::_internal_message_type() const {
  return _impl_.message_type_.Get();
}
inline void BlobSpec::_internal_set_message_type(const std::string& value) {
  
  _impl_.message_type_.Set(value, GetArenaForAllocation());
}
inline std::string* BlobSpec::_internal_mutable_message_type() {
  
  return _impl_.message_type_.Mutable(GetArenaForAllocation());
}
inline std::string* BlobSpec::release_message_type() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BlobSpec.message_type)
  return _impl_.message_type_.Release();
}
inline void BlobSpec::set_allocated_message_type(std::string* message_type) {
  if (message_type != nullptr) {
    
  } else {
    
  }
  _impl_.message_type_.SetAllocated(message_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_type_.IsDefault()) {
    _impl_.message_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BlobSpec.message_type)
}

// string channel = 3;
inline void BlobSpec::clear_channel() {
  _impl_.channel_.ClearToEmpty();
}
inline const std::string& BlobSpec::channel() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BlobSpec.channel)
  return _internal_channel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlobSpec::set_channel(ArgT0&& arg0, ArgT... args) {
 
 _impl_.channel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.BlobSpec.channel)
}
inline std::string* BlobSpec::mutable_channel() {
  std::string* _s = _internal_mutable_channel();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BlobSpec.channel)
  return _s;
}
inline const std::string& BlobSpec::_internal_channel() const {
  return _impl_.channel_.Get();
}
inline void BlobSpec::_internal_set_channel(const std::string& value) {
  
  _impl_.channel_.Set(value, GetArenaForAllocation());
}
inline std::string* BlobSpec::_internal_mutable_channel() {
  
  return _impl_.channel_.Mutable(GetArenaForAllocation());
}
inline std::string* BlobSpec::release_channel() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BlobSpec.channel)
  return _impl_.channel_.Release();
}
inline void BlobSpec::set_allocated_channel(std::string* channel) {
  if (channel != nullptr) {
    
  } else {
    
  }
  _impl_.channel_.SetAllocated(channel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.channel_.IsDefault()) {
    _impl_.channel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BlobSpec.channel)
}

// string channel_glob = 4;
inline void BlobSpec::clear_channel_glob() {
  _impl_.channel_glob_.ClearToEmpty();
}
inline const std::string& BlobSpec::channel_glob() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BlobSpec.channel_glob)
  return _internal_channel_glob();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlobSpec::set_channel_glob(ArgT0&& arg0, ArgT... args) {
 
 _impl_.channel_glob_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.BlobSpec.channel_glob)
}
inline std::string* BlobSpec::mutable_channel_glob() {
  std::string* _s = _internal_mutable_channel_glob();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BlobSpec.channel_glob)
  return _s;
}
inline const std::string& BlobSpec::_internal_channel_glob() const {
  return _impl_.channel_glob_.Get();
}
inline void BlobSpec::_internal_set_channel_glob(const std::string& value) {
  
  _impl_.channel_glob_.Set(value, GetArenaForAllocation());
}
inline std::string* BlobSpec::_internal_mutable_channel_glob() {
  
  return _impl_.channel_glob_.Mutable(GetArenaForAllocation());
}
inline std::string* BlobSpec::release_channel_glob() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BlobSpec.channel_glob)
  return _impl_.channel_glob_.Release();
}
inline void BlobSpec::set_allocated_channel_glob(std::string* channel_glob) {
  if (channel_glob != nullptr) {
    
  } else {
    
  }
  _impl_.channel_glob_.SetAllocated(channel_glob, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.channel_glob_.IsDefault()) {
    _impl_.channel_glob_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BlobSpec.channel_glob)
}

// -------------------------------------------------------------------

// EventSpec

// string source = 1;
inline void EventSpec::clear_source() {
  _impl_.source_.ClearToEmpty();
}
inline const std::string& EventSpec::source() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EventSpec.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventSpec::set_source(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.EventSpec.source)
}
inline std::string* EventSpec::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EventSpec.source)
  return _s;
}
inline const std::string& EventSpec::_internal_source() const {
  return _impl_.source_.Get();
}
inline void EventSpec::_internal_set_source(const std::string& value) {
  
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSpec::_internal_mutable_source() {
  
  return _impl_.source_.Mutable(GetArenaForAllocation());
}
inline std::string* EventSpec::release_source() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EventSpec.source)
  return _impl_.source_.Release();
}
inline void EventSpec::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  _impl_.source_.SetAllocated(source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EventSpec.source)
}

// string type = 2;
inline void EventSpec::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& EventSpec::type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EventSpec.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventSpec::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.EventSpec.type)
}
inline std::string* EventSpec::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EventSpec.type)
  return _s;
}
inline const std::string& EventSpec::_internal_type() const {
  return _impl_.type_.Get();
}
inline void EventSpec::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSpec::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* EventSpec::release_type() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EventSpec.type)
  return _impl_.type_.Release();
}
inline void EventSpec::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EventSpec.type)
}

// .google.protobuf.Int32Value level = 3;
inline bool EventSpec::_internal_has_level() const {
  return this != internal_default_instance() && _impl_.level_ != nullptr;
}
inline bool EventSpec::has_level() const {
  return _internal_has_level();
}
inline const ::PROTOBUF_NAMESPACE_ID::Int32Value& EventSpec::_internal_level() const {
  const ::PROTOBUF_NAMESPACE_ID::Int32Value* p = _impl_.level_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Int32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Int32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Int32Value& EventSpec::level() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EventSpec.level)
  return _internal_level();
}
inline void EventSpec::unsafe_arena_set_allocated_level(
    ::PROTOBUF_NAMESPACE_ID::Int32Value* level) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.level_);
  }
  _impl_.level_ = level;
  if (level) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EventSpec.level)
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* EventSpec::release_level() {
  
  ::PROTOBUF_NAMESPACE_ID::Int32Value* temp = _impl_.level_;
  _impl_.level_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* EventSpec::unsafe_arena_release_level() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EventSpec.level)
  
  ::PROTOBUF_NAMESPACE_ID::Int32Value* temp = _impl_.level_;
  _impl_.level_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* EventSpec::_internal_mutable_level() {
  
  if (_impl_.level_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Int32Value>(GetArenaForAllocation());
    _impl_.level_ = p;
  }
  return _impl_.level_;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* EventSpec::mutable_level() {
  ::PROTOBUF_NAMESPACE_ID::Int32Value* _msg = _internal_mutable_level();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EventSpec.level)
  return _msg;
}
inline void EventSpec::set_allocated_level(::PROTOBUF_NAMESPACE_ID::Int32Value* level) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.level_);
  }
  if (level) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(level));
    if (message_arena != submessage_arena) {
      level = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, level, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.level_ = level;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EventSpec.level)
}

// .bosdyn.api.Event.LogPreserveHint log_preserve_hint = 4;
inline void EventSpec::clear_log_preserve_hint() {
  _impl_.log_preserve_hint_ = 0;
}
inline ::bosdyn::api::Event_LogPreserveHint EventSpec::_internal_log_preserve_hint() const {
  return static_cast< ::bosdyn::api::Event_LogPreserveHint >(_impl_.log_preserve_hint_);
}
inline ::bosdyn::api::Event_LogPreserveHint EventSpec::log_preserve_hint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EventSpec.log_preserve_hint)
  return _internal_log_preserve_hint();
}
inline void EventSpec::_internal_set_log_preserve_hint(::bosdyn::api::Event_LogPreserveHint value) {
  
  _impl_.log_preserve_hint_ = value;
}
inline void EventSpec::set_log_preserve_hint(::bosdyn::api::Event_LogPreserveHint value) {
  _internal_set_log_preserve_hint(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EventSpec.log_preserve_hint)
}

// -------------------------------------------------------------------

// PageInfo

// string id = 1;
inline void PageInfo::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& PageInfo::id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PageInfo.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PageInfo::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.PageInfo.id)
}
inline std::string* PageInfo::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PageInfo.id)
  return _s;
}
inline const std::string& PageInfo::_internal_id() const {
  return _impl_.id_.Get();
}
inline void PageInfo::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* PageInfo::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* PageInfo::release_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PageInfo.id)
  return _impl_.id_.Release();
}
inline void PageInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PageInfo.id)
}

// string path = 2;
inline void PageInfo::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& PageInfo::path() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PageInfo.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PageInfo::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.PageInfo.path)
}
inline std::string* PageInfo::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PageInfo.path)
  return _s;
}
inline const std::string& PageInfo::_internal_path() const {
  return _impl_.path_.Get();
}
inline void PageInfo::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* PageInfo::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* PageInfo::release_path() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PageInfo.path)
  return _impl_.path_.Release();
}
inline void PageInfo::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PageInfo.path)
}

// string source = 3;
inline void PageInfo::clear_source() {
  _impl_.source_.ClearToEmpty();
}
inline const std::string& PageInfo::source() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PageInfo.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PageInfo::set_source(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.PageInfo.source)
}
inline std::string* PageInfo::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PageInfo.source)
  return _s;
}
inline const std::string& PageInfo::_internal_source() const {
  return _impl_.source_.Get();
}
inline void PageInfo::_internal_set_source(const std::string& value) {
  
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* PageInfo::_internal_mutable_source() {
  
  return _impl_.source_.Mutable(GetArenaForAllocation());
}
inline std::string* PageInfo::release_source() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PageInfo.source)
  return _impl_.source_.Release();
}
inline void PageInfo::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  _impl_.source_.SetAllocated(source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PageInfo.source)
}

// .bosdyn.api.TimeRange time_range = 4;
inline bool PageInfo::_internal_has_time_range() const {
  return this != internal_default_instance() && _impl_.time_range_ != nullptr;
}
inline bool PageInfo::has_time_range() const {
  return _internal_has_time_range();
}
inline const ::bosdyn::api::TimeRange& PageInfo::_internal_time_range() const {
  const ::bosdyn::api::TimeRange* p = _impl_.time_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::TimeRange&>(
      ::bosdyn::api::_TimeRange_default_instance_);
}
inline const ::bosdyn::api::TimeRange& PageInfo::time_range() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PageInfo.time_range)
  return _internal_time_range();
}
inline void PageInfo::unsafe_arena_set_allocated_time_range(
    ::bosdyn::api::TimeRange* time_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  _impl_.time_range_ = time_range;
  if (time_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PageInfo.time_range)
}
inline ::bosdyn::api::TimeRange* PageInfo::release_time_range() {
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::TimeRange* PageInfo::unsafe_arena_release_time_range() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PageInfo.time_range)
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
  return temp;
}
inline ::bosdyn::api::TimeRange* PageInfo::_internal_mutable_time_range() {
  
  if (_impl_.time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::TimeRange>(GetArenaForAllocation());
    _impl_.time_range_ = p;
  }
  return _impl_.time_range_;
}
inline ::bosdyn::api::TimeRange* PageInfo::mutable_time_range() {
  ::bosdyn::api::TimeRange* _msg = _internal_mutable_time_range();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PageInfo.time_range)
  return _msg;
}
inline void PageInfo::set_allocated_time_range(::bosdyn::api::TimeRange* time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  if (time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range));
    if (message_arena != submessage_arena) {
      time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_range, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_range_ = time_range;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PageInfo.time_range)
}

// int64 num_ticks = 5;
inline void PageInfo::clear_num_ticks() {
  _impl_.num_ticks_ = int64_t{0};
}
inline int64_t PageInfo::_internal_num_ticks() const {
  return _impl_.num_ticks_;
}
inline int64_t PageInfo::num_ticks() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PageInfo.num_ticks)
  return _internal_num_ticks();
}
inline void PageInfo::_internal_set_num_ticks(int64_t value) {
  
  _impl_.num_ticks_ = value;
}
inline void PageInfo::set_num_ticks(int64_t value) {
  _internal_set_num_ticks(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PageInfo.num_ticks)
}

// int64 total_bytes = 6;
inline void PageInfo::clear_total_bytes() {
  _impl_.total_bytes_ = int64_t{0};
}
inline int64_t PageInfo::_internal_total_bytes() const {
  return _impl_.total_bytes_;
}
inline int64_t PageInfo::total_bytes() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PageInfo.total_bytes)
  return _internal_total_bytes();
}
inline void PageInfo::_internal_set_total_bytes(int64_t value) {
  
  _impl_.total_bytes_ = value;
}
inline void PageInfo::set_total_bytes(int64_t value) {
  _internal_set_total_bytes(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PageInfo.total_bytes)
}

// .bosdyn.api.PageInfo.PageFormat format = 7;
inline void PageInfo::clear_format() {
  _impl_.format_ = 0;
}
inline ::bosdyn::api::PageInfo_PageFormat PageInfo::_internal_format() const {
  return static_cast< ::bosdyn::api::PageInfo_PageFormat >(_impl_.format_);
}
inline ::bosdyn::api::PageInfo_PageFormat PageInfo::format() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PageInfo.format)
  return _internal_format();
}
inline void PageInfo::_internal_set_format(::bosdyn::api::PageInfo_PageFormat value) {
  
  _impl_.format_ = value;
}
inline void PageInfo::set_format(::bosdyn::api::PageInfo_PageFormat value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PageInfo.format)
}

// .bosdyn.api.PageInfo.Compression compression = 8;
inline void PageInfo::clear_compression() {
  _impl_.compression_ = 0;
}
inline ::bosdyn::api::PageInfo_Compression PageInfo::_internal_compression() const {
  return static_cast< ::bosdyn::api::PageInfo_Compression >(_impl_.compression_);
}
inline ::bosdyn::api::PageInfo_Compression PageInfo::compression() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PageInfo.compression)
  return _internal_compression();
}
inline void PageInfo::_internal_set_compression(::bosdyn::api::PageInfo_Compression value) {
  
  _impl_.compression_ = value;
}
inline void PageInfo::set_compression(::bosdyn::api::PageInfo_Compression value) {
  _internal_set_compression(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PageInfo.compression)
}

// bool is_open = 9;
inline void PageInfo::clear_is_open() {
  _impl_.is_open_ = false;
}
inline bool PageInfo::_internal_is_open() const {
  return _impl_.is_open_;
}
inline bool PageInfo::is_open() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PageInfo.is_open)
  return _internal_is_open();
}
inline void PageInfo::_internal_set_is_open(bool value) {
  
  _impl_.is_open_ = value;
}
inline void PageInfo::set_is_open(bool value) {
  _internal_set_is_open(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PageInfo.is_open)
}

// bool is_downloaded = 10;
inline void PageInfo::clear_is_downloaded() {
  _impl_.is_downloaded_ = false;
}
inline bool PageInfo::_internal_is_downloaded() const {
  return _impl_.is_downloaded_;
}
inline bool PageInfo::is_downloaded() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PageInfo.is_downloaded)
  return _internal_is_downloaded();
}
inline void PageInfo::_internal_set_is_downloaded(bool value) {
  
  _impl_.is_downloaded_ = value;
}
inline void PageInfo::set_is_downloaded(bool value) {
  _internal_set_is_downloaded(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PageInfo.is_downloaded)
}

// .google.protobuf.Timestamp deleted_timestamp = 11;
inline bool PageInfo::_internal_has_deleted_timestamp() const {
  return this != internal_default_instance() && _impl_.deleted_timestamp_ != nullptr;
}
inline bool PageInfo::has_deleted_timestamp() const {
  return _internal_has_deleted_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PageInfo::_internal_deleted_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.deleted_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PageInfo::deleted_timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PageInfo.deleted_timestamp)
  return _internal_deleted_timestamp();
}
inline void PageInfo::unsafe_arena_set_allocated_deleted_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deleted_timestamp_);
  }
  _impl_.deleted_timestamp_ = deleted_timestamp;
  if (deleted_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PageInfo.deleted_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PageInfo::release_deleted_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deleted_timestamp_;
  _impl_.deleted_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PageInfo::unsafe_arena_release_deleted_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PageInfo.deleted_timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deleted_timestamp_;
  _impl_.deleted_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PageInfo::_internal_mutable_deleted_timestamp() {
  
  if (_impl_.deleted_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.deleted_timestamp_ = p;
  }
  return _impl_.deleted_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PageInfo::mutable_deleted_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_deleted_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PageInfo.deleted_timestamp)
  return _msg;
}
inline void PageInfo::set_allocated_deleted_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deleted_timestamp_);
  }
  if (deleted_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_timestamp));
    if (message_arena != submessage_arena) {
      deleted_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deleted_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.deleted_timestamp_ = deleted_timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PageInfo.deleted_timestamp)
}

// .google.protobuf.Timestamp download_started_timestamp = 12;
inline bool PageInfo::_internal_has_download_started_timestamp() const {
  return this != internal_default_instance() && _impl_.download_started_timestamp_ != nullptr;
}
inline bool PageInfo::has_download_started_timestamp() const {
  return _internal_has_download_started_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PageInfo::_internal_download_started_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.download_started_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PageInfo::download_started_timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PageInfo.download_started_timestamp)
  return _internal_download_started_timestamp();
}
inline void PageInfo::unsafe_arena_set_allocated_download_started_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* download_started_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.download_started_timestamp_);
  }
  _impl_.download_started_timestamp_ = download_started_timestamp;
  if (download_started_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PageInfo.download_started_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PageInfo::release_download_started_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.download_started_timestamp_;
  _impl_.download_started_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PageInfo::unsafe_arena_release_download_started_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PageInfo.download_started_timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.download_started_timestamp_;
  _impl_.download_started_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PageInfo::_internal_mutable_download_started_timestamp() {
  
  if (_impl_.download_started_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.download_started_timestamp_ = p;
  }
  return _impl_.download_started_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PageInfo::mutable_download_started_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_download_started_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PageInfo.download_started_timestamp)
  return _msg;
}
inline void PageInfo::set_allocated_download_started_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* download_started_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.download_started_timestamp_);
  }
  if (download_started_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(download_started_timestamp));
    if (message_arena != submessage_arena) {
      download_started_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, download_started_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.download_started_timestamp_ = download_started_timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PageInfo.download_started_timestamp)
}

// bool request_preserve = 13;
inline void PageInfo::clear_request_preserve() {
  _impl_.request_preserve_ = false;
}
inline bool PageInfo::_internal_request_preserve() const {
  return _impl_.request_preserve_;
}
inline bool PageInfo::request_preserve() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PageInfo.request_preserve)
  return _internal_request_preserve();
}
inline void PageInfo::_internal_set_request_preserve(bool value) {
  
  _impl_.request_preserve_ = value;
}
inline void PageInfo::set_request_preserve(bool value) {
  _internal_set_request_preserve(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PageInfo.request_preserve)
}

// -------------------------------------------------------------------

// GrpcPages

// .bosdyn.api.TimeRange time_range = 1;
inline bool GrpcPages::_internal_has_time_range() const {
  return this != internal_default_instance() && _impl_.time_range_ != nullptr;
}
inline bool GrpcPages::has_time_range() const {
  return _internal_has_time_range();
}
inline const ::bosdyn::api::TimeRange& GrpcPages::_internal_time_range() const {
  const ::bosdyn::api::TimeRange* p = _impl_.time_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::TimeRange&>(
      ::bosdyn::api::_TimeRange_default_instance_);
}
inline const ::bosdyn::api::TimeRange& GrpcPages::time_range() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GrpcPages.time_range)
  return _internal_time_range();
}
inline void GrpcPages::unsafe_arena_set_allocated_time_range(
    ::bosdyn::api::TimeRange* time_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  _impl_.time_range_ = time_range;
  if (time_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GrpcPages.time_range)
}
inline ::bosdyn::api::TimeRange* GrpcPages::release_time_range() {
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::TimeRange* GrpcPages::unsafe_arena_release_time_range() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GrpcPages.time_range)
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
  return temp;
}
inline ::bosdyn::api::TimeRange* GrpcPages::_internal_mutable_time_range() {
  
  if (_impl_.time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::TimeRange>(GetArenaForAllocation());
    _impl_.time_range_ = p;
  }
  return _impl_.time_range_;
}
inline ::bosdyn::api::TimeRange* GrpcPages::mutable_time_range() {
  ::bosdyn::api::TimeRange* _msg = _internal_mutable_time_range();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GrpcPages.time_range)
  return _msg;
}
inline void GrpcPages::set_allocated_time_range(::bosdyn::api::TimeRange* time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  if (time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range));
    if (message_arena != submessage_arena) {
      time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_range, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_range_ = time_range;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GrpcPages.time_range)
}

// .bosdyn.api.GrpcSpec spec = 2;
inline bool GrpcPages::_internal_has_spec() const {
  return this != internal_default_instance() && _impl_.spec_ != nullptr;
}
inline bool GrpcPages::has_spec() const {
  return _internal_has_spec();
}
inline void GrpcPages::clear_spec() {
  if (GetArenaForAllocation() == nullptr && _impl_.spec_ != nullptr) {
    delete _impl_.spec_;
  }
  _impl_.spec_ = nullptr;
}
inline const ::bosdyn::api::GrpcSpec& GrpcPages::_internal_spec() const {
  const ::bosdyn::api::GrpcSpec* p = _impl_.spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::GrpcSpec&>(
      ::bosdyn::api::_GrpcSpec_default_instance_);
}
inline const ::bosdyn::api::GrpcSpec& GrpcPages::spec() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GrpcPages.spec)
  return _internal_spec();
}
inline void GrpcPages::unsafe_arena_set_allocated_spec(
    ::bosdyn::api::GrpcSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spec_);
  }
  _impl_.spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GrpcPages.spec)
}
inline ::bosdyn::api::GrpcSpec* GrpcPages::release_spec() {
  
  ::bosdyn::api::GrpcSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::GrpcSpec* GrpcPages::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GrpcPages.spec)
  
  ::bosdyn::api::GrpcSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
  return temp;
}
inline ::bosdyn::api::GrpcSpec* GrpcPages::_internal_mutable_spec() {
  
  if (_impl_.spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::GrpcSpec>(GetArenaForAllocation());
    _impl_.spec_ = p;
  }
  return _impl_.spec_;
}
inline ::bosdyn::api::GrpcSpec* GrpcPages::mutable_spec() {
  ::bosdyn::api::GrpcSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GrpcPages.spec)
  return _msg;
}
inline void GrpcPages::set_allocated_spec(::bosdyn::api::GrpcSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GrpcPages.spec)
}

// repeated .bosdyn.api.PageInfo pages = 3;
inline int GrpcPages::_internal_pages_size() const {
  return _impl_.pages_.size();
}
inline int GrpcPages::pages_size() const {
  return _internal_pages_size();
}
inline void GrpcPages::clear_pages() {
  _impl_.pages_.Clear();
}
inline ::bosdyn::api::PageInfo* GrpcPages::mutable_pages(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GrpcPages.pages)
  return _impl_.pages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PageInfo >*
GrpcPages::mutable_pages() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.GrpcPages.pages)
  return &_impl_.pages_;
}
inline const ::bosdyn::api::PageInfo& GrpcPages::_internal_pages(int index) const {
  return _impl_.pages_.Get(index);
}
inline const ::bosdyn::api::PageInfo& GrpcPages::pages(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GrpcPages.pages)
  return _internal_pages(index);
}
inline ::bosdyn::api::PageInfo* GrpcPages::_internal_add_pages() {
  return _impl_.pages_.Add();
}
inline ::bosdyn::api::PageInfo* GrpcPages::add_pages() {
  ::bosdyn::api::PageInfo* _add = _internal_add_pages();
  // @@protoc_insertion_point(field_add:bosdyn.api.GrpcPages.pages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PageInfo >&
GrpcPages::pages() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.GrpcPages.pages)
  return _impl_.pages_;
}

// -------------------------------------------------------------------

// BlobPage

// .bosdyn.api.BlobSpec spec = 1;
inline bool BlobPage::_internal_has_spec() const {
  return this != internal_default_instance() && _impl_.spec_ != nullptr;
}
inline bool BlobPage::has_spec() const {
  return _internal_has_spec();
}
inline void BlobPage::clear_spec() {
  if (GetArenaForAllocation() == nullptr && _impl_.spec_ != nullptr) {
    delete _impl_.spec_;
  }
  _impl_.spec_ = nullptr;
}
inline const ::bosdyn::api::BlobSpec& BlobPage::_internal_spec() const {
  const ::bosdyn::api::BlobSpec* p = _impl_.spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::BlobSpec&>(
      ::bosdyn::api::_BlobSpec_default_instance_);
}
inline const ::bosdyn::api::BlobSpec& BlobPage::spec() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BlobPage.spec)
  return _internal_spec();
}
inline void BlobPage::unsafe_arena_set_allocated_spec(
    ::bosdyn::api::BlobSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spec_);
  }
  _impl_.spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.BlobPage.spec)
}
inline ::bosdyn::api::BlobSpec* BlobPage::release_spec() {
  
  ::bosdyn::api::BlobSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::BlobSpec* BlobPage::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BlobPage.spec)
  
  ::bosdyn::api::BlobSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
  return temp;
}
inline ::bosdyn::api::BlobSpec* BlobPage::_internal_mutable_spec() {
  
  if (_impl_.spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::BlobSpec>(GetArenaForAllocation());
    _impl_.spec_ = p;
  }
  return _impl_.spec_;
}
inline ::bosdyn::api::BlobSpec* BlobPage::mutable_spec() {
  ::bosdyn::api::BlobSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BlobPage.spec)
  return _msg;
}
inline void BlobPage::set_allocated_spec(::bosdyn::api::BlobSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BlobPage.spec)
}

// .bosdyn.api.PageInfo page = 2;
inline bool BlobPage::_internal_has_page() const {
  return this != internal_default_instance() && _impl_.page_ != nullptr;
}
inline bool BlobPage::has_page() const {
  return _internal_has_page();
}
inline void BlobPage::clear_page() {
  if (GetArenaForAllocation() == nullptr && _impl_.page_ != nullptr) {
    delete _impl_.page_;
  }
  _impl_.page_ = nullptr;
}
inline const ::bosdyn::api::PageInfo& BlobPage::_internal_page() const {
  const ::bosdyn::api::PageInfo* p = _impl_.page_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::PageInfo&>(
      ::bosdyn::api::_PageInfo_default_instance_);
}
inline const ::bosdyn::api::PageInfo& BlobPage::page() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BlobPage.page)
  return _internal_page();
}
inline void BlobPage::unsafe_arena_set_allocated_page(
    ::bosdyn::api::PageInfo* page) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.page_);
  }
  _impl_.page_ = page;
  if (page) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.BlobPage.page)
}
inline ::bosdyn::api::PageInfo* BlobPage::release_page() {
  
  ::bosdyn::api::PageInfo* temp = _impl_.page_;
  _impl_.page_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::PageInfo* BlobPage::unsafe_arena_release_page() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BlobPage.page)
  
  ::bosdyn::api::PageInfo* temp = _impl_.page_;
  _impl_.page_ = nullptr;
  return temp;
}
inline ::bosdyn::api::PageInfo* BlobPage::_internal_mutable_page() {
  
  if (_impl_.page_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::PageInfo>(GetArenaForAllocation());
    _impl_.page_ = p;
  }
  return _impl_.page_;
}
inline ::bosdyn::api::PageInfo* BlobPage::mutable_page() {
  ::bosdyn::api::PageInfo* _msg = _internal_mutable_page();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BlobPage.page)
  return _msg;
}
inline void BlobPage::set_allocated_page(::bosdyn::api::PageInfo* page) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.page_;
  }
  if (page) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(page);
    if (message_arena != submessage_arena) {
      page = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, page, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.page_ = page;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BlobPage.page)
}

// -------------------------------------------------------------------

// BlobPages

// .bosdyn.api.TimeRange time_range = 1;
inline bool BlobPages::_internal_has_time_range() const {
  return this != internal_default_instance() && _impl_.time_range_ != nullptr;
}
inline bool BlobPages::has_time_range() const {
  return _internal_has_time_range();
}
inline const ::bosdyn::api::TimeRange& BlobPages::_internal_time_range() const {
  const ::bosdyn::api::TimeRange* p = _impl_.time_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::TimeRange&>(
      ::bosdyn::api::_TimeRange_default_instance_);
}
inline const ::bosdyn::api::TimeRange& BlobPages::time_range() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BlobPages.time_range)
  return _internal_time_range();
}
inline void BlobPages::unsafe_arena_set_allocated_time_range(
    ::bosdyn::api::TimeRange* time_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  _impl_.time_range_ = time_range;
  if (time_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.BlobPages.time_range)
}
inline ::bosdyn::api::TimeRange* BlobPages::release_time_range() {
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::TimeRange* BlobPages::unsafe_arena_release_time_range() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BlobPages.time_range)
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
  return temp;
}
inline ::bosdyn::api::TimeRange* BlobPages::_internal_mutable_time_range() {
  
  if (_impl_.time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::TimeRange>(GetArenaForAllocation());
    _impl_.time_range_ = p;
  }
  return _impl_.time_range_;
}
inline ::bosdyn::api::TimeRange* BlobPages::mutable_time_range() {
  ::bosdyn::api::TimeRange* _msg = _internal_mutable_time_range();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BlobPages.time_range)
  return _msg;
}
inline void BlobPages::set_allocated_time_range(::bosdyn::api::TimeRange* time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  if (time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range));
    if (message_arena != submessage_arena) {
      time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_range, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_range_ = time_range;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BlobPages.time_range)
}

// repeated .bosdyn.api.BlobPage pages = 3;
inline int BlobPages::_internal_pages_size() const {
  return _impl_.pages_.size();
}
inline int BlobPages::pages_size() const {
  return _internal_pages_size();
}
inline void BlobPages::clear_pages() {
  _impl_.pages_.Clear();
}
inline ::bosdyn::api::BlobPage* BlobPages::mutable_pages(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BlobPages.pages)
  return _impl_.pages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobPage >*
BlobPages::mutable_pages() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.BlobPages.pages)
  return &_impl_.pages_;
}
inline const ::bosdyn::api::BlobPage& BlobPages::_internal_pages(int index) const {
  return _impl_.pages_.Get(index);
}
inline const ::bosdyn::api::BlobPage& BlobPages::pages(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BlobPages.pages)
  return _internal_pages(index);
}
inline ::bosdyn::api::BlobPage* BlobPages::_internal_add_pages() {
  return _impl_.pages_.Add();
}
inline ::bosdyn::api::BlobPage* BlobPages::add_pages() {
  ::bosdyn::api::BlobPage* _add = _internal_add_pages();
  // @@protoc_insertion_point(field_add:bosdyn.api.BlobPages.pages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobPage >&
BlobPages::pages() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.BlobPages.pages)
  return _impl_.pages_;
}

// -------------------------------------------------------------------

// PagesAndTimestamp

// .bosdyn.api.TimeRange time_range = 1;
inline bool PagesAndTimestamp::_internal_has_time_range() const {
  return this != internal_default_instance() && _impl_.time_range_ != nullptr;
}
inline bool PagesAndTimestamp::has_time_range() const {
  return _internal_has_time_range();
}
inline const ::bosdyn::api::TimeRange& PagesAndTimestamp::_internal_time_range() const {
  const ::bosdyn::api::TimeRange* p = _impl_.time_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::TimeRange&>(
      ::bosdyn::api::_TimeRange_default_instance_);
}
inline const ::bosdyn::api::TimeRange& PagesAndTimestamp::time_range() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PagesAndTimestamp.time_range)
  return _internal_time_range();
}
inline void PagesAndTimestamp::unsafe_arena_set_allocated_time_range(
    ::bosdyn::api::TimeRange* time_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  _impl_.time_range_ = time_range;
  if (time_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PagesAndTimestamp.time_range)
}
inline ::bosdyn::api::TimeRange* PagesAndTimestamp::release_time_range() {
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::TimeRange* PagesAndTimestamp::unsafe_arena_release_time_range() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PagesAndTimestamp.time_range)
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
  return temp;
}
inline ::bosdyn::api::TimeRange* PagesAndTimestamp::_internal_mutable_time_range() {
  
  if (_impl_.time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::TimeRange>(GetArenaForAllocation());
    _impl_.time_range_ = p;
  }
  return _impl_.time_range_;
}
inline ::bosdyn::api::TimeRange* PagesAndTimestamp::mutable_time_range() {
  ::bosdyn::api::TimeRange* _msg = _internal_mutable_time_range();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PagesAndTimestamp.time_range)
  return _msg;
}
inline void PagesAndTimestamp::set_allocated_time_range(::bosdyn::api::TimeRange* time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  if (time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range));
    if (message_arena != submessage_arena) {
      time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_range, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_range_ = time_range;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PagesAndTimestamp.time_range)
}

// repeated .bosdyn.api.PageInfo pages = 2;
inline int PagesAndTimestamp::_internal_pages_size() const {
  return _impl_.pages_.size();
}
inline int PagesAndTimestamp::pages_size() const {
  return _internal_pages_size();
}
inline void PagesAndTimestamp::clear_pages() {
  _impl_.pages_.Clear();
}
inline ::bosdyn::api::PageInfo* PagesAndTimestamp::mutable_pages(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PagesAndTimestamp.pages)
  return _impl_.pages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PageInfo >*
PagesAndTimestamp::mutable_pages() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.PagesAndTimestamp.pages)
  return &_impl_.pages_;
}
inline const ::bosdyn::api::PageInfo& PagesAndTimestamp::_internal_pages(int index) const {
  return _impl_.pages_.Get(index);
}
inline const ::bosdyn::api::PageInfo& PagesAndTimestamp::pages(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PagesAndTimestamp.pages)
  return _internal_pages(index);
}
inline ::bosdyn::api::PageInfo* PagesAndTimestamp::_internal_add_pages() {
  return _impl_.pages_.Add();
}
inline ::bosdyn::api::PageInfo* PagesAndTimestamp::add_pages() {
  ::bosdyn::api::PageInfo* _add = _internal_add_pages();
  // @@protoc_insertion_point(field_add:bosdyn.api.PagesAndTimestamp.pages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PageInfo >&
PagesAndTimestamp::pages() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.PagesAndTimestamp.pages)
  return _impl_.pages_;
}

// -------------------------------------------------------------------

// DataQuery

// .bosdyn.api.TimeRange time_range = 1;
inline bool DataQuery::_internal_has_time_range() const {
  return this != internal_default_instance() && _impl_.time_range_ != nullptr;
}
inline bool DataQuery::has_time_range() const {
  return _internal_has_time_range();
}
inline const ::bosdyn::api::TimeRange& DataQuery::_internal_time_range() const {
  const ::bosdyn::api::TimeRange* p = _impl_.time_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::TimeRange&>(
      ::bosdyn::api::_TimeRange_default_instance_);
}
inline const ::bosdyn::api::TimeRange& DataQuery::time_range() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataQuery.time_range)
  return _internal_time_range();
}
inline void DataQuery::unsafe_arena_set_allocated_time_range(
    ::bosdyn::api::TimeRange* time_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  _impl_.time_range_ = time_range;
  if (time_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DataQuery.time_range)
}
inline ::bosdyn::api::TimeRange* DataQuery::release_time_range() {
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::TimeRange* DataQuery::unsafe_arena_release_time_range() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataQuery.time_range)
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
  return temp;
}
inline ::bosdyn::api::TimeRange* DataQuery::_internal_mutable_time_range() {
  
  if (_impl_.time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::TimeRange>(GetArenaForAllocation());
    _impl_.time_range_ = p;
  }
  return _impl_.time_range_;
}
inline ::bosdyn::api::TimeRange* DataQuery::mutable_time_range() {
  ::bosdyn::api::TimeRange* _msg = _internal_mutable_time_range();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataQuery.time_range)
  return _msg;
}
inline void DataQuery::set_allocated_time_range(::bosdyn::api::TimeRange* time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  if (time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range));
    if (message_arena != submessage_arena) {
      time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_range, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_range_ = time_range;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataQuery.time_range)
}

// repeated .bosdyn.api.BlobSpec blobs = 2;
inline int DataQuery::_internal_blobs_size() const {
  return _impl_.blobs_.size();
}
inline int DataQuery::blobs_size() const {
  return _internal_blobs_size();
}
inline void DataQuery::clear_blobs() {
  _impl_.blobs_.Clear();
}
inline ::bosdyn::api::BlobSpec* DataQuery::mutable_blobs(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataQuery.blobs)
  return _impl_.blobs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobSpec >*
DataQuery::mutable_blobs() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.DataQuery.blobs)
  return &_impl_.blobs_;
}
inline const ::bosdyn::api::BlobSpec& DataQuery::_internal_blobs(int index) const {
  return _impl_.blobs_.Get(index);
}
inline const ::bosdyn::api::BlobSpec& DataQuery::blobs(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataQuery.blobs)
  return _internal_blobs(index);
}
inline ::bosdyn::api::BlobSpec* DataQuery::_internal_add_blobs() {
  return _impl_.blobs_.Add();
}
inline ::bosdyn::api::BlobSpec* DataQuery::add_blobs() {
  ::bosdyn::api::BlobSpec* _add = _internal_add_blobs();
  // @@protoc_insertion_point(field_add:bosdyn.api.DataQuery.blobs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobSpec >&
DataQuery::blobs() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.DataQuery.blobs)
  return _impl_.blobs_;
}

// bool text_messages = 3;
inline void DataQuery::clear_text_messages() {
  _impl_.text_messages_ = false;
}
inline bool DataQuery::_internal_text_messages() const {
  return _impl_.text_messages_;
}
inline bool DataQuery::text_messages() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataQuery.text_messages)
  return _internal_text_messages();
}
inline void DataQuery::_internal_set_text_messages(bool value) {
  
  _impl_.text_messages_ = value;
}
inline void DataQuery::set_text_messages(bool value) {
  _internal_set_text_messages(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DataQuery.text_messages)
}

// bool events = 4;
inline void DataQuery::clear_events() {
  _impl_.events_ = false;
}
inline bool DataQuery::_internal_events() const {
  return _impl_.events_;
}
inline bool DataQuery::events() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataQuery.events)
  return _internal_events();
}
inline void DataQuery::_internal_set_events(bool value) {
  
  _impl_.events_ = value;
}
inline void DataQuery::set_events(bool value) {
  _internal_set_events(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DataQuery.events)
}

// bool comments = 6;
inline void DataQuery::clear_comments() {
  _impl_.comments_ = false;
}
inline bool DataQuery::_internal_comments() const {
  return _impl_.comments_;
}
inline bool DataQuery::comments() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataQuery.comments)
  return _internal_comments();
}
inline void DataQuery::_internal_set_comments(bool value) {
  
  _impl_.comments_ = value;
}
inline void DataQuery::set_comments(bool value) {
  _internal_set_comments(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DataQuery.comments)
}

// -------------------------------------------------------------------

// DataIndex

// .bosdyn.api.TimeRange time_range = 1;
inline bool DataIndex::_internal_has_time_range() const {
  return this != internal_default_instance() && _impl_.time_range_ != nullptr;
}
inline bool DataIndex::has_time_range() const {
  return _internal_has_time_range();
}
inline const ::bosdyn::api::TimeRange& DataIndex::_internal_time_range() const {
  const ::bosdyn::api::TimeRange* p = _impl_.time_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::TimeRange&>(
      ::bosdyn::api::_TimeRange_default_instance_);
}
inline const ::bosdyn::api::TimeRange& DataIndex::time_range() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataIndex.time_range)
  return _internal_time_range();
}
inline void DataIndex::unsafe_arena_set_allocated_time_range(
    ::bosdyn::api::TimeRange* time_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  _impl_.time_range_ = time_range;
  if (time_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DataIndex.time_range)
}
inline ::bosdyn::api::TimeRange* DataIndex::release_time_range() {
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::TimeRange* DataIndex::unsafe_arena_release_time_range() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataIndex.time_range)
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
  return temp;
}
inline ::bosdyn::api::TimeRange* DataIndex::_internal_mutable_time_range() {
  
  if (_impl_.time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::TimeRange>(GetArenaForAllocation());
    _impl_.time_range_ = p;
  }
  return _impl_.time_range_;
}
inline ::bosdyn::api::TimeRange* DataIndex::mutable_time_range() {
  ::bosdyn::api::TimeRange* _msg = _internal_mutable_time_range();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataIndex.time_range)
  return _msg;
}
inline void DataIndex::set_allocated_time_range(::bosdyn::api::TimeRange* time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  if (time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range));
    if (message_arena != submessage_arena) {
      time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_range, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_range_ = time_range;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataIndex.time_range)
}

// repeated .bosdyn.api.BlobPages blobs = 2;
inline int DataIndex::_internal_blobs_size() const {
  return _impl_.blobs_.size();
}
inline int DataIndex::blobs_size() const {
  return _internal_blobs_size();
}
inline void DataIndex::clear_blobs() {
  _impl_.blobs_.Clear();
}
inline ::bosdyn::api::BlobPages* DataIndex::mutable_blobs(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataIndex.blobs)
  return _impl_.blobs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobPages >*
DataIndex::mutable_blobs() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.DataIndex.blobs)
  return &_impl_.blobs_;
}
inline const ::bosdyn::api::BlobPages& DataIndex::_internal_blobs(int index) const {
  return _impl_.blobs_.Get(index);
}
inline const ::bosdyn::api::BlobPages& DataIndex::blobs(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataIndex.blobs)
  return _internal_blobs(index);
}
inline ::bosdyn::api::BlobPages* DataIndex::_internal_add_blobs() {
  return _impl_.blobs_.Add();
}
inline ::bosdyn::api::BlobPages* DataIndex::add_blobs() {
  ::bosdyn::api::BlobPages* _add = _internal_add_blobs();
  // @@protoc_insertion_point(field_add:bosdyn.api.DataIndex.blobs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobPages >&
DataIndex::blobs() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.DataIndex.blobs)
  return _impl_.blobs_;
}

// .bosdyn.api.PagesAndTimestamp text_messages = 3;
inline bool DataIndex::_internal_has_text_messages() const {
  return this != internal_default_instance() && _impl_.text_messages_ != nullptr;
}
inline bool DataIndex::has_text_messages() const {
  return _internal_has_text_messages();
}
inline void DataIndex::clear_text_messages() {
  if (GetArenaForAllocation() == nullptr && _impl_.text_messages_ != nullptr) {
    delete _impl_.text_messages_;
  }
  _impl_.text_messages_ = nullptr;
}
inline const ::bosdyn::api::PagesAndTimestamp& DataIndex::_internal_text_messages() const {
  const ::bosdyn::api::PagesAndTimestamp* p = _impl_.text_messages_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::PagesAndTimestamp&>(
      ::bosdyn::api::_PagesAndTimestamp_default_instance_);
}
inline const ::bosdyn::api::PagesAndTimestamp& DataIndex::text_messages() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataIndex.text_messages)
  return _internal_text_messages();
}
inline void DataIndex::unsafe_arena_set_allocated_text_messages(
    ::bosdyn::api::PagesAndTimestamp* text_messages) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.text_messages_);
  }
  _impl_.text_messages_ = text_messages;
  if (text_messages) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DataIndex.text_messages)
}
inline ::bosdyn::api::PagesAndTimestamp* DataIndex::release_text_messages() {
  
  ::bosdyn::api::PagesAndTimestamp* temp = _impl_.text_messages_;
  _impl_.text_messages_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::PagesAndTimestamp* DataIndex::unsafe_arena_release_text_messages() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataIndex.text_messages)
  
  ::bosdyn::api::PagesAndTimestamp* temp = _impl_.text_messages_;
  _impl_.text_messages_ = nullptr;
  return temp;
}
inline ::bosdyn::api::PagesAndTimestamp* DataIndex::_internal_mutable_text_messages() {
  
  if (_impl_.text_messages_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::PagesAndTimestamp>(GetArenaForAllocation());
    _impl_.text_messages_ = p;
  }
  return _impl_.text_messages_;
}
inline ::bosdyn::api::PagesAndTimestamp* DataIndex::mutable_text_messages() {
  ::bosdyn::api::PagesAndTimestamp* _msg = _internal_mutable_text_messages();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataIndex.text_messages)
  return _msg;
}
inline void DataIndex::set_allocated_text_messages(::bosdyn::api::PagesAndTimestamp* text_messages) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.text_messages_;
  }
  if (text_messages) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_messages);
    if (message_arena != submessage_arena) {
      text_messages = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_messages, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.text_messages_ = text_messages;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataIndex.text_messages)
}

// .bosdyn.api.PagesAndTimestamp events = 4;
inline bool DataIndex::_internal_has_events() const {
  return this != internal_default_instance() && _impl_.events_ != nullptr;
}
inline bool DataIndex::has_events() const {
  return _internal_has_events();
}
inline void DataIndex::clear_events() {
  if (GetArenaForAllocation() == nullptr && _impl_.events_ != nullptr) {
    delete _impl_.events_;
  }
  _impl_.events_ = nullptr;
}
inline const ::bosdyn::api::PagesAndTimestamp& DataIndex::_internal_events() const {
  const ::bosdyn::api::PagesAndTimestamp* p = _impl_.events_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::PagesAndTimestamp&>(
      ::bosdyn::api::_PagesAndTimestamp_default_instance_);
}
inline const ::bosdyn::api::PagesAndTimestamp& DataIndex::events() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataIndex.events)
  return _internal_events();
}
inline void DataIndex::unsafe_arena_set_allocated_events(
    ::bosdyn::api::PagesAndTimestamp* events) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.events_);
  }
  _impl_.events_ = events;
  if (events) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DataIndex.events)
}
inline ::bosdyn::api::PagesAndTimestamp* DataIndex::release_events() {
  
  ::bosdyn::api::PagesAndTimestamp* temp = _impl_.events_;
  _impl_.events_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::PagesAndTimestamp* DataIndex::unsafe_arena_release_events() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataIndex.events)
  
  ::bosdyn::api::PagesAndTimestamp* temp = _impl_.events_;
  _impl_.events_ = nullptr;
  return temp;
}
inline ::bosdyn::api::PagesAndTimestamp* DataIndex::_internal_mutable_events() {
  
  if (_impl_.events_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::PagesAndTimestamp>(GetArenaForAllocation());
    _impl_.events_ = p;
  }
  return _impl_.events_;
}
inline ::bosdyn::api::PagesAndTimestamp* DataIndex::mutable_events() {
  ::bosdyn::api::PagesAndTimestamp* _msg = _internal_mutable_events();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataIndex.events)
  return _msg;
}
inline void DataIndex::set_allocated_events(::bosdyn::api::PagesAndTimestamp* events) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.events_;
  }
  if (events) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(events);
    if (message_arena != submessage_arena) {
      events = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, events, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.events_ = events;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataIndex.events)
}

// .bosdyn.api.PagesAndTimestamp comments = 6;
inline bool DataIndex::_internal_has_comments() const {
  return this != internal_default_instance() && _impl_.comments_ != nullptr;
}
inline bool DataIndex::has_comments() const {
  return _internal_has_comments();
}
inline void DataIndex::clear_comments() {
  if (GetArenaForAllocation() == nullptr && _impl_.comments_ != nullptr) {
    delete _impl_.comments_;
  }
  _impl_.comments_ = nullptr;
}
inline const ::bosdyn::api::PagesAndTimestamp& DataIndex::_internal_comments() const {
  const ::bosdyn::api::PagesAndTimestamp* p = _impl_.comments_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::PagesAndTimestamp&>(
      ::bosdyn::api::_PagesAndTimestamp_default_instance_);
}
inline const ::bosdyn::api::PagesAndTimestamp& DataIndex::comments() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataIndex.comments)
  return _internal_comments();
}
inline void DataIndex::unsafe_arena_set_allocated_comments(
    ::bosdyn::api::PagesAndTimestamp* comments) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.comments_);
  }
  _impl_.comments_ = comments;
  if (comments) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DataIndex.comments)
}
inline ::bosdyn::api::PagesAndTimestamp* DataIndex::release_comments() {
  
  ::bosdyn::api::PagesAndTimestamp* temp = _impl_.comments_;
  _impl_.comments_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::PagesAndTimestamp* DataIndex::unsafe_arena_release_comments() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DataIndex.comments)
  
  ::bosdyn::api::PagesAndTimestamp* temp = _impl_.comments_;
  _impl_.comments_ = nullptr;
  return temp;
}
inline ::bosdyn::api::PagesAndTimestamp* DataIndex::_internal_mutable_comments() {
  
  if (_impl_.comments_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::PagesAndTimestamp>(GetArenaForAllocation());
    _impl_.comments_ = p;
  }
  return _impl_.comments_;
}
inline ::bosdyn::api::PagesAndTimestamp* DataIndex::mutable_comments() {
  ::bosdyn::api::PagesAndTimestamp* _msg = _internal_mutable_comments();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataIndex.comments)
  return _msg;
}
inline void DataIndex::set_allocated_comments(::bosdyn::api::PagesAndTimestamp* comments) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.comments_;
  }
  if (comments) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(comments);
    if (message_arena != submessage_arena) {
      comments = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, comments, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.comments_ = comments;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DataIndex.comments)
}

// -------------------------------------------------------------------

// EventsCommentsSpec

// .bosdyn.api.TimeRange time_range = 1;
inline bool EventsCommentsSpec::_internal_has_time_range() const {
  return this != internal_default_instance() && _impl_.time_range_ != nullptr;
}
inline bool EventsCommentsSpec::has_time_range() const {
  return _internal_has_time_range();
}
inline const ::bosdyn::api::TimeRange& EventsCommentsSpec::_internal_time_range() const {
  const ::bosdyn::api::TimeRange* p = _impl_.time_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::TimeRange&>(
      ::bosdyn::api::_TimeRange_default_instance_);
}
inline const ::bosdyn::api::TimeRange& EventsCommentsSpec::time_range() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EventsCommentsSpec.time_range)
  return _internal_time_range();
}
inline void EventsCommentsSpec::unsafe_arena_set_allocated_time_range(
    ::bosdyn::api::TimeRange* time_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  _impl_.time_range_ = time_range;
  if (time_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EventsCommentsSpec.time_range)
}
inline ::bosdyn::api::TimeRange* EventsCommentsSpec::release_time_range() {
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::TimeRange* EventsCommentsSpec::unsafe_arena_release_time_range() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EventsCommentsSpec.time_range)
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
  return temp;
}
inline ::bosdyn::api::TimeRange* EventsCommentsSpec::_internal_mutable_time_range() {
  
  if (_impl_.time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::TimeRange>(GetArenaForAllocation());
    _impl_.time_range_ = p;
  }
  return _impl_.time_range_;
}
inline ::bosdyn::api::TimeRange* EventsCommentsSpec::mutable_time_range() {
  ::bosdyn::api::TimeRange* _msg = _internal_mutable_time_range();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EventsCommentsSpec.time_range)
  return _msg;
}
inline void EventsCommentsSpec::set_allocated_time_range(::bosdyn::api::TimeRange* time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  if (time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range));
    if (message_arena != submessage_arena) {
      time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_range, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_range_ = time_range;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EventsCommentsSpec.time_range)
}

// repeated .bosdyn.api.EventSpec events = 2;
inline int EventsCommentsSpec::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int EventsCommentsSpec::events_size() const {
  return _internal_events_size();
}
inline void EventsCommentsSpec::clear_events() {
  _impl_.events_.Clear();
}
inline ::bosdyn::api::EventSpec* EventsCommentsSpec::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EventsCommentsSpec.events)
  return _impl_.events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EventSpec >*
EventsCommentsSpec::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.EventsCommentsSpec.events)
  return &_impl_.events_;
}
inline const ::bosdyn::api::EventSpec& EventsCommentsSpec::_internal_events(int index) const {
  return _impl_.events_.Get(index);
}
inline const ::bosdyn::api::EventSpec& EventsCommentsSpec::events(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EventsCommentsSpec.events)
  return _internal_events(index);
}
inline ::bosdyn::api::EventSpec* EventsCommentsSpec::_internal_add_events() {
  return _impl_.events_.Add();
}
inline ::bosdyn::api::EventSpec* EventsCommentsSpec::add_events() {
  ::bosdyn::api::EventSpec* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:bosdyn.api.EventsCommentsSpec.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EventSpec >&
EventsCommentsSpec::events() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.EventsCommentsSpec.events)
  return _impl_.events_;
}

// bool comments = 3;
inline void EventsCommentsSpec::clear_comments() {
  _impl_.comments_ = false;
}
inline bool EventsCommentsSpec::_internal_comments() const {
  return _impl_.comments_;
}
inline bool EventsCommentsSpec::comments() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EventsCommentsSpec.comments)
  return _internal_comments();
}
inline void EventsCommentsSpec::_internal_set_comments(bool value) {
  
  _impl_.comments_ = value;
}
inline void EventsCommentsSpec::set_comments(bool value) {
  _internal_set_comments(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EventsCommentsSpec.comments)
}

// uint32 max_events = 4;
inline void EventsCommentsSpec::clear_max_events() {
  _impl_.max_events_ = 0u;
}
inline uint32_t EventsCommentsSpec::_internal_max_events() const {
  return _impl_.max_events_;
}
inline uint32_t EventsCommentsSpec::max_events() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EventsCommentsSpec.max_events)
  return _internal_max_events();
}
inline void EventsCommentsSpec::_internal_set_max_events(uint32_t value) {
  
  _impl_.max_events_ = value;
}
inline void EventsCommentsSpec::set_max_events(uint32_t value) {
  _internal_set_max_events(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EventsCommentsSpec.max_events)
}

// uint32 max_comments = 5;
inline void EventsCommentsSpec::clear_max_comments() {
  _impl_.max_comments_ = 0u;
}
inline uint32_t EventsCommentsSpec::_internal_max_comments() const {
  return _impl_.max_comments_;
}
inline uint32_t EventsCommentsSpec::max_comments() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EventsCommentsSpec.max_comments)
  return _internal_max_comments();
}
inline void EventsCommentsSpec::_internal_set_max_comments(uint32_t value) {
  
  _impl_.max_comments_ = value;
}
inline void EventsCommentsSpec::set_max_comments(uint32_t value) {
  _internal_set_max_comments(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EventsCommentsSpec.max_comments)
}

// -------------------------------------------------------------------

// EventsComments

// .bosdyn.api.TimeRange time_range = 1;
inline bool EventsComments::_internal_has_time_range() const {
  return this != internal_default_instance() && _impl_.time_range_ != nullptr;
}
inline bool EventsComments::has_time_range() const {
  return _internal_has_time_range();
}
inline const ::bosdyn::api::TimeRange& EventsComments::_internal_time_range() const {
  const ::bosdyn::api::TimeRange* p = _impl_.time_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::TimeRange&>(
      ::bosdyn::api::_TimeRange_default_instance_);
}
inline const ::bosdyn::api::TimeRange& EventsComments::time_range() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EventsComments.time_range)
  return _internal_time_range();
}
inline void EventsComments::unsafe_arena_set_allocated_time_range(
    ::bosdyn::api::TimeRange* time_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  _impl_.time_range_ = time_range;
  if (time_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EventsComments.time_range)
}
inline ::bosdyn::api::TimeRange* EventsComments::release_time_range() {
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::TimeRange* EventsComments::unsafe_arena_release_time_range() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EventsComments.time_range)
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
  return temp;
}
inline ::bosdyn::api::TimeRange* EventsComments::_internal_mutable_time_range() {
  
  if (_impl_.time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::TimeRange>(GetArenaForAllocation());
    _impl_.time_range_ = p;
  }
  return _impl_.time_range_;
}
inline ::bosdyn::api::TimeRange* EventsComments::mutable_time_range() {
  ::bosdyn::api::TimeRange* _msg = _internal_mutable_time_range();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EventsComments.time_range)
  return _msg;
}
inline void EventsComments::set_allocated_time_range(::bosdyn::api::TimeRange* time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  if (time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range));
    if (message_arena != submessage_arena) {
      time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_range, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_range_ = time_range;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EventsComments.time_range)
}

// repeated .bosdyn.api.Event events = 2;
inline int EventsComments::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int EventsComments::events_size() const {
  return _internal_events_size();
}
inline ::bosdyn::api::Event* EventsComments::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EventsComments.events)
  return _impl_.events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Event >*
EventsComments::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.EventsComments.events)
  return &_impl_.events_;
}
inline const ::bosdyn::api::Event& EventsComments::_internal_events(int index) const {
  return _impl_.events_.Get(index);
}
inline const ::bosdyn::api::Event& EventsComments::events(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EventsComments.events)
  return _internal_events(index);
}
inline ::bosdyn::api::Event* EventsComments::_internal_add_events() {
  return _impl_.events_.Add();
}
inline ::bosdyn::api::Event* EventsComments::add_events() {
  ::bosdyn::api::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:bosdyn.api.EventsComments.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Event >&
EventsComments::events() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.EventsComments.events)
  return _impl_.events_;
}

// repeated .bosdyn.api.OperatorComment operator_comments = 3;
inline int EventsComments::_internal_operator_comments_size() const {
  return _impl_.operator_comments_.size();
}
inline int EventsComments::operator_comments_size() const {
  return _internal_operator_comments_size();
}
inline ::bosdyn::api::OperatorComment* EventsComments::mutable_operator_comments(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EventsComments.operator_comments)
  return _impl_.operator_comments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::OperatorComment >*
EventsComments::mutable_operator_comments() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.EventsComments.operator_comments)
  return &_impl_.operator_comments_;
}
inline const ::bosdyn::api::OperatorComment& EventsComments::_internal_operator_comments(int index) const {
  return _impl_.operator_comments_.Get(index);
}
inline const ::bosdyn::api::OperatorComment& EventsComments::operator_comments(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EventsComments.operator_comments)
  return _internal_operator_comments(index);
}
inline ::bosdyn::api::OperatorComment* EventsComments::_internal_add_operator_comments() {
  return _impl_.operator_comments_.Add();
}
inline ::bosdyn::api::OperatorComment* EventsComments::add_operator_comments() {
  ::bosdyn::api::OperatorComment* _add = _internal_add_operator_comments();
  // @@protoc_insertion_point(field_add:bosdyn.api.EventsComments.operator_comments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::OperatorComment >&
EventsComments::operator_comments() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.EventsComments.operator_comments)
  return _impl_.operator_comments_;
}

// bool events_limited = 4;
inline void EventsComments::clear_events_limited() {
  _impl_.events_limited_ = false;
}
inline bool EventsComments::_internal_events_limited() const {
  return _impl_.events_limited_;
}
inline bool EventsComments::events_limited() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EventsComments.events_limited)
  return _internal_events_limited();
}
inline void EventsComments::_internal_set_events_limited(bool value) {
  
  _impl_.events_limited_ = value;
}
inline void EventsComments::set_events_limited(bool value) {
  _internal_set_events_limited(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EventsComments.events_limited)
}

// bool operator_comments_limited = 5;
inline void EventsComments::clear_operator_comments_limited() {
  _impl_.operator_comments_limited_ = false;
}
inline bool EventsComments::_internal_operator_comments_limited() const {
  return _impl_.operator_comments_limited_;
}
inline bool EventsComments::operator_comments_limited() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EventsComments.operator_comments_limited)
  return _internal_operator_comments_limited();
}
inline void EventsComments::_internal_set_operator_comments_limited(bool value) {
  
  _impl_.operator_comments_limited_ = value;
}
inline void EventsComments::set_operator_comments_limited(bool value) {
  _internal_set_operator_comments_limited(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EventsComments.operator_comments_limited)
}

// -------------------------------------------------------------------

// DataBufferStatus

// int64 num_data_buffer_pages = 1;
inline void DataBufferStatus::clear_num_data_buffer_pages() {
  _impl_.num_data_buffer_pages_ = int64_t{0};
}
inline int64_t DataBufferStatus::_internal_num_data_buffer_pages() const {
  return _impl_.num_data_buffer_pages_;
}
inline int64_t DataBufferStatus::num_data_buffer_pages() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataBufferStatus.num_data_buffer_pages)
  return _internal_num_data_buffer_pages();
}
inline void DataBufferStatus::_internal_set_num_data_buffer_pages(int64_t value) {
  
  _impl_.num_data_buffer_pages_ = value;
}
inline void DataBufferStatus::set_num_data_buffer_pages(int64_t value) {
  _internal_set_num_data_buffer_pages(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DataBufferStatus.num_data_buffer_pages)
}

// int64 data_buffer_total_bytes = 2;
inline void DataBufferStatus::clear_data_buffer_total_bytes() {
  _impl_.data_buffer_total_bytes_ = int64_t{0};
}
inline int64_t DataBufferStatus::_internal_data_buffer_total_bytes() const {
  return _impl_.data_buffer_total_bytes_;
}
inline int64_t DataBufferStatus::data_buffer_total_bytes() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataBufferStatus.data_buffer_total_bytes)
  return _internal_data_buffer_total_bytes();
}
inline void DataBufferStatus::_internal_set_data_buffer_total_bytes(int64_t value) {
  
  _impl_.data_buffer_total_bytes_ = value;
}
inline void DataBufferStatus::set_data_buffer_total_bytes(int64_t value) {
  _internal_set_data_buffer_total_bytes(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DataBufferStatus.data_buffer_total_bytes)
}

// int64 num_comments = 3;
inline void DataBufferStatus::clear_num_comments() {
  _impl_.num_comments_ = int64_t{0};
}
inline int64_t DataBufferStatus::_internal_num_comments() const {
  return _impl_.num_comments_;
}
inline int64_t DataBufferStatus::num_comments() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataBufferStatus.num_comments)
  return _internal_num_comments();
}
inline void DataBufferStatus::_internal_set_num_comments(int64_t value) {
  
  _impl_.num_comments_ = value;
}
inline void DataBufferStatus::set_num_comments(int64_t value) {
  _internal_set_num_comments(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DataBufferStatus.num_comments)
}

// int64 num_events = 4;
inline void DataBufferStatus::clear_num_events() {
  _impl_.num_events_ = int64_t{0};
}
inline int64_t DataBufferStatus::_internal_num_events() const {
  return _impl_.num_events_;
}
inline int64_t DataBufferStatus::num_events() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataBufferStatus.num_events)
  return _internal_num_events();
}
inline void DataBufferStatus::_internal_set_num_events(int64_t value) {
  
  _impl_.num_events_ = value;
}
inline void DataBufferStatus::set_num_events(int64_t value) {
  _internal_set_num_events(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DataBufferStatus.num_events)
}

// repeated .bosdyn.api.BlobSpec blob_specs = 5;
inline int DataBufferStatus::_internal_blob_specs_size() const {
  return _impl_.blob_specs_.size();
}
inline int DataBufferStatus::blob_specs_size() const {
  return _internal_blob_specs_size();
}
inline void DataBufferStatus::clear_blob_specs() {
  _impl_.blob_specs_.Clear();
}
inline ::bosdyn::api::BlobSpec* DataBufferStatus::mutable_blob_specs(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DataBufferStatus.blob_specs)
  return _impl_.blob_specs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobSpec >*
DataBufferStatus::mutable_blob_specs() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.DataBufferStatus.blob_specs)
  return &_impl_.blob_specs_;
}
inline const ::bosdyn::api::BlobSpec& DataBufferStatus::_internal_blob_specs(int index) const {
  return _impl_.blob_specs_.Get(index);
}
inline const ::bosdyn::api::BlobSpec& DataBufferStatus::blob_specs(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DataBufferStatus.blob_specs)
  return _internal_blob_specs(index);
}
inline ::bosdyn::api::BlobSpec* DataBufferStatus::_internal_add_blob_specs() {
  return _impl_.blob_specs_.Add();
}
inline ::bosdyn::api::BlobSpec* DataBufferStatus::add_blob_specs() {
  ::bosdyn::api::BlobSpec* _add = _internal_add_blob_specs();
  // @@protoc_insertion_point(field_add:bosdyn.api.DataBufferStatus.blob_specs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BlobSpec >&
DataBufferStatus::blob_specs() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.DataBufferStatus.blob_specs)
  return _impl_.blob_specs_;
}

// -------------------------------------------------------------------

// GetDataIndexResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetDataIndexResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetDataIndexResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetDataIndexResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetDataIndexResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetDataIndexResponse.header)
  return _internal_header();
}
inline void GetDataIndexResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetDataIndexResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetDataIndexResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetDataIndexResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetDataIndexResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetDataIndexResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* GetDataIndexResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetDataIndexResponse.header)
  return _msg;
}
inline void GetDataIndexResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetDataIndexResponse.header)
}

// .bosdyn.api.DataIndex data_index = 2;
inline bool GetDataIndexResponse::_internal_has_data_index() const {
  return this != internal_default_instance() && _impl_.data_index_ != nullptr;
}
inline bool GetDataIndexResponse::has_data_index() const {
  return _internal_has_data_index();
}
inline void GetDataIndexResponse::clear_data_index() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_index_ != nullptr) {
    delete _impl_.data_index_;
  }
  _impl_.data_index_ = nullptr;
}
inline const ::bosdyn::api::DataIndex& GetDataIndexResponse::_internal_data_index() const {
  const ::bosdyn::api::DataIndex* p = _impl_.data_index_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataIndex&>(
      ::bosdyn::api::_DataIndex_default_instance_);
}
inline const ::bosdyn::api::DataIndex& GetDataIndexResponse::data_index() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetDataIndexResponse.data_index)
  return _internal_data_index();
}
inline void GetDataIndexResponse::unsafe_arena_set_allocated_data_index(
    ::bosdyn::api::DataIndex* data_index) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_index_);
  }
  _impl_.data_index_ = data_index;
  if (data_index) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetDataIndexResponse.data_index)
}
inline ::bosdyn::api::DataIndex* GetDataIndexResponse::release_data_index() {
  
  ::bosdyn::api::DataIndex* temp = _impl_.data_index_;
  _impl_.data_index_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataIndex* GetDataIndexResponse::unsafe_arena_release_data_index() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetDataIndexResponse.data_index)
  
  ::bosdyn::api::DataIndex* temp = _impl_.data_index_;
  _impl_.data_index_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataIndex* GetDataIndexResponse::_internal_mutable_data_index() {
  
  if (_impl_.data_index_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataIndex>(GetArenaForAllocation());
    _impl_.data_index_ = p;
  }
  return _impl_.data_index_;
}
inline ::bosdyn::api::DataIndex* GetDataIndexResponse::mutable_data_index() {
  ::bosdyn::api::DataIndex* _msg = _internal_mutable_data_index();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetDataIndexResponse.data_index)
  return _msg;
}
inline void GetDataIndexResponse::set_allocated_data_index(::bosdyn::api::DataIndex* data_index) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_index_;
  }
  if (data_index) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data_index);
    if (message_arena != submessage_arena) {
      data_index = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_index, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_index_ = data_index;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetDataIndexResponse.data_index)
}

// -------------------------------------------------------------------

// GetDataIndexRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetDataIndexRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetDataIndexRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetDataIndexRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetDataIndexRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetDataIndexRequest.header)
  return _internal_header();
}
inline void GetDataIndexRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetDataIndexRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetDataIndexRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetDataIndexRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetDataIndexRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetDataIndexRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* GetDataIndexRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetDataIndexRequest.header)
  return _msg;
}
inline void GetDataIndexRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetDataIndexRequest.header)
}

// .bosdyn.api.DataQuery data_query = 2;
inline bool GetDataIndexRequest::_internal_has_data_query() const {
  return this != internal_default_instance() && _impl_.data_query_ != nullptr;
}
inline bool GetDataIndexRequest::has_data_query() const {
  return _internal_has_data_query();
}
inline void GetDataIndexRequest::clear_data_query() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_query_ != nullptr) {
    delete _impl_.data_query_;
  }
  _impl_.data_query_ = nullptr;
}
inline const ::bosdyn::api::DataQuery& GetDataIndexRequest::_internal_data_query() const {
  const ::bosdyn::api::DataQuery* p = _impl_.data_query_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataQuery&>(
      ::bosdyn::api::_DataQuery_default_instance_);
}
inline const ::bosdyn::api::DataQuery& GetDataIndexRequest::data_query() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetDataIndexRequest.data_query)
  return _internal_data_query();
}
inline void GetDataIndexRequest::unsafe_arena_set_allocated_data_query(
    ::bosdyn::api::DataQuery* data_query) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_query_);
  }
  _impl_.data_query_ = data_query;
  if (data_query) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetDataIndexRequest.data_query)
}
inline ::bosdyn::api::DataQuery* GetDataIndexRequest::release_data_query() {
  
  ::bosdyn::api::DataQuery* temp = _impl_.data_query_;
  _impl_.data_query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataQuery* GetDataIndexRequest::unsafe_arena_release_data_query() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetDataIndexRequest.data_query)
  
  ::bosdyn::api::DataQuery* temp = _impl_.data_query_;
  _impl_.data_query_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataQuery* GetDataIndexRequest::_internal_mutable_data_query() {
  
  if (_impl_.data_query_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataQuery>(GetArenaForAllocation());
    _impl_.data_query_ = p;
  }
  return _impl_.data_query_;
}
inline ::bosdyn::api::DataQuery* GetDataIndexRequest::mutable_data_query() {
  ::bosdyn::api::DataQuery* _msg = _internal_mutable_data_query();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetDataIndexRequest.data_query)
  return _msg;
}
inline void GetDataIndexRequest::set_allocated_data_query(::bosdyn::api::DataQuery* data_query) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_query_;
  }
  if (data_query) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data_query);
    if (message_arena != submessage_arena) {
      data_query = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_query, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_query_ = data_query;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetDataIndexRequest.data_query)
}

// -------------------------------------------------------------------

// GetEventsCommentsRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetEventsCommentsRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetEventsCommentsRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetEventsCommentsRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetEventsCommentsRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEventsCommentsRequest.header)
  return _internal_header();
}
inline void GetEventsCommentsRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEventsCommentsRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetEventsCommentsRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetEventsCommentsRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEventsCommentsRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetEventsCommentsRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* GetEventsCommentsRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEventsCommentsRequest.header)
  return _msg;
}
inline void GetEventsCommentsRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEventsCommentsRequest.header)
}

// .bosdyn.api.EventsCommentsSpec event_comment_request = 2;
inline bool GetEventsCommentsRequest::_internal_has_event_comment_request() const {
  return this != internal_default_instance() && _impl_.event_comment_request_ != nullptr;
}
inline bool GetEventsCommentsRequest::has_event_comment_request() const {
  return _internal_has_event_comment_request();
}
inline void GetEventsCommentsRequest::clear_event_comment_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.event_comment_request_ != nullptr) {
    delete _impl_.event_comment_request_;
  }
  _impl_.event_comment_request_ = nullptr;
}
inline const ::bosdyn::api::EventsCommentsSpec& GetEventsCommentsRequest::_internal_event_comment_request() const {
  const ::bosdyn::api::EventsCommentsSpec* p = _impl_.event_comment_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::EventsCommentsSpec&>(
      ::bosdyn::api::_EventsCommentsSpec_default_instance_);
}
inline const ::bosdyn::api::EventsCommentsSpec& GetEventsCommentsRequest::event_comment_request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEventsCommentsRequest.event_comment_request)
  return _internal_event_comment_request();
}
inline void GetEventsCommentsRequest::unsafe_arena_set_allocated_event_comment_request(
    ::bosdyn::api::EventsCommentsSpec* event_comment_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_comment_request_);
  }
  _impl_.event_comment_request_ = event_comment_request;
  if (event_comment_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEventsCommentsRequest.event_comment_request)
}
inline ::bosdyn::api::EventsCommentsSpec* GetEventsCommentsRequest::release_event_comment_request() {
  
  ::bosdyn::api::EventsCommentsSpec* temp = _impl_.event_comment_request_;
  _impl_.event_comment_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::EventsCommentsSpec* GetEventsCommentsRequest::unsafe_arena_release_event_comment_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEventsCommentsRequest.event_comment_request)
  
  ::bosdyn::api::EventsCommentsSpec* temp = _impl_.event_comment_request_;
  _impl_.event_comment_request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EventsCommentsSpec* GetEventsCommentsRequest::_internal_mutable_event_comment_request() {
  
  if (_impl_.event_comment_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EventsCommentsSpec>(GetArenaForAllocation());
    _impl_.event_comment_request_ = p;
  }
  return _impl_.event_comment_request_;
}
inline ::bosdyn::api::EventsCommentsSpec* GetEventsCommentsRequest::mutable_event_comment_request() {
  ::bosdyn::api::EventsCommentsSpec* _msg = _internal_mutable_event_comment_request();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEventsCommentsRequest.event_comment_request)
  return _msg;
}
inline void GetEventsCommentsRequest::set_allocated_event_comment_request(::bosdyn::api::EventsCommentsSpec* event_comment_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.event_comment_request_;
  }
  if (event_comment_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(event_comment_request);
    if (message_arena != submessage_arena) {
      event_comment_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event_comment_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.event_comment_request_ = event_comment_request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEventsCommentsRequest.event_comment_request)
}

// -------------------------------------------------------------------

// GetEventsCommentsResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetEventsCommentsResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetEventsCommentsResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetEventsCommentsResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetEventsCommentsResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEventsCommentsResponse.header)
  return _internal_header();
}
inline void GetEventsCommentsResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEventsCommentsResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetEventsCommentsResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetEventsCommentsResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEventsCommentsResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetEventsCommentsResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* GetEventsCommentsResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEventsCommentsResponse.header)
  return _msg;
}
inline void GetEventsCommentsResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEventsCommentsResponse.header)
}

// .bosdyn.api.EventsComments events_comments = 2;
inline bool GetEventsCommentsResponse::_internal_has_events_comments() const {
  return this != internal_default_instance() && _impl_.events_comments_ != nullptr;
}
inline bool GetEventsCommentsResponse::has_events_comments() const {
  return _internal_has_events_comments();
}
inline void GetEventsCommentsResponse::clear_events_comments() {
  if (GetArenaForAllocation() == nullptr && _impl_.events_comments_ != nullptr) {
    delete _impl_.events_comments_;
  }
  _impl_.events_comments_ = nullptr;
}
inline const ::bosdyn::api::EventsComments& GetEventsCommentsResponse::_internal_events_comments() const {
  const ::bosdyn::api::EventsComments* p = _impl_.events_comments_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::EventsComments&>(
      ::bosdyn::api::_EventsComments_default_instance_);
}
inline const ::bosdyn::api::EventsComments& GetEventsCommentsResponse::events_comments() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEventsCommentsResponse.events_comments)
  return _internal_events_comments();
}
inline void GetEventsCommentsResponse::unsafe_arena_set_allocated_events_comments(
    ::bosdyn::api::EventsComments* events_comments) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.events_comments_);
  }
  _impl_.events_comments_ = events_comments;
  if (events_comments) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEventsCommentsResponse.events_comments)
}
inline ::bosdyn::api::EventsComments* GetEventsCommentsResponse::release_events_comments() {
  
  ::bosdyn::api::EventsComments* temp = _impl_.events_comments_;
  _impl_.events_comments_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::EventsComments* GetEventsCommentsResponse::unsafe_arena_release_events_comments() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEventsCommentsResponse.events_comments)
  
  ::bosdyn::api::EventsComments* temp = _impl_.events_comments_;
  _impl_.events_comments_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EventsComments* GetEventsCommentsResponse::_internal_mutable_events_comments() {
  
  if (_impl_.events_comments_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EventsComments>(GetArenaForAllocation());
    _impl_.events_comments_ = p;
  }
  return _impl_.events_comments_;
}
inline ::bosdyn::api::EventsComments* GetEventsCommentsResponse::mutable_events_comments() {
  ::bosdyn::api::EventsComments* _msg = _internal_mutable_events_comments();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEventsCommentsResponse.events_comments)
  return _msg;
}
inline void GetEventsCommentsResponse::set_allocated_events_comments(::bosdyn::api::EventsComments* events_comments) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.events_comments_;
  }
  if (events_comments) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(events_comments);
    if (message_arena != submessage_arena) {
      events_comments = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, events_comments, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.events_comments_ = events_comments;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEventsCommentsResponse.events_comments)
}

// -------------------------------------------------------------------

// GetDataBufferStatusRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetDataBufferStatusRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetDataBufferStatusRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetDataBufferStatusRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetDataBufferStatusRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetDataBufferStatusRequest.header)
  return _internal_header();
}
inline void GetDataBufferStatusRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetDataBufferStatusRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetDataBufferStatusRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetDataBufferStatusRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetDataBufferStatusRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetDataBufferStatusRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* GetDataBufferStatusRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetDataBufferStatusRequest.header)
  return _msg;
}
inline void GetDataBufferStatusRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetDataBufferStatusRequest.header)
}

// bool get_blob_specs = 2;
inline void GetDataBufferStatusRequest::clear_get_blob_specs() {
  _impl_.get_blob_specs_ = false;
}
inline bool GetDataBufferStatusRequest::_internal_get_blob_specs() const {
  return _impl_.get_blob_specs_;
}
inline bool GetDataBufferStatusRequest::get_blob_specs() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetDataBufferStatusRequest.get_blob_specs)
  return _internal_get_blob_specs();
}
inline void GetDataBufferStatusRequest::_internal_set_get_blob_specs(bool value) {
  
  _impl_.get_blob_specs_ = value;
}
inline void GetDataBufferStatusRequest::set_get_blob_specs(bool value) {
  _internal_set_get_blob_specs(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.GetDataBufferStatusRequest.get_blob_specs)
}

// -------------------------------------------------------------------

// GetDataBufferStatusResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetDataBufferStatusResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetDataBufferStatusResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetDataBufferStatusResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetDataBufferStatusResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetDataBufferStatusResponse.header)
  return _internal_header();
}
inline void GetDataBufferStatusResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetDataBufferStatusResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetDataBufferStatusResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetDataBufferStatusResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetDataBufferStatusResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetDataBufferStatusResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* GetDataBufferStatusResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetDataBufferStatusResponse.header)
  return _msg;
}
inline void GetDataBufferStatusResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetDataBufferStatusResponse.header)
}

// .bosdyn.api.DataBufferStatus data_buffer_status = 2;
inline bool GetDataBufferStatusResponse::_internal_has_data_buffer_status() const {
  return this != internal_default_instance() && _impl_.data_buffer_status_ != nullptr;
}
inline bool GetDataBufferStatusResponse::has_data_buffer_status() const {
  return _internal_has_data_buffer_status();
}
inline void GetDataBufferStatusResponse::clear_data_buffer_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_buffer_status_ != nullptr) {
    delete _impl_.data_buffer_status_;
  }
  _impl_.data_buffer_status_ = nullptr;
}
inline const ::bosdyn::api::DataBufferStatus& GetDataBufferStatusResponse::_internal_data_buffer_status() const {
  const ::bosdyn::api::DataBufferStatus* p = _impl_.data_buffer_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataBufferStatus&>(
      ::bosdyn::api::_DataBufferStatus_default_instance_);
}
inline const ::bosdyn::api::DataBufferStatus& GetDataBufferStatusResponse::data_buffer_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetDataBufferStatusResponse.data_buffer_status)
  return _internal_data_buffer_status();
}
inline void GetDataBufferStatusResponse::unsafe_arena_set_allocated_data_buffer_status(
    ::bosdyn::api::DataBufferStatus* data_buffer_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_buffer_status_);
  }
  _impl_.data_buffer_status_ = data_buffer_status;
  if (data_buffer_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetDataBufferStatusResponse.data_buffer_status)
}
inline ::bosdyn::api::DataBufferStatus* GetDataBufferStatusResponse::release_data_buffer_status() {
  
  ::bosdyn::api::DataBufferStatus* temp = _impl_.data_buffer_status_;
  _impl_.data_buffer_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataBufferStatus* GetDataBufferStatusResponse::unsafe_arena_release_data_buffer_status() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetDataBufferStatusResponse.data_buffer_status)
  
  ::bosdyn::api::DataBufferStatus* temp = _impl_.data_buffer_status_;
  _impl_.data_buffer_status_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataBufferStatus* GetDataBufferStatusResponse::_internal_mutable_data_buffer_status() {
  
  if (_impl_.data_buffer_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataBufferStatus>(GetArenaForAllocation());
    _impl_.data_buffer_status_ = p;
  }
  return _impl_.data_buffer_status_;
}
inline ::bosdyn::api::DataBufferStatus* GetDataBufferStatusResponse::mutable_data_buffer_status() {
  ::bosdyn::api::DataBufferStatus* _msg = _internal_mutable_data_buffer_status();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetDataBufferStatusResponse.data_buffer_status)
  return _msg;
}
inline void GetDataBufferStatusResponse::set_allocated_data_buffer_status(::bosdyn::api::DataBufferStatus* data_buffer_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_buffer_status_;
  }
  if (data_buffer_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data_buffer_status);
    if (message_arena != submessage_arena) {
      data_buffer_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_buffer_status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_buffer_status_ = data_buffer_status;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetDataBufferStatusResponse.data_buffer_status)
}

// -------------------------------------------------------------------

// GetDataPagesRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetDataPagesRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetDataPagesRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetDataPagesRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetDataPagesRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetDataPagesRequest.header)
  return _internal_header();
}
inline void GetDataPagesRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetDataPagesRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetDataPagesRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetDataPagesRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetDataPagesRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetDataPagesRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* GetDataPagesRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetDataPagesRequest.header)
  return _msg;
}
inline void GetDataPagesRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetDataPagesRequest.header)
}

// .bosdyn.api.TimeRange time_range = 2;
inline bool GetDataPagesRequest::_internal_has_time_range() const {
  return this != internal_default_instance() && _impl_.time_range_ != nullptr;
}
inline bool GetDataPagesRequest::has_time_range() const {
  return _internal_has_time_range();
}
inline const ::bosdyn::api::TimeRange& GetDataPagesRequest::_internal_time_range() const {
  const ::bosdyn::api::TimeRange* p = _impl_.time_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::TimeRange&>(
      ::bosdyn::api::_TimeRange_default_instance_);
}
inline const ::bosdyn::api::TimeRange& GetDataPagesRequest::time_range() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetDataPagesRequest.time_range)
  return _internal_time_range();
}
inline void GetDataPagesRequest::unsafe_arena_set_allocated_time_range(
    ::bosdyn::api::TimeRange* time_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  _impl_.time_range_ = time_range;
  if (time_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetDataPagesRequest.time_range)
}
inline ::bosdyn::api::TimeRange* GetDataPagesRequest::release_time_range() {
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::TimeRange* GetDataPagesRequest::unsafe_arena_release_time_range() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetDataPagesRequest.time_range)
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
  return temp;
}
inline ::bosdyn::api::TimeRange* GetDataPagesRequest::_internal_mutable_time_range() {
  
  if (_impl_.time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::TimeRange>(GetArenaForAllocation());
    _impl_.time_range_ = p;
  }
  return _impl_.time_range_;
}
inline ::bosdyn::api::TimeRange* GetDataPagesRequest::mutable_time_range() {
  ::bosdyn::api::TimeRange* _msg = _internal_mutable_time_range();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetDataPagesRequest.time_range)
  return _msg;
}
inline void GetDataPagesRequest::set_allocated_time_range(::bosdyn::api::TimeRange* time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  if (time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range));
    if (message_arena != submessage_arena) {
      time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_range, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_range_ = time_range;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetDataPagesRequest.time_range)
}

// -------------------------------------------------------------------

// GetDataPagesResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetDataPagesResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool GetDataPagesResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetDataPagesResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetDataPagesResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetDataPagesResponse.header)
  return _internal_header();
}
inline void GetDataPagesResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetDataPagesResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetDataPagesResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetDataPagesResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetDataPagesResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetDataPagesResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* GetDataPagesResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetDataPagesResponse.header)
  return _msg;
}
inline void GetDataPagesResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetDataPagesResponse.header)
}

// repeated .bosdyn.api.PageInfo pages = 2;
inline int GetDataPagesResponse::_internal_pages_size() const {
  return _impl_.pages_.size();
}
inline int GetDataPagesResponse::pages_size() const {
  return _internal_pages_size();
}
inline void GetDataPagesResponse::clear_pages() {
  _impl_.pages_.Clear();
}
inline ::bosdyn::api::PageInfo* GetDataPagesResponse::mutable_pages(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetDataPagesResponse.pages)
  return _impl_.pages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PageInfo >*
GetDataPagesResponse::mutable_pages() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.GetDataPagesResponse.pages)
  return &_impl_.pages_;
}
inline const ::bosdyn::api::PageInfo& GetDataPagesResponse::_internal_pages(int index) const {
  return _impl_.pages_.Get(index);
}
inline const ::bosdyn::api::PageInfo& GetDataPagesResponse::pages(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetDataPagesResponse.pages)
  return _internal_pages(index);
}
inline ::bosdyn::api::PageInfo* GetDataPagesResponse::_internal_add_pages() {
  return _impl_.pages_.Add();
}
inline ::bosdyn::api::PageInfo* GetDataPagesResponse::add_pages() {
  ::bosdyn::api::PageInfo* _add = _internal_add_pages();
  // @@protoc_insertion_point(field_add:bosdyn.api.GetDataPagesResponse.pages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PageInfo >&
GetDataPagesResponse::pages() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.GetDataPagesResponse.pages)
  return _impl_.pages_;
}

// -------------------------------------------------------------------

// DeleteDataPagesRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool DeleteDataPagesRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DeleteDataPagesRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& DeleteDataPagesRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& DeleteDataPagesRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeleteDataPagesRequest.header)
  return _internal_header();
}
inline void DeleteDataPagesRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DeleteDataPagesRequest.header)
}
inline ::bosdyn::api::RequestHeader* DeleteDataPagesRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* DeleteDataPagesRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DeleteDataPagesRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* DeleteDataPagesRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* DeleteDataPagesRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DeleteDataPagesRequest.header)
  return _msg;
}
inline void DeleteDataPagesRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DeleteDataPagesRequest.header)
}

// .bosdyn.api.TimeRange time_range = 2;
inline bool DeleteDataPagesRequest::_internal_has_time_range() const {
  return this != internal_default_instance() && _impl_.time_range_ != nullptr;
}
inline bool DeleteDataPagesRequest::has_time_range() const {
  return _internal_has_time_range();
}
inline const ::bosdyn::api::TimeRange& DeleteDataPagesRequest::_internal_time_range() const {
  const ::bosdyn::api::TimeRange* p = _impl_.time_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::TimeRange&>(
      ::bosdyn::api::_TimeRange_default_instance_);
}
inline const ::bosdyn::api::TimeRange& DeleteDataPagesRequest::time_range() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeleteDataPagesRequest.time_range)
  return _internal_time_range();
}
inline void DeleteDataPagesRequest::unsafe_arena_set_allocated_time_range(
    ::bosdyn::api::TimeRange* time_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  _impl_.time_range_ = time_range;
  if (time_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DeleteDataPagesRequest.time_range)
}
inline ::bosdyn::api::TimeRange* DeleteDataPagesRequest::release_time_range() {
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::TimeRange* DeleteDataPagesRequest::unsafe_arena_release_time_range() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DeleteDataPagesRequest.time_range)
  
  ::bosdyn::api::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
  return temp;
}
inline ::bosdyn::api::TimeRange* DeleteDataPagesRequest::_internal_mutable_time_range() {
  
  if (_impl_.time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::TimeRange>(GetArenaForAllocation());
    _impl_.time_range_ = p;
  }
  return _impl_.time_range_;
}
inline ::bosdyn::api::TimeRange* DeleteDataPagesRequest::mutable_time_range() {
  ::bosdyn::api::TimeRange* _msg = _internal_mutable_time_range();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DeleteDataPagesRequest.time_range)
  return _msg;
}
inline void DeleteDataPagesRequest::set_allocated_time_range(::bosdyn::api::TimeRange* time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_range_);
  }
  if (time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range));
    if (message_arena != submessage_arena) {
      time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_range, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_range_ = time_range;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DeleteDataPagesRequest.time_range)
}

// repeated string page_ids = 3;
inline int DeleteDataPagesRequest::_internal_page_ids_size() const {
  return _impl_.page_ids_.size();
}
inline int DeleteDataPagesRequest::page_ids_size() const {
  return _internal_page_ids_size();
}
inline void DeleteDataPagesRequest::clear_page_ids() {
  _impl_.page_ids_.Clear();
}
inline std::string* DeleteDataPagesRequest::add_page_ids() {
  std::string* _s = _internal_add_page_ids();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.DeleteDataPagesRequest.page_ids)
  return _s;
}
inline const std::string& DeleteDataPagesRequest::_internal_page_ids(int index) const {
  return _impl_.page_ids_.Get(index);
}
inline const std::string& DeleteDataPagesRequest::page_ids(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeleteDataPagesRequest.page_ids)
  return _internal_page_ids(index);
}
inline std::string* DeleteDataPagesRequest::mutable_page_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DeleteDataPagesRequest.page_ids)
  return _impl_.page_ids_.Mutable(index);
}
inline void DeleteDataPagesRequest::set_page_ids(int index, const std::string& value) {
  _impl_.page_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DeleteDataPagesRequest.page_ids)
}
inline void DeleteDataPagesRequest::set_page_ids(int index, std::string&& value) {
  _impl_.page_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.DeleteDataPagesRequest.page_ids)
}
inline void DeleteDataPagesRequest::set_page_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.page_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.DeleteDataPagesRequest.page_ids)
}
inline void DeleteDataPagesRequest::set_page_ids(int index, const char* value, size_t size) {
  _impl_.page_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.DeleteDataPagesRequest.page_ids)
}
inline std::string* DeleteDataPagesRequest::_internal_add_page_ids() {
  return _impl_.page_ids_.Add();
}
inline void DeleteDataPagesRequest::add_page_ids(const std::string& value) {
  _impl_.page_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.DeleteDataPagesRequest.page_ids)
}
inline void DeleteDataPagesRequest::add_page_ids(std::string&& value) {
  _impl_.page_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.DeleteDataPagesRequest.page_ids)
}
inline void DeleteDataPagesRequest::add_page_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.page_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.DeleteDataPagesRequest.page_ids)
}
inline void DeleteDataPagesRequest::add_page_ids(const char* value, size_t size) {
  _impl_.page_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.DeleteDataPagesRequest.page_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeleteDataPagesRequest::page_ids() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.DeleteDataPagesRequest.page_ids)
  return _impl_.page_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeleteDataPagesRequest::mutable_page_ids() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.DeleteDataPagesRequest.page_ids)
  return &_impl_.page_ids_;
}

// -------------------------------------------------------------------

// DeletePageStatus

// string page_id = 1;
inline void DeletePageStatus::clear_page_id() {
  _impl_.page_id_.ClearToEmpty();
}
inline const std::string& DeletePageStatus::page_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeletePageStatus.page_id)
  return _internal_page_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePageStatus::set_page_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.DeletePageStatus.page_id)
}
inline std::string* DeletePageStatus::mutable_page_id() {
  std::string* _s = _internal_mutable_page_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DeletePageStatus.page_id)
  return _s;
}
inline const std::string& DeletePageStatus::_internal_page_id() const {
  return _impl_.page_id_.Get();
}
inline void DeletePageStatus::_internal_set_page_id(const std::string& value) {
  
  _impl_.page_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeletePageStatus::_internal_mutable_page_id() {
  
  return _impl_.page_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeletePageStatus::release_page_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DeletePageStatus.page_id)
  return _impl_.page_id_.Release();
}
inline void DeletePageStatus::set_allocated_page_id(std::string* page_id) {
  if (page_id != nullptr) {
    
  } else {
    
  }
  _impl_.page_id_.SetAllocated(page_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_id_.IsDefault()) {
    _impl_.page_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DeletePageStatus.page_id)
}

// .bosdyn.api.DeletePageStatus.Status status = 2;
inline void DeletePageStatus::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::DeletePageStatus_Status DeletePageStatus::_internal_status() const {
  return static_cast< ::bosdyn::api::DeletePageStatus_Status >(_impl_.status_);
}
inline ::bosdyn::api::DeletePageStatus_Status DeletePageStatus::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeletePageStatus.status)
  return _internal_status();
}
inline void DeletePageStatus::_internal_set_status(::bosdyn::api::DeletePageStatus_Status value) {
  
  _impl_.status_ = value;
}
inline void DeletePageStatus::set_status(::bosdyn::api::DeletePageStatus_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DeletePageStatus.status)
}

// -------------------------------------------------------------------

// DeleteDataPagesResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool DeleteDataPagesResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DeleteDataPagesResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& DeleteDataPagesResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& DeleteDataPagesResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeleteDataPagesResponse.header)
  return _internal_header();
}
inline void DeleteDataPagesResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DeleteDataPagesResponse.header)
}
inline ::bosdyn::api::ResponseHeader* DeleteDataPagesResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DeleteDataPagesResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DeleteDataPagesResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DeleteDataPagesResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* DeleteDataPagesResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DeleteDataPagesResponse.header)
  return _msg;
}
inline void DeleteDataPagesResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DeleteDataPagesResponse.header)
}

// int64 bytes_deleted = 2;
inline void DeleteDataPagesResponse::clear_bytes_deleted() {
  _impl_.bytes_deleted_ = int64_t{0};
}
inline int64_t DeleteDataPagesResponse::_internal_bytes_deleted() const {
  return _impl_.bytes_deleted_;
}
inline int64_t DeleteDataPagesResponse::bytes_deleted() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeleteDataPagesResponse.bytes_deleted)
  return _internal_bytes_deleted();
}
inline void DeleteDataPagesResponse::_internal_set_bytes_deleted(int64_t value) {
  
  _impl_.bytes_deleted_ = value;
}
inline void DeleteDataPagesResponse::set_bytes_deleted(int64_t value) {
  _internal_set_bytes_deleted(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DeleteDataPagesResponse.bytes_deleted)
}

// repeated .bosdyn.api.DeletePageStatus status = 3;
inline int DeleteDataPagesResponse::_internal_status_size() const {
  return _impl_.status_.size();
}
inline int DeleteDataPagesResponse::status_size() const {
  return _internal_status_size();
}
inline void DeleteDataPagesResponse::clear_status() {
  _impl_.status_.Clear();
}
inline ::bosdyn::api::DeletePageStatus* DeleteDataPagesResponse::mutable_status(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DeleteDataPagesResponse.status)
  return _impl_.status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DeletePageStatus >*
DeleteDataPagesResponse::mutable_status() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.DeleteDataPagesResponse.status)
  return &_impl_.status_;
}
inline const ::bosdyn::api::DeletePageStatus& DeleteDataPagesResponse::_internal_status(int index) const {
  return _impl_.status_.Get(index);
}
inline const ::bosdyn::api::DeletePageStatus& DeleteDataPagesResponse::status(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeleteDataPagesResponse.status)
  return _internal_status(index);
}
inline ::bosdyn::api::DeletePageStatus* DeleteDataPagesResponse::_internal_add_status() {
  return _impl_.status_.Add();
}
inline ::bosdyn::api::DeletePageStatus* DeleteDataPagesResponse::add_status() {
  ::bosdyn::api::DeletePageStatus* _add = _internal_add_status();
  // @@protoc_insertion_point(field_add:bosdyn.api.DeleteDataPagesResponse.status)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::DeletePageStatus >&
DeleteDataPagesResponse::status() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.DeleteDataPagesResponse.status)
  return _impl_.status_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::PageInfo_PageFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::PageInfo_PageFormat>() {
  return ::bosdyn::api::PageInfo_PageFormat_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::PageInfo_Compression> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::PageInfo_Compression>() {
  return ::bosdyn::api::PageInfo_Compression_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::DeletePageStatus_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::DeletePageStatus_Status>() {
  return ::bosdyn::api::DeletePageStatus_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fdata_5findex_2eproto
