// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/robot_state.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2frobot_5fstate_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2frobot_5fstate_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/geometry.pb.h"
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/parameter.pb.h"
#include "bosdyn/api/service_fault.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2frobot_5fstate_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto;
namespace bosdyn {
namespace api {
class BatteryState;
struct BatteryStateDefaultTypeInternal;
extern BatteryStateDefaultTypeInternal _BatteryState_default_instance_;
class BehaviorFault;
struct BehaviorFaultDefaultTypeInternal;
extern BehaviorFaultDefaultTypeInternal _BehaviorFault_default_instance_;
class BehaviorFaultState;
struct BehaviorFaultStateDefaultTypeInternal;
extern BehaviorFaultStateDefaultTypeInternal _BehaviorFaultState_default_instance_;
class CommsState;
struct CommsStateDefaultTypeInternal;
extern CommsStateDefaultTypeInternal _CommsState_default_instance_;
class EStopState;
struct EStopStateDefaultTypeInternal;
extern EStopStateDefaultTypeInternal _EStopState_default_instance_;
class FootState;
struct FootStateDefaultTypeInternal;
extern FootStateDefaultTypeInternal _FootState_default_instance_;
class FootState_TerrainState;
struct FootState_TerrainStateDefaultTypeInternal;
extern FootState_TerrainStateDefaultTypeInternal _FootState_TerrainState_default_instance_;
class HardwareConfiguration;
struct HardwareConfigurationDefaultTypeInternal;
extern HardwareConfigurationDefaultTypeInternal _HardwareConfiguration_default_instance_;
class JointState;
struct JointStateDefaultTypeInternal;
extern JointStateDefaultTypeInternal _JointState_default_instance_;
class KinematicState;
struct KinematicStateDefaultTypeInternal;
extern KinematicStateDefaultTypeInternal _KinematicState_default_instance_;
class ManipulatorState;
struct ManipulatorStateDefaultTypeInternal;
extern ManipulatorStateDefaultTypeInternal _ManipulatorState_default_instance_;
class PowerState;
struct PowerStateDefaultTypeInternal;
extern PowerStateDefaultTypeInternal _PowerState_default_instance_;
class RobotHardwareConfigurationRequest;
struct RobotHardwareConfigurationRequestDefaultTypeInternal;
extern RobotHardwareConfigurationRequestDefaultTypeInternal _RobotHardwareConfigurationRequest_default_instance_;
class RobotHardwareConfigurationResponse;
struct RobotHardwareConfigurationResponseDefaultTypeInternal;
extern RobotHardwareConfigurationResponseDefaultTypeInternal _RobotHardwareConfigurationResponse_default_instance_;
class RobotImpairedState;
struct RobotImpairedStateDefaultTypeInternal;
extern RobotImpairedStateDefaultTypeInternal _RobotImpairedState_default_instance_;
class RobotLinkModelRequest;
struct RobotLinkModelRequestDefaultTypeInternal;
extern RobotLinkModelRequestDefaultTypeInternal _RobotLinkModelRequest_default_instance_;
class RobotLinkModelResponse;
struct RobotLinkModelResponseDefaultTypeInternal;
extern RobotLinkModelResponseDefaultTypeInternal _RobotLinkModelResponse_default_instance_;
class RobotMetrics;
struct RobotMetricsDefaultTypeInternal;
extern RobotMetricsDefaultTypeInternal _RobotMetrics_default_instance_;
class RobotMetricsRequest;
struct RobotMetricsRequestDefaultTypeInternal;
extern RobotMetricsRequestDefaultTypeInternal _RobotMetricsRequest_default_instance_;
class RobotMetricsResponse;
struct RobotMetricsResponseDefaultTypeInternal;
extern RobotMetricsResponseDefaultTypeInternal _RobotMetricsResponse_default_instance_;
class RobotState;
struct RobotStateDefaultTypeInternal;
extern RobotStateDefaultTypeInternal _RobotState_default_instance_;
class RobotStateRequest;
struct RobotStateRequestDefaultTypeInternal;
extern RobotStateRequestDefaultTypeInternal _RobotStateRequest_default_instance_;
class RobotStateResponse;
struct RobotStateResponseDefaultTypeInternal;
extern RobotStateResponseDefaultTypeInternal _RobotStateResponse_default_instance_;
class ServiceFaultState;
struct ServiceFaultStateDefaultTypeInternal;
extern ServiceFaultStateDefaultTypeInternal _ServiceFaultState_default_instance_;
class ServiceFaultState_AggregatedEntry_DoNotUse;
struct ServiceFaultState_AggregatedEntry_DoNotUseDefaultTypeInternal;
extern ServiceFaultState_AggregatedEntry_DoNotUseDefaultTypeInternal _ServiceFaultState_AggregatedEntry_DoNotUse_default_instance_;
class Skeleton;
struct SkeletonDefaultTypeInternal;
extern SkeletonDefaultTypeInternal _Skeleton_default_instance_;
class Skeleton_Link;
struct Skeleton_LinkDefaultTypeInternal;
extern Skeleton_LinkDefaultTypeInternal _Skeleton_Link_default_instance_;
class Skeleton_Link_ObjModel;
struct Skeleton_Link_ObjModelDefaultTypeInternal;
extern Skeleton_Link_ObjModelDefaultTypeInternal _Skeleton_Link_ObjModel_default_instance_;
class SystemFault;
struct SystemFaultDefaultTypeInternal;
extern SystemFaultDefaultTypeInternal _SystemFault_default_instance_;
class SystemFaultState;
struct SystemFaultStateDefaultTypeInternal;
extern SystemFaultStateDefaultTypeInternal _SystemFaultState_default_instance_;
class SystemFaultState_AggregatedEntry_DoNotUse;
struct SystemFaultState_AggregatedEntry_DoNotUseDefaultTypeInternal;
extern SystemFaultState_AggregatedEntry_DoNotUseDefaultTypeInternal _SystemFaultState_AggregatedEntry_DoNotUse_default_instance_;
class TerrainState;
struct TerrainStateDefaultTypeInternal;
extern TerrainStateDefaultTypeInternal _TerrainState_default_instance_;
class WiFiState;
struct WiFiStateDefaultTypeInternal;
extern WiFiStateDefaultTypeInternal _WiFiState_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::BatteryState* Arena::CreateMaybeMessage<::bosdyn::api::BatteryState>(Arena*);
template<> ::bosdyn::api::BehaviorFault* Arena::CreateMaybeMessage<::bosdyn::api::BehaviorFault>(Arena*);
template<> ::bosdyn::api::BehaviorFaultState* Arena::CreateMaybeMessage<::bosdyn::api::BehaviorFaultState>(Arena*);
template<> ::bosdyn::api::CommsState* Arena::CreateMaybeMessage<::bosdyn::api::CommsState>(Arena*);
template<> ::bosdyn::api::EStopState* Arena::CreateMaybeMessage<::bosdyn::api::EStopState>(Arena*);
template<> ::bosdyn::api::FootState* Arena::CreateMaybeMessage<::bosdyn::api::FootState>(Arena*);
template<> ::bosdyn::api::FootState_TerrainState* Arena::CreateMaybeMessage<::bosdyn::api::FootState_TerrainState>(Arena*);
template<> ::bosdyn::api::HardwareConfiguration* Arena::CreateMaybeMessage<::bosdyn::api::HardwareConfiguration>(Arena*);
template<> ::bosdyn::api::JointState* Arena::CreateMaybeMessage<::bosdyn::api::JointState>(Arena*);
template<> ::bosdyn::api::KinematicState* Arena::CreateMaybeMessage<::bosdyn::api::KinematicState>(Arena*);
template<> ::bosdyn::api::ManipulatorState* Arena::CreateMaybeMessage<::bosdyn::api::ManipulatorState>(Arena*);
template<> ::bosdyn::api::PowerState* Arena::CreateMaybeMessage<::bosdyn::api::PowerState>(Arena*);
template<> ::bosdyn::api::RobotHardwareConfigurationRequest* Arena::CreateMaybeMessage<::bosdyn::api::RobotHardwareConfigurationRequest>(Arena*);
template<> ::bosdyn::api::RobotHardwareConfigurationResponse* Arena::CreateMaybeMessage<::bosdyn::api::RobotHardwareConfigurationResponse>(Arena*);
template<> ::bosdyn::api::RobotImpairedState* Arena::CreateMaybeMessage<::bosdyn::api::RobotImpairedState>(Arena*);
template<> ::bosdyn::api::RobotLinkModelRequest* Arena::CreateMaybeMessage<::bosdyn::api::RobotLinkModelRequest>(Arena*);
template<> ::bosdyn::api::RobotLinkModelResponse* Arena::CreateMaybeMessage<::bosdyn::api::RobotLinkModelResponse>(Arena*);
template<> ::bosdyn::api::RobotMetrics* Arena::CreateMaybeMessage<::bosdyn::api::RobotMetrics>(Arena*);
template<> ::bosdyn::api::RobotMetricsRequest* Arena::CreateMaybeMessage<::bosdyn::api::RobotMetricsRequest>(Arena*);
template<> ::bosdyn::api::RobotMetricsResponse* Arena::CreateMaybeMessage<::bosdyn::api::RobotMetricsResponse>(Arena*);
template<> ::bosdyn::api::RobotState* Arena::CreateMaybeMessage<::bosdyn::api::RobotState>(Arena*);
template<> ::bosdyn::api::RobotStateRequest* Arena::CreateMaybeMessage<::bosdyn::api::RobotStateRequest>(Arena*);
template<> ::bosdyn::api::RobotStateResponse* Arena::CreateMaybeMessage<::bosdyn::api::RobotStateResponse>(Arena*);
template<> ::bosdyn::api::ServiceFaultState* Arena::CreateMaybeMessage<::bosdyn::api::ServiceFaultState>(Arena*);
template<> ::bosdyn::api::ServiceFaultState_AggregatedEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::ServiceFaultState_AggregatedEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::Skeleton* Arena::CreateMaybeMessage<::bosdyn::api::Skeleton>(Arena*);
template<> ::bosdyn::api::Skeleton_Link* Arena::CreateMaybeMessage<::bosdyn::api::Skeleton_Link>(Arena*);
template<> ::bosdyn::api::Skeleton_Link_ObjModel* Arena::CreateMaybeMessage<::bosdyn::api::Skeleton_Link_ObjModel>(Arena*);
template<> ::bosdyn::api::SystemFault* Arena::CreateMaybeMessage<::bosdyn::api::SystemFault>(Arena*);
template<> ::bosdyn::api::SystemFaultState* Arena::CreateMaybeMessage<::bosdyn::api::SystemFaultState>(Arena*);
template<> ::bosdyn::api::SystemFaultState_AggregatedEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::SystemFaultState_AggregatedEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::TerrainState* Arena::CreateMaybeMessage<::bosdyn::api::TerrainState>(Arena*);
template<> ::bosdyn::api::WiFiState* Arena::CreateMaybeMessage<::bosdyn::api::WiFiState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum PowerState_MotorPowerState : int {
  PowerState_MotorPowerState_STATE_UNKNOWN PROTOBUF_DEPRECATED_ENUM = 0,
  PowerState_MotorPowerState_MOTOR_POWER_STATE_UNKNOWN = 0,
  PowerState_MotorPowerState_STATE_OFF PROTOBUF_DEPRECATED_ENUM = 1,
  PowerState_MotorPowerState_MOTOR_POWER_STATE_OFF = 1,
  PowerState_MotorPowerState_STATE_ON PROTOBUF_DEPRECATED_ENUM = 2,
  PowerState_MotorPowerState_MOTOR_POWER_STATE_ON = 2,
  PowerState_MotorPowerState_STATE_POWERING_ON PROTOBUF_DEPRECATED_ENUM = 3,
  PowerState_MotorPowerState_MOTOR_POWER_STATE_POWERING_ON = 3,
  PowerState_MotorPowerState_STATE_POWERING_OFF PROTOBUF_DEPRECATED_ENUM = 4,
  PowerState_MotorPowerState_MOTOR_POWER_STATE_POWERING_OFF = 4,
  PowerState_MotorPowerState_STATE_ERROR PROTOBUF_DEPRECATED_ENUM = 5,
  PowerState_MotorPowerState_MOTOR_POWER_STATE_ERROR = 5,
  PowerState_MotorPowerState_PowerState_MotorPowerState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PowerState_MotorPowerState_PowerState_MotorPowerState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PowerState_MotorPowerState_IsValid(int value);
constexpr PowerState_MotorPowerState PowerState_MotorPowerState_MotorPowerState_MIN = PowerState_MotorPowerState_STATE_UNKNOWN;
constexpr PowerState_MotorPowerState PowerState_MotorPowerState_MotorPowerState_MAX = PowerState_MotorPowerState_STATE_ERROR;
constexpr int PowerState_MotorPowerState_MotorPowerState_ARRAYSIZE = PowerState_MotorPowerState_MotorPowerState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PowerState_MotorPowerState_descriptor();
template<typename T>
inline const std::string& PowerState_MotorPowerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerState_MotorPowerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerState_MotorPowerState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PowerState_MotorPowerState_descriptor(), enum_t_value);
}
inline bool PowerState_MotorPowerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerState_MotorPowerState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PowerState_MotorPowerState>(
    PowerState_MotorPowerState_descriptor(), name, value);
}
enum PowerState_ShorePowerState : int {
  PowerState_ShorePowerState_STATE_UNKNOWN_SHORE_POWER PROTOBUF_DEPRECATED_ENUM = 0,
  PowerState_ShorePowerState_SHORE_POWER_STATE_UNKNOWN = 0,
  PowerState_ShorePowerState_STATE_ON_SHORE_POWER PROTOBUF_DEPRECATED_ENUM = 1,
  PowerState_ShorePowerState_SHORE_POWER_STATE_ON = 1,
  PowerState_ShorePowerState_STATE_OFF_SHORE_POWER PROTOBUF_DEPRECATED_ENUM = 2,
  PowerState_ShorePowerState_SHORE_POWER_STATE_OFF = 2,
  PowerState_ShorePowerState_PowerState_ShorePowerState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PowerState_ShorePowerState_PowerState_ShorePowerState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PowerState_ShorePowerState_IsValid(int value);
constexpr PowerState_ShorePowerState PowerState_ShorePowerState_ShorePowerState_MIN = PowerState_ShorePowerState_STATE_UNKNOWN_SHORE_POWER;
constexpr PowerState_ShorePowerState PowerState_ShorePowerState_ShorePowerState_MAX = PowerState_ShorePowerState_STATE_OFF_SHORE_POWER;
constexpr int PowerState_ShorePowerState_ShorePowerState_ARRAYSIZE = PowerState_ShorePowerState_ShorePowerState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PowerState_ShorePowerState_descriptor();
template<typename T>
inline const std::string& PowerState_ShorePowerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerState_ShorePowerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerState_ShorePowerState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PowerState_ShorePowerState_descriptor(), enum_t_value);
}
inline bool PowerState_ShorePowerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerState_ShorePowerState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PowerState_ShorePowerState>(
    PowerState_ShorePowerState_descriptor(), name, value);
}
enum PowerState_RobotPowerState : int {
  PowerState_RobotPowerState_ROBOT_POWER_STATE_UNKNOWN = 0,
  PowerState_RobotPowerState_ROBOT_POWER_STATE_ON = 1,
  PowerState_RobotPowerState_ROBOT_POWER_STATE_OFF = 2,
  PowerState_RobotPowerState_PowerState_RobotPowerState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PowerState_RobotPowerState_PowerState_RobotPowerState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PowerState_RobotPowerState_IsValid(int value);
constexpr PowerState_RobotPowerState PowerState_RobotPowerState_RobotPowerState_MIN = PowerState_RobotPowerState_ROBOT_POWER_STATE_UNKNOWN;
constexpr PowerState_RobotPowerState PowerState_RobotPowerState_RobotPowerState_MAX = PowerState_RobotPowerState_ROBOT_POWER_STATE_OFF;
constexpr int PowerState_RobotPowerState_RobotPowerState_ARRAYSIZE = PowerState_RobotPowerState_RobotPowerState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PowerState_RobotPowerState_descriptor();
template<typename T>
inline const std::string& PowerState_RobotPowerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerState_RobotPowerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerState_RobotPowerState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PowerState_RobotPowerState_descriptor(), enum_t_value);
}
inline bool PowerState_RobotPowerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerState_RobotPowerState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PowerState_RobotPowerState>(
    PowerState_RobotPowerState_descriptor(), name, value);
}
enum PowerState_PayloadPortsPowerState : int {
  PowerState_PayloadPortsPowerState_PAYLOAD_PORTS_POWER_STATE_UNKNOWN = 0,
  PowerState_PayloadPortsPowerState_PAYLOAD_PORTS_POWER_STATE_ON = 1,
  PowerState_PayloadPortsPowerState_PAYLOAD_PORTS_POWER_STATE_OFF = 2,
  PowerState_PayloadPortsPowerState_PowerState_PayloadPortsPowerState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PowerState_PayloadPortsPowerState_PowerState_PayloadPortsPowerState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PowerState_PayloadPortsPowerState_IsValid(int value);
constexpr PowerState_PayloadPortsPowerState PowerState_PayloadPortsPowerState_PayloadPortsPowerState_MIN = PowerState_PayloadPortsPowerState_PAYLOAD_PORTS_POWER_STATE_UNKNOWN;
constexpr PowerState_PayloadPortsPowerState PowerState_PayloadPortsPowerState_PayloadPortsPowerState_MAX = PowerState_PayloadPortsPowerState_PAYLOAD_PORTS_POWER_STATE_OFF;
constexpr int PowerState_PayloadPortsPowerState_PayloadPortsPowerState_ARRAYSIZE = PowerState_PayloadPortsPowerState_PayloadPortsPowerState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PowerState_PayloadPortsPowerState_descriptor();
template<typename T>
inline const std::string& PowerState_PayloadPortsPowerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerState_PayloadPortsPowerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerState_PayloadPortsPowerState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PowerState_PayloadPortsPowerState_descriptor(), enum_t_value);
}
inline bool PowerState_PayloadPortsPowerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerState_PayloadPortsPowerState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PowerState_PayloadPortsPowerState>(
    PowerState_PayloadPortsPowerState_descriptor(), name, value);
}
enum PowerState_WifiRadioPowerState : int {
  PowerState_WifiRadioPowerState_WIFI_RADIO_POWER_STATE_UNKNOWN = 0,
  PowerState_WifiRadioPowerState_WIFI_RADIO_POWER_STATE_ON = 1,
  PowerState_WifiRadioPowerState_WIFI_RADIO_POWER_STATE_OFF = 2,
  PowerState_WifiRadioPowerState_PowerState_WifiRadioPowerState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PowerState_WifiRadioPowerState_PowerState_WifiRadioPowerState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PowerState_WifiRadioPowerState_IsValid(int value);
constexpr PowerState_WifiRadioPowerState PowerState_WifiRadioPowerState_WifiRadioPowerState_MIN = PowerState_WifiRadioPowerState_WIFI_RADIO_POWER_STATE_UNKNOWN;
constexpr PowerState_WifiRadioPowerState PowerState_WifiRadioPowerState_WifiRadioPowerState_MAX = PowerState_WifiRadioPowerState_WIFI_RADIO_POWER_STATE_OFF;
constexpr int PowerState_WifiRadioPowerState_WifiRadioPowerState_ARRAYSIZE = PowerState_WifiRadioPowerState_WifiRadioPowerState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PowerState_WifiRadioPowerState_descriptor();
template<typename T>
inline const std::string& PowerState_WifiRadioPowerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerState_WifiRadioPowerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerState_WifiRadioPowerState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PowerState_WifiRadioPowerState_descriptor(), enum_t_value);
}
inline bool PowerState_WifiRadioPowerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerState_WifiRadioPowerState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PowerState_WifiRadioPowerState>(
    PowerState_WifiRadioPowerState_descriptor(), name, value);
}
enum SystemFault_Severity : int {
  SystemFault_Severity_SEVERITY_UNKNOWN = 0,
  SystemFault_Severity_SEVERITY_INFO = 1,
  SystemFault_Severity_SEVERITY_WARN = 2,
  SystemFault_Severity_SEVERITY_CRITICAL = 3,
  SystemFault_Severity_SystemFault_Severity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SystemFault_Severity_SystemFault_Severity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SystemFault_Severity_IsValid(int value);
constexpr SystemFault_Severity SystemFault_Severity_Severity_MIN = SystemFault_Severity_SEVERITY_UNKNOWN;
constexpr SystemFault_Severity SystemFault_Severity_Severity_MAX = SystemFault_Severity_SEVERITY_CRITICAL;
constexpr int SystemFault_Severity_Severity_ARRAYSIZE = SystemFault_Severity_Severity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SystemFault_Severity_descriptor();
template<typename T>
inline const std::string& SystemFault_Severity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SystemFault_Severity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SystemFault_Severity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SystemFault_Severity_descriptor(), enum_t_value);
}
inline bool SystemFault_Severity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemFault_Severity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SystemFault_Severity>(
    SystemFault_Severity_descriptor(), name, value);
}
enum EStopState_Type : int {
  EStopState_Type_TYPE_UNKNOWN = 0,
  EStopState_Type_TYPE_HARDWARE = 1,
  EStopState_Type_TYPE_SOFTWARE = 2,
  EStopState_Type_EStopState_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EStopState_Type_EStopState_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EStopState_Type_IsValid(int value);
constexpr EStopState_Type EStopState_Type_Type_MIN = EStopState_Type_TYPE_UNKNOWN;
constexpr EStopState_Type EStopState_Type_Type_MAX = EStopState_Type_TYPE_SOFTWARE;
constexpr int EStopState_Type_Type_ARRAYSIZE = EStopState_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStopState_Type_descriptor();
template<typename T>
inline const std::string& EStopState_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStopState_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStopState_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStopState_Type_descriptor(), enum_t_value);
}
inline bool EStopState_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStopState_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStopState_Type>(
    EStopState_Type_descriptor(), name, value);
}
enum EStopState_State : int {
  EStopState_State_STATE_UNKNOWN = 0,
  EStopState_State_STATE_ESTOPPED = 1,
  EStopState_State_STATE_NOT_ESTOPPED = 2,
  EStopState_State_EStopState_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EStopState_State_EStopState_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EStopState_State_IsValid(int value);
constexpr EStopState_State EStopState_State_State_MIN = EStopState_State_STATE_UNKNOWN;
constexpr EStopState_State EStopState_State_State_MAX = EStopState_State_STATE_NOT_ESTOPPED;
constexpr int EStopState_State_State_ARRAYSIZE = EStopState_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStopState_State_descriptor();
template<typename T>
inline const std::string& EStopState_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStopState_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStopState_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStopState_State_descriptor(), enum_t_value);
}
inline bool EStopState_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStopState_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStopState_State>(
    EStopState_State_descriptor(), name, value);
}
enum BatteryState_Status : int {
  BatteryState_Status_STATUS_UNKNOWN = 0,
  BatteryState_Status_STATUS_MISSING = 1,
  BatteryState_Status_STATUS_CHARGING = 2,
  BatteryState_Status_STATUS_DISCHARGING = 3,
  BatteryState_Status_STATUS_BOOTING = 4,
  BatteryState_Status_BatteryState_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BatteryState_Status_BatteryState_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BatteryState_Status_IsValid(int value);
constexpr BatteryState_Status BatteryState_Status_Status_MIN = BatteryState_Status_STATUS_UNKNOWN;
constexpr BatteryState_Status BatteryState_Status_Status_MAX = BatteryState_Status_STATUS_BOOTING;
constexpr int BatteryState_Status_Status_ARRAYSIZE = BatteryState_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatteryState_Status_descriptor();
template<typename T>
inline const std::string& BatteryState_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BatteryState_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BatteryState_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BatteryState_Status_descriptor(), enum_t_value);
}
inline bool BatteryState_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BatteryState_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BatteryState_Status>(
    BatteryState_Status_descriptor(), name, value);
}
enum BehaviorFault_Cause : int {
  BehaviorFault_Cause_CAUSE_UNKNOWN = 0,
  BehaviorFault_Cause_CAUSE_FALL = 1,
  BehaviorFault_Cause_CAUSE_HARDWARE = 2,
  BehaviorFault_Cause_CAUSE_LEASE_TIMEOUT = 3,
  BehaviorFault_Cause_BehaviorFault_Cause_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BehaviorFault_Cause_BehaviorFault_Cause_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BehaviorFault_Cause_IsValid(int value);
constexpr BehaviorFault_Cause BehaviorFault_Cause_Cause_MIN = BehaviorFault_Cause_CAUSE_UNKNOWN;
constexpr BehaviorFault_Cause BehaviorFault_Cause_Cause_MAX = BehaviorFault_Cause_CAUSE_LEASE_TIMEOUT;
constexpr int BehaviorFault_Cause_Cause_ARRAYSIZE = BehaviorFault_Cause_Cause_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BehaviorFault_Cause_descriptor();
template<typename T>
inline const std::string& BehaviorFault_Cause_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BehaviorFault_Cause>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BehaviorFault_Cause_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BehaviorFault_Cause_descriptor(), enum_t_value);
}
inline bool BehaviorFault_Cause_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BehaviorFault_Cause* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BehaviorFault_Cause>(
    BehaviorFault_Cause_descriptor(), name, value);
}
enum BehaviorFault_Status : int {
  BehaviorFault_Status_STATUS_UNKNOWN = 0,
  BehaviorFault_Status_STATUS_CLEARABLE = 1,
  BehaviorFault_Status_STATUS_UNCLEARABLE = 2,
  BehaviorFault_Status_BehaviorFault_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BehaviorFault_Status_BehaviorFault_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BehaviorFault_Status_IsValid(int value);
constexpr BehaviorFault_Status BehaviorFault_Status_Status_MIN = BehaviorFault_Status_STATUS_UNKNOWN;
constexpr BehaviorFault_Status BehaviorFault_Status_Status_MAX = BehaviorFault_Status_STATUS_UNCLEARABLE;
constexpr int BehaviorFault_Status_Status_ARRAYSIZE = BehaviorFault_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BehaviorFault_Status_descriptor();
template<typename T>
inline const std::string& BehaviorFault_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BehaviorFault_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BehaviorFault_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BehaviorFault_Status_descriptor(), enum_t_value);
}
inline bool BehaviorFault_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BehaviorFault_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BehaviorFault_Status>(
    BehaviorFault_Status_descriptor(), name, value);
}
enum WiFiState_Mode : int {
  WiFiState_Mode_MODE_UNKNOWN = 0,
  WiFiState_Mode_MODE_ACCESS_POINT = 1,
  WiFiState_Mode_MODE_CLIENT = 2,
  WiFiState_Mode_WiFiState_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WiFiState_Mode_WiFiState_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WiFiState_Mode_IsValid(int value);
constexpr WiFiState_Mode WiFiState_Mode_Mode_MIN = WiFiState_Mode_MODE_UNKNOWN;
constexpr WiFiState_Mode WiFiState_Mode_Mode_MAX = WiFiState_Mode_MODE_CLIENT;
constexpr int WiFiState_Mode_Mode_ARRAYSIZE = WiFiState_Mode_Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WiFiState_Mode_descriptor();
template<typename T>
inline const std::string& WiFiState_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WiFiState_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WiFiState_Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WiFiState_Mode_descriptor(), enum_t_value);
}
inline bool WiFiState_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WiFiState_Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WiFiState_Mode>(
    WiFiState_Mode_descriptor(), name, value);
}
enum FootState_Contact : int {
  FootState_Contact_CONTACT_UNKNOWN = 0,
  FootState_Contact_CONTACT_MADE = 1,
  FootState_Contact_CONTACT_LOST = 2,
  FootState_Contact_FootState_Contact_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FootState_Contact_FootState_Contact_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FootState_Contact_IsValid(int value);
constexpr FootState_Contact FootState_Contact_Contact_MIN = FootState_Contact_CONTACT_UNKNOWN;
constexpr FootState_Contact FootState_Contact_Contact_MAX = FootState_Contact_CONTACT_LOST;
constexpr int FootState_Contact_Contact_ARRAYSIZE = FootState_Contact_Contact_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FootState_Contact_descriptor();
template<typename T>
inline const std::string& FootState_Contact_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FootState_Contact>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FootState_Contact_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FootState_Contact_descriptor(), enum_t_value);
}
inline bool FootState_Contact_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FootState_Contact* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FootState_Contact>(
    FootState_Contact_descriptor(), name, value);
}
enum ManipulatorState_StowState : int {
  ManipulatorState_StowState_STOWSTATE_UNKNOWN = 0,
  ManipulatorState_StowState_STOWSTATE_STOWED = 1,
  ManipulatorState_StowState_STOWSTATE_DEPLOYED = 2,
  ManipulatorState_StowState_ManipulatorState_StowState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ManipulatorState_StowState_ManipulatorState_StowState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ManipulatorState_StowState_IsValid(int value);
constexpr ManipulatorState_StowState ManipulatorState_StowState_StowState_MIN = ManipulatorState_StowState_STOWSTATE_UNKNOWN;
constexpr ManipulatorState_StowState ManipulatorState_StowState_StowState_MAX = ManipulatorState_StowState_STOWSTATE_DEPLOYED;
constexpr int ManipulatorState_StowState_StowState_ARRAYSIZE = ManipulatorState_StowState_StowState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ManipulatorState_StowState_descriptor();
template<typename T>
inline const std::string& ManipulatorState_StowState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ManipulatorState_StowState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ManipulatorState_StowState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ManipulatorState_StowState_descriptor(), enum_t_value);
}
inline bool ManipulatorState_StowState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ManipulatorState_StowState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ManipulatorState_StowState>(
    ManipulatorState_StowState_descriptor(), name, value);
}
enum ManipulatorState_CarryState : int {
  ManipulatorState_CarryState_CARRY_STATE_UNKNOWN = 0,
  ManipulatorState_CarryState_CARRY_STATE_NOT_CARRIABLE = 1,
  ManipulatorState_CarryState_CARRY_STATE_CARRIABLE = 2,
  ManipulatorState_CarryState_CARRY_STATE_CARRIABLE_AND_STOWABLE = 3,
  ManipulatorState_CarryState_ManipulatorState_CarryState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ManipulatorState_CarryState_ManipulatorState_CarryState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ManipulatorState_CarryState_IsValid(int value);
constexpr ManipulatorState_CarryState ManipulatorState_CarryState_CarryState_MIN = ManipulatorState_CarryState_CARRY_STATE_UNKNOWN;
constexpr ManipulatorState_CarryState ManipulatorState_CarryState_CarryState_MAX = ManipulatorState_CarryState_CARRY_STATE_CARRIABLE_AND_STOWABLE;
constexpr int ManipulatorState_CarryState_CarryState_ARRAYSIZE = ManipulatorState_CarryState_CarryState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ManipulatorState_CarryState_descriptor();
template<typename T>
inline const std::string& ManipulatorState_CarryState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ManipulatorState_CarryState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ManipulatorState_CarryState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ManipulatorState_CarryState_descriptor(), enum_t_value);
}
inline bool ManipulatorState_CarryState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ManipulatorState_CarryState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ManipulatorState_CarryState>(
    ManipulatorState_CarryState_descriptor(), name, value);
}
enum RobotImpairedState_ImpairedStatus : int {
  RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_UNKNOWN = 0,
  RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_OK = 1,
  RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_NO_ROBOT_DATA = 2,
  RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_SYSTEM_FAULT = 3,
  RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_NO_MOTOR_POWER = 4,
  RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_REMOTE_CLOUDS_NOT_WORKING = 5,
  RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_SERVICE_FAULT = 6,
  RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_BEHAVIOR_FAULT = 7,
  RobotImpairedState_ImpairedStatus_RobotImpairedState_ImpairedStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RobotImpairedState_ImpairedStatus_RobotImpairedState_ImpairedStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RobotImpairedState_ImpairedStatus_IsValid(int value);
constexpr RobotImpairedState_ImpairedStatus RobotImpairedState_ImpairedStatus_ImpairedStatus_MIN = RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_UNKNOWN;
constexpr RobotImpairedState_ImpairedStatus RobotImpairedState_ImpairedStatus_ImpairedStatus_MAX = RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_BEHAVIOR_FAULT;
constexpr int RobotImpairedState_ImpairedStatus_ImpairedStatus_ARRAYSIZE = RobotImpairedState_ImpairedStatus_ImpairedStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RobotImpairedState_ImpairedStatus_descriptor();
template<typename T>
inline const std::string& RobotImpairedState_ImpairedStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RobotImpairedState_ImpairedStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RobotImpairedState_ImpairedStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RobotImpairedState_ImpairedStatus_descriptor(), enum_t_value);
}
inline bool RobotImpairedState_ImpairedStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RobotImpairedState_ImpairedStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RobotImpairedState_ImpairedStatus>(
    RobotImpairedState_ImpairedStatus_descriptor(), name, value);
}
// ===================================================================

class Skeleton_Link_ObjModel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Skeleton.Link.ObjModel) */ {
 public:
  inline Skeleton_Link_ObjModel() : Skeleton_Link_ObjModel(nullptr) {}
  ~Skeleton_Link_ObjModel() override;
  explicit PROTOBUF_CONSTEXPR Skeleton_Link_ObjModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Skeleton_Link_ObjModel(const Skeleton_Link_ObjModel& from);
  Skeleton_Link_ObjModel(Skeleton_Link_ObjModel&& from) noexcept
    : Skeleton_Link_ObjModel() {
    *this = ::std::move(from);
  }

  inline Skeleton_Link_ObjModel& operator=(const Skeleton_Link_ObjModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Skeleton_Link_ObjModel& operator=(Skeleton_Link_ObjModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Skeleton_Link_ObjModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const Skeleton_Link_ObjModel* internal_default_instance() {
    return reinterpret_cast<const Skeleton_Link_ObjModel*>(
               &_Skeleton_Link_ObjModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Skeleton_Link_ObjModel& a, Skeleton_Link_ObjModel& b) {
    a.Swap(&b);
  }
  inline void Swap(Skeleton_Link_ObjModel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Skeleton_Link_ObjModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Skeleton_Link_ObjModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Skeleton_Link_ObjModel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Skeleton_Link_ObjModel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Skeleton_Link_ObjModel& from) {
    Skeleton_Link_ObjModel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Skeleton_Link_ObjModel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Skeleton.Link.ObjModel";
  }
  protected:
  explicit Skeleton_Link_ObjModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 1,
    kFileContentsFieldNumber = 2,
  };
  // string file_name = 1;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // string file_contents = 2;
  void clear_file_contents();
  const std::string& file_contents() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_contents(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_contents();
  PROTOBUF_NODISCARD std::string* release_file_contents();
  void set_allocated_file_contents(std::string* file_contents);
  private:
  const std::string& _internal_file_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_contents(const std::string& value);
  std::string* _internal_mutable_file_contents();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Skeleton.Link.ObjModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_contents_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class Skeleton_Link final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Skeleton.Link) */ {
 public:
  inline Skeleton_Link() : Skeleton_Link(nullptr) {}
  ~Skeleton_Link() override;
  explicit PROTOBUF_CONSTEXPR Skeleton_Link(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Skeleton_Link(const Skeleton_Link& from);
  Skeleton_Link(Skeleton_Link&& from) noexcept
    : Skeleton_Link() {
    *this = ::std::move(from);
  }

  inline Skeleton_Link& operator=(const Skeleton_Link& from) {
    CopyFrom(from);
    return *this;
  }
  inline Skeleton_Link& operator=(Skeleton_Link&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Skeleton_Link& default_instance() {
    return *internal_default_instance();
  }
  static inline const Skeleton_Link* internal_default_instance() {
    return reinterpret_cast<const Skeleton_Link*>(
               &_Skeleton_Link_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Skeleton_Link& a, Skeleton_Link& b) {
    a.Swap(&b);
  }
  inline void Swap(Skeleton_Link* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Skeleton_Link* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Skeleton_Link* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Skeleton_Link>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Skeleton_Link& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Skeleton_Link& from) {
    Skeleton_Link::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Skeleton_Link* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Skeleton.Link";
  }
  protected:
  explicit Skeleton_Link(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Skeleton_Link_ObjModel ObjModel;

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kObjModelFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .bosdyn.api.Skeleton.Link.ObjModel obj_model = 2;
  bool has_obj_model() const;
  private:
  bool _internal_has_obj_model() const;
  public:
  void clear_obj_model();
  const ::bosdyn::api::Skeleton_Link_ObjModel& obj_model() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Skeleton_Link_ObjModel* release_obj_model();
  ::bosdyn::api::Skeleton_Link_ObjModel* mutable_obj_model();
  void set_allocated_obj_model(::bosdyn::api::Skeleton_Link_ObjModel* obj_model);
  private:
  const ::bosdyn::api::Skeleton_Link_ObjModel& _internal_obj_model() const;
  ::bosdyn::api::Skeleton_Link_ObjModel* _internal_mutable_obj_model();
  public:
  void unsafe_arena_set_allocated_obj_model(
      ::bosdyn::api::Skeleton_Link_ObjModel* obj_model);
  ::bosdyn::api::Skeleton_Link_ObjModel* unsafe_arena_release_obj_model();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Skeleton.Link)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::bosdyn::api::Skeleton_Link_ObjModel* obj_model_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class Skeleton final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Skeleton) */ {
 public:
  inline Skeleton() : Skeleton(nullptr) {}
  ~Skeleton() override;
  explicit PROTOBUF_CONSTEXPR Skeleton(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Skeleton(const Skeleton& from);
  Skeleton(Skeleton&& from) noexcept
    : Skeleton() {
    *this = ::std::move(from);
  }

  inline Skeleton& operator=(const Skeleton& from) {
    CopyFrom(from);
    return *this;
  }
  inline Skeleton& operator=(Skeleton&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Skeleton& default_instance() {
    return *internal_default_instance();
  }
  static inline const Skeleton* internal_default_instance() {
    return reinterpret_cast<const Skeleton*>(
               &_Skeleton_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Skeleton& a, Skeleton& b) {
    a.Swap(&b);
  }
  inline void Swap(Skeleton* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Skeleton* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Skeleton* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Skeleton>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Skeleton& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Skeleton& from) {
    Skeleton::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Skeleton* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Skeleton";
  }
  protected:
  explicit Skeleton(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Skeleton_Link Link;

  // accessors -------------------------------------------------------

  enum : int {
    kLinksFieldNumber = 2,
    kUrdfFieldNumber = 3,
  };
  // repeated .bosdyn.api.Skeleton.Link links = 2;
  int links_size() const;
  private:
  int _internal_links_size() const;
  public:
  void clear_links();
  ::bosdyn::api::Skeleton_Link* mutable_links(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Skeleton_Link >*
      mutable_links();
  private:
  const ::bosdyn::api::Skeleton_Link& _internal_links(int index) const;
  ::bosdyn::api::Skeleton_Link* _internal_add_links();
  public:
  const ::bosdyn::api::Skeleton_Link& links(int index) const;
  ::bosdyn::api::Skeleton_Link* add_links();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Skeleton_Link >&
      links() const;

  // string urdf = 3;
  void clear_urdf();
  const std::string& urdf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_urdf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_urdf();
  PROTOBUF_NODISCARD std::string* release_urdf();
  void set_allocated_urdf(std::string* urdf);
  private:
  const std::string& _internal_urdf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_urdf(const std::string& value);
  std::string* _internal_mutable_urdf();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Skeleton)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Skeleton_Link > links_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr urdf_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class HardwareConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.HardwareConfiguration) */ {
 public:
  inline HardwareConfiguration() : HardwareConfiguration(nullptr) {}
  ~HardwareConfiguration() override;
  explicit PROTOBUF_CONSTEXPR HardwareConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HardwareConfiguration(const HardwareConfiguration& from);
  HardwareConfiguration(HardwareConfiguration&& from) noexcept
    : HardwareConfiguration() {
    *this = ::std::move(from);
  }

  inline HardwareConfiguration& operator=(const HardwareConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline HardwareConfiguration& operator=(HardwareConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HardwareConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const HardwareConfiguration* internal_default_instance() {
    return reinterpret_cast<const HardwareConfiguration*>(
               &_HardwareConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HardwareConfiguration& a, HardwareConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(HardwareConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HardwareConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HardwareConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HardwareConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HardwareConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HardwareConfiguration& from) {
    HardwareConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HardwareConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.HardwareConfiguration";
  }
  protected:
  explicit HardwareConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkeletonFieldNumber = 1,
    kCanPowerCommandRequestOffRobotFieldNumber = 2,
    kCanPowerCommandRequestCycleRobotFieldNumber = 3,
    kCanPowerCommandRequestPayloadPortsFieldNumber = 4,
    kCanPowerCommandRequestWifiRadioFieldNumber = 5,
  };
  // .bosdyn.api.Skeleton skeleton = 1;
  bool has_skeleton() const;
  private:
  bool _internal_has_skeleton() const;
  public:
  void clear_skeleton();
  const ::bosdyn::api::Skeleton& skeleton() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Skeleton* release_skeleton();
  ::bosdyn::api::Skeleton* mutable_skeleton();
  void set_allocated_skeleton(::bosdyn::api::Skeleton* skeleton);
  private:
  const ::bosdyn::api::Skeleton& _internal_skeleton() const;
  ::bosdyn::api::Skeleton* _internal_mutable_skeleton();
  public:
  void unsafe_arena_set_allocated_skeleton(
      ::bosdyn::api::Skeleton* skeleton);
  ::bosdyn::api::Skeleton* unsafe_arena_release_skeleton();

  // bool can_power_command_request_off_robot = 2;
  void clear_can_power_command_request_off_robot();
  bool can_power_command_request_off_robot() const;
  void set_can_power_command_request_off_robot(bool value);
  private:
  bool _internal_can_power_command_request_off_robot() const;
  void _internal_set_can_power_command_request_off_robot(bool value);
  public:

  // bool can_power_command_request_cycle_robot = 3;
  void clear_can_power_command_request_cycle_robot();
  bool can_power_command_request_cycle_robot() const;
  void set_can_power_command_request_cycle_robot(bool value);
  private:
  bool _internal_can_power_command_request_cycle_robot() const;
  void _internal_set_can_power_command_request_cycle_robot(bool value);
  public:

  // bool can_power_command_request_payload_ports = 4;
  void clear_can_power_command_request_payload_ports();
  bool can_power_command_request_payload_ports() const;
  void set_can_power_command_request_payload_ports(bool value);
  private:
  bool _internal_can_power_command_request_payload_ports() const;
  void _internal_set_can_power_command_request_payload_ports(bool value);
  public:

  // bool can_power_command_request_wifi_radio = 5;
  void clear_can_power_command_request_wifi_radio();
  bool can_power_command_request_wifi_radio() const;
  void set_can_power_command_request_wifi_radio(bool value);
  private:
  bool _internal_can_power_command_request_wifi_radio() const;
  void _internal_set_can_power_command_request_wifi_radio(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.HardwareConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Skeleton* skeleton_;
    bool can_power_command_request_off_robot_;
    bool can_power_command_request_cycle_robot_;
    bool can_power_command_request_payload_ports_;
    bool can_power_command_request_wifi_radio_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotState) */ {
 public:
  inline RobotState() : RobotState(nullptr) {}
  ~RobotState() override;
  explicit PROTOBUF_CONSTEXPR RobotState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotState(const RobotState& from);
  RobotState(RobotState&& from) noexcept
    : RobotState() {
    *this = ::std::move(from);
  }

  inline RobotState& operator=(const RobotState& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotState& operator=(RobotState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotState& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotState* internal_default_instance() {
    return reinterpret_cast<const RobotState*>(
               &_RobotState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RobotState& a, RobotState& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotState& from) {
    RobotState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotState";
  }
  protected:
  explicit RobotState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatteryStatesFieldNumber = 2,
    kCommsStatesFieldNumber = 3,
    kEstopStatesFieldNumber = 5,
    kFootStateFieldNumber = 8,
    kPowerStateFieldNumber = 1,
    kSystemFaultStateFieldNumber = 4,
    kKinematicStateFieldNumber = 6,
    kBehaviorFaultStateFieldNumber = 7,
    kServiceFaultStateFieldNumber = 10,
    kManipulatorStateFieldNumber = 11,
    kTerrainStateFieldNumber = 12,
  };
  // repeated .bosdyn.api.BatteryState battery_states = 2;
  int battery_states_size() const;
  private:
  int _internal_battery_states_size() const;
  public:
  void clear_battery_states();
  ::bosdyn::api::BatteryState* mutable_battery_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BatteryState >*
      mutable_battery_states();
  private:
  const ::bosdyn::api::BatteryState& _internal_battery_states(int index) const;
  ::bosdyn::api::BatteryState* _internal_add_battery_states();
  public:
  const ::bosdyn::api::BatteryState& battery_states(int index) const;
  ::bosdyn::api::BatteryState* add_battery_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BatteryState >&
      battery_states() const;

  // repeated .bosdyn.api.CommsState comms_states = 3;
  int comms_states_size() const;
  private:
  int _internal_comms_states_size() const;
  public:
  void clear_comms_states();
  ::bosdyn::api::CommsState* mutable_comms_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CommsState >*
      mutable_comms_states();
  private:
  const ::bosdyn::api::CommsState& _internal_comms_states(int index) const;
  ::bosdyn::api::CommsState* _internal_add_comms_states();
  public:
  const ::bosdyn::api::CommsState& comms_states(int index) const;
  ::bosdyn::api::CommsState* add_comms_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CommsState >&
      comms_states() const;

  // repeated .bosdyn.api.EStopState estop_states = 5;
  int estop_states_size() const;
  private:
  int _internal_estop_states_size() const;
  public:
  void clear_estop_states();
  ::bosdyn::api::EStopState* mutable_estop_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EStopState >*
      mutable_estop_states();
  private:
  const ::bosdyn::api::EStopState& _internal_estop_states(int index) const;
  ::bosdyn::api::EStopState* _internal_add_estop_states();
  public:
  const ::bosdyn::api::EStopState& estop_states(int index) const;
  ::bosdyn::api::EStopState* add_estop_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EStopState >&
      estop_states() const;

  // repeated .bosdyn.api.FootState foot_state = 8;
  int foot_state_size() const;
  private:
  int _internal_foot_state_size() const;
  public:
  void clear_foot_state();
  ::bosdyn::api::FootState* mutable_foot_state(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::FootState >*
      mutable_foot_state();
  private:
  const ::bosdyn::api::FootState& _internal_foot_state(int index) const;
  ::bosdyn::api::FootState* _internal_add_foot_state();
  public:
  const ::bosdyn::api::FootState& foot_state(int index) const;
  ::bosdyn::api::FootState* add_foot_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::FootState >&
      foot_state() const;

  // .bosdyn.api.PowerState power_state = 1;
  bool has_power_state() const;
  private:
  bool _internal_has_power_state() const;
  public:
  void clear_power_state();
  const ::bosdyn::api::PowerState& power_state() const;
  PROTOBUF_NODISCARD ::bosdyn::api::PowerState* release_power_state();
  ::bosdyn::api::PowerState* mutable_power_state();
  void set_allocated_power_state(::bosdyn::api::PowerState* power_state);
  private:
  const ::bosdyn::api::PowerState& _internal_power_state() const;
  ::bosdyn::api::PowerState* _internal_mutable_power_state();
  public:
  void unsafe_arena_set_allocated_power_state(
      ::bosdyn::api::PowerState* power_state);
  ::bosdyn::api::PowerState* unsafe_arena_release_power_state();

  // .bosdyn.api.SystemFaultState system_fault_state = 4;
  bool has_system_fault_state() const;
  private:
  bool _internal_has_system_fault_state() const;
  public:
  void clear_system_fault_state();
  const ::bosdyn::api::SystemFaultState& system_fault_state() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SystemFaultState* release_system_fault_state();
  ::bosdyn::api::SystemFaultState* mutable_system_fault_state();
  void set_allocated_system_fault_state(::bosdyn::api::SystemFaultState* system_fault_state);
  private:
  const ::bosdyn::api::SystemFaultState& _internal_system_fault_state() const;
  ::bosdyn::api::SystemFaultState* _internal_mutable_system_fault_state();
  public:
  void unsafe_arena_set_allocated_system_fault_state(
      ::bosdyn::api::SystemFaultState* system_fault_state);
  ::bosdyn::api::SystemFaultState* unsafe_arena_release_system_fault_state();

  // .bosdyn.api.KinematicState kinematic_state = 6;
  bool has_kinematic_state() const;
  private:
  bool _internal_has_kinematic_state() const;
  public:
  void clear_kinematic_state();
  const ::bosdyn::api::KinematicState& kinematic_state() const;
  PROTOBUF_NODISCARD ::bosdyn::api::KinematicState* release_kinematic_state();
  ::bosdyn::api::KinematicState* mutable_kinematic_state();
  void set_allocated_kinematic_state(::bosdyn::api::KinematicState* kinematic_state);
  private:
  const ::bosdyn::api::KinematicState& _internal_kinematic_state() const;
  ::bosdyn::api::KinematicState* _internal_mutable_kinematic_state();
  public:
  void unsafe_arena_set_allocated_kinematic_state(
      ::bosdyn::api::KinematicState* kinematic_state);
  ::bosdyn::api::KinematicState* unsafe_arena_release_kinematic_state();

  // .bosdyn.api.BehaviorFaultState behavior_fault_state = 7;
  bool has_behavior_fault_state() const;
  private:
  bool _internal_has_behavior_fault_state() const;
  public:
  void clear_behavior_fault_state();
  const ::bosdyn::api::BehaviorFaultState& behavior_fault_state() const;
  PROTOBUF_NODISCARD ::bosdyn::api::BehaviorFaultState* release_behavior_fault_state();
  ::bosdyn::api::BehaviorFaultState* mutable_behavior_fault_state();
  void set_allocated_behavior_fault_state(::bosdyn::api::BehaviorFaultState* behavior_fault_state);
  private:
  const ::bosdyn::api::BehaviorFaultState& _internal_behavior_fault_state() const;
  ::bosdyn::api::BehaviorFaultState* _internal_mutable_behavior_fault_state();
  public:
  void unsafe_arena_set_allocated_behavior_fault_state(
      ::bosdyn::api::BehaviorFaultState* behavior_fault_state);
  ::bosdyn::api::BehaviorFaultState* unsafe_arena_release_behavior_fault_state();

  // .bosdyn.api.ServiceFaultState service_fault_state = 10;
  bool has_service_fault_state() const;
  private:
  bool _internal_has_service_fault_state() const;
  public:
  void clear_service_fault_state();
  const ::bosdyn::api::ServiceFaultState& service_fault_state() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ServiceFaultState* release_service_fault_state();
  ::bosdyn::api::ServiceFaultState* mutable_service_fault_state();
  void set_allocated_service_fault_state(::bosdyn::api::ServiceFaultState* service_fault_state);
  private:
  const ::bosdyn::api::ServiceFaultState& _internal_service_fault_state() const;
  ::bosdyn::api::ServiceFaultState* _internal_mutable_service_fault_state();
  public:
  void unsafe_arena_set_allocated_service_fault_state(
      ::bosdyn::api::ServiceFaultState* service_fault_state);
  ::bosdyn::api::ServiceFaultState* unsafe_arena_release_service_fault_state();

  // .bosdyn.api.ManipulatorState manipulator_state = 11;
  bool has_manipulator_state() const;
  private:
  bool _internal_has_manipulator_state() const;
  public:
  void clear_manipulator_state();
  const ::bosdyn::api::ManipulatorState& manipulator_state() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ManipulatorState* release_manipulator_state();
  ::bosdyn::api::ManipulatorState* mutable_manipulator_state();
  void set_allocated_manipulator_state(::bosdyn::api::ManipulatorState* manipulator_state);
  private:
  const ::bosdyn::api::ManipulatorState& _internal_manipulator_state() const;
  ::bosdyn::api::ManipulatorState* _internal_mutable_manipulator_state();
  public:
  void unsafe_arena_set_allocated_manipulator_state(
      ::bosdyn::api::ManipulatorState* manipulator_state);
  ::bosdyn::api::ManipulatorState* unsafe_arena_release_manipulator_state();

  // .bosdyn.api.TerrainState terrain_state = 12;
  bool has_terrain_state() const;
  private:
  bool _internal_has_terrain_state() const;
  public:
  void clear_terrain_state();
  const ::bosdyn::api::TerrainState& terrain_state() const;
  PROTOBUF_NODISCARD ::bosdyn::api::TerrainState* release_terrain_state();
  ::bosdyn::api::TerrainState* mutable_terrain_state();
  void set_allocated_terrain_state(::bosdyn::api::TerrainState* terrain_state);
  private:
  const ::bosdyn::api::TerrainState& _internal_terrain_state() const;
  ::bosdyn::api::TerrainState* _internal_mutable_terrain_state();
  public:
  void unsafe_arena_set_allocated_terrain_state(
      ::bosdyn::api::TerrainState* terrain_state);
  ::bosdyn::api::TerrainState* unsafe_arena_release_terrain_state();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BatteryState > battery_states_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CommsState > comms_states_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EStopState > estop_states_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::FootState > foot_state_;
    ::bosdyn::api::PowerState* power_state_;
    ::bosdyn::api::SystemFaultState* system_fault_state_;
    ::bosdyn::api::KinematicState* kinematic_state_;
    ::bosdyn::api::BehaviorFaultState* behavior_fault_state_;
    ::bosdyn::api::ServiceFaultState* service_fault_state_;
    ::bosdyn::api::ManipulatorState* manipulator_state_;
    ::bosdyn::api::TerrainState* terrain_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class PowerState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PowerState) */ {
 public:
  inline PowerState() : PowerState(nullptr) {}
  ~PowerState() override;
  explicit PROTOBUF_CONSTEXPR PowerState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PowerState(const PowerState& from);
  PowerState(PowerState&& from) noexcept
    : PowerState() {
    *this = ::std::move(from);
  }

  inline PowerState& operator=(const PowerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PowerState& operator=(PowerState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PowerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const PowerState* internal_default_instance() {
    return reinterpret_cast<const PowerState*>(
               &_PowerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PowerState& a, PowerState& b) {
    a.Swap(&b);
  }
  inline void Swap(PowerState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PowerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PowerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PowerState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PowerState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PowerState& from) {
    PowerState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PowerState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PowerState";
  }
  protected:
  explicit PowerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PowerState_MotorPowerState MotorPowerState;
  PROTOBUF_DEPRECATED_ENUM static constexpr MotorPowerState STATE_UNKNOWN =
    PowerState_MotorPowerState_STATE_UNKNOWN;
  static constexpr MotorPowerState MOTOR_POWER_STATE_UNKNOWN =
    PowerState_MotorPowerState_MOTOR_POWER_STATE_UNKNOWN;
  PROTOBUF_DEPRECATED_ENUM static constexpr MotorPowerState STATE_OFF =
    PowerState_MotorPowerState_STATE_OFF;
  static constexpr MotorPowerState MOTOR_POWER_STATE_OFF =
    PowerState_MotorPowerState_MOTOR_POWER_STATE_OFF;
  PROTOBUF_DEPRECATED_ENUM static constexpr MotorPowerState STATE_ON =
    PowerState_MotorPowerState_STATE_ON;
  static constexpr MotorPowerState MOTOR_POWER_STATE_ON =
    PowerState_MotorPowerState_MOTOR_POWER_STATE_ON;
  PROTOBUF_DEPRECATED_ENUM static constexpr MotorPowerState STATE_POWERING_ON =
    PowerState_MotorPowerState_STATE_POWERING_ON;
  static constexpr MotorPowerState MOTOR_POWER_STATE_POWERING_ON =
    PowerState_MotorPowerState_MOTOR_POWER_STATE_POWERING_ON;
  PROTOBUF_DEPRECATED_ENUM static constexpr MotorPowerState STATE_POWERING_OFF =
    PowerState_MotorPowerState_STATE_POWERING_OFF;
  static constexpr MotorPowerState MOTOR_POWER_STATE_POWERING_OFF =
    PowerState_MotorPowerState_MOTOR_POWER_STATE_POWERING_OFF;
  PROTOBUF_DEPRECATED_ENUM static constexpr MotorPowerState STATE_ERROR =
    PowerState_MotorPowerState_STATE_ERROR;
  static constexpr MotorPowerState MOTOR_POWER_STATE_ERROR =
    PowerState_MotorPowerState_MOTOR_POWER_STATE_ERROR;
  static inline bool MotorPowerState_IsValid(int value) {
    return PowerState_MotorPowerState_IsValid(value);
  }
  static constexpr MotorPowerState MotorPowerState_MIN =
    PowerState_MotorPowerState_MotorPowerState_MIN;
  static constexpr MotorPowerState MotorPowerState_MAX =
    PowerState_MotorPowerState_MotorPowerState_MAX;
  static constexpr int MotorPowerState_ARRAYSIZE =
    PowerState_MotorPowerState_MotorPowerState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MotorPowerState_descriptor() {
    return PowerState_MotorPowerState_descriptor();
  }
  template<typename T>
  static inline const std::string& MotorPowerState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MotorPowerState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MotorPowerState_Name.");
    return PowerState_MotorPowerState_Name(enum_t_value);
  }
  static inline bool MotorPowerState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MotorPowerState* value) {
    return PowerState_MotorPowerState_Parse(name, value);
  }

  typedef PowerState_ShorePowerState ShorePowerState;
  PROTOBUF_DEPRECATED_ENUM static constexpr ShorePowerState STATE_UNKNOWN_SHORE_POWER =
    PowerState_ShorePowerState_STATE_UNKNOWN_SHORE_POWER;
  static constexpr ShorePowerState SHORE_POWER_STATE_UNKNOWN =
    PowerState_ShorePowerState_SHORE_POWER_STATE_UNKNOWN;
  PROTOBUF_DEPRECATED_ENUM static constexpr ShorePowerState STATE_ON_SHORE_POWER =
    PowerState_ShorePowerState_STATE_ON_SHORE_POWER;
  static constexpr ShorePowerState SHORE_POWER_STATE_ON =
    PowerState_ShorePowerState_SHORE_POWER_STATE_ON;
  PROTOBUF_DEPRECATED_ENUM static constexpr ShorePowerState STATE_OFF_SHORE_POWER =
    PowerState_ShorePowerState_STATE_OFF_SHORE_POWER;
  static constexpr ShorePowerState SHORE_POWER_STATE_OFF =
    PowerState_ShorePowerState_SHORE_POWER_STATE_OFF;
  static inline bool ShorePowerState_IsValid(int value) {
    return PowerState_ShorePowerState_IsValid(value);
  }
  static constexpr ShorePowerState ShorePowerState_MIN =
    PowerState_ShorePowerState_ShorePowerState_MIN;
  static constexpr ShorePowerState ShorePowerState_MAX =
    PowerState_ShorePowerState_ShorePowerState_MAX;
  static constexpr int ShorePowerState_ARRAYSIZE =
    PowerState_ShorePowerState_ShorePowerState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ShorePowerState_descriptor() {
    return PowerState_ShorePowerState_descriptor();
  }
  template<typename T>
  static inline const std::string& ShorePowerState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ShorePowerState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ShorePowerState_Name.");
    return PowerState_ShorePowerState_Name(enum_t_value);
  }
  static inline bool ShorePowerState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ShorePowerState* value) {
    return PowerState_ShorePowerState_Parse(name, value);
  }

  typedef PowerState_RobotPowerState RobotPowerState;
  static constexpr RobotPowerState ROBOT_POWER_STATE_UNKNOWN =
    PowerState_RobotPowerState_ROBOT_POWER_STATE_UNKNOWN;
  static constexpr RobotPowerState ROBOT_POWER_STATE_ON =
    PowerState_RobotPowerState_ROBOT_POWER_STATE_ON;
  static constexpr RobotPowerState ROBOT_POWER_STATE_OFF =
    PowerState_RobotPowerState_ROBOT_POWER_STATE_OFF;
  static inline bool RobotPowerState_IsValid(int value) {
    return PowerState_RobotPowerState_IsValid(value);
  }
  static constexpr RobotPowerState RobotPowerState_MIN =
    PowerState_RobotPowerState_RobotPowerState_MIN;
  static constexpr RobotPowerState RobotPowerState_MAX =
    PowerState_RobotPowerState_RobotPowerState_MAX;
  static constexpr int RobotPowerState_ARRAYSIZE =
    PowerState_RobotPowerState_RobotPowerState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RobotPowerState_descriptor() {
    return PowerState_RobotPowerState_descriptor();
  }
  template<typename T>
  static inline const std::string& RobotPowerState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RobotPowerState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RobotPowerState_Name.");
    return PowerState_RobotPowerState_Name(enum_t_value);
  }
  static inline bool RobotPowerState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RobotPowerState* value) {
    return PowerState_RobotPowerState_Parse(name, value);
  }

  typedef PowerState_PayloadPortsPowerState PayloadPortsPowerState;
  static constexpr PayloadPortsPowerState PAYLOAD_PORTS_POWER_STATE_UNKNOWN =
    PowerState_PayloadPortsPowerState_PAYLOAD_PORTS_POWER_STATE_UNKNOWN;
  static constexpr PayloadPortsPowerState PAYLOAD_PORTS_POWER_STATE_ON =
    PowerState_PayloadPortsPowerState_PAYLOAD_PORTS_POWER_STATE_ON;
  static constexpr PayloadPortsPowerState PAYLOAD_PORTS_POWER_STATE_OFF =
    PowerState_PayloadPortsPowerState_PAYLOAD_PORTS_POWER_STATE_OFF;
  static inline bool PayloadPortsPowerState_IsValid(int value) {
    return PowerState_PayloadPortsPowerState_IsValid(value);
  }
  static constexpr PayloadPortsPowerState PayloadPortsPowerState_MIN =
    PowerState_PayloadPortsPowerState_PayloadPortsPowerState_MIN;
  static constexpr PayloadPortsPowerState PayloadPortsPowerState_MAX =
    PowerState_PayloadPortsPowerState_PayloadPortsPowerState_MAX;
  static constexpr int PayloadPortsPowerState_ARRAYSIZE =
    PowerState_PayloadPortsPowerState_PayloadPortsPowerState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PayloadPortsPowerState_descriptor() {
    return PowerState_PayloadPortsPowerState_descriptor();
  }
  template<typename T>
  static inline const std::string& PayloadPortsPowerState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PayloadPortsPowerState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PayloadPortsPowerState_Name.");
    return PowerState_PayloadPortsPowerState_Name(enum_t_value);
  }
  static inline bool PayloadPortsPowerState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PayloadPortsPowerState* value) {
    return PowerState_PayloadPortsPowerState_Parse(name, value);
  }

  typedef PowerState_WifiRadioPowerState WifiRadioPowerState;
  static constexpr WifiRadioPowerState WIFI_RADIO_POWER_STATE_UNKNOWN =
    PowerState_WifiRadioPowerState_WIFI_RADIO_POWER_STATE_UNKNOWN;
  static constexpr WifiRadioPowerState WIFI_RADIO_POWER_STATE_ON =
    PowerState_WifiRadioPowerState_WIFI_RADIO_POWER_STATE_ON;
  static constexpr WifiRadioPowerState WIFI_RADIO_POWER_STATE_OFF =
    PowerState_WifiRadioPowerState_WIFI_RADIO_POWER_STATE_OFF;
  static inline bool WifiRadioPowerState_IsValid(int value) {
    return PowerState_WifiRadioPowerState_IsValid(value);
  }
  static constexpr WifiRadioPowerState WifiRadioPowerState_MIN =
    PowerState_WifiRadioPowerState_WifiRadioPowerState_MIN;
  static constexpr WifiRadioPowerState WifiRadioPowerState_MAX =
    PowerState_WifiRadioPowerState_WifiRadioPowerState_MAX;
  static constexpr int WifiRadioPowerState_ARRAYSIZE =
    PowerState_WifiRadioPowerState_WifiRadioPowerState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  WifiRadioPowerState_descriptor() {
    return PowerState_WifiRadioPowerState_descriptor();
  }
  template<typename T>
  static inline const std::string& WifiRadioPowerState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WifiRadioPowerState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WifiRadioPowerState_Name.");
    return PowerState_WifiRadioPowerState_Name(enum_t_value);
  }
  static inline bool WifiRadioPowerState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      WifiRadioPowerState* value) {
    return PowerState_WifiRadioPowerState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kLocomotionChargePercentageFieldNumber = 4,
    kLocomotionEstimatedRuntimeFieldNumber = 5,
    kMotorPowerStateFieldNumber = 2,
    kShorePowerStateFieldNumber = 3,
    kRobotPowerStateFieldNumber = 6,
    kPayloadPortsPowerStateFieldNumber = 7,
    kWifiRadioPowerStateFieldNumber = 9,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .google.protobuf.DoubleValue locomotion_charge_percentage = 4;
  bool has_locomotion_charge_percentage() const;
  private:
  bool _internal_has_locomotion_charge_percentage() const;
  public:
  void clear_locomotion_charge_percentage();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& locomotion_charge_percentage() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_locomotion_charge_percentage();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_locomotion_charge_percentage();
  void set_allocated_locomotion_charge_percentage(::PROTOBUF_NAMESPACE_ID::DoubleValue* locomotion_charge_percentage);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_locomotion_charge_percentage() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_locomotion_charge_percentage();
  public:
  void unsafe_arena_set_allocated_locomotion_charge_percentage(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* locomotion_charge_percentage);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_locomotion_charge_percentage();

  // .google.protobuf.Duration locomotion_estimated_runtime = 5;
  bool has_locomotion_estimated_runtime() const;
  private:
  bool _internal_has_locomotion_estimated_runtime() const;
  public:
  void clear_locomotion_estimated_runtime();
  const ::PROTOBUF_NAMESPACE_ID::Duration& locomotion_estimated_runtime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_locomotion_estimated_runtime();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_locomotion_estimated_runtime();
  void set_allocated_locomotion_estimated_runtime(::PROTOBUF_NAMESPACE_ID::Duration* locomotion_estimated_runtime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_locomotion_estimated_runtime() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_locomotion_estimated_runtime();
  public:
  void unsafe_arena_set_allocated_locomotion_estimated_runtime(
      ::PROTOBUF_NAMESPACE_ID::Duration* locomotion_estimated_runtime);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_locomotion_estimated_runtime();

  // .bosdyn.api.PowerState.MotorPowerState motor_power_state = 2;
  void clear_motor_power_state();
  ::bosdyn::api::PowerState_MotorPowerState motor_power_state() const;
  void set_motor_power_state(::bosdyn::api::PowerState_MotorPowerState value);
  private:
  ::bosdyn::api::PowerState_MotorPowerState _internal_motor_power_state() const;
  void _internal_set_motor_power_state(::bosdyn::api::PowerState_MotorPowerState value);
  public:

  // .bosdyn.api.PowerState.ShorePowerState shore_power_state = 3;
  void clear_shore_power_state();
  ::bosdyn::api::PowerState_ShorePowerState shore_power_state() const;
  void set_shore_power_state(::bosdyn::api::PowerState_ShorePowerState value);
  private:
  ::bosdyn::api::PowerState_ShorePowerState _internal_shore_power_state() const;
  void _internal_set_shore_power_state(::bosdyn::api::PowerState_ShorePowerState value);
  public:

  // .bosdyn.api.PowerState.RobotPowerState robot_power_state = 6;
  void clear_robot_power_state();
  ::bosdyn::api::PowerState_RobotPowerState robot_power_state() const;
  void set_robot_power_state(::bosdyn::api::PowerState_RobotPowerState value);
  private:
  ::bosdyn::api::PowerState_RobotPowerState _internal_robot_power_state() const;
  void _internal_set_robot_power_state(::bosdyn::api::PowerState_RobotPowerState value);
  public:

  // .bosdyn.api.PowerState.PayloadPortsPowerState payload_ports_power_state = 7;
  void clear_payload_ports_power_state();
  ::bosdyn::api::PowerState_PayloadPortsPowerState payload_ports_power_state() const;
  void set_payload_ports_power_state(::bosdyn::api::PowerState_PayloadPortsPowerState value);
  private:
  ::bosdyn::api::PowerState_PayloadPortsPowerState _internal_payload_ports_power_state() const;
  void _internal_set_payload_ports_power_state(::bosdyn::api::PowerState_PayloadPortsPowerState value);
  public:

  // .bosdyn.api.PowerState.WifiRadioPowerState wifi_radio_power_state = 9;
  void clear_wifi_radio_power_state();
  ::bosdyn::api::PowerState_WifiRadioPowerState wifi_radio_power_state() const;
  void set_wifi_radio_power_state(::bosdyn::api::PowerState_WifiRadioPowerState value);
  private:
  ::bosdyn::api::PowerState_WifiRadioPowerState _internal_wifi_radio_power_state() const;
  void _internal_set_wifi_radio_power_state(::bosdyn::api::PowerState_WifiRadioPowerState value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.PowerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* locomotion_charge_percentage_;
    ::PROTOBUF_NAMESPACE_ID::Duration* locomotion_estimated_runtime_;
    int motor_power_state_;
    int shore_power_state_;
    int robot_power_state_;
    int payload_ports_power_state_;
    int wifi_radio_power_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class SystemFaultState_AggregatedEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SystemFaultState_AggregatedEntry_DoNotUse, 
    std::string, ::bosdyn::api::SystemFault_Severity,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SystemFaultState_AggregatedEntry_DoNotUse, 
    std::string, ::bosdyn::api::SystemFault_Severity,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> SuperType;
  SystemFaultState_AggregatedEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SystemFaultState_AggregatedEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SystemFaultState_AggregatedEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SystemFaultState_AggregatedEntry_DoNotUse& other);
  static const SystemFaultState_AggregatedEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SystemFaultState_AggregatedEntry_DoNotUse*>(&_SystemFaultState_AggregatedEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.SystemFaultState.AggregatedEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};

// -------------------------------------------------------------------

class SystemFaultState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SystemFaultState) */ {
 public:
  inline SystemFaultState() : SystemFaultState(nullptr) {}
  ~SystemFaultState() override;
  explicit PROTOBUF_CONSTEXPR SystemFaultState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemFaultState(const SystemFaultState& from);
  SystemFaultState(SystemFaultState&& from) noexcept
    : SystemFaultState() {
    *this = ::std::move(from);
  }

  inline SystemFaultState& operator=(const SystemFaultState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemFaultState& operator=(SystemFaultState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemFaultState& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemFaultState* internal_default_instance() {
    return reinterpret_cast<const SystemFaultState*>(
               &_SystemFaultState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SystemFaultState& a, SystemFaultState& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemFaultState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemFaultState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemFaultState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemFaultState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemFaultState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemFaultState& from) {
    SystemFaultState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemFaultState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SystemFaultState";
  }
  protected:
  explicit SystemFaultState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFaultsFieldNumber = 1,
    kHistoricalFaultsFieldNumber = 2,
    kAggregatedFieldNumber = 3,
  };
  // repeated .bosdyn.api.SystemFault faults = 1;
  int faults_size() const;
  private:
  int _internal_faults_size() const;
  public:
  void clear_faults();
  ::bosdyn::api::SystemFault* mutable_faults(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >*
      mutable_faults();
  private:
  const ::bosdyn::api::SystemFault& _internal_faults(int index) const;
  ::bosdyn::api::SystemFault* _internal_add_faults();
  public:
  const ::bosdyn::api::SystemFault& faults(int index) const;
  ::bosdyn::api::SystemFault* add_faults();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >&
      faults() const;

  // repeated .bosdyn.api.SystemFault historical_faults = 2;
  int historical_faults_size() const;
  private:
  int _internal_historical_faults_size() const;
  public:
  void clear_historical_faults();
  ::bosdyn::api::SystemFault* mutable_historical_faults(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >*
      mutable_historical_faults();
  private:
  const ::bosdyn::api::SystemFault& _internal_historical_faults(int index) const;
  ::bosdyn::api::SystemFault* _internal_add_historical_faults();
  public:
  const ::bosdyn::api::SystemFault& historical_faults(int index) const;
  ::bosdyn::api::SystemFault* add_historical_faults();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >&
      historical_faults() const;

  // map<string, .bosdyn.api.SystemFault.Severity> aggregated = 3;
  int aggregated_size() const;
  private:
  int _internal_aggregated_size() const;
  public:
  void clear_aggregated();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::SystemFault_Severity >&
      _internal_aggregated() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::SystemFault_Severity >*
      _internal_mutable_aggregated();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::SystemFault_Severity >&
      aggregated() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::SystemFault_Severity >*
      mutable_aggregated();

  // @@protoc_insertion_point(class_scope:bosdyn.api.SystemFaultState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault > faults_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault > historical_faults_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SystemFaultState_AggregatedEntry_DoNotUse,
        std::string, ::bosdyn::api::SystemFault_Severity,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> aggregated_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class SystemFault final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SystemFault) */ {
 public:
  inline SystemFault() : SystemFault(nullptr) {}
  ~SystemFault() override;
  explicit PROTOBUF_CONSTEXPR SystemFault(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemFault(const SystemFault& from);
  SystemFault(SystemFault&& from) noexcept
    : SystemFault() {
    *this = ::std::move(from);
  }

  inline SystemFault& operator=(const SystemFault& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemFault& operator=(SystemFault&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemFault& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemFault* internal_default_instance() {
    return reinterpret_cast<const SystemFault*>(
               &_SystemFault_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SystemFault& a, SystemFault& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemFault* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemFault* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemFault* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemFault>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemFault& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemFault& from) {
    SystemFault::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemFault* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SystemFault";
  }
  protected:
  explicit SystemFault(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SystemFault_Severity Severity;
  static constexpr Severity SEVERITY_UNKNOWN =
    SystemFault_Severity_SEVERITY_UNKNOWN;
  static constexpr Severity SEVERITY_INFO =
    SystemFault_Severity_SEVERITY_INFO;
  static constexpr Severity SEVERITY_WARN =
    SystemFault_Severity_SEVERITY_WARN;
  static constexpr Severity SEVERITY_CRITICAL =
    SystemFault_Severity_SEVERITY_CRITICAL;
  static inline bool Severity_IsValid(int value) {
    return SystemFault_Severity_IsValid(value);
  }
  static constexpr Severity Severity_MIN =
    SystemFault_Severity_Severity_MIN;
  static constexpr Severity Severity_MAX =
    SystemFault_Severity_Severity_MAX;
  static constexpr int Severity_ARRAYSIZE =
    SystemFault_Severity_Severity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Severity_descriptor() {
    return SystemFault_Severity_descriptor();
  }
  template<typename T>
  static inline const std::string& Severity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Severity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Severity_Name.");
    return SystemFault_Severity_Name(enum_t_value);
  }
  static inline bool Severity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Severity* value) {
    return SystemFault_Severity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 6,
    kNameFieldNumber = 1,
    kErrorMessageFieldNumber = 5,
    kOnsetTimestampFieldNumber = 2,
    kDurationFieldNumber = 3,
    kCodeFieldNumber = 4,
    kSeverityFieldNumber = 7,
    kUidFieldNumber = 8,
  };
  // repeated string attributes = 6;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  const std::string& attributes(int index) const;
  std::string* mutable_attributes(int index);
  void set_attributes(int index, const std::string& value);
  void set_attributes(int index, std::string&& value);
  void set_attributes(int index, const char* value);
  void set_attributes(int index, const char* value, size_t size);
  std::string* add_attributes();
  void add_attributes(const std::string& value);
  void add_attributes(std::string&& value);
  void add_attributes(const char* value);
  void add_attributes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& attributes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_attributes();
  private:
  const std::string& _internal_attributes(int index) const;
  std::string* _internal_add_attributes();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string error_message = 5;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .google.protobuf.Timestamp onset_timestamp = 2;
  bool has_onset_timestamp() const;
  private:
  bool _internal_has_onset_timestamp() const;
  public:
  void clear_onset_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& onset_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_onset_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_onset_timestamp();
  void set_allocated_onset_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_onset_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_onset_timestamp();
  public:
  void unsafe_arena_set_allocated_onset_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_onset_timestamp();

  // .google.protobuf.Duration duration = 3;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_duration();
  void set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_duration();

  // int32 code = 4;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // .bosdyn.api.SystemFault.Severity severity = 7;
  void clear_severity();
  ::bosdyn::api::SystemFault_Severity severity() const;
  void set_severity(::bosdyn::api::SystemFault_Severity value);
  private:
  ::bosdyn::api::SystemFault_Severity _internal_severity() const;
  void _internal_set_severity(::bosdyn::api::SystemFault_Severity value);
  public:

  // uint64 uid = 8;
  void clear_uid();
  uint64_t uid() const;
  void set_uid(uint64_t value);
  private:
  uint64_t _internal_uid() const;
  void _internal_set_uid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SystemFault)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp_;
    ::PROTOBUF_NAMESPACE_ID::Duration* duration_;
    int32_t code_;
    int severity_;
    uint64_t uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class EStopState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EStopState) */ {
 public:
  inline EStopState() : EStopState(nullptr) {}
  ~EStopState() override;
  explicit PROTOBUF_CONSTEXPR EStopState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EStopState(const EStopState& from);
  EStopState(EStopState&& from) noexcept
    : EStopState() {
    *this = ::std::move(from);
  }

  inline EStopState& operator=(const EStopState& from) {
    CopyFrom(from);
    return *this;
  }
  inline EStopState& operator=(EStopState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EStopState& default_instance() {
    return *internal_default_instance();
  }
  static inline const EStopState* internal_default_instance() {
    return reinterpret_cast<const EStopState*>(
               &_EStopState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EStopState& a, EStopState& b) {
    a.Swap(&b);
  }
  inline void Swap(EStopState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EStopState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EStopState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EStopState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EStopState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EStopState& from) {
    EStopState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EStopState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EStopState";
  }
  protected:
  explicit EStopState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EStopState_Type Type;
  static constexpr Type TYPE_UNKNOWN =
    EStopState_Type_TYPE_UNKNOWN;
  static constexpr Type TYPE_HARDWARE =
    EStopState_Type_TYPE_HARDWARE;
  static constexpr Type TYPE_SOFTWARE =
    EStopState_Type_TYPE_SOFTWARE;
  static inline bool Type_IsValid(int value) {
    return EStopState_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    EStopState_Type_Type_MIN;
  static constexpr Type Type_MAX =
    EStopState_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    EStopState_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return EStopState_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return EStopState_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return EStopState_Type_Parse(name, value);
  }

  typedef EStopState_State State;
  static constexpr State STATE_UNKNOWN =
    EStopState_State_STATE_UNKNOWN;
  static constexpr State STATE_ESTOPPED =
    EStopState_State_STATE_ESTOPPED;
  static constexpr State STATE_NOT_ESTOPPED =
    EStopState_State_STATE_NOT_ESTOPPED;
  static inline bool State_IsValid(int value) {
    return EStopState_State_IsValid(value);
  }
  static constexpr State State_MIN =
    EStopState_State_State_MIN;
  static constexpr State State_MAX =
    EStopState_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    EStopState_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return EStopState_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return EStopState_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return EStopState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kStateDescriptionFieldNumber = 5,
    kTimestampFieldNumber = 1,
    kTypeFieldNumber = 3,
    kStateFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string state_description = 5;
  void clear_state_description();
  const std::string& state_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state_description();
  PROTOBUF_NODISCARD std::string* release_state_description();
  void set_allocated_state_description(std::string* state_description);
  private:
  const std::string& _internal_state_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_description(const std::string& value);
  std::string* _internal_mutable_state_description();
  public:

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .bosdyn.api.EStopState.Type type = 3;
  void clear_type();
  ::bosdyn::api::EStopState_Type type() const;
  void set_type(::bosdyn::api::EStopState_Type value);
  private:
  ::bosdyn::api::EStopState_Type _internal_type() const;
  void _internal_set_type(::bosdyn::api::EStopState_Type value);
  public:

  // .bosdyn.api.EStopState.State state = 4;
  void clear_state();
  ::bosdyn::api::EStopState_State state() const;
  void set_state(::bosdyn::api::EStopState_State value);
  private:
  ::bosdyn::api::EStopState_State _internal_state() const;
  void _internal_set_state(::bosdyn::api::EStopState_State value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.EStopState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_description_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    int type_;
    int state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class BatteryState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.BatteryState) */ {
 public:
  inline BatteryState() : BatteryState(nullptr) {}
  ~BatteryState() override;
  explicit PROTOBUF_CONSTEXPR BatteryState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatteryState(const BatteryState& from);
  BatteryState(BatteryState&& from) noexcept
    : BatteryState() {
    *this = ::std::move(from);
  }

  inline BatteryState& operator=(const BatteryState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatteryState& operator=(BatteryState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatteryState& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatteryState* internal_default_instance() {
    return reinterpret_cast<const BatteryState*>(
               &_BatteryState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BatteryState& a, BatteryState& b) {
    a.Swap(&b);
  }
  inline void Swap(BatteryState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatteryState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatteryState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatteryState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatteryState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatteryState& from) {
    BatteryState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatteryState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.BatteryState";
  }
  protected:
  explicit BatteryState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BatteryState_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    BatteryState_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_MISSING =
    BatteryState_Status_STATUS_MISSING;
  static constexpr Status STATUS_CHARGING =
    BatteryState_Status_STATUS_CHARGING;
  static constexpr Status STATUS_DISCHARGING =
    BatteryState_Status_STATUS_DISCHARGING;
  static constexpr Status STATUS_BOOTING =
    BatteryState_Status_STATUS_BOOTING;
  static inline bool Status_IsValid(int value) {
    return BatteryState_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    BatteryState_Status_Status_MIN;
  static constexpr Status Status_MAX =
    BatteryState_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    BatteryState_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return BatteryState_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return BatteryState_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return BatteryState_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTemperaturesFieldNumber = 7,
    kIdentifierFieldNumber = 2,
    kTimestampFieldNumber = 1,
    kChargePercentageFieldNumber = 3,
    kEstimatedRuntimeFieldNumber = 4,
    kCurrentFieldNumber = 5,
    kVoltageFieldNumber = 6,
    kStatusFieldNumber = 8,
  };
  // repeated double temperatures = 7;
  int temperatures_size() const;
  private:
  int _internal_temperatures_size() const;
  public:
  void clear_temperatures();
  private:
  double _internal_temperatures(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_temperatures() const;
  void _internal_add_temperatures(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_temperatures();
  public:
  double temperatures(int index) const;
  void set_temperatures(int index, double value);
  void add_temperatures(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      temperatures() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_temperatures();

  // string identifier = 2;
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .google.protobuf.DoubleValue charge_percentage = 3;
  bool has_charge_percentage() const;
  private:
  bool _internal_has_charge_percentage() const;
  public:
  void clear_charge_percentage();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& charge_percentage() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_charge_percentage();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_charge_percentage();
  void set_allocated_charge_percentage(::PROTOBUF_NAMESPACE_ID::DoubleValue* charge_percentage);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_charge_percentage() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_charge_percentage();
  public:
  void unsafe_arena_set_allocated_charge_percentage(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* charge_percentage);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_charge_percentage();

  // .google.protobuf.Duration estimated_runtime = 4;
  bool has_estimated_runtime() const;
  private:
  bool _internal_has_estimated_runtime() const;
  public:
  void clear_estimated_runtime();
  const ::PROTOBUF_NAMESPACE_ID::Duration& estimated_runtime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_estimated_runtime();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_estimated_runtime();
  void set_allocated_estimated_runtime(::PROTOBUF_NAMESPACE_ID::Duration* estimated_runtime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_estimated_runtime() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_estimated_runtime();
  public:
  void unsafe_arena_set_allocated_estimated_runtime(
      ::PROTOBUF_NAMESPACE_ID::Duration* estimated_runtime);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_estimated_runtime();

  // .google.protobuf.DoubleValue current = 5;
  bool has_current() const;
  private:
  bool _internal_has_current() const;
  public:
  void clear_current();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& current() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_current();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_current();
  void set_allocated_current(::PROTOBUF_NAMESPACE_ID::DoubleValue* current);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_current() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_current();
  public:
  void unsafe_arena_set_allocated_current(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* current);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_current();

  // .google.protobuf.DoubleValue voltage = 6;
  bool has_voltage() const;
  private:
  bool _internal_has_voltage() const;
  public:
  void clear_voltage();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& voltage() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_voltage();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_voltage();
  void set_allocated_voltage(::PROTOBUF_NAMESPACE_ID::DoubleValue* voltage);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_voltage() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_voltage();
  public:
  void unsafe_arena_set_allocated_voltage(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* voltage);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_voltage();

  // .bosdyn.api.BatteryState.Status status = 8;
  void clear_status();
  ::bosdyn::api::BatteryState_Status status() const;
  void set_status(::bosdyn::api::BatteryState_Status value);
  private:
  ::bosdyn::api::BatteryState_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::BatteryState_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.BatteryState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > temperatures_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* charge_percentage_;
    ::PROTOBUF_NAMESPACE_ID::Duration* estimated_runtime_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* current_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* voltage_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class KinematicState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.KinematicState) */ {
 public:
  inline KinematicState() : KinematicState(nullptr) {}
  ~KinematicState() override;
  explicit PROTOBUF_CONSTEXPR KinematicState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KinematicState(const KinematicState& from);
  KinematicState(KinematicState&& from) noexcept
    : KinematicState() {
    *this = ::std::move(from);
  }

  inline KinematicState& operator=(const KinematicState& from) {
    CopyFrom(from);
    return *this;
  }
  inline KinematicState& operator=(KinematicState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KinematicState& default_instance() {
    return *internal_default_instance();
  }
  static inline const KinematicState* internal_default_instance() {
    return reinterpret_cast<const KinematicState*>(
               &_KinematicState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(KinematicState& a, KinematicState& b) {
    a.Swap(&b);
  }
  inline void Swap(KinematicState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KinematicState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KinematicState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KinematicState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KinematicState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KinematicState& from) {
    KinematicState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KinematicState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.KinematicState";
  }
  protected:
  explicit KinematicState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointStatesFieldNumber = 2,
    kVelocityOfBodyInVisionFieldNumber = 8,
    kVelocityOfBodyInOdomFieldNumber = 12,
    kAcquisitionTimestampFieldNumber = 30,
    kTransformsSnapshotFieldNumber = 31,
  };
  // repeated .bosdyn.api.JointState joint_states = 2;
  int joint_states_size() const;
  private:
  int _internal_joint_states_size() const;
  public:
  void clear_joint_states();
  ::bosdyn::api::JointState* mutable_joint_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointState >*
      mutable_joint_states();
  private:
  const ::bosdyn::api::JointState& _internal_joint_states(int index) const;
  ::bosdyn::api::JointState* _internal_add_joint_states();
  public:
  const ::bosdyn::api::JointState& joint_states(int index) const;
  ::bosdyn::api::JointState* add_joint_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointState >&
      joint_states() const;

  // .bosdyn.api.SE3Velocity velocity_of_body_in_vision = 8;
  bool has_velocity_of_body_in_vision() const;
  private:
  bool _internal_has_velocity_of_body_in_vision() const;
  public:
  void clear_velocity_of_body_in_vision();
  const ::bosdyn::api::SE3Velocity& velocity_of_body_in_vision() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Velocity* release_velocity_of_body_in_vision();
  ::bosdyn::api::SE3Velocity* mutable_velocity_of_body_in_vision();
  void set_allocated_velocity_of_body_in_vision(::bosdyn::api::SE3Velocity* velocity_of_body_in_vision);
  private:
  const ::bosdyn::api::SE3Velocity& _internal_velocity_of_body_in_vision() const;
  ::bosdyn::api::SE3Velocity* _internal_mutable_velocity_of_body_in_vision();
  public:
  void unsafe_arena_set_allocated_velocity_of_body_in_vision(
      ::bosdyn::api::SE3Velocity* velocity_of_body_in_vision);
  ::bosdyn::api::SE3Velocity* unsafe_arena_release_velocity_of_body_in_vision();

  // .bosdyn.api.SE3Velocity velocity_of_body_in_odom = 12;
  bool has_velocity_of_body_in_odom() const;
  private:
  bool _internal_has_velocity_of_body_in_odom() const;
  public:
  void clear_velocity_of_body_in_odom();
  const ::bosdyn::api::SE3Velocity& velocity_of_body_in_odom() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Velocity* release_velocity_of_body_in_odom();
  ::bosdyn::api::SE3Velocity* mutable_velocity_of_body_in_odom();
  void set_allocated_velocity_of_body_in_odom(::bosdyn::api::SE3Velocity* velocity_of_body_in_odom);
  private:
  const ::bosdyn::api::SE3Velocity& _internal_velocity_of_body_in_odom() const;
  ::bosdyn::api::SE3Velocity* _internal_mutable_velocity_of_body_in_odom();
  public:
  void unsafe_arena_set_allocated_velocity_of_body_in_odom(
      ::bosdyn::api::SE3Velocity* velocity_of_body_in_odom);
  ::bosdyn::api::SE3Velocity* unsafe_arena_release_velocity_of_body_in_odom();

  // .google.protobuf.Timestamp acquisition_timestamp = 30;
  bool has_acquisition_timestamp() const;
  private:
  bool _internal_has_acquisition_timestamp() const;
  public:
  void clear_acquisition_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& acquisition_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_acquisition_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_acquisition_timestamp();
  void set_allocated_acquisition_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_acquisition_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_acquisition_timestamp();
  public:
  void unsafe_arena_set_allocated_acquisition_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_acquisition_timestamp();

  // .bosdyn.api.FrameTreeSnapshot transforms_snapshot = 31;
  bool has_transforms_snapshot() const;
  private:
  bool _internal_has_transforms_snapshot() const;
  public:
  void clear_transforms_snapshot();
  const ::bosdyn::api::FrameTreeSnapshot& transforms_snapshot() const;
  PROTOBUF_NODISCARD ::bosdyn::api::FrameTreeSnapshot* release_transforms_snapshot();
  ::bosdyn::api::FrameTreeSnapshot* mutable_transforms_snapshot();
  void set_allocated_transforms_snapshot(::bosdyn::api::FrameTreeSnapshot* transforms_snapshot);
  private:
  const ::bosdyn::api::FrameTreeSnapshot& _internal_transforms_snapshot() const;
  ::bosdyn::api::FrameTreeSnapshot* _internal_mutable_transforms_snapshot();
  public:
  void unsafe_arena_set_allocated_transforms_snapshot(
      ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot);
  ::bosdyn::api::FrameTreeSnapshot* unsafe_arena_release_transforms_snapshot();

  // @@protoc_insertion_point(class_scope:bosdyn.api.KinematicState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointState > joint_states_;
    ::bosdyn::api::SE3Velocity* velocity_of_body_in_vision_;
    ::bosdyn::api::SE3Velocity* velocity_of_body_in_odom_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_timestamp_;
    ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class JointState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.JointState) */ {
 public:
  inline JointState() : JointState(nullptr) {}
  ~JointState() override;
  explicit PROTOBUF_CONSTEXPR JointState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JointState(const JointState& from);
  JointState(JointState&& from) noexcept
    : JointState() {
    *this = ::std::move(from);
  }

  inline JointState& operator=(const JointState& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointState& operator=(JointState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JointState& default_instance() {
    return *internal_default_instance();
  }
  static inline const JointState* internal_default_instance() {
    return reinterpret_cast<const JointState*>(
               &_JointState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(JointState& a, JointState& b) {
    a.Swap(&b);
  }
  inline void Swap(JointState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JointState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JointState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JointState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JointState& from) {
    JointState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.JointState";
  }
  protected:
  explicit JointState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPositionFieldNumber = 2,
    kVelocityFieldNumber = 3,
    kAccelerationFieldNumber = 4,
    kLoadFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.DoubleValue position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& position() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_position();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_position();
  void set_allocated_position(::PROTOBUF_NAMESPACE_ID::DoubleValue* position);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_position() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* position);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_position();

  // .google.protobuf.DoubleValue velocity = 3;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& velocity() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_velocity();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_velocity();
  void set_allocated_velocity(::PROTOBUF_NAMESPACE_ID::DoubleValue* velocity);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_velocity() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* velocity);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_velocity();

  // .google.protobuf.DoubleValue acceleration = 4;
  bool has_acceleration() const;
  private:
  bool _internal_has_acceleration() const;
  public:
  void clear_acceleration();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& acceleration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_acceleration();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_acceleration();
  void set_allocated_acceleration(::PROTOBUF_NAMESPACE_ID::DoubleValue* acceleration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_acceleration() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_acceleration();
  public:
  void unsafe_arena_set_allocated_acceleration(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* acceleration);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_acceleration();

  // .google.protobuf.DoubleValue load = 5;
  bool has_load() const;
  private:
  bool _internal_has_load() const;
  public:
  void clear_load();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& load() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_load();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_load();
  void set_allocated_load(::PROTOBUF_NAMESPACE_ID::DoubleValue* load);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_load() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_load();
  public:
  void unsafe_arena_set_allocated_load(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* load);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_load();

  // @@protoc_insertion_point(class_scope:bosdyn.api.JointState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* position_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* velocity_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* acceleration_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* load_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class BehaviorFaultState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.BehaviorFaultState) */ {
 public:
  inline BehaviorFaultState() : BehaviorFaultState(nullptr) {}
  ~BehaviorFaultState() override;
  explicit PROTOBUF_CONSTEXPR BehaviorFaultState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BehaviorFaultState(const BehaviorFaultState& from);
  BehaviorFaultState(BehaviorFaultState&& from) noexcept
    : BehaviorFaultState() {
    *this = ::std::move(from);
  }

  inline BehaviorFaultState& operator=(const BehaviorFaultState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BehaviorFaultState& operator=(BehaviorFaultState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BehaviorFaultState& default_instance() {
    return *internal_default_instance();
  }
  static inline const BehaviorFaultState* internal_default_instance() {
    return reinterpret_cast<const BehaviorFaultState*>(
               &_BehaviorFaultState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BehaviorFaultState& a, BehaviorFaultState& b) {
    a.Swap(&b);
  }
  inline void Swap(BehaviorFaultState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BehaviorFaultState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BehaviorFaultState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BehaviorFaultState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BehaviorFaultState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BehaviorFaultState& from) {
    BehaviorFaultState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BehaviorFaultState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.BehaviorFaultState";
  }
  protected:
  explicit BehaviorFaultState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFaultsFieldNumber = 1,
  };
  // repeated .bosdyn.api.BehaviorFault faults = 1;
  int faults_size() const;
  private:
  int _internal_faults_size() const;
  public:
  void clear_faults();
  ::bosdyn::api::BehaviorFault* mutable_faults(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BehaviorFault >*
      mutable_faults();
  private:
  const ::bosdyn::api::BehaviorFault& _internal_faults(int index) const;
  ::bosdyn::api::BehaviorFault* _internal_add_faults();
  public:
  const ::bosdyn::api::BehaviorFault& faults(int index) const;
  ::bosdyn::api::BehaviorFault* add_faults();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BehaviorFault >&
      faults() const;

  // @@protoc_insertion_point(class_scope:bosdyn.api.BehaviorFaultState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BehaviorFault > faults_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class BehaviorFault final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.BehaviorFault) */ {
 public:
  inline BehaviorFault() : BehaviorFault(nullptr) {}
  ~BehaviorFault() override;
  explicit PROTOBUF_CONSTEXPR BehaviorFault(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BehaviorFault(const BehaviorFault& from);
  BehaviorFault(BehaviorFault&& from) noexcept
    : BehaviorFault() {
    *this = ::std::move(from);
  }

  inline BehaviorFault& operator=(const BehaviorFault& from) {
    CopyFrom(from);
    return *this;
  }
  inline BehaviorFault& operator=(BehaviorFault&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BehaviorFault& default_instance() {
    return *internal_default_instance();
  }
  static inline const BehaviorFault* internal_default_instance() {
    return reinterpret_cast<const BehaviorFault*>(
               &_BehaviorFault_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BehaviorFault& a, BehaviorFault& b) {
    a.Swap(&b);
  }
  inline void Swap(BehaviorFault* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BehaviorFault* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BehaviorFault* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BehaviorFault>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BehaviorFault& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BehaviorFault& from) {
    BehaviorFault::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BehaviorFault* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.BehaviorFault";
  }
  protected:
  explicit BehaviorFault(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BehaviorFault_Cause Cause;
  static constexpr Cause CAUSE_UNKNOWN =
    BehaviorFault_Cause_CAUSE_UNKNOWN;
  static constexpr Cause CAUSE_FALL =
    BehaviorFault_Cause_CAUSE_FALL;
  static constexpr Cause CAUSE_HARDWARE =
    BehaviorFault_Cause_CAUSE_HARDWARE;
  static constexpr Cause CAUSE_LEASE_TIMEOUT =
    BehaviorFault_Cause_CAUSE_LEASE_TIMEOUT;
  static inline bool Cause_IsValid(int value) {
    return BehaviorFault_Cause_IsValid(value);
  }
  static constexpr Cause Cause_MIN =
    BehaviorFault_Cause_Cause_MIN;
  static constexpr Cause Cause_MAX =
    BehaviorFault_Cause_Cause_MAX;
  static constexpr int Cause_ARRAYSIZE =
    BehaviorFault_Cause_Cause_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Cause_descriptor() {
    return BehaviorFault_Cause_descriptor();
  }
  template<typename T>
  static inline const std::string& Cause_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Cause>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Cause_Name.");
    return BehaviorFault_Cause_Name(enum_t_value);
  }
  static inline bool Cause_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Cause* value) {
    return BehaviorFault_Cause_Parse(name, value);
  }

  typedef BehaviorFault_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    BehaviorFault_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_CLEARABLE =
    BehaviorFault_Status_STATUS_CLEARABLE;
  static constexpr Status STATUS_UNCLEARABLE =
    BehaviorFault_Status_STATUS_UNCLEARABLE;
  static inline bool Status_IsValid(int value) {
    return BehaviorFault_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    BehaviorFault_Status_Status_MIN;
  static constexpr Status Status_MAX =
    BehaviorFault_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    BehaviorFault_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return BehaviorFault_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return BehaviorFault_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return BehaviorFault_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOnsetTimestampFieldNumber = 2,
    kBehaviorFaultIdFieldNumber = 1,
    kCauseFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // .google.protobuf.Timestamp onset_timestamp = 2;
  bool has_onset_timestamp() const;
  private:
  bool _internal_has_onset_timestamp() const;
  public:
  void clear_onset_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& onset_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_onset_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_onset_timestamp();
  void set_allocated_onset_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_onset_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_onset_timestamp();
  public:
  void unsafe_arena_set_allocated_onset_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_onset_timestamp();

  // uint32 behavior_fault_id = 1;
  void clear_behavior_fault_id();
  uint32_t behavior_fault_id() const;
  void set_behavior_fault_id(uint32_t value);
  private:
  uint32_t _internal_behavior_fault_id() const;
  void _internal_set_behavior_fault_id(uint32_t value);
  public:

  // .bosdyn.api.BehaviorFault.Cause cause = 3;
  void clear_cause();
  ::bosdyn::api::BehaviorFault_Cause cause() const;
  void set_cause(::bosdyn::api::BehaviorFault_Cause value);
  private:
  ::bosdyn::api::BehaviorFault_Cause _internal_cause() const;
  void _internal_set_cause(::bosdyn::api::BehaviorFault_Cause value);
  public:

  // .bosdyn.api.BehaviorFault.Status status = 4;
  void clear_status();
  ::bosdyn::api::BehaviorFault_Status status() const;
  void set_status(::bosdyn::api::BehaviorFault_Status value);
  private:
  ::bosdyn::api::BehaviorFault_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::BehaviorFault_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.BehaviorFault)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp_;
    uint32_t behavior_fault_id_;
    int cause_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotMetrics) */ {
 public:
  inline RobotMetrics() : RobotMetrics(nullptr) {}
  ~RobotMetrics() override;
  explicit PROTOBUF_CONSTEXPR RobotMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotMetrics(const RobotMetrics& from);
  RobotMetrics(RobotMetrics&& from) noexcept
    : RobotMetrics() {
    *this = ::std::move(from);
  }

  inline RobotMetrics& operator=(const RobotMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotMetrics& operator=(RobotMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotMetrics* internal_default_instance() {
    return reinterpret_cast<const RobotMetrics*>(
               &_RobotMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RobotMetrics& a, RobotMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotMetrics& from) {
    RobotMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotMetrics";
  }
  protected:
  explicit RobotMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricsFieldNumber = 2,
    kTimestampFieldNumber = 1,
  };
  // repeated .bosdyn.api.Parameter metrics = 2;
  int metrics_size() const;
  private:
  int _internal_metrics_size() const;
  public:
  void clear_metrics();
  ::bosdyn::api::Parameter* mutable_metrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Parameter >*
      mutable_metrics();
  private:
  const ::bosdyn::api::Parameter& _internal_metrics(int index) const;
  ::bosdyn::api::Parameter* _internal_add_metrics();
  public:
  const ::bosdyn::api::Parameter& metrics(int index) const;
  ::bosdyn::api::Parameter* add_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Parameter >&
      metrics() const;

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Parameter > metrics_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class CommsState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.CommsState) */ {
 public:
  inline CommsState() : CommsState(nullptr) {}
  ~CommsState() override;
  explicit PROTOBUF_CONSTEXPR CommsState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommsState(const CommsState& from);
  CommsState(CommsState&& from) noexcept
    : CommsState() {
    *this = ::std::move(from);
  }

  inline CommsState& operator=(const CommsState& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommsState& operator=(CommsState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommsState& default_instance() {
    return *internal_default_instance();
  }
  enum StateCase {
    kWifiState = 2,
    STATE_NOT_SET = 0,
  };

  static inline const CommsState* internal_default_instance() {
    return reinterpret_cast<const CommsState*>(
               &_CommsState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CommsState& a, CommsState& b) {
    a.Swap(&b);
  }
  inline void Swap(CommsState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommsState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommsState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommsState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommsState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommsState& from) {
    CommsState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommsState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.CommsState";
  }
  protected:
  explicit CommsState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kWifiStateFieldNumber = 2,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .bosdyn.api.WiFiState wifi_state = 2;
  bool has_wifi_state() const;
  private:
  bool _internal_has_wifi_state() const;
  public:
  void clear_wifi_state();
  const ::bosdyn::api::WiFiState& wifi_state() const;
  PROTOBUF_NODISCARD ::bosdyn::api::WiFiState* release_wifi_state();
  ::bosdyn::api::WiFiState* mutable_wifi_state();
  void set_allocated_wifi_state(::bosdyn::api::WiFiState* wifi_state);
  private:
  const ::bosdyn::api::WiFiState& _internal_wifi_state() const;
  ::bosdyn::api::WiFiState* _internal_mutable_wifi_state();
  public:
  void unsafe_arena_set_allocated_wifi_state(
      ::bosdyn::api::WiFiState* wifi_state);
  ::bosdyn::api::WiFiState* unsafe_arena_release_wifi_state();

  void clear_state();
  StateCase state_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.CommsState)
 private:
  class _Internal;
  void set_has_wifi_state();

  inline bool has_state() const;
  inline void clear_has_state();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    union StateUnion {
      constexpr StateUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::WiFiState* wifi_state_;
    } state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class WiFiState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.WiFiState) */ {
 public:
  inline WiFiState() : WiFiState(nullptr) {}
  ~WiFiState() override;
  explicit PROTOBUF_CONSTEXPR WiFiState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WiFiState(const WiFiState& from);
  WiFiState(WiFiState&& from) noexcept
    : WiFiState() {
    *this = ::std::move(from);
  }

  inline WiFiState& operator=(const WiFiState& from) {
    CopyFrom(from);
    return *this;
  }
  inline WiFiState& operator=(WiFiState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WiFiState& default_instance() {
    return *internal_default_instance();
  }
  static inline const WiFiState* internal_default_instance() {
    return reinterpret_cast<const WiFiState*>(
               &_WiFiState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WiFiState& a, WiFiState& b) {
    a.Swap(&b);
  }
  inline void Swap(WiFiState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WiFiState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WiFiState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WiFiState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WiFiState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WiFiState& from) {
    WiFiState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WiFiState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.WiFiState";
  }
  protected:
  explicit WiFiState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WiFiState_Mode Mode;
  static constexpr Mode MODE_UNKNOWN =
    WiFiState_Mode_MODE_UNKNOWN;
  static constexpr Mode MODE_ACCESS_POINT =
    WiFiState_Mode_MODE_ACCESS_POINT;
  static constexpr Mode MODE_CLIENT =
    WiFiState_Mode_MODE_CLIENT;
  static inline bool Mode_IsValid(int value) {
    return WiFiState_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN =
    WiFiState_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX =
    WiFiState_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE =
    WiFiState_Mode_Mode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Mode_descriptor() {
    return WiFiState_Mode_descriptor();
  }
  template<typename T>
  static inline const std::string& Mode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Mode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Mode_Name.");
    return WiFiState_Mode_Name(enum_t_value);
  }
  static inline bool Mode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Mode* value) {
    return WiFiState_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEssidFieldNumber = 2,
    kCurrentModeFieldNumber = 1,
  };
  // string essid = 2;
  void clear_essid();
  const std::string& essid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_essid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_essid();
  PROTOBUF_NODISCARD std::string* release_essid();
  void set_allocated_essid(std::string* essid);
  private:
  const std::string& _internal_essid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_essid(const std::string& value);
  std::string* _internal_mutable_essid();
  public:

  // .bosdyn.api.WiFiState.Mode current_mode = 1;
  void clear_current_mode();
  ::bosdyn::api::WiFiState_Mode current_mode() const;
  void set_current_mode(::bosdyn::api::WiFiState_Mode value);
  private:
  ::bosdyn::api::WiFiState_Mode _internal_current_mode() const;
  void _internal_set_current_mode(::bosdyn::api::WiFiState_Mode value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.WiFiState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr essid_;
    int current_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class FootState_TerrainState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.FootState.TerrainState) */ {
 public:
  inline FootState_TerrainState() : FootState_TerrainState(nullptr) {}
  ~FootState_TerrainState() override;
  explicit PROTOBUF_CONSTEXPR FootState_TerrainState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FootState_TerrainState(const FootState_TerrainState& from);
  FootState_TerrainState(FootState_TerrainState&& from) noexcept
    : FootState_TerrainState() {
    *this = ::std::move(from);
  }

  inline FootState_TerrainState& operator=(const FootState_TerrainState& from) {
    CopyFrom(from);
    return *this;
  }
  inline FootState_TerrainState& operator=(FootState_TerrainState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FootState_TerrainState& default_instance() {
    return *internal_default_instance();
  }
  static inline const FootState_TerrainState* internal_default_instance() {
    return reinterpret_cast<const FootState_TerrainState*>(
               &_FootState_TerrainState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(FootState_TerrainState& a, FootState_TerrainState& b) {
    a.Swap(&b);
  }
  inline void Swap(FootState_TerrainState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FootState_TerrainState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FootState_TerrainState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FootState_TerrainState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FootState_TerrainState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FootState_TerrainState& from) {
    FootState_TerrainState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FootState_TerrainState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FootState.TerrainState";
  }
  protected:
  explicit FootState_TerrainState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFieldNumber = 2,
    kFootSlipDistanceRtFrameFieldNumber = 3,
    kFootSlipVelocityRtFrameFieldNumber = 4,
    kGroundContactNormalRtFrameFieldNumber = 5,
    kGroundMuEstFieldNumber = 1,
    kVisualSurfaceGroundPenetrationMeanFieldNumber = 6,
    kVisualSurfaceGroundPenetrationStdFieldNumber = 7,
  };
  // string frame_name = 2;
  void clear_frame_name();
  const std::string& frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name();
  PROTOBUF_NODISCARD std::string* release_frame_name();
  void set_allocated_frame_name(std::string* frame_name);
  private:
  const std::string& _internal_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name(const std::string& value);
  std::string* _internal_mutable_frame_name();
  public:

  // .bosdyn.api.Vec3 foot_slip_distance_rt_frame = 3;
  bool has_foot_slip_distance_rt_frame() const;
  private:
  bool _internal_has_foot_slip_distance_rt_frame() const;
  public:
  void clear_foot_slip_distance_rt_frame();
  const ::bosdyn::api::Vec3& foot_slip_distance_rt_frame() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_foot_slip_distance_rt_frame();
  ::bosdyn::api::Vec3* mutable_foot_slip_distance_rt_frame();
  void set_allocated_foot_slip_distance_rt_frame(::bosdyn::api::Vec3* foot_slip_distance_rt_frame);
  private:
  const ::bosdyn::api::Vec3& _internal_foot_slip_distance_rt_frame() const;
  ::bosdyn::api::Vec3* _internal_mutable_foot_slip_distance_rt_frame();
  public:
  void unsafe_arena_set_allocated_foot_slip_distance_rt_frame(
      ::bosdyn::api::Vec3* foot_slip_distance_rt_frame);
  ::bosdyn::api::Vec3* unsafe_arena_release_foot_slip_distance_rt_frame();

  // .bosdyn.api.Vec3 foot_slip_velocity_rt_frame = 4;
  bool has_foot_slip_velocity_rt_frame() const;
  private:
  bool _internal_has_foot_slip_velocity_rt_frame() const;
  public:
  void clear_foot_slip_velocity_rt_frame();
  const ::bosdyn::api::Vec3& foot_slip_velocity_rt_frame() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_foot_slip_velocity_rt_frame();
  ::bosdyn::api::Vec3* mutable_foot_slip_velocity_rt_frame();
  void set_allocated_foot_slip_velocity_rt_frame(::bosdyn::api::Vec3* foot_slip_velocity_rt_frame);
  private:
  const ::bosdyn::api::Vec3& _internal_foot_slip_velocity_rt_frame() const;
  ::bosdyn::api::Vec3* _internal_mutable_foot_slip_velocity_rt_frame();
  public:
  void unsafe_arena_set_allocated_foot_slip_velocity_rt_frame(
      ::bosdyn::api::Vec3* foot_slip_velocity_rt_frame);
  ::bosdyn::api::Vec3* unsafe_arena_release_foot_slip_velocity_rt_frame();

  // .bosdyn.api.Vec3 ground_contact_normal_rt_frame = 5;
  bool has_ground_contact_normal_rt_frame() const;
  private:
  bool _internal_has_ground_contact_normal_rt_frame() const;
  public:
  void clear_ground_contact_normal_rt_frame();
  const ::bosdyn::api::Vec3& ground_contact_normal_rt_frame() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_ground_contact_normal_rt_frame();
  ::bosdyn::api::Vec3* mutable_ground_contact_normal_rt_frame();
  void set_allocated_ground_contact_normal_rt_frame(::bosdyn::api::Vec3* ground_contact_normal_rt_frame);
  private:
  const ::bosdyn::api::Vec3& _internal_ground_contact_normal_rt_frame() const;
  ::bosdyn::api::Vec3* _internal_mutable_ground_contact_normal_rt_frame();
  public:
  void unsafe_arena_set_allocated_ground_contact_normal_rt_frame(
      ::bosdyn::api::Vec3* ground_contact_normal_rt_frame);
  ::bosdyn::api::Vec3* unsafe_arena_release_ground_contact_normal_rt_frame();

  // double ground_mu_est = 1;
  void clear_ground_mu_est();
  double ground_mu_est() const;
  void set_ground_mu_est(double value);
  private:
  double _internal_ground_mu_est() const;
  void _internal_set_ground_mu_est(double value);
  public:

  // double visual_surface_ground_penetration_mean = 6;
  void clear_visual_surface_ground_penetration_mean();
  double visual_surface_ground_penetration_mean() const;
  void set_visual_surface_ground_penetration_mean(double value);
  private:
  double _internal_visual_surface_ground_penetration_mean() const;
  void _internal_set_visual_surface_ground_penetration_mean(double value);
  public:

  // double visual_surface_ground_penetration_std = 7;
  void clear_visual_surface_ground_penetration_std();
  double visual_surface_ground_penetration_std() const;
  void set_visual_surface_ground_penetration_std(double value);
  private:
  double _internal_visual_surface_ground_penetration_std() const;
  void _internal_set_visual_surface_ground_penetration_std(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.FootState.TerrainState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_;
    ::bosdyn::api::Vec3* foot_slip_distance_rt_frame_;
    ::bosdyn::api::Vec3* foot_slip_velocity_rt_frame_;
    ::bosdyn::api::Vec3* ground_contact_normal_rt_frame_;
    double ground_mu_est_;
    double visual_surface_ground_penetration_mean_;
    double visual_surface_ground_penetration_std_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class FootState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.FootState) */ {
 public:
  inline FootState() : FootState(nullptr) {}
  ~FootState() override;
  explicit PROTOBUF_CONSTEXPR FootState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FootState(const FootState& from);
  FootState(FootState&& from) noexcept
    : FootState() {
    *this = ::std::move(from);
  }

  inline FootState& operator=(const FootState& from) {
    CopyFrom(from);
    return *this;
  }
  inline FootState& operator=(FootState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FootState& default_instance() {
    return *internal_default_instance();
  }
  static inline const FootState* internal_default_instance() {
    return reinterpret_cast<const FootState*>(
               &_FootState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(FootState& a, FootState& b) {
    a.Swap(&b);
  }
  inline void Swap(FootState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FootState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FootState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FootState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FootState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FootState& from) {
    FootState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FootState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FootState";
  }
  protected:
  explicit FootState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FootState_TerrainState TerrainState;

  typedef FootState_Contact Contact;
  static constexpr Contact CONTACT_UNKNOWN =
    FootState_Contact_CONTACT_UNKNOWN;
  static constexpr Contact CONTACT_MADE =
    FootState_Contact_CONTACT_MADE;
  static constexpr Contact CONTACT_LOST =
    FootState_Contact_CONTACT_LOST;
  static inline bool Contact_IsValid(int value) {
    return FootState_Contact_IsValid(value);
  }
  static constexpr Contact Contact_MIN =
    FootState_Contact_Contact_MIN;
  static constexpr Contact Contact_MAX =
    FootState_Contact_Contact_MAX;
  static constexpr int Contact_ARRAYSIZE =
    FootState_Contact_Contact_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Contact_descriptor() {
    return FootState_Contact_descriptor();
  }
  template<typename T>
  static inline const std::string& Contact_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Contact>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Contact_Name.");
    return FootState_Contact_Name(enum_t_value);
  }
  static inline bool Contact_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Contact* value) {
    return FootState_Contact_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFootPositionRtBodyFieldNumber = 1,
    kTerrainFieldNumber = 3,
    kContactFieldNumber = 2,
  };
  // .bosdyn.api.Vec3 foot_position_rt_body = 1;
  bool has_foot_position_rt_body() const;
  private:
  bool _internal_has_foot_position_rt_body() const;
  public:
  void clear_foot_position_rt_body();
  const ::bosdyn::api::Vec3& foot_position_rt_body() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_foot_position_rt_body();
  ::bosdyn::api::Vec3* mutable_foot_position_rt_body();
  void set_allocated_foot_position_rt_body(::bosdyn::api::Vec3* foot_position_rt_body);
  private:
  const ::bosdyn::api::Vec3& _internal_foot_position_rt_body() const;
  ::bosdyn::api::Vec3* _internal_mutable_foot_position_rt_body();
  public:
  void unsafe_arena_set_allocated_foot_position_rt_body(
      ::bosdyn::api::Vec3* foot_position_rt_body);
  ::bosdyn::api::Vec3* unsafe_arena_release_foot_position_rt_body();

  // .bosdyn.api.FootState.TerrainState terrain = 3;
  bool has_terrain() const;
  private:
  bool _internal_has_terrain() const;
  public:
  void clear_terrain();
  const ::bosdyn::api::FootState_TerrainState& terrain() const;
  PROTOBUF_NODISCARD ::bosdyn::api::FootState_TerrainState* release_terrain();
  ::bosdyn::api::FootState_TerrainState* mutable_terrain();
  void set_allocated_terrain(::bosdyn::api::FootState_TerrainState* terrain);
  private:
  const ::bosdyn::api::FootState_TerrainState& _internal_terrain() const;
  ::bosdyn::api::FootState_TerrainState* _internal_mutable_terrain();
  public:
  void unsafe_arena_set_allocated_terrain(
      ::bosdyn::api::FootState_TerrainState* terrain);
  ::bosdyn::api::FootState_TerrainState* unsafe_arena_release_terrain();

  // .bosdyn.api.FootState.Contact contact = 2;
  void clear_contact();
  ::bosdyn::api::FootState_Contact contact() const;
  void set_contact(::bosdyn::api::FootState_Contact value);
  private:
  ::bosdyn::api::FootState_Contact _internal_contact() const;
  void _internal_set_contact(::bosdyn::api::FootState_Contact value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.FootState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec3* foot_position_rt_body_;
    ::bosdyn::api::FootState_TerrainState* terrain_;
    int contact_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class ManipulatorState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ManipulatorState) */ {
 public:
  inline ManipulatorState() : ManipulatorState(nullptr) {}
  ~ManipulatorState() override;
  explicit PROTOBUF_CONSTEXPR ManipulatorState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ManipulatorState(const ManipulatorState& from);
  ManipulatorState(ManipulatorState&& from) noexcept
    : ManipulatorState() {
    *this = ::std::move(from);
  }

  inline ManipulatorState& operator=(const ManipulatorState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManipulatorState& operator=(ManipulatorState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ManipulatorState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManipulatorState* internal_default_instance() {
    return reinterpret_cast<const ManipulatorState*>(
               &_ManipulatorState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ManipulatorState& a, ManipulatorState& b) {
    a.Swap(&b);
  }
  inline void Swap(ManipulatorState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManipulatorState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ManipulatorState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ManipulatorState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ManipulatorState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ManipulatorState& from) {
    ManipulatorState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManipulatorState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ManipulatorState";
  }
  protected:
  explicit ManipulatorState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ManipulatorState_StowState StowState;
  static constexpr StowState STOWSTATE_UNKNOWN =
    ManipulatorState_StowState_STOWSTATE_UNKNOWN;
  static constexpr StowState STOWSTATE_STOWED =
    ManipulatorState_StowState_STOWSTATE_STOWED;
  static constexpr StowState STOWSTATE_DEPLOYED =
    ManipulatorState_StowState_STOWSTATE_DEPLOYED;
  static inline bool StowState_IsValid(int value) {
    return ManipulatorState_StowState_IsValid(value);
  }
  static constexpr StowState StowState_MIN =
    ManipulatorState_StowState_StowState_MIN;
  static constexpr StowState StowState_MAX =
    ManipulatorState_StowState_StowState_MAX;
  static constexpr int StowState_ARRAYSIZE =
    ManipulatorState_StowState_StowState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StowState_descriptor() {
    return ManipulatorState_StowState_descriptor();
  }
  template<typename T>
  static inline const std::string& StowState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StowState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StowState_Name.");
    return ManipulatorState_StowState_Name(enum_t_value);
  }
  static inline bool StowState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StowState* value) {
    return ManipulatorState_StowState_Parse(name, value);
  }

  typedef ManipulatorState_CarryState CarryState;
  static constexpr CarryState CARRY_STATE_UNKNOWN =
    ManipulatorState_CarryState_CARRY_STATE_UNKNOWN;
  static constexpr CarryState CARRY_STATE_NOT_CARRIABLE =
    ManipulatorState_CarryState_CARRY_STATE_NOT_CARRIABLE;
  static constexpr CarryState CARRY_STATE_CARRIABLE =
    ManipulatorState_CarryState_CARRY_STATE_CARRIABLE;
  static constexpr CarryState CARRY_STATE_CARRIABLE_AND_STOWABLE =
    ManipulatorState_CarryState_CARRY_STATE_CARRIABLE_AND_STOWABLE;
  static inline bool CarryState_IsValid(int value) {
    return ManipulatorState_CarryState_IsValid(value);
  }
  static constexpr CarryState CarryState_MIN =
    ManipulatorState_CarryState_CarryState_MIN;
  static constexpr CarryState CarryState_MAX =
    ManipulatorState_CarryState_CarryState_MAX;
  static constexpr int CarryState_ARRAYSIZE =
    ManipulatorState_CarryState_CarryState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CarryState_descriptor() {
    return ManipulatorState_CarryState_descriptor();
  }
  template<typename T>
  static inline const std::string& CarryState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CarryState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CarryState_Name.");
    return ManipulatorState_CarryState_Name(enum_t_value);
  }
  static inline bool CarryState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CarryState* value) {
    return ManipulatorState_CarryState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEstimatedEndEffectorForceInHandFieldNumber = 13,
    kVelocityOfHandInVisionFieldNumber = 14,
    kVelocityOfHandInOdomFieldNumber = 15,
    kIsGripperHoldingItemFieldNumber = 6,
    kStowStateFieldNumber = 9,
    kGripperOpenPercentageFieldNumber = 12,
    kCarryStateFieldNumber = 16,
  };
  // .bosdyn.api.Vec3 estimated_end_effector_force_in_hand = 13;
  bool has_estimated_end_effector_force_in_hand() const;
  private:
  bool _internal_has_estimated_end_effector_force_in_hand() const;
  public:
  void clear_estimated_end_effector_force_in_hand();
  const ::bosdyn::api::Vec3& estimated_end_effector_force_in_hand() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3* release_estimated_end_effector_force_in_hand();
  ::bosdyn::api::Vec3* mutable_estimated_end_effector_force_in_hand();
  void set_allocated_estimated_end_effector_force_in_hand(::bosdyn::api::Vec3* estimated_end_effector_force_in_hand);
  private:
  const ::bosdyn::api::Vec3& _internal_estimated_end_effector_force_in_hand() const;
  ::bosdyn::api::Vec3* _internal_mutable_estimated_end_effector_force_in_hand();
  public:
  void unsafe_arena_set_allocated_estimated_end_effector_force_in_hand(
      ::bosdyn::api::Vec3* estimated_end_effector_force_in_hand);
  ::bosdyn::api::Vec3* unsafe_arena_release_estimated_end_effector_force_in_hand();

  // .bosdyn.api.SE3Velocity velocity_of_hand_in_vision = 14;
  bool has_velocity_of_hand_in_vision() const;
  private:
  bool _internal_has_velocity_of_hand_in_vision() const;
  public:
  void clear_velocity_of_hand_in_vision();
  const ::bosdyn::api::SE3Velocity& velocity_of_hand_in_vision() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Velocity* release_velocity_of_hand_in_vision();
  ::bosdyn::api::SE3Velocity* mutable_velocity_of_hand_in_vision();
  void set_allocated_velocity_of_hand_in_vision(::bosdyn::api::SE3Velocity* velocity_of_hand_in_vision);
  private:
  const ::bosdyn::api::SE3Velocity& _internal_velocity_of_hand_in_vision() const;
  ::bosdyn::api::SE3Velocity* _internal_mutable_velocity_of_hand_in_vision();
  public:
  void unsafe_arena_set_allocated_velocity_of_hand_in_vision(
      ::bosdyn::api::SE3Velocity* velocity_of_hand_in_vision);
  ::bosdyn::api::SE3Velocity* unsafe_arena_release_velocity_of_hand_in_vision();

  // .bosdyn.api.SE3Velocity velocity_of_hand_in_odom = 15;
  bool has_velocity_of_hand_in_odom() const;
  private:
  bool _internal_has_velocity_of_hand_in_odom() const;
  public:
  void clear_velocity_of_hand_in_odom();
  const ::bosdyn::api::SE3Velocity& velocity_of_hand_in_odom() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Velocity* release_velocity_of_hand_in_odom();
  ::bosdyn::api::SE3Velocity* mutable_velocity_of_hand_in_odom();
  void set_allocated_velocity_of_hand_in_odom(::bosdyn::api::SE3Velocity* velocity_of_hand_in_odom);
  private:
  const ::bosdyn::api::SE3Velocity& _internal_velocity_of_hand_in_odom() const;
  ::bosdyn::api::SE3Velocity* _internal_mutable_velocity_of_hand_in_odom();
  public:
  void unsafe_arena_set_allocated_velocity_of_hand_in_odom(
      ::bosdyn::api::SE3Velocity* velocity_of_hand_in_odom);
  ::bosdyn::api::SE3Velocity* unsafe_arena_release_velocity_of_hand_in_odom();

  // bool is_gripper_holding_item = 6;
  void clear_is_gripper_holding_item();
  bool is_gripper_holding_item() const;
  void set_is_gripper_holding_item(bool value);
  private:
  bool _internal_is_gripper_holding_item() const;
  void _internal_set_is_gripper_holding_item(bool value);
  public:

  // .bosdyn.api.ManipulatorState.StowState stow_state = 9;
  void clear_stow_state();
  ::bosdyn::api::ManipulatorState_StowState stow_state() const;
  void set_stow_state(::bosdyn::api::ManipulatorState_StowState value);
  private:
  ::bosdyn::api::ManipulatorState_StowState _internal_stow_state() const;
  void _internal_set_stow_state(::bosdyn::api::ManipulatorState_StowState value);
  public:

  // double gripper_open_percentage = 12;
  void clear_gripper_open_percentage();
  double gripper_open_percentage() const;
  void set_gripper_open_percentage(double value);
  private:
  double _internal_gripper_open_percentage() const;
  void _internal_set_gripper_open_percentage(double value);
  public:

  // .bosdyn.api.ManipulatorState.CarryState carry_state = 16;
  void clear_carry_state();
  ::bosdyn::api::ManipulatorState_CarryState carry_state() const;
  void set_carry_state(::bosdyn::api::ManipulatorState_CarryState value);
  private:
  ::bosdyn::api::ManipulatorState_CarryState _internal_carry_state() const;
  void _internal_set_carry_state(::bosdyn::api::ManipulatorState_CarryState value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ManipulatorState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec3* estimated_end_effector_force_in_hand_;
    ::bosdyn::api::SE3Velocity* velocity_of_hand_in_vision_;
    ::bosdyn::api::SE3Velocity* velocity_of_hand_in_odom_;
    bool is_gripper_holding_item_;
    int stow_state_;
    double gripper_open_percentage_;
    int carry_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class ServiceFaultState_AggregatedEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ServiceFaultState_AggregatedEntry_DoNotUse, 
    std::string, ::bosdyn::api::ServiceFault_Severity,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ServiceFaultState_AggregatedEntry_DoNotUse, 
    std::string, ::bosdyn::api::ServiceFault_Severity,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> SuperType;
  ServiceFaultState_AggregatedEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ServiceFaultState_AggregatedEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ServiceFaultState_AggregatedEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ServiceFaultState_AggregatedEntry_DoNotUse& other);
  static const ServiceFaultState_AggregatedEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ServiceFaultState_AggregatedEntry_DoNotUse*>(&_ServiceFaultState_AggregatedEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.ServiceFaultState.AggregatedEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};

// -------------------------------------------------------------------

class ServiceFaultState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ServiceFaultState) */ {
 public:
  inline ServiceFaultState() : ServiceFaultState(nullptr) {}
  ~ServiceFaultState() override;
  explicit PROTOBUF_CONSTEXPR ServiceFaultState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceFaultState(const ServiceFaultState& from);
  ServiceFaultState(ServiceFaultState&& from) noexcept
    : ServiceFaultState() {
    *this = ::std::move(from);
  }

  inline ServiceFaultState& operator=(const ServiceFaultState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceFaultState& operator=(ServiceFaultState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceFaultState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceFaultState* internal_default_instance() {
    return reinterpret_cast<const ServiceFaultState*>(
               &_ServiceFaultState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ServiceFaultState& a, ServiceFaultState& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceFaultState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceFaultState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceFaultState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceFaultState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceFaultState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceFaultState& from) {
    ServiceFaultState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceFaultState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ServiceFaultState";
  }
  protected:
  explicit ServiceFaultState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFaultsFieldNumber = 1,
    kHistoricalFaultsFieldNumber = 2,
    kAggregatedFieldNumber = 3,
  };
  // repeated .bosdyn.api.ServiceFault faults = 1;
  int faults_size() const;
  private:
  int _internal_faults_size() const;
  public:
  void clear_faults();
  ::bosdyn::api::ServiceFault* mutable_faults(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ServiceFault >*
      mutable_faults();
  private:
  const ::bosdyn::api::ServiceFault& _internal_faults(int index) const;
  ::bosdyn::api::ServiceFault* _internal_add_faults();
  public:
  const ::bosdyn::api::ServiceFault& faults(int index) const;
  ::bosdyn::api::ServiceFault* add_faults();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ServiceFault >&
      faults() const;

  // repeated .bosdyn.api.ServiceFault historical_faults = 2;
  int historical_faults_size() const;
  private:
  int _internal_historical_faults_size() const;
  public:
  void clear_historical_faults();
  ::bosdyn::api::ServiceFault* mutable_historical_faults(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ServiceFault >*
      mutable_historical_faults();
  private:
  const ::bosdyn::api::ServiceFault& _internal_historical_faults(int index) const;
  ::bosdyn::api::ServiceFault* _internal_add_historical_faults();
  public:
  const ::bosdyn::api::ServiceFault& historical_faults(int index) const;
  ::bosdyn::api::ServiceFault* add_historical_faults();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ServiceFault >&
      historical_faults() const;

  // map<string, .bosdyn.api.ServiceFault.Severity> aggregated = 3;
  int aggregated_size() const;
  private:
  int _internal_aggregated_size() const;
  public:
  void clear_aggregated();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::ServiceFault_Severity >&
      _internal_aggregated() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::ServiceFault_Severity >*
      _internal_mutable_aggregated();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::ServiceFault_Severity >&
      aggregated() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::ServiceFault_Severity >*
      mutable_aggregated();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ServiceFaultState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ServiceFault > faults_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ServiceFault > historical_faults_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ServiceFaultState_AggregatedEntry_DoNotUse,
        std::string, ::bosdyn::api::ServiceFault_Severity,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> aggregated_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class TerrainState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.TerrainState) */ {
 public:
  inline TerrainState() : TerrainState(nullptr) {}
  ~TerrainState() override;
  explicit PROTOBUF_CONSTEXPR TerrainState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TerrainState(const TerrainState& from);
  TerrainState(TerrainState&& from) noexcept
    : TerrainState() {
    *this = ::std::move(from);
  }

  inline TerrainState& operator=(const TerrainState& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerrainState& operator=(TerrainState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TerrainState& default_instance() {
    return *internal_default_instance();
  }
  static inline const TerrainState* internal_default_instance() {
    return reinterpret_cast<const TerrainState*>(
               &_TerrainState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TerrainState& a, TerrainState& b) {
    a.Swap(&b);
  }
  inline void Swap(TerrainState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TerrainState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TerrainState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TerrainState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TerrainState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TerrainState& from) {
    TerrainState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TerrainState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.TerrainState";
  }
  protected:
  explicit TerrainState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsUnsafeToSitFieldNumber = 1,
  };
  // bool is_unsafe_to_sit = 1;
  void clear_is_unsafe_to_sit();
  bool is_unsafe_to_sit() const;
  void set_is_unsafe_to_sit(bool value);
  private:
  bool _internal_is_unsafe_to_sit() const;
  void _internal_set_is_unsafe_to_sit(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.TerrainState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool is_unsafe_to_sit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotStateRequest) */ {
 public:
  inline RobotStateRequest() : RobotStateRequest(nullptr) {}
  ~RobotStateRequest() override;
  explicit PROTOBUF_CONSTEXPR RobotStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotStateRequest(const RobotStateRequest& from);
  RobotStateRequest(RobotStateRequest&& from) noexcept
    : RobotStateRequest() {
    *this = ::std::move(from);
  }

  inline RobotStateRequest& operator=(const RobotStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotStateRequest& operator=(RobotStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotStateRequest* internal_default_instance() {
    return reinterpret_cast<const RobotStateRequest*>(
               &_RobotStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(RobotStateRequest& a, RobotStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotStateRequest& from) {
    RobotStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotStateRequest";
  }
  protected:
  explicit RobotStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotStateResponse) */ {
 public:
  inline RobotStateResponse() : RobotStateResponse(nullptr) {}
  ~RobotStateResponse() override;
  explicit PROTOBUF_CONSTEXPR RobotStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotStateResponse(const RobotStateResponse& from);
  RobotStateResponse(RobotStateResponse&& from) noexcept
    : RobotStateResponse() {
    *this = ::std::move(from);
  }

  inline RobotStateResponse& operator=(const RobotStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotStateResponse& operator=(RobotStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotStateResponse* internal_default_instance() {
    return reinterpret_cast<const RobotStateResponse*>(
               &_RobotStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RobotStateResponse& a, RobotStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotStateResponse& from) {
    RobotStateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotStateResponse";
  }
  protected:
  explicit RobotStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRobotStateFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.RobotState robot_state = 2;
  bool has_robot_state() const;
  private:
  bool _internal_has_robot_state() const;
  public:
  void clear_robot_state();
  const ::bosdyn::api::RobotState& robot_state() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RobotState* release_robot_state();
  ::bosdyn::api::RobotState* mutable_robot_state();
  void set_allocated_robot_state(::bosdyn::api::RobotState* robot_state);
  private:
  const ::bosdyn::api::RobotState& _internal_robot_state() const;
  ::bosdyn::api::RobotState* _internal_mutable_robot_state();
  public:
  void unsafe_arena_set_allocated_robot_state(
      ::bosdyn::api::RobotState* robot_state);
  ::bosdyn::api::RobotState* unsafe_arena_release_robot_state();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::RobotState* robot_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotMetricsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotMetricsRequest) */ {
 public:
  inline RobotMetricsRequest() : RobotMetricsRequest(nullptr) {}
  ~RobotMetricsRequest() override;
  explicit PROTOBUF_CONSTEXPR RobotMetricsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotMetricsRequest(const RobotMetricsRequest& from);
  RobotMetricsRequest(RobotMetricsRequest&& from) noexcept
    : RobotMetricsRequest() {
    *this = ::std::move(from);
  }

  inline RobotMetricsRequest& operator=(const RobotMetricsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotMetricsRequest& operator=(RobotMetricsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotMetricsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotMetricsRequest* internal_default_instance() {
    return reinterpret_cast<const RobotMetricsRequest*>(
               &_RobotMetricsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(RobotMetricsRequest& a, RobotMetricsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotMetricsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotMetricsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotMetricsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotMetricsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotMetricsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotMetricsRequest& from) {
    RobotMetricsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotMetricsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotMetricsRequest";
  }
  protected:
  explicit RobotMetricsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotMetricsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotMetricsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotMetricsResponse) */ {
 public:
  inline RobotMetricsResponse() : RobotMetricsResponse(nullptr) {}
  ~RobotMetricsResponse() override;
  explicit PROTOBUF_CONSTEXPR RobotMetricsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotMetricsResponse(const RobotMetricsResponse& from);
  RobotMetricsResponse(RobotMetricsResponse&& from) noexcept
    : RobotMetricsResponse() {
    *this = ::std::move(from);
  }

  inline RobotMetricsResponse& operator=(const RobotMetricsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotMetricsResponse& operator=(RobotMetricsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotMetricsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotMetricsResponse* internal_default_instance() {
    return reinterpret_cast<const RobotMetricsResponse*>(
               &_RobotMetricsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(RobotMetricsResponse& a, RobotMetricsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotMetricsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotMetricsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotMetricsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotMetricsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotMetricsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotMetricsResponse& from) {
    RobotMetricsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotMetricsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotMetricsResponse";
  }
  protected:
  explicit RobotMetricsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRobotMetricsFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.RobotMetrics robot_metrics = 2;
  bool has_robot_metrics() const;
  private:
  bool _internal_has_robot_metrics() const;
  public:
  void clear_robot_metrics();
  const ::bosdyn::api::RobotMetrics& robot_metrics() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RobotMetrics* release_robot_metrics();
  ::bosdyn::api::RobotMetrics* mutable_robot_metrics();
  void set_allocated_robot_metrics(::bosdyn::api::RobotMetrics* robot_metrics);
  private:
  const ::bosdyn::api::RobotMetrics& _internal_robot_metrics() const;
  ::bosdyn::api::RobotMetrics* _internal_mutable_robot_metrics();
  public:
  void unsafe_arena_set_allocated_robot_metrics(
      ::bosdyn::api::RobotMetrics* robot_metrics);
  ::bosdyn::api::RobotMetrics* unsafe_arena_release_robot_metrics();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotMetricsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::RobotMetrics* robot_metrics_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotHardwareConfigurationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotHardwareConfigurationRequest) */ {
 public:
  inline RobotHardwareConfigurationRequest() : RobotHardwareConfigurationRequest(nullptr) {}
  ~RobotHardwareConfigurationRequest() override;
  explicit PROTOBUF_CONSTEXPR RobotHardwareConfigurationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotHardwareConfigurationRequest(const RobotHardwareConfigurationRequest& from);
  RobotHardwareConfigurationRequest(RobotHardwareConfigurationRequest&& from) noexcept
    : RobotHardwareConfigurationRequest() {
    *this = ::std::move(from);
  }

  inline RobotHardwareConfigurationRequest& operator=(const RobotHardwareConfigurationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotHardwareConfigurationRequest& operator=(RobotHardwareConfigurationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotHardwareConfigurationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotHardwareConfigurationRequest* internal_default_instance() {
    return reinterpret_cast<const RobotHardwareConfigurationRequest*>(
               &_RobotHardwareConfigurationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(RobotHardwareConfigurationRequest& a, RobotHardwareConfigurationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotHardwareConfigurationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotHardwareConfigurationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotHardwareConfigurationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotHardwareConfigurationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotHardwareConfigurationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotHardwareConfigurationRequest& from) {
    RobotHardwareConfigurationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotHardwareConfigurationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotHardwareConfigurationRequest";
  }
  protected:
  explicit RobotHardwareConfigurationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotHardwareConfigurationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotHardwareConfigurationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotHardwareConfigurationResponse) */ {
 public:
  inline RobotHardwareConfigurationResponse() : RobotHardwareConfigurationResponse(nullptr) {}
  ~RobotHardwareConfigurationResponse() override;
  explicit PROTOBUF_CONSTEXPR RobotHardwareConfigurationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotHardwareConfigurationResponse(const RobotHardwareConfigurationResponse& from);
  RobotHardwareConfigurationResponse(RobotHardwareConfigurationResponse&& from) noexcept
    : RobotHardwareConfigurationResponse() {
    *this = ::std::move(from);
  }

  inline RobotHardwareConfigurationResponse& operator=(const RobotHardwareConfigurationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotHardwareConfigurationResponse& operator=(RobotHardwareConfigurationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotHardwareConfigurationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotHardwareConfigurationResponse* internal_default_instance() {
    return reinterpret_cast<const RobotHardwareConfigurationResponse*>(
               &_RobotHardwareConfigurationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(RobotHardwareConfigurationResponse& a, RobotHardwareConfigurationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotHardwareConfigurationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotHardwareConfigurationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotHardwareConfigurationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotHardwareConfigurationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotHardwareConfigurationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotHardwareConfigurationResponse& from) {
    RobotHardwareConfigurationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotHardwareConfigurationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotHardwareConfigurationResponse";
  }
  protected:
  explicit RobotHardwareConfigurationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kHardwareConfigurationFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.HardwareConfiguration hardware_configuration = 2;
  bool has_hardware_configuration() const;
  private:
  bool _internal_has_hardware_configuration() const;
  public:
  void clear_hardware_configuration();
  const ::bosdyn::api::HardwareConfiguration& hardware_configuration() const;
  PROTOBUF_NODISCARD ::bosdyn::api::HardwareConfiguration* release_hardware_configuration();
  ::bosdyn::api::HardwareConfiguration* mutable_hardware_configuration();
  void set_allocated_hardware_configuration(::bosdyn::api::HardwareConfiguration* hardware_configuration);
  private:
  const ::bosdyn::api::HardwareConfiguration& _internal_hardware_configuration() const;
  ::bosdyn::api::HardwareConfiguration* _internal_mutable_hardware_configuration();
  public:
  void unsafe_arena_set_allocated_hardware_configuration(
      ::bosdyn::api::HardwareConfiguration* hardware_configuration);
  ::bosdyn::api::HardwareConfiguration* unsafe_arena_release_hardware_configuration();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotHardwareConfigurationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::HardwareConfiguration* hardware_configuration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotLinkModelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotLinkModelRequest) */ {
 public:
  inline RobotLinkModelRequest() : RobotLinkModelRequest(nullptr) {}
  ~RobotLinkModelRequest() override;
  explicit PROTOBUF_CONSTEXPR RobotLinkModelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotLinkModelRequest(const RobotLinkModelRequest& from);
  RobotLinkModelRequest(RobotLinkModelRequest&& from) noexcept
    : RobotLinkModelRequest() {
    *this = ::std::move(from);
  }

  inline RobotLinkModelRequest& operator=(const RobotLinkModelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotLinkModelRequest& operator=(RobotLinkModelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotLinkModelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotLinkModelRequest* internal_default_instance() {
    return reinterpret_cast<const RobotLinkModelRequest*>(
               &_RobotLinkModelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(RobotLinkModelRequest& a, RobotLinkModelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotLinkModelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotLinkModelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotLinkModelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotLinkModelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotLinkModelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotLinkModelRequest& from) {
    RobotLinkModelRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotLinkModelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotLinkModelRequest";
  }
  protected:
  explicit RobotLinkModelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkNameFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // string link_name = 2;
  void clear_link_name();
  const std::string& link_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_link_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_link_name();
  PROTOBUF_NODISCARD std::string* release_link_name();
  void set_allocated_link_name(std::string* link_name);
  private:
  const std::string& _internal_link_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_name(const std::string& value);
  std::string* _internal_mutable_link_name();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotLinkModelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_name_;
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotLinkModelResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotLinkModelResponse) */ {
 public:
  inline RobotLinkModelResponse() : RobotLinkModelResponse(nullptr) {}
  ~RobotLinkModelResponse() override;
  explicit PROTOBUF_CONSTEXPR RobotLinkModelResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotLinkModelResponse(const RobotLinkModelResponse& from);
  RobotLinkModelResponse(RobotLinkModelResponse&& from) noexcept
    : RobotLinkModelResponse() {
    *this = ::std::move(from);
  }

  inline RobotLinkModelResponse& operator=(const RobotLinkModelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotLinkModelResponse& operator=(RobotLinkModelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotLinkModelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotLinkModelResponse* internal_default_instance() {
    return reinterpret_cast<const RobotLinkModelResponse*>(
               &_RobotLinkModelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(RobotLinkModelResponse& a, RobotLinkModelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotLinkModelResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotLinkModelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotLinkModelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotLinkModelResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotLinkModelResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotLinkModelResponse& from) {
    RobotLinkModelResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotLinkModelResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotLinkModelResponse";
  }
  protected:
  explicit RobotLinkModelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLinkModelFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.Skeleton.Link.ObjModel link_model = 2;
  bool has_link_model() const;
  private:
  bool _internal_has_link_model() const;
  public:
  void clear_link_model();
  const ::bosdyn::api::Skeleton_Link_ObjModel& link_model() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Skeleton_Link_ObjModel* release_link_model();
  ::bosdyn::api::Skeleton_Link_ObjModel* mutable_link_model();
  void set_allocated_link_model(::bosdyn::api::Skeleton_Link_ObjModel* link_model);
  private:
  const ::bosdyn::api::Skeleton_Link_ObjModel& _internal_link_model() const;
  ::bosdyn::api::Skeleton_Link_ObjModel* _internal_mutable_link_model();
  public:
  void unsafe_arena_set_allocated_link_model(
      ::bosdyn::api::Skeleton_Link_ObjModel* link_model);
  ::bosdyn::api::Skeleton_Link_ObjModel* unsafe_arena_release_link_model();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotLinkModelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::Skeleton_Link_ObjModel* link_model_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotImpairedState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotImpairedState) */ {
 public:
  inline RobotImpairedState() : RobotImpairedState(nullptr) {}
  ~RobotImpairedState() override;
  explicit PROTOBUF_CONSTEXPR RobotImpairedState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotImpairedState(const RobotImpairedState& from);
  RobotImpairedState(RobotImpairedState&& from) noexcept
    : RobotImpairedState() {
    *this = ::std::move(from);
  }

  inline RobotImpairedState& operator=(const RobotImpairedState& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotImpairedState& operator=(RobotImpairedState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotImpairedState& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotImpairedState* internal_default_instance() {
    return reinterpret_cast<const RobotImpairedState*>(
               &_RobotImpairedState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(RobotImpairedState& a, RobotImpairedState& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotImpairedState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotImpairedState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotImpairedState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotImpairedState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotImpairedState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotImpairedState& from) {
    RobotImpairedState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotImpairedState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotImpairedState";
  }
  protected:
  explicit RobotImpairedState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RobotImpairedState_ImpairedStatus ImpairedStatus;
  static constexpr ImpairedStatus IMPAIRED_STATUS_UNKNOWN =
    RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_UNKNOWN;
  static constexpr ImpairedStatus IMPAIRED_STATUS_OK =
    RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_OK;
  static constexpr ImpairedStatus IMPAIRED_STATUS_NO_ROBOT_DATA =
    RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_NO_ROBOT_DATA;
  static constexpr ImpairedStatus IMPAIRED_STATUS_SYSTEM_FAULT =
    RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_SYSTEM_FAULT;
  static constexpr ImpairedStatus IMPAIRED_STATUS_NO_MOTOR_POWER =
    RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_NO_MOTOR_POWER;
  static constexpr ImpairedStatus IMPAIRED_STATUS_REMOTE_CLOUDS_NOT_WORKING =
    RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_REMOTE_CLOUDS_NOT_WORKING;
  static constexpr ImpairedStatus IMPAIRED_STATUS_SERVICE_FAULT =
    RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_SERVICE_FAULT;
  static constexpr ImpairedStatus IMPAIRED_STATUS_BEHAVIOR_FAULT =
    RobotImpairedState_ImpairedStatus_IMPAIRED_STATUS_BEHAVIOR_FAULT;
  static inline bool ImpairedStatus_IsValid(int value) {
    return RobotImpairedState_ImpairedStatus_IsValid(value);
  }
  static constexpr ImpairedStatus ImpairedStatus_MIN =
    RobotImpairedState_ImpairedStatus_ImpairedStatus_MIN;
  static constexpr ImpairedStatus ImpairedStatus_MAX =
    RobotImpairedState_ImpairedStatus_ImpairedStatus_MAX;
  static constexpr int ImpairedStatus_ARRAYSIZE =
    RobotImpairedState_ImpairedStatus_ImpairedStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ImpairedStatus_descriptor() {
    return RobotImpairedState_ImpairedStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& ImpairedStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ImpairedStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ImpairedStatus_Name.");
    return RobotImpairedState_ImpairedStatus_Name(enum_t_value);
  }
  static inline bool ImpairedStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ImpairedStatus* value) {
    return RobotImpairedState_ImpairedStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSystemFaultsFieldNumber = 2,
    kServiceFaultsFieldNumber = 3,
    kBehaviorFaultsFieldNumber = 4,
    kImpairedStatusFieldNumber = 1,
  };
  // repeated .bosdyn.api.SystemFault system_faults = 2;
  int system_faults_size() const;
  private:
  int _internal_system_faults_size() const;
  public:
  void clear_system_faults();
  ::bosdyn::api::SystemFault* mutable_system_faults(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >*
      mutable_system_faults();
  private:
  const ::bosdyn::api::SystemFault& _internal_system_faults(int index) const;
  ::bosdyn::api::SystemFault* _internal_add_system_faults();
  public:
  const ::bosdyn::api::SystemFault& system_faults(int index) const;
  ::bosdyn::api::SystemFault* add_system_faults();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >&
      system_faults() const;

  // repeated .bosdyn.api.ServiceFault service_faults = 3;
  int service_faults_size() const;
  private:
  int _internal_service_faults_size() const;
  public:
  void clear_service_faults();
  ::bosdyn::api::ServiceFault* mutable_service_faults(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ServiceFault >*
      mutable_service_faults();
  private:
  const ::bosdyn::api::ServiceFault& _internal_service_faults(int index) const;
  ::bosdyn::api::ServiceFault* _internal_add_service_faults();
  public:
  const ::bosdyn::api::ServiceFault& service_faults(int index) const;
  ::bosdyn::api::ServiceFault* add_service_faults();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ServiceFault >&
      service_faults() const;

  // repeated .bosdyn.api.BehaviorFault behavior_faults = 4;
  int behavior_faults_size() const;
  private:
  int _internal_behavior_faults_size() const;
  public:
  void clear_behavior_faults();
  ::bosdyn::api::BehaviorFault* mutable_behavior_faults(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BehaviorFault >*
      mutable_behavior_faults();
  private:
  const ::bosdyn::api::BehaviorFault& _internal_behavior_faults(int index) const;
  ::bosdyn::api::BehaviorFault* _internal_add_behavior_faults();
  public:
  const ::bosdyn::api::BehaviorFault& behavior_faults(int index) const;
  ::bosdyn::api::BehaviorFault* add_behavior_faults();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BehaviorFault >&
      behavior_faults() const;

  // .bosdyn.api.RobotImpairedState.ImpairedStatus impaired_status = 1;
  void clear_impaired_status();
  ::bosdyn::api::RobotImpairedState_ImpairedStatus impaired_status() const;
  void set_impaired_status(::bosdyn::api::RobotImpairedState_ImpairedStatus value);
  private:
  ::bosdyn::api::RobotImpairedState_ImpairedStatus _internal_impaired_status() const;
  void _internal_set_impaired_status(::bosdyn::api::RobotImpairedState_ImpairedStatus value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotImpairedState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault > system_faults_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ServiceFault > service_faults_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BehaviorFault > behavior_faults_;
    int impaired_status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Skeleton_Link_ObjModel

// string file_name = 1;
inline void Skeleton_Link_ObjModel::clear_file_name() {
  _impl_.file_name_.ClearToEmpty();
}
inline const std::string& Skeleton_Link_ObjModel::file_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Skeleton.Link.ObjModel.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Skeleton_Link_ObjModel::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.Skeleton.Link.ObjModel.file_name)
}
inline std::string* Skeleton_Link_ObjModel::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Skeleton.Link.ObjModel.file_name)
  return _s;
}
inline const std::string& Skeleton_Link_ObjModel::_internal_file_name() const {
  return _impl_.file_name_.Get();
}
inline void Skeleton_Link_ObjModel::_internal_set_file_name(const std::string& value) {
  
  _impl_.file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Skeleton_Link_ObjModel::_internal_mutable_file_name() {
  
  return _impl_.file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Skeleton_Link_ObjModel::release_file_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Skeleton.Link.ObjModel.file_name)
  return _impl_.file_name_.Release();
}
inline void Skeleton_Link_ObjModel::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  _impl_.file_name_.SetAllocated(file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_name_.IsDefault()) {
    _impl_.file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Skeleton.Link.ObjModel.file_name)
}

// string file_contents = 2;
inline void Skeleton_Link_ObjModel::clear_file_contents() {
  _impl_.file_contents_.ClearToEmpty();
}
inline const std::string& Skeleton_Link_ObjModel::file_contents() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Skeleton.Link.ObjModel.file_contents)
  return _internal_file_contents();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Skeleton_Link_ObjModel::set_file_contents(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_contents_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.Skeleton.Link.ObjModel.file_contents)
}
inline std::string* Skeleton_Link_ObjModel::mutable_file_contents() {
  std::string* _s = _internal_mutable_file_contents();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Skeleton.Link.ObjModel.file_contents)
  return _s;
}
inline const std::string& Skeleton_Link_ObjModel::_internal_file_contents() const {
  return _impl_.file_contents_.Get();
}
inline void Skeleton_Link_ObjModel::_internal_set_file_contents(const std::string& value) {
  
  _impl_.file_contents_.Set(value, GetArenaForAllocation());
}
inline std::string* Skeleton_Link_ObjModel::_internal_mutable_file_contents() {
  
  return _impl_.file_contents_.Mutable(GetArenaForAllocation());
}
inline std::string* Skeleton_Link_ObjModel::release_file_contents() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Skeleton.Link.ObjModel.file_contents)
  return _impl_.file_contents_.Release();
}
inline void Skeleton_Link_ObjModel::set_allocated_file_contents(std::string* file_contents) {
  if (file_contents != nullptr) {
    
  } else {
    
  }
  _impl_.file_contents_.SetAllocated(file_contents, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_contents_.IsDefault()) {
    _impl_.file_contents_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Skeleton.Link.ObjModel.file_contents)
}

// -------------------------------------------------------------------

// Skeleton_Link

// string name = 1;
inline void Skeleton_Link::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Skeleton_Link::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Skeleton.Link.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Skeleton_Link::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.Skeleton.Link.name)
}
inline std::string* Skeleton_Link::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Skeleton.Link.name)
  return _s;
}
inline const std::string& Skeleton_Link::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Skeleton_Link::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Skeleton_Link::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Skeleton_Link::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Skeleton.Link.name)
  return _impl_.name_.Release();
}
inline void Skeleton_Link::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Skeleton.Link.name)
}

// .bosdyn.api.Skeleton.Link.ObjModel obj_model = 2;
inline bool Skeleton_Link::_internal_has_obj_model() const {
  return this != internal_default_instance() && _impl_.obj_model_ != nullptr;
}
inline bool Skeleton_Link::has_obj_model() const {
  return _internal_has_obj_model();
}
inline void Skeleton_Link::clear_obj_model() {
  if (GetArenaForAllocation() == nullptr && _impl_.obj_model_ != nullptr) {
    delete _impl_.obj_model_;
  }
  _impl_.obj_model_ = nullptr;
}
inline const ::bosdyn::api::Skeleton_Link_ObjModel& Skeleton_Link::_internal_obj_model() const {
  const ::bosdyn::api::Skeleton_Link_ObjModel* p = _impl_.obj_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Skeleton_Link_ObjModel&>(
      ::bosdyn::api::_Skeleton_Link_ObjModel_default_instance_);
}
inline const ::bosdyn::api::Skeleton_Link_ObjModel& Skeleton_Link::obj_model() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Skeleton.Link.obj_model)
  return _internal_obj_model();
}
inline void Skeleton_Link::unsafe_arena_set_allocated_obj_model(
    ::bosdyn::api::Skeleton_Link_ObjModel* obj_model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obj_model_);
  }
  _impl_.obj_model_ = obj_model;
  if (obj_model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Skeleton.Link.obj_model)
}
inline ::bosdyn::api::Skeleton_Link_ObjModel* Skeleton_Link::release_obj_model() {
  
  ::bosdyn::api::Skeleton_Link_ObjModel* temp = _impl_.obj_model_;
  _impl_.obj_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Skeleton_Link_ObjModel* Skeleton_Link::unsafe_arena_release_obj_model() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Skeleton.Link.obj_model)
  
  ::bosdyn::api::Skeleton_Link_ObjModel* temp = _impl_.obj_model_;
  _impl_.obj_model_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Skeleton_Link_ObjModel* Skeleton_Link::_internal_mutable_obj_model() {
  
  if (_impl_.obj_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Skeleton_Link_ObjModel>(GetArenaForAllocation());
    _impl_.obj_model_ = p;
  }
  return _impl_.obj_model_;
}
inline ::bosdyn::api::Skeleton_Link_ObjModel* Skeleton_Link::mutable_obj_model() {
  ::bosdyn::api::Skeleton_Link_ObjModel* _msg = _internal_mutable_obj_model();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Skeleton.Link.obj_model)
  return _msg;
}
inline void Skeleton_Link::set_allocated_obj_model(::bosdyn::api::Skeleton_Link_ObjModel* obj_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.obj_model_;
  }
  if (obj_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(obj_model);
    if (message_arena != submessage_arena) {
      obj_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obj_model, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.obj_model_ = obj_model;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Skeleton.Link.obj_model)
}

// -------------------------------------------------------------------

// Skeleton

// repeated .bosdyn.api.Skeleton.Link links = 2;
inline int Skeleton::_internal_links_size() const {
  return _impl_.links_.size();
}
inline int Skeleton::links_size() const {
  return _internal_links_size();
}
inline void Skeleton::clear_links() {
  _impl_.links_.Clear();
}
inline ::bosdyn::api::Skeleton_Link* Skeleton::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Skeleton.links)
  return _impl_.links_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Skeleton_Link >*
Skeleton::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.Skeleton.links)
  return &_impl_.links_;
}
inline const ::bosdyn::api::Skeleton_Link& Skeleton::_internal_links(int index) const {
  return _impl_.links_.Get(index);
}
inline const ::bosdyn::api::Skeleton_Link& Skeleton::links(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Skeleton.links)
  return _internal_links(index);
}
inline ::bosdyn::api::Skeleton_Link* Skeleton::_internal_add_links() {
  return _impl_.links_.Add();
}
inline ::bosdyn::api::Skeleton_Link* Skeleton::add_links() {
  ::bosdyn::api::Skeleton_Link* _add = _internal_add_links();
  // @@protoc_insertion_point(field_add:bosdyn.api.Skeleton.links)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Skeleton_Link >&
Skeleton::links() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.Skeleton.links)
  return _impl_.links_;
}

// string urdf = 3;
inline void Skeleton::clear_urdf() {
  _impl_.urdf_.ClearToEmpty();
}
inline const std::string& Skeleton::urdf() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Skeleton.urdf)
  return _internal_urdf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Skeleton::set_urdf(ArgT0&& arg0, ArgT... args) {
 
 _impl_.urdf_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.Skeleton.urdf)
}
inline std::string* Skeleton::mutable_urdf() {
  std::string* _s = _internal_mutable_urdf();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Skeleton.urdf)
  return _s;
}
inline const std::string& Skeleton::_internal_urdf() const {
  return _impl_.urdf_.Get();
}
inline void Skeleton::_internal_set_urdf(const std::string& value) {
  
  _impl_.urdf_.Set(value, GetArenaForAllocation());
}
inline std::string* Skeleton::_internal_mutable_urdf() {
  
  return _impl_.urdf_.Mutable(GetArenaForAllocation());
}
inline std::string* Skeleton::release_urdf() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Skeleton.urdf)
  return _impl_.urdf_.Release();
}
inline void Skeleton::set_allocated_urdf(std::string* urdf) {
  if (urdf != nullptr) {
    
  } else {
    
  }
  _impl_.urdf_.SetAllocated(urdf, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.urdf_.IsDefault()) {
    _impl_.urdf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Skeleton.urdf)
}

// -------------------------------------------------------------------

// HardwareConfiguration

// .bosdyn.api.Skeleton skeleton = 1;
inline bool HardwareConfiguration::_internal_has_skeleton() const {
  return this != internal_default_instance() && _impl_.skeleton_ != nullptr;
}
inline bool HardwareConfiguration::has_skeleton() const {
  return _internal_has_skeleton();
}
inline void HardwareConfiguration::clear_skeleton() {
  if (GetArenaForAllocation() == nullptr && _impl_.skeleton_ != nullptr) {
    delete _impl_.skeleton_;
  }
  _impl_.skeleton_ = nullptr;
}
inline const ::bosdyn::api::Skeleton& HardwareConfiguration::_internal_skeleton() const {
  const ::bosdyn::api::Skeleton* p = _impl_.skeleton_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Skeleton&>(
      ::bosdyn::api::_Skeleton_default_instance_);
}
inline const ::bosdyn::api::Skeleton& HardwareConfiguration::skeleton() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.HardwareConfiguration.skeleton)
  return _internal_skeleton();
}
inline void HardwareConfiguration::unsafe_arena_set_allocated_skeleton(
    ::bosdyn::api::Skeleton* skeleton) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.skeleton_);
  }
  _impl_.skeleton_ = skeleton;
  if (skeleton) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.HardwareConfiguration.skeleton)
}
inline ::bosdyn::api::Skeleton* HardwareConfiguration::release_skeleton() {
  
  ::bosdyn::api::Skeleton* temp = _impl_.skeleton_;
  _impl_.skeleton_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Skeleton* HardwareConfiguration::unsafe_arena_release_skeleton() {
  // @@protoc_insertion_point(field_release:bosdyn.api.HardwareConfiguration.skeleton)
  
  ::bosdyn::api::Skeleton* temp = _impl_.skeleton_;
  _impl_.skeleton_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Skeleton* HardwareConfiguration::_internal_mutable_skeleton() {
  
  if (_impl_.skeleton_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Skeleton>(GetArenaForAllocation());
    _impl_.skeleton_ = p;
  }
  return _impl_.skeleton_;
}
inline ::bosdyn::api::Skeleton* HardwareConfiguration::mutable_skeleton() {
  ::bosdyn::api::Skeleton* _msg = _internal_mutable_skeleton();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.HardwareConfiguration.skeleton)
  return _msg;
}
inline void HardwareConfiguration::set_allocated_skeleton(::bosdyn::api::Skeleton* skeleton) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.skeleton_;
  }
  if (skeleton) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(skeleton);
    if (message_arena != submessage_arena) {
      skeleton = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, skeleton, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.skeleton_ = skeleton;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.HardwareConfiguration.skeleton)
}

// bool can_power_command_request_off_robot = 2;
inline void HardwareConfiguration::clear_can_power_command_request_off_robot() {
  _impl_.can_power_command_request_off_robot_ = false;
}
inline bool HardwareConfiguration::_internal_can_power_command_request_off_robot() const {
  return _impl_.can_power_command_request_off_robot_;
}
inline bool HardwareConfiguration::can_power_command_request_off_robot() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.HardwareConfiguration.can_power_command_request_off_robot)
  return _internal_can_power_command_request_off_robot();
}
inline void HardwareConfiguration::_internal_set_can_power_command_request_off_robot(bool value) {
  
  _impl_.can_power_command_request_off_robot_ = value;
}
inline void HardwareConfiguration::set_can_power_command_request_off_robot(bool value) {
  _internal_set_can_power_command_request_off_robot(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.HardwareConfiguration.can_power_command_request_off_robot)
}

// bool can_power_command_request_cycle_robot = 3;
inline void HardwareConfiguration::clear_can_power_command_request_cycle_robot() {
  _impl_.can_power_command_request_cycle_robot_ = false;
}
inline bool HardwareConfiguration::_internal_can_power_command_request_cycle_robot() const {
  return _impl_.can_power_command_request_cycle_robot_;
}
inline bool HardwareConfiguration::can_power_command_request_cycle_robot() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.HardwareConfiguration.can_power_command_request_cycle_robot)
  return _internal_can_power_command_request_cycle_robot();
}
inline void HardwareConfiguration::_internal_set_can_power_command_request_cycle_robot(bool value) {
  
  _impl_.can_power_command_request_cycle_robot_ = value;
}
inline void HardwareConfiguration::set_can_power_command_request_cycle_robot(bool value) {
  _internal_set_can_power_command_request_cycle_robot(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.HardwareConfiguration.can_power_command_request_cycle_robot)
}

// bool can_power_command_request_payload_ports = 4;
inline void HardwareConfiguration::clear_can_power_command_request_payload_ports() {
  _impl_.can_power_command_request_payload_ports_ = false;
}
inline bool HardwareConfiguration::_internal_can_power_command_request_payload_ports() const {
  return _impl_.can_power_command_request_payload_ports_;
}
inline bool HardwareConfiguration::can_power_command_request_payload_ports() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.HardwareConfiguration.can_power_command_request_payload_ports)
  return _internal_can_power_command_request_payload_ports();
}
inline void HardwareConfiguration::_internal_set_can_power_command_request_payload_ports(bool value) {
  
  _impl_.can_power_command_request_payload_ports_ = value;
}
inline void HardwareConfiguration::set_can_power_command_request_payload_ports(bool value) {
  _internal_set_can_power_command_request_payload_ports(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.HardwareConfiguration.can_power_command_request_payload_ports)
}

// bool can_power_command_request_wifi_radio = 5;
inline void HardwareConfiguration::clear_can_power_command_request_wifi_radio() {
  _impl_.can_power_command_request_wifi_radio_ = false;
}
inline bool HardwareConfiguration::_internal_can_power_command_request_wifi_radio() const {
  return _impl_.can_power_command_request_wifi_radio_;
}
inline bool HardwareConfiguration::can_power_command_request_wifi_radio() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.HardwareConfiguration.can_power_command_request_wifi_radio)
  return _internal_can_power_command_request_wifi_radio();
}
inline void HardwareConfiguration::_internal_set_can_power_command_request_wifi_radio(bool value) {
  
  _impl_.can_power_command_request_wifi_radio_ = value;
}
inline void HardwareConfiguration::set_can_power_command_request_wifi_radio(bool value) {
  _internal_set_can_power_command_request_wifi_radio(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.HardwareConfiguration.can_power_command_request_wifi_radio)
}

// -------------------------------------------------------------------

// RobotState

// .bosdyn.api.PowerState power_state = 1;
inline bool RobotState::_internal_has_power_state() const {
  return this != internal_default_instance() && _impl_.power_state_ != nullptr;
}
inline bool RobotState::has_power_state() const {
  return _internal_has_power_state();
}
inline void RobotState::clear_power_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.power_state_ != nullptr) {
    delete _impl_.power_state_;
  }
  _impl_.power_state_ = nullptr;
}
inline const ::bosdyn::api::PowerState& RobotState::_internal_power_state() const {
  const ::bosdyn::api::PowerState* p = _impl_.power_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::PowerState&>(
      ::bosdyn::api::_PowerState_default_instance_);
}
inline const ::bosdyn::api::PowerState& RobotState::power_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.power_state)
  return _internal_power_state();
}
inline void RobotState::unsafe_arena_set_allocated_power_state(
    ::bosdyn::api::PowerState* power_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.power_state_);
  }
  _impl_.power_state_ = power_state;
  if (power_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotState.power_state)
}
inline ::bosdyn::api::PowerState* RobotState::release_power_state() {
  
  ::bosdyn::api::PowerState* temp = _impl_.power_state_;
  _impl_.power_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::PowerState* RobotState::unsafe_arena_release_power_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotState.power_state)
  
  ::bosdyn::api::PowerState* temp = _impl_.power_state_;
  _impl_.power_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::PowerState* RobotState::_internal_mutable_power_state() {
  
  if (_impl_.power_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::PowerState>(GetArenaForAllocation());
    _impl_.power_state_ = p;
  }
  return _impl_.power_state_;
}
inline ::bosdyn::api::PowerState* RobotState::mutable_power_state() {
  ::bosdyn::api::PowerState* _msg = _internal_mutable_power_state();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.power_state)
  return _msg;
}
inline void RobotState::set_allocated_power_state(::bosdyn::api::PowerState* power_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.power_state_;
  }
  if (power_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(power_state);
    if (message_arena != submessage_arena) {
      power_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, power_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.power_state_ = power_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotState.power_state)
}

// repeated .bosdyn.api.BatteryState battery_states = 2;
inline int RobotState::_internal_battery_states_size() const {
  return _impl_.battery_states_.size();
}
inline int RobotState::battery_states_size() const {
  return _internal_battery_states_size();
}
inline void RobotState::clear_battery_states() {
  _impl_.battery_states_.Clear();
}
inline ::bosdyn::api::BatteryState* RobotState::mutable_battery_states(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.battery_states)
  return _impl_.battery_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BatteryState >*
RobotState::mutable_battery_states() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RobotState.battery_states)
  return &_impl_.battery_states_;
}
inline const ::bosdyn::api::BatteryState& RobotState::_internal_battery_states(int index) const {
  return _impl_.battery_states_.Get(index);
}
inline const ::bosdyn::api::BatteryState& RobotState::battery_states(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.battery_states)
  return _internal_battery_states(index);
}
inline ::bosdyn::api::BatteryState* RobotState::_internal_add_battery_states() {
  return _impl_.battery_states_.Add();
}
inline ::bosdyn::api::BatteryState* RobotState::add_battery_states() {
  ::bosdyn::api::BatteryState* _add = _internal_add_battery_states();
  // @@protoc_insertion_point(field_add:bosdyn.api.RobotState.battery_states)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BatteryState >&
RobotState::battery_states() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RobotState.battery_states)
  return _impl_.battery_states_;
}

// repeated .bosdyn.api.CommsState comms_states = 3;
inline int RobotState::_internal_comms_states_size() const {
  return _impl_.comms_states_.size();
}
inline int RobotState::comms_states_size() const {
  return _internal_comms_states_size();
}
inline void RobotState::clear_comms_states() {
  _impl_.comms_states_.Clear();
}
inline ::bosdyn::api::CommsState* RobotState::mutable_comms_states(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.comms_states)
  return _impl_.comms_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CommsState >*
RobotState::mutable_comms_states() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RobotState.comms_states)
  return &_impl_.comms_states_;
}
inline const ::bosdyn::api::CommsState& RobotState::_internal_comms_states(int index) const {
  return _impl_.comms_states_.Get(index);
}
inline const ::bosdyn::api::CommsState& RobotState::comms_states(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.comms_states)
  return _internal_comms_states(index);
}
inline ::bosdyn::api::CommsState* RobotState::_internal_add_comms_states() {
  return _impl_.comms_states_.Add();
}
inline ::bosdyn::api::CommsState* RobotState::add_comms_states() {
  ::bosdyn::api::CommsState* _add = _internal_add_comms_states();
  // @@protoc_insertion_point(field_add:bosdyn.api.RobotState.comms_states)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CommsState >&
RobotState::comms_states() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RobotState.comms_states)
  return _impl_.comms_states_;
}

// .bosdyn.api.SystemFaultState system_fault_state = 4;
inline bool RobotState::_internal_has_system_fault_state() const {
  return this != internal_default_instance() && _impl_.system_fault_state_ != nullptr;
}
inline bool RobotState::has_system_fault_state() const {
  return _internal_has_system_fault_state();
}
inline void RobotState::clear_system_fault_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.system_fault_state_ != nullptr) {
    delete _impl_.system_fault_state_;
  }
  _impl_.system_fault_state_ = nullptr;
}
inline const ::bosdyn::api::SystemFaultState& RobotState::_internal_system_fault_state() const {
  const ::bosdyn::api::SystemFaultState* p = _impl_.system_fault_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SystemFaultState&>(
      ::bosdyn::api::_SystemFaultState_default_instance_);
}
inline const ::bosdyn::api::SystemFaultState& RobotState::system_fault_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.system_fault_state)
  return _internal_system_fault_state();
}
inline void RobotState::unsafe_arena_set_allocated_system_fault_state(
    ::bosdyn::api::SystemFaultState* system_fault_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_fault_state_);
  }
  _impl_.system_fault_state_ = system_fault_state;
  if (system_fault_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotState.system_fault_state)
}
inline ::bosdyn::api::SystemFaultState* RobotState::release_system_fault_state() {
  
  ::bosdyn::api::SystemFaultState* temp = _impl_.system_fault_state_;
  _impl_.system_fault_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SystemFaultState* RobotState::unsafe_arena_release_system_fault_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotState.system_fault_state)
  
  ::bosdyn::api::SystemFaultState* temp = _impl_.system_fault_state_;
  _impl_.system_fault_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SystemFaultState* RobotState::_internal_mutable_system_fault_state() {
  
  if (_impl_.system_fault_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SystemFaultState>(GetArenaForAllocation());
    _impl_.system_fault_state_ = p;
  }
  return _impl_.system_fault_state_;
}
inline ::bosdyn::api::SystemFaultState* RobotState::mutable_system_fault_state() {
  ::bosdyn::api::SystemFaultState* _msg = _internal_mutable_system_fault_state();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.system_fault_state)
  return _msg;
}
inline void RobotState::set_allocated_system_fault_state(::bosdyn::api::SystemFaultState* system_fault_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.system_fault_state_;
  }
  if (system_fault_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(system_fault_state);
    if (message_arena != submessage_arena) {
      system_fault_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_fault_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.system_fault_state_ = system_fault_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotState.system_fault_state)
}

// repeated .bosdyn.api.EStopState estop_states = 5;
inline int RobotState::_internal_estop_states_size() const {
  return _impl_.estop_states_.size();
}
inline int RobotState::estop_states_size() const {
  return _internal_estop_states_size();
}
inline void RobotState::clear_estop_states() {
  _impl_.estop_states_.Clear();
}
inline ::bosdyn::api::EStopState* RobotState::mutable_estop_states(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.estop_states)
  return _impl_.estop_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EStopState >*
RobotState::mutable_estop_states() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RobotState.estop_states)
  return &_impl_.estop_states_;
}
inline const ::bosdyn::api::EStopState& RobotState::_internal_estop_states(int index) const {
  return _impl_.estop_states_.Get(index);
}
inline const ::bosdyn::api::EStopState& RobotState::estop_states(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.estop_states)
  return _internal_estop_states(index);
}
inline ::bosdyn::api::EStopState* RobotState::_internal_add_estop_states() {
  return _impl_.estop_states_.Add();
}
inline ::bosdyn::api::EStopState* RobotState::add_estop_states() {
  ::bosdyn::api::EStopState* _add = _internal_add_estop_states();
  // @@protoc_insertion_point(field_add:bosdyn.api.RobotState.estop_states)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EStopState >&
RobotState::estop_states() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RobotState.estop_states)
  return _impl_.estop_states_;
}

// .bosdyn.api.KinematicState kinematic_state = 6;
inline bool RobotState::_internal_has_kinematic_state() const {
  return this != internal_default_instance() && _impl_.kinematic_state_ != nullptr;
}
inline bool RobotState::has_kinematic_state() const {
  return _internal_has_kinematic_state();
}
inline void RobotState::clear_kinematic_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.kinematic_state_ != nullptr) {
    delete _impl_.kinematic_state_;
  }
  _impl_.kinematic_state_ = nullptr;
}
inline const ::bosdyn::api::KinematicState& RobotState::_internal_kinematic_state() const {
  const ::bosdyn::api::KinematicState* p = _impl_.kinematic_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::KinematicState&>(
      ::bosdyn::api::_KinematicState_default_instance_);
}
inline const ::bosdyn::api::KinematicState& RobotState::kinematic_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.kinematic_state)
  return _internal_kinematic_state();
}
inline void RobotState::unsafe_arena_set_allocated_kinematic_state(
    ::bosdyn::api::KinematicState* kinematic_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.kinematic_state_);
  }
  _impl_.kinematic_state_ = kinematic_state;
  if (kinematic_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotState.kinematic_state)
}
inline ::bosdyn::api::KinematicState* RobotState::release_kinematic_state() {
  
  ::bosdyn::api::KinematicState* temp = _impl_.kinematic_state_;
  _impl_.kinematic_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::KinematicState* RobotState::unsafe_arena_release_kinematic_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotState.kinematic_state)
  
  ::bosdyn::api::KinematicState* temp = _impl_.kinematic_state_;
  _impl_.kinematic_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::KinematicState* RobotState::_internal_mutable_kinematic_state() {
  
  if (_impl_.kinematic_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::KinematicState>(GetArenaForAllocation());
    _impl_.kinematic_state_ = p;
  }
  return _impl_.kinematic_state_;
}
inline ::bosdyn::api::KinematicState* RobotState::mutable_kinematic_state() {
  ::bosdyn::api::KinematicState* _msg = _internal_mutable_kinematic_state();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.kinematic_state)
  return _msg;
}
inline void RobotState::set_allocated_kinematic_state(::bosdyn::api::KinematicState* kinematic_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.kinematic_state_;
  }
  if (kinematic_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(kinematic_state);
    if (message_arena != submessage_arena) {
      kinematic_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kinematic_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.kinematic_state_ = kinematic_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotState.kinematic_state)
}

// .bosdyn.api.BehaviorFaultState behavior_fault_state = 7;
inline bool RobotState::_internal_has_behavior_fault_state() const {
  return this != internal_default_instance() && _impl_.behavior_fault_state_ != nullptr;
}
inline bool RobotState::has_behavior_fault_state() const {
  return _internal_has_behavior_fault_state();
}
inline void RobotState::clear_behavior_fault_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.behavior_fault_state_ != nullptr) {
    delete _impl_.behavior_fault_state_;
  }
  _impl_.behavior_fault_state_ = nullptr;
}
inline const ::bosdyn::api::BehaviorFaultState& RobotState::_internal_behavior_fault_state() const {
  const ::bosdyn::api::BehaviorFaultState* p = _impl_.behavior_fault_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::BehaviorFaultState&>(
      ::bosdyn::api::_BehaviorFaultState_default_instance_);
}
inline const ::bosdyn::api::BehaviorFaultState& RobotState::behavior_fault_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.behavior_fault_state)
  return _internal_behavior_fault_state();
}
inline void RobotState::unsafe_arena_set_allocated_behavior_fault_state(
    ::bosdyn::api::BehaviorFaultState* behavior_fault_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.behavior_fault_state_);
  }
  _impl_.behavior_fault_state_ = behavior_fault_state;
  if (behavior_fault_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotState.behavior_fault_state)
}
inline ::bosdyn::api::BehaviorFaultState* RobotState::release_behavior_fault_state() {
  
  ::bosdyn::api::BehaviorFaultState* temp = _impl_.behavior_fault_state_;
  _impl_.behavior_fault_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::BehaviorFaultState* RobotState::unsafe_arena_release_behavior_fault_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotState.behavior_fault_state)
  
  ::bosdyn::api::BehaviorFaultState* temp = _impl_.behavior_fault_state_;
  _impl_.behavior_fault_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::BehaviorFaultState* RobotState::_internal_mutable_behavior_fault_state() {
  
  if (_impl_.behavior_fault_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::BehaviorFaultState>(GetArenaForAllocation());
    _impl_.behavior_fault_state_ = p;
  }
  return _impl_.behavior_fault_state_;
}
inline ::bosdyn::api::BehaviorFaultState* RobotState::mutable_behavior_fault_state() {
  ::bosdyn::api::BehaviorFaultState* _msg = _internal_mutable_behavior_fault_state();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.behavior_fault_state)
  return _msg;
}
inline void RobotState::set_allocated_behavior_fault_state(::bosdyn::api::BehaviorFaultState* behavior_fault_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.behavior_fault_state_;
  }
  if (behavior_fault_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(behavior_fault_state);
    if (message_arena != submessage_arena) {
      behavior_fault_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, behavior_fault_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.behavior_fault_state_ = behavior_fault_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotState.behavior_fault_state)
}

// repeated .bosdyn.api.FootState foot_state = 8;
inline int RobotState::_internal_foot_state_size() const {
  return _impl_.foot_state_.size();
}
inline int RobotState::foot_state_size() const {
  return _internal_foot_state_size();
}
inline void RobotState::clear_foot_state() {
  _impl_.foot_state_.Clear();
}
inline ::bosdyn::api::FootState* RobotState::mutable_foot_state(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.foot_state)
  return _impl_.foot_state_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::FootState >*
RobotState::mutable_foot_state() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RobotState.foot_state)
  return &_impl_.foot_state_;
}
inline const ::bosdyn::api::FootState& RobotState::_internal_foot_state(int index) const {
  return _impl_.foot_state_.Get(index);
}
inline const ::bosdyn::api::FootState& RobotState::foot_state(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.foot_state)
  return _internal_foot_state(index);
}
inline ::bosdyn::api::FootState* RobotState::_internal_add_foot_state() {
  return _impl_.foot_state_.Add();
}
inline ::bosdyn::api::FootState* RobotState::add_foot_state() {
  ::bosdyn::api::FootState* _add = _internal_add_foot_state();
  // @@protoc_insertion_point(field_add:bosdyn.api.RobotState.foot_state)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::FootState >&
RobotState::foot_state() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RobotState.foot_state)
  return _impl_.foot_state_;
}

// .bosdyn.api.ManipulatorState manipulator_state = 11;
inline bool RobotState::_internal_has_manipulator_state() const {
  return this != internal_default_instance() && _impl_.manipulator_state_ != nullptr;
}
inline bool RobotState::has_manipulator_state() const {
  return _internal_has_manipulator_state();
}
inline void RobotState::clear_manipulator_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.manipulator_state_ != nullptr) {
    delete _impl_.manipulator_state_;
  }
  _impl_.manipulator_state_ = nullptr;
}
inline const ::bosdyn::api::ManipulatorState& RobotState::_internal_manipulator_state() const {
  const ::bosdyn::api::ManipulatorState* p = _impl_.manipulator_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ManipulatorState&>(
      ::bosdyn::api::_ManipulatorState_default_instance_);
}
inline const ::bosdyn::api::ManipulatorState& RobotState::manipulator_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.manipulator_state)
  return _internal_manipulator_state();
}
inline void RobotState::unsafe_arena_set_allocated_manipulator_state(
    ::bosdyn::api::ManipulatorState* manipulator_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.manipulator_state_);
  }
  _impl_.manipulator_state_ = manipulator_state;
  if (manipulator_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotState.manipulator_state)
}
inline ::bosdyn::api::ManipulatorState* RobotState::release_manipulator_state() {
  
  ::bosdyn::api::ManipulatorState* temp = _impl_.manipulator_state_;
  _impl_.manipulator_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ManipulatorState* RobotState::unsafe_arena_release_manipulator_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotState.manipulator_state)
  
  ::bosdyn::api::ManipulatorState* temp = _impl_.manipulator_state_;
  _impl_.manipulator_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ManipulatorState* RobotState::_internal_mutable_manipulator_state() {
  
  if (_impl_.manipulator_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ManipulatorState>(GetArenaForAllocation());
    _impl_.manipulator_state_ = p;
  }
  return _impl_.manipulator_state_;
}
inline ::bosdyn::api::ManipulatorState* RobotState::mutable_manipulator_state() {
  ::bosdyn::api::ManipulatorState* _msg = _internal_mutable_manipulator_state();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.manipulator_state)
  return _msg;
}
inline void RobotState::set_allocated_manipulator_state(::bosdyn::api::ManipulatorState* manipulator_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.manipulator_state_;
  }
  if (manipulator_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(manipulator_state);
    if (message_arena != submessage_arena) {
      manipulator_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, manipulator_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.manipulator_state_ = manipulator_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotState.manipulator_state)
}

// .bosdyn.api.ServiceFaultState service_fault_state = 10;
inline bool RobotState::_internal_has_service_fault_state() const {
  return this != internal_default_instance() && _impl_.service_fault_state_ != nullptr;
}
inline bool RobotState::has_service_fault_state() const {
  return _internal_has_service_fault_state();
}
inline void RobotState::clear_service_fault_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.service_fault_state_ != nullptr) {
    delete _impl_.service_fault_state_;
  }
  _impl_.service_fault_state_ = nullptr;
}
inline const ::bosdyn::api::ServiceFaultState& RobotState::_internal_service_fault_state() const {
  const ::bosdyn::api::ServiceFaultState* p = _impl_.service_fault_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ServiceFaultState&>(
      ::bosdyn::api::_ServiceFaultState_default_instance_);
}
inline const ::bosdyn::api::ServiceFaultState& RobotState::service_fault_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.service_fault_state)
  return _internal_service_fault_state();
}
inline void RobotState::unsafe_arena_set_allocated_service_fault_state(
    ::bosdyn::api::ServiceFaultState* service_fault_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_fault_state_);
  }
  _impl_.service_fault_state_ = service_fault_state;
  if (service_fault_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotState.service_fault_state)
}
inline ::bosdyn::api::ServiceFaultState* RobotState::release_service_fault_state() {
  
  ::bosdyn::api::ServiceFaultState* temp = _impl_.service_fault_state_;
  _impl_.service_fault_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ServiceFaultState* RobotState::unsafe_arena_release_service_fault_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotState.service_fault_state)
  
  ::bosdyn::api::ServiceFaultState* temp = _impl_.service_fault_state_;
  _impl_.service_fault_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ServiceFaultState* RobotState::_internal_mutable_service_fault_state() {
  
  if (_impl_.service_fault_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ServiceFaultState>(GetArenaForAllocation());
    _impl_.service_fault_state_ = p;
  }
  return _impl_.service_fault_state_;
}
inline ::bosdyn::api::ServiceFaultState* RobotState::mutable_service_fault_state() {
  ::bosdyn::api::ServiceFaultState* _msg = _internal_mutable_service_fault_state();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.service_fault_state)
  return _msg;
}
inline void RobotState::set_allocated_service_fault_state(::bosdyn::api::ServiceFaultState* service_fault_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.service_fault_state_;
  }
  if (service_fault_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(service_fault_state);
    if (message_arena != submessage_arena) {
      service_fault_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_fault_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.service_fault_state_ = service_fault_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotState.service_fault_state)
}

// .bosdyn.api.TerrainState terrain_state = 12;
inline bool RobotState::_internal_has_terrain_state() const {
  return this != internal_default_instance() && _impl_.terrain_state_ != nullptr;
}
inline bool RobotState::has_terrain_state() const {
  return _internal_has_terrain_state();
}
inline void RobotState::clear_terrain_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.terrain_state_ != nullptr) {
    delete _impl_.terrain_state_;
  }
  _impl_.terrain_state_ = nullptr;
}
inline const ::bosdyn::api::TerrainState& RobotState::_internal_terrain_state() const {
  const ::bosdyn::api::TerrainState* p = _impl_.terrain_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::TerrainState&>(
      ::bosdyn::api::_TerrainState_default_instance_);
}
inline const ::bosdyn::api::TerrainState& RobotState::terrain_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.terrain_state)
  return _internal_terrain_state();
}
inline void RobotState::unsafe_arena_set_allocated_terrain_state(
    ::bosdyn::api::TerrainState* terrain_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.terrain_state_);
  }
  _impl_.terrain_state_ = terrain_state;
  if (terrain_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotState.terrain_state)
}
inline ::bosdyn::api::TerrainState* RobotState::release_terrain_state() {
  
  ::bosdyn::api::TerrainState* temp = _impl_.terrain_state_;
  _impl_.terrain_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::TerrainState* RobotState::unsafe_arena_release_terrain_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotState.terrain_state)
  
  ::bosdyn::api::TerrainState* temp = _impl_.terrain_state_;
  _impl_.terrain_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::TerrainState* RobotState::_internal_mutable_terrain_state() {
  
  if (_impl_.terrain_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::TerrainState>(GetArenaForAllocation());
    _impl_.terrain_state_ = p;
  }
  return _impl_.terrain_state_;
}
inline ::bosdyn::api::TerrainState* RobotState::mutable_terrain_state() {
  ::bosdyn::api::TerrainState* _msg = _internal_mutable_terrain_state();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.terrain_state)
  return _msg;
}
inline void RobotState::set_allocated_terrain_state(::bosdyn::api::TerrainState* terrain_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.terrain_state_;
  }
  if (terrain_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(terrain_state);
    if (message_arena != submessage_arena) {
      terrain_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terrain_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.terrain_state_ = terrain_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotState.terrain_state)
}

// -------------------------------------------------------------------

// PowerState

// .google.protobuf.Timestamp timestamp = 1;
inline bool PowerState::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool PowerState::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PowerState::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PowerState::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerState.timestamp)
  return _internal_timestamp();
}
inline void PowerState::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PowerState.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PowerState::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PowerState::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PowerState.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PowerState::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PowerState::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PowerState.timestamp)
  return _msg;
}
inline void PowerState::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PowerState.timestamp)
}

// .bosdyn.api.PowerState.MotorPowerState motor_power_state = 2;
inline void PowerState::clear_motor_power_state() {
  _impl_.motor_power_state_ = 0;
}
inline ::bosdyn::api::PowerState_MotorPowerState PowerState::_internal_motor_power_state() const {
  return static_cast< ::bosdyn::api::PowerState_MotorPowerState >(_impl_.motor_power_state_);
}
inline ::bosdyn::api::PowerState_MotorPowerState PowerState::motor_power_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerState.motor_power_state)
  return _internal_motor_power_state();
}
inline void PowerState::_internal_set_motor_power_state(::bosdyn::api::PowerState_MotorPowerState value) {
  
  _impl_.motor_power_state_ = value;
}
inline void PowerState::set_motor_power_state(::bosdyn::api::PowerState_MotorPowerState value) {
  _internal_set_motor_power_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PowerState.motor_power_state)
}

// .bosdyn.api.PowerState.ShorePowerState shore_power_state = 3;
inline void PowerState::clear_shore_power_state() {
  _impl_.shore_power_state_ = 0;
}
inline ::bosdyn::api::PowerState_ShorePowerState PowerState::_internal_shore_power_state() const {
  return static_cast< ::bosdyn::api::PowerState_ShorePowerState >(_impl_.shore_power_state_);
}
inline ::bosdyn::api::PowerState_ShorePowerState PowerState::shore_power_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerState.shore_power_state)
  return _internal_shore_power_state();
}
inline void PowerState::_internal_set_shore_power_state(::bosdyn::api::PowerState_ShorePowerState value) {
  
  _impl_.shore_power_state_ = value;
}
inline void PowerState::set_shore_power_state(::bosdyn::api::PowerState_ShorePowerState value) {
  _internal_set_shore_power_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PowerState.shore_power_state)
}

// .bosdyn.api.PowerState.RobotPowerState robot_power_state = 6;
inline void PowerState::clear_robot_power_state() {
  _impl_.robot_power_state_ = 0;
}
inline ::bosdyn::api::PowerState_RobotPowerState PowerState::_internal_robot_power_state() const {
  return static_cast< ::bosdyn::api::PowerState_RobotPowerState >(_impl_.robot_power_state_);
}
inline ::bosdyn::api::PowerState_RobotPowerState PowerState::robot_power_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerState.robot_power_state)
  return _internal_robot_power_state();
}
inline void PowerState::_internal_set_robot_power_state(::bosdyn::api::PowerState_RobotPowerState value) {
  
  _impl_.robot_power_state_ = value;
}
inline void PowerState::set_robot_power_state(::bosdyn::api::PowerState_RobotPowerState value) {
  _internal_set_robot_power_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PowerState.robot_power_state)
}

// .bosdyn.api.PowerState.PayloadPortsPowerState payload_ports_power_state = 7;
inline void PowerState::clear_payload_ports_power_state() {
  _impl_.payload_ports_power_state_ = 0;
}
inline ::bosdyn::api::PowerState_PayloadPortsPowerState PowerState::_internal_payload_ports_power_state() const {
  return static_cast< ::bosdyn::api::PowerState_PayloadPortsPowerState >(_impl_.payload_ports_power_state_);
}
inline ::bosdyn::api::PowerState_PayloadPortsPowerState PowerState::payload_ports_power_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerState.payload_ports_power_state)
  return _internal_payload_ports_power_state();
}
inline void PowerState::_internal_set_payload_ports_power_state(::bosdyn::api::PowerState_PayloadPortsPowerState value) {
  
  _impl_.payload_ports_power_state_ = value;
}
inline void PowerState::set_payload_ports_power_state(::bosdyn::api::PowerState_PayloadPortsPowerState value) {
  _internal_set_payload_ports_power_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PowerState.payload_ports_power_state)
}

// .bosdyn.api.PowerState.WifiRadioPowerState wifi_radio_power_state = 9;
inline void PowerState::clear_wifi_radio_power_state() {
  _impl_.wifi_radio_power_state_ = 0;
}
inline ::bosdyn::api::PowerState_WifiRadioPowerState PowerState::_internal_wifi_radio_power_state() const {
  return static_cast< ::bosdyn::api::PowerState_WifiRadioPowerState >(_impl_.wifi_radio_power_state_);
}
inline ::bosdyn::api::PowerState_WifiRadioPowerState PowerState::wifi_radio_power_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerState.wifi_radio_power_state)
  return _internal_wifi_radio_power_state();
}
inline void PowerState::_internal_set_wifi_radio_power_state(::bosdyn::api::PowerState_WifiRadioPowerState value) {
  
  _impl_.wifi_radio_power_state_ = value;
}
inline void PowerState::set_wifi_radio_power_state(::bosdyn::api::PowerState_WifiRadioPowerState value) {
  _internal_set_wifi_radio_power_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PowerState.wifi_radio_power_state)
}

// .google.protobuf.DoubleValue locomotion_charge_percentage = 4;
inline bool PowerState::_internal_has_locomotion_charge_percentage() const {
  return this != internal_default_instance() && _impl_.locomotion_charge_percentage_ != nullptr;
}
inline bool PowerState::has_locomotion_charge_percentage() const {
  return _internal_has_locomotion_charge_percentage();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& PowerState::_internal_locomotion_charge_percentage() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.locomotion_charge_percentage_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& PowerState::locomotion_charge_percentage() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerState.locomotion_charge_percentage)
  return _internal_locomotion_charge_percentage();
}
inline void PowerState::unsafe_arena_set_allocated_locomotion_charge_percentage(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* locomotion_charge_percentage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.locomotion_charge_percentage_);
  }
  _impl_.locomotion_charge_percentage_ = locomotion_charge_percentage;
  if (locomotion_charge_percentage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PowerState.locomotion_charge_percentage)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* PowerState::release_locomotion_charge_percentage() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.locomotion_charge_percentage_;
  _impl_.locomotion_charge_percentage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* PowerState::unsafe_arena_release_locomotion_charge_percentage() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PowerState.locomotion_charge_percentage)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.locomotion_charge_percentage_;
  _impl_.locomotion_charge_percentage_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* PowerState::_internal_mutable_locomotion_charge_percentage() {
  
  if (_impl_.locomotion_charge_percentage_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.locomotion_charge_percentage_ = p;
  }
  return _impl_.locomotion_charge_percentage_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* PowerState::mutable_locomotion_charge_percentage() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_locomotion_charge_percentage();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PowerState.locomotion_charge_percentage)
  return _msg;
}
inline void PowerState::set_allocated_locomotion_charge_percentage(::PROTOBUF_NAMESPACE_ID::DoubleValue* locomotion_charge_percentage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.locomotion_charge_percentage_);
  }
  if (locomotion_charge_percentage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(locomotion_charge_percentage));
    if (message_arena != submessage_arena) {
      locomotion_charge_percentage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, locomotion_charge_percentage, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.locomotion_charge_percentage_ = locomotion_charge_percentage;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PowerState.locomotion_charge_percentage)
}

// .google.protobuf.Duration locomotion_estimated_runtime = 5;
inline bool PowerState::_internal_has_locomotion_estimated_runtime() const {
  return this != internal_default_instance() && _impl_.locomotion_estimated_runtime_ != nullptr;
}
inline bool PowerState::has_locomotion_estimated_runtime() const {
  return _internal_has_locomotion_estimated_runtime();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PowerState::_internal_locomotion_estimated_runtime() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.locomotion_estimated_runtime_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& PowerState::locomotion_estimated_runtime() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerState.locomotion_estimated_runtime)
  return _internal_locomotion_estimated_runtime();
}
inline void PowerState::unsafe_arena_set_allocated_locomotion_estimated_runtime(
    ::PROTOBUF_NAMESPACE_ID::Duration* locomotion_estimated_runtime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.locomotion_estimated_runtime_);
  }
  _impl_.locomotion_estimated_runtime_ = locomotion_estimated_runtime;
  if (locomotion_estimated_runtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PowerState.locomotion_estimated_runtime)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PowerState::release_locomotion_estimated_runtime() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.locomotion_estimated_runtime_;
  _impl_.locomotion_estimated_runtime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PowerState::unsafe_arena_release_locomotion_estimated_runtime() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PowerState.locomotion_estimated_runtime)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.locomotion_estimated_runtime_;
  _impl_.locomotion_estimated_runtime_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PowerState::_internal_mutable_locomotion_estimated_runtime() {
  
  if (_impl_.locomotion_estimated_runtime_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.locomotion_estimated_runtime_ = p;
  }
  return _impl_.locomotion_estimated_runtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* PowerState::mutable_locomotion_estimated_runtime() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_locomotion_estimated_runtime();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PowerState.locomotion_estimated_runtime)
  return _msg;
}
inline void PowerState::set_allocated_locomotion_estimated_runtime(::PROTOBUF_NAMESPACE_ID::Duration* locomotion_estimated_runtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.locomotion_estimated_runtime_);
  }
  if (locomotion_estimated_runtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(locomotion_estimated_runtime));
    if (message_arena != submessage_arena) {
      locomotion_estimated_runtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, locomotion_estimated_runtime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.locomotion_estimated_runtime_ = locomotion_estimated_runtime;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PowerState.locomotion_estimated_runtime)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SystemFaultState

// repeated .bosdyn.api.SystemFault faults = 1;
inline int SystemFaultState::_internal_faults_size() const {
  return _impl_.faults_.size();
}
inline int SystemFaultState::faults_size() const {
  return _internal_faults_size();
}
inline void SystemFaultState::clear_faults() {
  _impl_.faults_.Clear();
}
inline ::bosdyn::api::SystemFault* SystemFaultState::mutable_faults(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SystemFaultState.faults)
  return _impl_.faults_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >*
SystemFaultState::mutable_faults() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.SystemFaultState.faults)
  return &_impl_.faults_;
}
inline const ::bosdyn::api::SystemFault& SystemFaultState::_internal_faults(int index) const {
  return _impl_.faults_.Get(index);
}
inline const ::bosdyn::api::SystemFault& SystemFaultState::faults(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFaultState.faults)
  return _internal_faults(index);
}
inline ::bosdyn::api::SystemFault* SystemFaultState::_internal_add_faults() {
  return _impl_.faults_.Add();
}
inline ::bosdyn::api::SystemFault* SystemFaultState::add_faults() {
  ::bosdyn::api::SystemFault* _add = _internal_add_faults();
  // @@protoc_insertion_point(field_add:bosdyn.api.SystemFaultState.faults)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >&
SystemFaultState::faults() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.SystemFaultState.faults)
  return _impl_.faults_;
}

// repeated .bosdyn.api.SystemFault historical_faults = 2;
inline int SystemFaultState::_internal_historical_faults_size() const {
  return _impl_.historical_faults_.size();
}
inline int SystemFaultState::historical_faults_size() const {
  return _internal_historical_faults_size();
}
inline void SystemFaultState::clear_historical_faults() {
  _impl_.historical_faults_.Clear();
}
inline ::bosdyn::api::SystemFault* SystemFaultState::mutable_historical_faults(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SystemFaultState.historical_faults)
  return _impl_.historical_faults_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >*
SystemFaultState::mutable_historical_faults() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.SystemFaultState.historical_faults)
  return &_impl_.historical_faults_;
}
inline const ::bosdyn::api::SystemFault& SystemFaultState::_internal_historical_faults(int index) const {
  return _impl_.historical_faults_.Get(index);
}
inline const ::bosdyn::api::SystemFault& SystemFaultState::historical_faults(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFaultState.historical_faults)
  return _internal_historical_faults(index);
}
inline ::bosdyn::api::SystemFault* SystemFaultState::_internal_add_historical_faults() {
  return _impl_.historical_faults_.Add();
}
inline ::bosdyn::api::SystemFault* SystemFaultState::add_historical_faults() {
  ::bosdyn::api::SystemFault* _add = _internal_add_historical_faults();
  // @@protoc_insertion_point(field_add:bosdyn.api.SystemFaultState.historical_faults)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >&
SystemFaultState::historical_faults() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.SystemFaultState.historical_faults)
  return _impl_.historical_faults_;
}

// map<string, .bosdyn.api.SystemFault.Severity> aggregated = 3;
inline int SystemFaultState::_internal_aggregated_size() const {
  return _impl_.aggregated_.size();
}
inline int SystemFaultState::aggregated_size() const {
  return _internal_aggregated_size();
}
inline void SystemFaultState::clear_aggregated() {
  _impl_.aggregated_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::SystemFault_Severity >&
SystemFaultState::_internal_aggregated() const {
  return _impl_.aggregated_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::SystemFault_Severity >&
SystemFaultState::aggregated() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.SystemFaultState.aggregated)
  return _internal_aggregated();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::SystemFault_Severity >*
SystemFaultState::_internal_mutable_aggregated() {
  return _impl_.aggregated_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::SystemFault_Severity >*
SystemFaultState::mutable_aggregated() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.SystemFaultState.aggregated)
  return _internal_mutable_aggregated();
}

// -------------------------------------------------------------------

// SystemFault

// string name = 1;
inline void SystemFault::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SystemFault::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFault.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemFault::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.SystemFault.name)
}
inline std::string* SystemFault::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SystemFault.name)
  return _s;
}
inline const std::string& SystemFault::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SystemFault::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemFault::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemFault::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SystemFault.name)
  return _impl_.name_.Release();
}
inline void SystemFault::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SystemFault.name)
}

// .google.protobuf.Timestamp onset_timestamp = 2;
inline bool SystemFault::_internal_has_onset_timestamp() const {
  return this != internal_default_instance() && _impl_.onset_timestamp_ != nullptr;
}
inline bool SystemFault::has_onset_timestamp() const {
  return _internal_has_onset_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SystemFault::_internal_onset_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.onset_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SystemFault::onset_timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFault.onset_timestamp)
  return _internal_onset_timestamp();
}
inline void SystemFault::unsafe_arena_set_allocated_onset_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.onset_timestamp_);
  }
  _impl_.onset_timestamp_ = onset_timestamp;
  if (onset_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SystemFault.onset_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemFault::release_onset_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.onset_timestamp_;
  _impl_.onset_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemFault::unsafe_arena_release_onset_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SystemFault.onset_timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.onset_timestamp_;
  _impl_.onset_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemFault::_internal_mutable_onset_timestamp() {
  
  if (_impl_.onset_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.onset_timestamp_ = p;
  }
  return _impl_.onset_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemFault::mutable_onset_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_onset_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SystemFault.onset_timestamp)
  return _msg;
}
inline void SystemFault::set_allocated_onset_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.onset_timestamp_);
  }
  if (onset_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(onset_timestamp));
    if (message_arena != submessage_arena) {
      onset_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, onset_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.onset_timestamp_ = onset_timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SystemFault.onset_timestamp)
}

// .google.protobuf.Duration duration = 3;
inline bool SystemFault::_internal_has_duration() const {
  return this != internal_default_instance() && _impl_.duration_ != nullptr;
}
inline bool SystemFault::has_duration() const {
  return _internal_has_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& SystemFault::_internal_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& SystemFault::duration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFault.duration)
  return _internal_duration();
}
inline void SystemFault::unsafe_arena_set_allocated_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_);
  }
  _impl_.duration_ = duration;
  if (duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SystemFault.duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SystemFault::release_duration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SystemFault::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SystemFault.duration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SystemFault::_internal_mutable_duration() {
  
  if (_impl_.duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.duration_ = p;
  }
  return _impl_.duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SystemFault::mutable_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SystemFault.duration)
  return _msg;
}
inline void SystemFault::set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_);
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration));
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SystemFault.duration)
}

// int32 code = 4;
inline void SystemFault::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t SystemFault::_internal_code() const {
  return _impl_.code_;
}
inline int32_t SystemFault::code() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFault.code)
  return _internal_code();
}
inline void SystemFault::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void SystemFault::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SystemFault.code)
}

// uint64 uid = 8;
inline void SystemFault::clear_uid() {
  _impl_.uid_ = uint64_t{0u};
}
inline uint64_t SystemFault::_internal_uid() const {
  return _impl_.uid_;
}
inline uint64_t SystemFault::uid() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFault.uid)
  return _internal_uid();
}
inline void SystemFault::_internal_set_uid(uint64_t value) {
  
  _impl_.uid_ = value;
}
inline void SystemFault::set_uid(uint64_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SystemFault.uid)
}

// string error_message = 5;
inline void SystemFault::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& SystemFault::error_message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFault.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemFault::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.SystemFault.error_message)
}
inline std::string* SystemFault::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SystemFault.error_message)
  return _s;
}
inline const std::string& SystemFault::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void SystemFault::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemFault::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemFault::release_error_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SystemFault.error_message)
  return _impl_.error_message_.Release();
}
inline void SystemFault::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SystemFault.error_message)
}

// repeated string attributes = 6;
inline int SystemFault::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int SystemFault::attributes_size() const {
  return _internal_attributes_size();
}
inline void SystemFault::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline std::string* SystemFault::add_attributes() {
  std::string* _s = _internal_add_attributes();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.SystemFault.attributes)
  return _s;
}
inline const std::string& SystemFault::_internal_attributes(int index) const {
  return _impl_.attributes_.Get(index);
}
inline const std::string& SystemFault::attributes(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFault.attributes)
  return _internal_attributes(index);
}
inline std::string* SystemFault::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SystemFault.attributes)
  return _impl_.attributes_.Mutable(index);
}
inline void SystemFault::set_attributes(int index, const std::string& value) {
  _impl_.attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SystemFault.attributes)
}
inline void SystemFault::set_attributes(int index, std::string&& value) {
  _impl_.attributes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.SystemFault.attributes)
}
inline void SystemFault::set_attributes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.SystemFault.attributes)
}
inline void SystemFault::set_attributes(int index, const char* value, size_t size) {
  _impl_.attributes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.SystemFault.attributes)
}
inline std::string* SystemFault::_internal_add_attributes() {
  return _impl_.attributes_.Add();
}
inline void SystemFault::add_attributes(const std::string& value) {
  _impl_.attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.SystemFault.attributes)
}
inline void SystemFault::add_attributes(std::string&& value) {
  _impl_.attributes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.SystemFault.attributes)
}
inline void SystemFault::add_attributes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.SystemFault.attributes)
}
inline void SystemFault::add_attributes(const char* value, size_t size) {
  _impl_.attributes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.SystemFault.attributes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SystemFault::attributes() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.SystemFault.attributes)
  return _impl_.attributes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SystemFault::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.SystemFault.attributes)
  return &_impl_.attributes_;
}

// .bosdyn.api.SystemFault.Severity severity = 7;
inline void SystemFault::clear_severity() {
  _impl_.severity_ = 0;
}
inline ::bosdyn::api::SystemFault_Severity SystemFault::_internal_severity() const {
  return static_cast< ::bosdyn::api::SystemFault_Severity >(_impl_.severity_);
}
inline ::bosdyn::api::SystemFault_Severity SystemFault::severity() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFault.severity)
  return _internal_severity();
}
inline void SystemFault::_internal_set_severity(::bosdyn::api::SystemFault_Severity value) {
  
  _impl_.severity_ = value;
}
inline void SystemFault::set_severity(::bosdyn::api::SystemFault_Severity value) {
  _internal_set_severity(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SystemFault.severity)
}

// -------------------------------------------------------------------

// EStopState

// .google.protobuf.Timestamp timestamp = 1;
inline bool EStopState::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool EStopState::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EStopState::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EStopState::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EStopState.timestamp)
  return _internal_timestamp();
}
inline void EStopState::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EStopState.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EStopState::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EStopState::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EStopState.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EStopState::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EStopState::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EStopState.timestamp)
  return _msg;
}
inline void EStopState::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EStopState.timestamp)
}

// string name = 2;
inline void EStopState::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& EStopState::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EStopState.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EStopState::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.EStopState.name)
}
inline std::string* EStopState::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EStopState.name)
  return _s;
}
inline const std::string& EStopState::_internal_name() const {
  return _impl_.name_.Get();
}
inline void EStopState::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* EStopState::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* EStopState::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EStopState.name)
  return _impl_.name_.Release();
}
inline void EStopState::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EStopState.name)
}

// .bosdyn.api.EStopState.Type type = 3;
inline void EStopState::clear_type() {
  _impl_.type_ = 0;
}
inline ::bosdyn::api::EStopState_Type EStopState::_internal_type() const {
  return static_cast< ::bosdyn::api::EStopState_Type >(_impl_.type_);
}
inline ::bosdyn::api::EStopState_Type EStopState::type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EStopState.type)
  return _internal_type();
}
inline void EStopState::_internal_set_type(::bosdyn::api::EStopState_Type value) {
  
  _impl_.type_ = value;
}
inline void EStopState::set_type(::bosdyn::api::EStopState_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EStopState.type)
}

// .bosdyn.api.EStopState.State state = 4;
inline void EStopState::clear_state() {
  _impl_.state_ = 0;
}
inline ::bosdyn::api::EStopState_State EStopState::_internal_state() const {
  return static_cast< ::bosdyn::api::EStopState_State >(_impl_.state_);
}
inline ::bosdyn::api::EStopState_State EStopState::state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EStopState.state)
  return _internal_state();
}
inline void EStopState::_internal_set_state(::bosdyn::api::EStopState_State value) {
  
  _impl_.state_ = value;
}
inline void EStopState::set_state(::bosdyn::api::EStopState_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EStopState.state)
}

// string state_description = 5;
inline void EStopState::clear_state_description() {
  _impl_.state_description_.ClearToEmpty();
}
inline const std::string& EStopState::state_description() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EStopState.state_description)
  return _internal_state_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EStopState::set_state_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.EStopState.state_description)
}
inline std::string* EStopState::mutable_state_description() {
  std::string* _s = _internal_mutable_state_description();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EStopState.state_description)
  return _s;
}
inline const std::string& EStopState::_internal_state_description() const {
  return _impl_.state_description_.Get();
}
inline void EStopState::_internal_set_state_description(const std::string& value) {
  
  _impl_.state_description_.Set(value, GetArenaForAllocation());
}
inline std::string* EStopState::_internal_mutable_state_description() {
  
  return _impl_.state_description_.Mutable(GetArenaForAllocation());
}
inline std::string* EStopState::release_state_description() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EStopState.state_description)
  return _impl_.state_description_.Release();
}
inline void EStopState::set_allocated_state_description(std::string* state_description) {
  if (state_description != nullptr) {
    
  } else {
    
  }
  _impl_.state_description_.SetAllocated(state_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_description_.IsDefault()) {
    _impl_.state_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EStopState.state_description)
}

// -------------------------------------------------------------------

// BatteryState

// .google.protobuf.Timestamp timestamp = 1;
inline bool BatteryState::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool BatteryState::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BatteryState::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BatteryState::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryState.timestamp)
  return _internal_timestamp();
}
inline void BatteryState::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.BatteryState.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BatteryState::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BatteryState::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BatteryState.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BatteryState::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BatteryState::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BatteryState.timestamp)
  return _msg;
}
inline void BatteryState::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BatteryState.timestamp)
}

// string identifier = 2;
inline void BatteryState::clear_identifier() {
  _impl_.identifier_.ClearToEmpty();
}
inline const std::string& BatteryState::identifier() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryState.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatteryState::set_identifier(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.BatteryState.identifier)
}
inline std::string* BatteryState::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BatteryState.identifier)
  return _s;
}
inline const std::string& BatteryState::_internal_identifier() const {
  return _impl_.identifier_.Get();
}
inline void BatteryState::_internal_set_identifier(const std::string& value) {
  
  _impl_.identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* BatteryState::_internal_mutable_identifier() {
  
  return _impl_.identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* BatteryState::release_identifier() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BatteryState.identifier)
  return _impl_.identifier_.Release();
}
inline void BatteryState::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    
  } else {
    
  }
  _impl_.identifier_.SetAllocated(identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identifier_.IsDefault()) {
    _impl_.identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BatteryState.identifier)
}

// .google.protobuf.DoubleValue charge_percentage = 3;
inline bool BatteryState::_internal_has_charge_percentage() const {
  return this != internal_default_instance() && _impl_.charge_percentage_ != nullptr;
}
inline bool BatteryState::has_charge_percentage() const {
  return _internal_has_charge_percentage();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& BatteryState::_internal_charge_percentage() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.charge_percentage_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& BatteryState::charge_percentage() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryState.charge_percentage)
  return _internal_charge_percentage();
}
inline void BatteryState::unsafe_arena_set_allocated_charge_percentage(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* charge_percentage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.charge_percentage_);
  }
  _impl_.charge_percentage_ = charge_percentage;
  if (charge_percentage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.BatteryState.charge_percentage)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::release_charge_percentage() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.charge_percentage_;
  _impl_.charge_percentage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::unsafe_arena_release_charge_percentage() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BatteryState.charge_percentage)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.charge_percentage_;
  _impl_.charge_percentage_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::_internal_mutable_charge_percentage() {
  
  if (_impl_.charge_percentage_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.charge_percentage_ = p;
  }
  return _impl_.charge_percentage_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::mutable_charge_percentage() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_charge_percentage();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BatteryState.charge_percentage)
  return _msg;
}
inline void BatteryState::set_allocated_charge_percentage(::PROTOBUF_NAMESPACE_ID::DoubleValue* charge_percentage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.charge_percentage_);
  }
  if (charge_percentage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(charge_percentage));
    if (message_arena != submessage_arena) {
      charge_percentage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, charge_percentage, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.charge_percentage_ = charge_percentage;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BatteryState.charge_percentage)
}

// .google.protobuf.Duration estimated_runtime = 4;
inline bool BatteryState::_internal_has_estimated_runtime() const {
  return this != internal_default_instance() && _impl_.estimated_runtime_ != nullptr;
}
inline bool BatteryState::has_estimated_runtime() const {
  return _internal_has_estimated_runtime();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& BatteryState::_internal_estimated_runtime() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.estimated_runtime_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& BatteryState::estimated_runtime() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryState.estimated_runtime)
  return _internal_estimated_runtime();
}
inline void BatteryState::unsafe_arena_set_allocated_estimated_runtime(
    ::PROTOBUF_NAMESPACE_ID::Duration* estimated_runtime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.estimated_runtime_);
  }
  _impl_.estimated_runtime_ = estimated_runtime;
  if (estimated_runtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.BatteryState.estimated_runtime)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* BatteryState::release_estimated_runtime() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.estimated_runtime_;
  _impl_.estimated_runtime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* BatteryState::unsafe_arena_release_estimated_runtime() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BatteryState.estimated_runtime)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.estimated_runtime_;
  _impl_.estimated_runtime_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* BatteryState::_internal_mutable_estimated_runtime() {
  
  if (_impl_.estimated_runtime_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.estimated_runtime_ = p;
  }
  return _impl_.estimated_runtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* BatteryState::mutable_estimated_runtime() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_estimated_runtime();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BatteryState.estimated_runtime)
  return _msg;
}
inline void BatteryState::set_allocated_estimated_runtime(::PROTOBUF_NAMESPACE_ID::Duration* estimated_runtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.estimated_runtime_);
  }
  if (estimated_runtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(estimated_runtime));
    if (message_arena != submessage_arena) {
      estimated_runtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, estimated_runtime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.estimated_runtime_ = estimated_runtime;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BatteryState.estimated_runtime)
}

// .google.protobuf.DoubleValue current = 5;
inline bool BatteryState::_internal_has_current() const {
  return this != internal_default_instance() && _impl_.current_ != nullptr;
}
inline bool BatteryState::has_current() const {
  return _internal_has_current();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& BatteryState::_internal_current() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.current_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& BatteryState::current() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryState.current)
  return _internal_current();
}
inline void BatteryState::unsafe_arena_set_allocated_current(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* current) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.current_);
  }
  _impl_.current_ = current;
  if (current) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.BatteryState.current)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::release_current() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.current_;
  _impl_.current_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::unsafe_arena_release_current() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BatteryState.current)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.current_;
  _impl_.current_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::_internal_mutable_current() {
  
  if (_impl_.current_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.current_ = p;
  }
  return _impl_.current_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::mutable_current() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_current();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BatteryState.current)
  return _msg;
}
inline void BatteryState::set_allocated_current(::PROTOBUF_NAMESPACE_ID::DoubleValue* current) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.current_);
  }
  if (current) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(current));
    if (message_arena != submessage_arena) {
      current = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, current, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.current_ = current;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BatteryState.current)
}

// .google.protobuf.DoubleValue voltage = 6;
inline bool BatteryState::_internal_has_voltage() const {
  return this != internal_default_instance() && _impl_.voltage_ != nullptr;
}
inline bool BatteryState::has_voltage() const {
  return _internal_has_voltage();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& BatteryState::_internal_voltage() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.voltage_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& BatteryState::voltage() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryState.voltage)
  return _internal_voltage();
}
inline void BatteryState::unsafe_arena_set_allocated_voltage(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* voltage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltage_);
  }
  _impl_.voltage_ = voltage;
  if (voltage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.BatteryState.voltage)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::release_voltage() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.voltage_;
  _impl_.voltage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::unsafe_arena_release_voltage() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BatteryState.voltage)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.voltage_;
  _impl_.voltage_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::_internal_mutable_voltage() {
  
  if (_impl_.voltage_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.voltage_ = p;
  }
  return _impl_.voltage_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::mutable_voltage() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_voltage();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BatteryState.voltage)
  return _msg;
}
inline void BatteryState::set_allocated_voltage(::PROTOBUF_NAMESPACE_ID::DoubleValue* voltage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltage_);
  }
  if (voltage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltage));
    if (message_arena != submessage_arena) {
      voltage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltage, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.voltage_ = voltage;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BatteryState.voltage)
}

// repeated double temperatures = 7;
inline int BatteryState::_internal_temperatures_size() const {
  return _impl_.temperatures_.size();
}
inline int BatteryState::temperatures_size() const {
  return _internal_temperatures_size();
}
inline void BatteryState::clear_temperatures() {
  _impl_.temperatures_.Clear();
}
inline double BatteryState::_internal_temperatures(int index) const {
  return _impl_.temperatures_.Get(index);
}
inline double BatteryState::temperatures(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryState.temperatures)
  return _internal_temperatures(index);
}
inline void BatteryState::set_temperatures(int index, double value) {
  _impl_.temperatures_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.BatteryState.temperatures)
}
inline void BatteryState::_internal_add_temperatures(double value) {
  _impl_.temperatures_.Add(value);
}
inline void BatteryState::add_temperatures(double value) {
  _internal_add_temperatures(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.BatteryState.temperatures)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
BatteryState::_internal_temperatures() const {
  return _impl_.temperatures_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
BatteryState::temperatures() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.BatteryState.temperatures)
  return _internal_temperatures();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
BatteryState::_internal_mutable_temperatures() {
  return &_impl_.temperatures_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
BatteryState::mutable_temperatures() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.BatteryState.temperatures)
  return _internal_mutable_temperatures();
}

// .bosdyn.api.BatteryState.Status status = 8;
inline void BatteryState::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::BatteryState_Status BatteryState::_internal_status() const {
  return static_cast< ::bosdyn::api::BatteryState_Status >(_impl_.status_);
}
inline ::bosdyn::api::BatteryState_Status BatteryState::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryState.status)
  return _internal_status();
}
inline void BatteryState::_internal_set_status(::bosdyn::api::BatteryState_Status value) {
  
  _impl_.status_ = value;
}
inline void BatteryState::set_status(::bosdyn::api::BatteryState_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.BatteryState.status)
}

// -------------------------------------------------------------------

// KinematicState

// repeated .bosdyn.api.JointState joint_states = 2;
inline int KinematicState::_internal_joint_states_size() const {
  return _impl_.joint_states_.size();
}
inline int KinematicState::joint_states_size() const {
  return _internal_joint_states_size();
}
inline void KinematicState::clear_joint_states() {
  _impl_.joint_states_.Clear();
}
inline ::bosdyn::api::JointState* KinematicState::mutable_joint_states(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.KinematicState.joint_states)
  return _impl_.joint_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointState >*
KinematicState::mutable_joint_states() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.KinematicState.joint_states)
  return &_impl_.joint_states_;
}
inline const ::bosdyn::api::JointState& KinematicState::_internal_joint_states(int index) const {
  return _impl_.joint_states_.Get(index);
}
inline const ::bosdyn::api::JointState& KinematicState::joint_states(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.KinematicState.joint_states)
  return _internal_joint_states(index);
}
inline ::bosdyn::api::JointState* KinematicState::_internal_add_joint_states() {
  return _impl_.joint_states_.Add();
}
inline ::bosdyn::api::JointState* KinematicState::add_joint_states() {
  ::bosdyn::api::JointState* _add = _internal_add_joint_states();
  // @@protoc_insertion_point(field_add:bosdyn.api.KinematicState.joint_states)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointState >&
KinematicState::joint_states() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.KinematicState.joint_states)
  return _impl_.joint_states_;
}

// .google.protobuf.Timestamp acquisition_timestamp = 30;
inline bool KinematicState::_internal_has_acquisition_timestamp() const {
  return this != internal_default_instance() && _impl_.acquisition_timestamp_ != nullptr;
}
inline bool KinematicState::has_acquisition_timestamp() const {
  return _internal_has_acquisition_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& KinematicState::_internal_acquisition_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.acquisition_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& KinematicState::acquisition_timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.KinematicState.acquisition_timestamp)
  return _internal_acquisition_timestamp();
}
inline void KinematicState::unsafe_arena_set_allocated_acquisition_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acquisition_timestamp_);
  }
  _impl_.acquisition_timestamp_ = acquisition_timestamp;
  if (acquisition_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.KinematicState.acquisition_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* KinematicState::release_acquisition_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.acquisition_timestamp_;
  _impl_.acquisition_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* KinematicState::unsafe_arena_release_acquisition_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.KinematicState.acquisition_timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.acquisition_timestamp_;
  _impl_.acquisition_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* KinematicState::_internal_mutable_acquisition_timestamp() {
  
  if (_impl_.acquisition_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.acquisition_timestamp_ = p;
  }
  return _impl_.acquisition_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* KinematicState::mutable_acquisition_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_acquisition_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.KinematicState.acquisition_timestamp)
  return _msg;
}
inline void KinematicState::set_allocated_acquisition_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acquisition_timestamp_);
  }
  if (acquisition_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acquisition_timestamp));
    if (message_arena != submessage_arena) {
      acquisition_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acquisition_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.acquisition_timestamp_ = acquisition_timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.KinematicState.acquisition_timestamp)
}

// .bosdyn.api.FrameTreeSnapshot transforms_snapshot = 31;
inline bool KinematicState::_internal_has_transforms_snapshot() const {
  return this != internal_default_instance() && _impl_.transforms_snapshot_ != nullptr;
}
inline bool KinematicState::has_transforms_snapshot() const {
  return _internal_has_transforms_snapshot();
}
inline const ::bosdyn::api::FrameTreeSnapshot& KinematicState::_internal_transforms_snapshot() const {
  const ::bosdyn::api::FrameTreeSnapshot* p = _impl_.transforms_snapshot_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::FrameTreeSnapshot&>(
      ::bosdyn::api::_FrameTreeSnapshot_default_instance_);
}
inline const ::bosdyn::api::FrameTreeSnapshot& KinematicState::transforms_snapshot() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.KinematicState.transforms_snapshot)
  return _internal_transforms_snapshot();
}
inline void KinematicState::unsafe_arena_set_allocated_transforms_snapshot(
    ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transforms_snapshot_);
  }
  _impl_.transforms_snapshot_ = transforms_snapshot;
  if (transforms_snapshot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.KinematicState.transforms_snapshot)
}
inline ::bosdyn::api::FrameTreeSnapshot* KinematicState::release_transforms_snapshot() {
  
  ::bosdyn::api::FrameTreeSnapshot* temp = _impl_.transforms_snapshot_;
  _impl_.transforms_snapshot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::FrameTreeSnapshot* KinematicState::unsafe_arena_release_transforms_snapshot() {
  // @@protoc_insertion_point(field_release:bosdyn.api.KinematicState.transforms_snapshot)
  
  ::bosdyn::api::FrameTreeSnapshot* temp = _impl_.transforms_snapshot_;
  _impl_.transforms_snapshot_ = nullptr;
  return temp;
}
inline ::bosdyn::api::FrameTreeSnapshot* KinematicState::_internal_mutable_transforms_snapshot() {
  
  if (_impl_.transforms_snapshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::FrameTreeSnapshot>(GetArenaForAllocation());
    _impl_.transforms_snapshot_ = p;
  }
  return _impl_.transforms_snapshot_;
}
inline ::bosdyn::api::FrameTreeSnapshot* KinematicState::mutable_transforms_snapshot() {
  ::bosdyn::api::FrameTreeSnapshot* _msg = _internal_mutable_transforms_snapshot();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.KinematicState.transforms_snapshot)
  return _msg;
}
inline void KinematicState::set_allocated_transforms_snapshot(::bosdyn::api::FrameTreeSnapshot* transforms_snapshot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transforms_snapshot_);
  }
  if (transforms_snapshot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transforms_snapshot));
    if (message_arena != submessage_arena) {
      transforms_snapshot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transforms_snapshot, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transforms_snapshot_ = transforms_snapshot;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.KinematicState.transforms_snapshot)
}

// .bosdyn.api.SE3Velocity velocity_of_body_in_vision = 8;
inline bool KinematicState::_internal_has_velocity_of_body_in_vision() const {
  return this != internal_default_instance() && _impl_.velocity_of_body_in_vision_ != nullptr;
}
inline bool KinematicState::has_velocity_of_body_in_vision() const {
  return _internal_has_velocity_of_body_in_vision();
}
inline const ::bosdyn::api::SE3Velocity& KinematicState::_internal_velocity_of_body_in_vision() const {
  const ::bosdyn::api::SE3Velocity* p = _impl_.velocity_of_body_in_vision_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Velocity&>(
      ::bosdyn::api::_SE3Velocity_default_instance_);
}
inline const ::bosdyn::api::SE3Velocity& KinematicState::velocity_of_body_in_vision() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.KinematicState.velocity_of_body_in_vision)
  return _internal_velocity_of_body_in_vision();
}
inline void KinematicState::unsafe_arena_set_allocated_velocity_of_body_in_vision(
    ::bosdyn::api::SE3Velocity* velocity_of_body_in_vision) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_of_body_in_vision_);
  }
  _impl_.velocity_of_body_in_vision_ = velocity_of_body_in_vision;
  if (velocity_of_body_in_vision) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.KinematicState.velocity_of_body_in_vision)
}
inline ::bosdyn::api::SE3Velocity* KinematicState::release_velocity_of_body_in_vision() {
  
  ::bosdyn::api::SE3Velocity* temp = _impl_.velocity_of_body_in_vision_;
  _impl_.velocity_of_body_in_vision_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Velocity* KinematicState::unsafe_arena_release_velocity_of_body_in_vision() {
  // @@protoc_insertion_point(field_release:bosdyn.api.KinematicState.velocity_of_body_in_vision)
  
  ::bosdyn::api::SE3Velocity* temp = _impl_.velocity_of_body_in_vision_;
  _impl_.velocity_of_body_in_vision_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Velocity* KinematicState::_internal_mutable_velocity_of_body_in_vision() {
  
  if (_impl_.velocity_of_body_in_vision_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Velocity>(GetArenaForAllocation());
    _impl_.velocity_of_body_in_vision_ = p;
  }
  return _impl_.velocity_of_body_in_vision_;
}
inline ::bosdyn::api::SE3Velocity* KinematicState::mutable_velocity_of_body_in_vision() {
  ::bosdyn::api::SE3Velocity* _msg = _internal_mutable_velocity_of_body_in_vision();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.KinematicState.velocity_of_body_in_vision)
  return _msg;
}
inline void KinematicState::set_allocated_velocity_of_body_in_vision(::bosdyn::api::SE3Velocity* velocity_of_body_in_vision) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_of_body_in_vision_);
  }
  if (velocity_of_body_in_vision) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_of_body_in_vision));
    if (message_arena != submessage_arena) {
      velocity_of_body_in_vision = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity_of_body_in_vision, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.velocity_of_body_in_vision_ = velocity_of_body_in_vision;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.KinematicState.velocity_of_body_in_vision)
}

// .bosdyn.api.SE3Velocity velocity_of_body_in_odom = 12;
inline bool KinematicState::_internal_has_velocity_of_body_in_odom() const {
  return this != internal_default_instance() && _impl_.velocity_of_body_in_odom_ != nullptr;
}
inline bool KinematicState::has_velocity_of_body_in_odom() const {
  return _internal_has_velocity_of_body_in_odom();
}
inline const ::bosdyn::api::SE3Velocity& KinematicState::_internal_velocity_of_body_in_odom() const {
  const ::bosdyn::api::SE3Velocity* p = _impl_.velocity_of_body_in_odom_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Velocity&>(
      ::bosdyn::api::_SE3Velocity_default_instance_);
}
inline const ::bosdyn::api::SE3Velocity& KinematicState::velocity_of_body_in_odom() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.KinematicState.velocity_of_body_in_odom)
  return _internal_velocity_of_body_in_odom();
}
inline void KinematicState::unsafe_arena_set_allocated_velocity_of_body_in_odom(
    ::bosdyn::api::SE3Velocity* velocity_of_body_in_odom) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_of_body_in_odom_);
  }
  _impl_.velocity_of_body_in_odom_ = velocity_of_body_in_odom;
  if (velocity_of_body_in_odom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.KinematicState.velocity_of_body_in_odom)
}
inline ::bosdyn::api::SE3Velocity* KinematicState::release_velocity_of_body_in_odom() {
  
  ::bosdyn::api::SE3Velocity* temp = _impl_.velocity_of_body_in_odom_;
  _impl_.velocity_of_body_in_odom_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Velocity* KinematicState::unsafe_arena_release_velocity_of_body_in_odom() {
  // @@protoc_insertion_point(field_release:bosdyn.api.KinematicState.velocity_of_body_in_odom)
  
  ::bosdyn::api::SE3Velocity* temp = _impl_.velocity_of_body_in_odom_;
  _impl_.velocity_of_body_in_odom_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Velocity* KinematicState::_internal_mutable_velocity_of_body_in_odom() {
  
  if (_impl_.velocity_of_body_in_odom_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Velocity>(GetArenaForAllocation());
    _impl_.velocity_of_body_in_odom_ = p;
  }
  return _impl_.velocity_of_body_in_odom_;
}
inline ::bosdyn::api::SE3Velocity* KinematicState::mutable_velocity_of_body_in_odom() {
  ::bosdyn::api::SE3Velocity* _msg = _internal_mutable_velocity_of_body_in_odom();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.KinematicState.velocity_of_body_in_odom)
  return _msg;
}
inline void KinematicState::set_allocated_velocity_of_body_in_odom(::bosdyn::api::SE3Velocity* velocity_of_body_in_odom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_of_body_in_odom_);
  }
  if (velocity_of_body_in_odom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_of_body_in_odom));
    if (message_arena != submessage_arena) {
      velocity_of_body_in_odom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity_of_body_in_odom, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.velocity_of_body_in_odom_ = velocity_of_body_in_odom;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.KinematicState.velocity_of_body_in_odom)
}

// -------------------------------------------------------------------

// JointState

// string name = 1;
inline void JointState::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& JointState::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.JointState.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JointState::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.JointState.name)
}
inline std::string* JointState::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.JointState.name)
  return _s;
}
inline const std::string& JointState::_internal_name() const {
  return _impl_.name_.Get();
}
inline void JointState::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* JointState::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* JointState::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.JointState.name)
  return _impl_.name_.Release();
}
inline void JointState::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.JointState.name)
}

// .google.protobuf.DoubleValue position = 2;
inline bool JointState::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool JointState::has_position() const {
  return _internal_has_position();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& JointState::_internal_position() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& JointState::position() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.JointState.position)
  return _internal_position();
}
inline void JointState::unsafe_arena_set_allocated_position(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.JointState.position)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::release_position() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:bosdyn.api.JointState.position)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::mutable_position() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.JointState.position)
  return _msg;
}
inline void JointState::set_allocated_position(::PROTOBUF_NAMESPACE_ID::DoubleValue* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.JointState.position)
}

// .google.protobuf.DoubleValue velocity = 3;
inline bool JointState::_internal_has_velocity() const {
  return this != internal_default_instance() && _impl_.velocity_ != nullptr;
}
inline bool JointState::has_velocity() const {
  return _internal_has_velocity();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& JointState::_internal_velocity() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& JointState::velocity() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.JointState.velocity)
  return _internal_velocity();
}
inline void JointState::unsafe_arena_set_allocated_velocity(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.JointState.velocity)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::release_velocity() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:bosdyn.api.JointState.velocity)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::_internal_mutable_velocity() {
  
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::mutable_velocity() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.JointState.velocity)
  return _msg;
}
inline void JointState::set_allocated_velocity(::PROTOBUF_NAMESPACE_ID::DoubleValue* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity));
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.JointState.velocity)
}

// .google.protobuf.DoubleValue acceleration = 4;
inline bool JointState::_internal_has_acceleration() const {
  return this != internal_default_instance() && _impl_.acceleration_ != nullptr;
}
inline bool JointState::has_acceleration() const {
  return _internal_has_acceleration();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& JointState::_internal_acceleration() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& JointState::acceleration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.JointState.acceleration)
  return _internal_acceleration();
}
inline void JointState::unsafe_arena_set_allocated_acceleration(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* acceleration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acceleration_);
  }
  _impl_.acceleration_ = acceleration;
  if (acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.JointState.acceleration)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::release_acceleration() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::unsafe_arena_release_acceleration() {
  // @@protoc_insertion_point(field_release:bosdyn.api.JointState.acceleration)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::_internal_mutable_acceleration() {
  
  if (_impl_.acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.acceleration_ = p;
  }
  return _impl_.acceleration_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::mutable_acceleration() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.JointState.acceleration)
  return _msg;
}
inline void JointState::set_allocated_acceleration(::PROTOBUF_NAMESPACE_ID::DoubleValue* acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acceleration_);
  }
  if (acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acceleration));
    if (message_arena != submessage_arena) {
      acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.JointState.acceleration)
}

// .google.protobuf.DoubleValue load = 5;
inline bool JointState::_internal_has_load() const {
  return this != internal_default_instance() && _impl_.load_ != nullptr;
}
inline bool JointState::has_load() const {
  return _internal_has_load();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& JointState::_internal_load() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.load_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& JointState::load() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.JointState.load)
  return _internal_load();
}
inline void JointState::unsafe_arena_set_allocated_load(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* load) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.load_);
  }
  _impl_.load_ = load;
  if (load) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.JointState.load)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::release_load() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.load_;
  _impl_.load_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::unsafe_arena_release_load() {
  // @@protoc_insertion_point(field_release:bosdyn.api.JointState.load)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.load_;
  _impl_.load_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::_internal_mutable_load() {
  
  if (_impl_.load_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.load_ = p;
  }
  return _impl_.load_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::mutable_load() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_load();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.JointState.load)
  return _msg;
}
inline void JointState::set_allocated_load(::PROTOBUF_NAMESPACE_ID::DoubleValue* load) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.load_);
  }
  if (load) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(load));
    if (message_arena != submessage_arena) {
      load = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, load, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.load_ = load;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.JointState.load)
}

// -------------------------------------------------------------------

// BehaviorFaultState

// repeated .bosdyn.api.BehaviorFault faults = 1;
inline int BehaviorFaultState::_internal_faults_size() const {
  return _impl_.faults_.size();
}
inline int BehaviorFaultState::faults_size() const {
  return _internal_faults_size();
}
inline void BehaviorFaultState::clear_faults() {
  _impl_.faults_.Clear();
}
inline ::bosdyn::api::BehaviorFault* BehaviorFaultState::mutable_faults(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BehaviorFaultState.faults)
  return _impl_.faults_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BehaviorFault >*
BehaviorFaultState::mutable_faults() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.BehaviorFaultState.faults)
  return &_impl_.faults_;
}
inline const ::bosdyn::api::BehaviorFault& BehaviorFaultState::_internal_faults(int index) const {
  return _impl_.faults_.Get(index);
}
inline const ::bosdyn::api::BehaviorFault& BehaviorFaultState::faults(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BehaviorFaultState.faults)
  return _internal_faults(index);
}
inline ::bosdyn::api::BehaviorFault* BehaviorFaultState::_internal_add_faults() {
  return _impl_.faults_.Add();
}
inline ::bosdyn::api::BehaviorFault* BehaviorFaultState::add_faults() {
  ::bosdyn::api::BehaviorFault* _add = _internal_add_faults();
  // @@protoc_insertion_point(field_add:bosdyn.api.BehaviorFaultState.faults)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BehaviorFault >&
BehaviorFaultState::faults() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.BehaviorFaultState.faults)
  return _impl_.faults_;
}

// -------------------------------------------------------------------

// BehaviorFault

// uint32 behavior_fault_id = 1;
inline void BehaviorFault::clear_behavior_fault_id() {
  _impl_.behavior_fault_id_ = 0u;
}
inline uint32_t BehaviorFault::_internal_behavior_fault_id() const {
  return _impl_.behavior_fault_id_;
}
inline uint32_t BehaviorFault::behavior_fault_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BehaviorFault.behavior_fault_id)
  return _internal_behavior_fault_id();
}
inline void BehaviorFault::_internal_set_behavior_fault_id(uint32_t value) {
  
  _impl_.behavior_fault_id_ = value;
}
inline void BehaviorFault::set_behavior_fault_id(uint32_t value) {
  _internal_set_behavior_fault_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.BehaviorFault.behavior_fault_id)
}

// .google.protobuf.Timestamp onset_timestamp = 2;
inline bool BehaviorFault::_internal_has_onset_timestamp() const {
  return this != internal_default_instance() && _impl_.onset_timestamp_ != nullptr;
}
inline bool BehaviorFault::has_onset_timestamp() const {
  return _internal_has_onset_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BehaviorFault::_internal_onset_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.onset_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BehaviorFault::onset_timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BehaviorFault.onset_timestamp)
  return _internal_onset_timestamp();
}
inline void BehaviorFault::unsafe_arena_set_allocated_onset_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.onset_timestamp_);
  }
  _impl_.onset_timestamp_ = onset_timestamp;
  if (onset_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.BehaviorFault.onset_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BehaviorFault::release_onset_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.onset_timestamp_;
  _impl_.onset_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BehaviorFault::unsafe_arena_release_onset_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BehaviorFault.onset_timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.onset_timestamp_;
  _impl_.onset_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BehaviorFault::_internal_mutable_onset_timestamp() {
  
  if (_impl_.onset_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.onset_timestamp_ = p;
  }
  return _impl_.onset_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BehaviorFault::mutable_onset_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_onset_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BehaviorFault.onset_timestamp)
  return _msg;
}
inline void BehaviorFault::set_allocated_onset_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.onset_timestamp_);
  }
  if (onset_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(onset_timestamp));
    if (message_arena != submessage_arena) {
      onset_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, onset_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.onset_timestamp_ = onset_timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BehaviorFault.onset_timestamp)
}

// .bosdyn.api.BehaviorFault.Cause cause = 3;
inline void BehaviorFault::clear_cause() {
  _impl_.cause_ = 0;
}
inline ::bosdyn::api::BehaviorFault_Cause BehaviorFault::_internal_cause() const {
  return static_cast< ::bosdyn::api::BehaviorFault_Cause >(_impl_.cause_);
}
inline ::bosdyn::api::BehaviorFault_Cause BehaviorFault::cause() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BehaviorFault.cause)
  return _internal_cause();
}
inline void BehaviorFault::_internal_set_cause(::bosdyn::api::BehaviorFault_Cause value) {
  
  _impl_.cause_ = value;
}
inline void BehaviorFault::set_cause(::bosdyn::api::BehaviorFault_Cause value) {
  _internal_set_cause(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.BehaviorFault.cause)
}

// .bosdyn.api.BehaviorFault.Status status = 4;
inline void BehaviorFault::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::BehaviorFault_Status BehaviorFault::_internal_status() const {
  return static_cast< ::bosdyn::api::BehaviorFault_Status >(_impl_.status_);
}
inline ::bosdyn::api::BehaviorFault_Status BehaviorFault::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BehaviorFault.status)
  return _internal_status();
}
inline void BehaviorFault::_internal_set_status(::bosdyn::api::BehaviorFault_Status value) {
  
  _impl_.status_ = value;
}
inline void BehaviorFault::set_status(::bosdyn::api::BehaviorFault_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.BehaviorFault.status)
}

// -------------------------------------------------------------------

// RobotMetrics

// .google.protobuf.Timestamp timestamp = 1;
inline bool RobotMetrics::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool RobotMetrics::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotMetrics::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotMetrics::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotMetrics.timestamp)
  return _internal_timestamp();
}
inline void RobotMetrics::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotMetrics.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotMetrics::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotMetrics::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotMetrics.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotMetrics::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotMetrics::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotMetrics.timestamp)
  return _msg;
}
inline void RobotMetrics::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotMetrics.timestamp)
}

// repeated .bosdyn.api.Parameter metrics = 2;
inline int RobotMetrics::_internal_metrics_size() const {
  return _impl_.metrics_.size();
}
inline int RobotMetrics::metrics_size() const {
  return _internal_metrics_size();
}
inline ::bosdyn::api::Parameter* RobotMetrics::mutable_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotMetrics.metrics)
  return _impl_.metrics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Parameter >*
RobotMetrics::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RobotMetrics.metrics)
  return &_impl_.metrics_;
}
inline const ::bosdyn::api::Parameter& RobotMetrics::_internal_metrics(int index) const {
  return _impl_.metrics_.Get(index);
}
inline const ::bosdyn::api::Parameter& RobotMetrics::metrics(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotMetrics.metrics)
  return _internal_metrics(index);
}
inline ::bosdyn::api::Parameter* RobotMetrics::_internal_add_metrics() {
  return _impl_.metrics_.Add();
}
inline ::bosdyn::api::Parameter* RobotMetrics::add_metrics() {
  ::bosdyn::api::Parameter* _add = _internal_add_metrics();
  // @@protoc_insertion_point(field_add:bosdyn.api.RobotMetrics.metrics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Parameter >&
RobotMetrics::metrics() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RobotMetrics.metrics)
  return _impl_.metrics_;
}

// -------------------------------------------------------------------

// CommsState

// .google.protobuf.Timestamp timestamp = 1;
inline bool CommsState::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool CommsState::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CommsState::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CommsState::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CommsState.timestamp)
  return _internal_timestamp();
}
inline void CommsState::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.CommsState.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CommsState::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CommsState::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.CommsState.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CommsState::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CommsState::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.CommsState.timestamp)
  return _msg;
}
inline void CommsState::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.CommsState.timestamp)
}

// .bosdyn.api.WiFiState wifi_state = 2;
inline bool CommsState::_internal_has_wifi_state() const {
  return state_case() == kWifiState;
}
inline bool CommsState::has_wifi_state() const {
  return _internal_has_wifi_state();
}
inline void CommsState::set_has_wifi_state() {
  _impl_._oneof_case_[0] = kWifiState;
}
inline void CommsState::clear_wifi_state() {
  if (_internal_has_wifi_state()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.state_.wifi_state_;
    }
    clear_has_state();
  }
}
inline ::bosdyn::api::WiFiState* CommsState::release_wifi_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.CommsState.wifi_state)
  if (_internal_has_wifi_state()) {
    clear_has_state();
    ::bosdyn::api::WiFiState* temp = _impl_.state_.wifi_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.state_.wifi_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::WiFiState& CommsState::_internal_wifi_state() const {
  return _internal_has_wifi_state()
      ? *_impl_.state_.wifi_state_
      : reinterpret_cast< ::bosdyn::api::WiFiState&>(::bosdyn::api::_WiFiState_default_instance_);
}
inline const ::bosdyn::api::WiFiState& CommsState::wifi_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CommsState.wifi_state)
  return _internal_wifi_state();
}
inline ::bosdyn::api::WiFiState* CommsState::unsafe_arena_release_wifi_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.CommsState.wifi_state)
  if (_internal_has_wifi_state()) {
    clear_has_state();
    ::bosdyn::api::WiFiState* temp = _impl_.state_.wifi_state_;
    _impl_.state_.wifi_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CommsState::unsafe_arena_set_allocated_wifi_state(::bosdyn::api::WiFiState* wifi_state) {
  clear_state();
  if (wifi_state) {
    set_has_wifi_state();
    _impl_.state_.wifi_state_ = wifi_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.CommsState.wifi_state)
}
inline ::bosdyn::api::WiFiState* CommsState::_internal_mutable_wifi_state() {
  if (!_internal_has_wifi_state()) {
    clear_state();
    set_has_wifi_state();
    _impl_.state_.wifi_state_ = CreateMaybeMessage< ::bosdyn::api::WiFiState >(GetArenaForAllocation());
  }
  return _impl_.state_.wifi_state_;
}
inline ::bosdyn::api::WiFiState* CommsState::mutable_wifi_state() {
  ::bosdyn::api::WiFiState* _msg = _internal_mutable_wifi_state();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.CommsState.wifi_state)
  return _msg;
}

inline bool CommsState::has_state() const {
  return state_case() != STATE_NOT_SET;
}
inline void CommsState::clear_has_state() {
  _impl_._oneof_case_[0] = STATE_NOT_SET;
}
inline CommsState::StateCase CommsState::state_case() const {
  return CommsState::StateCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// WiFiState

// .bosdyn.api.WiFiState.Mode current_mode = 1;
inline void WiFiState::clear_current_mode() {
  _impl_.current_mode_ = 0;
}
inline ::bosdyn::api::WiFiState_Mode WiFiState::_internal_current_mode() const {
  return static_cast< ::bosdyn::api::WiFiState_Mode >(_impl_.current_mode_);
}
inline ::bosdyn::api::WiFiState_Mode WiFiState::current_mode() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WiFiState.current_mode)
  return _internal_current_mode();
}
inline void WiFiState::_internal_set_current_mode(::bosdyn::api::WiFiState_Mode value) {
  
  _impl_.current_mode_ = value;
}
inline void WiFiState::set_current_mode(::bosdyn::api::WiFiState_Mode value) {
  _internal_set_current_mode(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.WiFiState.current_mode)
}

// string essid = 2;
inline void WiFiState::clear_essid() {
  _impl_.essid_.ClearToEmpty();
}
inline const std::string& WiFiState::essid() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WiFiState.essid)
  return _internal_essid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WiFiState::set_essid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.essid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.WiFiState.essid)
}
inline std::string* WiFiState::mutable_essid() {
  std::string* _s = _internal_mutable_essid();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WiFiState.essid)
  return _s;
}
inline const std::string& WiFiState::_internal_essid() const {
  return _impl_.essid_.Get();
}
inline void WiFiState::_internal_set_essid(const std::string& value) {
  
  _impl_.essid_.Set(value, GetArenaForAllocation());
}
inline std::string* WiFiState::_internal_mutable_essid() {
  
  return _impl_.essid_.Mutable(GetArenaForAllocation());
}
inline std::string* WiFiState::release_essid() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WiFiState.essid)
  return _impl_.essid_.Release();
}
inline void WiFiState::set_allocated_essid(std::string* essid) {
  if (essid != nullptr) {
    
  } else {
    
  }
  _impl_.essid_.SetAllocated(essid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.essid_.IsDefault()) {
    _impl_.essid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WiFiState.essid)
}

// -------------------------------------------------------------------

// FootState_TerrainState

// double ground_mu_est = 1;
inline void FootState_TerrainState::clear_ground_mu_est() {
  _impl_.ground_mu_est_ = 0;
}
inline double FootState_TerrainState::_internal_ground_mu_est() const {
  return _impl_.ground_mu_est_;
}
inline double FootState_TerrainState::ground_mu_est() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FootState.TerrainState.ground_mu_est)
  return _internal_ground_mu_est();
}
inline void FootState_TerrainState::_internal_set_ground_mu_est(double value) {
  
  _impl_.ground_mu_est_ = value;
}
inline void FootState_TerrainState::set_ground_mu_est(double value) {
  _internal_set_ground_mu_est(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.FootState.TerrainState.ground_mu_est)
}

// string frame_name = 2;
inline void FootState_TerrainState::clear_frame_name() {
  _impl_.frame_name_.ClearToEmpty();
}
inline const std::string& FootState_TerrainState::frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FootState.TerrainState.frame_name)
  return _internal_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FootState_TerrainState::set_frame_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.FootState.TerrainState.frame_name)
}
inline std::string* FootState_TerrainState::mutable_frame_name() {
  std::string* _s = _internal_mutable_frame_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FootState.TerrainState.frame_name)
  return _s;
}
inline const std::string& FootState_TerrainState::_internal_frame_name() const {
  return _impl_.frame_name_.Get();
}
inline void FootState_TerrainState::_internal_set_frame_name(const std::string& value) {
  
  _impl_.frame_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FootState_TerrainState::_internal_mutable_frame_name() {
  
  return _impl_.frame_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FootState_TerrainState::release_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FootState.TerrainState.frame_name)
  return _impl_.frame_name_.Release();
}
inline void FootState_TerrainState::set_allocated_frame_name(std::string* frame_name) {
  if (frame_name != nullptr) {
    
  } else {
    
  }
  _impl_.frame_name_.SetAllocated(frame_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_name_.IsDefault()) {
    _impl_.frame_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FootState.TerrainState.frame_name)
}

// .bosdyn.api.Vec3 foot_slip_distance_rt_frame = 3;
inline bool FootState_TerrainState::_internal_has_foot_slip_distance_rt_frame() const {
  return this != internal_default_instance() && _impl_.foot_slip_distance_rt_frame_ != nullptr;
}
inline bool FootState_TerrainState::has_foot_slip_distance_rt_frame() const {
  return _internal_has_foot_slip_distance_rt_frame();
}
inline const ::bosdyn::api::Vec3& FootState_TerrainState::_internal_foot_slip_distance_rt_frame() const {
  const ::bosdyn::api::Vec3* p = _impl_.foot_slip_distance_rt_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& FootState_TerrainState::foot_slip_distance_rt_frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FootState.TerrainState.foot_slip_distance_rt_frame)
  return _internal_foot_slip_distance_rt_frame();
}
inline void FootState_TerrainState::unsafe_arena_set_allocated_foot_slip_distance_rt_frame(
    ::bosdyn::api::Vec3* foot_slip_distance_rt_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.foot_slip_distance_rt_frame_);
  }
  _impl_.foot_slip_distance_rt_frame_ = foot_slip_distance_rt_frame;
  if (foot_slip_distance_rt_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FootState.TerrainState.foot_slip_distance_rt_frame)
}
inline ::bosdyn::api::Vec3* FootState_TerrainState::release_foot_slip_distance_rt_frame() {
  
  ::bosdyn::api::Vec3* temp = _impl_.foot_slip_distance_rt_frame_;
  _impl_.foot_slip_distance_rt_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* FootState_TerrainState::unsafe_arena_release_foot_slip_distance_rt_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FootState.TerrainState.foot_slip_distance_rt_frame)
  
  ::bosdyn::api::Vec3* temp = _impl_.foot_slip_distance_rt_frame_;
  _impl_.foot_slip_distance_rt_frame_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* FootState_TerrainState::_internal_mutable_foot_slip_distance_rt_frame() {
  
  if (_impl_.foot_slip_distance_rt_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.foot_slip_distance_rt_frame_ = p;
  }
  return _impl_.foot_slip_distance_rt_frame_;
}
inline ::bosdyn::api::Vec3* FootState_TerrainState::mutable_foot_slip_distance_rt_frame() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_foot_slip_distance_rt_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FootState.TerrainState.foot_slip_distance_rt_frame)
  return _msg;
}
inline void FootState_TerrainState::set_allocated_foot_slip_distance_rt_frame(::bosdyn::api::Vec3* foot_slip_distance_rt_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.foot_slip_distance_rt_frame_);
  }
  if (foot_slip_distance_rt_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(foot_slip_distance_rt_frame));
    if (message_arena != submessage_arena) {
      foot_slip_distance_rt_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, foot_slip_distance_rt_frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.foot_slip_distance_rt_frame_ = foot_slip_distance_rt_frame;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FootState.TerrainState.foot_slip_distance_rt_frame)
}

// .bosdyn.api.Vec3 foot_slip_velocity_rt_frame = 4;
inline bool FootState_TerrainState::_internal_has_foot_slip_velocity_rt_frame() const {
  return this != internal_default_instance() && _impl_.foot_slip_velocity_rt_frame_ != nullptr;
}
inline bool FootState_TerrainState::has_foot_slip_velocity_rt_frame() const {
  return _internal_has_foot_slip_velocity_rt_frame();
}
inline const ::bosdyn::api::Vec3& FootState_TerrainState::_internal_foot_slip_velocity_rt_frame() const {
  const ::bosdyn::api::Vec3* p = _impl_.foot_slip_velocity_rt_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& FootState_TerrainState::foot_slip_velocity_rt_frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FootState.TerrainState.foot_slip_velocity_rt_frame)
  return _internal_foot_slip_velocity_rt_frame();
}
inline void FootState_TerrainState::unsafe_arena_set_allocated_foot_slip_velocity_rt_frame(
    ::bosdyn::api::Vec3* foot_slip_velocity_rt_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.foot_slip_velocity_rt_frame_);
  }
  _impl_.foot_slip_velocity_rt_frame_ = foot_slip_velocity_rt_frame;
  if (foot_slip_velocity_rt_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FootState.TerrainState.foot_slip_velocity_rt_frame)
}
inline ::bosdyn::api::Vec3* FootState_TerrainState::release_foot_slip_velocity_rt_frame() {
  
  ::bosdyn::api::Vec3* temp = _impl_.foot_slip_velocity_rt_frame_;
  _impl_.foot_slip_velocity_rt_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* FootState_TerrainState::unsafe_arena_release_foot_slip_velocity_rt_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FootState.TerrainState.foot_slip_velocity_rt_frame)
  
  ::bosdyn::api::Vec3* temp = _impl_.foot_slip_velocity_rt_frame_;
  _impl_.foot_slip_velocity_rt_frame_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* FootState_TerrainState::_internal_mutable_foot_slip_velocity_rt_frame() {
  
  if (_impl_.foot_slip_velocity_rt_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.foot_slip_velocity_rt_frame_ = p;
  }
  return _impl_.foot_slip_velocity_rt_frame_;
}
inline ::bosdyn::api::Vec3* FootState_TerrainState::mutable_foot_slip_velocity_rt_frame() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_foot_slip_velocity_rt_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FootState.TerrainState.foot_slip_velocity_rt_frame)
  return _msg;
}
inline void FootState_TerrainState::set_allocated_foot_slip_velocity_rt_frame(::bosdyn::api::Vec3* foot_slip_velocity_rt_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.foot_slip_velocity_rt_frame_);
  }
  if (foot_slip_velocity_rt_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(foot_slip_velocity_rt_frame));
    if (message_arena != submessage_arena) {
      foot_slip_velocity_rt_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, foot_slip_velocity_rt_frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.foot_slip_velocity_rt_frame_ = foot_slip_velocity_rt_frame;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FootState.TerrainState.foot_slip_velocity_rt_frame)
}

// .bosdyn.api.Vec3 ground_contact_normal_rt_frame = 5;
inline bool FootState_TerrainState::_internal_has_ground_contact_normal_rt_frame() const {
  return this != internal_default_instance() && _impl_.ground_contact_normal_rt_frame_ != nullptr;
}
inline bool FootState_TerrainState::has_ground_contact_normal_rt_frame() const {
  return _internal_has_ground_contact_normal_rt_frame();
}
inline const ::bosdyn::api::Vec3& FootState_TerrainState::_internal_ground_contact_normal_rt_frame() const {
  const ::bosdyn::api::Vec3* p = _impl_.ground_contact_normal_rt_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& FootState_TerrainState::ground_contact_normal_rt_frame() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FootState.TerrainState.ground_contact_normal_rt_frame)
  return _internal_ground_contact_normal_rt_frame();
}
inline void FootState_TerrainState::unsafe_arena_set_allocated_ground_contact_normal_rt_frame(
    ::bosdyn::api::Vec3* ground_contact_normal_rt_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ground_contact_normal_rt_frame_);
  }
  _impl_.ground_contact_normal_rt_frame_ = ground_contact_normal_rt_frame;
  if (ground_contact_normal_rt_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FootState.TerrainState.ground_contact_normal_rt_frame)
}
inline ::bosdyn::api::Vec3* FootState_TerrainState::release_ground_contact_normal_rt_frame() {
  
  ::bosdyn::api::Vec3* temp = _impl_.ground_contact_normal_rt_frame_;
  _impl_.ground_contact_normal_rt_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* FootState_TerrainState::unsafe_arena_release_ground_contact_normal_rt_frame() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FootState.TerrainState.ground_contact_normal_rt_frame)
  
  ::bosdyn::api::Vec3* temp = _impl_.ground_contact_normal_rt_frame_;
  _impl_.ground_contact_normal_rt_frame_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* FootState_TerrainState::_internal_mutable_ground_contact_normal_rt_frame() {
  
  if (_impl_.ground_contact_normal_rt_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.ground_contact_normal_rt_frame_ = p;
  }
  return _impl_.ground_contact_normal_rt_frame_;
}
inline ::bosdyn::api::Vec3* FootState_TerrainState::mutable_ground_contact_normal_rt_frame() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_ground_contact_normal_rt_frame();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FootState.TerrainState.ground_contact_normal_rt_frame)
  return _msg;
}
inline void FootState_TerrainState::set_allocated_ground_contact_normal_rt_frame(::bosdyn::api::Vec3* ground_contact_normal_rt_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ground_contact_normal_rt_frame_);
  }
  if (ground_contact_normal_rt_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ground_contact_normal_rt_frame));
    if (message_arena != submessage_arena) {
      ground_contact_normal_rt_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ground_contact_normal_rt_frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ground_contact_normal_rt_frame_ = ground_contact_normal_rt_frame;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FootState.TerrainState.ground_contact_normal_rt_frame)
}

// double visual_surface_ground_penetration_mean = 6;
inline void FootState_TerrainState::clear_visual_surface_ground_penetration_mean() {
  _impl_.visual_surface_ground_penetration_mean_ = 0;
}
inline double FootState_TerrainState::_internal_visual_surface_ground_penetration_mean() const {
  return _impl_.visual_surface_ground_penetration_mean_;
}
inline double FootState_TerrainState::visual_surface_ground_penetration_mean() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FootState.TerrainState.visual_surface_ground_penetration_mean)
  return _internal_visual_surface_ground_penetration_mean();
}
inline void FootState_TerrainState::_internal_set_visual_surface_ground_penetration_mean(double value) {
  
  _impl_.visual_surface_ground_penetration_mean_ = value;
}
inline void FootState_TerrainState::set_visual_surface_ground_penetration_mean(double value) {
  _internal_set_visual_surface_ground_penetration_mean(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.FootState.TerrainState.visual_surface_ground_penetration_mean)
}

// double visual_surface_ground_penetration_std = 7;
inline void FootState_TerrainState::clear_visual_surface_ground_penetration_std() {
  _impl_.visual_surface_ground_penetration_std_ = 0;
}
inline double FootState_TerrainState::_internal_visual_surface_ground_penetration_std() const {
  return _impl_.visual_surface_ground_penetration_std_;
}
inline double FootState_TerrainState::visual_surface_ground_penetration_std() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FootState.TerrainState.visual_surface_ground_penetration_std)
  return _internal_visual_surface_ground_penetration_std();
}
inline void FootState_TerrainState::_internal_set_visual_surface_ground_penetration_std(double value) {
  
  _impl_.visual_surface_ground_penetration_std_ = value;
}
inline void FootState_TerrainState::set_visual_surface_ground_penetration_std(double value) {
  _internal_set_visual_surface_ground_penetration_std(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.FootState.TerrainState.visual_surface_ground_penetration_std)
}

// -------------------------------------------------------------------

// FootState

// .bosdyn.api.Vec3 foot_position_rt_body = 1;
inline bool FootState::_internal_has_foot_position_rt_body() const {
  return this != internal_default_instance() && _impl_.foot_position_rt_body_ != nullptr;
}
inline bool FootState::has_foot_position_rt_body() const {
  return _internal_has_foot_position_rt_body();
}
inline const ::bosdyn::api::Vec3& FootState::_internal_foot_position_rt_body() const {
  const ::bosdyn::api::Vec3* p = _impl_.foot_position_rt_body_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& FootState::foot_position_rt_body() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FootState.foot_position_rt_body)
  return _internal_foot_position_rt_body();
}
inline void FootState::unsafe_arena_set_allocated_foot_position_rt_body(
    ::bosdyn::api::Vec3* foot_position_rt_body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.foot_position_rt_body_);
  }
  _impl_.foot_position_rt_body_ = foot_position_rt_body;
  if (foot_position_rt_body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FootState.foot_position_rt_body)
}
inline ::bosdyn::api::Vec3* FootState::release_foot_position_rt_body() {
  
  ::bosdyn::api::Vec3* temp = _impl_.foot_position_rt_body_;
  _impl_.foot_position_rt_body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* FootState::unsafe_arena_release_foot_position_rt_body() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FootState.foot_position_rt_body)
  
  ::bosdyn::api::Vec3* temp = _impl_.foot_position_rt_body_;
  _impl_.foot_position_rt_body_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* FootState::_internal_mutable_foot_position_rt_body() {
  
  if (_impl_.foot_position_rt_body_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.foot_position_rt_body_ = p;
  }
  return _impl_.foot_position_rt_body_;
}
inline ::bosdyn::api::Vec3* FootState::mutable_foot_position_rt_body() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_foot_position_rt_body();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FootState.foot_position_rt_body)
  return _msg;
}
inline void FootState::set_allocated_foot_position_rt_body(::bosdyn::api::Vec3* foot_position_rt_body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.foot_position_rt_body_);
  }
  if (foot_position_rt_body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(foot_position_rt_body));
    if (message_arena != submessage_arena) {
      foot_position_rt_body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, foot_position_rt_body, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.foot_position_rt_body_ = foot_position_rt_body;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FootState.foot_position_rt_body)
}

// .bosdyn.api.FootState.Contact contact = 2;
inline void FootState::clear_contact() {
  _impl_.contact_ = 0;
}
inline ::bosdyn::api::FootState_Contact FootState::_internal_contact() const {
  return static_cast< ::bosdyn::api::FootState_Contact >(_impl_.contact_);
}
inline ::bosdyn::api::FootState_Contact FootState::contact() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FootState.contact)
  return _internal_contact();
}
inline void FootState::_internal_set_contact(::bosdyn::api::FootState_Contact value) {
  
  _impl_.contact_ = value;
}
inline void FootState::set_contact(::bosdyn::api::FootState_Contact value) {
  _internal_set_contact(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.FootState.contact)
}

// .bosdyn.api.FootState.TerrainState terrain = 3;
inline bool FootState::_internal_has_terrain() const {
  return this != internal_default_instance() && _impl_.terrain_ != nullptr;
}
inline bool FootState::has_terrain() const {
  return _internal_has_terrain();
}
inline void FootState::clear_terrain() {
  if (GetArenaForAllocation() == nullptr && _impl_.terrain_ != nullptr) {
    delete _impl_.terrain_;
  }
  _impl_.terrain_ = nullptr;
}
inline const ::bosdyn::api::FootState_TerrainState& FootState::_internal_terrain() const {
  const ::bosdyn::api::FootState_TerrainState* p = _impl_.terrain_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::FootState_TerrainState&>(
      ::bosdyn::api::_FootState_TerrainState_default_instance_);
}
inline const ::bosdyn::api::FootState_TerrainState& FootState::terrain() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FootState.terrain)
  return _internal_terrain();
}
inline void FootState::unsafe_arena_set_allocated_terrain(
    ::bosdyn::api::FootState_TerrainState* terrain) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.terrain_);
  }
  _impl_.terrain_ = terrain;
  if (terrain) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FootState.terrain)
}
inline ::bosdyn::api::FootState_TerrainState* FootState::release_terrain() {
  
  ::bosdyn::api::FootState_TerrainState* temp = _impl_.terrain_;
  _impl_.terrain_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::FootState_TerrainState* FootState::unsafe_arena_release_terrain() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FootState.terrain)
  
  ::bosdyn::api::FootState_TerrainState* temp = _impl_.terrain_;
  _impl_.terrain_ = nullptr;
  return temp;
}
inline ::bosdyn::api::FootState_TerrainState* FootState::_internal_mutable_terrain() {
  
  if (_impl_.terrain_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::FootState_TerrainState>(GetArenaForAllocation());
    _impl_.terrain_ = p;
  }
  return _impl_.terrain_;
}
inline ::bosdyn::api::FootState_TerrainState* FootState::mutable_terrain() {
  ::bosdyn::api::FootState_TerrainState* _msg = _internal_mutable_terrain();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FootState.terrain)
  return _msg;
}
inline void FootState::set_allocated_terrain(::bosdyn::api::FootState_TerrainState* terrain) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.terrain_;
  }
  if (terrain) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(terrain);
    if (message_arena != submessage_arena) {
      terrain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terrain, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.terrain_ = terrain;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FootState.terrain)
}

// -------------------------------------------------------------------

// ManipulatorState

// double gripper_open_percentage = 12;
inline void ManipulatorState::clear_gripper_open_percentage() {
  _impl_.gripper_open_percentage_ = 0;
}
inline double ManipulatorState::_internal_gripper_open_percentage() const {
  return _impl_.gripper_open_percentage_;
}
inline double ManipulatorState::gripper_open_percentage() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulatorState.gripper_open_percentage)
  return _internal_gripper_open_percentage();
}
inline void ManipulatorState::_internal_set_gripper_open_percentage(double value) {
  
  _impl_.gripper_open_percentage_ = value;
}
inline void ManipulatorState::set_gripper_open_percentage(double value) {
  _internal_set_gripper_open_percentage(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ManipulatorState.gripper_open_percentage)
}

// bool is_gripper_holding_item = 6;
inline void ManipulatorState::clear_is_gripper_holding_item() {
  _impl_.is_gripper_holding_item_ = false;
}
inline bool ManipulatorState::_internal_is_gripper_holding_item() const {
  return _impl_.is_gripper_holding_item_;
}
inline bool ManipulatorState::is_gripper_holding_item() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulatorState.is_gripper_holding_item)
  return _internal_is_gripper_holding_item();
}
inline void ManipulatorState::_internal_set_is_gripper_holding_item(bool value) {
  
  _impl_.is_gripper_holding_item_ = value;
}
inline void ManipulatorState::set_is_gripper_holding_item(bool value) {
  _internal_set_is_gripper_holding_item(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ManipulatorState.is_gripper_holding_item)
}

// .bosdyn.api.Vec3 estimated_end_effector_force_in_hand = 13;
inline bool ManipulatorState::_internal_has_estimated_end_effector_force_in_hand() const {
  return this != internal_default_instance() && _impl_.estimated_end_effector_force_in_hand_ != nullptr;
}
inline bool ManipulatorState::has_estimated_end_effector_force_in_hand() const {
  return _internal_has_estimated_end_effector_force_in_hand();
}
inline const ::bosdyn::api::Vec3& ManipulatorState::_internal_estimated_end_effector_force_in_hand() const {
  const ::bosdyn::api::Vec3* p = _impl_.estimated_end_effector_force_in_hand_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3&>(
      ::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& ManipulatorState::estimated_end_effector_force_in_hand() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulatorState.estimated_end_effector_force_in_hand)
  return _internal_estimated_end_effector_force_in_hand();
}
inline void ManipulatorState::unsafe_arena_set_allocated_estimated_end_effector_force_in_hand(
    ::bosdyn::api::Vec3* estimated_end_effector_force_in_hand) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.estimated_end_effector_force_in_hand_);
  }
  _impl_.estimated_end_effector_force_in_hand_ = estimated_end_effector_force_in_hand;
  if (estimated_end_effector_force_in_hand) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ManipulatorState.estimated_end_effector_force_in_hand)
}
inline ::bosdyn::api::Vec3* ManipulatorState::release_estimated_end_effector_force_in_hand() {
  
  ::bosdyn::api::Vec3* temp = _impl_.estimated_end_effector_force_in_hand_;
  _impl_.estimated_end_effector_force_in_hand_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3* ManipulatorState::unsafe_arena_release_estimated_end_effector_force_in_hand() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ManipulatorState.estimated_end_effector_force_in_hand)
  
  ::bosdyn::api::Vec3* temp = _impl_.estimated_end_effector_force_in_hand_;
  _impl_.estimated_end_effector_force_in_hand_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* ManipulatorState::_internal_mutable_estimated_end_effector_force_in_hand() {
  
  if (_impl_.estimated_end_effector_force_in_hand_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArenaForAllocation());
    _impl_.estimated_end_effector_force_in_hand_ = p;
  }
  return _impl_.estimated_end_effector_force_in_hand_;
}
inline ::bosdyn::api::Vec3* ManipulatorState::mutable_estimated_end_effector_force_in_hand() {
  ::bosdyn::api::Vec3* _msg = _internal_mutable_estimated_end_effector_force_in_hand();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ManipulatorState.estimated_end_effector_force_in_hand)
  return _msg;
}
inline void ManipulatorState::set_allocated_estimated_end_effector_force_in_hand(::bosdyn::api::Vec3* estimated_end_effector_force_in_hand) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.estimated_end_effector_force_in_hand_);
  }
  if (estimated_end_effector_force_in_hand) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(estimated_end_effector_force_in_hand));
    if (message_arena != submessage_arena) {
      estimated_end_effector_force_in_hand = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, estimated_end_effector_force_in_hand, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.estimated_end_effector_force_in_hand_ = estimated_end_effector_force_in_hand;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ManipulatorState.estimated_end_effector_force_in_hand)
}

// .bosdyn.api.ManipulatorState.StowState stow_state = 9;
inline void ManipulatorState::clear_stow_state() {
  _impl_.stow_state_ = 0;
}
inline ::bosdyn::api::ManipulatorState_StowState ManipulatorState::_internal_stow_state() const {
  return static_cast< ::bosdyn::api::ManipulatorState_StowState >(_impl_.stow_state_);
}
inline ::bosdyn::api::ManipulatorState_StowState ManipulatorState::stow_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulatorState.stow_state)
  return _internal_stow_state();
}
inline void ManipulatorState::_internal_set_stow_state(::bosdyn::api::ManipulatorState_StowState value) {
  
  _impl_.stow_state_ = value;
}
inline void ManipulatorState::set_stow_state(::bosdyn::api::ManipulatorState_StowState value) {
  _internal_set_stow_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ManipulatorState.stow_state)
}

// .bosdyn.api.SE3Velocity velocity_of_hand_in_vision = 14;
inline bool ManipulatorState::_internal_has_velocity_of_hand_in_vision() const {
  return this != internal_default_instance() && _impl_.velocity_of_hand_in_vision_ != nullptr;
}
inline bool ManipulatorState::has_velocity_of_hand_in_vision() const {
  return _internal_has_velocity_of_hand_in_vision();
}
inline const ::bosdyn::api::SE3Velocity& ManipulatorState::_internal_velocity_of_hand_in_vision() const {
  const ::bosdyn::api::SE3Velocity* p = _impl_.velocity_of_hand_in_vision_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Velocity&>(
      ::bosdyn::api::_SE3Velocity_default_instance_);
}
inline const ::bosdyn::api::SE3Velocity& ManipulatorState::velocity_of_hand_in_vision() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulatorState.velocity_of_hand_in_vision)
  return _internal_velocity_of_hand_in_vision();
}
inline void ManipulatorState::unsafe_arena_set_allocated_velocity_of_hand_in_vision(
    ::bosdyn::api::SE3Velocity* velocity_of_hand_in_vision) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_of_hand_in_vision_);
  }
  _impl_.velocity_of_hand_in_vision_ = velocity_of_hand_in_vision;
  if (velocity_of_hand_in_vision) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ManipulatorState.velocity_of_hand_in_vision)
}
inline ::bosdyn::api::SE3Velocity* ManipulatorState::release_velocity_of_hand_in_vision() {
  
  ::bosdyn::api::SE3Velocity* temp = _impl_.velocity_of_hand_in_vision_;
  _impl_.velocity_of_hand_in_vision_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Velocity* ManipulatorState::unsafe_arena_release_velocity_of_hand_in_vision() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ManipulatorState.velocity_of_hand_in_vision)
  
  ::bosdyn::api::SE3Velocity* temp = _impl_.velocity_of_hand_in_vision_;
  _impl_.velocity_of_hand_in_vision_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Velocity* ManipulatorState::_internal_mutable_velocity_of_hand_in_vision() {
  
  if (_impl_.velocity_of_hand_in_vision_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Velocity>(GetArenaForAllocation());
    _impl_.velocity_of_hand_in_vision_ = p;
  }
  return _impl_.velocity_of_hand_in_vision_;
}
inline ::bosdyn::api::SE3Velocity* ManipulatorState::mutable_velocity_of_hand_in_vision() {
  ::bosdyn::api::SE3Velocity* _msg = _internal_mutable_velocity_of_hand_in_vision();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ManipulatorState.velocity_of_hand_in_vision)
  return _msg;
}
inline void ManipulatorState::set_allocated_velocity_of_hand_in_vision(::bosdyn::api::SE3Velocity* velocity_of_hand_in_vision) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_of_hand_in_vision_);
  }
  if (velocity_of_hand_in_vision) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_of_hand_in_vision));
    if (message_arena != submessage_arena) {
      velocity_of_hand_in_vision = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity_of_hand_in_vision, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.velocity_of_hand_in_vision_ = velocity_of_hand_in_vision;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ManipulatorState.velocity_of_hand_in_vision)
}

// .bosdyn.api.SE3Velocity velocity_of_hand_in_odom = 15;
inline bool ManipulatorState::_internal_has_velocity_of_hand_in_odom() const {
  return this != internal_default_instance() && _impl_.velocity_of_hand_in_odom_ != nullptr;
}
inline bool ManipulatorState::has_velocity_of_hand_in_odom() const {
  return _internal_has_velocity_of_hand_in_odom();
}
inline const ::bosdyn::api::SE3Velocity& ManipulatorState::_internal_velocity_of_hand_in_odom() const {
  const ::bosdyn::api::SE3Velocity* p = _impl_.velocity_of_hand_in_odom_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Velocity&>(
      ::bosdyn::api::_SE3Velocity_default_instance_);
}
inline const ::bosdyn::api::SE3Velocity& ManipulatorState::velocity_of_hand_in_odom() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulatorState.velocity_of_hand_in_odom)
  return _internal_velocity_of_hand_in_odom();
}
inline void ManipulatorState::unsafe_arena_set_allocated_velocity_of_hand_in_odom(
    ::bosdyn::api::SE3Velocity* velocity_of_hand_in_odom) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_of_hand_in_odom_);
  }
  _impl_.velocity_of_hand_in_odom_ = velocity_of_hand_in_odom;
  if (velocity_of_hand_in_odom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ManipulatorState.velocity_of_hand_in_odom)
}
inline ::bosdyn::api::SE3Velocity* ManipulatorState::release_velocity_of_hand_in_odom() {
  
  ::bosdyn::api::SE3Velocity* temp = _impl_.velocity_of_hand_in_odom_;
  _impl_.velocity_of_hand_in_odom_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Velocity* ManipulatorState::unsafe_arena_release_velocity_of_hand_in_odom() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ManipulatorState.velocity_of_hand_in_odom)
  
  ::bosdyn::api::SE3Velocity* temp = _impl_.velocity_of_hand_in_odom_;
  _impl_.velocity_of_hand_in_odom_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Velocity* ManipulatorState::_internal_mutable_velocity_of_hand_in_odom() {
  
  if (_impl_.velocity_of_hand_in_odom_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Velocity>(GetArenaForAllocation());
    _impl_.velocity_of_hand_in_odom_ = p;
  }
  return _impl_.velocity_of_hand_in_odom_;
}
inline ::bosdyn::api::SE3Velocity* ManipulatorState::mutable_velocity_of_hand_in_odom() {
  ::bosdyn::api::SE3Velocity* _msg = _internal_mutable_velocity_of_hand_in_odom();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ManipulatorState.velocity_of_hand_in_odom)
  return _msg;
}
inline void ManipulatorState::set_allocated_velocity_of_hand_in_odom(::bosdyn::api::SE3Velocity* velocity_of_hand_in_odom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_of_hand_in_odom_);
  }
  if (velocity_of_hand_in_odom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_of_hand_in_odom));
    if (message_arena != submessage_arena) {
      velocity_of_hand_in_odom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity_of_hand_in_odom, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.velocity_of_hand_in_odom_ = velocity_of_hand_in_odom;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ManipulatorState.velocity_of_hand_in_odom)
}

// .bosdyn.api.ManipulatorState.CarryState carry_state = 16;
inline void ManipulatorState::clear_carry_state() {
  _impl_.carry_state_ = 0;
}
inline ::bosdyn::api::ManipulatorState_CarryState ManipulatorState::_internal_carry_state() const {
  return static_cast< ::bosdyn::api::ManipulatorState_CarryState >(_impl_.carry_state_);
}
inline ::bosdyn::api::ManipulatorState_CarryState ManipulatorState::carry_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ManipulatorState.carry_state)
  return _internal_carry_state();
}
inline void ManipulatorState::_internal_set_carry_state(::bosdyn::api::ManipulatorState_CarryState value) {
  
  _impl_.carry_state_ = value;
}
inline void ManipulatorState::set_carry_state(::bosdyn::api::ManipulatorState_CarryState value) {
  _internal_set_carry_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ManipulatorState.carry_state)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ServiceFaultState

// repeated .bosdyn.api.ServiceFault faults = 1;
inline int ServiceFaultState::_internal_faults_size() const {
  return _impl_.faults_.size();
}
inline int ServiceFaultState::faults_size() const {
  return _internal_faults_size();
}
inline ::bosdyn::api::ServiceFault* ServiceFaultState::mutable_faults(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ServiceFaultState.faults)
  return _impl_.faults_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ServiceFault >*
ServiceFaultState::mutable_faults() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ServiceFaultState.faults)
  return &_impl_.faults_;
}
inline const ::bosdyn::api::ServiceFault& ServiceFaultState::_internal_faults(int index) const {
  return _impl_.faults_.Get(index);
}
inline const ::bosdyn::api::ServiceFault& ServiceFaultState::faults(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ServiceFaultState.faults)
  return _internal_faults(index);
}
inline ::bosdyn::api::ServiceFault* ServiceFaultState::_internal_add_faults() {
  return _impl_.faults_.Add();
}
inline ::bosdyn::api::ServiceFault* ServiceFaultState::add_faults() {
  ::bosdyn::api::ServiceFault* _add = _internal_add_faults();
  // @@protoc_insertion_point(field_add:bosdyn.api.ServiceFaultState.faults)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ServiceFault >&
ServiceFaultState::faults() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ServiceFaultState.faults)
  return _impl_.faults_;
}

// repeated .bosdyn.api.ServiceFault historical_faults = 2;
inline int ServiceFaultState::_internal_historical_faults_size() const {
  return _impl_.historical_faults_.size();
}
inline int ServiceFaultState::historical_faults_size() const {
  return _internal_historical_faults_size();
}
inline ::bosdyn::api::ServiceFault* ServiceFaultState::mutable_historical_faults(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ServiceFaultState.historical_faults)
  return _impl_.historical_faults_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ServiceFault >*
ServiceFaultState::mutable_historical_faults() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ServiceFaultState.historical_faults)
  return &_impl_.historical_faults_;
}
inline const ::bosdyn::api::ServiceFault& ServiceFaultState::_internal_historical_faults(int index) const {
  return _impl_.historical_faults_.Get(index);
}
inline const ::bosdyn::api::ServiceFault& ServiceFaultState::historical_faults(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ServiceFaultState.historical_faults)
  return _internal_historical_faults(index);
}
inline ::bosdyn::api::ServiceFault* ServiceFaultState::_internal_add_historical_faults() {
  return _impl_.historical_faults_.Add();
}
inline ::bosdyn::api::ServiceFault* ServiceFaultState::add_historical_faults() {
  ::bosdyn::api::ServiceFault* _add = _internal_add_historical_faults();
  // @@protoc_insertion_point(field_add:bosdyn.api.ServiceFaultState.historical_faults)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ServiceFault >&
ServiceFaultState::historical_faults() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ServiceFaultState.historical_faults)
  return _impl_.historical_faults_;
}

// map<string, .bosdyn.api.ServiceFault.Severity> aggregated = 3;
inline int ServiceFaultState::_internal_aggregated_size() const {
  return _impl_.aggregated_.size();
}
inline int ServiceFaultState::aggregated_size() const {
  return _internal_aggregated_size();
}
inline void ServiceFaultState::clear_aggregated() {
  _impl_.aggregated_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::ServiceFault_Severity >&
ServiceFaultState::_internal_aggregated() const {
  return _impl_.aggregated_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::ServiceFault_Severity >&
ServiceFaultState::aggregated() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.ServiceFaultState.aggregated)
  return _internal_aggregated();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::ServiceFault_Severity >*
ServiceFaultState::_internal_mutable_aggregated() {
  return _impl_.aggregated_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::ServiceFault_Severity >*
ServiceFaultState::mutable_aggregated() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.ServiceFaultState.aggregated)
  return _internal_mutable_aggregated();
}

// -------------------------------------------------------------------

// TerrainState

// bool is_unsafe_to_sit = 1;
inline void TerrainState::clear_is_unsafe_to_sit() {
  _impl_.is_unsafe_to_sit_ = false;
}
inline bool TerrainState::_internal_is_unsafe_to_sit() const {
  return _impl_.is_unsafe_to_sit_;
}
inline bool TerrainState::is_unsafe_to_sit() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TerrainState.is_unsafe_to_sit)
  return _internal_is_unsafe_to_sit();
}
inline void TerrainState::_internal_set_is_unsafe_to_sit(bool value) {
  
  _impl_.is_unsafe_to_sit_ = value;
}
inline void TerrainState::set_is_unsafe_to_sit(bool value) {
  _internal_set_is_unsafe_to_sit(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.TerrainState.is_unsafe_to_sit)
}

// -------------------------------------------------------------------

// RobotStateRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RobotStateRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RobotStateRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RobotStateRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RobotStateRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotStateRequest.header)
  return _internal_header();
}
inline void RobotStateRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotStateRequest.header)
}
inline ::bosdyn::api::RequestHeader* RobotStateRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotStateRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotStateRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotStateRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* RobotStateRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotStateRequest.header)
  return _msg;
}
inline void RobotStateRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotStateRequest.header)
}

// -------------------------------------------------------------------

// RobotStateResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RobotStateResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RobotStateResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RobotStateResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RobotStateResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotStateResponse.header)
  return _internal_header();
}
inline void RobotStateResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotStateResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RobotStateResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotStateResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotStateResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotStateResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* RobotStateResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotStateResponse.header)
  return _msg;
}
inline void RobotStateResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotStateResponse.header)
}

// .bosdyn.api.RobotState robot_state = 2;
inline bool RobotStateResponse::_internal_has_robot_state() const {
  return this != internal_default_instance() && _impl_.robot_state_ != nullptr;
}
inline bool RobotStateResponse::has_robot_state() const {
  return _internal_has_robot_state();
}
inline void RobotStateResponse::clear_robot_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.robot_state_ != nullptr) {
    delete _impl_.robot_state_;
  }
  _impl_.robot_state_ = nullptr;
}
inline const ::bosdyn::api::RobotState& RobotStateResponse::_internal_robot_state() const {
  const ::bosdyn::api::RobotState* p = _impl_.robot_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RobotState&>(
      ::bosdyn::api::_RobotState_default_instance_);
}
inline const ::bosdyn::api::RobotState& RobotStateResponse::robot_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotStateResponse.robot_state)
  return _internal_robot_state();
}
inline void RobotStateResponse::unsafe_arena_set_allocated_robot_state(
    ::bosdyn::api::RobotState* robot_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_state_);
  }
  _impl_.robot_state_ = robot_state;
  if (robot_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotStateResponse.robot_state)
}
inline ::bosdyn::api::RobotState* RobotStateResponse::release_robot_state() {
  
  ::bosdyn::api::RobotState* temp = _impl_.robot_state_;
  _impl_.robot_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RobotState* RobotStateResponse::unsafe_arena_release_robot_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotStateResponse.robot_state)
  
  ::bosdyn::api::RobotState* temp = _impl_.robot_state_;
  _impl_.robot_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RobotState* RobotStateResponse::_internal_mutable_robot_state() {
  
  if (_impl_.robot_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RobotState>(GetArenaForAllocation());
    _impl_.robot_state_ = p;
  }
  return _impl_.robot_state_;
}
inline ::bosdyn::api::RobotState* RobotStateResponse::mutable_robot_state() {
  ::bosdyn::api::RobotState* _msg = _internal_mutable_robot_state();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotStateResponse.robot_state)
  return _msg;
}
inline void RobotStateResponse::set_allocated_robot_state(::bosdyn::api::RobotState* robot_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.robot_state_;
  }
  if (robot_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot_state);
    if (message_arena != submessage_arena) {
      robot_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.robot_state_ = robot_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotStateResponse.robot_state)
}

// -------------------------------------------------------------------

// RobotMetricsRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RobotMetricsRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RobotMetricsRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RobotMetricsRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RobotMetricsRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotMetricsRequest.header)
  return _internal_header();
}
inline void RobotMetricsRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotMetricsRequest.header)
}
inline ::bosdyn::api::RequestHeader* RobotMetricsRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotMetricsRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotMetricsRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotMetricsRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* RobotMetricsRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotMetricsRequest.header)
  return _msg;
}
inline void RobotMetricsRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotMetricsRequest.header)
}

// -------------------------------------------------------------------

// RobotMetricsResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RobotMetricsResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RobotMetricsResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RobotMetricsResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RobotMetricsResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotMetricsResponse.header)
  return _internal_header();
}
inline void RobotMetricsResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotMetricsResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RobotMetricsResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotMetricsResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotMetricsResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotMetricsResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* RobotMetricsResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotMetricsResponse.header)
  return _msg;
}
inline void RobotMetricsResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotMetricsResponse.header)
}

// .bosdyn.api.RobotMetrics robot_metrics = 2;
inline bool RobotMetricsResponse::_internal_has_robot_metrics() const {
  return this != internal_default_instance() && _impl_.robot_metrics_ != nullptr;
}
inline bool RobotMetricsResponse::has_robot_metrics() const {
  return _internal_has_robot_metrics();
}
inline void RobotMetricsResponse::clear_robot_metrics() {
  if (GetArenaForAllocation() == nullptr && _impl_.robot_metrics_ != nullptr) {
    delete _impl_.robot_metrics_;
  }
  _impl_.robot_metrics_ = nullptr;
}
inline const ::bosdyn::api::RobotMetrics& RobotMetricsResponse::_internal_robot_metrics() const {
  const ::bosdyn::api::RobotMetrics* p = _impl_.robot_metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RobotMetrics&>(
      ::bosdyn::api::_RobotMetrics_default_instance_);
}
inline const ::bosdyn::api::RobotMetrics& RobotMetricsResponse::robot_metrics() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotMetricsResponse.robot_metrics)
  return _internal_robot_metrics();
}
inline void RobotMetricsResponse::unsafe_arena_set_allocated_robot_metrics(
    ::bosdyn::api::RobotMetrics* robot_metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_metrics_);
  }
  _impl_.robot_metrics_ = robot_metrics;
  if (robot_metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotMetricsResponse.robot_metrics)
}
inline ::bosdyn::api::RobotMetrics* RobotMetricsResponse::release_robot_metrics() {
  
  ::bosdyn::api::RobotMetrics* temp = _impl_.robot_metrics_;
  _impl_.robot_metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RobotMetrics* RobotMetricsResponse::unsafe_arena_release_robot_metrics() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotMetricsResponse.robot_metrics)
  
  ::bosdyn::api::RobotMetrics* temp = _impl_.robot_metrics_;
  _impl_.robot_metrics_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RobotMetrics* RobotMetricsResponse::_internal_mutable_robot_metrics() {
  
  if (_impl_.robot_metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RobotMetrics>(GetArenaForAllocation());
    _impl_.robot_metrics_ = p;
  }
  return _impl_.robot_metrics_;
}
inline ::bosdyn::api::RobotMetrics* RobotMetricsResponse::mutable_robot_metrics() {
  ::bosdyn::api::RobotMetrics* _msg = _internal_mutable_robot_metrics();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotMetricsResponse.robot_metrics)
  return _msg;
}
inline void RobotMetricsResponse::set_allocated_robot_metrics(::bosdyn::api::RobotMetrics* robot_metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.robot_metrics_;
  }
  if (robot_metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot_metrics);
    if (message_arena != submessage_arena) {
      robot_metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_metrics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.robot_metrics_ = robot_metrics;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotMetricsResponse.robot_metrics)
}

// -------------------------------------------------------------------

// RobotHardwareConfigurationRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RobotHardwareConfigurationRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RobotHardwareConfigurationRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RobotHardwareConfigurationRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RobotHardwareConfigurationRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotHardwareConfigurationRequest.header)
  return _internal_header();
}
inline void RobotHardwareConfigurationRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotHardwareConfigurationRequest.header)
}
inline ::bosdyn::api::RequestHeader* RobotHardwareConfigurationRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotHardwareConfigurationRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotHardwareConfigurationRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotHardwareConfigurationRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* RobotHardwareConfigurationRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotHardwareConfigurationRequest.header)
  return _msg;
}
inline void RobotHardwareConfigurationRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotHardwareConfigurationRequest.header)
}

// -------------------------------------------------------------------

// RobotHardwareConfigurationResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RobotHardwareConfigurationResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RobotHardwareConfigurationResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RobotHardwareConfigurationResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RobotHardwareConfigurationResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotHardwareConfigurationResponse.header)
  return _internal_header();
}
inline void RobotHardwareConfigurationResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotHardwareConfigurationResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RobotHardwareConfigurationResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotHardwareConfigurationResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotHardwareConfigurationResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotHardwareConfigurationResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* RobotHardwareConfigurationResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotHardwareConfigurationResponse.header)
  return _msg;
}
inline void RobotHardwareConfigurationResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotHardwareConfigurationResponse.header)
}

// .bosdyn.api.HardwareConfiguration hardware_configuration = 2;
inline bool RobotHardwareConfigurationResponse::_internal_has_hardware_configuration() const {
  return this != internal_default_instance() && _impl_.hardware_configuration_ != nullptr;
}
inline bool RobotHardwareConfigurationResponse::has_hardware_configuration() const {
  return _internal_has_hardware_configuration();
}
inline void RobotHardwareConfigurationResponse::clear_hardware_configuration() {
  if (GetArenaForAllocation() == nullptr && _impl_.hardware_configuration_ != nullptr) {
    delete _impl_.hardware_configuration_;
  }
  _impl_.hardware_configuration_ = nullptr;
}
inline const ::bosdyn::api::HardwareConfiguration& RobotHardwareConfigurationResponse::_internal_hardware_configuration() const {
  const ::bosdyn::api::HardwareConfiguration* p = _impl_.hardware_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::HardwareConfiguration&>(
      ::bosdyn::api::_HardwareConfiguration_default_instance_);
}
inline const ::bosdyn::api::HardwareConfiguration& RobotHardwareConfigurationResponse::hardware_configuration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotHardwareConfigurationResponse.hardware_configuration)
  return _internal_hardware_configuration();
}
inline void RobotHardwareConfigurationResponse::unsafe_arena_set_allocated_hardware_configuration(
    ::bosdyn::api::HardwareConfiguration* hardware_configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hardware_configuration_);
  }
  _impl_.hardware_configuration_ = hardware_configuration;
  if (hardware_configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotHardwareConfigurationResponse.hardware_configuration)
}
inline ::bosdyn::api::HardwareConfiguration* RobotHardwareConfigurationResponse::release_hardware_configuration() {
  
  ::bosdyn::api::HardwareConfiguration* temp = _impl_.hardware_configuration_;
  _impl_.hardware_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::HardwareConfiguration* RobotHardwareConfigurationResponse::unsafe_arena_release_hardware_configuration() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotHardwareConfigurationResponse.hardware_configuration)
  
  ::bosdyn::api::HardwareConfiguration* temp = _impl_.hardware_configuration_;
  _impl_.hardware_configuration_ = nullptr;
  return temp;
}
inline ::bosdyn::api::HardwareConfiguration* RobotHardwareConfigurationResponse::_internal_mutable_hardware_configuration() {
  
  if (_impl_.hardware_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::HardwareConfiguration>(GetArenaForAllocation());
    _impl_.hardware_configuration_ = p;
  }
  return _impl_.hardware_configuration_;
}
inline ::bosdyn::api::HardwareConfiguration* RobotHardwareConfigurationResponse::mutable_hardware_configuration() {
  ::bosdyn::api::HardwareConfiguration* _msg = _internal_mutable_hardware_configuration();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotHardwareConfigurationResponse.hardware_configuration)
  return _msg;
}
inline void RobotHardwareConfigurationResponse::set_allocated_hardware_configuration(::bosdyn::api::HardwareConfiguration* hardware_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hardware_configuration_;
  }
  if (hardware_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hardware_configuration);
    if (message_arena != submessage_arena) {
      hardware_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hardware_configuration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hardware_configuration_ = hardware_configuration;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotHardwareConfigurationResponse.hardware_configuration)
}

// -------------------------------------------------------------------

// RobotLinkModelRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RobotLinkModelRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RobotLinkModelRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RobotLinkModelRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RobotLinkModelRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotLinkModelRequest.header)
  return _internal_header();
}
inline void RobotLinkModelRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotLinkModelRequest.header)
}
inline ::bosdyn::api::RequestHeader* RobotLinkModelRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotLinkModelRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotLinkModelRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotLinkModelRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* RobotLinkModelRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotLinkModelRequest.header)
  return _msg;
}
inline void RobotLinkModelRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotLinkModelRequest.header)
}

// string link_name = 2;
inline void RobotLinkModelRequest::clear_link_name() {
  _impl_.link_name_.ClearToEmpty();
}
inline const std::string& RobotLinkModelRequest::link_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotLinkModelRequest.link_name)
  return _internal_link_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotLinkModelRequest::set_link_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.link_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.RobotLinkModelRequest.link_name)
}
inline std::string* RobotLinkModelRequest::mutable_link_name() {
  std::string* _s = _internal_mutable_link_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotLinkModelRequest.link_name)
  return _s;
}
inline const std::string& RobotLinkModelRequest::_internal_link_name() const {
  return _impl_.link_name_.Get();
}
inline void RobotLinkModelRequest::_internal_set_link_name(const std::string& value) {
  
  _impl_.link_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotLinkModelRequest::_internal_mutable_link_name() {
  
  return _impl_.link_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotLinkModelRequest::release_link_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotLinkModelRequest.link_name)
  return _impl_.link_name_.Release();
}
inline void RobotLinkModelRequest::set_allocated_link_name(std::string* link_name) {
  if (link_name != nullptr) {
    
  } else {
    
  }
  _impl_.link_name_.SetAllocated(link_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.link_name_.IsDefault()) {
    _impl_.link_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotLinkModelRequest.link_name)
}

// -------------------------------------------------------------------

// RobotLinkModelResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RobotLinkModelResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RobotLinkModelResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RobotLinkModelResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RobotLinkModelResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotLinkModelResponse.header)
  return _internal_header();
}
inline void RobotLinkModelResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotLinkModelResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RobotLinkModelResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotLinkModelResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotLinkModelResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotLinkModelResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* RobotLinkModelResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotLinkModelResponse.header)
  return _msg;
}
inline void RobotLinkModelResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotLinkModelResponse.header)
}

// .bosdyn.api.Skeleton.Link.ObjModel link_model = 2;
inline bool RobotLinkModelResponse::_internal_has_link_model() const {
  return this != internal_default_instance() && _impl_.link_model_ != nullptr;
}
inline bool RobotLinkModelResponse::has_link_model() const {
  return _internal_has_link_model();
}
inline void RobotLinkModelResponse::clear_link_model() {
  if (GetArenaForAllocation() == nullptr && _impl_.link_model_ != nullptr) {
    delete _impl_.link_model_;
  }
  _impl_.link_model_ = nullptr;
}
inline const ::bosdyn::api::Skeleton_Link_ObjModel& RobotLinkModelResponse::_internal_link_model() const {
  const ::bosdyn::api::Skeleton_Link_ObjModel* p = _impl_.link_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Skeleton_Link_ObjModel&>(
      ::bosdyn::api::_Skeleton_Link_ObjModel_default_instance_);
}
inline const ::bosdyn::api::Skeleton_Link_ObjModel& RobotLinkModelResponse::link_model() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotLinkModelResponse.link_model)
  return _internal_link_model();
}
inline void RobotLinkModelResponse::unsafe_arena_set_allocated_link_model(
    ::bosdyn::api::Skeleton_Link_ObjModel* link_model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.link_model_);
  }
  _impl_.link_model_ = link_model;
  if (link_model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotLinkModelResponse.link_model)
}
inline ::bosdyn::api::Skeleton_Link_ObjModel* RobotLinkModelResponse::release_link_model() {
  
  ::bosdyn::api::Skeleton_Link_ObjModel* temp = _impl_.link_model_;
  _impl_.link_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Skeleton_Link_ObjModel* RobotLinkModelResponse::unsafe_arena_release_link_model() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotLinkModelResponse.link_model)
  
  ::bosdyn::api::Skeleton_Link_ObjModel* temp = _impl_.link_model_;
  _impl_.link_model_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Skeleton_Link_ObjModel* RobotLinkModelResponse::_internal_mutable_link_model() {
  
  if (_impl_.link_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Skeleton_Link_ObjModel>(GetArenaForAllocation());
    _impl_.link_model_ = p;
  }
  return _impl_.link_model_;
}
inline ::bosdyn::api::Skeleton_Link_ObjModel* RobotLinkModelResponse::mutable_link_model() {
  ::bosdyn::api::Skeleton_Link_ObjModel* _msg = _internal_mutable_link_model();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotLinkModelResponse.link_model)
  return _msg;
}
inline void RobotLinkModelResponse::set_allocated_link_model(::bosdyn::api::Skeleton_Link_ObjModel* link_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.link_model_;
  }
  if (link_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(link_model);
    if (message_arena != submessage_arena) {
      link_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link_model, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.link_model_ = link_model;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotLinkModelResponse.link_model)
}

// -------------------------------------------------------------------

// RobotImpairedState

// .bosdyn.api.RobotImpairedState.ImpairedStatus impaired_status = 1;
inline void RobotImpairedState::clear_impaired_status() {
  _impl_.impaired_status_ = 0;
}
inline ::bosdyn::api::RobotImpairedState_ImpairedStatus RobotImpairedState::_internal_impaired_status() const {
  return static_cast< ::bosdyn::api::RobotImpairedState_ImpairedStatus >(_impl_.impaired_status_);
}
inline ::bosdyn::api::RobotImpairedState_ImpairedStatus RobotImpairedState::impaired_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotImpairedState.impaired_status)
  return _internal_impaired_status();
}
inline void RobotImpairedState::_internal_set_impaired_status(::bosdyn::api::RobotImpairedState_ImpairedStatus value) {
  
  _impl_.impaired_status_ = value;
}
inline void RobotImpairedState::set_impaired_status(::bosdyn::api::RobotImpairedState_ImpairedStatus value) {
  _internal_set_impaired_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RobotImpairedState.impaired_status)
}

// repeated .bosdyn.api.SystemFault system_faults = 2;
inline int RobotImpairedState::_internal_system_faults_size() const {
  return _impl_.system_faults_.size();
}
inline int RobotImpairedState::system_faults_size() const {
  return _internal_system_faults_size();
}
inline void RobotImpairedState::clear_system_faults() {
  _impl_.system_faults_.Clear();
}
inline ::bosdyn::api::SystemFault* RobotImpairedState::mutable_system_faults(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotImpairedState.system_faults)
  return _impl_.system_faults_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >*
RobotImpairedState::mutable_system_faults() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RobotImpairedState.system_faults)
  return &_impl_.system_faults_;
}
inline const ::bosdyn::api::SystemFault& RobotImpairedState::_internal_system_faults(int index) const {
  return _impl_.system_faults_.Get(index);
}
inline const ::bosdyn::api::SystemFault& RobotImpairedState::system_faults(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotImpairedState.system_faults)
  return _internal_system_faults(index);
}
inline ::bosdyn::api::SystemFault* RobotImpairedState::_internal_add_system_faults() {
  return _impl_.system_faults_.Add();
}
inline ::bosdyn::api::SystemFault* RobotImpairedState::add_system_faults() {
  ::bosdyn::api::SystemFault* _add = _internal_add_system_faults();
  // @@protoc_insertion_point(field_add:bosdyn.api.RobotImpairedState.system_faults)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >&
RobotImpairedState::system_faults() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RobotImpairedState.system_faults)
  return _impl_.system_faults_;
}

// repeated .bosdyn.api.ServiceFault service_faults = 3;
inline int RobotImpairedState::_internal_service_faults_size() const {
  return _impl_.service_faults_.size();
}
inline int RobotImpairedState::service_faults_size() const {
  return _internal_service_faults_size();
}
inline ::bosdyn::api::ServiceFault* RobotImpairedState::mutable_service_faults(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotImpairedState.service_faults)
  return _impl_.service_faults_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ServiceFault >*
RobotImpairedState::mutable_service_faults() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RobotImpairedState.service_faults)
  return &_impl_.service_faults_;
}
inline const ::bosdyn::api::ServiceFault& RobotImpairedState::_internal_service_faults(int index) const {
  return _impl_.service_faults_.Get(index);
}
inline const ::bosdyn::api::ServiceFault& RobotImpairedState::service_faults(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotImpairedState.service_faults)
  return _internal_service_faults(index);
}
inline ::bosdyn::api::ServiceFault* RobotImpairedState::_internal_add_service_faults() {
  return _impl_.service_faults_.Add();
}
inline ::bosdyn::api::ServiceFault* RobotImpairedState::add_service_faults() {
  ::bosdyn::api::ServiceFault* _add = _internal_add_service_faults();
  // @@protoc_insertion_point(field_add:bosdyn.api.RobotImpairedState.service_faults)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ServiceFault >&
RobotImpairedState::service_faults() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RobotImpairedState.service_faults)
  return _impl_.service_faults_;
}

// repeated .bosdyn.api.BehaviorFault behavior_faults = 4;
inline int RobotImpairedState::_internal_behavior_faults_size() const {
  return _impl_.behavior_faults_.size();
}
inline int RobotImpairedState::behavior_faults_size() const {
  return _internal_behavior_faults_size();
}
inline void RobotImpairedState::clear_behavior_faults() {
  _impl_.behavior_faults_.Clear();
}
inline ::bosdyn::api::BehaviorFault* RobotImpairedState::mutable_behavior_faults(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotImpairedState.behavior_faults)
  return _impl_.behavior_faults_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BehaviorFault >*
RobotImpairedState::mutable_behavior_faults() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RobotImpairedState.behavior_faults)
  return &_impl_.behavior_faults_;
}
inline const ::bosdyn::api::BehaviorFault& RobotImpairedState::_internal_behavior_faults(int index) const {
  return _impl_.behavior_faults_.Get(index);
}
inline const ::bosdyn::api::BehaviorFault& RobotImpairedState::behavior_faults(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotImpairedState.behavior_faults)
  return _internal_behavior_faults(index);
}
inline ::bosdyn::api::BehaviorFault* RobotImpairedState::_internal_add_behavior_faults() {
  return _impl_.behavior_faults_.Add();
}
inline ::bosdyn::api::BehaviorFault* RobotImpairedState::add_behavior_faults() {
  ::bosdyn::api::BehaviorFault* _add = _internal_add_behavior_faults();
  // @@protoc_insertion_point(field_add:bosdyn.api.RobotImpairedState.behavior_faults)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BehaviorFault >&
RobotImpairedState::behavior_faults() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RobotImpairedState.behavior_faults)
  return _impl_.behavior_faults_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::PowerState_MotorPowerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::PowerState_MotorPowerState>() {
  return ::bosdyn::api::PowerState_MotorPowerState_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::PowerState_ShorePowerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::PowerState_ShorePowerState>() {
  return ::bosdyn::api::PowerState_ShorePowerState_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::PowerState_RobotPowerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::PowerState_RobotPowerState>() {
  return ::bosdyn::api::PowerState_RobotPowerState_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::PowerState_PayloadPortsPowerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::PowerState_PayloadPortsPowerState>() {
  return ::bosdyn::api::PowerState_PayloadPortsPowerState_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::PowerState_WifiRadioPowerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::PowerState_WifiRadioPowerState>() {
  return ::bosdyn::api::PowerState_WifiRadioPowerState_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::SystemFault_Severity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::SystemFault_Severity>() {
  return ::bosdyn::api::SystemFault_Severity_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::EStopState_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::EStopState_Type>() {
  return ::bosdyn::api::EStopState_Type_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::EStopState_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::EStopState_State>() {
  return ::bosdyn::api::EStopState_State_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::BatteryState_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::BatteryState_Status>() {
  return ::bosdyn::api::BatteryState_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::BehaviorFault_Cause> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::BehaviorFault_Cause>() {
  return ::bosdyn::api::BehaviorFault_Cause_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::BehaviorFault_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::BehaviorFault_Status>() {
  return ::bosdyn::api::BehaviorFault_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::WiFiState_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::WiFiState_Mode>() {
  return ::bosdyn::api::WiFiState_Mode_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::FootState_Contact> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::FootState_Contact>() {
  return ::bosdyn::api::FootState_Contact_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::ManipulatorState_StowState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ManipulatorState_StowState>() {
  return ::bosdyn::api::ManipulatorState_StowState_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::ManipulatorState_CarryState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ManipulatorState_CarryState>() {
  return ::bosdyn::api::ManipulatorState_CarryState_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::RobotImpairedState_ImpairedStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::RobotImpairedState_ImpairedStatus>() {
  return ::bosdyn::api::RobotImpairedState_ImpairedStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2frobot_5fstate_2eproto
