// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/spot/choreography_sequence.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/wrappers.pb.h>
#include "bosdyn/api/geometry.pb.h"
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/lease.pb.h"
#include "bosdyn/api/spot/choreography_params.pb.h"
#include "bosdyn/api/data_chunk.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
namespace bosdyn {
namespace api {
namespace spot {
class AnimateArm;
struct AnimateArmDefaultTypeInternal;
extern AnimateArmDefaultTypeInternal _AnimateArm_default_instance_;
class AnimateArm_HandPose;
struct AnimateArm_HandPoseDefaultTypeInternal;
extern AnimateArm_HandPoseDefaultTypeInternal _AnimateArm_HandPose_default_instance_;
class AnimateBody;
struct AnimateBodyDefaultTypeInternal;
extern AnimateBodyDefaultTypeInternal _AnimateBody_default_instance_;
class AnimateGripper;
struct AnimateGripperDefaultTypeInternal;
extern AnimateGripperDefaultTypeInternal _AnimateGripper_default_instance_;
class AnimateLegs;
struct AnimateLegsDefaultTypeInternal;
extern AnimateLegsDefaultTypeInternal _AnimateLegs_default_instance_;
class AnimateSingleLeg;
struct AnimateSingleLegDefaultTypeInternal;
extern AnimateSingleLegDefaultTypeInternal _AnimateSingleLeg_default_instance_;
class Animation;
struct AnimationDefaultTypeInternal;
extern AnimationDefaultTypeInternal _Animation_default_instance_;
class AnimationKeyframe;
struct AnimationKeyframeDefaultTypeInternal;
extern AnimationKeyframeDefaultTypeInternal _AnimationKeyframe_default_instance_;
class ArmJointAngles;
struct ArmJointAnglesDefaultTypeInternal;
extern ArmJointAnglesDefaultTypeInternal _ArmJointAngles_default_instance_;
class ChoreographerDisplayInfo;
struct ChoreographerDisplayInfoDefaultTypeInternal;
extern ChoreographerDisplayInfoDefaultTypeInternal _ChoreographerDisplayInfo_default_instance_;
class ChoreographerDisplayInfo_Color;
struct ChoreographerDisplayInfo_ColorDefaultTypeInternal;
extern ChoreographerDisplayInfo_ColorDefaultTypeInternal _ChoreographerDisplayInfo_Color_default_instance_;
class ChoreographerSave;
struct ChoreographerSaveDefaultTypeInternal;
extern ChoreographerSaveDefaultTypeInternal _ChoreographerSave_default_instance_;
class ChoreographyInfo;
struct ChoreographyInfoDefaultTypeInternal;
extern ChoreographyInfoDefaultTypeInternal _ChoreographyInfo_default_instance_;
class ChoreographySequence;
struct ChoreographySequenceDefaultTypeInternal;
extern ChoreographySequenceDefaultTypeInternal _ChoreographySequence_default_instance_;
class ChoreographyStateLog;
struct ChoreographyStateLogDefaultTypeInternal;
extern ChoreographyStateLogDefaultTypeInternal _ChoreographyStateLog_default_instance_;
class ClearAllSequenceFilesRequest;
struct ClearAllSequenceFilesRequestDefaultTypeInternal;
extern ClearAllSequenceFilesRequestDefaultTypeInternal _ClearAllSequenceFilesRequest_default_instance_;
class ClearAllSequenceFilesResponse;
struct ClearAllSequenceFilesResponseDefaultTypeInternal;
extern ClearAllSequenceFilesResponseDefaultTypeInternal _ClearAllSequenceFilesResponse_default_instance_;
class DeleteSequenceRequest;
struct DeleteSequenceRequestDefaultTypeInternal;
extern DeleteSequenceRequestDefaultTypeInternal _DeleteSequenceRequest_default_instance_;
class DeleteSequenceResponse;
struct DeleteSequenceResponseDefaultTypeInternal;
extern DeleteSequenceResponseDefaultTypeInternal _DeleteSequenceResponse_default_instance_;
class DownloadRobotStateLogRequest;
struct DownloadRobotStateLogRequestDefaultTypeInternal;
extern DownloadRobotStateLogRequestDefaultTypeInternal _DownloadRobotStateLogRequest_default_instance_;
class DownloadRobotStateLogResponse;
struct DownloadRobotStateLogResponseDefaultTypeInternal;
extern DownloadRobotStateLogResponseDefaultTypeInternal _DownloadRobotStateLogResponse_default_instance_;
class ExecuteChoreographyRequest;
struct ExecuteChoreographyRequestDefaultTypeInternal;
extern ExecuteChoreographyRequestDefaultTypeInternal _ExecuteChoreographyRequest_default_instance_;
class ExecuteChoreographyResponse;
struct ExecuteChoreographyResponseDefaultTypeInternal;
extern ExecuteChoreographyResponseDefaultTypeInternal _ExecuteChoreographyResponse_default_instance_;
class LegJointAngles;
struct LegJointAnglesDefaultTypeInternal;
extern LegJointAnglesDefaultTypeInternal _LegJointAngles_default_instance_;
class ListAllMovesRequest;
struct ListAllMovesRequestDefaultTypeInternal;
extern ListAllMovesRequestDefaultTypeInternal _ListAllMovesRequest_default_instance_;
class ListAllMovesResponse;
struct ListAllMovesResponseDefaultTypeInternal;
extern ListAllMovesResponseDefaultTypeInternal _ListAllMovesResponse_default_instance_;
class ListAllSequencesRequest;
struct ListAllSequencesRequestDefaultTypeInternal;
extern ListAllSequencesRequestDefaultTypeInternal _ListAllSequencesRequest_default_instance_;
class ListAllSequencesResponse;
struct ListAllSequencesResponseDefaultTypeInternal;
extern ListAllSequencesResponseDefaultTypeInternal _ListAllSequencesResponse_default_instance_;
class LoggedFootContacts;
struct LoggedFootContactsDefaultTypeInternal;
extern LoggedFootContactsDefaultTypeInternal _LoggedFootContacts_default_instance_;
class LoggedJoints;
struct LoggedJointsDefaultTypeInternal;
extern LoggedJointsDefaultTypeInternal _LoggedJoints_default_instance_;
class LoggedStateKeyFrame;
struct LoggedStateKeyFrameDefaultTypeInternal;
extern LoggedStateKeyFrameDefaultTypeInternal _LoggedStateKeyFrame_default_instance_;
class ModifyChoreographyInfoRequest;
struct ModifyChoreographyInfoRequestDefaultTypeInternal;
extern ModifyChoreographyInfoRequestDefaultTypeInternal _ModifyChoreographyInfoRequest_default_instance_;
class ModifyChoreographyInfoResponse;
struct ModifyChoreographyInfoResponseDefaultTypeInternal;
extern ModifyChoreographyInfoResponseDefaultTypeInternal _ModifyChoreographyInfoResponse_default_instance_;
class MoveInfo;
struct MoveInfoDefaultTypeInternal;
extern MoveInfoDefaultTypeInternal _MoveInfo_default_instance_;
class MoveParams;
struct MoveParamsDefaultTypeInternal;
extern MoveParamsDefaultTypeInternal _MoveParams_default_instance_;
class SaveSequenceRequest;
struct SaveSequenceRequestDefaultTypeInternal;
extern SaveSequenceRequestDefaultTypeInternal _SaveSequenceRequest_default_instance_;
class SaveSequenceResponse;
struct SaveSequenceResponseDefaultTypeInternal;
extern SaveSequenceResponseDefaultTypeInternal _SaveSequenceResponse_default_instance_;
class SequenceInfo;
struct SequenceInfoDefaultTypeInternal;
extern SequenceInfoDefaultTypeInternal _SequenceInfo_default_instance_;
class StartRecordingStateRequest;
struct StartRecordingStateRequestDefaultTypeInternal;
extern StartRecordingStateRequestDefaultTypeInternal _StartRecordingStateRequest_default_instance_;
class StartRecordingStateResponse;
struct StartRecordingStateResponseDefaultTypeInternal;
extern StartRecordingStateResponseDefaultTypeInternal _StartRecordingStateResponse_default_instance_;
class StopRecordingStateRequest;
struct StopRecordingStateRequestDefaultTypeInternal;
extern StopRecordingStateRequestDefaultTypeInternal _StopRecordingStateRequest_default_instance_;
class StopRecordingStateResponse;
struct StopRecordingStateResponseDefaultTypeInternal;
extern StopRecordingStateResponseDefaultTypeInternal _StopRecordingStateResponse_default_instance_;
class UploadAnimatedMoveRequest;
struct UploadAnimatedMoveRequestDefaultTypeInternal;
extern UploadAnimatedMoveRequestDefaultTypeInternal _UploadAnimatedMoveRequest_default_instance_;
class UploadAnimatedMoveResponse;
struct UploadAnimatedMoveResponseDefaultTypeInternal;
extern UploadAnimatedMoveResponseDefaultTypeInternal _UploadAnimatedMoveResponse_default_instance_;
class UploadChoreographyRequest;
struct UploadChoreographyRequestDefaultTypeInternal;
extern UploadChoreographyRequestDefaultTypeInternal _UploadChoreographyRequest_default_instance_;
class UploadChoreographyResponse;
struct UploadChoreographyResponseDefaultTypeInternal;
extern UploadChoreographyResponseDefaultTypeInternal _UploadChoreographyResponse_default_instance_;
}  // namespace spot
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::spot::AnimateArm* Arena::CreateMaybeMessage<::bosdyn::api::spot::AnimateArm>(Arena*);
template<> ::bosdyn::api::spot::AnimateArm_HandPose* Arena::CreateMaybeMessage<::bosdyn::api::spot::AnimateArm_HandPose>(Arena*);
template<> ::bosdyn::api::spot::AnimateBody* Arena::CreateMaybeMessage<::bosdyn::api::spot::AnimateBody>(Arena*);
template<> ::bosdyn::api::spot::AnimateGripper* Arena::CreateMaybeMessage<::bosdyn::api::spot::AnimateGripper>(Arena*);
template<> ::bosdyn::api::spot::AnimateLegs* Arena::CreateMaybeMessage<::bosdyn::api::spot::AnimateLegs>(Arena*);
template<> ::bosdyn::api::spot::AnimateSingleLeg* Arena::CreateMaybeMessage<::bosdyn::api::spot::AnimateSingleLeg>(Arena*);
template<> ::bosdyn::api::spot::Animation* Arena::CreateMaybeMessage<::bosdyn::api::spot::Animation>(Arena*);
template<> ::bosdyn::api::spot::AnimationKeyframe* Arena::CreateMaybeMessage<::bosdyn::api::spot::AnimationKeyframe>(Arena*);
template<> ::bosdyn::api::spot::ArmJointAngles* Arena::CreateMaybeMessage<::bosdyn::api::spot::ArmJointAngles>(Arena*);
template<> ::bosdyn::api::spot::ChoreographerDisplayInfo* Arena::CreateMaybeMessage<::bosdyn::api::spot::ChoreographerDisplayInfo>(Arena*);
template<> ::bosdyn::api::spot::ChoreographerDisplayInfo_Color* Arena::CreateMaybeMessage<::bosdyn::api::spot::ChoreographerDisplayInfo_Color>(Arena*);
template<> ::bosdyn::api::spot::ChoreographerSave* Arena::CreateMaybeMessage<::bosdyn::api::spot::ChoreographerSave>(Arena*);
template<> ::bosdyn::api::spot::ChoreographyInfo* Arena::CreateMaybeMessage<::bosdyn::api::spot::ChoreographyInfo>(Arena*);
template<> ::bosdyn::api::spot::ChoreographySequence* Arena::CreateMaybeMessage<::bosdyn::api::spot::ChoreographySequence>(Arena*);
template<> ::bosdyn::api::spot::ChoreographyStateLog* Arena::CreateMaybeMessage<::bosdyn::api::spot::ChoreographyStateLog>(Arena*);
template<> ::bosdyn::api::spot::ClearAllSequenceFilesRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::ClearAllSequenceFilesRequest>(Arena*);
template<> ::bosdyn::api::spot::ClearAllSequenceFilesResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::ClearAllSequenceFilesResponse>(Arena*);
template<> ::bosdyn::api::spot::DeleteSequenceRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::DeleteSequenceRequest>(Arena*);
template<> ::bosdyn::api::spot::DeleteSequenceResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::DeleteSequenceResponse>(Arena*);
template<> ::bosdyn::api::spot::DownloadRobotStateLogRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::DownloadRobotStateLogRequest>(Arena*);
template<> ::bosdyn::api::spot::DownloadRobotStateLogResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::DownloadRobotStateLogResponse>(Arena*);
template<> ::bosdyn::api::spot::ExecuteChoreographyRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::ExecuteChoreographyRequest>(Arena*);
template<> ::bosdyn::api::spot::ExecuteChoreographyResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::ExecuteChoreographyResponse>(Arena*);
template<> ::bosdyn::api::spot::LegJointAngles* Arena::CreateMaybeMessage<::bosdyn::api::spot::LegJointAngles>(Arena*);
template<> ::bosdyn::api::spot::ListAllMovesRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::ListAllMovesRequest>(Arena*);
template<> ::bosdyn::api::spot::ListAllMovesResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::ListAllMovesResponse>(Arena*);
template<> ::bosdyn::api::spot::ListAllSequencesRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::ListAllSequencesRequest>(Arena*);
template<> ::bosdyn::api::spot::ListAllSequencesResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::ListAllSequencesResponse>(Arena*);
template<> ::bosdyn::api::spot::LoggedFootContacts* Arena::CreateMaybeMessage<::bosdyn::api::spot::LoggedFootContacts>(Arena*);
template<> ::bosdyn::api::spot::LoggedJoints* Arena::CreateMaybeMessage<::bosdyn::api::spot::LoggedJoints>(Arena*);
template<> ::bosdyn::api::spot::LoggedStateKeyFrame* Arena::CreateMaybeMessage<::bosdyn::api::spot::LoggedStateKeyFrame>(Arena*);
template<> ::bosdyn::api::spot::ModifyChoreographyInfoRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::ModifyChoreographyInfoRequest>(Arena*);
template<> ::bosdyn::api::spot::ModifyChoreographyInfoResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::ModifyChoreographyInfoResponse>(Arena*);
template<> ::bosdyn::api::spot::MoveInfo* Arena::CreateMaybeMessage<::bosdyn::api::spot::MoveInfo>(Arena*);
template<> ::bosdyn::api::spot::MoveParams* Arena::CreateMaybeMessage<::bosdyn::api::spot::MoveParams>(Arena*);
template<> ::bosdyn::api::spot::SaveSequenceRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::SaveSequenceRequest>(Arena*);
template<> ::bosdyn::api::spot::SaveSequenceResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::SaveSequenceResponse>(Arena*);
template<> ::bosdyn::api::spot::SequenceInfo* Arena::CreateMaybeMessage<::bosdyn::api::spot::SequenceInfo>(Arena*);
template<> ::bosdyn::api::spot::StartRecordingStateRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::StartRecordingStateRequest>(Arena*);
template<> ::bosdyn::api::spot::StartRecordingStateResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::StartRecordingStateResponse>(Arena*);
template<> ::bosdyn::api::spot::StopRecordingStateRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::StopRecordingStateRequest>(Arena*);
template<> ::bosdyn::api::spot::StopRecordingStateResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::StopRecordingStateResponse>(Arena*);
template<> ::bosdyn::api::spot::UploadAnimatedMoveRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::UploadAnimatedMoveRequest>(Arena*);
template<> ::bosdyn::api::spot::UploadAnimatedMoveResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::UploadAnimatedMoveResponse>(Arena*);
template<> ::bosdyn::api::spot::UploadChoreographyRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::UploadChoreographyRequest>(Arena*);
template<> ::bosdyn::api::spot::UploadChoreographyResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::UploadChoreographyResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {
namespace spot {

enum SequenceInfo_SavedState : int {
  SequenceInfo_SavedState_SAVED_STATE_UNKNOWN = 0,
  SequenceInfo_SavedState_SAVED_STATE_TEMPORARY = 1,
  SequenceInfo_SavedState_SAVED_STATE_RETAINED = 2,
  SequenceInfo_SavedState_SAVED_STATE_PERMANENT = 3,
  SequenceInfo_SavedState_SequenceInfo_SavedState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SequenceInfo_SavedState_SequenceInfo_SavedState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SequenceInfo_SavedState_IsValid(int value);
constexpr SequenceInfo_SavedState SequenceInfo_SavedState_SavedState_MIN = SequenceInfo_SavedState_SAVED_STATE_UNKNOWN;
constexpr SequenceInfo_SavedState SequenceInfo_SavedState_SavedState_MAX = SequenceInfo_SavedState_SAVED_STATE_PERMANENT;
constexpr int SequenceInfo_SavedState_SavedState_ARRAYSIZE = SequenceInfo_SavedState_SavedState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SequenceInfo_SavedState_descriptor();
template<typename T>
inline const std::string& SequenceInfo_SavedState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SequenceInfo_SavedState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SequenceInfo_SavedState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SequenceInfo_SavedState_descriptor(), enum_t_value);
}
inline bool SequenceInfo_SavedState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SequenceInfo_SavedState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SequenceInfo_SavedState>(
    SequenceInfo_SavedState_descriptor(), name, value);
}
enum DeleteSequenceResponse_Status : int {
  DeleteSequenceResponse_Status_STATUS_UNKNOWN = 0,
  DeleteSequenceResponse_Status_STATUS_OK = 1,
  DeleteSequenceResponse_Status_STATUS_UNKNOWN_SEQUENCE = 2,
  DeleteSequenceResponse_Status_STATUS_ALREADY_TEMPORARY = 3,
  DeleteSequenceResponse_Status_STATUS_PERMANENT_SEQUENCE = 4,
  DeleteSequenceResponse_Status_DeleteSequenceResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DeleteSequenceResponse_Status_DeleteSequenceResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DeleteSequenceResponse_Status_IsValid(int value);
constexpr DeleteSequenceResponse_Status DeleteSequenceResponse_Status_Status_MIN = DeleteSequenceResponse_Status_STATUS_UNKNOWN;
constexpr DeleteSequenceResponse_Status DeleteSequenceResponse_Status_Status_MAX = DeleteSequenceResponse_Status_STATUS_PERMANENT_SEQUENCE;
constexpr int DeleteSequenceResponse_Status_Status_ARRAYSIZE = DeleteSequenceResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeleteSequenceResponse_Status_descriptor();
template<typename T>
inline const std::string& DeleteSequenceResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeleteSequenceResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeleteSequenceResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeleteSequenceResponse_Status_descriptor(), enum_t_value);
}
inline bool DeleteSequenceResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeleteSequenceResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeleteSequenceResponse_Status>(
    DeleteSequenceResponse_Status_descriptor(), name, value);
}
enum SaveSequenceResponse_Status : int {
  SaveSequenceResponse_Status_STATUS_UNKNOWN = 0,
  SaveSequenceResponse_Status_STATUS_OK = 1,
  SaveSequenceResponse_Status_STATUS_UNKNOWN_SEQUENCE = 2,
  SaveSequenceResponse_Status_STATUS_PERMANENT_SEQUENCE = 3,
  SaveSequenceResponse_Status_STATUS_FAILED_TO_SAVE = 4,
  SaveSequenceResponse_Status_SaveSequenceResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SaveSequenceResponse_Status_SaveSequenceResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SaveSequenceResponse_Status_IsValid(int value);
constexpr SaveSequenceResponse_Status SaveSequenceResponse_Status_Status_MIN = SaveSequenceResponse_Status_STATUS_UNKNOWN;
constexpr SaveSequenceResponse_Status SaveSequenceResponse_Status_Status_MAX = SaveSequenceResponse_Status_STATUS_FAILED_TO_SAVE;
constexpr int SaveSequenceResponse_Status_Status_ARRAYSIZE = SaveSequenceResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SaveSequenceResponse_Status_descriptor();
template<typename T>
inline const std::string& SaveSequenceResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SaveSequenceResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SaveSequenceResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SaveSequenceResponse_Status_descriptor(), enum_t_value);
}
inline bool SaveSequenceResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SaveSequenceResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SaveSequenceResponse_Status>(
    SaveSequenceResponse_Status_descriptor(), name, value);
}
enum ModifyChoreographyInfoResponse_Status : int {
  ModifyChoreographyInfoResponse_Status_STATUS_UNKNOWN = 0,
  ModifyChoreographyInfoResponse_Status_STATUS_OK = 1,
  ModifyChoreographyInfoResponse_Status_STATUS_UNKNOWN_SEQUENCE = 2,
  ModifyChoreographyInfoResponse_Status_STATUS_PERMANENT_SEQUENCE = 3,
  ModifyChoreographyInfoResponse_Status_STATUS_FAILED_TO_UPDATE = 4,
  ModifyChoreographyInfoResponse_Status_ModifyChoreographyInfoResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModifyChoreographyInfoResponse_Status_ModifyChoreographyInfoResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModifyChoreographyInfoResponse_Status_IsValid(int value);
constexpr ModifyChoreographyInfoResponse_Status ModifyChoreographyInfoResponse_Status_Status_MIN = ModifyChoreographyInfoResponse_Status_STATUS_UNKNOWN;
constexpr ModifyChoreographyInfoResponse_Status ModifyChoreographyInfoResponse_Status_Status_MAX = ModifyChoreographyInfoResponse_Status_STATUS_FAILED_TO_UPDATE;
constexpr int ModifyChoreographyInfoResponse_Status_Status_ARRAYSIZE = ModifyChoreographyInfoResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModifyChoreographyInfoResponse_Status_descriptor();
template<typename T>
inline const std::string& ModifyChoreographyInfoResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModifyChoreographyInfoResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModifyChoreographyInfoResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModifyChoreographyInfoResponse_Status_descriptor(), enum_t_value);
}
inline bool ModifyChoreographyInfoResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModifyChoreographyInfoResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModifyChoreographyInfoResponse_Status>(
    ModifyChoreographyInfoResponse_Status_descriptor(), name, value);
}
enum ClearAllSequenceFilesResponse_Status : int {
  ClearAllSequenceFilesResponse_Status_STATUS_UNKNOWN = 0,
  ClearAllSequenceFilesResponse_Status_STATUS_OK = 1,
  ClearAllSequenceFilesResponse_Status_STATUS_FAILED_TO_DELETE = 2,
  ClearAllSequenceFilesResponse_Status_ClearAllSequenceFilesResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ClearAllSequenceFilesResponse_Status_ClearAllSequenceFilesResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ClearAllSequenceFilesResponse_Status_IsValid(int value);
constexpr ClearAllSequenceFilesResponse_Status ClearAllSequenceFilesResponse_Status_Status_MIN = ClearAllSequenceFilesResponse_Status_STATUS_UNKNOWN;
constexpr ClearAllSequenceFilesResponse_Status ClearAllSequenceFilesResponse_Status_Status_MAX = ClearAllSequenceFilesResponse_Status_STATUS_FAILED_TO_DELETE;
constexpr int ClearAllSequenceFilesResponse_Status_Status_ARRAYSIZE = ClearAllSequenceFilesResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClearAllSequenceFilesResponse_Status_descriptor();
template<typename T>
inline const std::string& ClearAllSequenceFilesResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClearAllSequenceFilesResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClearAllSequenceFilesResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClearAllSequenceFilesResponse_Status_descriptor(), enum_t_value);
}
inline bool ClearAllSequenceFilesResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClearAllSequenceFilesResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClearAllSequenceFilesResponse_Status>(
    ClearAllSequenceFilesResponse_Status_descriptor(), name, value);
}
enum UploadAnimatedMoveResponse_Status : int {
  UploadAnimatedMoveResponse_Status_STATUS_UNKNOWN = 0,
  UploadAnimatedMoveResponse_Status_STATUS_OK = 1,
  UploadAnimatedMoveResponse_Status_STATUS_ANIMATION_VALIDATION_FAILED = 2,
  UploadAnimatedMoveResponse_Status_STATUS_PING_RESPONSE = 3,
  UploadAnimatedMoveResponse_Status_UploadAnimatedMoveResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UploadAnimatedMoveResponse_Status_UploadAnimatedMoveResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UploadAnimatedMoveResponse_Status_IsValid(int value);
constexpr UploadAnimatedMoveResponse_Status UploadAnimatedMoveResponse_Status_Status_MIN = UploadAnimatedMoveResponse_Status_STATUS_UNKNOWN;
constexpr UploadAnimatedMoveResponse_Status UploadAnimatedMoveResponse_Status_Status_MAX = UploadAnimatedMoveResponse_Status_STATUS_PING_RESPONSE;
constexpr int UploadAnimatedMoveResponse_Status_Status_ARRAYSIZE = UploadAnimatedMoveResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UploadAnimatedMoveResponse_Status_descriptor();
template<typename T>
inline const std::string& UploadAnimatedMoveResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UploadAnimatedMoveResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UploadAnimatedMoveResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UploadAnimatedMoveResponse_Status_descriptor(), enum_t_value);
}
inline bool UploadAnimatedMoveResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UploadAnimatedMoveResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UploadAnimatedMoveResponse_Status>(
    UploadAnimatedMoveResponse_Status_descriptor(), name, value);
}
enum ExecuteChoreographyResponse_Status : int {
  ExecuteChoreographyResponse_Status_STATUS_UNKNOWN = 0,
  ExecuteChoreographyResponse_Status_STATUS_OK = 1,
  ExecuteChoreographyResponse_Status_STATUS_INVALID_UPLOADED_CHOREOGRAPHY = 2,
  ExecuteChoreographyResponse_Status_STATUS_ROBOT_COMMAND_ISSUES = 3,
  ExecuteChoreographyResponse_Status_STATUS_LEASE_ERROR = 4,
  ExecuteChoreographyResponse_Status_ExecuteChoreographyResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ExecuteChoreographyResponse_Status_ExecuteChoreographyResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ExecuteChoreographyResponse_Status_IsValid(int value);
constexpr ExecuteChoreographyResponse_Status ExecuteChoreographyResponse_Status_Status_MIN = ExecuteChoreographyResponse_Status_STATUS_UNKNOWN;
constexpr ExecuteChoreographyResponse_Status ExecuteChoreographyResponse_Status_Status_MAX = ExecuteChoreographyResponse_Status_STATUS_LEASE_ERROR;
constexpr int ExecuteChoreographyResponse_Status_Status_ARRAYSIZE = ExecuteChoreographyResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExecuteChoreographyResponse_Status_descriptor();
template<typename T>
inline const std::string& ExecuteChoreographyResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExecuteChoreographyResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExecuteChoreographyResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExecuteChoreographyResponse_Status_descriptor(), enum_t_value);
}
inline bool ExecuteChoreographyResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExecuteChoreographyResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExecuteChoreographyResponse_Status>(
    ExecuteChoreographyResponse_Status_descriptor(), name, value);
}
enum StartRecordingStateResponse_Status : int {
  StartRecordingStateResponse_Status_STATUS_UNKNOWN = 0,
  StartRecordingStateResponse_Status_STATUS_OK = 1,
  StartRecordingStateResponse_Status_STATUS_UNKNOWN_RECORDING_SESSION_ID = 2,
  StartRecordingStateResponse_Status_STATUS_RECORDING_BUFFER_FULL = 3,
  StartRecordingStateResponse_Status_StartRecordingStateResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StartRecordingStateResponse_Status_StartRecordingStateResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StartRecordingStateResponse_Status_IsValid(int value);
constexpr StartRecordingStateResponse_Status StartRecordingStateResponse_Status_Status_MIN = StartRecordingStateResponse_Status_STATUS_UNKNOWN;
constexpr StartRecordingStateResponse_Status StartRecordingStateResponse_Status_Status_MAX = StartRecordingStateResponse_Status_STATUS_RECORDING_BUFFER_FULL;
constexpr int StartRecordingStateResponse_Status_Status_ARRAYSIZE = StartRecordingStateResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StartRecordingStateResponse_Status_descriptor();
template<typename T>
inline const std::string& StartRecordingStateResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StartRecordingStateResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StartRecordingStateResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StartRecordingStateResponse_Status_descriptor(), enum_t_value);
}
inline bool StartRecordingStateResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StartRecordingStateResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StartRecordingStateResponse_Status>(
    StartRecordingStateResponse_Status_descriptor(), name, value);
}
enum DownloadRobotStateLogRequest_LogType : int {
  DownloadRobotStateLogRequest_LogType_LOG_TYPE_UNKNOWN = 0,
  DownloadRobotStateLogRequest_LogType_LOG_TYPE_MANUAL = 1,
  DownloadRobotStateLogRequest_LogType_LOG_TYPE_LAST_CHOREOGRAPHY = 2,
  DownloadRobotStateLogRequest_LogType_DownloadRobotStateLogRequest_LogType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DownloadRobotStateLogRequest_LogType_DownloadRobotStateLogRequest_LogType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DownloadRobotStateLogRequest_LogType_IsValid(int value);
constexpr DownloadRobotStateLogRequest_LogType DownloadRobotStateLogRequest_LogType_LogType_MIN = DownloadRobotStateLogRequest_LogType_LOG_TYPE_UNKNOWN;
constexpr DownloadRobotStateLogRequest_LogType DownloadRobotStateLogRequest_LogType_LogType_MAX = DownloadRobotStateLogRequest_LogType_LOG_TYPE_LAST_CHOREOGRAPHY;
constexpr int DownloadRobotStateLogRequest_LogType_LogType_ARRAYSIZE = DownloadRobotStateLogRequest_LogType_LogType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DownloadRobotStateLogRequest_LogType_descriptor();
template<typename T>
inline const std::string& DownloadRobotStateLogRequest_LogType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DownloadRobotStateLogRequest_LogType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DownloadRobotStateLogRequest_LogType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DownloadRobotStateLogRequest_LogType_descriptor(), enum_t_value);
}
inline bool DownloadRobotStateLogRequest_LogType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DownloadRobotStateLogRequest_LogType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DownloadRobotStateLogRequest_LogType>(
    DownloadRobotStateLogRequest_LogType_descriptor(), name, value);
}
enum DownloadRobotStateLogResponse_Status : int {
  DownloadRobotStateLogResponse_Status_STATUS_UNKNOWN = 0,
  DownloadRobotStateLogResponse_Status_STATUS_OK = 1,
  DownloadRobotStateLogResponse_Status_STATUS_NO_RECORDED_INFORMATION = 2,
  DownloadRobotStateLogResponse_Status_STATUS_INCOMPLETE_DATA = 3,
  DownloadRobotStateLogResponse_Status_DownloadRobotStateLogResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DownloadRobotStateLogResponse_Status_DownloadRobotStateLogResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DownloadRobotStateLogResponse_Status_IsValid(int value);
constexpr DownloadRobotStateLogResponse_Status DownloadRobotStateLogResponse_Status_Status_MIN = DownloadRobotStateLogResponse_Status_STATUS_UNKNOWN;
constexpr DownloadRobotStateLogResponse_Status DownloadRobotStateLogResponse_Status_Status_MAX = DownloadRobotStateLogResponse_Status_STATUS_INCOMPLETE_DATA;
constexpr int DownloadRobotStateLogResponse_Status_Status_ARRAYSIZE = DownloadRobotStateLogResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DownloadRobotStateLogResponse_Status_descriptor();
template<typename T>
inline const std::string& DownloadRobotStateLogResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DownloadRobotStateLogResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DownloadRobotStateLogResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DownloadRobotStateLogResponse_Status_descriptor(), enum_t_value);
}
inline bool DownloadRobotStateLogResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DownloadRobotStateLogResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DownloadRobotStateLogResponse_Status>(
    DownloadRobotStateLogResponse_Status_descriptor(), name, value);
}
enum MoveInfo_TransitionState : int {
  MoveInfo_TransitionState_TRANSITION_STATE_UNKNOWN = 0,
  MoveInfo_TransitionState_TRANSITION_STATE_STAND = 1,
  MoveInfo_TransitionState_TRANSITION_STATE_KNEEL = 2,
  MoveInfo_TransitionState_TRANSITION_STATE_SIT = 3,
  MoveInfo_TransitionState_TRANSITION_STATE_SPRAWL = 4,
  MoveInfo_TransitionState_MoveInfo_TransitionState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MoveInfo_TransitionState_MoveInfo_TransitionState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MoveInfo_TransitionState_IsValid(int value);
constexpr MoveInfo_TransitionState MoveInfo_TransitionState_TransitionState_MIN = MoveInfo_TransitionState_TRANSITION_STATE_UNKNOWN;
constexpr MoveInfo_TransitionState MoveInfo_TransitionState_TransitionState_MAX = MoveInfo_TransitionState_TRANSITION_STATE_SPRAWL;
constexpr int MoveInfo_TransitionState_TransitionState_ARRAYSIZE = MoveInfo_TransitionState_TransitionState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MoveInfo_TransitionState_descriptor();
template<typename T>
inline const std::string& MoveInfo_TransitionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MoveInfo_TransitionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MoveInfo_TransitionState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MoveInfo_TransitionState_descriptor(), enum_t_value);
}
inline bool MoveInfo_TransitionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MoveInfo_TransitionState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MoveInfo_TransitionState>(
    MoveInfo_TransitionState_descriptor(), name, value);
}
enum ChoreographerDisplayInfo_Category : int {
  ChoreographerDisplayInfo_Category_CATEGORY_UNKNOWN = 0,
  ChoreographerDisplayInfo_Category_CATEGORY_BODY = 1,
  ChoreographerDisplayInfo_Category_CATEGORY_STEP = 2,
  ChoreographerDisplayInfo_Category_CATEGORY_DYNAMIC = 3,
  ChoreographerDisplayInfo_Category_CATEGORY_TRANSITION = 4,
  ChoreographerDisplayInfo_Category_CATEGORY_KNEEL = 5,
  ChoreographerDisplayInfo_Category_CATEGORY_ARM = 6,
  ChoreographerDisplayInfo_Category_CATEGORY_ANIMATION = 7,
  ChoreographerDisplayInfo_Category_CATEGORY_MPC = 8,
  ChoreographerDisplayInfo_Category_CATEGORY_LIGHTS = 9,
  ChoreographerDisplayInfo_Category_CATEGORY_ANNOTATIONS = 10,
  ChoreographerDisplayInfo_Category_ChoreographerDisplayInfo_Category_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChoreographerDisplayInfo_Category_ChoreographerDisplayInfo_Category_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChoreographerDisplayInfo_Category_IsValid(int value);
constexpr ChoreographerDisplayInfo_Category ChoreographerDisplayInfo_Category_Category_MIN = ChoreographerDisplayInfo_Category_CATEGORY_UNKNOWN;
constexpr ChoreographerDisplayInfo_Category ChoreographerDisplayInfo_Category_Category_MAX = ChoreographerDisplayInfo_Category_CATEGORY_ANNOTATIONS;
constexpr int ChoreographerDisplayInfo_Category_Category_ARRAYSIZE = ChoreographerDisplayInfo_Category_Category_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChoreographerDisplayInfo_Category_descriptor();
template<typename T>
inline const std::string& ChoreographerDisplayInfo_Category_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChoreographerDisplayInfo_Category>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChoreographerDisplayInfo_Category_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChoreographerDisplayInfo_Category_descriptor(), enum_t_value);
}
inline bool ChoreographerDisplayInfo_Category_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChoreographerDisplayInfo_Category* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChoreographerDisplayInfo_Category>(
    ChoreographerDisplayInfo_Category_descriptor(), name, value);
}
enum Animation_ArmPlayback : int {
  Animation_ArmPlayback_ARM_PLAYBACK_DEFAULT = 0,
  Animation_ArmPlayback_ARM_PLAYBACK_JOINTSPACE = 1,
  Animation_ArmPlayback_ARM_PLAYBACK_WORKSPACE = 2,
  Animation_ArmPlayback_ARM_PLAYBACK_WORKSPACE_DANCE_FRAME = 3,
  Animation_ArmPlayback_Animation_ArmPlayback_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Animation_ArmPlayback_Animation_ArmPlayback_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Animation_ArmPlayback_IsValid(int value);
constexpr Animation_ArmPlayback Animation_ArmPlayback_ArmPlayback_MIN = Animation_ArmPlayback_ARM_PLAYBACK_DEFAULT;
constexpr Animation_ArmPlayback Animation_ArmPlayback_ArmPlayback_MAX = Animation_ArmPlayback_ARM_PLAYBACK_WORKSPACE_DANCE_FRAME;
constexpr int Animation_ArmPlayback_ArmPlayback_ARRAYSIZE = Animation_ArmPlayback_ArmPlayback_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Animation_ArmPlayback_descriptor();
template<typename T>
inline const std::string& Animation_ArmPlayback_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Animation_ArmPlayback>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Animation_ArmPlayback_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Animation_ArmPlayback_descriptor(), enum_t_value);
}
inline bool Animation_ArmPlayback_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Animation_ArmPlayback* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Animation_ArmPlayback>(
    Animation_ArmPlayback_descriptor(), name, value);
}
// ===================================================================

class ListAllMovesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ListAllMovesRequest) */ {
 public:
  inline ListAllMovesRequest() : ListAllMovesRequest(nullptr) {}
  ~ListAllMovesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListAllMovesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListAllMovesRequest(const ListAllMovesRequest& from);
  ListAllMovesRequest(ListAllMovesRequest&& from) noexcept
    : ListAllMovesRequest() {
    *this = ::std::move(from);
  }

  inline ListAllMovesRequest& operator=(const ListAllMovesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAllMovesRequest& operator=(ListAllMovesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAllMovesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAllMovesRequest* internal_default_instance() {
    return reinterpret_cast<const ListAllMovesRequest*>(
               &_ListAllMovesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ListAllMovesRequest& a, ListAllMovesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAllMovesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAllMovesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAllMovesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAllMovesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListAllMovesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListAllMovesRequest& from) {
    ListAllMovesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAllMovesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ListAllMovesRequest";
  }
  protected:
  explicit ListAllMovesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ListAllMovesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class ListAllMovesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ListAllMovesResponse) */ {
 public:
  inline ListAllMovesResponse() : ListAllMovesResponse(nullptr) {}
  ~ListAllMovesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListAllMovesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListAllMovesResponse(const ListAllMovesResponse& from);
  ListAllMovesResponse(ListAllMovesResponse&& from) noexcept
    : ListAllMovesResponse() {
    *this = ::std::move(from);
  }

  inline ListAllMovesResponse& operator=(const ListAllMovesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAllMovesResponse& operator=(ListAllMovesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAllMovesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAllMovesResponse* internal_default_instance() {
    return reinterpret_cast<const ListAllMovesResponse*>(
               &_ListAllMovesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ListAllMovesResponse& a, ListAllMovesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAllMovesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAllMovesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAllMovesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAllMovesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListAllMovesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListAllMovesResponse& from) {
    ListAllMovesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAllMovesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ListAllMovesResponse";
  }
  protected:
  explicit ListAllMovesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMovesFieldNumber = 2,
    kMoveParamConfigFieldNumber = 3,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.spot.MoveInfo moves = 2;
  int moves_size() const;
  private:
  int _internal_moves_size() const;
  public:
  void clear_moves();
  ::bosdyn::api::spot::MoveInfo* mutable_moves(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::MoveInfo >*
      mutable_moves();
  private:
  const ::bosdyn::api::spot::MoveInfo& _internal_moves(int index) const;
  ::bosdyn::api::spot::MoveInfo* _internal_add_moves();
  public:
  const ::bosdyn::api::spot::MoveInfo& moves(int index) const;
  ::bosdyn::api::spot::MoveInfo* add_moves();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::MoveInfo >&
      moves() const;

  // string move_param_config = 3;
  void clear_move_param_config();
  const std::string& move_param_config() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_move_param_config(ArgT0&& arg0, ArgT... args);
  std::string* mutable_move_param_config();
  PROTOBUF_NODISCARD std::string* release_move_param_config();
  void set_allocated_move_param_config(std::string* move_param_config);
  private:
  const std::string& _internal_move_param_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_move_param_config(const std::string& value);
  std::string* _internal_mutable_move_param_config();
  public:

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ListAllMovesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::MoveInfo > moves_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr move_param_config_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class ListAllSequencesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ListAllSequencesRequest) */ {
 public:
  inline ListAllSequencesRequest() : ListAllSequencesRequest(nullptr) {}
  ~ListAllSequencesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListAllSequencesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListAllSequencesRequest(const ListAllSequencesRequest& from);
  ListAllSequencesRequest(ListAllSequencesRequest&& from) noexcept
    : ListAllSequencesRequest() {
    *this = ::std::move(from);
  }

  inline ListAllSequencesRequest& operator=(const ListAllSequencesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAllSequencesRequest& operator=(ListAllSequencesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAllSequencesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAllSequencesRequest* internal_default_instance() {
    return reinterpret_cast<const ListAllSequencesRequest*>(
               &_ListAllSequencesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ListAllSequencesRequest& a, ListAllSequencesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAllSequencesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAllSequencesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAllSequencesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAllSequencesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListAllSequencesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListAllSequencesRequest& from) {
    ListAllSequencesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAllSequencesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ListAllSequencesRequest";
  }
  protected:
  explicit ListAllSequencesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ListAllSequencesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class ListAllSequencesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ListAllSequencesResponse) */ {
 public:
  inline ListAllSequencesResponse() : ListAllSequencesResponse(nullptr) {}
  ~ListAllSequencesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListAllSequencesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListAllSequencesResponse(const ListAllSequencesResponse& from);
  ListAllSequencesResponse(ListAllSequencesResponse&& from) noexcept
    : ListAllSequencesResponse() {
    *this = ::std::move(from);
  }

  inline ListAllSequencesResponse& operator=(const ListAllSequencesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAllSequencesResponse& operator=(ListAllSequencesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAllSequencesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAllSequencesResponse* internal_default_instance() {
    return reinterpret_cast<const ListAllSequencesResponse*>(
               &_ListAllSequencesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ListAllSequencesResponse& a, ListAllSequencesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAllSequencesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAllSequencesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAllSequencesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAllSequencesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListAllSequencesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListAllSequencesResponse& from) {
    ListAllSequencesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAllSequencesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ListAllSequencesResponse";
  }
  protected:
  explicit ListAllSequencesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKnownSequencesFieldNumber = 2,
    kSequenceInfoFieldNumber = 3,
    kHeaderFieldNumber = 1,
  };
  // repeated string known_sequences = 2 [deprecated = true];
  PROTOBUF_DEPRECATED int known_sequences_size() const;
  private:
  int _internal_known_sequences_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_known_sequences();
  PROTOBUF_DEPRECATED const std::string& known_sequences(int index) const;
  PROTOBUF_DEPRECATED std::string* mutable_known_sequences(int index);
  PROTOBUF_DEPRECATED void set_known_sequences(int index, const std::string& value);
  PROTOBUF_DEPRECATED void set_known_sequences(int index, std::string&& value);
  PROTOBUF_DEPRECATED void set_known_sequences(int index, const char* value);
  PROTOBUF_DEPRECATED void set_known_sequences(int index, const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* add_known_sequences();
  PROTOBUF_DEPRECATED void add_known_sequences(const std::string& value);
  PROTOBUF_DEPRECATED void add_known_sequences(std::string&& value);
  PROTOBUF_DEPRECATED void add_known_sequences(const char* value);
  PROTOBUF_DEPRECATED void add_known_sequences(const char* value, size_t size);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& known_sequences() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_known_sequences();
  private:
  const std::string& _internal_known_sequences(int index) const;
  std::string* _internal_add_known_sequences();
  public:

  // repeated .bosdyn.api.spot.SequenceInfo sequence_info = 3;
  int sequence_info_size() const;
  private:
  int _internal_sequence_info_size() const;
  public:
  void clear_sequence_info();
  ::bosdyn::api::spot::SequenceInfo* mutable_sequence_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::SequenceInfo >*
      mutable_sequence_info();
  private:
  const ::bosdyn::api::spot::SequenceInfo& _internal_sequence_info(int index) const;
  ::bosdyn::api::spot::SequenceInfo* _internal_add_sequence_info();
  public:
  const ::bosdyn::api::spot::SequenceInfo& sequence_info(int index) const;
  ::bosdyn::api::spot::SequenceInfo* add_sequence_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::SequenceInfo >&
      sequence_info() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ListAllSequencesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> known_sequences_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::SequenceInfo > sequence_info_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class SequenceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.SequenceInfo) */ {
 public:
  inline SequenceInfo() : SequenceInfo(nullptr) {}
  ~SequenceInfo() override;
  explicit PROTOBUF_CONSTEXPR SequenceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SequenceInfo(const SequenceInfo& from);
  SequenceInfo(SequenceInfo&& from) noexcept
    : SequenceInfo() {
    *this = ::std::move(from);
  }

  inline SequenceInfo& operator=(const SequenceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SequenceInfo& operator=(SequenceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SequenceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SequenceInfo* internal_default_instance() {
    return reinterpret_cast<const SequenceInfo*>(
               &_SequenceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SequenceInfo& a, SequenceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SequenceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SequenceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SequenceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SequenceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SequenceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SequenceInfo& from) {
    SequenceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SequenceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.SequenceInfo";
  }
  protected:
  explicit SequenceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SequenceInfo_SavedState SavedState;
  static constexpr SavedState SAVED_STATE_UNKNOWN =
    SequenceInfo_SavedState_SAVED_STATE_UNKNOWN;
  static constexpr SavedState SAVED_STATE_TEMPORARY =
    SequenceInfo_SavedState_SAVED_STATE_TEMPORARY;
  static constexpr SavedState SAVED_STATE_RETAINED =
    SequenceInfo_SavedState_SAVED_STATE_RETAINED;
  static constexpr SavedState SAVED_STATE_PERMANENT =
    SequenceInfo_SavedState_SAVED_STATE_PERMANENT;
  static inline bool SavedState_IsValid(int value) {
    return SequenceInfo_SavedState_IsValid(value);
  }
  static constexpr SavedState SavedState_MIN =
    SequenceInfo_SavedState_SavedState_MIN;
  static constexpr SavedState SavedState_MAX =
    SequenceInfo_SavedState_SavedState_MAX;
  static constexpr int SavedState_ARRAYSIZE =
    SequenceInfo_SavedState_SavedState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SavedState_descriptor() {
    return SequenceInfo_SavedState_descriptor();
  }
  template<typename T>
  static inline const std::string& SavedState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SavedState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SavedState_Name.");
    return SequenceInfo_SavedState_Name(enum_t_value);
  }
  static inline bool SavedState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SavedState* value) {
    return SequenceInfo_SavedState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 2,
    kNameFieldNumber = 1,
    kSavedStateFieldNumber = 3,
  };
  // repeated string labels = 2;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  const std::string& labels(int index) const;
  std::string* mutable_labels(int index);
  void set_labels(int index, const std::string& value);
  void set_labels(int index, std::string&& value);
  void set_labels(int index, const char* value);
  void set_labels(int index, const char* value, size_t size);
  std::string* add_labels();
  void add_labels(const std::string& value);
  void add_labels(std::string&& value);
  void add_labels(const char* value);
  void add_labels(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& labels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_labels();
  private:
  const std::string& _internal_labels(int index) const;
  std::string* _internal_add_labels();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .bosdyn.api.spot.SequenceInfo.SavedState saved_state = 3;
  void clear_saved_state();
  ::bosdyn::api::spot::SequenceInfo_SavedState saved_state() const;
  void set_saved_state(::bosdyn::api::spot::SequenceInfo_SavedState value);
  private:
  ::bosdyn::api::spot::SequenceInfo_SavedState _internal_saved_state() const;
  void _internal_set_saved_state(::bosdyn::api::spot::SequenceInfo_SavedState value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.SequenceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int saved_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class DeleteSequenceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.DeleteSequenceRequest) */ {
 public:
  inline DeleteSequenceRequest() : DeleteSequenceRequest(nullptr) {}
  ~DeleteSequenceRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteSequenceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteSequenceRequest(const DeleteSequenceRequest& from);
  DeleteSequenceRequest(DeleteSequenceRequest&& from) noexcept
    : DeleteSequenceRequest() {
    *this = ::std::move(from);
  }

  inline DeleteSequenceRequest& operator=(const DeleteSequenceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSequenceRequest& operator=(DeleteSequenceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSequenceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSequenceRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteSequenceRequest*>(
               &_DeleteSequenceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeleteSequenceRequest& a, DeleteSequenceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSequenceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSequenceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSequenceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSequenceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteSequenceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteSequenceRequest& from) {
    DeleteSequenceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSequenceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.DeleteSequenceRequest";
  }
  protected:
  explicit DeleteSequenceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceNameFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // string sequence_name = 2;
  void clear_sequence_name();
  const std::string& sequence_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequence_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequence_name();
  PROTOBUF_NODISCARD std::string* release_sequence_name();
  void set_allocated_sequence_name(std::string* sequence_name);
  private:
  const std::string& _internal_sequence_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequence_name(const std::string& value);
  std::string* _internal_mutable_sequence_name();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.DeleteSequenceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequence_name_;
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class DeleteSequenceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.DeleteSequenceResponse) */ {
 public:
  inline DeleteSequenceResponse() : DeleteSequenceResponse(nullptr) {}
  ~DeleteSequenceResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteSequenceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteSequenceResponse(const DeleteSequenceResponse& from);
  DeleteSequenceResponse(DeleteSequenceResponse&& from) noexcept
    : DeleteSequenceResponse() {
    *this = ::std::move(from);
  }

  inline DeleteSequenceResponse& operator=(const DeleteSequenceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSequenceResponse& operator=(DeleteSequenceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSequenceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSequenceResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteSequenceResponse*>(
               &_DeleteSequenceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DeleteSequenceResponse& a, DeleteSequenceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSequenceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSequenceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSequenceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSequenceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteSequenceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteSequenceResponse& from) {
    DeleteSequenceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSequenceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.DeleteSequenceResponse";
  }
  protected:
  explicit DeleteSequenceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DeleteSequenceResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    DeleteSequenceResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    DeleteSequenceResponse_Status_STATUS_OK;
  static constexpr Status STATUS_UNKNOWN_SEQUENCE =
    DeleteSequenceResponse_Status_STATUS_UNKNOWN_SEQUENCE;
  static constexpr Status STATUS_ALREADY_TEMPORARY =
    DeleteSequenceResponse_Status_STATUS_ALREADY_TEMPORARY;
  static constexpr Status STATUS_PERMANENT_SEQUENCE =
    DeleteSequenceResponse_Status_STATUS_PERMANENT_SEQUENCE;
  static inline bool Status_IsValid(int value) {
    return DeleteSequenceResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    DeleteSequenceResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    DeleteSequenceResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    DeleteSequenceResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return DeleteSequenceResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return DeleteSequenceResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return DeleteSequenceResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot.DeleteSequenceResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::spot::DeleteSequenceResponse_Status status() const;
  void set_status(::bosdyn::api::spot::DeleteSequenceResponse_Status value);
  private:
  ::bosdyn::api::spot::DeleteSequenceResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::DeleteSequenceResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.DeleteSequenceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class SaveSequenceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.SaveSequenceRequest) */ {
 public:
  inline SaveSequenceRequest() : SaveSequenceRequest(nullptr) {}
  ~SaveSequenceRequest() override;
  explicit PROTOBUF_CONSTEXPR SaveSequenceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveSequenceRequest(const SaveSequenceRequest& from);
  SaveSequenceRequest(SaveSequenceRequest&& from) noexcept
    : SaveSequenceRequest() {
    *this = ::std::move(from);
  }

  inline SaveSequenceRequest& operator=(const SaveSequenceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveSequenceRequest& operator=(SaveSequenceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveSequenceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveSequenceRequest* internal_default_instance() {
    return reinterpret_cast<const SaveSequenceRequest*>(
               &_SaveSequenceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SaveSequenceRequest& a, SaveSequenceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveSequenceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveSequenceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveSequenceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveSequenceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveSequenceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaveSequenceRequest& from) {
    SaveSequenceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveSequenceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.SaveSequenceRequest";
  }
  protected:
  explicit SaveSequenceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddLabelsFieldNumber = 3,
    kSequenceNameFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated string add_labels = 3;
  int add_labels_size() const;
  private:
  int _internal_add_labels_size() const;
  public:
  void clear_add_labels();
  const std::string& add_labels(int index) const;
  std::string* mutable_add_labels(int index);
  void set_add_labels(int index, const std::string& value);
  void set_add_labels(int index, std::string&& value);
  void set_add_labels(int index, const char* value);
  void set_add_labels(int index, const char* value, size_t size);
  std::string* add_add_labels();
  void add_add_labels(const std::string& value);
  void add_add_labels(std::string&& value);
  void add_add_labels(const char* value);
  void add_add_labels(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& add_labels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_add_labels();
  private:
  const std::string& _internal_add_labels(int index) const;
  std::string* _internal_add_add_labels();
  public:

  // string sequence_name = 2;
  void clear_sequence_name();
  const std::string& sequence_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequence_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequence_name();
  PROTOBUF_NODISCARD std::string* release_sequence_name();
  void set_allocated_sequence_name(std::string* sequence_name);
  private:
  const std::string& _internal_sequence_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequence_name(const std::string& value);
  std::string* _internal_mutable_sequence_name();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.SaveSequenceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> add_labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequence_name_;
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class SaveSequenceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.SaveSequenceResponse) */ {
 public:
  inline SaveSequenceResponse() : SaveSequenceResponse(nullptr) {}
  ~SaveSequenceResponse() override;
  explicit PROTOBUF_CONSTEXPR SaveSequenceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveSequenceResponse(const SaveSequenceResponse& from);
  SaveSequenceResponse(SaveSequenceResponse&& from) noexcept
    : SaveSequenceResponse() {
    *this = ::std::move(from);
  }

  inline SaveSequenceResponse& operator=(const SaveSequenceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveSequenceResponse& operator=(SaveSequenceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveSequenceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveSequenceResponse* internal_default_instance() {
    return reinterpret_cast<const SaveSequenceResponse*>(
               &_SaveSequenceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SaveSequenceResponse& a, SaveSequenceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveSequenceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveSequenceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveSequenceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveSequenceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveSequenceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaveSequenceResponse& from) {
    SaveSequenceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveSequenceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.SaveSequenceResponse";
  }
  protected:
  explicit SaveSequenceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SaveSequenceResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    SaveSequenceResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    SaveSequenceResponse_Status_STATUS_OK;
  static constexpr Status STATUS_UNKNOWN_SEQUENCE =
    SaveSequenceResponse_Status_STATUS_UNKNOWN_SEQUENCE;
  static constexpr Status STATUS_PERMANENT_SEQUENCE =
    SaveSequenceResponse_Status_STATUS_PERMANENT_SEQUENCE;
  static constexpr Status STATUS_FAILED_TO_SAVE =
    SaveSequenceResponse_Status_STATUS_FAILED_TO_SAVE;
  static inline bool Status_IsValid(int value) {
    return SaveSequenceResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    SaveSequenceResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    SaveSequenceResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    SaveSequenceResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return SaveSequenceResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return SaveSequenceResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return SaveSequenceResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot.SaveSequenceResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::spot::SaveSequenceResponse_Status status() const;
  void set_status(::bosdyn::api::spot::SaveSequenceResponse_Status value);
  private:
  ::bosdyn::api::spot::SaveSequenceResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::SaveSequenceResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.SaveSequenceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class ModifyChoreographyInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ModifyChoreographyInfoRequest) */ {
 public:
  inline ModifyChoreographyInfoRequest() : ModifyChoreographyInfoRequest(nullptr) {}
  ~ModifyChoreographyInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR ModifyChoreographyInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModifyChoreographyInfoRequest(const ModifyChoreographyInfoRequest& from);
  ModifyChoreographyInfoRequest(ModifyChoreographyInfoRequest&& from) noexcept
    : ModifyChoreographyInfoRequest() {
    *this = ::std::move(from);
  }

  inline ModifyChoreographyInfoRequest& operator=(const ModifyChoreographyInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyChoreographyInfoRequest& operator=(ModifyChoreographyInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifyChoreographyInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModifyChoreographyInfoRequest* internal_default_instance() {
    return reinterpret_cast<const ModifyChoreographyInfoRequest*>(
               &_ModifyChoreographyInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ModifyChoreographyInfoRequest& a, ModifyChoreographyInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyChoreographyInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyChoreographyInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifyChoreographyInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModifyChoreographyInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModifyChoreographyInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModifyChoreographyInfoRequest& from) {
    ModifyChoreographyInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyChoreographyInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ModifyChoreographyInfoRequest";
  }
  protected:
  explicit ModifyChoreographyInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddLabelsFieldNumber = 3,
    kRemoveLabelsFieldNumber = 4,
    kSequenceNameFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated string add_labels = 3;
  int add_labels_size() const;
  private:
  int _internal_add_labels_size() const;
  public:
  void clear_add_labels();
  const std::string& add_labels(int index) const;
  std::string* mutable_add_labels(int index);
  void set_add_labels(int index, const std::string& value);
  void set_add_labels(int index, std::string&& value);
  void set_add_labels(int index, const char* value);
  void set_add_labels(int index, const char* value, size_t size);
  std::string* add_add_labels();
  void add_add_labels(const std::string& value);
  void add_add_labels(std::string&& value);
  void add_add_labels(const char* value);
  void add_add_labels(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& add_labels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_add_labels();
  private:
  const std::string& _internal_add_labels(int index) const;
  std::string* _internal_add_add_labels();
  public:

  // repeated string remove_labels = 4;
  int remove_labels_size() const;
  private:
  int _internal_remove_labels_size() const;
  public:
  void clear_remove_labels();
  const std::string& remove_labels(int index) const;
  std::string* mutable_remove_labels(int index);
  void set_remove_labels(int index, const std::string& value);
  void set_remove_labels(int index, std::string&& value);
  void set_remove_labels(int index, const char* value);
  void set_remove_labels(int index, const char* value, size_t size);
  std::string* add_remove_labels();
  void add_remove_labels(const std::string& value);
  void add_remove_labels(std::string&& value);
  void add_remove_labels(const char* value);
  void add_remove_labels(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& remove_labels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_remove_labels();
  private:
  const std::string& _internal_remove_labels(int index) const;
  std::string* _internal_add_remove_labels();
  public:

  // string sequence_name = 2;
  void clear_sequence_name();
  const std::string& sequence_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequence_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequence_name();
  PROTOBUF_NODISCARD std::string* release_sequence_name();
  void set_allocated_sequence_name(std::string* sequence_name);
  private:
  const std::string& _internal_sequence_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequence_name(const std::string& value);
  std::string* _internal_mutable_sequence_name();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ModifyChoreographyInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> add_labels_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> remove_labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequence_name_;
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class ModifyChoreographyInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ModifyChoreographyInfoResponse) */ {
 public:
  inline ModifyChoreographyInfoResponse() : ModifyChoreographyInfoResponse(nullptr) {}
  ~ModifyChoreographyInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR ModifyChoreographyInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModifyChoreographyInfoResponse(const ModifyChoreographyInfoResponse& from);
  ModifyChoreographyInfoResponse(ModifyChoreographyInfoResponse&& from) noexcept
    : ModifyChoreographyInfoResponse() {
    *this = ::std::move(from);
  }

  inline ModifyChoreographyInfoResponse& operator=(const ModifyChoreographyInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyChoreographyInfoResponse& operator=(ModifyChoreographyInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifyChoreographyInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModifyChoreographyInfoResponse* internal_default_instance() {
    return reinterpret_cast<const ModifyChoreographyInfoResponse*>(
               &_ModifyChoreographyInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ModifyChoreographyInfoResponse& a, ModifyChoreographyInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyChoreographyInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyChoreographyInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifyChoreographyInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModifyChoreographyInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModifyChoreographyInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModifyChoreographyInfoResponse& from) {
    ModifyChoreographyInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyChoreographyInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ModifyChoreographyInfoResponse";
  }
  protected:
  explicit ModifyChoreographyInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModifyChoreographyInfoResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    ModifyChoreographyInfoResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    ModifyChoreographyInfoResponse_Status_STATUS_OK;
  static constexpr Status STATUS_UNKNOWN_SEQUENCE =
    ModifyChoreographyInfoResponse_Status_STATUS_UNKNOWN_SEQUENCE;
  static constexpr Status STATUS_PERMANENT_SEQUENCE =
    ModifyChoreographyInfoResponse_Status_STATUS_PERMANENT_SEQUENCE;
  static constexpr Status STATUS_FAILED_TO_UPDATE =
    ModifyChoreographyInfoResponse_Status_STATUS_FAILED_TO_UPDATE;
  static inline bool Status_IsValid(int value) {
    return ModifyChoreographyInfoResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ModifyChoreographyInfoResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ModifyChoreographyInfoResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ModifyChoreographyInfoResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return ModifyChoreographyInfoResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ModifyChoreographyInfoResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return ModifyChoreographyInfoResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot.ModifyChoreographyInfoResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::spot::ModifyChoreographyInfoResponse_Status status() const;
  void set_status(::bosdyn::api::spot::ModifyChoreographyInfoResponse_Status value);
  private:
  ::bosdyn::api::spot::ModifyChoreographyInfoResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::ModifyChoreographyInfoResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ModifyChoreographyInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class ClearAllSequenceFilesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ClearAllSequenceFilesRequest) */ {
 public:
  inline ClearAllSequenceFilesRequest() : ClearAllSequenceFilesRequest(nullptr) {}
  ~ClearAllSequenceFilesRequest() override;
  explicit PROTOBUF_CONSTEXPR ClearAllSequenceFilesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearAllSequenceFilesRequest(const ClearAllSequenceFilesRequest& from);
  ClearAllSequenceFilesRequest(ClearAllSequenceFilesRequest&& from) noexcept
    : ClearAllSequenceFilesRequest() {
    *this = ::std::move(from);
  }

  inline ClearAllSequenceFilesRequest& operator=(const ClearAllSequenceFilesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearAllSequenceFilesRequest& operator=(ClearAllSequenceFilesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearAllSequenceFilesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearAllSequenceFilesRequest* internal_default_instance() {
    return reinterpret_cast<const ClearAllSequenceFilesRequest*>(
               &_ClearAllSequenceFilesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ClearAllSequenceFilesRequest& a, ClearAllSequenceFilesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearAllSequenceFilesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearAllSequenceFilesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearAllSequenceFilesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearAllSequenceFilesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearAllSequenceFilesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearAllSequenceFilesRequest& from) {
    ClearAllSequenceFilesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearAllSequenceFilesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ClearAllSequenceFilesRequest";
  }
  protected:
  explicit ClearAllSequenceFilesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ClearAllSequenceFilesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class ClearAllSequenceFilesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ClearAllSequenceFilesResponse) */ {
 public:
  inline ClearAllSequenceFilesResponse() : ClearAllSequenceFilesResponse(nullptr) {}
  ~ClearAllSequenceFilesResponse() override;
  explicit PROTOBUF_CONSTEXPR ClearAllSequenceFilesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearAllSequenceFilesResponse(const ClearAllSequenceFilesResponse& from);
  ClearAllSequenceFilesResponse(ClearAllSequenceFilesResponse&& from) noexcept
    : ClearAllSequenceFilesResponse() {
    *this = ::std::move(from);
  }

  inline ClearAllSequenceFilesResponse& operator=(const ClearAllSequenceFilesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearAllSequenceFilesResponse& operator=(ClearAllSequenceFilesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearAllSequenceFilesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearAllSequenceFilesResponse* internal_default_instance() {
    return reinterpret_cast<const ClearAllSequenceFilesResponse*>(
               &_ClearAllSequenceFilesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ClearAllSequenceFilesResponse& a, ClearAllSequenceFilesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearAllSequenceFilesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearAllSequenceFilesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearAllSequenceFilesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearAllSequenceFilesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearAllSequenceFilesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearAllSequenceFilesResponse& from) {
    ClearAllSequenceFilesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearAllSequenceFilesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ClearAllSequenceFilesResponse";
  }
  protected:
  explicit ClearAllSequenceFilesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClearAllSequenceFilesResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    ClearAllSequenceFilesResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    ClearAllSequenceFilesResponse_Status_STATUS_OK;
  static constexpr Status STATUS_FAILED_TO_DELETE =
    ClearAllSequenceFilesResponse_Status_STATUS_FAILED_TO_DELETE;
  static inline bool Status_IsValid(int value) {
    return ClearAllSequenceFilesResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ClearAllSequenceFilesResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ClearAllSequenceFilesResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ClearAllSequenceFilesResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return ClearAllSequenceFilesResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ClearAllSequenceFilesResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return ClearAllSequenceFilesResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot.ClearAllSequenceFilesResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::spot::ClearAllSequenceFilesResponse_Status status() const;
  void set_status(::bosdyn::api::spot::ClearAllSequenceFilesResponse_Status value);
  private:
  ::bosdyn::api::spot::ClearAllSequenceFilesResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::ClearAllSequenceFilesResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ClearAllSequenceFilesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class UploadChoreographyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.UploadChoreographyRequest) */ {
 public:
  inline UploadChoreographyRequest() : UploadChoreographyRequest(nullptr) {}
  ~UploadChoreographyRequest() override;
  explicit PROTOBUF_CONSTEXPR UploadChoreographyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadChoreographyRequest(const UploadChoreographyRequest& from);
  UploadChoreographyRequest(UploadChoreographyRequest&& from) noexcept
    : UploadChoreographyRequest() {
    *this = ::std::move(from);
  }

  inline UploadChoreographyRequest& operator=(const UploadChoreographyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadChoreographyRequest& operator=(UploadChoreographyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadChoreographyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadChoreographyRequest* internal_default_instance() {
    return reinterpret_cast<const UploadChoreographyRequest*>(
               &_UploadChoreographyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UploadChoreographyRequest& a, UploadChoreographyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadChoreographyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadChoreographyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadChoreographyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadChoreographyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadChoreographyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadChoreographyRequest& from) {
    UploadChoreographyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadChoreographyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.UploadChoreographyRequest";
  }
  protected:
  explicit UploadChoreographyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kChoreographySequenceFieldNumber = 2,
    kNonStrictParsingFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot.ChoreographySequence choreography_sequence = 2;
  bool has_choreography_sequence() const;
  private:
  bool _internal_has_choreography_sequence() const;
  public:
  void clear_choreography_sequence();
  const ::bosdyn::api::spot::ChoreographySequence& choreography_sequence() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::ChoreographySequence* release_choreography_sequence();
  ::bosdyn::api::spot::ChoreographySequence* mutable_choreography_sequence();
  void set_allocated_choreography_sequence(::bosdyn::api::spot::ChoreographySequence* choreography_sequence);
  private:
  const ::bosdyn::api::spot::ChoreographySequence& _internal_choreography_sequence() const;
  ::bosdyn::api::spot::ChoreographySequence* _internal_mutable_choreography_sequence();
  public:
  void unsafe_arena_set_allocated_choreography_sequence(
      ::bosdyn::api::spot::ChoreographySequence* choreography_sequence);
  ::bosdyn::api::spot::ChoreographySequence* unsafe_arena_release_choreography_sequence();

  // bool non_strict_parsing = 3;
  void clear_non_strict_parsing();
  bool non_strict_parsing() const;
  void set_non_strict_parsing(bool value);
  private:
  bool _internal_non_strict_parsing() const;
  void _internal_set_non_strict_parsing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.UploadChoreographyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::spot::ChoreographySequence* choreography_sequence_;
    bool non_strict_parsing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class UploadChoreographyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.UploadChoreographyResponse) */ {
 public:
  inline UploadChoreographyResponse() : UploadChoreographyResponse(nullptr) {}
  ~UploadChoreographyResponse() override;
  explicit PROTOBUF_CONSTEXPR UploadChoreographyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadChoreographyResponse(const UploadChoreographyResponse& from);
  UploadChoreographyResponse(UploadChoreographyResponse&& from) noexcept
    : UploadChoreographyResponse() {
    *this = ::std::move(from);
  }

  inline UploadChoreographyResponse& operator=(const UploadChoreographyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadChoreographyResponse& operator=(UploadChoreographyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadChoreographyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadChoreographyResponse* internal_default_instance() {
    return reinterpret_cast<const UploadChoreographyResponse*>(
               &_UploadChoreographyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UploadChoreographyResponse& a, UploadChoreographyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadChoreographyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadChoreographyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadChoreographyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadChoreographyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadChoreographyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadChoreographyResponse& from) {
    UploadChoreographyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadChoreographyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.UploadChoreographyResponse";
  }
  protected:
  explicit UploadChoreographyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWarningsFieldNumber = 3,
    kHeaderFieldNumber = 1,
  };
  // repeated string warnings = 3;
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;
  public:
  void clear_warnings();
  const std::string& warnings(int index) const;
  std::string* mutable_warnings(int index);
  void set_warnings(int index, const std::string& value);
  void set_warnings(int index, std::string&& value);
  void set_warnings(int index, const char* value);
  void set_warnings(int index, const char* value, size_t size);
  std::string* add_warnings();
  void add_warnings(const std::string& value);
  void add_warnings(std::string&& value);
  void add_warnings(const char* value);
  void add_warnings(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& warnings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_warnings();
  private:
  const std::string& _internal_warnings(int index) const;
  std::string* _internal_add_warnings();
  public:

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.UploadChoreographyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> warnings_;
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class UploadAnimatedMoveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.UploadAnimatedMoveRequest) */ {
 public:
  inline UploadAnimatedMoveRequest() : UploadAnimatedMoveRequest(nullptr) {}
  ~UploadAnimatedMoveRequest() override;
  explicit PROTOBUF_CONSTEXPR UploadAnimatedMoveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadAnimatedMoveRequest(const UploadAnimatedMoveRequest& from);
  UploadAnimatedMoveRequest(UploadAnimatedMoveRequest&& from) noexcept
    : UploadAnimatedMoveRequest() {
    *this = ::std::move(from);
  }

  inline UploadAnimatedMoveRequest& operator=(const UploadAnimatedMoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadAnimatedMoveRequest& operator=(UploadAnimatedMoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadAnimatedMoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadAnimatedMoveRequest* internal_default_instance() {
    return reinterpret_cast<const UploadAnimatedMoveRequest*>(
               &_UploadAnimatedMoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UploadAnimatedMoveRequest& a, UploadAnimatedMoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadAnimatedMoveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadAnimatedMoveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadAnimatedMoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadAnimatedMoveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadAnimatedMoveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadAnimatedMoveRequest& from) {
    UploadAnimatedMoveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadAnimatedMoveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.UploadAnimatedMoveRequest";
  }
  protected:
  explicit UploadAnimatedMoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kAnimatedMoveFieldNumber = 2,
    kAnimatedMoveGeneratedIdFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot.Animation animated_move = 2;
  bool has_animated_move() const;
  private:
  bool _internal_has_animated_move() const;
  public:
  void clear_animated_move();
  const ::bosdyn::api::spot::Animation& animated_move() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::Animation* release_animated_move();
  ::bosdyn::api::spot::Animation* mutable_animated_move();
  void set_allocated_animated_move(::bosdyn::api::spot::Animation* animated_move);
  private:
  const ::bosdyn::api::spot::Animation& _internal_animated_move() const;
  ::bosdyn::api::spot::Animation* _internal_mutable_animated_move();
  public:
  void unsafe_arena_set_allocated_animated_move(
      ::bosdyn::api::spot::Animation* animated_move);
  ::bosdyn::api::spot::Animation* unsafe_arena_release_animated_move();

  // .google.protobuf.StringValue animated_move_generated_id = 3;
  bool has_animated_move_generated_id() const;
  private:
  bool _internal_has_animated_move_generated_id() const;
  public:
  void clear_animated_move_generated_id();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& animated_move_generated_id() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_animated_move_generated_id();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_animated_move_generated_id();
  void set_allocated_animated_move_generated_id(::PROTOBUF_NAMESPACE_ID::StringValue* animated_move_generated_id);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_animated_move_generated_id() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_animated_move_generated_id();
  public:
  void unsafe_arena_set_allocated_animated_move_generated_id(
      ::PROTOBUF_NAMESPACE_ID::StringValue* animated_move_generated_id);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_animated_move_generated_id();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.UploadAnimatedMoveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::bosdyn::api::spot::Animation* animated_move_;
    ::PROTOBUF_NAMESPACE_ID::StringValue* animated_move_generated_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class UploadAnimatedMoveResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.UploadAnimatedMoveResponse) */ {
 public:
  inline UploadAnimatedMoveResponse() : UploadAnimatedMoveResponse(nullptr) {}
  ~UploadAnimatedMoveResponse() override;
  explicit PROTOBUF_CONSTEXPR UploadAnimatedMoveResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadAnimatedMoveResponse(const UploadAnimatedMoveResponse& from);
  UploadAnimatedMoveResponse(UploadAnimatedMoveResponse&& from) noexcept
    : UploadAnimatedMoveResponse() {
    *this = ::std::move(from);
  }

  inline UploadAnimatedMoveResponse& operator=(const UploadAnimatedMoveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadAnimatedMoveResponse& operator=(UploadAnimatedMoveResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadAnimatedMoveResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadAnimatedMoveResponse* internal_default_instance() {
    return reinterpret_cast<const UploadAnimatedMoveResponse*>(
               &_UploadAnimatedMoveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UploadAnimatedMoveResponse& a, UploadAnimatedMoveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadAnimatedMoveResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadAnimatedMoveResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadAnimatedMoveResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadAnimatedMoveResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadAnimatedMoveResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadAnimatedMoveResponse& from) {
    UploadAnimatedMoveResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadAnimatedMoveResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.UploadAnimatedMoveResponse";
  }
  protected:
  explicit UploadAnimatedMoveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UploadAnimatedMoveResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    UploadAnimatedMoveResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    UploadAnimatedMoveResponse_Status_STATUS_OK;
  static constexpr Status STATUS_ANIMATION_VALIDATION_FAILED =
    UploadAnimatedMoveResponse_Status_STATUS_ANIMATION_VALIDATION_FAILED;
  static constexpr Status STATUS_PING_RESPONSE =
    UploadAnimatedMoveResponse_Status_STATUS_PING_RESPONSE;
  static inline bool Status_IsValid(int value) {
    return UploadAnimatedMoveResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    UploadAnimatedMoveResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    UploadAnimatedMoveResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    UploadAnimatedMoveResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return UploadAnimatedMoveResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return UploadAnimatedMoveResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return UploadAnimatedMoveResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kWarningsFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated string warnings = 3;
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;
  public:
  void clear_warnings();
  const std::string& warnings(int index) const;
  std::string* mutable_warnings(int index);
  void set_warnings(int index, const std::string& value);
  void set_warnings(int index, std::string&& value);
  void set_warnings(int index, const char* value);
  void set_warnings(int index, const char* value, size_t size);
  std::string* add_warnings();
  void add_warnings(const std::string& value);
  void add_warnings(std::string&& value);
  void add_warnings(const char* value);
  void add_warnings(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& warnings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_warnings();
  private:
  const std::string& _internal_warnings(int index) const;
  std::string* _internal_add_warnings();
  public:

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot.UploadAnimatedMoveResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::spot::UploadAnimatedMoveResponse_Status status() const;
  void set_status(::bosdyn::api::spot::UploadAnimatedMoveResponse_Status value);
  private:
  ::bosdyn::api::spot::UploadAnimatedMoveResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::UploadAnimatedMoveResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.UploadAnimatedMoveResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> warnings_;
    ::bosdyn::api::ResponseHeader* header_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class ExecuteChoreographyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ExecuteChoreographyRequest) */ {
 public:
  inline ExecuteChoreographyRequest() : ExecuteChoreographyRequest(nullptr) {}
  ~ExecuteChoreographyRequest() override;
  explicit PROTOBUF_CONSTEXPR ExecuteChoreographyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteChoreographyRequest(const ExecuteChoreographyRequest& from);
  ExecuteChoreographyRequest(ExecuteChoreographyRequest&& from) noexcept
    : ExecuteChoreographyRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteChoreographyRequest& operator=(const ExecuteChoreographyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteChoreographyRequest& operator=(ExecuteChoreographyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteChoreographyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteChoreographyRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteChoreographyRequest*>(
               &_ExecuteChoreographyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ExecuteChoreographyRequest& a, ExecuteChoreographyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteChoreographyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteChoreographyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteChoreographyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteChoreographyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteChoreographyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteChoreographyRequest& from) {
    ExecuteChoreographyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteChoreographyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ExecuteChoreographyRequest";
  }
  protected:
  explicit ExecuteChoreographyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChoreographySequenceNameFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kStartTimeFieldNumber = 3,
    kLeaseFieldNumber = 6,
    kChoreographyStartingSliceFieldNumber = 4,
  };
  // string choreography_sequence_name = 2;
  void clear_choreography_sequence_name();
  const std::string& choreography_sequence_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_choreography_sequence_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_choreography_sequence_name();
  PROTOBUF_NODISCARD std::string* release_choreography_sequence_name();
  void set_allocated_choreography_sequence_name(std::string* choreography_sequence_name);
  private:
  const std::string& _internal_choreography_sequence_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_choreography_sequence_name(const std::string& value);
  std::string* _internal_mutable_choreography_sequence_name();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .google.protobuf.Timestamp start_time = 3;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .bosdyn.api.Lease lease = 6;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // double choreography_starting_slice = 4;
  void clear_choreography_starting_slice();
  double choreography_starting_slice() const;
  void set_choreography_starting_slice(double value);
  private:
  double _internal_choreography_starting_slice() const;
  void _internal_set_choreography_starting_slice(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ExecuteChoreographyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr choreography_sequence_name_;
    ::bosdyn::api::RequestHeader* header_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::bosdyn::api::Lease* lease_;
    double choreography_starting_slice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class ExecuteChoreographyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ExecuteChoreographyResponse) */ {
 public:
  inline ExecuteChoreographyResponse() : ExecuteChoreographyResponse(nullptr) {}
  ~ExecuteChoreographyResponse() override;
  explicit PROTOBUF_CONSTEXPR ExecuteChoreographyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteChoreographyResponse(const ExecuteChoreographyResponse& from);
  ExecuteChoreographyResponse(ExecuteChoreographyResponse&& from) noexcept
    : ExecuteChoreographyResponse() {
    *this = ::std::move(from);
  }

  inline ExecuteChoreographyResponse& operator=(const ExecuteChoreographyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteChoreographyResponse& operator=(ExecuteChoreographyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteChoreographyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteChoreographyResponse* internal_default_instance() {
    return reinterpret_cast<const ExecuteChoreographyResponse*>(
               &_ExecuteChoreographyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ExecuteChoreographyResponse& a, ExecuteChoreographyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteChoreographyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteChoreographyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteChoreographyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteChoreographyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteChoreographyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteChoreographyResponse& from) {
    ExecuteChoreographyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteChoreographyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ExecuteChoreographyResponse";
  }
  protected:
  explicit ExecuteChoreographyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ExecuteChoreographyResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    ExecuteChoreographyResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    ExecuteChoreographyResponse_Status_STATUS_OK;
  static constexpr Status STATUS_INVALID_UPLOADED_CHOREOGRAPHY =
    ExecuteChoreographyResponse_Status_STATUS_INVALID_UPLOADED_CHOREOGRAPHY;
  static constexpr Status STATUS_ROBOT_COMMAND_ISSUES =
    ExecuteChoreographyResponse_Status_STATUS_ROBOT_COMMAND_ISSUES;
  static constexpr Status STATUS_LEASE_ERROR =
    ExecuteChoreographyResponse_Status_STATUS_LEASE_ERROR;
  static inline bool Status_IsValid(int value) {
    return ExecuteChoreographyResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ExecuteChoreographyResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ExecuteChoreographyResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ExecuteChoreographyResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return ExecuteChoreographyResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ExecuteChoreographyResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return ExecuteChoreographyResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  PROTOBUF_NODISCARD ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // .bosdyn.api.spot.ExecuteChoreographyResponse.Status status = 3;
  void clear_status();
  ::bosdyn::api::spot::ExecuteChoreographyResponse_Status status() const;
  void set_status(::bosdyn::api::spot::ExecuteChoreographyResponse_Status value);
  private:
  ::bosdyn::api::spot::ExecuteChoreographyResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::ExecuteChoreographyResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ExecuteChoreographyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::LeaseUseResult* lease_use_result_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class StartRecordingStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.StartRecordingStateRequest) */ {
 public:
  inline StartRecordingStateRequest() : StartRecordingStateRequest(nullptr) {}
  ~StartRecordingStateRequest() override;
  explicit PROTOBUF_CONSTEXPR StartRecordingStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartRecordingStateRequest(const StartRecordingStateRequest& from);
  StartRecordingStateRequest(StartRecordingStateRequest&& from) noexcept
    : StartRecordingStateRequest() {
    *this = ::std::move(from);
  }

  inline StartRecordingStateRequest& operator=(const StartRecordingStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartRecordingStateRequest& operator=(StartRecordingStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartRecordingStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartRecordingStateRequest* internal_default_instance() {
    return reinterpret_cast<const StartRecordingStateRequest*>(
               &_StartRecordingStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(StartRecordingStateRequest& a, StartRecordingStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartRecordingStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartRecordingStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartRecordingStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartRecordingStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartRecordingStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartRecordingStateRequest& from) {
    StartRecordingStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartRecordingStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.StartRecordingStateRequest";
  }
  protected:
  explicit StartRecordingStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kContinueRecordingDurationFieldNumber = 2,
    kRecordingSessionIdFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .google.protobuf.Duration continue_recording_duration = 2;
  bool has_continue_recording_duration() const;
  private:
  bool _internal_has_continue_recording_duration() const;
  public:
  void clear_continue_recording_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& continue_recording_duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_continue_recording_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_continue_recording_duration();
  void set_allocated_continue_recording_duration(::PROTOBUF_NAMESPACE_ID::Duration* continue_recording_duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_continue_recording_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_continue_recording_duration();
  public:
  void unsafe_arena_set_allocated_continue_recording_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* continue_recording_duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_continue_recording_duration();

  // uint64 recording_session_id = 3;
  void clear_recording_session_id();
  uint64_t recording_session_id() const;
  void set_recording_session_id(uint64_t value);
  private:
  uint64_t _internal_recording_session_id() const;
  void _internal_set_recording_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.StartRecordingStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    ::PROTOBUF_NAMESPACE_ID::Duration* continue_recording_duration_;
    uint64_t recording_session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class StartRecordingStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.StartRecordingStateResponse) */ {
 public:
  inline StartRecordingStateResponse() : StartRecordingStateResponse(nullptr) {}
  ~StartRecordingStateResponse() override;
  explicit PROTOBUF_CONSTEXPR StartRecordingStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartRecordingStateResponse(const StartRecordingStateResponse& from);
  StartRecordingStateResponse(StartRecordingStateResponse&& from) noexcept
    : StartRecordingStateResponse() {
    *this = ::std::move(from);
  }

  inline StartRecordingStateResponse& operator=(const StartRecordingStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartRecordingStateResponse& operator=(StartRecordingStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartRecordingStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartRecordingStateResponse* internal_default_instance() {
    return reinterpret_cast<const StartRecordingStateResponse*>(
               &_StartRecordingStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(StartRecordingStateResponse& a, StartRecordingStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StartRecordingStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartRecordingStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartRecordingStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartRecordingStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartRecordingStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartRecordingStateResponse& from) {
    StartRecordingStateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartRecordingStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.StartRecordingStateResponse";
  }
  protected:
  explicit StartRecordingStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StartRecordingStateResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    StartRecordingStateResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    StartRecordingStateResponse_Status_STATUS_OK;
  static constexpr Status STATUS_UNKNOWN_RECORDING_SESSION_ID =
    StartRecordingStateResponse_Status_STATUS_UNKNOWN_RECORDING_SESSION_ID;
  static constexpr Status STATUS_RECORDING_BUFFER_FULL =
    StartRecordingStateResponse_Status_STATUS_RECORDING_BUFFER_FULL;
  static inline bool Status_IsValid(int value) {
    return StartRecordingStateResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    StartRecordingStateResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    StartRecordingStateResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    StartRecordingStateResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return StartRecordingStateResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return StartRecordingStateResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return StartRecordingStateResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRecordingSessionIdFieldNumber = 3,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // uint64 recording_session_id = 3;
  void clear_recording_session_id();
  uint64_t recording_session_id() const;
  void set_recording_session_id(uint64_t value);
  private:
  uint64_t _internal_recording_session_id() const;
  void _internal_set_recording_session_id(uint64_t value);
  public:

  // .bosdyn.api.spot.StartRecordingStateResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::spot::StartRecordingStateResponse_Status status() const;
  void set_status(::bosdyn::api::spot::StartRecordingStateResponse_Status value);
  private:
  ::bosdyn::api::spot::StartRecordingStateResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::StartRecordingStateResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.StartRecordingStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    uint64_t recording_session_id_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class StopRecordingStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.StopRecordingStateRequest) */ {
 public:
  inline StopRecordingStateRequest() : StopRecordingStateRequest(nullptr) {}
  ~StopRecordingStateRequest() override;
  explicit PROTOBUF_CONSTEXPR StopRecordingStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopRecordingStateRequest(const StopRecordingStateRequest& from);
  StopRecordingStateRequest(StopRecordingStateRequest&& from) noexcept
    : StopRecordingStateRequest() {
    *this = ::std::move(from);
  }

  inline StopRecordingStateRequest& operator=(const StopRecordingStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopRecordingStateRequest& operator=(StopRecordingStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopRecordingStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopRecordingStateRequest* internal_default_instance() {
    return reinterpret_cast<const StopRecordingStateRequest*>(
               &_StopRecordingStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(StopRecordingStateRequest& a, StopRecordingStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopRecordingStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopRecordingStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopRecordingStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopRecordingStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopRecordingStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopRecordingStateRequest& from) {
    StopRecordingStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopRecordingStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.StopRecordingStateRequest";
  }
  protected:
  explicit StopRecordingStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.StopRecordingStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class StopRecordingStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.StopRecordingStateResponse) */ {
 public:
  inline StopRecordingStateResponse() : StopRecordingStateResponse(nullptr) {}
  ~StopRecordingStateResponse() override;
  explicit PROTOBUF_CONSTEXPR StopRecordingStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopRecordingStateResponse(const StopRecordingStateResponse& from);
  StopRecordingStateResponse(StopRecordingStateResponse&& from) noexcept
    : StopRecordingStateResponse() {
    *this = ::std::move(from);
  }

  inline StopRecordingStateResponse& operator=(const StopRecordingStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopRecordingStateResponse& operator=(StopRecordingStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopRecordingStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopRecordingStateResponse* internal_default_instance() {
    return reinterpret_cast<const StopRecordingStateResponse*>(
               &_StopRecordingStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(StopRecordingStateResponse& a, StopRecordingStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StopRecordingStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopRecordingStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopRecordingStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopRecordingStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopRecordingStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopRecordingStateResponse& from) {
    StopRecordingStateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopRecordingStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.StopRecordingStateResponse";
  }
  protected:
  explicit StopRecordingStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.StopRecordingStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class DownloadRobotStateLogRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.DownloadRobotStateLogRequest) */ {
 public:
  inline DownloadRobotStateLogRequest() : DownloadRobotStateLogRequest(nullptr) {}
  ~DownloadRobotStateLogRequest() override;
  explicit PROTOBUF_CONSTEXPR DownloadRobotStateLogRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadRobotStateLogRequest(const DownloadRobotStateLogRequest& from);
  DownloadRobotStateLogRequest(DownloadRobotStateLogRequest&& from) noexcept
    : DownloadRobotStateLogRequest() {
    *this = ::std::move(from);
  }

  inline DownloadRobotStateLogRequest& operator=(const DownloadRobotStateLogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadRobotStateLogRequest& operator=(DownloadRobotStateLogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadRobotStateLogRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadRobotStateLogRequest* internal_default_instance() {
    return reinterpret_cast<const DownloadRobotStateLogRequest*>(
               &_DownloadRobotStateLogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(DownloadRobotStateLogRequest& a, DownloadRobotStateLogRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadRobotStateLogRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadRobotStateLogRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadRobotStateLogRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadRobotStateLogRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DownloadRobotStateLogRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DownloadRobotStateLogRequest& from) {
    DownloadRobotStateLogRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadRobotStateLogRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.DownloadRobotStateLogRequest";
  }
  protected:
  explicit DownloadRobotStateLogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DownloadRobotStateLogRequest_LogType LogType;
  static constexpr LogType LOG_TYPE_UNKNOWN =
    DownloadRobotStateLogRequest_LogType_LOG_TYPE_UNKNOWN;
  static constexpr LogType LOG_TYPE_MANUAL =
    DownloadRobotStateLogRequest_LogType_LOG_TYPE_MANUAL;
  static constexpr LogType LOG_TYPE_LAST_CHOREOGRAPHY =
    DownloadRobotStateLogRequest_LogType_LOG_TYPE_LAST_CHOREOGRAPHY;
  static inline bool LogType_IsValid(int value) {
    return DownloadRobotStateLogRequest_LogType_IsValid(value);
  }
  static constexpr LogType LogType_MIN =
    DownloadRobotStateLogRequest_LogType_LogType_MIN;
  static constexpr LogType LogType_MAX =
    DownloadRobotStateLogRequest_LogType_LogType_MAX;
  static constexpr int LogType_ARRAYSIZE =
    DownloadRobotStateLogRequest_LogType_LogType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LogType_descriptor() {
    return DownloadRobotStateLogRequest_LogType_descriptor();
  }
  template<typename T>
  static inline const std::string& LogType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LogType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LogType_Name.");
    return DownloadRobotStateLogRequest_LogType_Name(enum_t_value);
  }
  static inline bool LogType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LogType* value) {
    return DownloadRobotStateLogRequest_LogType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLogTypeFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot.DownloadRobotStateLogRequest.LogType log_type = 2;
  void clear_log_type();
  ::bosdyn::api::spot::DownloadRobotStateLogRequest_LogType log_type() const;
  void set_log_type(::bosdyn::api::spot::DownloadRobotStateLogRequest_LogType value);
  private:
  ::bosdyn::api::spot::DownloadRobotStateLogRequest_LogType _internal_log_type() const;
  void _internal_set_log_type(::bosdyn::api::spot::DownloadRobotStateLogRequest_LogType value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.DownloadRobotStateLogRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::RequestHeader* header_;
    int log_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class LoggedJoints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.LoggedJoints) */ {
 public:
  inline LoggedJoints() : LoggedJoints(nullptr) {}
  ~LoggedJoints() override;
  explicit PROTOBUF_CONSTEXPR LoggedJoints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoggedJoints(const LoggedJoints& from);
  LoggedJoints(LoggedJoints&& from) noexcept
    : LoggedJoints() {
    *this = ::std::move(from);
  }

  inline LoggedJoints& operator=(const LoggedJoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoggedJoints& operator=(LoggedJoints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoggedJoints& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoggedJoints* internal_default_instance() {
    return reinterpret_cast<const LoggedJoints*>(
               &_LoggedJoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(LoggedJoints& a, LoggedJoints& b) {
    a.Swap(&b);
  }
  inline void Swap(LoggedJoints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoggedJoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoggedJoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoggedJoints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoggedJoints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoggedJoints& from) {
    LoggedJoints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoggedJoints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.LoggedJoints";
  }
  protected:
  explicit LoggedJoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlFieldNumber = 1,
    kFrFieldNumber = 2,
    kHlFieldNumber = 3,
    kHrFieldNumber = 4,
    kArmFieldNumber = 5,
    kGripperAngleFieldNumber = 6,
  };
  // .bosdyn.api.spot.LegJointAngles fl = 1;
  bool has_fl() const;
  private:
  bool _internal_has_fl() const;
  public:
  void clear_fl();
  const ::bosdyn::api::spot::LegJointAngles& fl() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::LegJointAngles* release_fl();
  ::bosdyn::api::spot::LegJointAngles* mutable_fl();
  void set_allocated_fl(::bosdyn::api::spot::LegJointAngles* fl);
  private:
  const ::bosdyn::api::spot::LegJointAngles& _internal_fl() const;
  ::bosdyn::api::spot::LegJointAngles* _internal_mutable_fl();
  public:
  void unsafe_arena_set_allocated_fl(
      ::bosdyn::api::spot::LegJointAngles* fl);
  ::bosdyn::api::spot::LegJointAngles* unsafe_arena_release_fl();

  // .bosdyn.api.spot.LegJointAngles fr = 2;
  bool has_fr() const;
  private:
  bool _internal_has_fr() const;
  public:
  void clear_fr();
  const ::bosdyn::api::spot::LegJointAngles& fr() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::LegJointAngles* release_fr();
  ::bosdyn::api::spot::LegJointAngles* mutable_fr();
  void set_allocated_fr(::bosdyn::api::spot::LegJointAngles* fr);
  private:
  const ::bosdyn::api::spot::LegJointAngles& _internal_fr() const;
  ::bosdyn::api::spot::LegJointAngles* _internal_mutable_fr();
  public:
  void unsafe_arena_set_allocated_fr(
      ::bosdyn::api::spot::LegJointAngles* fr);
  ::bosdyn::api::spot::LegJointAngles* unsafe_arena_release_fr();

  // .bosdyn.api.spot.LegJointAngles hl = 3;
  bool has_hl() const;
  private:
  bool _internal_has_hl() const;
  public:
  void clear_hl();
  const ::bosdyn::api::spot::LegJointAngles& hl() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::LegJointAngles* release_hl();
  ::bosdyn::api::spot::LegJointAngles* mutable_hl();
  void set_allocated_hl(::bosdyn::api::spot::LegJointAngles* hl);
  private:
  const ::bosdyn::api::spot::LegJointAngles& _internal_hl() const;
  ::bosdyn::api::spot::LegJointAngles* _internal_mutable_hl();
  public:
  void unsafe_arena_set_allocated_hl(
      ::bosdyn::api::spot::LegJointAngles* hl);
  ::bosdyn::api::spot::LegJointAngles* unsafe_arena_release_hl();

  // .bosdyn.api.spot.LegJointAngles hr = 4;
  bool has_hr() const;
  private:
  bool _internal_has_hr() const;
  public:
  void clear_hr();
  const ::bosdyn::api::spot::LegJointAngles& hr() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::LegJointAngles* release_hr();
  ::bosdyn::api::spot::LegJointAngles* mutable_hr();
  void set_allocated_hr(::bosdyn::api::spot::LegJointAngles* hr);
  private:
  const ::bosdyn::api::spot::LegJointAngles& _internal_hr() const;
  ::bosdyn::api::spot::LegJointAngles* _internal_mutable_hr();
  public:
  void unsafe_arena_set_allocated_hr(
      ::bosdyn::api::spot::LegJointAngles* hr);
  ::bosdyn::api::spot::LegJointAngles* unsafe_arena_release_hr();

  // .bosdyn.api.spot.ArmJointAngles arm = 5;
  bool has_arm() const;
  private:
  bool _internal_has_arm() const;
  public:
  void clear_arm();
  const ::bosdyn::api::spot::ArmJointAngles& arm() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::ArmJointAngles* release_arm();
  ::bosdyn::api::spot::ArmJointAngles* mutable_arm();
  void set_allocated_arm(::bosdyn::api::spot::ArmJointAngles* arm);
  private:
  const ::bosdyn::api::spot::ArmJointAngles& _internal_arm() const;
  ::bosdyn::api::spot::ArmJointAngles* _internal_mutable_arm();
  public:
  void unsafe_arena_set_allocated_arm(
      ::bosdyn::api::spot::ArmJointAngles* arm);
  ::bosdyn::api::spot::ArmJointAngles* unsafe_arena_release_arm();

  // .google.protobuf.DoubleValue gripper_angle = 6;
  bool has_gripper_angle() const;
  private:
  bool _internal_has_gripper_angle() const;
  public:
  void clear_gripper_angle();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& gripper_angle() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_gripper_angle();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_gripper_angle();
  void set_allocated_gripper_angle(::PROTOBUF_NAMESPACE_ID::DoubleValue* gripper_angle);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_gripper_angle() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_gripper_angle();
  public:
  void unsafe_arena_set_allocated_gripper_angle(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* gripper_angle);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_gripper_angle();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.LoggedJoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::spot::LegJointAngles* fl_;
    ::bosdyn::api::spot::LegJointAngles* fr_;
    ::bosdyn::api::spot::LegJointAngles* hl_;
    ::bosdyn::api::spot::LegJointAngles* hr_;
    ::bosdyn::api::spot::ArmJointAngles* arm_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* gripper_angle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class LoggedFootContacts final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.LoggedFootContacts) */ {
 public:
  inline LoggedFootContacts() : LoggedFootContacts(nullptr) {}
  ~LoggedFootContacts() override;
  explicit PROTOBUF_CONSTEXPR LoggedFootContacts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoggedFootContacts(const LoggedFootContacts& from);
  LoggedFootContacts(LoggedFootContacts&& from) noexcept
    : LoggedFootContacts() {
    *this = ::std::move(from);
  }

  inline LoggedFootContacts& operator=(const LoggedFootContacts& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoggedFootContacts& operator=(LoggedFootContacts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoggedFootContacts& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoggedFootContacts* internal_default_instance() {
    return reinterpret_cast<const LoggedFootContacts*>(
               &_LoggedFootContacts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(LoggedFootContacts& a, LoggedFootContacts& b) {
    a.Swap(&b);
  }
  inline void Swap(LoggedFootContacts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoggedFootContacts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoggedFootContacts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoggedFootContacts>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoggedFootContacts& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoggedFootContacts& from) {
    LoggedFootContacts::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoggedFootContacts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.LoggedFootContacts";
  }
  protected:
  explicit LoggedFootContacts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrContactFieldNumber = 1,
    kFlContactFieldNumber = 2,
    kHrContactFieldNumber = 3,
    kHlContactFieldNumber = 4,
  };
  // bool fr_contact = 1;
  void clear_fr_contact();
  bool fr_contact() const;
  void set_fr_contact(bool value);
  private:
  bool _internal_fr_contact() const;
  void _internal_set_fr_contact(bool value);
  public:

  // bool fl_contact = 2;
  void clear_fl_contact();
  bool fl_contact() const;
  void set_fl_contact(bool value);
  private:
  bool _internal_fl_contact() const;
  void _internal_set_fl_contact(bool value);
  public:

  // bool hr_contact = 3;
  void clear_hr_contact();
  bool hr_contact() const;
  void set_hr_contact(bool value);
  private:
  bool _internal_hr_contact() const;
  void _internal_set_hr_contact(bool value);
  public:

  // bool hl_contact = 4;
  void clear_hl_contact();
  bool hl_contact() const;
  void set_hl_contact(bool value);
  private:
  bool _internal_hl_contact() const;
  void _internal_set_hl_contact(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.LoggedFootContacts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool fr_contact_;
    bool fl_contact_;
    bool hr_contact_;
    bool hl_contact_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class LoggedStateKeyFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.LoggedStateKeyFrame) */ {
 public:
  inline LoggedStateKeyFrame() : LoggedStateKeyFrame(nullptr) {}
  ~LoggedStateKeyFrame() override;
  explicit PROTOBUF_CONSTEXPR LoggedStateKeyFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoggedStateKeyFrame(const LoggedStateKeyFrame& from);
  LoggedStateKeyFrame(LoggedStateKeyFrame&& from) noexcept
    : LoggedStateKeyFrame() {
    *this = ::std::move(from);
  }

  inline LoggedStateKeyFrame& operator=(const LoggedStateKeyFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoggedStateKeyFrame& operator=(LoggedStateKeyFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoggedStateKeyFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoggedStateKeyFrame* internal_default_instance() {
    return reinterpret_cast<const LoggedStateKeyFrame*>(
               &_LoggedStateKeyFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(LoggedStateKeyFrame& a, LoggedStateKeyFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(LoggedStateKeyFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoggedStateKeyFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoggedStateKeyFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoggedStateKeyFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoggedStateKeyFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoggedStateKeyFrame& from) {
    LoggedStateKeyFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoggedStateKeyFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.LoggedStateKeyFrame";
  }
  protected:
  explicit LoggedStateKeyFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointAnglesFieldNumber = 1,
    kAnimationTformBodyFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kFootContactStateFieldNumber = 4,
  };
  // .bosdyn.api.spot.LoggedJoints joint_angles = 1;
  bool has_joint_angles() const;
  private:
  bool _internal_has_joint_angles() const;
  public:
  void clear_joint_angles();
  const ::bosdyn::api::spot::LoggedJoints& joint_angles() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::LoggedJoints* release_joint_angles();
  ::bosdyn::api::spot::LoggedJoints* mutable_joint_angles();
  void set_allocated_joint_angles(::bosdyn::api::spot::LoggedJoints* joint_angles);
  private:
  const ::bosdyn::api::spot::LoggedJoints& _internal_joint_angles() const;
  ::bosdyn::api::spot::LoggedJoints* _internal_mutable_joint_angles();
  public:
  void unsafe_arena_set_allocated_joint_angles(
      ::bosdyn::api::spot::LoggedJoints* joint_angles);
  ::bosdyn::api::spot::LoggedJoints* unsafe_arena_release_joint_angles();

  // .bosdyn.api.SE3Pose animation_tform_body = 2;
  bool has_animation_tform_body() const;
  private:
  bool _internal_has_animation_tform_body() const;
  public:
  void clear_animation_tform_body();
  const ::bosdyn::api::SE3Pose& animation_tform_body() const;
  PROTOBUF_NODISCARD ::bosdyn::api::SE3Pose* release_animation_tform_body();
  ::bosdyn::api::SE3Pose* mutable_animation_tform_body();
  void set_allocated_animation_tform_body(::bosdyn::api::SE3Pose* animation_tform_body);
  private:
  const ::bosdyn::api::SE3Pose& _internal_animation_tform_body() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_animation_tform_body();
  public:
  void unsafe_arena_set_allocated_animation_tform_body(
      ::bosdyn::api::SE3Pose* animation_tform_body);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_animation_tform_body();

  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .bosdyn.api.spot.LoggedFootContacts foot_contact_state = 4;
  bool has_foot_contact_state() const;
  private:
  bool _internal_has_foot_contact_state() const;
  public:
  void clear_foot_contact_state();
  const ::bosdyn::api::spot::LoggedFootContacts& foot_contact_state() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::LoggedFootContacts* release_foot_contact_state();
  ::bosdyn::api::spot::LoggedFootContacts* mutable_foot_contact_state();
  void set_allocated_foot_contact_state(::bosdyn::api::spot::LoggedFootContacts* foot_contact_state);
  private:
  const ::bosdyn::api::spot::LoggedFootContacts& _internal_foot_contact_state() const;
  ::bosdyn::api::spot::LoggedFootContacts* _internal_mutable_foot_contact_state();
  public:
  void unsafe_arena_set_allocated_foot_contact_state(
      ::bosdyn::api::spot::LoggedFootContacts* foot_contact_state);
  ::bosdyn::api::spot::LoggedFootContacts* unsafe_arena_release_foot_contact_state();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.LoggedStateKeyFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::spot::LoggedJoints* joint_angles_;
    ::bosdyn::api::SE3Pose* animation_tform_body_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::bosdyn::api::spot::LoggedFootContacts* foot_contact_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class ChoreographyStateLog final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ChoreographyStateLog) */ {
 public:
  inline ChoreographyStateLog() : ChoreographyStateLog(nullptr) {}
  ~ChoreographyStateLog() override;
  explicit PROTOBUF_CONSTEXPR ChoreographyStateLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChoreographyStateLog(const ChoreographyStateLog& from);
  ChoreographyStateLog(ChoreographyStateLog&& from) noexcept
    : ChoreographyStateLog() {
    *this = ::std::move(from);
  }

  inline ChoreographyStateLog& operator=(const ChoreographyStateLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChoreographyStateLog& operator=(ChoreographyStateLog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChoreographyStateLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChoreographyStateLog* internal_default_instance() {
    return reinterpret_cast<const ChoreographyStateLog*>(
               &_ChoreographyStateLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ChoreographyStateLog& a, ChoreographyStateLog& b) {
    a.Swap(&b);
  }
  inline void Swap(ChoreographyStateLog* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChoreographyStateLog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChoreographyStateLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChoreographyStateLog>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChoreographyStateLog& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChoreographyStateLog& from) {
    ChoreographyStateLog::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChoreographyStateLog* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ChoreographyStateLog";
  }
  protected:
  explicit ChoreographyStateLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFramesFieldNumber = 1,
  };
  // repeated .bosdyn.api.spot.LoggedStateKeyFrame key_frames = 1;
  int key_frames_size() const;
  private:
  int _internal_key_frames_size() const;
  public:
  void clear_key_frames();
  ::bosdyn::api::spot::LoggedStateKeyFrame* mutable_key_frames(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::LoggedStateKeyFrame >*
      mutable_key_frames();
  private:
  const ::bosdyn::api::spot::LoggedStateKeyFrame& _internal_key_frames(int index) const;
  ::bosdyn::api::spot::LoggedStateKeyFrame* _internal_add_key_frames();
  public:
  const ::bosdyn::api::spot::LoggedStateKeyFrame& key_frames(int index) const;
  ::bosdyn::api::spot::LoggedStateKeyFrame* add_key_frames();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::LoggedStateKeyFrame >&
      key_frames() const;

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ChoreographyStateLog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::LoggedStateKeyFrame > key_frames_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class DownloadRobotStateLogResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.DownloadRobotStateLogResponse) */ {
 public:
  inline DownloadRobotStateLogResponse() : DownloadRobotStateLogResponse(nullptr) {}
  ~DownloadRobotStateLogResponse() override;
  explicit PROTOBUF_CONSTEXPR DownloadRobotStateLogResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadRobotStateLogResponse(const DownloadRobotStateLogResponse& from);
  DownloadRobotStateLogResponse(DownloadRobotStateLogResponse&& from) noexcept
    : DownloadRobotStateLogResponse() {
    *this = ::std::move(from);
  }

  inline DownloadRobotStateLogResponse& operator=(const DownloadRobotStateLogResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadRobotStateLogResponse& operator=(DownloadRobotStateLogResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadRobotStateLogResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadRobotStateLogResponse* internal_default_instance() {
    return reinterpret_cast<const DownloadRobotStateLogResponse*>(
               &_DownloadRobotStateLogResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(DownloadRobotStateLogResponse& a, DownloadRobotStateLogResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadRobotStateLogResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadRobotStateLogResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadRobotStateLogResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadRobotStateLogResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DownloadRobotStateLogResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DownloadRobotStateLogResponse& from) {
    DownloadRobotStateLogResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadRobotStateLogResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.DownloadRobotStateLogResponse";
  }
  protected:
  explicit DownloadRobotStateLogResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DownloadRobotStateLogResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    DownloadRobotStateLogResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    DownloadRobotStateLogResponse_Status_STATUS_OK;
  static constexpr Status STATUS_NO_RECORDED_INFORMATION =
    DownloadRobotStateLogResponse_Status_STATUS_NO_RECORDED_INFORMATION;
  static constexpr Status STATUS_INCOMPLETE_DATA =
    DownloadRobotStateLogResponse_Status_STATUS_INCOMPLETE_DATA;
  static inline bool Status_IsValid(int value) {
    return DownloadRobotStateLogResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    DownloadRobotStateLogResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    DownloadRobotStateLogResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    DownloadRobotStateLogResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return DownloadRobotStateLogResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return DownloadRobotStateLogResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return DownloadRobotStateLogResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kChunkFieldNumber = 3,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.DataChunk chunk = 3;
  bool has_chunk() const;
  private:
  bool _internal_has_chunk() const;
  public:
  void clear_chunk();
  const ::bosdyn::api::DataChunk& chunk() const;
  PROTOBUF_NODISCARD ::bosdyn::api::DataChunk* release_chunk();
  ::bosdyn::api::DataChunk* mutable_chunk();
  void set_allocated_chunk(::bosdyn::api::DataChunk* chunk);
  private:
  const ::bosdyn::api::DataChunk& _internal_chunk() const;
  ::bosdyn::api::DataChunk* _internal_mutable_chunk();
  public:
  void unsafe_arena_set_allocated_chunk(
      ::bosdyn::api::DataChunk* chunk);
  ::bosdyn::api::DataChunk* unsafe_arena_release_chunk();

  // .bosdyn.api.spot.DownloadRobotStateLogResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::spot::DownloadRobotStateLogResponse_Status status() const;
  void set_status(::bosdyn::api::spot::DownloadRobotStateLogResponse_Status value);
  private:
  ::bosdyn::api::spot::DownloadRobotStateLogResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::DownloadRobotStateLogResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.DownloadRobotStateLogResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::ResponseHeader* header_;
    ::bosdyn::api::DataChunk* chunk_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class MoveParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.MoveParams) */ {
 public:
  inline MoveParams() : MoveParams(nullptr) {}
  ~MoveParams() override;
  explicit PROTOBUF_CONSTEXPR MoveParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveParams(const MoveParams& from);
  MoveParams(MoveParams&& from) noexcept
    : MoveParams() {
    *this = ::std::move(from);
  }

  inline MoveParams& operator=(const MoveParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveParams& operator=(MoveParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveParams& default_instance() {
    return *internal_default_instance();
  }
  enum ParamsCase {
    kJumpParams = 11,
    kRotateBodyParams = 12,
    kStepParams = 13,
    kButtCircleParams = 14,
    kTurnParams = 15,
    kPace2StepParams = 16,
    kTwerkParams = 17,
    kChickenHeadParams = 18,
    kClapParams = 19,
    kFrontUpParams = 20,
    kSwayParams = 21,
    kBodyHoldParams = 22,
    kArmMoveParams = 23,
    kKneelLegMoveParams = 24,
    kRunningManParams = 25,
    kKneelCircleParams = 26,
    kGripperParams = 27,
    kHopParams = 28,
    kRandomRotateParams = 29,
    kCrawlParams = 30,
    kSideParams = 31,
    kBourreeParams = 32,
    kWorkspaceArmMoveParams = 33,
    kFigure8Params = 34,
    kKneelLegMove2Params = 35,
    kFidgetStandParams = 36,
    kGotoParams = 37,
    kFrameSnapshotParams = 38,
    kSetColorParams = 39,
    kRippleColorParams = 40,
    kFadeColorParams = 41,
    kIndependentColorParams = 42,
    kAnimateParams = 1000,
    PARAMS_NOT_SET = 0,
  };

  static inline const MoveParams* internal_default_instance() {
    return reinterpret_cast<const MoveParams*>(
               &_MoveParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(MoveParams& a, MoveParams& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveParams& from) {
    MoveParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.MoveParams";
  }
  protected:
  explicit MoveParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kStartSliceFieldNumber = 2,
    kRequestedSlicesFieldNumber = 3,
    kJumpParamsFieldNumber = 11,
    kRotateBodyParamsFieldNumber = 12,
    kStepParamsFieldNumber = 13,
    kButtCircleParamsFieldNumber = 14,
    kTurnParamsFieldNumber = 15,
    kPace2StepParamsFieldNumber = 16,
    kTwerkParamsFieldNumber = 17,
    kChickenHeadParamsFieldNumber = 18,
    kClapParamsFieldNumber = 19,
    kFrontUpParamsFieldNumber = 20,
    kSwayParamsFieldNumber = 21,
    kBodyHoldParamsFieldNumber = 22,
    kArmMoveParamsFieldNumber = 23,
    kKneelLegMoveParamsFieldNumber = 24,
    kRunningManParamsFieldNumber = 25,
    kKneelCircleParamsFieldNumber = 26,
    kGripperParamsFieldNumber = 27,
    kHopParamsFieldNumber = 28,
    kRandomRotateParamsFieldNumber = 29,
    kCrawlParamsFieldNumber = 30,
    kSideParamsFieldNumber = 31,
    kBourreeParamsFieldNumber = 32,
    kWorkspaceArmMoveParamsFieldNumber = 33,
    kFigure8ParamsFieldNumber = 34,
    kKneelLegMove2ParamsFieldNumber = 35,
    kFidgetStandParamsFieldNumber = 36,
    kGotoParamsFieldNumber = 37,
    kFrameSnapshotParamsFieldNumber = 38,
    kSetColorParamsFieldNumber = 39,
    kRippleColorParamsFieldNumber = 40,
    kFadeColorParamsFieldNumber = 41,
    kIndependentColorParamsFieldNumber = 42,
    kAnimateParamsFieldNumber = 1000,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // int32 start_slice = 2;
  void clear_start_slice();
  int32_t start_slice() const;
  void set_start_slice(int32_t value);
  private:
  int32_t _internal_start_slice() const;
  void _internal_set_start_slice(int32_t value);
  public:

  // int32 requested_slices = 3;
  void clear_requested_slices();
  int32_t requested_slices() const;
  void set_requested_slices(int32_t value);
  private:
  int32_t _internal_requested_slices() const;
  void _internal_set_requested_slices(int32_t value);
  public:

  // .bosdyn.api.spot.JumpParams jump_params = 11;
  bool has_jump_params() const;
  private:
  bool _internal_has_jump_params() const;
  public:
  void clear_jump_params();
  const ::bosdyn::api::spot::JumpParams& jump_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::JumpParams* release_jump_params();
  ::bosdyn::api::spot::JumpParams* mutable_jump_params();
  void set_allocated_jump_params(::bosdyn::api::spot::JumpParams* jump_params);
  private:
  const ::bosdyn::api::spot::JumpParams& _internal_jump_params() const;
  ::bosdyn::api::spot::JumpParams* _internal_mutable_jump_params();
  public:
  void unsafe_arena_set_allocated_jump_params(
      ::bosdyn::api::spot::JumpParams* jump_params);
  ::bosdyn::api::spot::JumpParams* unsafe_arena_release_jump_params();

  // .bosdyn.api.spot.RotateBodyParams rotate_body_params = 12;
  bool has_rotate_body_params() const;
  private:
  bool _internal_has_rotate_body_params() const;
  public:
  void clear_rotate_body_params();
  const ::bosdyn::api::spot::RotateBodyParams& rotate_body_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::RotateBodyParams* release_rotate_body_params();
  ::bosdyn::api::spot::RotateBodyParams* mutable_rotate_body_params();
  void set_allocated_rotate_body_params(::bosdyn::api::spot::RotateBodyParams* rotate_body_params);
  private:
  const ::bosdyn::api::spot::RotateBodyParams& _internal_rotate_body_params() const;
  ::bosdyn::api::spot::RotateBodyParams* _internal_mutable_rotate_body_params();
  public:
  void unsafe_arena_set_allocated_rotate_body_params(
      ::bosdyn::api::spot::RotateBodyParams* rotate_body_params);
  ::bosdyn::api::spot::RotateBodyParams* unsafe_arena_release_rotate_body_params();

  // .bosdyn.api.spot.StepParams step_params = 13;
  bool has_step_params() const;
  private:
  bool _internal_has_step_params() const;
  public:
  void clear_step_params();
  const ::bosdyn::api::spot::StepParams& step_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::StepParams* release_step_params();
  ::bosdyn::api::spot::StepParams* mutable_step_params();
  void set_allocated_step_params(::bosdyn::api::spot::StepParams* step_params);
  private:
  const ::bosdyn::api::spot::StepParams& _internal_step_params() const;
  ::bosdyn::api::spot::StepParams* _internal_mutable_step_params();
  public:
  void unsafe_arena_set_allocated_step_params(
      ::bosdyn::api::spot::StepParams* step_params);
  ::bosdyn::api::spot::StepParams* unsafe_arena_release_step_params();

  // .bosdyn.api.spot.ButtCircleParams butt_circle_params = 14;
  bool has_butt_circle_params() const;
  private:
  bool _internal_has_butt_circle_params() const;
  public:
  void clear_butt_circle_params();
  const ::bosdyn::api::spot::ButtCircleParams& butt_circle_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::ButtCircleParams* release_butt_circle_params();
  ::bosdyn::api::spot::ButtCircleParams* mutable_butt_circle_params();
  void set_allocated_butt_circle_params(::bosdyn::api::spot::ButtCircleParams* butt_circle_params);
  private:
  const ::bosdyn::api::spot::ButtCircleParams& _internal_butt_circle_params() const;
  ::bosdyn::api::spot::ButtCircleParams* _internal_mutable_butt_circle_params();
  public:
  void unsafe_arena_set_allocated_butt_circle_params(
      ::bosdyn::api::spot::ButtCircleParams* butt_circle_params);
  ::bosdyn::api::spot::ButtCircleParams* unsafe_arena_release_butt_circle_params();

  // .bosdyn.api.spot.TurnParams turn_params = 15;
  bool has_turn_params() const;
  private:
  bool _internal_has_turn_params() const;
  public:
  void clear_turn_params();
  const ::bosdyn::api::spot::TurnParams& turn_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::TurnParams* release_turn_params();
  ::bosdyn::api::spot::TurnParams* mutable_turn_params();
  void set_allocated_turn_params(::bosdyn::api::spot::TurnParams* turn_params);
  private:
  const ::bosdyn::api::spot::TurnParams& _internal_turn_params() const;
  ::bosdyn::api::spot::TurnParams* _internal_mutable_turn_params();
  public:
  void unsafe_arena_set_allocated_turn_params(
      ::bosdyn::api::spot::TurnParams* turn_params);
  ::bosdyn::api::spot::TurnParams* unsafe_arena_release_turn_params();

  // .bosdyn.api.spot.Pace2StepParams pace_2step_params = 16;
  bool has_pace_2step_params() const;
  private:
  bool _internal_has_pace_2step_params() const;
  public:
  void clear_pace_2step_params();
  const ::bosdyn::api::spot::Pace2StepParams& pace_2step_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::Pace2StepParams* release_pace_2step_params();
  ::bosdyn::api::spot::Pace2StepParams* mutable_pace_2step_params();
  void set_allocated_pace_2step_params(::bosdyn::api::spot::Pace2StepParams* pace_2step_params);
  private:
  const ::bosdyn::api::spot::Pace2StepParams& _internal_pace_2step_params() const;
  ::bosdyn::api::spot::Pace2StepParams* _internal_mutable_pace_2step_params();
  public:
  void unsafe_arena_set_allocated_pace_2step_params(
      ::bosdyn::api::spot::Pace2StepParams* pace_2step_params);
  ::bosdyn::api::spot::Pace2StepParams* unsafe_arena_release_pace_2step_params();

  // .bosdyn.api.spot.TwerkParams twerk_params = 17;
  bool has_twerk_params() const;
  private:
  bool _internal_has_twerk_params() const;
  public:
  void clear_twerk_params();
  const ::bosdyn::api::spot::TwerkParams& twerk_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::TwerkParams* release_twerk_params();
  ::bosdyn::api::spot::TwerkParams* mutable_twerk_params();
  void set_allocated_twerk_params(::bosdyn::api::spot::TwerkParams* twerk_params);
  private:
  const ::bosdyn::api::spot::TwerkParams& _internal_twerk_params() const;
  ::bosdyn::api::spot::TwerkParams* _internal_mutable_twerk_params();
  public:
  void unsafe_arena_set_allocated_twerk_params(
      ::bosdyn::api::spot::TwerkParams* twerk_params);
  ::bosdyn::api::spot::TwerkParams* unsafe_arena_release_twerk_params();

  // .bosdyn.api.spot.ChickenHeadParams chicken_head_params = 18;
  bool has_chicken_head_params() const;
  private:
  bool _internal_has_chicken_head_params() const;
  public:
  void clear_chicken_head_params();
  const ::bosdyn::api::spot::ChickenHeadParams& chicken_head_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::ChickenHeadParams* release_chicken_head_params();
  ::bosdyn::api::spot::ChickenHeadParams* mutable_chicken_head_params();
  void set_allocated_chicken_head_params(::bosdyn::api::spot::ChickenHeadParams* chicken_head_params);
  private:
  const ::bosdyn::api::spot::ChickenHeadParams& _internal_chicken_head_params() const;
  ::bosdyn::api::spot::ChickenHeadParams* _internal_mutable_chicken_head_params();
  public:
  void unsafe_arena_set_allocated_chicken_head_params(
      ::bosdyn::api::spot::ChickenHeadParams* chicken_head_params);
  ::bosdyn::api::spot::ChickenHeadParams* unsafe_arena_release_chicken_head_params();

  // .bosdyn.api.spot.ClapParams clap_params = 19;
  bool has_clap_params() const;
  private:
  bool _internal_has_clap_params() const;
  public:
  void clear_clap_params();
  const ::bosdyn::api::spot::ClapParams& clap_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::ClapParams* release_clap_params();
  ::bosdyn::api::spot::ClapParams* mutable_clap_params();
  void set_allocated_clap_params(::bosdyn::api::spot::ClapParams* clap_params);
  private:
  const ::bosdyn::api::spot::ClapParams& _internal_clap_params() const;
  ::bosdyn::api::spot::ClapParams* _internal_mutable_clap_params();
  public:
  void unsafe_arena_set_allocated_clap_params(
      ::bosdyn::api::spot::ClapParams* clap_params);
  ::bosdyn::api::spot::ClapParams* unsafe_arena_release_clap_params();

  // .bosdyn.api.spot.FrontUpParams front_up_params = 20;
  bool has_front_up_params() const;
  private:
  bool _internal_has_front_up_params() const;
  public:
  void clear_front_up_params();
  const ::bosdyn::api::spot::FrontUpParams& front_up_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::FrontUpParams* release_front_up_params();
  ::bosdyn::api::spot::FrontUpParams* mutable_front_up_params();
  void set_allocated_front_up_params(::bosdyn::api::spot::FrontUpParams* front_up_params);
  private:
  const ::bosdyn::api::spot::FrontUpParams& _internal_front_up_params() const;
  ::bosdyn::api::spot::FrontUpParams* _internal_mutable_front_up_params();
  public:
  void unsafe_arena_set_allocated_front_up_params(
      ::bosdyn::api::spot::FrontUpParams* front_up_params);
  ::bosdyn::api::spot::FrontUpParams* unsafe_arena_release_front_up_params();

  // .bosdyn.api.spot.SwayParams sway_params = 21;
  bool has_sway_params() const;
  private:
  bool _internal_has_sway_params() const;
  public:
  void clear_sway_params();
  const ::bosdyn::api::spot::SwayParams& sway_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::SwayParams* release_sway_params();
  ::bosdyn::api::spot::SwayParams* mutable_sway_params();
  void set_allocated_sway_params(::bosdyn::api::spot::SwayParams* sway_params);
  private:
  const ::bosdyn::api::spot::SwayParams& _internal_sway_params() const;
  ::bosdyn::api::spot::SwayParams* _internal_mutable_sway_params();
  public:
  void unsafe_arena_set_allocated_sway_params(
      ::bosdyn::api::spot::SwayParams* sway_params);
  ::bosdyn::api::spot::SwayParams* unsafe_arena_release_sway_params();

  // .bosdyn.api.spot.BodyHoldParams body_hold_params = 22;
  bool has_body_hold_params() const;
  private:
  bool _internal_has_body_hold_params() const;
  public:
  void clear_body_hold_params();
  const ::bosdyn::api::spot::BodyHoldParams& body_hold_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::BodyHoldParams* release_body_hold_params();
  ::bosdyn::api::spot::BodyHoldParams* mutable_body_hold_params();
  void set_allocated_body_hold_params(::bosdyn::api::spot::BodyHoldParams* body_hold_params);
  private:
  const ::bosdyn::api::spot::BodyHoldParams& _internal_body_hold_params() const;
  ::bosdyn::api::spot::BodyHoldParams* _internal_mutable_body_hold_params();
  public:
  void unsafe_arena_set_allocated_body_hold_params(
      ::bosdyn::api::spot::BodyHoldParams* body_hold_params);
  ::bosdyn::api::spot::BodyHoldParams* unsafe_arena_release_body_hold_params();

  // .bosdyn.api.spot.ArmMoveParams arm_move_params = 23;
  bool has_arm_move_params() const;
  private:
  bool _internal_has_arm_move_params() const;
  public:
  void clear_arm_move_params();
  const ::bosdyn::api::spot::ArmMoveParams& arm_move_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::ArmMoveParams* release_arm_move_params();
  ::bosdyn::api::spot::ArmMoveParams* mutable_arm_move_params();
  void set_allocated_arm_move_params(::bosdyn::api::spot::ArmMoveParams* arm_move_params);
  private:
  const ::bosdyn::api::spot::ArmMoveParams& _internal_arm_move_params() const;
  ::bosdyn::api::spot::ArmMoveParams* _internal_mutable_arm_move_params();
  public:
  void unsafe_arena_set_allocated_arm_move_params(
      ::bosdyn::api::spot::ArmMoveParams* arm_move_params);
  ::bosdyn::api::spot::ArmMoveParams* unsafe_arena_release_arm_move_params();

  // .bosdyn.api.spot.KneelLegMoveParams kneel_leg_move_params = 24;
  bool has_kneel_leg_move_params() const;
  private:
  bool _internal_has_kneel_leg_move_params() const;
  public:
  void clear_kneel_leg_move_params();
  const ::bosdyn::api::spot::KneelLegMoveParams& kneel_leg_move_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::KneelLegMoveParams* release_kneel_leg_move_params();
  ::bosdyn::api::spot::KneelLegMoveParams* mutable_kneel_leg_move_params();
  void set_allocated_kneel_leg_move_params(::bosdyn::api::spot::KneelLegMoveParams* kneel_leg_move_params);
  private:
  const ::bosdyn::api::spot::KneelLegMoveParams& _internal_kneel_leg_move_params() const;
  ::bosdyn::api::spot::KneelLegMoveParams* _internal_mutable_kneel_leg_move_params();
  public:
  void unsafe_arena_set_allocated_kneel_leg_move_params(
      ::bosdyn::api::spot::KneelLegMoveParams* kneel_leg_move_params);
  ::bosdyn::api::spot::KneelLegMoveParams* unsafe_arena_release_kneel_leg_move_params();

  // .bosdyn.api.spot.RunningManParams running_man_params = 25;
  bool has_running_man_params() const;
  private:
  bool _internal_has_running_man_params() const;
  public:
  void clear_running_man_params();
  const ::bosdyn::api::spot::RunningManParams& running_man_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::RunningManParams* release_running_man_params();
  ::bosdyn::api::spot::RunningManParams* mutable_running_man_params();
  void set_allocated_running_man_params(::bosdyn::api::spot::RunningManParams* running_man_params);
  private:
  const ::bosdyn::api::spot::RunningManParams& _internal_running_man_params() const;
  ::bosdyn::api::spot::RunningManParams* _internal_mutable_running_man_params();
  public:
  void unsafe_arena_set_allocated_running_man_params(
      ::bosdyn::api::spot::RunningManParams* running_man_params);
  ::bosdyn::api::spot::RunningManParams* unsafe_arena_release_running_man_params();

  // .bosdyn.api.spot.KneelCircleParams kneel_circle_params = 26;
  bool has_kneel_circle_params() const;
  private:
  bool _internal_has_kneel_circle_params() const;
  public:
  void clear_kneel_circle_params();
  const ::bosdyn::api::spot::KneelCircleParams& kneel_circle_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::KneelCircleParams* release_kneel_circle_params();
  ::bosdyn::api::spot::KneelCircleParams* mutable_kneel_circle_params();
  void set_allocated_kneel_circle_params(::bosdyn::api::spot::KneelCircleParams* kneel_circle_params);
  private:
  const ::bosdyn::api::spot::KneelCircleParams& _internal_kneel_circle_params() const;
  ::bosdyn::api::spot::KneelCircleParams* _internal_mutable_kneel_circle_params();
  public:
  void unsafe_arena_set_allocated_kneel_circle_params(
      ::bosdyn::api::spot::KneelCircleParams* kneel_circle_params);
  ::bosdyn::api::spot::KneelCircleParams* unsafe_arena_release_kneel_circle_params();

  // .bosdyn.api.spot.GripperParams gripper_params = 27;
  bool has_gripper_params() const;
  private:
  bool _internal_has_gripper_params() const;
  public:
  void clear_gripper_params();
  const ::bosdyn::api::spot::GripperParams& gripper_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::GripperParams* release_gripper_params();
  ::bosdyn::api::spot::GripperParams* mutable_gripper_params();
  void set_allocated_gripper_params(::bosdyn::api::spot::GripperParams* gripper_params);
  private:
  const ::bosdyn::api::spot::GripperParams& _internal_gripper_params() const;
  ::bosdyn::api::spot::GripperParams* _internal_mutable_gripper_params();
  public:
  void unsafe_arena_set_allocated_gripper_params(
      ::bosdyn::api::spot::GripperParams* gripper_params);
  ::bosdyn::api::spot::GripperParams* unsafe_arena_release_gripper_params();

  // .bosdyn.api.spot.HopParams hop_params = 28;
  bool has_hop_params() const;
  private:
  bool _internal_has_hop_params() const;
  public:
  void clear_hop_params();
  const ::bosdyn::api::spot::HopParams& hop_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::HopParams* release_hop_params();
  ::bosdyn::api::spot::HopParams* mutable_hop_params();
  void set_allocated_hop_params(::bosdyn::api::spot::HopParams* hop_params);
  private:
  const ::bosdyn::api::spot::HopParams& _internal_hop_params() const;
  ::bosdyn::api::spot::HopParams* _internal_mutable_hop_params();
  public:
  void unsafe_arena_set_allocated_hop_params(
      ::bosdyn::api::spot::HopParams* hop_params);
  ::bosdyn::api::spot::HopParams* unsafe_arena_release_hop_params();

  // .bosdyn.api.spot.RandomRotateParams random_rotate_params = 29;
  bool has_random_rotate_params() const;
  private:
  bool _internal_has_random_rotate_params() const;
  public:
  void clear_random_rotate_params();
  const ::bosdyn::api::spot::RandomRotateParams& random_rotate_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::RandomRotateParams* release_random_rotate_params();
  ::bosdyn::api::spot::RandomRotateParams* mutable_random_rotate_params();
  void set_allocated_random_rotate_params(::bosdyn::api::spot::RandomRotateParams* random_rotate_params);
  private:
  const ::bosdyn::api::spot::RandomRotateParams& _internal_random_rotate_params() const;
  ::bosdyn::api::spot::RandomRotateParams* _internal_mutable_random_rotate_params();
  public:
  void unsafe_arena_set_allocated_random_rotate_params(
      ::bosdyn::api::spot::RandomRotateParams* random_rotate_params);
  ::bosdyn::api::spot::RandomRotateParams* unsafe_arena_release_random_rotate_params();

  // .bosdyn.api.spot.CrawlParams crawl_params = 30;
  bool has_crawl_params() const;
  private:
  bool _internal_has_crawl_params() const;
  public:
  void clear_crawl_params();
  const ::bosdyn::api::spot::CrawlParams& crawl_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::CrawlParams* release_crawl_params();
  ::bosdyn::api::spot::CrawlParams* mutable_crawl_params();
  void set_allocated_crawl_params(::bosdyn::api::spot::CrawlParams* crawl_params);
  private:
  const ::bosdyn::api::spot::CrawlParams& _internal_crawl_params() const;
  ::bosdyn::api::spot::CrawlParams* _internal_mutable_crawl_params();
  public:
  void unsafe_arena_set_allocated_crawl_params(
      ::bosdyn::api::spot::CrawlParams* crawl_params);
  ::bosdyn::api::spot::CrawlParams* unsafe_arena_release_crawl_params();

  // .bosdyn.api.spot.SideParams side_params = 31;
  bool has_side_params() const;
  private:
  bool _internal_has_side_params() const;
  public:
  void clear_side_params();
  const ::bosdyn::api::spot::SideParams& side_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::SideParams* release_side_params();
  ::bosdyn::api::spot::SideParams* mutable_side_params();
  void set_allocated_side_params(::bosdyn::api::spot::SideParams* side_params);
  private:
  const ::bosdyn::api::spot::SideParams& _internal_side_params() const;
  ::bosdyn::api::spot::SideParams* _internal_mutable_side_params();
  public:
  void unsafe_arena_set_allocated_side_params(
      ::bosdyn::api::spot::SideParams* side_params);
  ::bosdyn::api::spot::SideParams* unsafe_arena_release_side_params();

  // .bosdyn.api.spot.BourreeParams bourree_params = 32;
  bool has_bourree_params() const;
  private:
  bool _internal_has_bourree_params() const;
  public:
  void clear_bourree_params();
  const ::bosdyn::api::spot::BourreeParams& bourree_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::BourreeParams* release_bourree_params();
  ::bosdyn::api::spot::BourreeParams* mutable_bourree_params();
  void set_allocated_bourree_params(::bosdyn::api::spot::BourreeParams* bourree_params);
  private:
  const ::bosdyn::api::spot::BourreeParams& _internal_bourree_params() const;
  ::bosdyn::api::spot::BourreeParams* _internal_mutable_bourree_params();
  public:
  void unsafe_arena_set_allocated_bourree_params(
      ::bosdyn::api::spot::BourreeParams* bourree_params);
  ::bosdyn::api::spot::BourreeParams* unsafe_arena_release_bourree_params();

  // .bosdyn.api.spot.WorkspaceArmMoveParams workspace_arm_move_params = 33;
  bool has_workspace_arm_move_params() const;
  private:
  bool _internal_has_workspace_arm_move_params() const;
  public:
  void clear_workspace_arm_move_params();
  const ::bosdyn::api::spot::WorkspaceArmMoveParams& workspace_arm_move_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::WorkspaceArmMoveParams* release_workspace_arm_move_params();
  ::bosdyn::api::spot::WorkspaceArmMoveParams* mutable_workspace_arm_move_params();
  void set_allocated_workspace_arm_move_params(::bosdyn::api::spot::WorkspaceArmMoveParams* workspace_arm_move_params);
  private:
  const ::bosdyn::api::spot::WorkspaceArmMoveParams& _internal_workspace_arm_move_params() const;
  ::bosdyn::api::spot::WorkspaceArmMoveParams* _internal_mutable_workspace_arm_move_params();
  public:
  void unsafe_arena_set_allocated_workspace_arm_move_params(
      ::bosdyn::api::spot::WorkspaceArmMoveParams* workspace_arm_move_params);
  ::bosdyn::api::spot::WorkspaceArmMoveParams* unsafe_arena_release_workspace_arm_move_params();

  // .bosdyn.api.spot.Figure8Params figure8_params = 34;
  bool has_figure8_params() const;
  private:
  bool _internal_has_figure8_params() const;
  public:
  void clear_figure8_params();
  const ::bosdyn::api::spot::Figure8Params& figure8_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::Figure8Params* release_figure8_params();
  ::bosdyn::api::spot::Figure8Params* mutable_figure8_params();
  void set_allocated_figure8_params(::bosdyn::api::spot::Figure8Params* figure8_params);
  private:
  const ::bosdyn::api::spot::Figure8Params& _internal_figure8_params() const;
  ::bosdyn::api::spot::Figure8Params* _internal_mutable_figure8_params();
  public:
  void unsafe_arena_set_allocated_figure8_params(
      ::bosdyn::api::spot::Figure8Params* figure8_params);
  ::bosdyn::api::spot::Figure8Params* unsafe_arena_release_figure8_params();

  // .bosdyn.api.spot.KneelLegMove2Params kneel_leg_move2_params = 35;
  bool has_kneel_leg_move2_params() const;
  private:
  bool _internal_has_kneel_leg_move2_params() const;
  public:
  void clear_kneel_leg_move2_params();
  const ::bosdyn::api::spot::KneelLegMove2Params& kneel_leg_move2_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::KneelLegMove2Params* release_kneel_leg_move2_params();
  ::bosdyn::api::spot::KneelLegMove2Params* mutable_kneel_leg_move2_params();
  void set_allocated_kneel_leg_move2_params(::bosdyn::api::spot::KneelLegMove2Params* kneel_leg_move2_params);
  private:
  const ::bosdyn::api::spot::KneelLegMove2Params& _internal_kneel_leg_move2_params() const;
  ::bosdyn::api::spot::KneelLegMove2Params* _internal_mutable_kneel_leg_move2_params();
  public:
  void unsafe_arena_set_allocated_kneel_leg_move2_params(
      ::bosdyn::api::spot::KneelLegMove2Params* kneel_leg_move2_params);
  ::bosdyn::api::spot::KneelLegMove2Params* unsafe_arena_release_kneel_leg_move2_params();

  // .bosdyn.api.spot.FidgetStandParams fidget_stand_params = 36;
  bool has_fidget_stand_params() const;
  private:
  bool _internal_has_fidget_stand_params() const;
  public:
  void clear_fidget_stand_params();
  const ::bosdyn::api::spot::FidgetStandParams& fidget_stand_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::FidgetStandParams* release_fidget_stand_params();
  ::bosdyn::api::spot::FidgetStandParams* mutable_fidget_stand_params();
  void set_allocated_fidget_stand_params(::bosdyn::api::spot::FidgetStandParams* fidget_stand_params);
  private:
  const ::bosdyn::api::spot::FidgetStandParams& _internal_fidget_stand_params() const;
  ::bosdyn::api::spot::FidgetStandParams* _internal_mutable_fidget_stand_params();
  public:
  void unsafe_arena_set_allocated_fidget_stand_params(
      ::bosdyn::api::spot::FidgetStandParams* fidget_stand_params);
  ::bosdyn::api::spot::FidgetStandParams* unsafe_arena_release_fidget_stand_params();

  // .bosdyn.api.spot.GotoParams goto_params = 37;
  bool has_goto_params() const;
  private:
  bool _internal_has_goto_params() const;
  public:
  void clear_goto_params();
  const ::bosdyn::api::spot::GotoParams& goto_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::GotoParams* release_goto_params();
  ::bosdyn::api::spot::GotoParams* mutable_goto_params();
  void set_allocated_goto_params(::bosdyn::api::spot::GotoParams* goto_params);
  private:
  const ::bosdyn::api::spot::GotoParams& _internal_goto_params() const;
  ::bosdyn::api::spot::GotoParams* _internal_mutable_goto_params();
  public:
  void unsafe_arena_set_allocated_goto_params(
      ::bosdyn::api::spot::GotoParams* goto_params);
  ::bosdyn::api::spot::GotoParams* unsafe_arena_release_goto_params();

  // .bosdyn.api.spot.FrameSnapshotParams frame_snapshot_params = 38;
  bool has_frame_snapshot_params() const;
  private:
  bool _internal_has_frame_snapshot_params() const;
  public:
  void clear_frame_snapshot_params();
  const ::bosdyn::api::spot::FrameSnapshotParams& frame_snapshot_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::FrameSnapshotParams* release_frame_snapshot_params();
  ::bosdyn::api::spot::FrameSnapshotParams* mutable_frame_snapshot_params();
  void set_allocated_frame_snapshot_params(::bosdyn::api::spot::FrameSnapshotParams* frame_snapshot_params);
  private:
  const ::bosdyn::api::spot::FrameSnapshotParams& _internal_frame_snapshot_params() const;
  ::bosdyn::api::spot::FrameSnapshotParams* _internal_mutable_frame_snapshot_params();
  public:
  void unsafe_arena_set_allocated_frame_snapshot_params(
      ::bosdyn::api::spot::FrameSnapshotParams* frame_snapshot_params);
  ::bosdyn::api::spot::FrameSnapshotParams* unsafe_arena_release_frame_snapshot_params();

  // .bosdyn.api.spot.SetColorParams set_color_params = 39;
  bool has_set_color_params() const;
  private:
  bool _internal_has_set_color_params() const;
  public:
  void clear_set_color_params();
  const ::bosdyn::api::spot::SetColorParams& set_color_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::SetColorParams* release_set_color_params();
  ::bosdyn::api::spot::SetColorParams* mutable_set_color_params();
  void set_allocated_set_color_params(::bosdyn::api::spot::SetColorParams* set_color_params);
  private:
  const ::bosdyn::api::spot::SetColorParams& _internal_set_color_params() const;
  ::bosdyn::api::spot::SetColorParams* _internal_mutable_set_color_params();
  public:
  void unsafe_arena_set_allocated_set_color_params(
      ::bosdyn::api::spot::SetColorParams* set_color_params);
  ::bosdyn::api::spot::SetColorParams* unsafe_arena_release_set_color_params();

  // .bosdyn.api.spot.RippleColorParams ripple_color_params = 40;
  bool has_ripple_color_params() const;
  private:
  bool _internal_has_ripple_color_params() const;
  public:
  void clear_ripple_color_params();
  const ::bosdyn::api::spot::RippleColorParams& ripple_color_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::RippleColorParams* release_ripple_color_params();
  ::bosdyn::api::spot::RippleColorParams* mutable_ripple_color_params();
  void set_allocated_ripple_color_params(::bosdyn::api::spot::RippleColorParams* ripple_color_params);
  private:
  const ::bosdyn::api::spot::RippleColorParams& _internal_ripple_color_params() const;
  ::bosdyn::api::spot::RippleColorParams* _internal_mutable_ripple_color_params();
  public:
  void unsafe_arena_set_allocated_ripple_color_params(
      ::bosdyn::api::spot::RippleColorParams* ripple_color_params);
  ::bosdyn::api::spot::RippleColorParams* unsafe_arena_release_ripple_color_params();

  // .bosdyn.api.spot.FadeColorParams fade_color_params = 41;
  bool has_fade_color_params() const;
  private:
  bool _internal_has_fade_color_params() const;
  public:
  void clear_fade_color_params();
  const ::bosdyn::api::spot::FadeColorParams& fade_color_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::FadeColorParams* release_fade_color_params();
  ::bosdyn::api::spot::FadeColorParams* mutable_fade_color_params();
  void set_allocated_fade_color_params(::bosdyn::api::spot::FadeColorParams* fade_color_params);
  private:
  const ::bosdyn::api::spot::FadeColorParams& _internal_fade_color_params() const;
  ::bosdyn::api::spot::FadeColorParams* _internal_mutable_fade_color_params();
  public:
  void unsafe_arena_set_allocated_fade_color_params(
      ::bosdyn::api::spot::FadeColorParams* fade_color_params);
  ::bosdyn::api::spot::FadeColorParams* unsafe_arena_release_fade_color_params();

  // .bosdyn.api.spot.IndependentColorParams independent_color_params = 42;
  bool has_independent_color_params() const;
  private:
  bool _internal_has_independent_color_params() const;
  public:
  void clear_independent_color_params();
  const ::bosdyn::api::spot::IndependentColorParams& independent_color_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::IndependentColorParams* release_independent_color_params();
  ::bosdyn::api::spot::IndependentColorParams* mutable_independent_color_params();
  void set_allocated_independent_color_params(::bosdyn::api::spot::IndependentColorParams* independent_color_params);
  private:
  const ::bosdyn::api::spot::IndependentColorParams& _internal_independent_color_params() const;
  ::bosdyn::api::spot::IndependentColorParams* _internal_mutable_independent_color_params();
  public:
  void unsafe_arena_set_allocated_independent_color_params(
      ::bosdyn::api::spot::IndependentColorParams* independent_color_params);
  ::bosdyn::api::spot::IndependentColorParams* unsafe_arena_release_independent_color_params();

  // .bosdyn.api.spot.AnimateParams animate_params = 1000;
  bool has_animate_params() const;
  private:
  bool _internal_has_animate_params() const;
  public:
  void clear_animate_params();
  const ::bosdyn::api::spot::AnimateParams& animate_params() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::AnimateParams* release_animate_params();
  ::bosdyn::api::spot::AnimateParams* mutable_animate_params();
  void set_allocated_animate_params(::bosdyn::api::spot::AnimateParams* animate_params);
  private:
  const ::bosdyn::api::spot::AnimateParams& _internal_animate_params() const;
  ::bosdyn::api::spot::AnimateParams* _internal_mutable_animate_params();
  public:
  void unsafe_arena_set_allocated_animate_params(
      ::bosdyn::api::spot::AnimateParams* animate_params);
  ::bosdyn::api::spot::AnimateParams* unsafe_arena_release_animate_params();

  void clear_params();
  ParamsCase params_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.MoveParams)
 private:
  class _Internal;
  void set_has_jump_params();
  void set_has_rotate_body_params();
  void set_has_step_params();
  void set_has_butt_circle_params();
  void set_has_turn_params();
  void set_has_pace_2step_params();
  void set_has_twerk_params();
  void set_has_chicken_head_params();
  void set_has_clap_params();
  void set_has_front_up_params();
  void set_has_sway_params();
  void set_has_body_hold_params();
  void set_has_arm_move_params();
  void set_has_kneel_leg_move_params();
  void set_has_running_man_params();
  void set_has_kneel_circle_params();
  void set_has_gripper_params();
  void set_has_hop_params();
  void set_has_random_rotate_params();
  void set_has_crawl_params();
  void set_has_side_params();
  void set_has_bourree_params();
  void set_has_workspace_arm_move_params();
  void set_has_figure8_params();
  void set_has_kneel_leg_move2_params();
  void set_has_fidget_stand_params();
  void set_has_goto_params();
  void set_has_frame_snapshot_params();
  void set_has_set_color_params();
  void set_has_ripple_color_params();
  void set_has_fade_color_params();
  void set_has_independent_color_params();
  void set_has_animate_params();

  inline bool has_params() const;
  inline void clear_has_params();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    int32_t start_slice_;
    int32_t requested_slices_;
    union ParamsUnion {
      constexpr ParamsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::spot::JumpParams* jump_params_;
      ::bosdyn::api::spot::RotateBodyParams* rotate_body_params_;
      ::bosdyn::api::spot::StepParams* step_params_;
      ::bosdyn::api::spot::ButtCircleParams* butt_circle_params_;
      ::bosdyn::api::spot::TurnParams* turn_params_;
      ::bosdyn::api::spot::Pace2StepParams* pace_2step_params_;
      ::bosdyn::api::spot::TwerkParams* twerk_params_;
      ::bosdyn::api::spot::ChickenHeadParams* chicken_head_params_;
      ::bosdyn::api::spot::ClapParams* clap_params_;
      ::bosdyn::api::spot::FrontUpParams* front_up_params_;
      ::bosdyn::api::spot::SwayParams* sway_params_;
      ::bosdyn::api::spot::BodyHoldParams* body_hold_params_;
      ::bosdyn::api::spot::ArmMoveParams* arm_move_params_;
      ::bosdyn::api::spot::KneelLegMoveParams* kneel_leg_move_params_;
      ::bosdyn::api::spot::RunningManParams* running_man_params_;
      ::bosdyn::api::spot::KneelCircleParams* kneel_circle_params_;
      ::bosdyn::api::spot::GripperParams* gripper_params_;
      ::bosdyn::api::spot::HopParams* hop_params_;
      ::bosdyn::api::spot::RandomRotateParams* random_rotate_params_;
      ::bosdyn::api::spot::CrawlParams* crawl_params_;
      ::bosdyn::api::spot::SideParams* side_params_;
      ::bosdyn::api::spot::BourreeParams* bourree_params_;
      ::bosdyn::api::spot::WorkspaceArmMoveParams* workspace_arm_move_params_;
      ::bosdyn::api::spot::Figure8Params* figure8_params_;
      ::bosdyn::api::spot::KneelLegMove2Params* kneel_leg_move2_params_;
      ::bosdyn::api::spot::FidgetStandParams* fidget_stand_params_;
      ::bosdyn::api::spot::GotoParams* goto_params_;
      ::bosdyn::api::spot::FrameSnapshotParams* frame_snapshot_params_;
      ::bosdyn::api::spot::SetColorParams* set_color_params_;
      ::bosdyn::api::spot::RippleColorParams* ripple_color_params_;
      ::bosdyn::api::spot::FadeColorParams* fade_color_params_;
      ::bosdyn::api::spot::IndependentColorParams* independent_color_params_;
      ::bosdyn::api::spot::AnimateParams* animate_params_;
    } params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class MoveInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.MoveInfo) */ {
 public:
  inline MoveInfo() : MoveInfo(nullptr) {}
  ~MoveInfo() override;
  explicit PROTOBUF_CONSTEXPR MoveInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveInfo(const MoveInfo& from);
  MoveInfo(MoveInfo&& from) noexcept
    : MoveInfo() {
    *this = ::std::move(from);
  }

  inline MoveInfo& operator=(const MoveInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveInfo& operator=(MoveInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveInfo* internal_default_instance() {
    return reinterpret_cast<const MoveInfo*>(
               &_MoveInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(MoveInfo& a, MoveInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveInfo& from) {
    MoveInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.MoveInfo";
  }
  protected:
  explicit MoveInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoveInfo_TransitionState TransitionState;
  static constexpr TransitionState TRANSITION_STATE_UNKNOWN =
    MoveInfo_TransitionState_TRANSITION_STATE_UNKNOWN;
  static constexpr TransitionState TRANSITION_STATE_STAND =
    MoveInfo_TransitionState_TRANSITION_STATE_STAND;
  static constexpr TransitionState TRANSITION_STATE_KNEEL =
    MoveInfo_TransitionState_TRANSITION_STATE_KNEEL;
  static constexpr TransitionState TRANSITION_STATE_SIT =
    MoveInfo_TransitionState_TRANSITION_STATE_SIT;
  static constexpr TransitionState TRANSITION_STATE_SPRAWL =
    MoveInfo_TransitionState_TRANSITION_STATE_SPRAWL;
  static inline bool TransitionState_IsValid(int value) {
    return MoveInfo_TransitionState_IsValid(value);
  }
  static constexpr TransitionState TransitionState_MIN =
    MoveInfo_TransitionState_TransitionState_MIN;
  static constexpr TransitionState TransitionState_MAX =
    MoveInfo_TransitionState_TransitionState_MAX;
  static constexpr int TransitionState_ARRAYSIZE =
    MoveInfo_TransitionState_TransitionState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TransitionState_descriptor() {
    return MoveInfo_TransitionState_descriptor();
  }
  template<typename T>
  static inline const std::string& TransitionState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TransitionState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TransitionState_Name.");
    return MoveInfo_TransitionState_Name(enum_t_value);
  }
  static inline bool TransitionState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TransitionState* value) {
    return MoveInfo_TransitionState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEntranceStatesFieldNumber = 4,
    kNameFieldNumber = 1,
    kDisplayFieldNumber = 11,
    kAnimatedMoveGeneratedIdFieldNumber = 16,
    kMoveLengthSlicesFieldNumber = 2,
    kExitStateFieldNumber = 5,
    kMinTimeFieldNumber = 6,
    kMaxTimeFieldNumber = 7,
    kIsExtendableFieldNumber = 3,
    kControlsArmFieldNumber = 8,
    kControlsLegsFieldNumber = 9,
    kControlsBodyFieldNumber = 10,
    kMinMoveLengthSlicesFieldNumber = 13,
    kMoveLengthTimeFieldNumber = 15,
    kMaxMoveLengthSlicesFieldNumber = 14,
    kControlsGripperFieldNumber = 12,
    kControlsLightsFieldNumber = 17,
    kControlsAnnotationsFieldNumber = 18,
  };
  // repeated .bosdyn.api.spot.MoveInfo.TransitionState entrance_states = 4;
  int entrance_states_size() const;
  private:
  int _internal_entrance_states_size() const;
  public:
  void clear_entrance_states();
  private:
  ::bosdyn::api::spot::MoveInfo_TransitionState _internal_entrance_states(int index) const;
  void _internal_add_entrance_states(::bosdyn::api::spot::MoveInfo_TransitionState value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_entrance_states();
  public:
  ::bosdyn::api::spot::MoveInfo_TransitionState entrance_states(int index) const;
  void set_entrance_states(int index, ::bosdyn::api::spot::MoveInfo_TransitionState value);
  void add_entrance_states(::bosdyn::api::spot::MoveInfo_TransitionState value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& entrance_states() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_entrance_states();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .bosdyn.api.spot.ChoreographerDisplayInfo display = 11;
  bool has_display() const;
  private:
  bool _internal_has_display() const;
  public:
  void clear_display();
  const ::bosdyn::api::spot::ChoreographerDisplayInfo& display() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::ChoreographerDisplayInfo* release_display();
  ::bosdyn::api::spot::ChoreographerDisplayInfo* mutable_display();
  void set_allocated_display(::bosdyn::api::spot::ChoreographerDisplayInfo* display);
  private:
  const ::bosdyn::api::spot::ChoreographerDisplayInfo& _internal_display() const;
  ::bosdyn::api::spot::ChoreographerDisplayInfo* _internal_mutable_display();
  public:
  void unsafe_arena_set_allocated_display(
      ::bosdyn::api::spot::ChoreographerDisplayInfo* display);
  ::bosdyn::api::spot::ChoreographerDisplayInfo* unsafe_arena_release_display();

  // .google.protobuf.StringValue animated_move_generated_id = 16;
  bool has_animated_move_generated_id() const;
  private:
  bool _internal_has_animated_move_generated_id() const;
  public:
  void clear_animated_move_generated_id();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& animated_move_generated_id() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_animated_move_generated_id();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_animated_move_generated_id();
  void set_allocated_animated_move_generated_id(::PROTOBUF_NAMESPACE_ID::StringValue* animated_move_generated_id);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_animated_move_generated_id() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_animated_move_generated_id();
  public:
  void unsafe_arena_set_allocated_animated_move_generated_id(
      ::PROTOBUF_NAMESPACE_ID::StringValue* animated_move_generated_id);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_animated_move_generated_id();

  // int32 move_length_slices = 2;
  void clear_move_length_slices();
  int32_t move_length_slices() const;
  void set_move_length_slices(int32_t value);
  private:
  int32_t _internal_move_length_slices() const;
  void _internal_set_move_length_slices(int32_t value);
  public:

  // .bosdyn.api.spot.MoveInfo.TransitionState exit_state = 5;
  void clear_exit_state();
  ::bosdyn::api::spot::MoveInfo_TransitionState exit_state() const;
  void set_exit_state(::bosdyn::api::spot::MoveInfo_TransitionState value);
  private:
  ::bosdyn::api::spot::MoveInfo_TransitionState _internal_exit_state() const;
  void _internal_set_exit_state(::bosdyn::api::spot::MoveInfo_TransitionState value);
  public:

  // double min_time = 6;
  void clear_min_time();
  double min_time() const;
  void set_min_time(double value);
  private:
  double _internal_min_time() const;
  void _internal_set_min_time(double value);
  public:

  // double max_time = 7;
  void clear_max_time();
  double max_time() const;
  void set_max_time(double value);
  private:
  double _internal_max_time() const;
  void _internal_set_max_time(double value);
  public:

  // bool is_extendable = 3;
  void clear_is_extendable();
  bool is_extendable() const;
  void set_is_extendable(bool value);
  private:
  bool _internal_is_extendable() const;
  void _internal_set_is_extendable(bool value);
  public:

  // bool controls_arm = 8;
  void clear_controls_arm();
  bool controls_arm() const;
  void set_controls_arm(bool value);
  private:
  bool _internal_controls_arm() const;
  void _internal_set_controls_arm(bool value);
  public:

  // bool controls_legs = 9;
  void clear_controls_legs();
  bool controls_legs() const;
  void set_controls_legs(bool value);
  private:
  bool _internal_controls_legs() const;
  void _internal_set_controls_legs(bool value);
  public:

  // bool controls_body = 10;
  void clear_controls_body();
  bool controls_body() const;
  void set_controls_body(bool value);
  private:
  bool _internal_controls_body() const;
  void _internal_set_controls_body(bool value);
  public:

  // int32 min_move_length_slices = 13;
  void clear_min_move_length_slices();
  int32_t min_move_length_slices() const;
  void set_min_move_length_slices(int32_t value);
  private:
  int32_t _internal_min_move_length_slices() const;
  void _internal_set_min_move_length_slices(int32_t value);
  public:

  // double move_length_time = 15;
  void clear_move_length_time();
  double move_length_time() const;
  void set_move_length_time(double value);
  private:
  double _internal_move_length_time() const;
  void _internal_set_move_length_time(double value);
  public:

  // int32 max_move_length_slices = 14;
  void clear_max_move_length_slices();
  int32_t max_move_length_slices() const;
  void set_max_move_length_slices(int32_t value);
  private:
  int32_t _internal_max_move_length_slices() const;
  void _internal_set_max_move_length_slices(int32_t value);
  public:

  // bool controls_gripper = 12;
  void clear_controls_gripper();
  bool controls_gripper() const;
  void set_controls_gripper(bool value);
  private:
  bool _internal_controls_gripper() const;
  void _internal_set_controls_gripper(bool value);
  public:

  // bool controls_lights = 17;
  void clear_controls_lights();
  bool controls_lights() const;
  void set_controls_lights(bool value);
  private:
  bool _internal_controls_lights() const;
  void _internal_set_controls_lights(bool value);
  public:

  // bool controls_annotations = 18;
  void clear_controls_annotations();
  bool controls_annotations() const;
  void set_controls_annotations(bool value);
  private:
  bool _internal_controls_annotations() const;
  void _internal_set_controls_annotations(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.MoveInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> entrance_states_;
    mutable std::atomic<int> _entrance_states_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::bosdyn::api::spot::ChoreographerDisplayInfo* display_;
    ::PROTOBUF_NAMESPACE_ID::StringValue* animated_move_generated_id_;
    int32_t move_length_slices_;
    int exit_state_;
    double min_time_;
    double max_time_;
    bool is_extendable_;
    bool controls_arm_;
    bool controls_legs_;
    bool controls_body_;
    int32_t min_move_length_slices_;
    double move_length_time_;
    int32_t max_move_length_slices_;
    bool controls_gripper_;
    bool controls_lights_;
    bool controls_annotations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class ChoreographerDisplayInfo_Color final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ChoreographerDisplayInfo.Color) */ {
 public:
  inline ChoreographerDisplayInfo_Color() : ChoreographerDisplayInfo_Color(nullptr) {}
  ~ChoreographerDisplayInfo_Color() override;
  explicit PROTOBUF_CONSTEXPR ChoreographerDisplayInfo_Color(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChoreographerDisplayInfo_Color(const ChoreographerDisplayInfo_Color& from);
  ChoreographerDisplayInfo_Color(ChoreographerDisplayInfo_Color&& from) noexcept
    : ChoreographerDisplayInfo_Color() {
    *this = ::std::move(from);
  }

  inline ChoreographerDisplayInfo_Color& operator=(const ChoreographerDisplayInfo_Color& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChoreographerDisplayInfo_Color& operator=(ChoreographerDisplayInfo_Color&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChoreographerDisplayInfo_Color& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChoreographerDisplayInfo_Color* internal_default_instance() {
    return reinterpret_cast<const ChoreographerDisplayInfo_Color*>(
               &_ChoreographerDisplayInfo_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ChoreographerDisplayInfo_Color& a, ChoreographerDisplayInfo_Color& b) {
    a.Swap(&b);
  }
  inline void Swap(ChoreographerDisplayInfo_Color* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChoreographerDisplayInfo_Color* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChoreographerDisplayInfo_Color* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChoreographerDisplayInfo_Color>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChoreographerDisplayInfo_Color& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChoreographerDisplayInfo_Color& from) {
    ChoreographerDisplayInfo_Color::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChoreographerDisplayInfo_Color* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ChoreographerDisplayInfo.Color";
  }
  protected:
  explicit ChoreographerDisplayInfo_Color(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kAFieldNumber = 4,
    kBFieldNumber = 3,
  };
  // int32 r = 1;
  void clear_r();
  int32_t r() const;
  void set_r(int32_t value);
  private:
  int32_t _internal_r() const;
  void _internal_set_r(int32_t value);
  public:

  // int32 g = 2;
  void clear_g();
  int32_t g() const;
  void set_g(int32_t value);
  private:
  int32_t _internal_g() const;
  void _internal_set_g(int32_t value);
  public:

  // double a = 4;
  void clear_a();
  double a() const;
  void set_a(double value);
  private:
  double _internal_a() const;
  void _internal_set_a(double value);
  public:

  // int32 b = 3;
  void clear_b();
  int32_t b() const;
  void set_b(int32_t value);
  private:
  int32_t _internal_b() const;
  void _internal_set_b(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ChoreographerDisplayInfo.Color)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t r_;
    int32_t g_;
    double a_;
    int32_t b_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class ChoreographerDisplayInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ChoreographerDisplayInfo) */ {
 public:
  inline ChoreographerDisplayInfo() : ChoreographerDisplayInfo(nullptr) {}
  ~ChoreographerDisplayInfo() override;
  explicit PROTOBUF_CONSTEXPR ChoreographerDisplayInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChoreographerDisplayInfo(const ChoreographerDisplayInfo& from);
  ChoreographerDisplayInfo(ChoreographerDisplayInfo&& from) noexcept
    : ChoreographerDisplayInfo() {
    *this = ::std::move(from);
  }

  inline ChoreographerDisplayInfo& operator=(const ChoreographerDisplayInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChoreographerDisplayInfo& operator=(ChoreographerDisplayInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChoreographerDisplayInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChoreographerDisplayInfo* internal_default_instance() {
    return reinterpret_cast<const ChoreographerDisplayInfo*>(
               &_ChoreographerDisplayInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ChoreographerDisplayInfo& a, ChoreographerDisplayInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ChoreographerDisplayInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChoreographerDisplayInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChoreographerDisplayInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChoreographerDisplayInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChoreographerDisplayInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChoreographerDisplayInfo& from) {
    ChoreographerDisplayInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChoreographerDisplayInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ChoreographerDisplayInfo";
  }
  protected:
  explicit ChoreographerDisplayInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChoreographerDisplayInfo_Color Color;

  typedef ChoreographerDisplayInfo_Category Category;
  static constexpr Category CATEGORY_UNKNOWN =
    ChoreographerDisplayInfo_Category_CATEGORY_UNKNOWN;
  static constexpr Category CATEGORY_BODY =
    ChoreographerDisplayInfo_Category_CATEGORY_BODY;
  static constexpr Category CATEGORY_STEP =
    ChoreographerDisplayInfo_Category_CATEGORY_STEP;
  static constexpr Category CATEGORY_DYNAMIC =
    ChoreographerDisplayInfo_Category_CATEGORY_DYNAMIC;
  static constexpr Category CATEGORY_TRANSITION =
    ChoreographerDisplayInfo_Category_CATEGORY_TRANSITION;
  static constexpr Category CATEGORY_KNEEL =
    ChoreographerDisplayInfo_Category_CATEGORY_KNEEL;
  static constexpr Category CATEGORY_ARM =
    ChoreographerDisplayInfo_Category_CATEGORY_ARM;
  static constexpr Category CATEGORY_ANIMATION =
    ChoreographerDisplayInfo_Category_CATEGORY_ANIMATION;
  static constexpr Category CATEGORY_MPC =
    ChoreographerDisplayInfo_Category_CATEGORY_MPC;
  static constexpr Category CATEGORY_LIGHTS =
    ChoreographerDisplayInfo_Category_CATEGORY_LIGHTS;
  static constexpr Category CATEGORY_ANNOTATIONS =
    ChoreographerDisplayInfo_Category_CATEGORY_ANNOTATIONS;
  static inline bool Category_IsValid(int value) {
    return ChoreographerDisplayInfo_Category_IsValid(value);
  }
  static constexpr Category Category_MIN =
    ChoreographerDisplayInfo_Category_Category_MIN;
  static constexpr Category Category_MAX =
    ChoreographerDisplayInfo_Category_Category_MAX;
  static constexpr int Category_ARRAYSIZE =
    ChoreographerDisplayInfo_Category_Category_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Category_descriptor() {
    return ChoreographerDisplayInfo_Category_descriptor();
  }
  template<typename T>
  static inline const std::string& Category_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Category>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Category_Name.");
    return ChoreographerDisplayInfo_Category_Name(enum_t_value);
  }
  static inline bool Category_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Category* value) {
    return ChoreographerDisplayInfo_Category_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMarkersFieldNumber = 13,
    kDescriptionFieldNumber = 14,
    kImageFieldNumber = 15,
    kColorFieldNumber = 1,
    kCategoryFieldNumber = 16,
  };
  // repeated int32 markers = 13;
  int markers_size() const;
  private:
  int _internal_markers_size() const;
  public:
  void clear_markers();
  private:
  int32_t _internal_markers(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_markers() const;
  void _internal_add_markers(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_markers();
  public:
  int32_t markers(int index) const;
  void set_markers(int index, int32_t value);
  void add_markers(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      markers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_markers();

  // string description = 14;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string image = 15;
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // .bosdyn.api.spot.ChoreographerDisplayInfo.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::bosdyn::api::spot::ChoreographerDisplayInfo_Color& color() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::ChoreographerDisplayInfo_Color* release_color();
  ::bosdyn::api::spot::ChoreographerDisplayInfo_Color* mutable_color();
  void set_allocated_color(::bosdyn::api::spot::ChoreographerDisplayInfo_Color* color);
  private:
  const ::bosdyn::api::spot::ChoreographerDisplayInfo_Color& _internal_color() const;
  ::bosdyn::api::spot::ChoreographerDisplayInfo_Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::bosdyn::api::spot::ChoreographerDisplayInfo_Color* color);
  ::bosdyn::api::spot::ChoreographerDisplayInfo_Color* unsafe_arena_release_color();

  // .bosdyn.api.spot.ChoreographerDisplayInfo.Category category = 16;
  void clear_category();
  ::bosdyn::api::spot::ChoreographerDisplayInfo_Category category() const;
  void set_category(::bosdyn::api::spot::ChoreographerDisplayInfo_Category value);
  private:
  ::bosdyn::api::spot::ChoreographerDisplayInfo_Category _internal_category() const;
  void _internal_set_category(::bosdyn::api::spot::ChoreographerDisplayInfo_Category value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ChoreographerDisplayInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > markers_;
    mutable std::atomic<int> _markers_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
    ::bosdyn::api::spot::ChoreographerDisplayInfo_Color* color_;
    int category_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class ChoreographySequence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ChoreographySequence) */ {
 public:
  inline ChoreographySequence() : ChoreographySequence(nullptr) {}
  ~ChoreographySequence() override;
  explicit PROTOBUF_CONSTEXPR ChoreographySequence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChoreographySequence(const ChoreographySequence& from);
  ChoreographySequence(ChoreographySequence&& from) noexcept
    : ChoreographySequence() {
    *this = ::std::move(from);
  }

  inline ChoreographySequence& operator=(const ChoreographySequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChoreographySequence& operator=(ChoreographySequence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChoreographySequence& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChoreographySequence* internal_default_instance() {
    return reinterpret_cast<const ChoreographySequence*>(
               &_ChoreographySequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ChoreographySequence& a, ChoreographySequence& b) {
    a.Swap(&b);
  }
  inline void Swap(ChoreographySequence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChoreographySequence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChoreographySequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChoreographySequence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChoreographySequence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChoreographySequence& from) {
    ChoreographySequence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChoreographySequence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ChoreographySequence";
  }
  protected:
  explicit ChoreographySequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMovesFieldNumber = 3,
    kNameFieldNumber = 1,
    kChoreographyInfoFieldNumber = 4,
    kSlicesPerMinuteFieldNumber = 2,
  };
  // repeated .bosdyn.api.spot.MoveParams moves = 3;
  int moves_size() const;
  private:
  int _internal_moves_size() const;
  public:
  void clear_moves();
  ::bosdyn::api::spot::MoveParams* mutable_moves(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::MoveParams >*
      mutable_moves();
  private:
  const ::bosdyn::api::spot::MoveParams& _internal_moves(int index) const;
  ::bosdyn::api::spot::MoveParams* _internal_add_moves();
  public:
  const ::bosdyn::api::spot::MoveParams& moves(int index) const;
  ::bosdyn::api::spot::MoveParams* add_moves();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::MoveParams >&
      moves() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .bosdyn.api.spot.ChoreographyInfo choreography_info = 4;
  bool has_choreography_info() const;
  private:
  bool _internal_has_choreography_info() const;
  public:
  void clear_choreography_info();
  const ::bosdyn::api::spot::ChoreographyInfo& choreography_info() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::ChoreographyInfo* release_choreography_info();
  ::bosdyn::api::spot::ChoreographyInfo* mutable_choreography_info();
  void set_allocated_choreography_info(::bosdyn::api::spot::ChoreographyInfo* choreography_info);
  private:
  const ::bosdyn::api::spot::ChoreographyInfo& _internal_choreography_info() const;
  ::bosdyn::api::spot::ChoreographyInfo* _internal_mutable_choreography_info();
  public:
  void unsafe_arena_set_allocated_choreography_info(
      ::bosdyn::api::spot::ChoreographyInfo* choreography_info);
  ::bosdyn::api::spot::ChoreographyInfo* unsafe_arena_release_choreography_info();

  // double slices_per_minute = 2;
  void clear_slices_per_minute();
  double slices_per_minute() const;
  void set_slices_per_minute(double value);
  private:
  double _internal_slices_per_minute() const;
  void _internal_set_slices_per_minute(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ChoreographySequence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::MoveParams > moves_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::bosdyn::api::spot::ChoreographyInfo* choreography_info_;
    double slices_per_minute_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class ChoreographyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ChoreographyInfo) */ {
 public:
  inline ChoreographyInfo() : ChoreographyInfo(nullptr) {}
  ~ChoreographyInfo() override;
  explicit PROTOBUF_CONSTEXPR ChoreographyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChoreographyInfo(const ChoreographyInfo& from);
  ChoreographyInfo(ChoreographyInfo&& from) noexcept
    : ChoreographyInfo() {
    *this = ::std::move(from);
  }

  inline ChoreographyInfo& operator=(const ChoreographyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChoreographyInfo& operator=(ChoreographyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChoreographyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChoreographyInfo* internal_default_instance() {
    return reinterpret_cast<const ChoreographyInfo*>(
               &_ChoreographyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ChoreographyInfo& a, ChoreographyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ChoreographyInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChoreographyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChoreographyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChoreographyInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChoreographyInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChoreographyInfo& from) {
    ChoreographyInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChoreographyInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ChoreographyInfo";
  }
  protected:
  explicit ChoreographyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 4,
  };
  // repeated string labels = 4;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  const std::string& labels(int index) const;
  std::string* mutable_labels(int index);
  void set_labels(int index, const std::string& value);
  void set_labels(int index, std::string&& value);
  void set_labels(int index, const char* value);
  void set_labels(int index, const char* value, size_t size);
  std::string* add_labels();
  void add_labels(const std::string& value);
  void add_labels(std::string&& value);
  void add_labels(const char* value);
  void add_labels(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& labels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_labels();
  private:
  const std::string& _internal_labels(int index) const;
  std::string* _internal_add_labels();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ChoreographyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> labels_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class ChoreographerSave final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ChoreographerSave) */ {
 public:
  inline ChoreographerSave() : ChoreographerSave(nullptr) {}
  ~ChoreographerSave() override;
  explicit PROTOBUF_CONSTEXPR ChoreographerSave(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChoreographerSave(const ChoreographerSave& from);
  ChoreographerSave(ChoreographerSave&& from) noexcept
    : ChoreographerSave() {
    *this = ::std::move(from);
  }

  inline ChoreographerSave& operator=(const ChoreographerSave& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChoreographerSave& operator=(ChoreographerSave&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChoreographerSave& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChoreographerSave* internal_default_instance() {
    return reinterpret_cast<const ChoreographerSave*>(
               &_ChoreographerSave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ChoreographerSave& a, ChoreographerSave& b) {
    a.Swap(&b);
  }
  inline void Swap(ChoreographerSave* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChoreographerSave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChoreographerSave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChoreographerSave>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChoreographerSave& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChoreographerSave& from) {
    ChoreographerSave::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChoreographerSave* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ChoreographerSave";
  }
  protected:
  explicit ChoreographerSave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMusicFileFieldNumber = 2,
    kChoreographySequenceFieldNumber = 1,
    kMusicStartSliceFieldNumber = 3,
    kChoreographyStartSliceFieldNumber = 4,
  };
  // string music_file = 2;
  void clear_music_file();
  const std::string& music_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_music_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_music_file();
  PROTOBUF_NODISCARD std::string* release_music_file();
  void set_allocated_music_file(std::string* music_file);
  private:
  const std::string& _internal_music_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_music_file(const std::string& value);
  std::string* _internal_mutable_music_file();
  public:

  // .bosdyn.api.spot.ChoreographySequence choreography_sequence = 1;
  bool has_choreography_sequence() const;
  private:
  bool _internal_has_choreography_sequence() const;
  public:
  void clear_choreography_sequence();
  const ::bosdyn::api::spot::ChoreographySequence& choreography_sequence() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::ChoreographySequence* release_choreography_sequence();
  ::bosdyn::api::spot::ChoreographySequence* mutable_choreography_sequence();
  void set_allocated_choreography_sequence(::bosdyn::api::spot::ChoreographySequence* choreography_sequence);
  private:
  const ::bosdyn::api::spot::ChoreographySequence& _internal_choreography_sequence() const;
  ::bosdyn::api::spot::ChoreographySequence* _internal_mutable_choreography_sequence();
  public:
  void unsafe_arena_set_allocated_choreography_sequence(
      ::bosdyn::api::spot::ChoreographySequence* choreography_sequence);
  ::bosdyn::api::spot::ChoreographySequence* unsafe_arena_release_choreography_sequence();

  // double music_start_slice = 3;
  void clear_music_start_slice();
  double music_start_slice() const;
  void set_music_start_slice(double value);
  private:
  double _internal_music_start_slice() const;
  void _internal_set_music_start_slice(double value);
  public:

  // double choreography_start_slice = 4;
  void clear_choreography_start_slice();
  double choreography_start_slice() const;
  void set_choreography_start_slice(double value);
  private:
  double _internal_choreography_start_slice() const;
  void _internal_set_choreography_start_slice(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ChoreographerSave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr music_file_;
    ::bosdyn::api::spot::ChoreographySequence* choreography_sequence_;
    double music_start_slice_;
    double choreography_start_slice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class Animation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.Animation) */ {
 public:
  inline Animation() : Animation(nullptr) {}
  ~Animation() override;
  explicit PROTOBUF_CONSTEXPR Animation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Animation(const Animation& from);
  Animation(Animation&& from) noexcept
    : Animation() {
    *this = ::std::move(from);
  }

  inline Animation& operator=(const Animation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Animation& operator=(Animation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Animation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Animation* internal_default_instance() {
    return reinterpret_cast<const Animation*>(
               &_Animation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(Animation& a, Animation& b) {
    a.Swap(&b);
  }
  inline void Swap(Animation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Animation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Animation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Animation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Animation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Animation& from) {
    Animation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Animation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.Animation";
  }
  protected:
  explicit Animation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Animation_ArmPlayback ArmPlayback;
  static constexpr ArmPlayback ARM_PLAYBACK_DEFAULT =
    Animation_ArmPlayback_ARM_PLAYBACK_DEFAULT;
  static constexpr ArmPlayback ARM_PLAYBACK_JOINTSPACE =
    Animation_ArmPlayback_ARM_PLAYBACK_JOINTSPACE;
  static constexpr ArmPlayback ARM_PLAYBACK_WORKSPACE =
    Animation_ArmPlayback_ARM_PLAYBACK_WORKSPACE;
  static constexpr ArmPlayback ARM_PLAYBACK_WORKSPACE_DANCE_FRAME =
    Animation_ArmPlayback_ARM_PLAYBACK_WORKSPACE_DANCE_FRAME;
  static inline bool ArmPlayback_IsValid(int value) {
    return Animation_ArmPlayback_IsValid(value);
  }
  static constexpr ArmPlayback ArmPlayback_MIN =
    Animation_ArmPlayback_ArmPlayback_MIN;
  static constexpr ArmPlayback ArmPlayback_MAX =
    Animation_ArmPlayback_ArmPlayback_MAX;
  static constexpr int ArmPlayback_ARRAYSIZE =
    Animation_ArmPlayback_ArmPlayback_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ArmPlayback_descriptor() {
    return Animation_ArmPlayback_descriptor();
  }
  template<typename T>
  static inline const std::string& ArmPlayback_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ArmPlayback>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ArmPlayback_Name.");
    return Animation_ArmPlayback_Name(enum_t_value);
  }
  static inline bool ArmPlayback_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ArmPlayback* value) {
    return Animation_ArmPlayback_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAnimationKeyframesFieldNumber = 2,
    kNameFieldNumber = 1,
    kMinimumParametersFieldNumber = 9,
    kDefaultParametersFieldNumber = 10,
    kMaximumParametersFieldNumber = 11,
    kBpmFieldNumber = 7,
    kControlsArmFieldNumber = 3,
    kControlsLegsFieldNumber = 4,
    kControlsBodyFieldNumber = 5,
    kControlsGripperFieldNumber = 6,
    kTrackSwingTrajectoriesFieldNumber = 16,
    kAssumeZeroRollAndPitchFieldNumber = 19,
    kRetimeToIntegerSlicesFieldNumber = 8,
    kTruncatableFieldNumber = 12,
    kExtendableFieldNumber = 13,
    kNeutralStartFieldNumber = 14,
    kPreciseStepsFieldNumber = 15,
    kPreciseTimingFieldNumber = 18,
    kArmPlaybackFieldNumber = 17,
    kArmRequiredFieldNumber = 20,
    kArmProhibitedFieldNumber = 22,
    kNoLoopingFieldNumber = 21,
  };
  // repeated .bosdyn.api.spot.AnimationKeyframe animation_keyframes = 2;
  int animation_keyframes_size() const;
  private:
  int _internal_animation_keyframes_size() const;
  public:
  void clear_animation_keyframes();
  ::bosdyn::api::spot::AnimationKeyframe* mutable_animation_keyframes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::AnimationKeyframe >*
      mutable_animation_keyframes();
  private:
  const ::bosdyn::api::spot::AnimationKeyframe& _internal_animation_keyframes(int index) const;
  ::bosdyn::api::spot::AnimationKeyframe* _internal_add_animation_keyframes();
  public:
  const ::bosdyn::api::spot::AnimationKeyframe& animation_keyframes(int index) const;
  ::bosdyn::api::spot::AnimationKeyframe* add_animation_keyframes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::AnimationKeyframe >&
      animation_keyframes() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .bosdyn.api.spot.AnimateParams minimum_parameters = 9;
  bool has_minimum_parameters() const;
  private:
  bool _internal_has_minimum_parameters() const;
  public:
  void clear_minimum_parameters();
  const ::bosdyn::api::spot::AnimateParams& minimum_parameters() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::AnimateParams* release_minimum_parameters();
  ::bosdyn::api::spot::AnimateParams* mutable_minimum_parameters();
  void set_allocated_minimum_parameters(::bosdyn::api::spot::AnimateParams* minimum_parameters);
  private:
  const ::bosdyn::api::spot::AnimateParams& _internal_minimum_parameters() const;
  ::bosdyn::api::spot::AnimateParams* _internal_mutable_minimum_parameters();
  public:
  void unsafe_arena_set_allocated_minimum_parameters(
      ::bosdyn::api::spot::AnimateParams* minimum_parameters);
  ::bosdyn::api::spot::AnimateParams* unsafe_arena_release_minimum_parameters();

  // .bosdyn.api.spot.AnimateParams default_parameters = 10;
  bool has_default_parameters() const;
  private:
  bool _internal_has_default_parameters() const;
  public:
  void clear_default_parameters();
  const ::bosdyn::api::spot::AnimateParams& default_parameters() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::AnimateParams* release_default_parameters();
  ::bosdyn::api::spot::AnimateParams* mutable_default_parameters();
  void set_allocated_default_parameters(::bosdyn::api::spot::AnimateParams* default_parameters);
  private:
  const ::bosdyn::api::spot::AnimateParams& _internal_default_parameters() const;
  ::bosdyn::api::spot::AnimateParams* _internal_mutable_default_parameters();
  public:
  void unsafe_arena_set_allocated_default_parameters(
      ::bosdyn::api::spot::AnimateParams* default_parameters);
  ::bosdyn::api::spot::AnimateParams* unsafe_arena_release_default_parameters();

  // .bosdyn.api.spot.AnimateParams maximum_parameters = 11;
  bool has_maximum_parameters() const;
  private:
  bool _internal_has_maximum_parameters() const;
  public:
  void clear_maximum_parameters();
  const ::bosdyn::api::spot::AnimateParams& maximum_parameters() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::AnimateParams* release_maximum_parameters();
  ::bosdyn::api::spot::AnimateParams* mutable_maximum_parameters();
  void set_allocated_maximum_parameters(::bosdyn::api::spot::AnimateParams* maximum_parameters);
  private:
  const ::bosdyn::api::spot::AnimateParams& _internal_maximum_parameters() const;
  ::bosdyn::api::spot::AnimateParams* _internal_mutable_maximum_parameters();
  public:
  void unsafe_arena_set_allocated_maximum_parameters(
      ::bosdyn::api::spot::AnimateParams* maximum_parameters);
  ::bosdyn::api::spot::AnimateParams* unsafe_arena_release_maximum_parameters();

  // double bpm = 7;
  void clear_bpm();
  double bpm() const;
  void set_bpm(double value);
  private:
  double _internal_bpm() const;
  void _internal_set_bpm(double value);
  public:

  // bool controls_arm = 3;
  void clear_controls_arm();
  bool controls_arm() const;
  void set_controls_arm(bool value);
  private:
  bool _internal_controls_arm() const;
  void _internal_set_controls_arm(bool value);
  public:

  // bool controls_legs = 4;
  void clear_controls_legs();
  bool controls_legs() const;
  void set_controls_legs(bool value);
  private:
  bool _internal_controls_legs() const;
  void _internal_set_controls_legs(bool value);
  public:

  // bool controls_body = 5;
  void clear_controls_body();
  bool controls_body() const;
  void set_controls_body(bool value);
  private:
  bool _internal_controls_body() const;
  void _internal_set_controls_body(bool value);
  public:

  // bool controls_gripper = 6;
  void clear_controls_gripper();
  bool controls_gripper() const;
  void set_controls_gripper(bool value);
  private:
  bool _internal_controls_gripper() const;
  void _internal_set_controls_gripper(bool value);
  public:

  // bool track_swing_trajectories = 16;
  void clear_track_swing_trajectories();
  bool track_swing_trajectories() const;
  void set_track_swing_trajectories(bool value);
  private:
  bool _internal_track_swing_trajectories() const;
  void _internal_set_track_swing_trajectories(bool value);
  public:

  // bool assume_zero_roll_and_pitch = 19;
  void clear_assume_zero_roll_and_pitch();
  bool assume_zero_roll_and_pitch() const;
  void set_assume_zero_roll_and_pitch(bool value);
  private:
  bool _internal_assume_zero_roll_and_pitch() const;
  void _internal_set_assume_zero_roll_and_pitch(bool value);
  public:

  // bool retime_to_integer_slices = 8;
  void clear_retime_to_integer_slices();
  bool retime_to_integer_slices() const;
  void set_retime_to_integer_slices(bool value);
  private:
  bool _internal_retime_to_integer_slices() const;
  void _internal_set_retime_to_integer_slices(bool value);
  public:

  // bool truncatable = 12;
  void clear_truncatable();
  bool truncatable() const;
  void set_truncatable(bool value);
  private:
  bool _internal_truncatable() const;
  void _internal_set_truncatable(bool value);
  public:

  // bool extendable = 13;
  void clear_extendable();
  bool extendable() const;
  void set_extendable(bool value);
  private:
  bool _internal_extendable() const;
  void _internal_set_extendable(bool value);
  public:

  // bool neutral_start = 14;
  void clear_neutral_start();
  bool neutral_start() const;
  void set_neutral_start(bool value);
  private:
  bool _internal_neutral_start() const;
  void _internal_set_neutral_start(bool value);
  public:

  // bool precise_steps = 15;
  void clear_precise_steps();
  bool precise_steps() const;
  void set_precise_steps(bool value);
  private:
  bool _internal_precise_steps() const;
  void _internal_set_precise_steps(bool value);
  public:

  // bool precise_timing = 18;
  void clear_precise_timing();
  bool precise_timing() const;
  void set_precise_timing(bool value);
  private:
  bool _internal_precise_timing() const;
  void _internal_set_precise_timing(bool value);
  public:

  // .bosdyn.api.spot.Animation.ArmPlayback arm_playback = 17;
  void clear_arm_playback();
  ::bosdyn::api::spot::Animation_ArmPlayback arm_playback() const;
  void set_arm_playback(::bosdyn::api::spot::Animation_ArmPlayback value);
  private:
  ::bosdyn::api::spot::Animation_ArmPlayback _internal_arm_playback() const;
  void _internal_set_arm_playback(::bosdyn::api::spot::Animation_ArmPlayback value);
  public:

  // bool arm_required = 20;
  void clear_arm_required();
  bool arm_required() const;
  void set_arm_required(bool value);
  private:
  bool _internal_arm_required() const;
  void _internal_set_arm_required(bool value);
  public:

  // bool arm_prohibited = 22;
  void clear_arm_prohibited();
  bool arm_prohibited() const;
  void set_arm_prohibited(bool value);
  private:
  bool _internal_arm_prohibited() const;
  void _internal_set_arm_prohibited(bool value);
  public:

  // bool no_looping = 21;
  void clear_no_looping();
  bool no_looping() const;
  void set_no_looping(bool value);
  private:
  bool _internal_no_looping() const;
  void _internal_set_no_looping(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.Animation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::AnimationKeyframe > animation_keyframes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::bosdyn::api::spot::AnimateParams* minimum_parameters_;
    ::bosdyn::api::spot::AnimateParams* default_parameters_;
    ::bosdyn::api::spot::AnimateParams* maximum_parameters_;
    double bpm_;
    bool controls_arm_;
    bool controls_legs_;
    bool controls_body_;
    bool controls_gripper_;
    bool track_swing_trajectories_;
    bool assume_zero_roll_and_pitch_;
    bool retime_to_integer_slices_;
    bool truncatable_;
    bool extendable_;
    bool neutral_start_;
    bool precise_steps_;
    bool precise_timing_;
    int arm_playback_;
    bool arm_required_;
    bool arm_prohibited_;
    bool no_looping_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class AnimationKeyframe final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.AnimationKeyframe) */ {
 public:
  inline AnimationKeyframe() : AnimationKeyframe(nullptr) {}
  ~AnimationKeyframe() override;
  explicit PROTOBUF_CONSTEXPR AnimationKeyframe(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnimationKeyframe(const AnimationKeyframe& from);
  AnimationKeyframe(AnimationKeyframe&& from) noexcept
    : AnimationKeyframe() {
    *this = ::std::move(from);
  }

  inline AnimationKeyframe& operator=(const AnimationKeyframe& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnimationKeyframe& operator=(AnimationKeyframe&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnimationKeyframe& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnimationKeyframe* internal_default_instance() {
    return reinterpret_cast<const AnimationKeyframe*>(
               &_AnimationKeyframe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(AnimationKeyframe& a, AnimationKeyframe& b) {
    a.Swap(&b);
  }
  inline void Swap(AnimationKeyframe* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnimationKeyframe* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnimationKeyframe* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnimationKeyframe>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnimationKeyframe& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnimationKeyframe& from) {
    AnimationKeyframe::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnimationKeyframe* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.AnimationKeyframe";
  }
  protected:
  explicit AnimationKeyframe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGripperFieldNumber = 2,
    kArmFieldNumber = 3,
    kBodyFieldNumber = 4,
    kLegsFieldNumber = 5,
    kTimeFieldNumber = 1,
  };
  // .bosdyn.api.spot.AnimateGripper gripper = 2;
  bool has_gripper() const;
  private:
  bool _internal_has_gripper() const;
  public:
  void clear_gripper();
  const ::bosdyn::api::spot::AnimateGripper& gripper() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::AnimateGripper* release_gripper();
  ::bosdyn::api::spot::AnimateGripper* mutable_gripper();
  void set_allocated_gripper(::bosdyn::api::spot::AnimateGripper* gripper);
  private:
  const ::bosdyn::api::spot::AnimateGripper& _internal_gripper() const;
  ::bosdyn::api::spot::AnimateGripper* _internal_mutable_gripper();
  public:
  void unsafe_arena_set_allocated_gripper(
      ::bosdyn::api::spot::AnimateGripper* gripper);
  ::bosdyn::api::spot::AnimateGripper* unsafe_arena_release_gripper();

  // .bosdyn.api.spot.AnimateArm arm = 3;
  bool has_arm() const;
  private:
  bool _internal_has_arm() const;
  public:
  void clear_arm();
  const ::bosdyn::api::spot::AnimateArm& arm() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::AnimateArm* release_arm();
  ::bosdyn::api::spot::AnimateArm* mutable_arm();
  void set_allocated_arm(::bosdyn::api::spot::AnimateArm* arm);
  private:
  const ::bosdyn::api::spot::AnimateArm& _internal_arm() const;
  ::bosdyn::api::spot::AnimateArm* _internal_mutable_arm();
  public:
  void unsafe_arena_set_allocated_arm(
      ::bosdyn::api::spot::AnimateArm* arm);
  ::bosdyn::api::spot::AnimateArm* unsafe_arena_release_arm();

  // .bosdyn.api.spot.AnimateBody body = 4;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const ::bosdyn::api::spot::AnimateBody& body() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::AnimateBody* release_body();
  ::bosdyn::api::spot::AnimateBody* mutable_body();
  void set_allocated_body(::bosdyn::api::spot::AnimateBody* body);
  private:
  const ::bosdyn::api::spot::AnimateBody& _internal_body() const;
  ::bosdyn::api::spot::AnimateBody* _internal_mutable_body();
  public:
  void unsafe_arena_set_allocated_body(
      ::bosdyn::api::spot::AnimateBody* body);
  ::bosdyn::api::spot::AnimateBody* unsafe_arena_release_body();

  // .bosdyn.api.spot.AnimateLegs legs = 5;
  bool has_legs() const;
  private:
  bool _internal_has_legs() const;
  public:
  void clear_legs();
  const ::bosdyn::api::spot::AnimateLegs& legs() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::AnimateLegs* release_legs();
  ::bosdyn::api::spot::AnimateLegs* mutable_legs();
  void set_allocated_legs(::bosdyn::api::spot::AnimateLegs* legs);
  private:
  const ::bosdyn::api::spot::AnimateLegs& _internal_legs() const;
  ::bosdyn::api::spot::AnimateLegs* _internal_mutable_legs();
  public:
  void unsafe_arena_set_allocated_legs(
      ::bosdyn::api::spot::AnimateLegs* legs);
  ::bosdyn::api::spot::AnimateLegs* unsafe_arena_release_legs();

  // double time = 1;
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.AnimationKeyframe)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::spot::AnimateGripper* gripper_;
    ::bosdyn::api::spot::AnimateArm* arm_;
    ::bosdyn::api::spot::AnimateBody* body_;
    ::bosdyn::api::spot::AnimateLegs* legs_;
    double time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class AnimateGripper final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.AnimateGripper) */ {
 public:
  inline AnimateGripper() : AnimateGripper(nullptr) {}
  ~AnimateGripper() override;
  explicit PROTOBUF_CONSTEXPR AnimateGripper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnimateGripper(const AnimateGripper& from);
  AnimateGripper(AnimateGripper&& from) noexcept
    : AnimateGripper() {
    *this = ::std::move(from);
  }

  inline AnimateGripper& operator=(const AnimateGripper& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnimateGripper& operator=(AnimateGripper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnimateGripper& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnimateGripper* internal_default_instance() {
    return reinterpret_cast<const AnimateGripper*>(
               &_AnimateGripper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(AnimateGripper& a, AnimateGripper& b) {
    a.Swap(&b);
  }
  inline void Swap(AnimateGripper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnimateGripper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnimateGripper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnimateGripper>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnimateGripper& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnimateGripper& from) {
    AnimateGripper::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnimateGripper* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.AnimateGripper";
  }
  protected:
  explicit AnimateGripper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGripperAngleFieldNumber = 1,
  };
  // .google.protobuf.DoubleValue gripper_angle = 1;
  bool has_gripper_angle() const;
  private:
  bool _internal_has_gripper_angle() const;
  public:
  void clear_gripper_angle();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& gripper_angle() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_gripper_angle();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_gripper_angle();
  void set_allocated_gripper_angle(::PROTOBUF_NAMESPACE_ID::DoubleValue* gripper_angle);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_gripper_angle() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_gripper_angle();
  public:
  void unsafe_arena_set_allocated_gripper_angle(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* gripper_angle);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_gripper_angle();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.AnimateGripper)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* gripper_angle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class AnimateArm_HandPose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.AnimateArm.HandPose) */ {
 public:
  inline AnimateArm_HandPose() : AnimateArm_HandPose(nullptr) {}
  ~AnimateArm_HandPose() override;
  explicit PROTOBUF_CONSTEXPR AnimateArm_HandPose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnimateArm_HandPose(const AnimateArm_HandPose& from);
  AnimateArm_HandPose(AnimateArm_HandPose&& from) noexcept
    : AnimateArm_HandPose() {
    *this = ::std::move(from);
  }

  inline AnimateArm_HandPose& operator=(const AnimateArm_HandPose& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnimateArm_HandPose& operator=(AnimateArm_HandPose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnimateArm_HandPose& default_instance() {
    return *internal_default_instance();
  }
  enum OrientationCase {
    kEulerAngles = 3,
    kQuaternion = 4,
    ORIENTATION_NOT_SET = 0,
  };

  static inline const AnimateArm_HandPose* internal_default_instance() {
    return reinterpret_cast<const AnimateArm_HandPose*>(
               &_AnimateArm_HandPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(AnimateArm_HandPose& a, AnimateArm_HandPose& b) {
    a.Swap(&b);
  }
  inline void Swap(AnimateArm_HandPose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnimateArm_HandPose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnimateArm_HandPose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnimateArm_HandPose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnimateArm_HandPose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnimateArm_HandPose& from) {
    AnimateArm_HandPose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnimateArm_HandPose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.AnimateArm.HandPose";
  }
  protected:
  explicit AnimateArm_HandPose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kEulerAnglesFieldNumber = 3,
    kQuaternionFieldNumber = 4,
  };
  // .bosdyn.api.Vec3Value position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::bosdyn::api::Vec3Value& position() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3Value* release_position();
  ::bosdyn::api::Vec3Value* mutable_position();
  void set_allocated_position(::bosdyn::api::Vec3Value* position);
  private:
  const ::bosdyn::api::Vec3Value& _internal_position() const;
  ::bosdyn::api::Vec3Value* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::bosdyn::api::Vec3Value* position);
  ::bosdyn::api::Vec3Value* unsafe_arena_release_position();

  // .bosdyn.api.spot.EulerZYXValue euler_angles = 3;
  bool has_euler_angles() const;
  private:
  bool _internal_has_euler_angles() const;
  public:
  void clear_euler_angles();
  const ::bosdyn::api::spot::EulerZYXValue& euler_angles() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::EulerZYXValue* release_euler_angles();
  ::bosdyn::api::spot::EulerZYXValue* mutable_euler_angles();
  void set_allocated_euler_angles(::bosdyn::api::spot::EulerZYXValue* euler_angles);
  private:
  const ::bosdyn::api::spot::EulerZYXValue& _internal_euler_angles() const;
  ::bosdyn::api::spot::EulerZYXValue* _internal_mutable_euler_angles();
  public:
  void unsafe_arena_set_allocated_euler_angles(
      ::bosdyn::api::spot::EulerZYXValue* euler_angles);
  ::bosdyn::api::spot::EulerZYXValue* unsafe_arena_release_euler_angles();

  // .bosdyn.api.Quaternion quaternion = 4;
  bool has_quaternion() const;
  private:
  bool _internal_has_quaternion() const;
  public:
  void clear_quaternion();
  const ::bosdyn::api::Quaternion& quaternion() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Quaternion* release_quaternion();
  ::bosdyn::api::Quaternion* mutable_quaternion();
  void set_allocated_quaternion(::bosdyn::api::Quaternion* quaternion);
  private:
  const ::bosdyn::api::Quaternion& _internal_quaternion() const;
  ::bosdyn::api::Quaternion* _internal_mutable_quaternion();
  public:
  void unsafe_arena_set_allocated_quaternion(
      ::bosdyn::api::Quaternion* quaternion);
  ::bosdyn::api::Quaternion* unsafe_arena_release_quaternion();

  void clear_orientation();
  OrientationCase orientation_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.AnimateArm.HandPose)
 private:
  class _Internal;
  void set_has_euler_angles();
  void set_has_quaternion();

  inline bool has_orientation() const;
  inline void clear_has_orientation();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::Vec3Value* position_;
    union OrientationUnion {
      constexpr OrientationUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::spot::EulerZYXValue* euler_angles_;
      ::bosdyn::api::Quaternion* quaternion_;
    } orientation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class AnimateArm final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.AnimateArm) */ {
 public:
  inline AnimateArm() : AnimateArm(nullptr) {}
  ~AnimateArm() override;
  explicit PROTOBUF_CONSTEXPR AnimateArm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnimateArm(const AnimateArm& from);
  AnimateArm(AnimateArm&& from) noexcept
    : AnimateArm() {
    *this = ::std::move(from);
  }

  inline AnimateArm& operator=(const AnimateArm& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnimateArm& operator=(AnimateArm&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnimateArm& default_instance() {
    return *internal_default_instance();
  }
  enum ArmCase {
    kJointAngles = 1,
    kHandPose = 2,
    ARM_NOT_SET = 0,
  };

  static inline const AnimateArm* internal_default_instance() {
    return reinterpret_cast<const AnimateArm*>(
               &_AnimateArm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(AnimateArm& a, AnimateArm& b) {
    a.Swap(&b);
  }
  inline void Swap(AnimateArm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnimateArm* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnimateArm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnimateArm>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnimateArm& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnimateArm& from) {
    AnimateArm::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnimateArm* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.AnimateArm";
  }
  protected:
  explicit AnimateArm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AnimateArm_HandPose HandPose;

  // accessors -------------------------------------------------------

  enum : int {
    kJointAnglesFieldNumber = 1,
    kHandPoseFieldNumber = 2,
  };
  // .bosdyn.api.spot.ArmJointAngles joint_angles = 1;
  bool has_joint_angles() const;
  private:
  bool _internal_has_joint_angles() const;
  public:
  void clear_joint_angles();
  const ::bosdyn::api::spot::ArmJointAngles& joint_angles() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::ArmJointAngles* release_joint_angles();
  ::bosdyn::api::spot::ArmJointAngles* mutable_joint_angles();
  void set_allocated_joint_angles(::bosdyn::api::spot::ArmJointAngles* joint_angles);
  private:
  const ::bosdyn::api::spot::ArmJointAngles& _internal_joint_angles() const;
  ::bosdyn::api::spot::ArmJointAngles* _internal_mutable_joint_angles();
  public:
  void unsafe_arena_set_allocated_joint_angles(
      ::bosdyn::api::spot::ArmJointAngles* joint_angles);
  ::bosdyn::api::spot::ArmJointAngles* unsafe_arena_release_joint_angles();

  // .bosdyn.api.spot.AnimateArm.HandPose hand_pose = 2;
  bool has_hand_pose() const;
  private:
  bool _internal_has_hand_pose() const;
  public:
  void clear_hand_pose();
  const ::bosdyn::api::spot::AnimateArm_HandPose& hand_pose() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::AnimateArm_HandPose* release_hand_pose();
  ::bosdyn::api::spot::AnimateArm_HandPose* mutable_hand_pose();
  void set_allocated_hand_pose(::bosdyn::api::spot::AnimateArm_HandPose* hand_pose);
  private:
  const ::bosdyn::api::spot::AnimateArm_HandPose& _internal_hand_pose() const;
  ::bosdyn::api::spot::AnimateArm_HandPose* _internal_mutable_hand_pose();
  public:
  void unsafe_arena_set_allocated_hand_pose(
      ::bosdyn::api::spot::AnimateArm_HandPose* hand_pose);
  ::bosdyn::api::spot::AnimateArm_HandPose* unsafe_arena_release_hand_pose();

  void clear_arm();
  ArmCase arm_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.AnimateArm)
 private:
  class _Internal;
  void set_has_joint_angles();
  void set_has_hand_pose();

  inline bool has_arm() const;
  inline void clear_has_arm();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ArmUnion {
      constexpr ArmUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::spot::ArmJointAngles* joint_angles_;
      ::bosdyn::api::spot::AnimateArm_HandPose* hand_pose_;
    } arm_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class ArmJointAngles final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.ArmJointAngles) */ {
 public:
  inline ArmJointAngles() : ArmJointAngles(nullptr) {}
  ~ArmJointAngles() override;
  explicit PROTOBUF_CONSTEXPR ArmJointAngles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArmJointAngles(const ArmJointAngles& from);
  ArmJointAngles(ArmJointAngles&& from) noexcept
    : ArmJointAngles() {
    *this = ::std::move(from);
  }

  inline ArmJointAngles& operator=(const ArmJointAngles& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArmJointAngles& operator=(ArmJointAngles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArmJointAngles& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArmJointAngles* internal_default_instance() {
    return reinterpret_cast<const ArmJointAngles*>(
               &_ArmJointAngles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ArmJointAngles& a, ArmJointAngles& b) {
    a.Swap(&b);
  }
  inline void Swap(ArmJointAngles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArmJointAngles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArmJointAngles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArmJointAngles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArmJointAngles& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArmJointAngles& from) {
    ArmJointAngles::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArmJointAngles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.ArmJointAngles";
  }
  protected:
  explicit ArmJointAngles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShoulder0FieldNumber = 1,
    kShoulder1FieldNumber = 2,
    kElbow0FieldNumber = 3,
    kElbow1FieldNumber = 4,
    kWrist0FieldNumber = 5,
    kWrist1FieldNumber = 6,
  };
  // .google.protobuf.DoubleValue shoulder_0 = 1;
  bool has_shoulder_0() const;
  private:
  bool _internal_has_shoulder_0() const;
  public:
  void clear_shoulder_0();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& shoulder_0() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_shoulder_0();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_shoulder_0();
  void set_allocated_shoulder_0(::PROTOBUF_NAMESPACE_ID::DoubleValue* shoulder_0);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_shoulder_0() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_shoulder_0();
  public:
  void unsafe_arena_set_allocated_shoulder_0(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* shoulder_0);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_shoulder_0();

  // .google.protobuf.DoubleValue shoulder_1 = 2;
  bool has_shoulder_1() const;
  private:
  bool _internal_has_shoulder_1() const;
  public:
  void clear_shoulder_1();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& shoulder_1() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_shoulder_1();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_shoulder_1();
  void set_allocated_shoulder_1(::PROTOBUF_NAMESPACE_ID::DoubleValue* shoulder_1);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_shoulder_1() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_shoulder_1();
  public:
  void unsafe_arena_set_allocated_shoulder_1(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* shoulder_1);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_shoulder_1();

  // .google.protobuf.DoubleValue elbow_0 = 3;
  bool has_elbow_0() const;
  private:
  bool _internal_has_elbow_0() const;
  public:
  void clear_elbow_0();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& elbow_0() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_elbow_0();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_elbow_0();
  void set_allocated_elbow_0(::PROTOBUF_NAMESPACE_ID::DoubleValue* elbow_0);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_elbow_0() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_elbow_0();
  public:
  void unsafe_arena_set_allocated_elbow_0(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* elbow_0);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_elbow_0();

  // .google.protobuf.DoubleValue elbow_1 = 4;
  bool has_elbow_1() const;
  private:
  bool _internal_has_elbow_1() const;
  public:
  void clear_elbow_1();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& elbow_1() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_elbow_1();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_elbow_1();
  void set_allocated_elbow_1(::PROTOBUF_NAMESPACE_ID::DoubleValue* elbow_1);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_elbow_1() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_elbow_1();
  public:
  void unsafe_arena_set_allocated_elbow_1(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* elbow_1);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_elbow_1();

  // .google.protobuf.DoubleValue wrist_0 = 5;
  bool has_wrist_0() const;
  private:
  bool _internal_has_wrist_0() const;
  public:
  void clear_wrist_0();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& wrist_0() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_wrist_0();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_wrist_0();
  void set_allocated_wrist_0(::PROTOBUF_NAMESPACE_ID::DoubleValue* wrist_0);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_wrist_0() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_wrist_0();
  public:
  void unsafe_arena_set_allocated_wrist_0(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* wrist_0);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_wrist_0();

  // .google.protobuf.DoubleValue wrist_1 = 6;
  bool has_wrist_1() const;
  private:
  bool _internal_has_wrist_1() const;
  public:
  void clear_wrist_1();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& wrist_1() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_wrist_1();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_wrist_1();
  void set_allocated_wrist_1(::PROTOBUF_NAMESPACE_ID::DoubleValue* wrist_1);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_wrist_1() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_wrist_1();
  public:
  void unsafe_arena_set_allocated_wrist_1(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* wrist_1);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_wrist_1();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.ArmJointAngles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* shoulder_0_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* shoulder_1_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* elbow_0_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* elbow_1_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* wrist_0_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* wrist_1_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class AnimateBody final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.AnimateBody) */ {
 public:
  inline AnimateBody() : AnimateBody(nullptr) {}
  ~AnimateBody() override;
  explicit PROTOBUF_CONSTEXPR AnimateBody(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnimateBody(const AnimateBody& from);
  AnimateBody(AnimateBody&& from) noexcept
    : AnimateBody() {
    *this = ::std::move(from);
  }

  inline AnimateBody& operator=(const AnimateBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnimateBody& operator=(AnimateBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnimateBody& default_instance() {
    return *internal_default_instance();
  }
  enum PositionCase {
    kBodyPos = 1,
    kComPos = 2,
    POSITION_NOT_SET = 0,
  };

  enum OrientationCase {
    kEulerAngles = 3,
    kQuaternion = 4,
    ORIENTATION_NOT_SET = 0,
  };

  static inline const AnimateBody* internal_default_instance() {
    return reinterpret_cast<const AnimateBody*>(
               &_AnimateBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(AnimateBody& a, AnimateBody& b) {
    a.Swap(&b);
  }
  inline void Swap(AnimateBody* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnimateBody* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnimateBody* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnimateBody>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnimateBody& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnimateBody& from) {
    AnimateBody::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnimateBody* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.AnimateBody";
  }
  protected:
  explicit AnimateBody(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBodyPosFieldNumber = 1,
    kComPosFieldNumber = 2,
    kEulerAnglesFieldNumber = 3,
    kQuaternionFieldNumber = 4,
  };
  // .bosdyn.api.Vec3Value body_pos = 1;
  bool has_body_pos() const;
  private:
  bool _internal_has_body_pos() const;
  public:
  void clear_body_pos();
  const ::bosdyn::api::Vec3Value& body_pos() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3Value* release_body_pos();
  ::bosdyn::api::Vec3Value* mutable_body_pos();
  void set_allocated_body_pos(::bosdyn::api::Vec3Value* body_pos);
  private:
  const ::bosdyn::api::Vec3Value& _internal_body_pos() const;
  ::bosdyn::api::Vec3Value* _internal_mutable_body_pos();
  public:
  void unsafe_arena_set_allocated_body_pos(
      ::bosdyn::api::Vec3Value* body_pos);
  ::bosdyn::api::Vec3Value* unsafe_arena_release_body_pos();

  // .bosdyn.api.Vec3Value com_pos = 2;
  bool has_com_pos() const;
  private:
  bool _internal_has_com_pos() const;
  public:
  void clear_com_pos();
  const ::bosdyn::api::Vec3Value& com_pos() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3Value* release_com_pos();
  ::bosdyn::api::Vec3Value* mutable_com_pos();
  void set_allocated_com_pos(::bosdyn::api::Vec3Value* com_pos);
  private:
  const ::bosdyn::api::Vec3Value& _internal_com_pos() const;
  ::bosdyn::api::Vec3Value* _internal_mutable_com_pos();
  public:
  void unsafe_arena_set_allocated_com_pos(
      ::bosdyn::api::Vec3Value* com_pos);
  ::bosdyn::api::Vec3Value* unsafe_arena_release_com_pos();

  // .bosdyn.api.spot.EulerZYXValue euler_angles = 3;
  bool has_euler_angles() const;
  private:
  bool _internal_has_euler_angles() const;
  public:
  void clear_euler_angles();
  const ::bosdyn::api::spot::EulerZYXValue& euler_angles() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::EulerZYXValue* release_euler_angles();
  ::bosdyn::api::spot::EulerZYXValue* mutable_euler_angles();
  void set_allocated_euler_angles(::bosdyn::api::spot::EulerZYXValue* euler_angles);
  private:
  const ::bosdyn::api::spot::EulerZYXValue& _internal_euler_angles() const;
  ::bosdyn::api::spot::EulerZYXValue* _internal_mutable_euler_angles();
  public:
  void unsafe_arena_set_allocated_euler_angles(
      ::bosdyn::api::spot::EulerZYXValue* euler_angles);
  ::bosdyn::api::spot::EulerZYXValue* unsafe_arena_release_euler_angles();

  // .bosdyn.api.Quaternion quaternion = 4;
  bool has_quaternion() const;
  private:
  bool _internal_has_quaternion() const;
  public:
  void clear_quaternion();
  const ::bosdyn::api::Quaternion& quaternion() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Quaternion* release_quaternion();
  ::bosdyn::api::Quaternion* mutable_quaternion();
  void set_allocated_quaternion(::bosdyn::api::Quaternion* quaternion);
  private:
  const ::bosdyn::api::Quaternion& _internal_quaternion() const;
  ::bosdyn::api::Quaternion* _internal_mutable_quaternion();
  public:
  void unsafe_arena_set_allocated_quaternion(
      ::bosdyn::api::Quaternion* quaternion);
  ::bosdyn::api::Quaternion* unsafe_arena_release_quaternion();

  void clear_position();
  PositionCase position_case() const;
  void clear_orientation();
  OrientationCase orientation_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.AnimateBody)
 private:
  class _Internal;
  void set_has_body_pos();
  void set_has_com_pos();
  void set_has_euler_angles();
  void set_has_quaternion();

  inline bool has_position() const;
  inline void clear_has_position();

  inline bool has_orientation() const;
  inline void clear_has_orientation();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PositionUnion {
      constexpr PositionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::Vec3Value* body_pos_;
      ::bosdyn::api::Vec3Value* com_pos_;
    } position_;
    union OrientationUnion {
      constexpr OrientationUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::spot::EulerZYXValue* euler_angles_;
      ::bosdyn::api::Quaternion* quaternion_;
    } orientation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class AnimateLegs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.AnimateLegs) */ {
 public:
  inline AnimateLegs() : AnimateLegs(nullptr) {}
  ~AnimateLegs() override;
  explicit PROTOBUF_CONSTEXPR AnimateLegs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnimateLegs(const AnimateLegs& from);
  AnimateLegs(AnimateLegs&& from) noexcept
    : AnimateLegs() {
    *this = ::std::move(from);
  }

  inline AnimateLegs& operator=(const AnimateLegs& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnimateLegs& operator=(AnimateLegs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnimateLegs& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnimateLegs* internal_default_instance() {
    return reinterpret_cast<const AnimateLegs*>(
               &_AnimateLegs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(AnimateLegs& a, AnimateLegs& b) {
    a.Swap(&b);
  }
  inline void Swap(AnimateLegs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnimateLegs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnimateLegs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnimateLegs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnimateLegs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnimateLegs& from) {
    AnimateLegs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnimateLegs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.AnimateLegs";
  }
  protected:
  explicit AnimateLegs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlFieldNumber = 1,
    kFrFieldNumber = 2,
    kHlFieldNumber = 3,
    kHrFieldNumber = 4,
  };
  // .bosdyn.api.spot.AnimateSingleLeg fl = 1;
  bool has_fl() const;
  private:
  bool _internal_has_fl() const;
  public:
  void clear_fl();
  const ::bosdyn::api::spot::AnimateSingleLeg& fl() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::AnimateSingleLeg* release_fl();
  ::bosdyn::api::spot::AnimateSingleLeg* mutable_fl();
  void set_allocated_fl(::bosdyn::api::spot::AnimateSingleLeg* fl);
  private:
  const ::bosdyn::api::spot::AnimateSingleLeg& _internal_fl() const;
  ::bosdyn::api::spot::AnimateSingleLeg* _internal_mutable_fl();
  public:
  void unsafe_arena_set_allocated_fl(
      ::bosdyn::api::spot::AnimateSingleLeg* fl);
  ::bosdyn::api::spot::AnimateSingleLeg* unsafe_arena_release_fl();

  // .bosdyn.api.spot.AnimateSingleLeg fr = 2;
  bool has_fr() const;
  private:
  bool _internal_has_fr() const;
  public:
  void clear_fr();
  const ::bosdyn::api::spot::AnimateSingleLeg& fr() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::AnimateSingleLeg* release_fr();
  ::bosdyn::api::spot::AnimateSingleLeg* mutable_fr();
  void set_allocated_fr(::bosdyn::api::spot::AnimateSingleLeg* fr);
  private:
  const ::bosdyn::api::spot::AnimateSingleLeg& _internal_fr() const;
  ::bosdyn::api::spot::AnimateSingleLeg* _internal_mutable_fr();
  public:
  void unsafe_arena_set_allocated_fr(
      ::bosdyn::api::spot::AnimateSingleLeg* fr);
  ::bosdyn::api::spot::AnimateSingleLeg* unsafe_arena_release_fr();

  // .bosdyn.api.spot.AnimateSingleLeg hl = 3;
  bool has_hl() const;
  private:
  bool _internal_has_hl() const;
  public:
  void clear_hl();
  const ::bosdyn::api::spot::AnimateSingleLeg& hl() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::AnimateSingleLeg* release_hl();
  ::bosdyn::api::spot::AnimateSingleLeg* mutable_hl();
  void set_allocated_hl(::bosdyn::api::spot::AnimateSingleLeg* hl);
  private:
  const ::bosdyn::api::spot::AnimateSingleLeg& _internal_hl() const;
  ::bosdyn::api::spot::AnimateSingleLeg* _internal_mutable_hl();
  public:
  void unsafe_arena_set_allocated_hl(
      ::bosdyn::api::spot::AnimateSingleLeg* hl);
  ::bosdyn::api::spot::AnimateSingleLeg* unsafe_arena_release_hl();

  // .bosdyn.api.spot.AnimateSingleLeg hr = 4;
  bool has_hr() const;
  private:
  bool _internal_has_hr() const;
  public:
  void clear_hr();
  const ::bosdyn::api::spot::AnimateSingleLeg& hr() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::AnimateSingleLeg* release_hr();
  ::bosdyn::api::spot::AnimateSingleLeg* mutable_hr();
  void set_allocated_hr(::bosdyn::api::spot::AnimateSingleLeg* hr);
  private:
  const ::bosdyn::api::spot::AnimateSingleLeg& _internal_hr() const;
  ::bosdyn::api::spot::AnimateSingleLeg* _internal_mutable_hr();
  public:
  void unsafe_arena_set_allocated_hr(
      ::bosdyn::api::spot::AnimateSingleLeg* hr);
  ::bosdyn::api::spot::AnimateSingleLeg* unsafe_arena_release_hr();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.AnimateLegs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::bosdyn::api::spot::AnimateSingleLeg* fl_;
    ::bosdyn::api::spot::AnimateSingleLeg* fr_;
    ::bosdyn::api::spot::AnimateSingleLeg* hl_;
    ::bosdyn::api::spot::AnimateSingleLeg* hr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class AnimateSingleLeg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.AnimateSingleLeg) */ {
 public:
  inline AnimateSingleLeg() : AnimateSingleLeg(nullptr) {}
  ~AnimateSingleLeg() override;
  explicit PROTOBUF_CONSTEXPR AnimateSingleLeg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnimateSingleLeg(const AnimateSingleLeg& from);
  AnimateSingleLeg(AnimateSingleLeg&& from) noexcept
    : AnimateSingleLeg() {
    *this = ::std::move(from);
  }

  inline AnimateSingleLeg& operator=(const AnimateSingleLeg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnimateSingleLeg& operator=(AnimateSingleLeg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnimateSingleLeg& default_instance() {
    return *internal_default_instance();
  }
  enum LegCase {
    kJointAngles = 1,
    kFootPos = 2,
    LEG_NOT_SET = 0,
  };

  static inline const AnimateSingleLeg* internal_default_instance() {
    return reinterpret_cast<const AnimateSingleLeg*>(
               &_AnimateSingleLeg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(AnimateSingleLeg& a, AnimateSingleLeg& b) {
    a.Swap(&b);
  }
  inline void Swap(AnimateSingleLeg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnimateSingleLeg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnimateSingleLeg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnimateSingleLeg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnimateSingleLeg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnimateSingleLeg& from) {
    AnimateSingleLeg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnimateSingleLeg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.AnimateSingleLeg";
  }
  protected:
  explicit AnimateSingleLeg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStanceFieldNumber = 3,
    kJointAnglesFieldNumber = 1,
    kFootPosFieldNumber = 2,
  };
  // .google.protobuf.BoolValue stance = 3;
  bool has_stance() const;
  private:
  bool _internal_has_stance() const;
  public:
  void clear_stance();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& stance() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_stance();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_stance();
  void set_allocated_stance(::PROTOBUF_NAMESPACE_ID::BoolValue* stance);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_stance() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_stance();
  public:
  void unsafe_arena_set_allocated_stance(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* stance);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_stance();

  // .bosdyn.api.spot.LegJointAngles joint_angles = 1;
  bool has_joint_angles() const;
  private:
  bool _internal_has_joint_angles() const;
  public:
  void clear_joint_angles();
  const ::bosdyn::api::spot::LegJointAngles& joint_angles() const;
  PROTOBUF_NODISCARD ::bosdyn::api::spot::LegJointAngles* release_joint_angles();
  ::bosdyn::api::spot::LegJointAngles* mutable_joint_angles();
  void set_allocated_joint_angles(::bosdyn::api::spot::LegJointAngles* joint_angles);
  private:
  const ::bosdyn::api::spot::LegJointAngles& _internal_joint_angles() const;
  ::bosdyn::api::spot::LegJointAngles* _internal_mutable_joint_angles();
  public:
  void unsafe_arena_set_allocated_joint_angles(
      ::bosdyn::api::spot::LegJointAngles* joint_angles);
  ::bosdyn::api::spot::LegJointAngles* unsafe_arena_release_joint_angles();

  // .bosdyn.api.Vec3Value foot_pos = 2;
  bool has_foot_pos() const;
  private:
  bool _internal_has_foot_pos() const;
  public:
  void clear_foot_pos();
  const ::bosdyn::api::Vec3Value& foot_pos() const;
  PROTOBUF_NODISCARD ::bosdyn::api::Vec3Value* release_foot_pos();
  ::bosdyn::api::Vec3Value* mutable_foot_pos();
  void set_allocated_foot_pos(::bosdyn::api::Vec3Value* foot_pos);
  private:
  const ::bosdyn::api::Vec3Value& _internal_foot_pos() const;
  ::bosdyn::api::Vec3Value* _internal_mutable_foot_pos();
  public:
  void unsafe_arena_set_allocated_foot_pos(
      ::bosdyn::api::Vec3Value* foot_pos);
  ::bosdyn::api::Vec3Value* unsafe_arena_release_foot_pos();

  void clear_leg();
  LegCase leg_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.AnimateSingleLeg)
 private:
  class _Internal;
  void set_has_joint_angles();
  void set_has_foot_pos();

  inline bool has_leg() const;
  inline void clear_has_leg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::BoolValue* stance_;
    union LegUnion {
      constexpr LegUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosdyn::api::spot::LegJointAngles* joint_angles_;
      ::bosdyn::api::Vec3Value* foot_pos_;
    } leg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// -------------------------------------------------------------------

class LegJointAngles final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.LegJointAngles) */ {
 public:
  inline LegJointAngles() : LegJointAngles(nullptr) {}
  ~LegJointAngles() override;
  explicit PROTOBUF_CONSTEXPR LegJointAngles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LegJointAngles(const LegJointAngles& from);
  LegJointAngles(LegJointAngles&& from) noexcept
    : LegJointAngles() {
    *this = ::std::move(from);
  }

  inline LegJointAngles& operator=(const LegJointAngles& from) {
    CopyFrom(from);
    return *this;
  }
  inline LegJointAngles& operator=(LegJointAngles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LegJointAngles& default_instance() {
    return *internal_default_instance();
  }
  static inline const LegJointAngles* internal_default_instance() {
    return reinterpret_cast<const LegJointAngles*>(
               &_LegJointAngles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(LegJointAngles& a, LegJointAngles& b) {
    a.Swap(&b);
  }
  inline void Swap(LegJointAngles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LegJointAngles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LegJointAngles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LegJointAngles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LegJointAngles& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LegJointAngles& from) {
    LegJointAngles::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LegJointAngles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.LegJointAngles";
  }
  protected:
  explicit LegJointAngles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHipXFieldNumber = 1,
    kHipYFieldNumber = 2,
    kKneeFieldNumber = 3,
  };
  // double hip_x = 1;
  void clear_hip_x();
  double hip_x() const;
  void set_hip_x(double value);
  private:
  double _internal_hip_x() const;
  void _internal_set_hip_x(double value);
  public:

  // double hip_y = 2;
  void clear_hip_y();
  double hip_y() const;
  void set_hip_y(double value);
  private:
  double _internal_hip_y() const;
  void _internal_set_hip_y(double value);
  public:

  // double knee = 3;
  void clear_knee();
  double knee() const;
  void set_knee(double value);
  private:
  double _internal_knee() const;
  void _internal_set_knee(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.LegJointAngles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double hip_x_;
    double hip_y_;
    double knee_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ListAllMovesRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListAllMovesRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListAllMovesRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListAllMovesRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListAllMovesRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ListAllMovesRequest.header)
  return _internal_header();
}
inline void ListAllMovesRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ListAllMovesRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListAllMovesRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListAllMovesRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ListAllMovesRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListAllMovesRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ListAllMovesRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ListAllMovesRequest.header)
  return _msg;
}
inline void ListAllMovesRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ListAllMovesRequest.header)
}

// -------------------------------------------------------------------

// ListAllMovesResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListAllMovesResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListAllMovesResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListAllMovesResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListAllMovesResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ListAllMovesResponse.header)
  return _internal_header();
}
inline void ListAllMovesResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ListAllMovesResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListAllMovesResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListAllMovesResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ListAllMovesResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListAllMovesResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ListAllMovesResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ListAllMovesResponse.header)
  return _msg;
}
inline void ListAllMovesResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ListAllMovesResponse.header)
}

// repeated .bosdyn.api.spot.MoveInfo moves = 2;
inline int ListAllMovesResponse::_internal_moves_size() const {
  return _impl_.moves_.size();
}
inline int ListAllMovesResponse::moves_size() const {
  return _internal_moves_size();
}
inline void ListAllMovesResponse::clear_moves() {
  _impl_.moves_.Clear();
}
inline ::bosdyn::api::spot::MoveInfo* ListAllMovesResponse::mutable_moves(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ListAllMovesResponse.moves)
  return _impl_.moves_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::MoveInfo >*
ListAllMovesResponse::mutable_moves() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.ListAllMovesResponse.moves)
  return &_impl_.moves_;
}
inline const ::bosdyn::api::spot::MoveInfo& ListAllMovesResponse::_internal_moves(int index) const {
  return _impl_.moves_.Get(index);
}
inline const ::bosdyn::api::spot::MoveInfo& ListAllMovesResponse::moves(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ListAllMovesResponse.moves)
  return _internal_moves(index);
}
inline ::bosdyn::api::spot::MoveInfo* ListAllMovesResponse::_internal_add_moves() {
  return _impl_.moves_.Add();
}
inline ::bosdyn::api::spot::MoveInfo* ListAllMovesResponse::add_moves() {
  ::bosdyn::api::spot::MoveInfo* _add = _internal_add_moves();
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.ListAllMovesResponse.moves)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::MoveInfo >&
ListAllMovesResponse::moves() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.ListAllMovesResponse.moves)
  return _impl_.moves_;
}

// string move_param_config = 3;
inline void ListAllMovesResponse::clear_move_param_config() {
  _impl_.move_param_config_.ClearToEmpty();
}
inline const std::string& ListAllMovesResponse::move_param_config() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ListAllMovesResponse.move_param_config)
  return _internal_move_param_config();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListAllMovesResponse::set_move_param_config(ArgT0&& arg0, ArgT... args) {
 
 _impl_.move_param_config_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ListAllMovesResponse.move_param_config)
}
inline std::string* ListAllMovesResponse::mutable_move_param_config() {
  std::string* _s = _internal_mutable_move_param_config();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ListAllMovesResponse.move_param_config)
  return _s;
}
inline const std::string& ListAllMovesResponse::_internal_move_param_config() const {
  return _impl_.move_param_config_.Get();
}
inline void ListAllMovesResponse::_internal_set_move_param_config(const std::string& value) {
  
  _impl_.move_param_config_.Set(value, GetArenaForAllocation());
}
inline std::string* ListAllMovesResponse::_internal_mutable_move_param_config() {
  
  return _impl_.move_param_config_.Mutable(GetArenaForAllocation());
}
inline std::string* ListAllMovesResponse::release_move_param_config() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ListAllMovesResponse.move_param_config)
  return _impl_.move_param_config_.Release();
}
inline void ListAllMovesResponse::set_allocated_move_param_config(std::string* move_param_config) {
  if (move_param_config != nullptr) {
    
  } else {
    
  }
  _impl_.move_param_config_.SetAllocated(move_param_config, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.move_param_config_.IsDefault()) {
    _impl_.move_param_config_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ListAllMovesResponse.move_param_config)
}

// -------------------------------------------------------------------

// ListAllSequencesRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListAllSequencesRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListAllSequencesRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListAllSequencesRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListAllSequencesRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ListAllSequencesRequest.header)
  return _internal_header();
}
inline void ListAllSequencesRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ListAllSequencesRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListAllSequencesRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListAllSequencesRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ListAllSequencesRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListAllSequencesRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ListAllSequencesRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ListAllSequencesRequest.header)
  return _msg;
}
inline void ListAllSequencesRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ListAllSequencesRequest.header)
}

// -------------------------------------------------------------------

// ListAllSequencesResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListAllSequencesResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ListAllSequencesResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListAllSequencesResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListAllSequencesResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ListAllSequencesResponse.header)
  return _internal_header();
}
inline void ListAllSequencesResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ListAllSequencesResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListAllSequencesResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListAllSequencesResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ListAllSequencesResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListAllSequencesResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ListAllSequencesResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ListAllSequencesResponse.header)
  return _msg;
}
inline void ListAllSequencesResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ListAllSequencesResponse.header)
}

// repeated string known_sequences = 2 [deprecated = true];
inline int ListAllSequencesResponse::_internal_known_sequences_size() const {
  return _impl_.known_sequences_.size();
}
inline int ListAllSequencesResponse::known_sequences_size() const {
  return _internal_known_sequences_size();
}
inline void ListAllSequencesResponse::clear_known_sequences() {
  _impl_.known_sequences_.Clear();
}
inline std::string* ListAllSequencesResponse::add_known_sequences() {
  std::string* _s = _internal_add_known_sequences();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.spot.ListAllSequencesResponse.known_sequences)
  return _s;
}
inline const std::string& ListAllSequencesResponse::_internal_known_sequences(int index) const {
  return _impl_.known_sequences_.Get(index);
}
inline const std::string& ListAllSequencesResponse::known_sequences(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ListAllSequencesResponse.known_sequences)
  return _internal_known_sequences(index);
}
inline std::string* ListAllSequencesResponse::mutable_known_sequences(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ListAllSequencesResponse.known_sequences)
  return _impl_.known_sequences_.Mutable(index);
}
inline void ListAllSequencesResponse::set_known_sequences(int index, const std::string& value) {
  _impl_.known_sequences_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ListAllSequencesResponse.known_sequences)
}
inline void ListAllSequencesResponse::set_known_sequences(int index, std::string&& value) {
  _impl_.known_sequences_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ListAllSequencesResponse.known_sequences)
}
inline void ListAllSequencesResponse::set_known_sequences(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.known_sequences_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.spot.ListAllSequencesResponse.known_sequences)
}
inline void ListAllSequencesResponse::set_known_sequences(int index, const char* value, size_t size) {
  _impl_.known_sequences_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.spot.ListAllSequencesResponse.known_sequences)
}
inline std::string* ListAllSequencesResponse::_internal_add_known_sequences() {
  return _impl_.known_sequences_.Add();
}
inline void ListAllSequencesResponse::add_known_sequences(const std::string& value) {
  _impl_.known_sequences_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.ListAllSequencesResponse.known_sequences)
}
inline void ListAllSequencesResponse::add_known_sequences(std::string&& value) {
  _impl_.known_sequences_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.ListAllSequencesResponse.known_sequences)
}
inline void ListAllSequencesResponse::add_known_sequences(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.known_sequences_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.spot.ListAllSequencesResponse.known_sequences)
}
inline void ListAllSequencesResponse::add_known_sequences(const char* value, size_t size) {
  _impl_.known_sequences_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.spot.ListAllSequencesResponse.known_sequences)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListAllSequencesResponse::known_sequences() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.ListAllSequencesResponse.known_sequences)
  return _impl_.known_sequences_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListAllSequencesResponse::mutable_known_sequences() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.ListAllSequencesResponse.known_sequences)
  return &_impl_.known_sequences_;
}

// repeated .bosdyn.api.spot.SequenceInfo sequence_info = 3;
inline int ListAllSequencesResponse::_internal_sequence_info_size() const {
  return _impl_.sequence_info_.size();
}
inline int ListAllSequencesResponse::sequence_info_size() const {
  return _internal_sequence_info_size();
}
inline void ListAllSequencesResponse::clear_sequence_info() {
  _impl_.sequence_info_.Clear();
}
inline ::bosdyn::api::spot::SequenceInfo* ListAllSequencesResponse::mutable_sequence_info(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ListAllSequencesResponse.sequence_info)
  return _impl_.sequence_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::SequenceInfo >*
ListAllSequencesResponse::mutable_sequence_info() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.ListAllSequencesResponse.sequence_info)
  return &_impl_.sequence_info_;
}
inline const ::bosdyn::api::spot::SequenceInfo& ListAllSequencesResponse::_internal_sequence_info(int index) const {
  return _impl_.sequence_info_.Get(index);
}
inline const ::bosdyn::api::spot::SequenceInfo& ListAllSequencesResponse::sequence_info(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ListAllSequencesResponse.sequence_info)
  return _internal_sequence_info(index);
}
inline ::bosdyn::api::spot::SequenceInfo* ListAllSequencesResponse::_internal_add_sequence_info() {
  return _impl_.sequence_info_.Add();
}
inline ::bosdyn::api::spot::SequenceInfo* ListAllSequencesResponse::add_sequence_info() {
  ::bosdyn::api::spot::SequenceInfo* _add = _internal_add_sequence_info();
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.ListAllSequencesResponse.sequence_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::SequenceInfo >&
ListAllSequencesResponse::sequence_info() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.ListAllSequencesResponse.sequence_info)
  return _impl_.sequence_info_;
}

// -------------------------------------------------------------------

// SequenceInfo

// string name = 1;
inline void SequenceInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SequenceInfo::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SequenceInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SequenceInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SequenceInfo.name)
}
inline std::string* SequenceInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SequenceInfo.name)
  return _s;
}
inline const std::string& SequenceInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SequenceInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SequenceInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SequenceInfo::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SequenceInfo.name)
  return _impl_.name_.Release();
}
inline void SequenceInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SequenceInfo.name)
}

// repeated string labels = 2;
inline int SequenceInfo::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int SequenceInfo::labels_size() const {
  return _internal_labels_size();
}
inline void SequenceInfo::clear_labels() {
  _impl_.labels_.Clear();
}
inline std::string* SequenceInfo::add_labels() {
  std::string* _s = _internal_add_labels();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.spot.SequenceInfo.labels)
  return _s;
}
inline const std::string& SequenceInfo::_internal_labels(int index) const {
  return _impl_.labels_.Get(index);
}
inline const std::string& SequenceInfo::labels(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SequenceInfo.labels)
  return _internal_labels(index);
}
inline std::string* SequenceInfo::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SequenceInfo.labels)
  return _impl_.labels_.Mutable(index);
}
inline void SequenceInfo::set_labels(int index, const std::string& value) {
  _impl_.labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SequenceInfo.labels)
}
inline void SequenceInfo::set_labels(int index, std::string&& value) {
  _impl_.labels_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SequenceInfo.labels)
}
inline void SequenceInfo::set_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.spot.SequenceInfo.labels)
}
inline void SequenceInfo::set_labels(int index, const char* value, size_t size) {
  _impl_.labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.spot.SequenceInfo.labels)
}
inline std::string* SequenceInfo::_internal_add_labels() {
  return _impl_.labels_.Add();
}
inline void SequenceInfo::add_labels(const std::string& value) {
  _impl_.labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.SequenceInfo.labels)
}
inline void SequenceInfo::add_labels(std::string&& value) {
  _impl_.labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.SequenceInfo.labels)
}
inline void SequenceInfo::add_labels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.spot.SequenceInfo.labels)
}
inline void SequenceInfo::add_labels(const char* value, size_t size) {
  _impl_.labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.spot.SequenceInfo.labels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SequenceInfo::labels() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.SequenceInfo.labels)
  return _impl_.labels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SequenceInfo::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.SequenceInfo.labels)
  return &_impl_.labels_;
}

// .bosdyn.api.spot.SequenceInfo.SavedState saved_state = 3;
inline void SequenceInfo::clear_saved_state() {
  _impl_.saved_state_ = 0;
}
inline ::bosdyn::api::spot::SequenceInfo_SavedState SequenceInfo::_internal_saved_state() const {
  return static_cast< ::bosdyn::api::spot::SequenceInfo_SavedState >(_impl_.saved_state_);
}
inline ::bosdyn::api::spot::SequenceInfo_SavedState SequenceInfo::saved_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SequenceInfo.saved_state)
  return _internal_saved_state();
}
inline void SequenceInfo::_internal_set_saved_state(::bosdyn::api::spot::SequenceInfo_SavedState value) {
  
  _impl_.saved_state_ = value;
}
inline void SequenceInfo::set_saved_state(::bosdyn::api::spot::SequenceInfo_SavedState value) {
  _internal_set_saved_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SequenceInfo.saved_state)
}

// -------------------------------------------------------------------

// DeleteSequenceRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool DeleteSequenceRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DeleteSequenceRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& DeleteSequenceRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& DeleteSequenceRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DeleteSequenceRequest.header)
  return _internal_header();
}
inline void DeleteSequenceRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.DeleteSequenceRequest.header)
}
inline ::bosdyn::api::RequestHeader* DeleteSequenceRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* DeleteSequenceRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.DeleteSequenceRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* DeleteSequenceRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* DeleteSequenceRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.DeleteSequenceRequest.header)
  return _msg;
}
inline void DeleteSequenceRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.DeleteSequenceRequest.header)
}

// string sequence_name = 2;
inline void DeleteSequenceRequest::clear_sequence_name() {
  _impl_.sequence_name_.ClearToEmpty();
}
inline const std::string& DeleteSequenceRequest::sequence_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DeleteSequenceRequest.sequence_name)
  return _internal_sequence_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteSequenceRequest::set_sequence_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequence_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DeleteSequenceRequest.sequence_name)
}
inline std::string* DeleteSequenceRequest::mutable_sequence_name() {
  std::string* _s = _internal_mutable_sequence_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.DeleteSequenceRequest.sequence_name)
  return _s;
}
inline const std::string& DeleteSequenceRequest::_internal_sequence_name() const {
  return _impl_.sequence_name_.Get();
}
inline void DeleteSequenceRequest::_internal_set_sequence_name(const std::string& value) {
  
  _impl_.sequence_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteSequenceRequest::_internal_mutable_sequence_name() {
  
  return _impl_.sequence_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteSequenceRequest::release_sequence_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.DeleteSequenceRequest.sequence_name)
  return _impl_.sequence_name_.Release();
}
inline void DeleteSequenceRequest::set_allocated_sequence_name(std::string* sequence_name) {
  if (sequence_name != nullptr) {
    
  } else {
    
  }
  _impl_.sequence_name_.SetAllocated(sequence_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequence_name_.IsDefault()) {
    _impl_.sequence_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.DeleteSequenceRequest.sequence_name)
}

// -------------------------------------------------------------------

// DeleteSequenceResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool DeleteSequenceResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DeleteSequenceResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& DeleteSequenceResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& DeleteSequenceResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DeleteSequenceResponse.header)
  return _internal_header();
}
inline void DeleteSequenceResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.DeleteSequenceResponse.header)
}
inline ::bosdyn::api::ResponseHeader* DeleteSequenceResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DeleteSequenceResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.DeleteSequenceResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DeleteSequenceResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* DeleteSequenceResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.DeleteSequenceResponse.header)
  return _msg;
}
inline void DeleteSequenceResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.DeleteSequenceResponse.header)
}

// .bosdyn.api.spot.DeleteSequenceResponse.Status status = 2;
inline void DeleteSequenceResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::spot::DeleteSequenceResponse_Status DeleteSequenceResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::DeleteSequenceResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::spot::DeleteSequenceResponse_Status DeleteSequenceResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DeleteSequenceResponse.status)
  return _internal_status();
}
inline void DeleteSequenceResponse::_internal_set_status(::bosdyn::api::spot::DeleteSequenceResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void DeleteSequenceResponse::set_status(::bosdyn::api::spot::DeleteSequenceResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DeleteSequenceResponse.status)
}

// -------------------------------------------------------------------

// SaveSequenceRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool SaveSequenceRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SaveSequenceRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& SaveSequenceRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& SaveSequenceRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SaveSequenceRequest.header)
  return _internal_header();
}
inline void SaveSequenceRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SaveSequenceRequest.header)
}
inline ::bosdyn::api::RequestHeader* SaveSequenceRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* SaveSequenceRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SaveSequenceRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* SaveSequenceRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* SaveSequenceRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SaveSequenceRequest.header)
  return _msg;
}
inline void SaveSequenceRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SaveSequenceRequest.header)
}

// string sequence_name = 2;
inline void SaveSequenceRequest::clear_sequence_name() {
  _impl_.sequence_name_.ClearToEmpty();
}
inline const std::string& SaveSequenceRequest::sequence_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SaveSequenceRequest.sequence_name)
  return _internal_sequence_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveSequenceRequest::set_sequence_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequence_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SaveSequenceRequest.sequence_name)
}
inline std::string* SaveSequenceRequest::mutable_sequence_name() {
  std::string* _s = _internal_mutable_sequence_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SaveSequenceRequest.sequence_name)
  return _s;
}
inline const std::string& SaveSequenceRequest::_internal_sequence_name() const {
  return _impl_.sequence_name_.Get();
}
inline void SaveSequenceRequest::_internal_set_sequence_name(const std::string& value) {
  
  _impl_.sequence_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SaveSequenceRequest::_internal_mutable_sequence_name() {
  
  return _impl_.sequence_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SaveSequenceRequest::release_sequence_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SaveSequenceRequest.sequence_name)
  return _impl_.sequence_name_.Release();
}
inline void SaveSequenceRequest::set_allocated_sequence_name(std::string* sequence_name) {
  if (sequence_name != nullptr) {
    
  } else {
    
  }
  _impl_.sequence_name_.SetAllocated(sequence_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequence_name_.IsDefault()) {
    _impl_.sequence_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SaveSequenceRequest.sequence_name)
}

// repeated string add_labels = 3;
inline int SaveSequenceRequest::_internal_add_labels_size() const {
  return _impl_.add_labels_.size();
}
inline int SaveSequenceRequest::add_labels_size() const {
  return _internal_add_labels_size();
}
inline void SaveSequenceRequest::clear_add_labels() {
  _impl_.add_labels_.Clear();
}
inline std::string* SaveSequenceRequest::add_add_labels() {
  std::string* _s = _internal_add_add_labels();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.spot.SaveSequenceRequest.add_labels)
  return _s;
}
inline const std::string& SaveSequenceRequest::_internal_add_labels(int index) const {
  return _impl_.add_labels_.Get(index);
}
inline const std::string& SaveSequenceRequest::add_labels(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SaveSequenceRequest.add_labels)
  return _internal_add_labels(index);
}
inline std::string* SaveSequenceRequest::mutable_add_labels(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SaveSequenceRequest.add_labels)
  return _impl_.add_labels_.Mutable(index);
}
inline void SaveSequenceRequest::set_add_labels(int index, const std::string& value) {
  _impl_.add_labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SaveSequenceRequest.add_labels)
}
inline void SaveSequenceRequest::set_add_labels(int index, std::string&& value) {
  _impl_.add_labels_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SaveSequenceRequest.add_labels)
}
inline void SaveSequenceRequest::set_add_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.add_labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.spot.SaveSequenceRequest.add_labels)
}
inline void SaveSequenceRequest::set_add_labels(int index, const char* value, size_t size) {
  _impl_.add_labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.spot.SaveSequenceRequest.add_labels)
}
inline std::string* SaveSequenceRequest::_internal_add_add_labels() {
  return _impl_.add_labels_.Add();
}
inline void SaveSequenceRequest::add_add_labels(const std::string& value) {
  _impl_.add_labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.SaveSequenceRequest.add_labels)
}
inline void SaveSequenceRequest::add_add_labels(std::string&& value) {
  _impl_.add_labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.SaveSequenceRequest.add_labels)
}
inline void SaveSequenceRequest::add_add_labels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.add_labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.spot.SaveSequenceRequest.add_labels)
}
inline void SaveSequenceRequest::add_add_labels(const char* value, size_t size) {
  _impl_.add_labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.spot.SaveSequenceRequest.add_labels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SaveSequenceRequest::add_labels() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.SaveSequenceRequest.add_labels)
  return _impl_.add_labels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SaveSequenceRequest::mutable_add_labels() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.SaveSequenceRequest.add_labels)
  return &_impl_.add_labels_;
}

// -------------------------------------------------------------------

// SaveSequenceResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool SaveSequenceResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SaveSequenceResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& SaveSequenceResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& SaveSequenceResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SaveSequenceResponse.header)
  return _internal_header();
}
inline void SaveSequenceResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SaveSequenceResponse.header)
}
inline ::bosdyn::api::ResponseHeader* SaveSequenceResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SaveSequenceResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SaveSequenceResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SaveSequenceResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* SaveSequenceResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SaveSequenceResponse.header)
  return _msg;
}
inline void SaveSequenceResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SaveSequenceResponse.header)
}

// .bosdyn.api.spot.SaveSequenceResponse.Status status = 2;
inline void SaveSequenceResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::spot::SaveSequenceResponse_Status SaveSequenceResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::SaveSequenceResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::spot::SaveSequenceResponse_Status SaveSequenceResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SaveSequenceResponse.status)
  return _internal_status();
}
inline void SaveSequenceResponse::_internal_set_status(::bosdyn::api::spot::SaveSequenceResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void SaveSequenceResponse::set_status(::bosdyn::api::spot::SaveSequenceResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SaveSequenceResponse.status)
}

// -------------------------------------------------------------------

// ModifyChoreographyInfoRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ModifyChoreographyInfoRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ModifyChoreographyInfoRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ModifyChoreographyInfoRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ModifyChoreographyInfoRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ModifyChoreographyInfoRequest.header)
  return _internal_header();
}
inline void ModifyChoreographyInfoRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ModifyChoreographyInfoRequest.header)
}
inline ::bosdyn::api::RequestHeader* ModifyChoreographyInfoRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ModifyChoreographyInfoRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ModifyChoreographyInfoRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ModifyChoreographyInfoRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ModifyChoreographyInfoRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ModifyChoreographyInfoRequest.header)
  return _msg;
}
inline void ModifyChoreographyInfoRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ModifyChoreographyInfoRequest.header)
}

// string sequence_name = 2;
inline void ModifyChoreographyInfoRequest::clear_sequence_name() {
  _impl_.sequence_name_.ClearToEmpty();
}
inline const std::string& ModifyChoreographyInfoRequest::sequence_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ModifyChoreographyInfoRequest.sequence_name)
  return _internal_sequence_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModifyChoreographyInfoRequest::set_sequence_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequence_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ModifyChoreographyInfoRequest.sequence_name)
}
inline std::string* ModifyChoreographyInfoRequest::mutable_sequence_name() {
  std::string* _s = _internal_mutable_sequence_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ModifyChoreographyInfoRequest.sequence_name)
  return _s;
}
inline const std::string& ModifyChoreographyInfoRequest::_internal_sequence_name() const {
  return _impl_.sequence_name_.Get();
}
inline void ModifyChoreographyInfoRequest::_internal_set_sequence_name(const std::string& value) {
  
  _impl_.sequence_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModifyChoreographyInfoRequest::_internal_mutable_sequence_name() {
  
  return _impl_.sequence_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModifyChoreographyInfoRequest::release_sequence_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ModifyChoreographyInfoRequest.sequence_name)
  return _impl_.sequence_name_.Release();
}
inline void ModifyChoreographyInfoRequest::set_allocated_sequence_name(std::string* sequence_name) {
  if (sequence_name != nullptr) {
    
  } else {
    
  }
  _impl_.sequence_name_.SetAllocated(sequence_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequence_name_.IsDefault()) {
    _impl_.sequence_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ModifyChoreographyInfoRequest.sequence_name)
}

// repeated string add_labels = 3;
inline int ModifyChoreographyInfoRequest::_internal_add_labels_size() const {
  return _impl_.add_labels_.size();
}
inline int ModifyChoreographyInfoRequest::add_labels_size() const {
  return _internal_add_labels_size();
}
inline void ModifyChoreographyInfoRequest::clear_add_labels() {
  _impl_.add_labels_.Clear();
}
inline std::string* ModifyChoreographyInfoRequest::add_add_labels() {
  std::string* _s = _internal_add_add_labels();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.spot.ModifyChoreographyInfoRequest.add_labels)
  return _s;
}
inline const std::string& ModifyChoreographyInfoRequest::_internal_add_labels(int index) const {
  return _impl_.add_labels_.Get(index);
}
inline const std::string& ModifyChoreographyInfoRequest::add_labels(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ModifyChoreographyInfoRequest.add_labels)
  return _internal_add_labels(index);
}
inline std::string* ModifyChoreographyInfoRequest::mutable_add_labels(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ModifyChoreographyInfoRequest.add_labels)
  return _impl_.add_labels_.Mutable(index);
}
inline void ModifyChoreographyInfoRequest::set_add_labels(int index, const std::string& value) {
  _impl_.add_labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ModifyChoreographyInfoRequest.add_labels)
}
inline void ModifyChoreographyInfoRequest::set_add_labels(int index, std::string&& value) {
  _impl_.add_labels_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ModifyChoreographyInfoRequest.add_labels)
}
inline void ModifyChoreographyInfoRequest::set_add_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.add_labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.spot.ModifyChoreographyInfoRequest.add_labels)
}
inline void ModifyChoreographyInfoRequest::set_add_labels(int index, const char* value, size_t size) {
  _impl_.add_labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.spot.ModifyChoreographyInfoRequest.add_labels)
}
inline std::string* ModifyChoreographyInfoRequest::_internal_add_add_labels() {
  return _impl_.add_labels_.Add();
}
inline void ModifyChoreographyInfoRequest::add_add_labels(const std::string& value) {
  _impl_.add_labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.ModifyChoreographyInfoRequest.add_labels)
}
inline void ModifyChoreographyInfoRequest::add_add_labels(std::string&& value) {
  _impl_.add_labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.ModifyChoreographyInfoRequest.add_labels)
}
inline void ModifyChoreographyInfoRequest::add_add_labels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.add_labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.spot.ModifyChoreographyInfoRequest.add_labels)
}
inline void ModifyChoreographyInfoRequest::add_add_labels(const char* value, size_t size) {
  _impl_.add_labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.spot.ModifyChoreographyInfoRequest.add_labels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModifyChoreographyInfoRequest::add_labels() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.ModifyChoreographyInfoRequest.add_labels)
  return _impl_.add_labels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModifyChoreographyInfoRequest::mutable_add_labels() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.ModifyChoreographyInfoRequest.add_labels)
  return &_impl_.add_labels_;
}

// repeated string remove_labels = 4;
inline int ModifyChoreographyInfoRequest::_internal_remove_labels_size() const {
  return _impl_.remove_labels_.size();
}
inline int ModifyChoreographyInfoRequest::remove_labels_size() const {
  return _internal_remove_labels_size();
}
inline void ModifyChoreographyInfoRequest::clear_remove_labels() {
  _impl_.remove_labels_.Clear();
}
inline std::string* ModifyChoreographyInfoRequest::add_remove_labels() {
  std::string* _s = _internal_add_remove_labels();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.spot.ModifyChoreographyInfoRequest.remove_labels)
  return _s;
}
inline const std::string& ModifyChoreographyInfoRequest::_internal_remove_labels(int index) const {
  return _impl_.remove_labels_.Get(index);
}
inline const std::string& ModifyChoreographyInfoRequest::remove_labels(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ModifyChoreographyInfoRequest.remove_labels)
  return _internal_remove_labels(index);
}
inline std::string* ModifyChoreographyInfoRequest::mutable_remove_labels(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ModifyChoreographyInfoRequest.remove_labels)
  return _impl_.remove_labels_.Mutable(index);
}
inline void ModifyChoreographyInfoRequest::set_remove_labels(int index, const std::string& value) {
  _impl_.remove_labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ModifyChoreographyInfoRequest.remove_labels)
}
inline void ModifyChoreographyInfoRequest::set_remove_labels(int index, std::string&& value) {
  _impl_.remove_labels_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ModifyChoreographyInfoRequest.remove_labels)
}
inline void ModifyChoreographyInfoRequest::set_remove_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.remove_labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.spot.ModifyChoreographyInfoRequest.remove_labels)
}
inline void ModifyChoreographyInfoRequest::set_remove_labels(int index, const char* value, size_t size) {
  _impl_.remove_labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.spot.ModifyChoreographyInfoRequest.remove_labels)
}
inline std::string* ModifyChoreographyInfoRequest::_internal_add_remove_labels() {
  return _impl_.remove_labels_.Add();
}
inline void ModifyChoreographyInfoRequest::add_remove_labels(const std::string& value) {
  _impl_.remove_labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.ModifyChoreographyInfoRequest.remove_labels)
}
inline void ModifyChoreographyInfoRequest::add_remove_labels(std::string&& value) {
  _impl_.remove_labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.ModifyChoreographyInfoRequest.remove_labels)
}
inline void ModifyChoreographyInfoRequest::add_remove_labels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.remove_labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.spot.ModifyChoreographyInfoRequest.remove_labels)
}
inline void ModifyChoreographyInfoRequest::add_remove_labels(const char* value, size_t size) {
  _impl_.remove_labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.spot.ModifyChoreographyInfoRequest.remove_labels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModifyChoreographyInfoRequest::remove_labels() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.ModifyChoreographyInfoRequest.remove_labels)
  return _impl_.remove_labels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModifyChoreographyInfoRequest::mutable_remove_labels() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.ModifyChoreographyInfoRequest.remove_labels)
  return &_impl_.remove_labels_;
}

// -------------------------------------------------------------------

// ModifyChoreographyInfoResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ModifyChoreographyInfoResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ModifyChoreographyInfoResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ModifyChoreographyInfoResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ModifyChoreographyInfoResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ModifyChoreographyInfoResponse.header)
  return _internal_header();
}
inline void ModifyChoreographyInfoResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ModifyChoreographyInfoResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ModifyChoreographyInfoResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ModifyChoreographyInfoResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ModifyChoreographyInfoResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ModifyChoreographyInfoResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ModifyChoreographyInfoResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ModifyChoreographyInfoResponse.header)
  return _msg;
}
inline void ModifyChoreographyInfoResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ModifyChoreographyInfoResponse.header)
}

// .bosdyn.api.spot.ModifyChoreographyInfoResponse.Status status = 2;
inline void ModifyChoreographyInfoResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::spot::ModifyChoreographyInfoResponse_Status ModifyChoreographyInfoResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::ModifyChoreographyInfoResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::spot::ModifyChoreographyInfoResponse_Status ModifyChoreographyInfoResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ModifyChoreographyInfoResponse.status)
  return _internal_status();
}
inline void ModifyChoreographyInfoResponse::_internal_set_status(::bosdyn::api::spot::ModifyChoreographyInfoResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void ModifyChoreographyInfoResponse::set_status(::bosdyn::api::spot::ModifyChoreographyInfoResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ModifyChoreographyInfoResponse.status)
}

// -------------------------------------------------------------------

// ClearAllSequenceFilesRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ClearAllSequenceFilesRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ClearAllSequenceFilesRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ClearAllSequenceFilesRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ClearAllSequenceFilesRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ClearAllSequenceFilesRequest.header)
  return _internal_header();
}
inline void ClearAllSequenceFilesRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ClearAllSequenceFilesRequest.header)
}
inline ::bosdyn::api::RequestHeader* ClearAllSequenceFilesRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ClearAllSequenceFilesRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ClearAllSequenceFilesRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ClearAllSequenceFilesRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ClearAllSequenceFilesRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ClearAllSequenceFilesRequest.header)
  return _msg;
}
inline void ClearAllSequenceFilesRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ClearAllSequenceFilesRequest.header)
}

// -------------------------------------------------------------------

// ClearAllSequenceFilesResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ClearAllSequenceFilesResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ClearAllSequenceFilesResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ClearAllSequenceFilesResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ClearAllSequenceFilesResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ClearAllSequenceFilesResponse.header)
  return _internal_header();
}
inline void ClearAllSequenceFilesResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ClearAllSequenceFilesResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ClearAllSequenceFilesResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ClearAllSequenceFilesResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ClearAllSequenceFilesResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ClearAllSequenceFilesResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ClearAllSequenceFilesResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ClearAllSequenceFilesResponse.header)
  return _msg;
}
inline void ClearAllSequenceFilesResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ClearAllSequenceFilesResponse.header)
}

// .bosdyn.api.spot.ClearAllSequenceFilesResponse.Status status = 2;
inline void ClearAllSequenceFilesResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::spot::ClearAllSequenceFilesResponse_Status ClearAllSequenceFilesResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::ClearAllSequenceFilesResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::spot::ClearAllSequenceFilesResponse_Status ClearAllSequenceFilesResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ClearAllSequenceFilesResponse.status)
  return _internal_status();
}
inline void ClearAllSequenceFilesResponse::_internal_set_status(::bosdyn::api::spot::ClearAllSequenceFilesResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void ClearAllSequenceFilesResponse::set_status(::bosdyn::api::spot::ClearAllSequenceFilesResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ClearAllSequenceFilesResponse.status)
}

// -------------------------------------------------------------------

// UploadChoreographyRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool UploadChoreographyRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool UploadChoreographyRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& UploadChoreographyRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& UploadChoreographyRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.UploadChoreographyRequest.header)
  return _internal_header();
}
inline void UploadChoreographyRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.UploadChoreographyRequest.header)
}
inline ::bosdyn::api::RequestHeader* UploadChoreographyRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* UploadChoreographyRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.UploadChoreographyRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* UploadChoreographyRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* UploadChoreographyRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.UploadChoreographyRequest.header)
  return _msg;
}
inline void UploadChoreographyRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.UploadChoreographyRequest.header)
}

// .bosdyn.api.spot.ChoreographySequence choreography_sequence = 2;
inline bool UploadChoreographyRequest::_internal_has_choreography_sequence() const {
  return this != internal_default_instance() && _impl_.choreography_sequence_ != nullptr;
}
inline bool UploadChoreographyRequest::has_choreography_sequence() const {
  return _internal_has_choreography_sequence();
}
inline void UploadChoreographyRequest::clear_choreography_sequence() {
  if (GetArenaForAllocation() == nullptr && _impl_.choreography_sequence_ != nullptr) {
    delete _impl_.choreography_sequence_;
  }
  _impl_.choreography_sequence_ = nullptr;
}
inline const ::bosdyn::api::spot::ChoreographySequence& UploadChoreographyRequest::_internal_choreography_sequence() const {
  const ::bosdyn::api::spot::ChoreographySequence* p = _impl_.choreography_sequence_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::ChoreographySequence&>(
      ::bosdyn::api::spot::_ChoreographySequence_default_instance_);
}
inline const ::bosdyn::api::spot::ChoreographySequence& UploadChoreographyRequest::choreography_sequence() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.UploadChoreographyRequest.choreography_sequence)
  return _internal_choreography_sequence();
}
inline void UploadChoreographyRequest::unsafe_arena_set_allocated_choreography_sequence(
    ::bosdyn::api::spot::ChoreographySequence* choreography_sequence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.choreography_sequence_);
  }
  _impl_.choreography_sequence_ = choreography_sequence;
  if (choreography_sequence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.UploadChoreographyRequest.choreography_sequence)
}
inline ::bosdyn::api::spot::ChoreographySequence* UploadChoreographyRequest::release_choreography_sequence() {
  
  ::bosdyn::api::spot::ChoreographySequence* temp = _impl_.choreography_sequence_;
  _impl_.choreography_sequence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::ChoreographySequence* UploadChoreographyRequest::unsafe_arena_release_choreography_sequence() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.UploadChoreographyRequest.choreography_sequence)
  
  ::bosdyn::api::spot::ChoreographySequence* temp = _impl_.choreography_sequence_;
  _impl_.choreography_sequence_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::ChoreographySequence* UploadChoreographyRequest::_internal_mutable_choreography_sequence() {
  
  if (_impl_.choreography_sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::ChoreographySequence>(GetArenaForAllocation());
    _impl_.choreography_sequence_ = p;
  }
  return _impl_.choreography_sequence_;
}
inline ::bosdyn::api::spot::ChoreographySequence* UploadChoreographyRequest::mutable_choreography_sequence() {
  ::bosdyn::api::spot::ChoreographySequence* _msg = _internal_mutable_choreography_sequence();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.UploadChoreographyRequest.choreography_sequence)
  return _msg;
}
inline void UploadChoreographyRequest::set_allocated_choreography_sequence(::bosdyn::api::spot::ChoreographySequence* choreography_sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.choreography_sequence_;
  }
  if (choreography_sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(choreography_sequence);
    if (message_arena != submessage_arena) {
      choreography_sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, choreography_sequence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.choreography_sequence_ = choreography_sequence;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.UploadChoreographyRequest.choreography_sequence)
}

// bool non_strict_parsing = 3;
inline void UploadChoreographyRequest::clear_non_strict_parsing() {
  _impl_.non_strict_parsing_ = false;
}
inline bool UploadChoreographyRequest::_internal_non_strict_parsing() const {
  return _impl_.non_strict_parsing_;
}
inline bool UploadChoreographyRequest::non_strict_parsing() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.UploadChoreographyRequest.non_strict_parsing)
  return _internal_non_strict_parsing();
}
inline void UploadChoreographyRequest::_internal_set_non_strict_parsing(bool value) {
  
  _impl_.non_strict_parsing_ = value;
}
inline void UploadChoreographyRequest::set_non_strict_parsing(bool value) {
  _internal_set_non_strict_parsing(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.UploadChoreographyRequest.non_strict_parsing)
}

// -------------------------------------------------------------------

// UploadChoreographyResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool UploadChoreographyResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool UploadChoreographyResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& UploadChoreographyResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& UploadChoreographyResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.UploadChoreographyResponse.header)
  return _internal_header();
}
inline void UploadChoreographyResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.UploadChoreographyResponse.header)
}
inline ::bosdyn::api::ResponseHeader* UploadChoreographyResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* UploadChoreographyResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.UploadChoreographyResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* UploadChoreographyResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* UploadChoreographyResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.UploadChoreographyResponse.header)
  return _msg;
}
inline void UploadChoreographyResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.UploadChoreographyResponse.header)
}

// repeated string warnings = 3;
inline int UploadChoreographyResponse::_internal_warnings_size() const {
  return _impl_.warnings_.size();
}
inline int UploadChoreographyResponse::warnings_size() const {
  return _internal_warnings_size();
}
inline void UploadChoreographyResponse::clear_warnings() {
  _impl_.warnings_.Clear();
}
inline std::string* UploadChoreographyResponse::add_warnings() {
  std::string* _s = _internal_add_warnings();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.spot.UploadChoreographyResponse.warnings)
  return _s;
}
inline const std::string& UploadChoreographyResponse::_internal_warnings(int index) const {
  return _impl_.warnings_.Get(index);
}
inline const std::string& UploadChoreographyResponse::warnings(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.UploadChoreographyResponse.warnings)
  return _internal_warnings(index);
}
inline std::string* UploadChoreographyResponse::mutable_warnings(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.UploadChoreographyResponse.warnings)
  return _impl_.warnings_.Mutable(index);
}
inline void UploadChoreographyResponse::set_warnings(int index, const std::string& value) {
  _impl_.warnings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.UploadChoreographyResponse.warnings)
}
inline void UploadChoreographyResponse::set_warnings(int index, std::string&& value) {
  _impl_.warnings_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.UploadChoreographyResponse.warnings)
}
inline void UploadChoreographyResponse::set_warnings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.warnings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.spot.UploadChoreographyResponse.warnings)
}
inline void UploadChoreographyResponse::set_warnings(int index, const char* value, size_t size) {
  _impl_.warnings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.spot.UploadChoreographyResponse.warnings)
}
inline std::string* UploadChoreographyResponse::_internal_add_warnings() {
  return _impl_.warnings_.Add();
}
inline void UploadChoreographyResponse::add_warnings(const std::string& value) {
  _impl_.warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.UploadChoreographyResponse.warnings)
}
inline void UploadChoreographyResponse::add_warnings(std::string&& value) {
  _impl_.warnings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.UploadChoreographyResponse.warnings)
}
inline void UploadChoreographyResponse::add_warnings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.spot.UploadChoreographyResponse.warnings)
}
inline void UploadChoreographyResponse::add_warnings(const char* value, size_t size) {
  _impl_.warnings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.spot.UploadChoreographyResponse.warnings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UploadChoreographyResponse::warnings() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.UploadChoreographyResponse.warnings)
  return _impl_.warnings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UploadChoreographyResponse::mutable_warnings() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.UploadChoreographyResponse.warnings)
  return &_impl_.warnings_;
}

// -------------------------------------------------------------------

// UploadAnimatedMoveRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool UploadAnimatedMoveRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool UploadAnimatedMoveRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& UploadAnimatedMoveRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& UploadAnimatedMoveRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.UploadAnimatedMoveRequest.header)
  return _internal_header();
}
inline void UploadAnimatedMoveRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.UploadAnimatedMoveRequest.header)
}
inline ::bosdyn::api::RequestHeader* UploadAnimatedMoveRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* UploadAnimatedMoveRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.UploadAnimatedMoveRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* UploadAnimatedMoveRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* UploadAnimatedMoveRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.UploadAnimatedMoveRequest.header)
  return _msg;
}
inline void UploadAnimatedMoveRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.UploadAnimatedMoveRequest.header)
}

// .google.protobuf.StringValue animated_move_generated_id = 3;
inline bool UploadAnimatedMoveRequest::_internal_has_animated_move_generated_id() const {
  return this != internal_default_instance() && _impl_.animated_move_generated_id_ != nullptr;
}
inline bool UploadAnimatedMoveRequest::has_animated_move_generated_id() const {
  return _internal_has_animated_move_generated_id();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& UploadAnimatedMoveRequest::_internal_animated_move_generated_id() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.animated_move_generated_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& UploadAnimatedMoveRequest::animated_move_generated_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.UploadAnimatedMoveRequest.animated_move_generated_id)
  return _internal_animated_move_generated_id();
}
inline void UploadAnimatedMoveRequest::unsafe_arena_set_allocated_animated_move_generated_id(
    ::PROTOBUF_NAMESPACE_ID::StringValue* animated_move_generated_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.animated_move_generated_id_);
  }
  _impl_.animated_move_generated_id_ = animated_move_generated_id;
  if (animated_move_generated_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.UploadAnimatedMoveRequest.animated_move_generated_id)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* UploadAnimatedMoveRequest::release_animated_move_generated_id() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.animated_move_generated_id_;
  _impl_.animated_move_generated_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* UploadAnimatedMoveRequest::unsafe_arena_release_animated_move_generated_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.UploadAnimatedMoveRequest.animated_move_generated_id)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.animated_move_generated_id_;
  _impl_.animated_move_generated_id_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* UploadAnimatedMoveRequest::_internal_mutable_animated_move_generated_id() {
  
  if (_impl_.animated_move_generated_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.animated_move_generated_id_ = p;
  }
  return _impl_.animated_move_generated_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* UploadAnimatedMoveRequest::mutable_animated_move_generated_id() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_animated_move_generated_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.UploadAnimatedMoveRequest.animated_move_generated_id)
  return _msg;
}
inline void UploadAnimatedMoveRequest::set_allocated_animated_move_generated_id(::PROTOBUF_NAMESPACE_ID::StringValue* animated_move_generated_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.animated_move_generated_id_);
  }
  if (animated_move_generated_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(animated_move_generated_id));
    if (message_arena != submessage_arena) {
      animated_move_generated_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, animated_move_generated_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.animated_move_generated_id_ = animated_move_generated_id;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.UploadAnimatedMoveRequest.animated_move_generated_id)
}

// .bosdyn.api.spot.Animation animated_move = 2;
inline bool UploadAnimatedMoveRequest::_internal_has_animated_move() const {
  return this != internal_default_instance() && _impl_.animated_move_ != nullptr;
}
inline bool UploadAnimatedMoveRequest::has_animated_move() const {
  return _internal_has_animated_move();
}
inline void UploadAnimatedMoveRequest::clear_animated_move() {
  if (GetArenaForAllocation() == nullptr && _impl_.animated_move_ != nullptr) {
    delete _impl_.animated_move_;
  }
  _impl_.animated_move_ = nullptr;
}
inline const ::bosdyn::api::spot::Animation& UploadAnimatedMoveRequest::_internal_animated_move() const {
  const ::bosdyn::api::spot::Animation* p = _impl_.animated_move_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::Animation&>(
      ::bosdyn::api::spot::_Animation_default_instance_);
}
inline const ::bosdyn::api::spot::Animation& UploadAnimatedMoveRequest::animated_move() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.UploadAnimatedMoveRequest.animated_move)
  return _internal_animated_move();
}
inline void UploadAnimatedMoveRequest::unsafe_arena_set_allocated_animated_move(
    ::bosdyn::api::spot::Animation* animated_move) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.animated_move_);
  }
  _impl_.animated_move_ = animated_move;
  if (animated_move) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.UploadAnimatedMoveRequest.animated_move)
}
inline ::bosdyn::api::spot::Animation* UploadAnimatedMoveRequest::release_animated_move() {
  
  ::bosdyn::api::spot::Animation* temp = _impl_.animated_move_;
  _impl_.animated_move_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::Animation* UploadAnimatedMoveRequest::unsafe_arena_release_animated_move() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.UploadAnimatedMoveRequest.animated_move)
  
  ::bosdyn::api::spot::Animation* temp = _impl_.animated_move_;
  _impl_.animated_move_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::Animation* UploadAnimatedMoveRequest::_internal_mutable_animated_move() {
  
  if (_impl_.animated_move_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::Animation>(GetArenaForAllocation());
    _impl_.animated_move_ = p;
  }
  return _impl_.animated_move_;
}
inline ::bosdyn::api::spot::Animation* UploadAnimatedMoveRequest::mutable_animated_move() {
  ::bosdyn::api::spot::Animation* _msg = _internal_mutable_animated_move();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.UploadAnimatedMoveRequest.animated_move)
  return _msg;
}
inline void UploadAnimatedMoveRequest::set_allocated_animated_move(::bosdyn::api::spot::Animation* animated_move) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.animated_move_;
  }
  if (animated_move) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(animated_move);
    if (message_arena != submessage_arena) {
      animated_move = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, animated_move, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.animated_move_ = animated_move;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.UploadAnimatedMoveRequest.animated_move)
}

// -------------------------------------------------------------------

// UploadAnimatedMoveResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool UploadAnimatedMoveResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool UploadAnimatedMoveResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& UploadAnimatedMoveResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& UploadAnimatedMoveResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.UploadAnimatedMoveResponse.header)
  return _internal_header();
}
inline void UploadAnimatedMoveResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.UploadAnimatedMoveResponse.header)
}
inline ::bosdyn::api::ResponseHeader* UploadAnimatedMoveResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* UploadAnimatedMoveResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.UploadAnimatedMoveResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* UploadAnimatedMoveResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* UploadAnimatedMoveResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.UploadAnimatedMoveResponse.header)
  return _msg;
}
inline void UploadAnimatedMoveResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.UploadAnimatedMoveResponse.header)
}

// .bosdyn.api.spot.UploadAnimatedMoveResponse.Status status = 2;
inline void UploadAnimatedMoveResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::spot::UploadAnimatedMoveResponse_Status UploadAnimatedMoveResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::UploadAnimatedMoveResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::spot::UploadAnimatedMoveResponse_Status UploadAnimatedMoveResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.UploadAnimatedMoveResponse.status)
  return _internal_status();
}
inline void UploadAnimatedMoveResponse::_internal_set_status(::bosdyn::api::spot::UploadAnimatedMoveResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void UploadAnimatedMoveResponse::set_status(::bosdyn::api::spot::UploadAnimatedMoveResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.UploadAnimatedMoveResponse.status)
}

// repeated string warnings = 3;
inline int UploadAnimatedMoveResponse::_internal_warnings_size() const {
  return _impl_.warnings_.size();
}
inline int UploadAnimatedMoveResponse::warnings_size() const {
  return _internal_warnings_size();
}
inline void UploadAnimatedMoveResponse::clear_warnings() {
  _impl_.warnings_.Clear();
}
inline std::string* UploadAnimatedMoveResponse::add_warnings() {
  std::string* _s = _internal_add_warnings();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.spot.UploadAnimatedMoveResponse.warnings)
  return _s;
}
inline const std::string& UploadAnimatedMoveResponse::_internal_warnings(int index) const {
  return _impl_.warnings_.Get(index);
}
inline const std::string& UploadAnimatedMoveResponse::warnings(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.UploadAnimatedMoveResponse.warnings)
  return _internal_warnings(index);
}
inline std::string* UploadAnimatedMoveResponse::mutable_warnings(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.UploadAnimatedMoveResponse.warnings)
  return _impl_.warnings_.Mutable(index);
}
inline void UploadAnimatedMoveResponse::set_warnings(int index, const std::string& value) {
  _impl_.warnings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.UploadAnimatedMoveResponse.warnings)
}
inline void UploadAnimatedMoveResponse::set_warnings(int index, std::string&& value) {
  _impl_.warnings_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.UploadAnimatedMoveResponse.warnings)
}
inline void UploadAnimatedMoveResponse::set_warnings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.warnings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.spot.UploadAnimatedMoveResponse.warnings)
}
inline void UploadAnimatedMoveResponse::set_warnings(int index, const char* value, size_t size) {
  _impl_.warnings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.spot.UploadAnimatedMoveResponse.warnings)
}
inline std::string* UploadAnimatedMoveResponse::_internal_add_warnings() {
  return _impl_.warnings_.Add();
}
inline void UploadAnimatedMoveResponse::add_warnings(const std::string& value) {
  _impl_.warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.UploadAnimatedMoveResponse.warnings)
}
inline void UploadAnimatedMoveResponse::add_warnings(std::string&& value) {
  _impl_.warnings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.UploadAnimatedMoveResponse.warnings)
}
inline void UploadAnimatedMoveResponse::add_warnings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.spot.UploadAnimatedMoveResponse.warnings)
}
inline void UploadAnimatedMoveResponse::add_warnings(const char* value, size_t size) {
  _impl_.warnings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.spot.UploadAnimatedMoveResponse.warnings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UploadAnimatedMoveResponse::warnings() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.UploadAnimatedMoveResponse.warnings)
  return _impl_.warnings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UploadAnimatedMoveResponse::mutable_warnings() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.UploadAnimatedMoveResponse.warnings)
  return &_impl_.warnings_;
}

// -------------------------------------------------------------------

// ExecuteChoreographyRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ExecuteChoreographyRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ExecuteChoreographyRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ExecuteChoreographyRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ExecuteChoreographyRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ExecuteChoreographyRequest.header)
  return _internal_header();
}
inline void ExecuteChoreographyRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ExecuteChoreographyRequest.header)
}
inline ::bosdyn::api::RequestHeader* ExecuteChoreographyRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* ExecuteChoreographyRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ExecuteChoreographyRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ExecuteChoreographyRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* ExecuteChoreographyRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ExecuteChoreographyRequest.header)
  return _msg;
}
inline void ExecuteChoreographyRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ExecuteChoreographyRequest.header)
}

// string choreography_sequence_name = 2;
inline void ExecuteChoreographyRequest::clear_choreography_sequence_name() {
  _impl_.choreography_sequence_name_.ClearToEmpty();
}
inline const std::string& ExecuteChoreographyRequest::choreography_sequence_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ExecuteChoreographyRequest.choreography_sequence_name)
  return _internal_choreography_sequence_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteChoreographyRequest::set_choreography_sequence_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.choreography_sequence_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ExecuteChoreographyRequest.choreography_sequence_name)
}
inline std::string* ExecuteChoreographyRequest::mutable_choreography_sequence_name() {
  std::string* _s = _internal_mutable_choreography_sequence_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ExecuteChoreographyRequest.choreography_sequence_name)
  return _s;
}
inline const std::string& ExecuteChoreographyRequest::_internal_choreography_sequence_name() const {
  return _impl_.choreography_sequence_name_.Get();
}
inline void ExecuteChoreographyRequest::_internal_set_choreography_sequence_name(const std::string& value) {
  
  _impl_.choreography_sequence_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteChoreographyRequest::_internal_mutable_choreography_sequence_name() {
  
  return _impl_.choreography_sequence_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteChoreographyRequest::release_choreography_sequence_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ExecuteChoreographyRequest.choreography_sequence_name)
  return _impl_.choreography_sequence_name_.Release();
}
inline void ExecuteChoreographyRequest::set_allocated_choreography_sequence_name(std::string* choreography_sequence_name) {
  if (choreography_sequence_name != nullptr) {
    
  } else {
    
  }
  _impl_.choreography_sequence_name_.SetAllocated(choreography_sequence_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.choreography_sequence_name_.IsDefault()) {
    _impl_.choreography_sequence_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ExecuteChoreographyRequest.choreography_sequence_name)
}

// .google.protobuf.Timestamp start_time = 3;
inline bool ExecuteChoreographyRequest::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool ExecuteChoreographyRequest::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ExecuteChoreographyRequest::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ExecuteChoreographyRequest::start_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ExecuteChoreographyRequest.start_time)
  return _internal_start_time();
}
inline void ExecuteChoreographyRequest::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ExecuteChoreographyRequest.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecuteChoreographyRequest::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecuteChoreographyRequest::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ExecuteChoreographyRequest.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecuteChoreographyRequest::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecuteChoreographyRequest::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ExecuteChoreographyRequest.start_time)
  return _msg;
}
inline void ExecuteChoreographyRequest::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ExecuteChoreographyRequest.start_time)
}

// double choreography_starting_slice = 4;
inline void ExecuteChoreographyRequest::clear_choreography_starting_slice() {
  _impl_.choreography_starting_slice_ = 0;
}
inline double ExecuteChoreographyRequest::_internal_choreography_starting_slice() const {
  return _impl_.choreography_starting_slice_;
}
inline double ExecuteChoreographyRequest::choreography_starting_slice() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ExecuteChoreographyRequest.choreography_starting_slice)
  return _internal_choreography_starting_slice();
}
inline void ExecuteChoreographyRequest::_internal_set_choreography_starting_slice(double value) {
  
  _impl_.choreography_starting_slice_ = value;
}
inline void ExecuteChoreographyRequest::set_choreography_starting_slice(double value) {
  _internal_set_choreography_starting_slice(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ExecuteChoreographyRequest.choreography_starting_slice)
}

// .bosdyn.api.Lease lease = 6;
inline bool ExecuteChoreographyRequest::_internal_has_lease() const {
  return this != internal_default_instance() && _impl_.lease_ != nullptr;
}
inline bool ExecuteChoreographyRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& ExecuteChoreographyRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = _impl_.lease_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Lease&>(
      ::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& ExecuteChoreographyRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ExecuteChoreographyRequest.lease)
  return _internal_lease();
}
inline void ExecuteChoreographyRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  _impl_.lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ExecuteChoreographyRequest.lease)
}
inline ::bosdyn::api::Lease* ExecuteChoreographyRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Lease* ExecuteChoreographyRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ExecuteChoreographyRequest.lease)
  
  ::bosdyn::api::Lease* temp = _impl_.lease_;
  _impl_.lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* ExecuteChoreographyRequest::_internal_mutable_lease() {
  
  if (_impl_.lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArenaForAllocation());
    _impl_.lease_ = p;
  }
  return _impl_.lease_;
}
inline ::bosdyn::api::Lease* ExecuteChoreographyRequest::mutable_lease() {
  ::bosdyn::api::Lease* _msg = _internal_mutable_lease();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ExecuteChoreographyRequest.lease)
  return _msg;
}
inline void ExecuteChoreographyRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease));
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ExecuteChoreographyRequest.lease)
}

// -------------------------------------------------------------------

// ExecuteChoreographyResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ExecuteChoreographyResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ExecuteChoreographyResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ExecuteChoreographyResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ExecuteChoreographyResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ExecuteChoreographyResponse.header)
  return _internal_header();
}
inline void ExecuteChoreographyResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ExecuteChoreographyResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ExecuteChoreographyResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ExecuteChoreographyResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ExecuteChoreographyResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ExecuteChoreographyResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* ExecuteChoreographyResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ExecuteChoreographyResponse.header)
  return _msg;
}
inline void ExecuteChoreographyResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ExecuteChoreographyResponse.header)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool ExecuteChoreographyResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && _impl_.lease_use_result_ != nullptr;
}
inline bool ExecuteChoreographyResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& ExecuteChoreographyResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = _impl_.lease_use_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::LeaseUseResult&>(
      ::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& ExecuteChoreographyResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ExecuteChoreographyResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void ExecuteChoreographyResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  _impl_.lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ExecuteChoreographyResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* ExecuteChoreographyResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* ExecuteChoreographyResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ExecuteChoreographyResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = _impl_.lease_use_result_;
  _impl_.lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* ExecuteChoreographyResponse::_internal_mutable_lease_use_result() {
  
  if (_impl_.lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArenaForAllocation());
    _impl_.lease_use_result_ = p;
  }
  return _impl_.lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* ExecuteChoreographyResponse::mutable_lease_use_result() {
  ::bosdyn::api::LeaseUseResult* _msg = _internal_mutable_lease_use_result();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ExecuteChoreographyResponse.lease_use_result)
  return _msg;
}
inline void ExecuteChoreographyResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result));
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ExecuteChoreographyResponse.lease_use_result)
}

// .bosdyn.api.spot.ExecuteChoreographyResponse.Status status = 3;
inline void ExecuteChoreographyResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::spot::ExecuteChoreographyResponse_Status ExecuteChoreographyResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::ExecuteChoreographyResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::spot::ExecuteChoreographyResponse_Status ExecuteChoreographyResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ExecuteChoreographyResponse.status)
  return _internal_status();
}
inline void ExecuteChoreographyResponse::_internal_set_status(::bosdyn::api::spot::ExecuteChoreographyResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void ExecuteChoreographyResponse::set_status(::bosdyn::api::spot::ExecuteChoreographyResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ExecuteChoreographyResponse.status)
}

// -------------------------------------------------------------------

// StartRecordingStateRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool StartRecordingStateRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool StartRecordingStateRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& StartRecordingStateRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& StartRecordingStateRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.StartRecordingStateRequest.header)
  return _internal_header();
}
inline void StartRecordingStateRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.StartRecordingStateRequest.header)
}
inline ::bosdyn::api::RequestHeader* StartRecordingStateRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* StartRecordingStateRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.StartRecordingStateRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* StartRecordingStateRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* StartRecordingStateRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.StartRecordingStateRequest.header)
  return _msg;
}
inline void StartRecordingStateRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.StartRecordingStateRequest.header)
}

// .google.protobuf.Duration continue_recording_duration = 2;
inline bool StartRecordingStateRequest::_internal_has_continue_recording_duration() const {
  return this != internal_default_instance() && _impl_.continue_recording_duration_ != nullptr;
}
inline bool StartRecordingStateRequest::has_continue_recording_duration() const {
  return _internal_has_continue_recording_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& StartRecordingStateRequest::_internal_continue_recording_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.continue_recording_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& StartRecordingStateRequest::continue_recording_duration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.StartRecordingStateRequest.continue_recording_duration)
  return _internal_continue_recording_duration();
}
inline void StartRecordingStateRequest::unsafe_arena_set_allocated_continue_recording_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* continue_recording_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.continue_recording_duration_);
  }
  _impl_.continue_recording_duration_ = continue_recording_duration;
  if (continue_recording_duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.StartRecordingStateRequest.continue_recording_duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* StartRecordingStateRequest::release_continue_recording_duration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.continue_recording_duration_;
  _impl_.continue_recording_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* StartRecordingStateRequest::unsafe_arena_release_continue_recording_duration() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.StartRecordingStateRequest.continue_recording_duration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.continue_recording_duration_;
  _impl_.continue_recording_duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* StartRecordingStateRequest::_internal_mutable_continue_recording_duration() {
  
  if (_impl_.continue_recording_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.continue_recording_duration_ = p;
  }
  return _impl_.continue_recording_duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* StartRecordingStateRequest::mutable_continue_recording_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_continue_recording_duration();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.StartRecordingStateRequest.continue_recording_duration)
  return _msg;
}
inline void StartRecordingStateRequest::set_allocated_continue_recording_duration(::PROTOBUF_NAMESPACE_ID::Duration* continue_recording_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.continue_recording_duration_);
  }
  if (continue_recording_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(continue_recording_duration));
    if (message_arena != submessage_arena) {
      continue_recording_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, continue_recording_duration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.continue_recording_duration_ = continue_recording_duration;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.StartRecordingStateRequest.continue_recording_duration)
}

// uint64 recording_session_id = 3;
inline void StartRecordingStateRequest::clear_recording_session_id() {
  _impl_.recording_session_id_ = uint64_t{0u};
}
inline uint64_t StartRecordingStateRequest::_internal_recording_session_id() const {
  return _impl_.recording_session_id_;
}
inline uint64_t StartRecordingStateRequest::recording_session_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.StartRecordingStateRequest.recording_session_id)
  return _internal_recording_session_id();
}
inline void StartRecordingStateRequest::_internal_set_recording_session_id(uint64_t value) {
  
  _impl_.recording_session_id_ = value;
}
inline void StartRecordingStateRequest::set_recording_session_id(uint64_t value) {
  _internal_set_recording_session_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.StartRecordingStateRequest.recording_session_id)
}

// -------------------------------------------------------------------

// StartRecordingStateResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool StartRecordingStateResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool StartRecordingStateResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& StartRecordingStateResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& StartRecordingStateResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.StartRecordingStateResponse.header)
  return _internal_header();
}
inline void StartRecordingStateResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.StartRecordingStateResponse.header)
}
inline ::bosdyn::api::ResponseHeader* StartRecordingStateResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StartRecordingStateResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.StartRecordingStateResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StartRecordingStateResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* StartRecordingStateResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.StartRecordingStateResponse.header)
  return _msg;
}
inline void StartRecordingStateResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.StartRecordingStateResponse.header)
}

// .bosdyn.api.spot.StartRecordingStateResponse.Status status = 2;
inline void StartRecordingStateResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::spot::StartRecordingStateResponse_Status StartRecordingStateResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::StartRecordingStateResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::spot::StartRecordingStateResponse_Status StartRecordingStateResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.StartRecordingStateResponse.status)
  return _internal_status();
}
inline void StartRecordingStateResponse::_internal_set_status(::bosdyn::api::spot::StartRecordingStateResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void StartRecordingStateResponse::set_status(::bosdyn::api::spot::StartRecordingStateResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.StartRecordingStateResponse.status)
}

// uint64 recording_session_id = 3;
inline void StartRecordingStateResponse::clear_recording_session_id() {
  _impl_.recording_session_id_ = uint64_t{0u};
}
inline uint64_t StartRecordingStateResponse::_internal_recording_session_id() const {
  return _impl_.recording_session_id_;
}
inline uint64_t StartRecordingStateResponse::recording_session_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.StartRecordingStateResponse.recording_session_id)
  return _internal_recording_session_id();
}
inline void StartRecordingStateResponse::_internal_set_recording_session_id(uint64_t value) {
  
  _impl_.recording_session_id_ = value;
}
inline void StartRecordingStateResponse::set_recording_session_id(uint64_t value) {
  _internal_set_recording_session_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.StartRecordingStateResponse.recording_session_id)
}

// -------------------------------------------------------------------

// StopRecordingStateRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool StopRecordingStateRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool StopRecordingStateRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& StopRecordingStateRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& StopRecordingStateRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.StopRecordingStateRequest.header)
  return _internal_header();
}
inline void StopRecordingStateRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.StopRecordingStateRequest.header)
}
inline ::bosdyn::api::RequestHeader* StopRecordingStateRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* StopRecordingStateRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.StopRecordingStateRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* StopRecordingStateRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* StopRecordingStateRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.StopRecordingStateRequest.header)
  return _msg;
}
inline void StopRecordingStateRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.StopRecordingStateRequest.header)
}

// -------------------------------------------------------------------

// StopRecordingStateResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool StopRecordingStateResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool StopRecordingStateResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& StopRecordingStateResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& StopRecordingStateResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.StopRecordingStateResponse.header)
  return _internal_header();
}
inline void StopRecordingStateResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.StopRecordingStateResponse.header)
}
inline ::bosdyn::api::ResponseHeader* StopRecordingStateResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StopRecordingStateResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.StopRecordingStateResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StopRecordingStateResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* StopRecordingStateResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.StopRecordingStateResponse.header)
  return _msg;
}
inline void StopRecordingStateResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.StopRecordingStateResponse.header)
}

// -------------------------------------------------------------------

// DownloadRobotStateLogRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool DownloadRobotStateLogRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DownloadRobotStateLogRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& DownloadRobotStateLogRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::RequestHeader&>(
      ::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& DownloadRobotStateLogRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DownloadRobotStateLogRequest.header)
  return _internal_header();
}
inline void DownloadRobotStateLogRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.DownloadRobotStateLogRequest.header)
}
inline ::bosdyn::api::RequestHeader* DownloadRobotStateLogRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::RequestHeader* DownloadRobotStateLogRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.DownloadRobotStateLogRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* DownloadRobotStateLogRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::RequestHeader* DownloadRobotStateLogRequest::mutable_header() {
  ::bosdyn::api::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.DownloadRobotStateLogRequest.header)
  return _msg;
}
inline void DownloadRobotStateLogRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.DownloadRobotStateLogRequest.header)
}

// .bosdyn.api.spot.DownloadRobotStateLogRequest.LogType log_type = 2;
inline void DownloadRobotStateLogRequest::clear_log_type() {
  _impl_.log_type_ = 0;
}
inline ::bosdyn::api::spot::DownloadRobotStateLogRequest_LogType DownloadRobotStateLogRequest::_internal_log_type() const {
  return static_cast< ::bosdyn::api::spot::DownloadRobotStateLogRequest_LogType >(_impl_.log_type_);
}
inline ::bosdyn::api::spot::DownloadRobotStateLogRequest_LogType DownloadRobotStateLogRequest::log_type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DownloadRobotStateLogRequest.log_type)
  return _internal_log_type();
}
inline void DownloadRobotStateLogRequest::_internal_set_log_type(::bosdyn::api::spot::DownloadRobotStateLogRequest_LogType value) {
  
  _impl_.log_type_ = value;
}
inline void DownloadRobotStateLogRequest::set_log_type(::bosdyn::api::spot::DownloadRobotStateLogRequest_LogType value) {
  _internal_set_log_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DownloadRobotStateLogRequest.log_type)
}

// -------------------------------------------------------------------

// LoggedJoints

// .bosdyn.api.spot.LegJointAngles fl = 1;
inline bool LoggedJoints::_internal_has_fl() const {
  return this != internal_default_instance() && _impl_.fl_ != nullptr;
}
inline bool LoggedJoints::has_fl() const {
  return _internal_has_fl();
}
inline void LoggedJoints::clear_fl() {
  if (GetArenaForAllocation() == nullptr && _impl_.fl_ != nullptr) {
    delete _impl_.fl_;
  }
  _impl_.fl_ = nullptr;
}
inline const ::bosdyn::api::spot::LegJointAngles& LoggedJoints::_internal_fl() const {
  const ::bosdyn::api::spot::LegJointAngles* p = _impl_.fl_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::LegJointAngles&>(
      ::bosdyn::api::spot::_LegJointAngles_default_instance_);
}
inline const ::bosdyn::api::spot::LegJointAngles& LoggedJoints::fl() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoggedJoints.fl)
  return _internal_fl();
}
inline void LoggedJoints::unsafe_arena_set_allocated_fl(
    ::bosdyn::api::spot::LegJointAngles* fl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fl_);
  }
  _impl_.fl_ = fl;
  if (fl) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.LoggedJoints.fl)
}
inline ::bosdyn::api::spot::LegJointAngles* LoggedJoints::release_fl() {
  
  ::bosdyn::api::spot::LegJointAngles* temp = _impl_.fl_;
  _impl_.fl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::LegJointAngles* LoggedJoints::unsafe_arena_release_fl() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.LoggedJoints.fl)
  
  ::bosdyn::api::spot::LegJointAngles* temp = _impl_.fl_;
  _impl_.fl_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::LegJointAngles* LoggedJoints::_internal_mutable_fl() {
  
  if (_impl_.fl_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::LegJointAngles>(GetArenaForAllocation());
    _impl_.fl_ = p;
  }
  return _impl_.fl_;
}
inline ::bosdyn::api::spot::LegJointAngles* LoggedJoints::mutable_fl() {
  ::bosdyn::api::spot::LegJointAngles* _msg = _internal_mutable_fl();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.LoggedJoints.fl)
  return _msg;
}
inline void LoggedJoints::set_allocated_fl(::bosdyn::api::spot::LegJointAngles* fl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fl_;
  }
  if (fl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fl);
    if (message_arena != submessage_arena) {
      fl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fl, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fl_ = fl;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.LoggedJoints.fl)
}

// .bosdyn.api.spot.LegJointAngles fr = 2;
inline bool LoggedJoints::_internal_has_fr() const {
  return this != internal_default_instance() && _impl_.fr_ != nullptr;
}
inline bool LoggedJoints::has_fr() const {
  return _internal_has_fr();
}
inline void LoggedJoints::clear_fr() {
  if (GetArenaForAllocation() == nullptr && _impl_.fr_ != nullptr) {
    delete _impl_.fr_;
  }
  _impl_.fr_ = nullptr;
}
inline const ::bosdyn::api::spot::LegJointAngles& LoggedJoints::_internal_fr() const {
  const ::bosdyn::api::spot::LegJointAngles* p = _impl_.fr_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::LegJointAngles&>(
      ::bosdyn::api::spot::_LegJointAngles_default_instance_);
}
inline const ::bosdyn::api::spot::LegJointAngles& LoggedJoints::fr() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoggedJoints.fr)
  return _internal_fr();
}
inline void LoggedJoints::unsafe_arena_set_allocated_fr(
    ::bosdyn::api::spot::LegJointAngles* fr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fr_);
  }
  _impl_.fr_ = fr;
  if (fr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.LoggedJoints.fr)
}
inline ::bosdyn::api::spot::LegJointAngles* LoggedJoints::release_fr() {
  
  ::bosdyn::api::spot::LegJointAngles* temp = _impl_.fr_;
  _impl_.fr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::LegJointAngles* LoggedJoints::unsafe_arena_release_fr() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.LoggedJoints.fr)
  
  ::bosdyn::api::spot::LegJointAngles* temp = _impl_.fr_;
  _impl_.fr_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::LegJointAngles* LoggedJoints::_internal_mutable_fr() {
  
  if (_impl_.fr_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::LegJointAngles>(GetArenaForAllocation());
    _impl_.fr_ = p;
  }
  return _impl_.fr_;
}
inline ::bosdyn::api::spot::LegJointAngles* LoggedJoints::mutable_fr() {
  ::bosdyn::api::spot::LegJointAngles* _msg = _internal_mutable_fr();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.LoggedJoints.fr)
  return _msg;
}
inline void LoggedJoints::set_allocated_fr(::bosdyn::api::spot::LegJointAngles* fr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fr_;
  }
  if (fr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fr);
    if (message_arena != submessage_arena) {
      fr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fr, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fr_ = fr;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.LoggedJoints.fr)
}

// .bosdyn.api.spot.LegJointAngles hl = 3;
inline bool LoggedJoints::_internal_has_hl() const {
  return this != internal_default_instance() && _impl_.hl_ != nullptr;
}
inline bool LoggedJoints::has_hl() const {
  return _internal_has_hl();
}
inline void LoggedJoints::clear_hl() {
  if (GetArenaForAllocation() == nullptr && _impl_.hl_ != nullptr) {
    delete _impl_.hl_;
  }
  _impl_.hl_ = nullptr;
}
inline const ::bosdyn::api::spot::LegJointAngles& LoggedJoints::_internal_hl() const {
  const ::bosdyn::api::spot::LegJointAngles* p = _impl_.hl_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::LegJointAngles&>(
      ::bosdyn::api::spot::_LegJointAngles_default_instance_);
}
inline const ::bosdyn::api::spot::LegJointAngles& LoggedJoints::hl() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoggedJoints.hl)
  return _internal_hl();
}
inline void LoggedJoints::unsafe_arena_set_allocated_hl(
    ::bosdyn::api::spot::LegJointAngles* hl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hl_);
  }
  _impl_.hl_ = hl;
  if (hl) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.LoggedJoints.hl)
}
inline ::bosdyn::api::spot::LegJointAngles* LoggedJoints::release_hl() {
  
  ::bosdyn::api::spot::LegJointAngles* temp = _impl_.hl_;
  _impl_.hl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::LegJointAngles* LoggedJoints::unsafe_arena_release_hl() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.LoggedJoints.hl)
  
  ::bosdyn::api::spot::LegJointAngles* temp = _impl_.hl_;
  _impl_.hl_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::LegJointAngles* LoggedJoints::_internal_mutable_hl() {
  
  if (_impl_.hl_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::LegJointAngles>(GetArenaForAllocation());
    _impl_.hl_ = p;
  }
  return _impl_.hl_;
}
inline ::bosdyn::api::spot::LegJointAngles* LoggedJoints::mutable_hl() {
  ::bosdyn::api::spot::LegJointAngles* _msg = _internal_mutable_hl();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.LoggedJoints.hl)
  return _msg;
}
inline void LoggedJoints::set_allocated_hl(::bosdyn::api::spot::LegJointAngles* hl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hl_;
  }
  if (hl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hl);
    if (message_arena != submessage_arena) {
      hl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hl, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hl_ = hl;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.LoggedJoints.hl)
}

// .bosdyn.api.spot.LegJointAngles hr = 4;
inline bool LoggedJoints::_internal_has_hr() const {
  return this != internal_default_instance() && _impl_.hr_ != nullptr;
}
inline bool LoggedJoints::has_hr() const {
  return _internal_has_hr();
}
inline void LoggedJoints::clear_hr() {
  if (GetArenaForAllocation() == nullptr && _impl_.hr_ != nullptr) {
    delete _impl_.hr_;
  }
  _impl_.hr_ = nullptr;
}
inline const ::bosdyn::api::spot::LegJointAngles& LoggedJoints::_internal_hr() const {
  const ::bosdyn::api::spot::LegJointAngles* p = _impl_.hr_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::LegJointAngles&>(
      ::bosdyn::api::spot::_LegJointAngles_default_instance_);
}
inline const ::bosdyn::api::spot::LegJointAngles& LoggedJoints::hr() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoggedJoints.hr)
  return _internal_hr();
}
inline void LoggedJoints::unsafe_arena_set_allocated_hr(
    ::bosdyn::api::spot::LegJointAngles* hr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hr_);
  }
  _impl_.hr_ = hr;
  if (hr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.LoggedJoints.hr)
}
inline ::bosdyn::api::spot::LegJointAngles* LoggedJoints::release_hr() {
  
  ::bosdyn::api::spot::LegJointAngles* temp = _impl_.hr_;
  _impl_.hr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::LegJointAngles* LoggedJoints::unsafe_arena_release_hr() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.LoggedJoints.hr)
  
  ::bosdyn::api::spot::LegJointAngles* temp = _impl_.hr_;
  _impl_.hr_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::LegJointAngles* LoggedJoints::_internal_mutable_hr() {
  
  if (_impl_.hr_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::LegJointAngles>(GetArenaForAllocation());
    _impl_.hr_ = p;
  }
  return _impl_.hr_;
}
inline ::bosdyn::api::spot::LegJointAngles* LoggedJoints::mutable_hr() {
  ::bosdyn::api::spot::LegJointAngles* _msg = _internal_mutable_hr();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.LoggedJoints.hr)
  return _msg;
}
inline void LoggedJoints::set_allocated_hr(::bosdyn::api::spot::LegJointAngles* hr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hr_;
  }
  if (hr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hr);
    if (message_arena != submessage_arena) {
      hr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hr, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hr_ = hr;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.LoggedJoints.hr)
}

// .bosdyn.api.spot.ArmJointAngles arm = 5;
inline bool LoggedJoints::_internal_has_arm() const {
  return this != internal_default_instance() && _impl_.arm_ != nullptr;
}
inline bool LoggedJoints::has_arm() const {
  return _internal_has_arm();
}
inline void LoggedJoints::clear_arm() {
  if (GetArenaForAllocation() == nullptr && _impl_.arm_ != nullptr) {
    delete _impl_.arm_;
  }
  _impl_.arm_ = nullptr;
}
inline const ::bosdyn::api::spot::ArmJointAngles& LoggedJoints::_internal_arm() const {
  const ::bosdyn::api::spot::ArmJointAngles* p = _impl_.arm_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::ArmJointAngles&>(
      ::bosdyn::api::spot::_ArmJointAngles_default_instance_);
}
inline const ::bosdyn::api::spot::ArmJointAngles& LoggedJoints::arm() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoggedJoints.arm)
  return _internal_arm();
}
inline void LoggedJoints::unsafe_arena_set_allocated_arm(
    ::bosdyn::api::spot::ArmJointAngles* arm) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arm_);
  }
  _impl_.arm_ = arm;
  if (arm) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.LoggedJoints.arm)
}
inline ::bosdyn::api::spot::ArmJointAngles* LoggedJoints::release_arm() {
  
  ::bosdyn::api::spot::ArmJointAngles* temp = _impl_.arm_;
  _impl_.arm_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::ArmJointAngles* LoggedJoints::unsafe_arena_release_arm() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.LoggedJoints.arm)
  
  ::bosdyn::api::spot::ArmJointAngles* temp = _impl_.arm_;
  _impl_.arm_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::ArmJointAngles* LoggedJoints::_internal_mutable_arm() {
  
  if (_impl_.arm_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::ArmJointAngles>(GetArenaForAllocation());
    _impl_.arm_ = p;
  }
  return _impl_.arm_;
}
inline ::bosdyn::api::spot::ArmJointAngles* LoggedJoints::mutable_arm() {
  ::bosdyn::api::spot::ArmJointAngles* _msg = _internal_mutable_arm();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.LoggedJoints.arm)
  return _msg;
}
inline void LoggedJoints::set_allocated_arm(::bosdyn::api::spot::ArmJointAngles* arm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.arm_;
  }
  if (arm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(arm);
    if (message_arena != submessage_arena) {
      arm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arm, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.arm_ = arm;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.LoggedJoints.arm)
}

// .google.protobuf.DoubleValue gripper_angle = 6;
inline bool LoggedJoints::_internal_has_gripper_angle() const {
  return this != internal_default_instance() && _impl_.gripper_angle_ != nullptr;
}
inline bool LoggedJoints::has_gripper_angle() const {
  return _internal_has_gripper_angle();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& LoggedJoints::_internal_gripper_angle() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.gripper_angle_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& LoggedJoints::gripper_angle() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoggedJoints.gripper_angle)
  return _internal_gripper_angle();
}
inline void LoggedJoints::unsafe_arena_set_allocated_gripper_angle(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* gripper_angle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gripper_angle_);
  }
  _impl_.gripper_angle_ = gripper_angle;
  if (gripper_angle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.LoggedJoints.gripper_angle)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* LoggedJoints::release_gripper_angle() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.gripper_angle_;
  _impl_.gripper_angle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* LoggedJoints::unsafe_arena_release_gripper_angle() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.LoggedJoints.gripper_angle)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.gripper_angle_;
  _impl_.gripper_angle_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* LoggedJoints::_internal_mutable_gripper_angle() {
  
  if (_impl_.gripper_angle_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.gripper_angle_ = p;
  }
  return _impl_.gripper_angle_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* LoggedJoints::mutable_gripper_angle() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_gripper_angle();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.LoggedJoints.gripper_angle)
  return _msg;
}
inline void LoggedJoints::set_allocated_gripper_angle(::PROTOBUF_NAMESPACE_ID::DoubleValue* gripper_angle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gripper_angle_);
  }
  if (gripper_angle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gripper_angle));
    if (message_arena != submessage_arena) {
      gripper_angle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gripper_angle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.gripper_angle_ = gripper_angle;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.LoggedJoints.gripper_angle)
}

// -------------------------------------------------------------------

// LoggedFootContacts

// bool fr_contact = 1;
inline void LoggedFootContacts::clear_fr_contact() {
  _impl_.fr_contact_ = false;
}
inline bool LoggedFootContacts::_internal_fr_contact() const {
  return _impl_.fr_contact_;
}
inline bool LoggedFootContacts::fr_contact() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoggedFootContacts.fr_contact)
  return _internal_fr_contact();
}
inline void LoggedFootContacts::_internal_set_fr_contact(bool value) {
  
  _impl_.fr_contact_ = value;
}
inline void LoggedFootContacts::set_fr_contact(bool value) {
  _internal_set_fr_contact(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LoggedFootContacts.fr_contact)
}

// bool fl_contact = 2;
inline void LoggedFootContacts::clear_fl_contact() {
  _impl_.fl_contact_ = false;
}
inline bool LoggedFootContacts::_internal_fl_contact() const {
  return _impl_.fl_contact_;
}
inline bool LoggedFootContacts::fl_contact() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoggedFootContacts.fl_contact)
  return _internal_fl_contact();
}
inline void LoggedFootContacts::_internal_set_fl_contact(bool value) {
  
  _impl_.fl_contact_ = value;
}
inline void LoggedFootContacts::set_fl_contact(bool value) {
  _internal_set_fl_contact(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LoggedFootContacts.fl_contact)
}

// bool hr_contact = 3;
inline void LoggedFootContacts::clear_hr_contact() {
  _impl_.hr_contact_ = false;
}
inline bool LoggedFootContacts::_internal_hr_contact() const {
  return _impl_.hr_contact_;
}
inline bool LoggedFootContacts::hr_contact() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoggedFootContacts.hr_contact)
  return _internal_hr_contact();
}
inline void LoggedFootContacts::_internal_set_hr_contact(bool value) {
  
  _impl_.hr_contact_ = value;
}
inline void LoggedFootContacts::set_hr_contact(bool value) {
  _internal_set_hr_contact(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LoggedFootContacts.hr_contact)
}

// bool hl_contact = 4;
inline void LoggedFootContacts::clear_hl_contact() {
  _impl_.hl_contact_ = false;
}
inline bool LoggedFootContacts::_internal_hl_contact() const {
  return _impl_.hl_contact_;
}
inline bool LoggedFootContacts::hl_contact() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoggedFootContacts.hl_contact)
  return _internal_hl_contact();
}
inline void LoggedFootContacts::_internal_set_hl_contact(bool value) {
  
  _impl_.hl_contact_ = value;
}
inline void LoggedFootContacts::set_hl_contact(bool value) {
  _internal_set_hl_contact(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LoggedFootContacts.hl_contact)
}

// -------------------------------------------------------------------

// LoggedStateKeyFrame

// .bosdyn.api.spot.LoggedJoints joint_angles = 1;
inline bool LoggedStateKeyFrame::_internal_has_joint_angles() const {
  return this != internal_default_instance() && _impl_.joint_angles_ != nullptr;
}
inline bool LoggedStateKeyFrame::has_joint_angles() const {
  return _internal_has_joint_angles();
}
inline void LoggedStateKeyFrame::clear_joint_angles() {
  if (GetArenaForAllocation() == nullptr && _impl_.joint_angles_ != nullptr) {
    delete _impl_.joint_angles_;
  }
  _impl_.joint_angles_ = nullptr;
}
inline const ::bosdyn::api::spot::LoggedJoints& LoggedStateKeyFrame::_internal_joint_angles() const {
  const ::bosdyn::api::spot::LoggedJoints* p = _impl_.joint_angles_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::LoggedJoints&>(
      ::bosdyn::api::spot::_LoggedJoints_default_instance_);
}
inline const ::bosdyn::api::spot::LoggedJoints& LoggedStateKeyFrame::joint_angles() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoggedStateKeyFrame.joint_angles)
  return _internal_joint_angles();
}
inline void LoggedStateKeyFrame::unsafe_arena_set_allocated_joint_angles(
    ::bosdyn::api::spot::LoggedJoints* joint_angles) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.joint_angles_);
  }
  _impl_.joint_angles_ = joint_angles;
  if (joint_angles) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.LoggedStateKeyFrame.joint_angles)
}
inline ::bosdyn::api::spot::LoggedJoints* LoggedStateKeyFrame::release_joint_angles() {
  
  ::bosdyn::api::spot::LoggedJoints* temp = _impl_.joint_angles_;
  _impl_.joint_angles_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::LoggedJoints* LoggedStateKeyFrame::unsafe_arena_release_joint_angles() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.LoggedStateKeyFrame.joint_angles)
  
  ::bosdyn::api::spot::LoggedJoints* temp = _impl_.joint_angles_;
  _impl_.joint_angles_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::LoggedJoints* LoggedStateKeyFrame::_internal_mutable_joint_angles() {
  
  if (_impl_.joint_angles_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::LoggedJoints>(GetArenaForAllocation());
    _impl_.joint_angles_ = p;
  }
  return _impl_.joint_angles_;
}
inline ::bosdyn::api::spot::LoggedJoints* LoggedStateKeyFrame::mutable_joint_angles() {
  ::bosdyn::api::spot::LoggedJoints* _msg = _internal_mutable_joint_angles();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.LoggedStateKeyFrame.joint_angles)
  return _msg;
}
inline void LoggedStateKeyFrame::set_allocated_joint_angles(::bosdyn::api::spot::LoggedJoints* joint_angles) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.joint_angles_;
  }
  if (joint_angles) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(joint_angles);
    if (message_arena != submessage_arena) {
      joint_angles = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joint_angles, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.joint_angles_ = joint_angles;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.LoggedStateKeyFrame.joint_angles)
}

// .bosdyn.api.spot.LoggedFootContacts foot_contact_state = 4;
inline bool LoggedStateKeyFrame::_internal_has_foot_contact_state() const {
  return this != internal_default_instance() && _impl_.foot_contact_state_ != nullptr;
}
inline bool LoggedStateKeyFrame::has_foot_contact_state() const {
  return _internal_has_foot_contact_state();
}
inline void LoggedStateKeyFrame::clear_foot_contact_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.foot_contact_state_ != nullptr) {
    delete _impl_.foot_contact_state_;
  }
  _impl_.foot_contact_state_ = nullptr;
}
inline const ::bosdyn::api::spot::LoggedFootContacts& LoggedStateKeyFrame::_internal_foot_contact_state() const {
  const ::bosdyn::api::spot::LoggedFootContacts* p = _impl_.foot_contact_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::LoggedFootContacts&>(
      ::bosdyn::api::spot::_LoggedFootContacts_default_instance_);
}
inline const ::bosdyn::api::spot::LoggedFootContacts& LoggedStateKeyFrame::foot_contact_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoggedStateKeyFrame.foot_contact_state)
  return _internal_foot_contact_state();
}
inline void LoggedStateKeyFrame::unsafe_arena_set_allocated_foot_contact_state(
    ::bosdyn::api::spot::LoggedFootContacts* foot_contact_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.foot_contact_state_);
  }
  _impl_.foot_contact_state_ = foot_contact_state;
  if (foot_contact_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.LoggedStateKeyFrame.foot_contact_state)
}
inline ::bosdyn::api::spot::LoggedFootContacts* LoggedStateKeyFrame::release_foot_contact_state() {
  
  ::bosdyn::api::spot::LoggedFootContacts* temp = _impl_.foot_contact_state_;
  _impl_.foot_contact_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::LoggedFootContacts* LoggedStateKeyFrame::unsafe_arena_release_foot_contact_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.LoggedStateKeyFrame.foot_contact_state)
  
  ::bosdyn::api::spot::LoggedFootContacts* temp = _impl_.foot_contact_state_;
  _impl_.foot_contact_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::LoggedFootContacts* LoggedStateKeyFrame::_internal_mutable_foot_contact_state() {
  
  if (_impl_.foot_contact_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::LoggedFootContacts>(GetArenaForAllocation());
    _impl_.foot_contact_state_ = p;
  }
  return _impl_.foot_contact_state_;
}
inline ::bosdyn::api::spot::LoggedFootContacts* LoggedStateKeyFrame::mutable_foot_contact_state() {
  ::bosdyn::api::spot::LoggedFootContacts* _msg = _internal_mutable_foot_contact_state();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.LoggedStateKeyFrame.foot_contact_state)
  return _msg;
}
inline void LoggedStateKeyFrame::set_allocated_foot_contact_state(::bosdyn::api::spot::LoggedFootContacts* foot_contact_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.foot_contact_state_;
  }
  if (foot_contact_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(foot_contact_state);
    if (message_arena != submessage_arena) {
      foot_contact_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, foot_contact_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.foot_contact_state_ = foot_contact_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.LoggedStateKeyFrame.foot_contact_state)
}

// .bosdyn.api.SE3Pose animation_tform_body = 2;
inline bool LoggedStateKeyFrame::_internal_has_animation_tform_body() const {
  return this != internal_default_instance() && _impl_.animation_tform_body_ != nullptr;
}
inline bool LoggedStateKeyFrame::has_animation_tform_body() const {
  return _internal_has_animation_tform_body();
}
inline const ::bosdyn::api::SE3Pose& LoggedStateKeyFrame::_internal_animation_tform_body() const {
  const ::bosdyn::api::SE3Pose* p = _impl_.animation_tform_body_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::SE3Pose&>(
      ::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& LoggedStateKeyFrame::animation_tform_body() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoggedStateKeyFrame.animation_tform_body)
  return _internal_animation_tform_body();
}
inline void LoggedStateKeyFrame::unsafe_arena_set_allocated_animation_tform_body(
    ::bosdyn::api::SE3Pose* animation_tform_body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.animation_tform_body_);
  }
  _impl_.animation_tform_body_ = animation_tform_body;
  if (animation_tform_body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.LoggedStateKeyFrame.animation_tform_body)
}
inline ::bosdyn::api::SE3Pose* LoggedStateKeyFrame::release_animation_tform_body() {
  
  ::bosdyn::api::SE3Pose* temp = _impl_.animation_tform_body_;
  _impl_.animation_tform_body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::SE3Pose* LoggedStateKeyFrame::unsafe_arena_release_animation_tform_body() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.LoggedStateKeyFrame.animation_tform_body)
  
  ::bosdyn::api::SE3Pose* temp = _impl_.animation_tform_body_;
  _impl_.animation_tform_body_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* LoggedStateKeyFrame::_internal_mutable_animation_tform_body() {
  
  if (_impl_.animation_tform_body_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArenaForAllocation());
    _impl_.animation_tform_body_ = p;
  }
  return _impl_.animation_tform_body_;
}
inline ::bosdyn::api::SE3Pose* LoggedStateKeyFrame::mutable_animation_tform_body() {
  ::bosdyn::api::SE3Pose* _msg = _internal_mutable_animation_tform_body();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.LoggedStateKeyFrame.animation_tform_body)
  return _msg;
}
inline void LoggedStateKeyFrame::set_allocated_animation_tform_body(::bosdyn::api::SE3Pose* animation_tform_body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.animation_tform_body_);
  }
  if (animation_tform_body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(animation_tform_body));
    if (message_arena != submessage_arena) {
      animation_tform_body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, animation_tform_body, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.animation_tform_body_ = animation_tform_body;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.LoggedStateKeyFrame.animation_tform_body)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool LoggedStateKeyFrame::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool LoggedStateKeyFrame::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LoggedStateKeyFrame::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LoggedStateKeyFrame::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoggedStateKeyFrame.timestamp)
  return _internal_timestamp();
}
inline void LoggedStateKeyFrame::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.LoggedStateKeyFrame.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LoggedStateKeyFrame::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LoggedStateKeyFrame::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.LoggedStateKeyFrame.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LoggedStateKeyFrame::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LoggedStateKeyFrame::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.LoggedStateKeyFrame.timestamp)
  return _msg;
}
inline void LoggedStateKeyFrame::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.LoggedStateKeyFrame.timestamp)
}

// -------------------------------------------------------------------

// ChoreographyStateLog

// repeated .bosdyn.api.spot.LoggedStateKeyFrame key_frames = 1;
inline int ChoreographyStateLog::_internal_key_frames_size() const {
  return _impl_.key_frames_.size();
}
inline int ChoreographyStateLog::key_frames_size() const {
  return _internal_key_frames_size();
}
inline void ChoreographyStateLog::clear_key_frames() {
  _impl_.key_frames_.Clear();
}
inline ::bosdyn::api::spot::LoggedStateKeyFrame* ChoreographyStateLog::mutable_key_frames(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ChoreographyStateLog.key_frames)
  return _impl_.key_frames_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::LoggedStateKeyFrame >*
ChoreographyStateLog::mutable_key_frames() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.ChoreographyStateLog.key_frames)
  return &_impl_.key_frames_;
}
inline const ::bosdyn::api::spot::LoggedStateKeyFrame& ChoreographyStateLog::_internal_key_frames(int index) const {
  return _impl_.key_frames_.Get(index);
}
inline const ::bosdyn::api::spot::LoggedStateKeyFrame& ChoreographyStateLog::key_frames(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographyStateLog.key_frames)
  return _internal_key_frames(index);
}
inline ::bosdyn::api::spot::LoggedStateKeyFrame* ChoreographyStateLog::_internal_add_key_frames() {
  return _impl_.key_frames_.Add();
}
inline ::bosdyn::api::spot::LoggedStateKeyFrame* ChoreographyStateLog::add_key_frames() {
  ::bosdyn::api::spot::LoggedStateKeyFrame* _add = _internal_add_key_frames();
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.ChoreographyStateLog.key_frames)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::LoggedStateKeyFrame >&
ChoreographyStateLog::key_frames() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.ChoreographyStateLog.key_frames)
  return _impl_.key_frames_;
}

// -------------------------------------------------------------------

// DownloadRobotStateLogResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool DownloadRobotStateLogResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DownloadRobotStateLogResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& DownloadRobotStateLogResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::ResponseHeader&>(
      ::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& DownloadRobotStateLogResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DownloadRobotStateLogResponse.header)
  return _internal_header();
}
inline void DownloadRobotStateLogResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.DownloadRobotStateLogResponse.header)
}
inline ::bosdyn::api::ResponseHeader* DownloadRobotStateLogResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DownloadRobotStateLogResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.DownloadRobotStateLogResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DownloadRobotStateLogResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::bosdyn::api::ResponseHeader* DownloadRobotStateLogResponse::mutable_header() {
  ::bosdyn::api::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.DownloadRobotStateLogResponse.header)
  return _msg;
}
inline void DownloadRobotStateLogResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.DownloadRobotStateLogResponse.header)
}

// .bosdyn.api.spot.DownloadRobotStateLogResponse.Status status = 2;
inline void DownloadRobotStateLogResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::bosdyn::api::spot::DownloadRobotStateLogResponse_Status DownloadRobotStateLogResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::DownloadRobotStateLogResponse_Status >(_impl_.status_);
}
inline ::bosdyn::api::spot::DownloadRobotStateLogResponse_Status DownloadRobotStateLogResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DownloadRobotStateLogResponse.status)
  return _internal_status();
}
inline void DownloadRobotStateLogResponse::_internal_set_status(::bosdyn::api::spot::DownloadRobotStateLogResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void DownloadRobotStateLogResponse::set_status(::bosdyn::api::spot::DownloadRobotStateLogResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DownloadRobotStateLogResponse.status)
}

// .bosdyn.api.DataChunk chunk = 3;
inline bool DownloadRobotStateLogResponse::_internal_has_chunk() const {
  return this != internal_default_instance() && _impl_.chunk_ != nullptr;
}
inline bool DownloadRobotStateLogResponse::has_chunk() const {
  return _internal_has_chunk();
}
inline const ::bosdyn::api::DataChunk& DownloadRobotStateLogResponse::_internal_chunk() const {
  const ::bosdyn::api::DataChunk* p = _impl_.chunk_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::DataChunk&>(
      ::bosdyn::api::_DataChunk_default_instance_);
}
inline const ::bosdyn::api::DataChunk& DownloadRobotStateLogResponse::chunk() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DownloadRobotStateLogResponse.chunk)
  return _internal_chunk();
}
inline void DownloadRobotStateLogResponse::unsafe_arena_set_allocated_chunk(
    ::bosdyn::api::DataChunk* chunk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chunk_);
  }
  _impl_.chunk_ = chunk;
  if (chunk) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.DownloadRobotStateLogResponse.chunk)
}
inline ::bosdyn::api::DataChunk* DownloadRobotStateLogResponse::release_chunk() {
  
  ::bosdyn::api::DataChunk* temp = _impl_.chunk_;
  _impl_.chunk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::DataChunk* DownloadRobotStateLogResponse::unsafe_arena_release_chunk() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.DownloadRobotStateLogResponse.chunk)
  
  ::bosdyn::api::DataChunk* temp = _impl_.chunk_;
  _impl_.chunk_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataChunk* DownloadRobotStateLogResponse::_internal_mutable_chunk() {
  
  if (_impl_.chunk_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataChunk>(GetArenaForAllocation());
    _impl_.chunk_ = p;
  }
  return _impl_.chunk_;
}
inline ::bosdyn::api::DataChunk* DownloadRobotStateLogResponse::mutable_chunk() {
  ::bosdyn::api::DataChunk* _msg = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.DownloadRobotStateLogResponse.chunk)
  return _msg;
}
inline void DownloadRobotStateLogResponse::set_allocated_chunk(::bosdyn::api::DataChunk* chunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chunk_);
  }
  if (chunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chunk));
    if (message_arena != submessage_arena) {
      chunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chunk, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chunk_ = chunk;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.DownloadRobotStateLogResponse.chunk)
}

// -------------------------------------------------------------------

// MoveParams

// string type = 1;
inline void MoveParams::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& MoveParams::type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoveParams::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveParams.type)
}
inline std::string* MoveParams::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.type)
  return _s;
}
inline const std::string& MoveParams::_internal_type() const {
  return _impl_.type_.Get();
}
inline void MoveParams::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* MoveParams::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* MoveParams::release_type() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.type)
  return _impl_.type_.Release();
}
inline void MoveParams::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.MoveParams.type)
}

// int32 start_slice = 2;
inline void MoveParams::clear_start_slice() {
  _impl_.start_slice_ = 0;
}
inline int32_t MoveParams::_internal_start_slice() const {
  return _impl_.start_slice_;
}
inline int32_t MoveParams::start_slice() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.start_slice)
  return _internal_start_slice();
}
inline void MoveParams::_internal_set_start_slice(int32_t value) {
  
  _impl_.start_slice_ = value;
}
inline void MoveParams::set_start_slice(int32_t value) {
  _internal_set_start_slice(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveParams.start_slice)
}

// int32 requested_slices = 3;
inline void MoveParams::clear_requested_slices() {
  _impl_.requested_slices_ = 0;
}
inline int32_t MoveParams::_internal_requested_slices() const {
  return _impl_.requested_slices_;
}
inline int32_t MoveParams::requested_slices() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.requested_slices)
  return _internal_requested_slices();
}
inline void MoveParams::_internal_set_requested_slices(int32_t value) {
  
  _impl_.requested_slices_ = value;
}
inline void MoveParams::set_requested_slices(int32_t value) {
  _internal_set_requested_slices(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveParams.requested_slices)
}

// .bosdyn.api.spot.JumpParams jump_params = 11;
inline bool MoveParams::_internal_has_jump_params() const {
  return params_case() == kJumpParams;
}
inline bool MoveParams::has_jump_params() const {
  return _internal_has_jump_params();
}
inline void MoveParams::set_has_jump_params() {
  _impl_._oneof_case_[0] = kJumpParams;
}
inline ::bosdyn::api::spot::JumpParams* MoveParams::release_jump_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.jump_params)
  if (_internal_has_jump_params()) {
    clear_has_params();
    ::bosdyn::api::spot::JumpParams* temp = _impl_.params_.jump_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.jump_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::JumpParams& MoveParams::_internal_jump_params() const {
  return _internal_has_jump_params()
      ? *_impl_.params_.jump_params_
      : reinterpret_cast< ::bosdyn::api::spot::JumpParams&>(::bosdyn::api::spot::_JumpParams_default_instance_);
}
inline const ::bosdyn::api::spot::JumpParams& MoveParams::jump_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.jump_params)
  return _internal_jump_params();
}
inline ::bosdyn::api::spot::JumpParams* MoveParams::unsafe_arena_release_jump_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.jump_params)
  if (_internal_has_jump_params()) {
    clear_has_params();
    ::bosdyn::api::spot::JumpParams* temp = _impl_.params_.jump_params_;
    _impl_.params_.jump_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_jump_params(::bosdyn::api::spot::JumpParams* jump_params) {
  clear_params();
  if (jump_params) {
    set_has_jump_params();
    _impl_.params_.jump_params_ = jump_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.jump_params)
}
inline ::bosdyn::api::spot::JumpParams* MoveParams::_internal_mutable_jump_params() {
  if (!_internal_has_jump_params()) {
    clear_params();
    set_has_jump_params();
    _impl_.params_.jump_params_ = CreateMaybeMessage< ::bosdyn::api::spot::JumpParams >(GetArenaForAllocation());
  }
  return _impl_.params_.jump_params_;
}
inline ::bosdyn::api::spot::JumpParams* MoveParams::mutable_jump_params() {
  ::bosdyn::api::spot::JumpParams* _msg = _internal_mutable_jump_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.jump_params)
  return _msg;
}

// .bosdyn.api.spot.RotateBodyParams rotate_body_params = 12;
inline bool MoveParams::_internal_has_rotate_body_params() const {
  return params_case() == kRotateBodyParams;
}
inline bool MoveParams::has_rotate_body_params() const {
  return _internal_has_rotate_body_params();
}
inline void MoveParams::set_has_rotate_body_params() {
  _impl_._oneof_case_[0] = kRotateBodyParams;
}
inline ::bosdyn::api::spot::RotateBodyParams* MoveParams::release_rotate_body_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.rotate_body_params)
  if (_internal_has_rotate_body_params()) {
    clear_has_params();
    ::bosdyn::api::spot::RotateBodyParams* temp = _impl_.params_.rotate_body_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.rotate_body_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::RotateBodyParams& MoveParams::_internal_rotate_body_params() const {
  return _internal_has_rotate_body_params()
      ? *_impl_.params_.rotate_body_params_
      : reinterpret_cast< ::bosdyn::api::spot::RotateBodyParams&>(::bosdyn::api::spot::_RotateBodyParams_default_instance_);
}
inline const ::bosdyn::api::spot::RotateBodyParams& MoveParams::rotate_body_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.rotate_body_params)
  return _internal_rotate_body_params();
}
inline ::bosdyn::api::spot::RotateBodyParams* MoveParams::unsafe_arena_release_rotate_body_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.rotate_body_params)
  if (_internal_has_rotate_body_params()) {
    clear_has_params();
    ::bosdyn::api::spot::RotateBodyParams* temp = _impl_.params_.rotate_body_params_;
    _impl_.params_.rotate_body_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_rotate_body_params(::bosdyn::api::spot::RotateBodyParams* rotate_body_params) {
  clear_params();
  if (rotate_body_params) {
    set_has_rotate_body_params();
    _impl_.params_.rotate_body_params_ = rotate_body_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.rotate_body_params)
}
inline ::bosdyn::api::spot::RotateBodyParams* MoveParams::_internal_mutable_rotate_body_params() {
  if (!_internal_has_rotate_body_params()) {
    clear_params();
    set_has_rotate_body_params();
    _impl_.params_.rotate_body_params_ = CreateMaybeMessage< ::bosdyn::api::spot::RotateBodyParams >(GetArenaForAllocation());
  }
  return _impl_.params_.rotate_body_params_;
}
inline ::bosdyn::api::spot::RotateBodyParams* MoveParams::mutable_rotate_body_params() {
  ::bosdyn::api::spot::RotateBodyParams* _msg = _internal_mutable_rotate_body_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.rotate_body_params)
  return _msg;
}

// .bosdyn.api.spot.StepParams step_params = 13;
inline bool MoveParams::_internal_has_step_params() const {
  return params_case() == kStepParams;
}
inline bool MoveParams::has_step_params() const {
  return _internal_has_step_params();
}
inline void MoveParams::set_has_step_params() {
  _impl_._oneof_case_[0] = kStepParams;
}
inline ::bosdyn::api::spot::StepParams* MoveParams::release_step_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.step_params)
  if (_internal_has_step_params()) {
    clear_has_params();
    ::bosdyn::api::spot::StepParams* temp = _impl_.params_.step_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.step_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::StepParams& MoveParams::_internal_step_params() const {
  return _internal_has_step_params()
      ? *_impl_.params_.step_params_
      : reinterpret_cast< ::bosdyn::api::spot::StepParams&>(::bosdyn::api::spot::_StepParams_default_instance_);
}
inline const ::bosdyn::api::spot::StepParams& MoveParams::step_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.step_params)
  return _internal_step_params();
}
inline ::bosdyn::api::spot::StepParams* MoveParams::unsafe_arena_release_step_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.step_params)
  if (_internal_has_step_params()) {
    clear_has_params();
    ::bosdyn::api::spot::StepParams* temp = _impl_.params_.step_params_;
    _impl_.params_.step_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_step_params(::bosdyn::api::spot::StepParams* step_params) {
  clear_params();
  if (step_params) {
    set_has_step_params();
    _impl_.params_.step_params_ = step_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.step_params)
}
inline ::bosdyn::api::spot::StepParams* MoveParams::_internal_mutable_step_params() {
  if (!_internal_has_step_params()) {
    clear_params();
    set_has_step_params();
    _impl_.params_.step_params_ = CreateMaybeMessage< ::bosdyn::api::spot::StepParams >(GetArenaForAllocation());
  }
  return _impl_.params_.step_params_;
}
inline ::bosdyn::api::spot::StepParams* MoveParams::mutable_step_params() {
  ::bosdyn::api::spot::StepParams* _msg = _internal_mutable_step_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.step_params)
  return _msg;
}

// .bosdyn.api.spot.ButtCircleParams butt_circle_params = 14;
inline bool MoveParams::_internal_has_butt_circle_params() const {
  return params_case() == kButtCircleParams;
}
inline bool MoveParams::has_butt_circle_params() const {
  return _internal_has_butt_circle_params();
}
inline void MoveParams::set_has_butt_circle_params() {
  _impl_._oneof_case_[0] = kButtCircleParams;
}
inline ::bosdyn::api::spot::ButtCircleParams* MoveParams::release_butt_circle_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.butt_circle_params)
  if (_internal_has_butt_circle_params()) {
    clear_has_params();
    ::bosdyn::api::spot::ButtCircleParams* temp = _impl_.params_.butt_circle_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.butt_circle_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::ButtCircleParams& MoveParams::_internal_butt_circle_params() const {
  return _internal_has_butt_circle_params()
      ? *_impl_.params_.butt_circle_params_
      : reinterpret_cast< ::bosdyn::api::spot::ButtCircleParams&>(::bosdyn::api::spot::_ButtCircleParams_default_instance_);
}
inline const ::bosdyn::api::spot::ButtCircleParams& MoveParams::butt_circle_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.butt_circle_params)
  return _internal_butt_circle_params();
}
inline ::bosdyn::api::spot::ButtCircleParams* MoveParams::unsafe_arena_release_butt_circle_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.butt_circle_params)
  if (_internal_has_butt_circle_params()) {
    clear_has_params();
    ::bosdyn::api::spot::ButtCircleParams* temp = _impl_.params_.butt_circle_params_;
    _impl_.params_.butt_circle_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_butt_circle_params(::bosdyn::api::spot::ButtCircleParams* butt_circle_params) {
  clear_params();
  if (butt_circle_params) {
    set_has_butt_circle_params();
    _impl_.params_.butt_circle_params_ = butt_circle_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.butt_circle_params)
}
inline ::bosdyn::api::spot::ButtCircleParams* MoveParams::_internal_mutable_butt_circle_params() {
  if (!_internal_has_butt_circle_params()) {
    clear_params();
    set_has_butt_circle_params();
    _impl_.params_.butt_circle_params_ = CreateMaybeMessage< ::bosdyn::api::spot::ButtCircleParams >(GetArenaForAllocation());
  }
  return _impl_.params_.butt_circle_params_;
}
inline ::bosdyn::api::spot::ButtCircleParams* MoveParams::mutable_butt_circle_params() {
  ::bosdyn::api::spot::ButtCircleParams* _msg = _internal_mutable_butt_circle_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.butt_circle_params)
  return _msg;
}

// .bosdyn.api.spot.TurnParams turn_params = 15;
inline bool MoveParams::_internal_has_turn_params() const {
  return params_case() == kTurnParams;
}
inline bool MoveParams::has_turn_params() const {
  return _internal_has_turn_params();
}
inline void MoveParams::set_has_turn_params() {
  _impl_._oneof_case_[0] = kTurnParams;
}
inline ::bosdyn::api::spot::TurnParams* MoveParams::release_turn_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.turn_params)
  if (_internal_has_turn_params()) {
    clear_has_params();
    ::bosdyn::api::spot::TurnParams* temp = _impl_.params_.turn_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.turn_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::TurnParams& MoveParams::_internal_turn_params() const {
  return _internal_has_turn_params()
      ? *_impl_.params_.turn_params_
      : reinterpret_cast< ::bosdyn::api::spot::TurnParams&>(::bosdyn::api::spot::_TurnParams_default_instance_);
}
inline const ::bosdyn::api::spot::TurnParams& MoveParams::turn_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.turn_params)
  return _internal_turn_params();
}
inline ::bosdyn::api::spot::TurnParams* MoveParams::unsafe_arena_release_turn_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.turn_params)
  if (_internal_has_turn_params()) {
    clear_has_params();
    ::bosdyn::api::spot::TurnParams* temp = _impl_.params_.turn_params_;
    _impl_.params_.turn_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_turn_params(::bosdyn::api::spot::TurnParams* turn_params) {
  clear_params();
  if (turn_params) {
    set_has_turn_params();
    _impl_.params_.turn_params_ = turn_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.turn_params)
}
inline ::bosdyn::api::spot::TurnParams* MoveParams::_internal_mutable_turn_params() {
  if (!_internal_has_turn_params()) {
    clear_params();
    set_has_turn_params();
    _impl_.params_.turn_params_ = CreateMaybeMessage< ::bosdyn::api::spot::TurnParams >(GetArenaForAllocation());
  }
  return _impl_.params_.turn_params_;
}
inline ::bosdyn::api::spot::TurnParams* MoveParams::mutable_turn_params() {
  ::bosdyn::api::spot::TurnParams* _msg = _internal_mutable_turn_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.turn_params)
  return _msg;
}

// .bosdyn.api.spot.Pace2StepParams pace_2step_params = 16;
inline bool MoveParams::_internal_has_pace_2step_params() const {
  return params_case() == kPace2StepParams;
}
inline bool MoveParams::has_pace_2step_params() const {
  return _internal_has_pace_2step_params();
}
inline void MoveParams::set_has_pace_2step_params() {
  _impl_._oneof_case_[0] = kPace2StepParams;
}
inline ::bosdyn::api::spot::Pace2StepParams* MoveParams::release_pace_2step_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.pace_2step_params)
  if (_internal_has_pace_2step_params()) {
    clear_has_params();
    ::bosdyn::api::spot::Pace2StepParams* temp = _impl_.params_.pace_2step_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.pace_2step_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::Pace2StepParams& MoveParams::_internal_pace_2step_params() const {
  return _internal_has_pace_2step_params()
      ? *_impl_.params_.pace_2step_params_
      : reinterpret_cast< ::bosdyn::api::spot::Pace2StepParams&>(::bosdyn::api::spot::_Pace2StepParams_default_instance_);
}
inline const ::bosdyn::api::spot::Pace2StepParams& MoveParams::pace_2step_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.pace_2step_params)
  return _internal_pace_2step_params();
}
inline ::bosdyn::api::spot::Pace2StepParams* MoveParams::unsafe_arena_release_pace_2step_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.pace_2step_params)
  if (_internal_has_pace_2step_params()) {
    clear_has_params();
    ::bosdyn::api::spot::Pace2StepParams* temp = _impl_.params_.pace_2step_params_;
    _impl_.params_.pace_2step_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_pace_2step_params(::bosdyn::api::spot::Pace2StepParams* pace_2step_params) {
  clear_params();
  if (pace_2step_params) {
    set_has_pace_2step_params();
    _impl_.params_.pace_2step_params_ = pace_2step_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.pace_2step_params)
}
inline ::bosdyn::api::spot::Pace2StepParams* MoveParams::_internal_mutable_pace_2step_params() {
  if (!_internal_has_pace_2step_params()) {
    clear_params();
    set_has_pace_2step_params();
    _impl_.params_.pace_2step_params_ = CreateMaybeMessage< ::bosdyn::api::spot::Pace2StepParams >(GetArenaForAllocation());
  }
  return _impl_.params_.pace_2step_params_;
}
inline ::bosdyn::api::spot::Pace2StepParams* MoveParams::mutable_pace_2step_params() {
  ::bosdyn::api::spot::Pace2StepParams* _msg = _internal_mutable_pace_2step_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.pace_2step_params)
  return _msg;
}

// .bosdyn.api.spot.TwerkParams twerk_params = 17;
inline bool MoveParams::_internal_has_twerk_params() const {
  return params_case() == kTwerkParams;
}
inline bool MoveParams::has_twerk_params() const {
  return _internal_has_twerk_params();
}
inline void MoveParams::set_has_twerk_params() {
  _impl_._oneof_case_[0] = kTwerkParams;
}
inline ::bosdyn::api::spot::TwerkParams* MoveParams::release_twerk_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.twerk_params)
  if (_internal_has_twerk_params()) {
    clear_has_params();
    ::bosdyn::api::spot::TwerkParams* temp = _impl_.params_.twerk_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.twerk_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::TwerkParams& MoveParams::_internal_twerk_params() const {
  return _internal_has_twerk_params()
      ? *_impl_.params_.twerk_params_
      : reinterpret_cast< ::bosdyn::api::spot::TwerkParams&>(::bosdyn::api::spot::_TwerkParams_default_instance_);
}
inline const ::bosdyn::api::spot::TwerkParams& MoveParams::twerk_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.twerk_params)
  return _internal_twerk_params();
}
inline ::bosdyn::api::spot::TwerkParams* MoveParams::unsafe_arena_release_twerk_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.twerk_params)
  if (_internal_has_twerk_params()) {
    clear_has_params();
    ::bosdyn::api::spot::TwerkParams* temp = _impl_.params_.twerk_params_;
    _impl_.params_.twerk_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_twerk_params(::bosdyn::api::spot::TwerkParams* twerk_params) {
  clear_params();
  if (twerk_params) {
    set_has_twerk_params();
    _impl_.params_.twerk_params_ = twerk_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.twerk_params)
}
inline ::bosdyn::api::spot::TwerkParams* MoveParams::_internal_mutable_twerk_params() {
  if (!_internal_has_twerk_params()) {
    clear_params();
    set_has_twerk_params();
    _impl_.params_.twerk_params_ = CreateMaybeMessage< ::bosdyn::api::spot::TwerkParams >(GetArenaForAllocation());
  }
  return _impl_.params_.twerk_params_;
}
inline ::bosdyn::api::spot::TwerkParams* MoveParams::mutable_twerk_params() {
  ::bosdyn::api::spot::TwerkParams* _msg = _internal_mutable_twerk_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.twerk_params)
  return _msg;
}

// .bosdyn.api.spot.ChickenHeadParams chicken_head_params = 18;
inline bool MoveParams::_internal_has_chicken_head_params() const {
  return params_case() == kChickenHeadParams;
}
inline bool MoveParams::has_chicken_head_params() const {
  return _internal_has_chicken_head_params();
}
inline void MoveParams::set_has_chicken_head_params() {
  _impl_._oneof_case_[0] = kChickenHeadParams;
}
inline ::bosdyn::api::spot::ChickenHeadParams* MoveParams::release_chicken_head_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.chicken_head_params)
  if (_internal_has_chicken_head_params()) {
    clear_has_params();
    ::bosdyn::api::spot::ChickenHeadParams* temp = _impl_.params_.chicken_head_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.chicken_head_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::ChickenHeadParams& MoveParams::_internal_chicken_head_params() const {
  return _internal_has_chicken_head_params()
      ? *_impl_.params_.chicken_head_params_
      : reinterpret_cast< ::bosdyn::api::spot::ChickenHeadParams&>(::bosdyn::api::spot::_ChickenHeadParams_default_instance_);
}
inline const ::bosdyn::api::spot::ChickenHeadParams& MoveParams::chicken_head_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.chicken_head_params)
  return _internal_chicken_head_params();
}
inline ::bosdyn::api::spot::ChickenHeadParams* MoveParams::unsafe_arena_release_chicken_head_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.chicken_head_params)
  if (_internal_has_chicken_head_params()) {
    clear_has_params();
    ::bosdyn::api::spot::ChickenHeadParams* temp = _impl_.params_.chicken_head_params_;
    _impl_.params_.chicken_head_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_chicken_head_params(::bosdyn::api::spot::ChickenHeadParams* chicken_head_params) {
  clear_params();
  if (chicken_head_params) {
    set_has_chicken_head_params();
    _impl_.params_.chicken_head_params_ = chicken_head_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.chicken_head_params)
}
inline ::bosdyn::api::spot::ChickenHeadParams* MoveParams::_internal_mutable_chicken_head_params() {
  if (!_internal_has_chicken_head_params()) {
    clear_params();
    set_has_chicken_head_params();
    _impl_.params_.chicken_head_params_ = CreateMaybeMessage< ::bosdyn::api::spot::ChickenHeadParams >(GetArenaForAllocation());
  }
  return _impl_.params_.chicken_head_params_;
}
inline ::bosdyn::api::spot::ChickenHeadParams* MoveParams::mutable_chicken_head_params() {
  ::bosdyn::api::spot::ChickenHeadParams* _msg = _internal_mutable_chicken_head_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.chicken_head_params)
  return _msg;
}

// .bosdyn.api.spot.ClapParams clap_params = 19;
inline bool MoveParams::_internal_has_clap_params() const {
  return params_case() == kClapParams;
}
inline bool MoveParams::has_clap_params() const {
  return _internal_has_clap_params();
}
inline void MoveParams::set_has_clap_params() {
  _impl_._oneof_case_[0] = kClapParams;
}
inline ::bosdyn::api::spot::ClapParams* MoveParams::release_clap_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.clap_params)
  if (_internal_has_clap_params()) {
    clear_has_params();
    ::bosdyn::api::spot::ClapParams* temp = _impl_.params_.clap_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.clap_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::ClapParams& MoveParams::_internal_clap_params() const {
  return _internal_has_clap_params()
      ? *_impl_.params_.clap_params_
      : reinterpret_cast< ::bosdyn::api::spot::ClapParams&>(::bosdyn::api::spot::_ClapParams_default_instance_);
}
inline const ::bosdyn::api::spot::ClapParams& MoveParams::clap_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.clap_params)
  return _internal_clap_params();
}
inline ::bosdyn::api::spot::ClapParams* MoveParams::unsafe_arena_release_clap_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.clap_params)
  if (_internal_has_clap_params()) {
    clear_has_params();
    ::bosdyn::api::spot::ClapParams* temp = _impl_.params_.clap_params_;
    _impl_.params_.clap_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_clap_params(::bosdyn::api::spot::ClapParams* clap_params) {
  clear_params();
  if (clap_params) {
    set_has_clap_params();
    _impl_.params_.clap_params_ = clap_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.clap_params)
}
inline ::bosdyn::api::spot::ClapParams* MoveParams::_internal_mutable_clap_params() {
  if (!_internal_has_clap_params()) {
    clear_params();
    set_has_clap_params();
    _impl_.params_.clap_params_ = CreateMaybeMessage< ::bosdyn::api::spot::ClapParams >(GetArenaForAllocation());
  }
  return _impl_.params_.clap_params_;
}
inline ::bosdyn::api::spot::ClapParams* MoveParams::mutable_clap_params() {
  ::bosdyn::api::spot::ClapParams* _msg = _internal_mutable_clap_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.clap_params)
  return _msg;
}

// .bosdyn.api.spot.FrontUpParams front_up_params = 20;
inline bool MoveParams::_internal_has_front_up_params() const {
  return params_case() == kFrontUpParams;
}
inline bool MoveParams::has_front_up_params() const {
  return _internal_has_front_up_params();
}
inline void MoveParams::set_has_front_up_params() {
  _impl_._oneof_case_[0] = kFrontUpParams;
}
inline ::bosdyn::api::spot::FrontUpParams* MoveParams::release_front_up_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.front_up_params)
  if (_internal_has_front_up_params()) {
    clear_has_params();
    ::bosdyn::api::spot::FrontUpParams* temp = _impl_.params_.front_up_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.front_up_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::FrontUpParams& MoveParams::_internal_front_up_params() const {
  return _internal_has_front_up_params()
      ? *_impl_.params_.front_up_params_
      : reinterpret_cast< ::bosdyn::api::spot::FrontUpParams&>(::bosdyn::api::spot::_FrontUpParams_default_instance_);
}
inline const ::bosdyn::api::spot::FrontUpParams& MoveParams::front_up_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.front_up_params)
  return _internal_front_up_params();
}
inline ::bosdyn::api::spot::FrontUpParams* MoveParams::unsafe_arena_release_front_up_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.front_up_params)
  if (_internal_has_front_up_params()) {
    clear_has_params();
    ::bosdyn::api::spot::FrontUpParams* temp = _impl_.params_.front_up_params_;
    _impl_.params_.front_up_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_front_up_params(::bosdyn::api::spot::FrontUpParams* front_up_params) {
  clear_params();
  if (front_up_params) {
    set_has_front_up_params();
    _impl_.params_.front_up_params_ = front_up_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.front_up_params)
}
inline ::bosdyn::api::spot::FrontUpParams* MoveParams::_internal_mutable_front_up_params() {
  if (!_internal_has_front_up_params()) {
    clear_params();
    set_has_front_up_params();
    _impl_.params_.front_up_params_ = CreateMaybeMessage< ::bosdyn::api::spot::FrontUpParams >(GetArenaForAllocation());
  }
  return _impl_.params_.front_up_params_;
}
inline ::bosdyn::api::spot::FrontUpParams* MoveParams::mutable_front_up_params() {
  ::bosdyn::api::spot::FrontUpParams* _msg = _internal_mutable_front_up_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.front_up_params)
  return _msg;
}

// .bosdyn.api.spot.SwayParams sway_params = 21;
inline bool MoveParams::_internal_has_sway_params() const {
  return params_case() == kSwayParams;
}
inline bool MoveParams::has_sway_params() const {
  return _internal_has_sway_params();
}
inline void MoveParams::set_has_sway_params() {
  _impl_._oneof_case_[0] = kSwayParams;
}
inline ::bosdyn::api::spot::SwayParams* MoveParams::release_sway_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.sway_params)
  if (_internal_has_sway_params()) {
    clear_has_params();
    ::bosdyn::api::spot::SwayParams* temp = _impl_.params_.sway_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.sway_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::SwayParams& MoveParams::_internal_sway_params() const {
  return _internal_has_sway_params()
      ? *_impl_.params_.sway_params_
      : reinterpret_cast< ::bosdyn::api::spot::SwayParams&>(::bosdyn::api::spot::_SwayParams_default_instance_);
}
inline const ::bosdyn::api::spot::SwayParams& MoveParams::sway_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.sway_params)
  return _internal_sway_params();
}
inline ::bosdyn::api::spot::SwayParams* MoveParams::unsafe_arena_release_sway_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.sway_params)
  if (_internal_has_sway_params()) {
    clear_has_params();
    ::bosdyn::api::spot::SwayParams* temp = _impl_.params_.sway_params_;
    _impl_.params_.sway_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_sway_params(::bosdyn::api::spot::SwayParams* sway_params) {
  clear_params();
  if (sway_params) {
    set_has_sway_params();
    _impl_.params_.sway_params_ = sway_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.sway_params)
}
inline ::bosdyn::api::spot::SwayParams* MoveParams::_internal_mutable_sway_params() {
  if (!_internal_has_sway_params()) {
    clear_params();
    set_has_sway_params();
    _impl_.params_.sway_params_ = CreateMaybeMessage< ::bosdyn::api::spot::SwayParams >(GetArenaForAllocation());
  }
  return _impl_.params_.sway_params_;
}
inline ::bosdyn::api::spot::SwayParams* MoveParams::mutable_sway_params() {
  ::bosdyn::api::spot::SwayParams* _msg = _internal_mutable_sway_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.sway_params)
  return _msg;
}

// .bosdyn.api.spot.BodyHoldParams body_hold_params = 22;
inline bool MoveParams::_internal_has_body_hold_params() const {
  return params_case() == kBodyHoldParams;
}
inline bool MoveParams::has_body_hold_params() const {
  return _internal_has_body_hold_params();
}
inline void MoveParams::set_has_body_hold_params() {
  _impl_._oneof_case_[0] = kBodyHoldParams;
}
inline ::bosdyn::api::spot::BodyHoldParams* MoveParams::release_body_hold_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.body_hold_params)
  if (_internal_has_body_hold_params()) {
    clear_has_params();
    ::bosdyn::api::spot::BodyHoldParams* temp = _impl_.params_.body_hold_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.body_hold_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::BodyHoldParams& MoveParams::_internal_body_hold_params() const {
  return _internal_has_body_hold_params()
      ? *_impl_.params_.body_hold_params_
      : reinterpret_cast< ::bosdyn::api::spot::BodyHoldParams&>(::bosdyn::api::spot::_BodyHoldParams_default_instance_);
}
inline const ::bosdyn::api::spot::BodyHoldParams& MoveParams::body_hold_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.body_hold_params)
  return _internal_body_hold_params();
}
inline ::bosdyn::api::spot::BodyHoldParams* MoveParams::unsafe_arena_release_body_hold_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.body_hold_params)
  if (_internal_has_body_hold_params()) {
    clear_has_params();
    ::bosdyn::api::spot::BodyHoldParams* temp = _impl_.params_.body_hold_params_;
    _impl_.params_.body_hold_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_body_hold_params(::bosdyn::api::spot::BodyHoldParams* body_hold_params) {
  clear_params();
  if (body_hold_params) {
    set_has_body_hold_params();
    _impl_.params_.body_hold_params_ = body_hold_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.body_hold_params)
}
inline ::bosdyn::api::spot::BodyHoldParams* MoveParams::_internal_mutable_body_hold_params() {
  if (!_internal_has_body_hold_params()) {
    clear_params();
    set_has_body_hold_params();
    _impl_.params_.body_hold_params_ = CreateMaybeMessage< ::bosdyn::api::spot::BodyHoldParams >(GetArenaForAllocation());
  }
  return _impl_.params_.body_hold_params_;
}
inline ::bosdyn::api::spot::BodyHoldParams* MoveParams::mutable_body_hold_params() {
  ::bosdyn::api::spot::BodyHoldParams* _msg = _internal_mutable_body_hold_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.body_hold_params)
  return _msg;
}

// .bosdyn.api.spot.ArmMoveParams arm_move_params = 23;
inline bool MoveParams::_internal_has_arm_move_params() const {
  return params_case() == kArmMoveParams;
}
inline bool MoveParams::has_arm_move_params() const {
  return _internal_has_arm_move_params();
}
inline void MoveParams::set_has_arm_move_params() {
  _impl_._oneof_case_[0] = kArmMoveParams;
}
inline ::bosdyn::api::spot::ArmMoveParams* MoveParams::release_arm_move_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.arm_move_params)
  if (_internal_has_arm_move_params()) {
    clear_has_params();
    ::bosdyn::api::spot::ArmMoveParams* temp = _impl_.params_.arm_move_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.arm_move_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::ArmMoveParams& MoveParams::_internal_arm_move_params() const {
  return _internal_has_arm_move_params()
      ? *_impl_.params_.arm_move_params_
      : reinterpret_cast< ::bosdyn::api::spot::ArmMoveParams&>(::bosdyn::api::spot::_ArmMoveParams_default_instance_);
}
inline const ::bosdyn::api::spot::ArmMoveParams& MoveParams::arm_move_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.arm_move_params)
  return _internal_arm_move_params();
}
inline ::bosdyn::api::spot::ArmMoveParams* MoveParams::unsafe_arena_release_arm_move_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.arm_move_params)
  if (_internal_has_arm_move_params()) {
    clear_has_params();
    ::bosdyn::api::spot::ArmMoveParams* temp = _impl_.params_.arm_move_params_;
    _impl_.params_.arm_move_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_arm_move_params(::bosdyn::api::spot::ArmMoveParams* arm_move_params) {
  clear_params();
  if (arm_move_params) {
    set_has_arm_move_params();
    _impl_.params_.arm_move_params_ = arm_move_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.arm_move_params)
}
inline ::bosdyn::api::spot::ArmMoveParams* MoveParams::_internal_mutable_arm_move_params() {
  if (!_internal_has_arm_move_params()) {
    clear_params();
    set_has_arm_move_params();
    _impl_.params_.arm_move_params_ = CreateMaybeMessage< ::bosdyn::api::spot::ArmMoveParams >(GetArenaForAllocation());
  }
  return _impl_.params_.arm_move_params_;
}
inline ::bosdyn::api::spot::ArmMoveParams* MoveParams::mutable_arm_move_params() {
  ::bosdyn::api::spot::ArmMoveParams* _msg = _internal_mutable_arm_move_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.arm_move_params)
  return _msg;
}

// .bosdyn.api.spot.KneelLegMoveParams kneel_leg_move_params = 24;
inline bool MoveParams::_internal_has_kneel_leg_move_params() const {
  return params_case() == kKneelLegMoveParams;
}
inline bool MoveParams::has_kneel_leg_move_params() const {
  return _internal_has_kneel_leg_move_params();
}
inline void MoveParams::set_has_kneel_leg_move_params() {
  _impl_._oneof_case_[0] = kKneelLegMoveParams;
}
inline ::bosdyn::api::spot::KneelLegMoveParams* MoveParams::release_kneel_leg_move_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.kneel_leg_move_params)
  if (_internal_has_kneel_leg_move_params()) {
    clear_has_params();
    ::bosdyn::api::spot::KneelLegMoveParams* temp = _impl_.params_.kneel_leg_move_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.kneel_leg_move_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::KneelLegMoveParams& MoveParams::_internal_kneel_leg_move_params() const {
  return _internal_has_kneel_leg_move_params()
      ? *_impl_.params_.kneel_leg_move_params_
      : reinterpret_cast< ::bosdyn::api::spot::KneelLegMoveParams&>(::bosdyn::api::spot::_KneelLegMoveParams_default_instance_);
}
inline const ::bosdyn::api::spot::KneelLegMoveParams& MoveParams::kneel_leg_move_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.kneel_leg_move_params)
  return _internal_kneel_leg_move_params();
}
inline ::bosdyn::api::spot::KneelLegMoveParams* MoveParams::unsafe_arena_release_kneel_leg_move_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.kneel_leg_move_params)
  if (_internal_has_kneel_leg_move_params()) {
    clear_has_params();
    ::bosdyn::api::spot::KneelLegMoveParams* temp = _impl_.params_.kneel_leg_move_params_;
    _impl_.params_.kneel_leg_move_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_kneel_leg_move_params(::bosdyn::api::spot::KneelLegMoveParams* kneel_leg_move_params) {
  clear_params();
  if (kneel_leg_move_params) {
    set_has_kneel_leg_move_params();
    _impl_.params_.kneel_leg_move_params_ = kneel_leg_move_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.kneel_leg_move_params)
}
inline ::bosdyn::api::spot::KneelLegMoveParams* MoveParams::_internal_mutable_kneel_leg_move_params() {
  if (!_internal_has_kneel_leg_move_params()) {
    clear_params();
    set_has_kneel_leg_move_params();
    _impl_.params_.kneel_leg_move_params_ = CreateMaybeMessage< ::bosdyn::api::spot::KneelLegMoveParams >(GetArenaForAllocation());
  }
  return _impl_.params_.kneel_leg_move_params_;
}
inline ::bosdyn::api::spot::KneelLegMoveParams* MoveParams::mutable_kneel_leg_move_params() {
  ::bosdyn::api::spot::KneelLegMoveParams* _msg = _internal_mutable_kneel_leg_move_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.kneel_leg_move_params)
  return _msg;
}

// .bosdyn.api.spot.RunningManParams running_man_params = 25;
inline bool MoveParams::_internal_has_running_man_params() const {
  return params_case() == kRunningManParams;
}
inline bool MoveParams::has_running_man_params() const {
  return _internal_has_running_man_params();
}
inline void MoveParams::set_has_running_man_params() {
  _impl_._oneof_case_[0] = kRunningManParams;
}
inline ::bosdyn::api::spot::RunningManParams* MoveParams::release_running_man_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.running_man_params)
  if (_internal_has_running_man_params()) {
    clear_has_params();
    ::bosdyn::api::spot::RunningManParams* temp = _impl_.params_.running_man_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.running_man_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::RunningManParams& MoveParams::_internal_running_man_params() const {
  return _internal_has_running_man_params()
      ? *_impl_.params_.running_man_params_
      : reinterpret_cast< ::bosdyn::api::spot::RunningManParams&>(::bosdyn::api::spot::_RunningManParams_default_instance_);
}
inline const ::bosdyn::api::spot::RunningManParams& MoveParams::running_man_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.running_man_params)
  return _internal_running_man_params();
}
inline ::bosdyn::api::spot::RunningManParams* MoveParams::unsafe_arena_release_running_man_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.running_man_params)
  if (_internal_has_running_man_params()) {
    clear_has_params();
    ::bosdyn::api::spot::RunningManParams* temp = _impl_.params_.running_man_params_;
    _impl_.params_.running_man_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_running_man_params(::bosdyn::api::spot::RunningManParams* running_man_params) {
  clear_params();
  if (running_man_params) {
    set_has_running_man_params();
    _impl_.params_.running_man_params_ = running_man_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.running_man_params)
}
inline ::bosdyn::api::spot::RunningManParams* MoveParams::_internal_mutable_running_man_params() {
  if (!_internal_has_running_man_params()) {
    clear_params();
    set_has_running_man_params();
    _impl_.params_.running_man_params_ = CreateMaybeMessage< ::bosdyn::api::spot::RunningManParams >(GetArenaForAllocation());
  }
  return _impl_.params_.running_man_params_;
}
inline ::bosdyn::api::spot::RunningManParams* MoveParams::mutable_running_man_params() {
  ::bosdyn::api::spot::RunningManParams* _msg = _internal_mutable_running_man_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.running_man_params)
  return _msg;
}

// .bosdyn.api.spot.KneelCircleParams kneel_circle_params = 26;
inline bool MoveParams::_internal_has_kneel_circle_params() const {
  return params_case() == kKneelCircleParams;
}
inline bool MoveParams::has_kneel_circle_params() const {
  return _internal_has_kneel_circle_params();
}
inline void MoveParams::set_has_kneel_circle_params() {
  _impl_._oneof_case_[0] = kKneelCircleParams;
}
inline ::bosdyn::api::spot::KneelCircleParams* MoveParams::release_kneel_circle_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.kneel_circle_params)
  if (_internal_has_kneel_circle_params()) {
    clear_has_params();
    ::bosdyn::api::spot::KneelCircleParams* temp = _impl_.params_.kneel_circle_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.kneel_circle_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::KneelCircleParams& MoveParams::_internal_kneel_circle_params() const {
  return _internal_has_kneel_circle_params()
      ? *_impl_.params_.kneel_circle_params_
      : reinterpret_cast< ::bosdyn::api::spot::KneelCircleParams&>(::bosdyn::api::spot::_KneelCircleParams_default_instance_);
}
inline const ::bosdyn::api::spot::KneelCircleParams& MoveParams::kneel_circle_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.kneel_circle_params)
  return _internal_kneel_circle_params();
}
inline ::bosdyn::api::spot::KneelCircleParams* MoveParams::unsafe_arena_release_kneel_circle_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.kneel_circle_params)
  if (_internal_has_kneel_circle_params()) {
    clear_has_params();
    ::bosdyn::api::spot::KneelCircleParams* temp = _impl_.params_.kneel_circle_params_;
    _impl_.params_.kneel_circle_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_kneel_circle_params(::bosdyn::api::spot::KneelCircleParams* kneel_circle_params) {
  clear_params();
  if (kneel_circle_params) {
    set_has_kneel_circle_params();
    _impl_.params_.kneel_circle_params_ = kneel_circle_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.kneel_circle_params)
}
inline ::bosdyn::api::spot::KneelCircleParams* MoveParams::_internal_mutable_kneel_circle_params() {
  if (!_internal_has_kneel_circle_params()) {
    clear_params();
    set_has_kneel_circle_params();
    _impl_.params_.kneel_circle_params_ = CreateMaybeMessage< ::bosdyn::api::spot::KneelCircleParams >(GetArenaForAllocation());
  }
  return _impl_.params_.kneel_circle_params_;
}
inline ::bosdyn::api::spot::KneelCircleParams* MoveParams::mutable_kneel_circle_params() {
  ::bosdyn::api::spot::KneelCircleParams* _msg = _internal_mutable_kneel_circle_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.kneel_circle_params)
  return _msg;
}

// .bosdyn.api.spot.GripperParams gripper_params = 27;
inline bool MoveParams::_internal_has_gripper_params() const {
  return params_case() == kGripperParams;
}
inline bool MoveParams::has_gripper_params() const {
  return _internal_has_gripper_params();
}
inline void MoveParams::set_has_gripper_params() {
  _impl_._oneof_case_[0] = kGripperParams;
}
inline ::bosdyn::api::spot::GripperParams* MoveParams::release_gripper_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.gripper_params)
  if (_internal_has_gripper_params()) {
    clear_has_params();
    ::bosdyn::api::spot::GripperParams* temp = _impl_.params_.gripper_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.gripper_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::GripperParams& MoveParams::_internal_gripper_params() const {
  return _internal_has_gripper_params()
      ? *_impl_.params_.gripper_params_
      : reinterpret_cast< ::bosdyn::api::spot::GripperParams&>(::bosdyn::api::spot::_GripperParams_default_instance_);
}
inline const ::bosdyn::api::spot::GripperParams& MoveParams::gripper_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.gripper_params)
  return _internal_gripper_params();
}
inline ::bosdyn::api::spot::GripperParams* MoveParams::unsafe_arena_release_gripper_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.gripper_params)
  if (_internal_has_gripper_params()) {
    clear_has_params();
    ::bosdyn::api::spot::GripperParams* temp = _impl_.params_.gripper_params_;
    _impl_.params_.gripper_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_gripper_params(::bosdyn::api::spot::GripperParams* gripper_params) {
  clear_params();
  if (gripper_params) {
    set_has_gripper_params();
    _impl_.params_.gripper_params_ = gripper_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.gripper_params)
}
inline ::bosdyn::api::spot::GripperParams* MoveParams::_internal_mutable_gripper_params() {
  if (!_internal_has_gripper_params()) {
    clear_params();
    set_has_gripper_params();
    _impl_.params_.gripper_params_ = CreateMaybeMessage< ::bosdyn::api::spot::GripperParams >(GetArenaForAllocation());
  }
  return _impl_.params_.gripper_params_;
}
inline ::bosdyn::api::spot::GripperParams* MoveParams::mutable_gripper_params() {
  ::bosdyn::api::spot::GripperParams* _msg = _internal_mutable_gripper_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.gripper_params)
  return _msg;
}

// .bosdyn.api.spot.HopParams hop_params = 28;
inline bool MoveParams::_internal_has_hop_params() const {
  return params_case() == kHopParams;
}
inline bool MoveParams::has_hop_params() const {
  return _internal_has_hop_params();
}
inline void MoveParams::set_has_hop_params() {
  _impl_._oneof_case_[0] = kHopParams;
}
inline ::bosdyn::api::spot::HopParams* MoveParams::release_hop_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.hop_params)
  if (_internal_has_hop_params()) {
    clear_has_params();
    ::bosdyn::api::spot::HopParams* temp = _impl_.params_.hop_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.hop_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::HopParams& MoveParams::_internal_hop_params() const {
  return _internal_has_hop_params()
      ? *_impl_.params_.hop_params_
      : reinterpret_cast< ::bosdyn::api::spot::HopParams&>(::bosdyn::api::spot::_HopParams_default_instance_);
}
inline const ::bosdyn::api::spot::HopParams& MoveParams::hop_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.hop_params)
  return _internal_hop_params();
}
inline ::bosdyn::api::spot::HopParams* MoveParams::unsafe_arena_release_hop_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.hop_params)
  if (_internal_has_hop_params()) {
    clear_has_params();
    ::bosdyn::api::spot::HopParams* temp = _impl_.params_.hop_params_;
    _impl_.params_.hop_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_hop_params(::bosdyn::api::spot::HopParams* hop_params) {
  clear_params();
  if (hop_params) {
    set_has_hop_params();
    _impl_.params_.hop_params_ = hop_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.hop_params)
}
inline ::bosdyn::api::spot::HopParams* MoveParams::_internal_mutable_hop_params() {
  if (!_internal_has_hop_params()) {
    clear_params();
    set_has_hop_params();
    _impl_.params_.hop_params_ = CreateMaybeMessage< ::bosdyn::api::spot::HopParams >(GetArenaForAllocation());
  }
  return _impl_.params_.hop_params_;
}
inline ::bosdyn::api::spot::HopParams* MoveParams::mutable_hop_params() {
  ::bosdyn::api::spot::HopParams* _msg = _internal_mutable_hop_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.hop_params)
  return _msg;
}

// .bosdyn.api.spot.RandomRotateParams random_rotate_params = 29;
inline bool MoveParams::_internal_has_random_rotate_params() const {
  return params_case() == kRandomRotateParams;
}
inline bool MoveParams::has_random_rotate_params() const {
  return _internal_has_random_rotate_params();
}
inline void MoveParams::set_has_random_rotate_params() {
  _impl_._oneof_case_[0] = kRandomRotateParams;
}
inline ::bosdyn::api::spot::RandomRotateParams* MoveParams::release_random_rotate_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.random_rotate_params)
  if (_internal_has_random_rotate_params()) {
    clear_has_params();
    ::bosdyn::api::spot::RandomRotateParams* temp = _impl_.params_.random_rotate_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.random_rotate_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::RandomRotateParams& MoveParams::_internal_random_rotate_params() const {
  return _internal_has_random_rotate_params()
      ? *_impl_.params_.random_rotate_params_
      : reinterpret_cast< ::bosdyn::api::spot::RandomRotateParams&>(::bosdyn::api::spot::_RandomRotateParams_default_instance_);
}
inline const ::bosdyn::api::spot::RandomRotateParams& MoveParams::random_rotate_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.random_rotate_params)
  return _internal_random_rotate_params();
}
inline ::bosdyn::api::spot::RandomRotateParams* MoveParams::unsafe_arena_release_random_rotate_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.random_rotate_params)
  if (_internal_has_random_rotate_params()) {
    clear_has_params();
    ::bosdyn::api::spot::RandomRotateParams* temp = _impl_.params_.random_rotate_params_;
    _impl_.params_.random_rotate_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_random_rotate_params(::bosdyn::api::spot::RandomRotateParams* random_rotate_params) {
  clear_params();
  if (random_rotate_params) {
    set_has_random_rotate_params();
    _impl_.params_.random_rotate_params_ = random_rotate_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.random_rotate_params)
}
inline ::bosdyn::api::spot::RandomRotateParams* MoveParams::_internal_mutable_random_rotate_params() {
  if (!_internal_has_random_rotate_params()) {
    clear_params();
    set_has_random_rotate_params();
    _impl_.params_.random_rotate_params_ = CreateMaybeMessage< ::bosdyn::api::spot::RandomRotateParams >(GetArenaForAllocation());
  }
  return _impl_.params_.random_rotate_params_;
}
inline ::bosdyn::api::spot::RandomRotateParams* MoveParams::mutable_random_rotate_params() {
  ::bosdyn::api::spot::RandomRotateParams* _msg = _internal_mutable_random_rotate_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.random_rotate_params)
  return _msg;
}

// .bosdyn.api.spot.CrawlParams crawl_params = 30;
inline bool MoveParams::_internal_has_crawl_params() const {
  return params_case() == kCrawlParams;
}
inline bool MoveParams::has_crawl_params() const {
  return _internal_has_crawl_params();
}
inline void MoveParams::set_has_crawl_params() {
  _impl_._oneof_case_[0] = kCrawlParams;
}
inline ::bosdyn::api::spot::CrawlParams* MoveParams::release_crawl_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.crawl_params)
  if (_internal_has_crawl_params()) {
    clear_has_params();
    ::bosdyn::api::spot::CrawlParams* temp = _impl_.params_.crawl_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.crawl_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::CrawlParams& MoveParams::_internal_crawl_params() const {
  return _internal_has_crawl_params()
      ? *_impl_.params_.crawl_params_
      : reinterpret_cast< ::bosdyn::api::spot::CrawlParams&>(::bosdyn::api::spot::_CrawlParams_default_instance_);
}
inline const ::bosdyn::api::spot::CrawlParams& MoveParams::crawl_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.crawl_params)
  return _internal_crawl_params();
}
inline ::bosdyn::api::spot::CrawlParams* MoveParams::unsafe_arena_release_crawl_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.crawl_params)
  if (_internal_has_crawl_params()) {
    clear_has_params();
    ::bosdyn::api::spot::CrawlParams* temp = _impl_.params_.crawl_params_;
    _impl_.params_.crawl_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_crawl_params(::bosdyn::api::spot::CrawlParams* crawl_params) {
  clear_params();
  if (crawl_params) {
    set_has_crawl_params();
    _impl_.params_.crawl_params_ = crawl_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.crawl_params)
}
inline ::bosdyn::api::spot::CrawlParams* MoveParams::_internal_mutable_crawl_params() {
  if (!_internal_has_crawl_params()) {
    clear_params();
    set_has_crawl_params();
    _impl_.params_.crawl_params_ = CreateMaybeMessage< ::bosdyn::api::spot::CrawlParams >(GetArenaForAllocation());
  }
  return _impl_.params_.crawl_params_;
}
inline ::bosdyn::api::spot::CrawlParams* MoveParams::mutable_crawl_params() {
  ::bosdyn::api::spot::CrawlParams* _msg = _internal_mutable_crawl_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.crawl_params)
  return _msg;
}

// .bosdyn.api.spot.SideParams side_params = 31;
inline bool MoveParams::_internal_has_side_params() const {
  return params_case() == kSideParams;
}
inline bool MoveParams::has_side_params() const {
  return _internal_has_side_params();
}
inline void MoveParams::set_has_side_params() {
  _impl_._oneof_case_[0] = kSideParams;
}
inline ::bosdyn::api::spot::SideParams* MoveParams::release_side_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.side_params)
  if (_internal_has_side_params()) {
    clear_has_params();
    ::bosdyn::api::spot::SideParams* temp = _impl_.params_.side_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.side_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::SideParams& MoveParams::_internal_side_params() const {
  return _internal_has_side_params()
      ? *_impl_.params_.side_params_
      : reinterpret_cast< ::bosdyn::api::spot::SideParams&>(::bosdyn::api::spot::_SideParams_default_instance_);
}
inline const ::bosdyn::api::spot::SideParams& MoveParams::side_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.side_params)
  return _internal_side_params();
}
inline ::bosdyn::api::spot::SideParams* MoveParams::unsafe_arena_release_side_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.side_params)
  if (_internal_has_side_params()) {
    clear_has_params();
    ::bosdyn::api::spot::SideParams* temp = _impl_.params_.side_params_;
    _impl_.params_.side_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_side_params(::bosdyn::api::spot::SideParams* side_params) {
  clear_params();
  if (side_params) {
    set_has_side_params();
    _impl_.params_.side_params_ = side_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.side_params)
}
inline ::bosdyn::api::spot::SideParams* MoveParams::_internal_mutable_side_params() {
  if (!_internal_has_side_params()) {
    clear_params();
    set_has_side_params();
    _impl_.params_.side_params_ = CreateMaybeMessage< ::bosdyn::api::spot::SideParams >(GetArenaForAllocation());
  }
  return _impl_.params_.side_params_;
}
inline ::bosdyn::api::spot::SideParams* MoveParams::mutable_side_params() {
  ::bosdyn::api::spot::SideParams* _msg = _internal_mutable_side_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.side_params)
  return _msg;
}

// .bosdyn.api.spot.BourreeParams bourree_params = 32;
inline bool MoveParams::_internal_has_bourree_params() const {
  return params_case() == kBourreeParams;
}
inline bool MoveParams::has_bourree_params() const {
  return _internal_has_bourree_params();
}
inline void MoveParams::set_has_bourree_params() {
  _impl_._oneof_case_[0] = kBourreeParams;
}
inline ::bosdyn::api::spot::BourreeParams* MoveParams::release_bourree_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.bourree_params)
  if (_internal_has_bourree_params()) {
    clear_has_params();
    ::bosdyn::api::spot::BourreeParams* temp = _impl_.params_.bourree_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.bourree_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::BourreeParams& MoveParams::_internal_bourree_params() const {
  return _internal_has_bourree_params()
      ? *_impl_.params_.bourree_params_
      : reinterpret_cast< ::bosdyn::api::spot::BourreeParams&>(::bosdyn::api::spot::_BourreeParams_default_instance_);
}
inline const ::bosdyn::api::spot::BourreeParams& MoveParams::bourree_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.bourree_params)
  return _internal_bourree_params();
}
inline ::bosdyn::api::spot::BourreeParams* MoveParams::unsafe_arena_release_bourree_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.bourree_params)
  if (_internal_has_bourree_params()) {
    clear_has_params();
    ::bosdyn::api::spot::BourreeParams* temp = _impl_.params_.bourree_params_;
    _impl_.params_.bourree_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_bourree_params(::bosdyn::api::spot::BourreeParams* bourree_params) {
  clear_params();
  if (bourree_params) {
    set_has_bourree_params();
    _impl_.params_.bourree_params_ = bourree_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.bourree_params)
}
inline ::bosdyn::api::spot::BourreeParams* MoveParams::_internal_mutable_bourree_params() {
  if (!_internal_has_bourree_params()) {
    clear_params();
    set_has_bourree_params();
    _impl_.params_.bourree_params_ = CreateMaybeMessage< ::bosdyn::api::spot::BourreeParams >(GetArenaForAllocation());
  }
  return _impl_.params_.bourree_params_;
}
inline ::bosdyn::api::spot::BourreeParams* MoveParams::mutable_bourree_params() {
  ::bosdyn::api::spot::BourreeParams* _msg = _internal_mutable_bourree_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.bourree_params)
  return _msg;
}

// .bosdyn.api.spot.WorkspaceArmMoveParams workspace_arm_move_params = 33;
inline bool MoveParams::_internal_has_workspace_arm_move_params() const {
  return params_case() == kWorkspaceArmMoveParams;
}
inline bool MoveParams::has_workspace_arm_move_params() const {
  return _internal_has_workspace_arm_move_params();
}
inline void MoveParams::set_has_workspace_arm_move_params() {
  _impl_._oneof_case_[0] = kWorkspaceArmMoveParams;
}
inline ::bosdyn::api::spot::WorkspaceArmMoveParams* MoveParams::release_workspace_arm_move_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.workspace_arm_move_params)
  if (_internal_has_workspace_arm_move_params()) {
    clear_has_params();
    ::bosdyn::api::spot::WorkspaceArmMoveParams* temp = _impl_.params_.workspace_arm_move_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.workspace_arm_move_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::WorkspaceArmMoveParams& MoveParams::_internal_workspace_arm_move_params() const {
  return _internal_has_workspace_arm_move_params()
      ? *_impl_.params_.workspace_arm_move_params_
      : reinterpret_cast< ::bosdyn::api::spot::WorkspaceArmMoveParams&>(::bosdyn::api::spot::_WorkspaceArmMoveParams_default_instance_);
}
inline const ::bosdyn::api::spot::WorkspaceArmMoveParams& MoveParams::workspace_arm_move_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.workspace_arm_move_params)
  return _internal_workspace_arm_move_params();
}
inline ::bosdyn::api::spot::WorkspaceArmMoveParams* MoveParams::unsafe_arena_release_workspace_arm_move_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.workspace_arm_move_params)
  if (_internal_has_workspace_arm_move_params()) {
    clear_has_params();
    ::bosdyn::api::spot::WorkspaceArmMoveParams* temp = _impl_.params_.workspace_arm_move_params_;
    _impl_.params_.workspace_arm_move_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_workspace_arm_move_params(::bosdyn::api::spot::WorkspaceArmMoveParams* workspace_arm_move_params) {
  clear_params();
  if (workspace_arm_move_params) {
    set_has_workspace_arm_move_params();
    _impl_.params_.workspace_arm_move_params_ = workspace_arm_move_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.workspace_arm_move_params)
}
inline ::bosdyn::api::spot::WorkspaceArmMoveParams* MoveParams::_internal_mutable_workspace_arm_move_params() {
  if (!_internal_has_workspace_arm_move_params()) {
    clear_params();
    set_has_workspace_arm_move_params();
    _impl_.params_.workspace_arm_move_params_ = CreateMaybeMessage< ::bosdyn::api::spot::WorkspaceArmMoveParams >(GetArenaForAllocation());
  }
  return _impl_.params_.workspace_arm_move_params_;
}
inline ::bosdyn::api::spot::WorkspaceArmMoveParams* MoveParams::mutable_workspace_arm_move_params() {
  ::bosdyn::api::spot::WorkspaceArmMoveParams* _msg = _internal_mutable_workspace_arm_move_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.workspace_arm_move_params)
  return _msg;
}

// .bosdyn.api.spot.Figure8Params figure8_params = 34;
inline bool MoveParams::_internal_has_figure8_params() const {
  return params_case() == kFigure8Params;
}
inline bool MoveParams::has_figure8_params() const {
  return _internal_has_figure8_params();
}
inline void MoveParams::set_has_figure8_params() {
  _impl_._oneof_case_[0] = kFigure8Params;
}
inline ::bosdyn::api::spot::Figure8Params* MoveParams::release_figure8_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.figure8_params)
  if (_internal_has_figure8_params()) {
    clear_has_params();
    ::bosdyn::api::spot::Figure8Params* temp = _impl_.params_.figure8_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.figure8_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::Figure8Params& MoveParams::_internal_figure8_params() const {
  return _internal_has_figure8_params()
      ? *_impl_.params_.figure8_params_
      : reinterpret_cast< ::bosdyn::api::spot::Figure8Params&>(::bosdyn::api::spot::_Figure8Params_default_instance_);
}
inline const ::bosdyn::api::spot::Figure8Params& MoveParams::figure8_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.figure8_params)
  return _internal_figure8_params();
}
inline ::bosdyn::api::spot::Figure8Params* MoveParams::unsafe_arena_release_figure8_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.figure8_params)
  if (_internal_has_figure8_params()) {
    clear_has_params();
    ::bosdyn::api::spot::Figure8Params* temp = _impl_.params_.figure8_params_;
    _impl_.params_.figure8_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_figure8_params(::bosdyn::api::spot::Figure8Params* figure8_params) {
  clear_params();
  if (figure8_params) {
    set_has_figure8_params();
    _impl_.params_.figure8_params_ = figure8_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.figure8_params)
}
inline ::bosdyn::api::spot::Figure8Params* MoveParams::_internal_mutable_figure8_params() {
  if (!_internal_has_figure8_params()) {
    clear_params();
    set_has_figure8_params();
    _impl_.params_.figure8_params_ = CreateMaybeMessage< ::bosdyn::api::spot::Figure8Params >(GetArenaForAllocation());
  }
  return _impl_.params_.figure8_params_;
}
inline ::bosdyn::api::spot::Figure8Params* MoveParams::mutable_figure8_params() {
  ::bosdyn::api::spot::Figure8Params* _msg = _internal_mutable_figure8_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.figure8_params)
  return _msg;
}

// .bosdyn.api.spot.KneelLegMove2Params kneel_leg_move2_params = 35;
inline bool MoveParams::_internal_has_kneel_leg_move2_params() const {
  return params_case() == kKneelLegMove2Params;
}
inline bool MoveParams::has_kneel_leg_move2_params() const {
  return _internal_has_kneel_leg_move2_params();
}
inline void MoveParams::set_has_kneel_leg_move2_params() {
  _impl_._oneof_case_[0] = kKneelLegMove2Params;
}
inline ::bosdyn::api::spot::KneelLegMove2Params* MoveParams::release_kneel_leg_move2_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.kneel_leg_move2_params)
  if (_internal_has_kneel_leg_move2_params()) {
    clear_has_params();
    ::bosdyn::api::spot::KneelLegMove2Params* temp = _impl_.params_.kneel_leg_move2_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.kneel_leg_move2_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::KneelLegMove2Params& MoveParams::_internal_kneel_leg_move2_params() const {
  return _internal_has_kneel_leg_move2_params()
      ? *_impl_.params_.kneel_leg_move2_params_
      : reinterpret_cast< ::bosdyn::api::spot::KneelLegMove2Params&>(::bosdyn::api::spot::_KneelLegMove2Params_default_instance_);
}
inline const ::bosdyn::api::spot::KneelLegMove2Params& MoveParams::kneel_leg_move2_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.kneel_leg_move2_params)
  return _internal_kneel_leg_move2_params();
}
inline ::bosdyn::api::spot::KneelLegMove2Params* MoveParams::unsafe_arena_release_kneel_leg_move2_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.kneel_leg_move2_params)
  if (_internal_has_kneel_leg_move2_params()) {
    clear_has_params();
    ::bosdyn::api::spot::KneelLegMove2Params* temp = _impl_.params_.kneel_leg_move2_params_;
    _impl_.params_.kneel_leg_move2_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_kneel_leg_move2_params(::bosdyn::api::spot::KneelLegMove2Params* kneel_leg_move2_params) {
  clear_params();
  if (kneel_leg_move2_params) {
    set_has_kneel_leg_move2_params();
    _impl_.params_.kneel_leg_move2_params_ = kneel_leg_move2_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.kneel_leg_move2_params)
}
inline ::bosdyn::api::spot::KneelLegMove2Params* MoveParams::_internal_mutable_kneel_leg_move2_params() {
  if (!_internal_has_kneel_leg_move2_params()) {
    clear_params();
    set_has_kneel_leg_move2_params();
    _impl_.params_.kneel_leg_move2_params_ = CreateMaybeMessage< ::bosdyn::api::spot::KneelLegMove2Params >(GetArenaForAllocation());
  }
  return _impl_.params_.kneel_leg_move2_params_;
}
inline ::bosdyn::api::spot::KneelLegMove2Params* MoveParams::mutable_kneel_leg_move2_params() {
  ::bosdyn::api::spot::KneelLegMove2Params* _msg = _internal_mutable_kneel_leg_move2_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.kneel_leg_move2_params)
  return _msg;
}

// .bosdyn.api.spot.FidgetStandParams fidget_stand_params = 36;
inline bool MoveParams::_internal_has_fidget_stand_params() const {
  return params_case() == kFidgetStandParams;
}
inline bool MoveParams::has_fidget_stand_params() const {
  return _internal_has_fidget_stand_params();
}
inline void MoveParams::set_has_fidget_stand_params() {
  _impl_._oneof_case_[0] = kFidgetStandParams;
}
inline ::bosdyn::api::spot::FidgetStandParams* MoveParams::release_fidget_stand_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.fidget_stand_params)
  if (_internal_has_fidget_stand_params()) {
    clear_has_params();
    ::bosdyn::api::spot::FidgetStandParams* temp = _impl_.params_.fidget_stand_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.fidget_stand_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::FidgetStandParams& MoveParams::_internal_fidget_stand_params() const {
  return _internal_has_fidget_stand_params()
      ? *_impl_.params_.fidget_stand_params_
      : reinterpret_cast< ::bosdyn::api::spot::FidgetStandParams&>(::bosdyn::api::spot::_FidgetStandParams_default_instance_);
}
inline const ::bosdyn::api::spot::FidgetStandParams& MoveParams::fidget_stand_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.fidget_stand_params)
  return _internal_fidget_stand_params();
}
inline ::bosdyn::api::spot::FidgetStandParams* MoveParams::unsafe_arena_release_fidget_stand_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.fidget_stand_params)
  if (_internal_has_fidget_stand_params()) {
    clear_has_params();
    ::bosdyn::api::spot::FidgetStandParams* temp = _impl_.params_.fidget_stand_params_;
    _impl_.params_.fidget_stand_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_fidget_stand_params(::bosdyn::api::spot::FidgetStandParams* fidget_stand_params) {
  clear_params();
  if (fidget_stand_params) {
    set_has_fidget_stand_params();
    _impl_.params_.fidget_stand_params_ = fidget_stand_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.fidget_stand_params)
}
inline ::bosdyn::api::spot::FidgetStandParams* MoveParams::_internal_mutable_fidget_stand_params() {
  if (!_internal_has_fidget_stand_params()) {
    clear_params();
    set_has_fidget_stand_params();
    _impl_.params_.fidget_stand_params_ = CreateMaybeMessage< ::bosdyn::api::spot::FidgetStandParams >(GetArenaForAllocation());
  }
  return _impl_.params_.fidget_stand_params_;
}
inline ::bosdyn::api::spot::FidgetStandParams* MoveParams::mutable_fidget_stand_params() {
  ::bosdyn::api::spot::FidgetStandParams* _msg = _internal_mutable_fidget_stand_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.fidget_stand_params)
  return _msg;
}

// .bosdyn.api.spot.GotoParams goto_params = 37;
inline bool MoveParams::_internal_has_goto_params() const {
  return params_case() == kGotoParams;
}
inline bool MoveParams::has_goto_params() const {
  return _internal_has_goto_params();
}
inline void MoveParams::set_has_goto_params() {
  _impl_._oneof_case_[0] = kGotoParams;
}
inline ::bosdyn::api::spot::GotoParams* MoveParams::release_goto_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.goto_params)
  if (_internal_has_goto_params()) {
    clear_has_params();
    ::bosdyn::api::spot::GotoParams* temp = _impl_.params_.goto_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.goto_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::GotoParams& MoveParams::_internal_goto_params() const {
  return _internal_has_goto_params()
      ? *_impl_.params_.goto_params_
      : reinterpret_cast< ::bosdyn::api::spot::GotoParams&>(::bosdyn::api::spot::_GotoParams_default_instance_);
}
inline const ::bosdyn::api::spot::GotoParams& MoveParams::goto_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.goto_params)
  return _internal_goto_params();
}
inline ::bosdyn::api::spot::GotoParams* MoveParams::unsafe_arena_release_goto_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.goto_params)
  if (_internal_has_goto_params()) {
    clear_has_params();
    ::bosdyn::api::spot::GotoParams* temp = _impl_.params_.goto_params_;
    _impl_.params_.goto_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_goto_params(::bosdyn::api::spot::GotoParams* goto_params) {
  clear_params();
  if (goto_params) {
    set_has_goto_params();
    _impl_.params_.goto_params_ = goto_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.goto_params)
}
inline ::bosdyn::api::spot::GotoParams* MoveParams::_internal_mutable_goto_params() {
  if (!_internal_has_goto_params()) {
    clear_params();
    set_has_goto_params();
    _impl_.params_.goto_params_ = CreateMaybeMessage< ::bosdyn::api::spot::GotoParams >(GetArenaForAllocation());
  }
  return _impl_.params_.goto_params_;
}
inline ::bosdyn::api::spot::GotoParams* MoveParams::mutable_goto_params() {
  ::bosdyn::api::spot::GotoParams* _msg = _internal_mutable_goto_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.goto_params)
  return _msg;
}

// .bosdyn.api.spot.FrameSnapshotParams frame_snapshot_params = 38;
inline bool MoveParams::_internal_has_frame_snapshot_params() const {
  return params_case() == kFrameSnapshotParams;
}
inline bool MoveParams::has_frame_snapshot_params() const {
  return _internal_has_frame_snapshot_params();
}
inline void MoveParams::set_has_frame_snapshot_params() {
  _impl_._oneof_case_[0] = kFrameSnapshotParams;
}
inline ::bosdyn::api::spot::FrameSnapshotParams* MoveParams::release_frame_snapshot_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.frame_snapshot_params)
  if (_internal_has_frame_snapshot_params()) {
    clear_has_params();
    ::bosdyn::api::spot::FrameSnapshotParams* temp = _impl_.params_.frame_snapshot_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.frame_snapshot_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::FrameSnapshotParams& MoveParams::_internal_frame_snapshot_params() const {
  return _internal_has_frame_snapshot_params()
      ? *_impl_.params_.frame_snapshot_params_
      : reinterpret_cast< ::bosdyn::api::spot::FrameSnapshotParams&>(::bosdyn::api::spot::_FrameSnapshotParams_default_instance_);
}
inline const ::bosdyn::api::spot::FrameSnapshotParams& MoveParams::frame_snapshot_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.frame_snapshot_params)
  return _internal_frame_snapshot_params();
}
inline ::bosdyn::api::spot::FrameSnapshotParams* MoveParams::unsafe_arena_release_frame_snapshot_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.frame_snapshot_params)
  if (_internal_has_frame_snapshot_params()) {
    clear_has_params();
    ::bosdyn::api::spot::FrameSnapshotParams* temp = _impl_.params_.frame_snapshot_params_;
    _impl_.params_.frame_snapshot_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_frame_snapshot_params(::bosdyn::api::spot::FrameSnapshotParams* frame_snapshot_params) {
  clear_params();
  if (frame_snapshot_params) {
    set_has_frame_snapshot_params();
    _impl_.params_.frame_snapshot_params_ = frame_snapshot_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.frame_snapshot_params)
}
inline ::bosdyn::api::spot::FrameSnapshotParams* MoveParams::_internal_mutable_frame_snapshot_params() {
  if (!_internal_has_frame_snapshot_params()) {
    clear_params();
    set_has_frame_snapshot_params();
    _impl_.params_.frame_snapshot_params_ = CreateMaybeMessage< ::bosdyn::api::spot::FrameSnapshotParams >(GetArenaForAllocation());
  }
  return _impl_.params_.frame_snapshot_params_;
}
inline ::bosdyn::api::spot::FrameSnapshotParams* MoveParams::mutable_frame_snapshot_params() {
  ::bosdyn::api::spot::FrameSnapshotParams* _msg = _internal_mutable_frame_snapshot_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.frame_snapshot_params)
  return _msg;
}

// .bosdyn.api.spot.SetColorParams set_color_params = 39;
inline bool MoveParams::_internal_has_set_color_params() const {
  return params_case() == kSetColorParams;
}
inline bool MoveParams::has_set_color_params() const {
  return _internal_has_set_color_params();
}
inline void MoveParams::set_has_set_color_params() {
  _impl_._oneof_case_[0] = kSetColorParams;
}
inline ::bosdyn::api::spot::SetColorParams* MoveParams::release_set_color_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.set_color_params)
  if (_internal_has_set_color_params()) {
    clear_has_params();
    ::bosdyn::api::spot::SetColorParams* temp = _impl_.params_.set_color_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.set_color_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::SetColorParams& MoveParams::_internal_set_color_params() const {
  return _internal_has_set_color_params()
      ? *_impl_.params_.set_color_params_
      : reinterpret_cast< ::bosdyn::api::spot::SetColorParams&>(::bosdyn::api::spot::_SetColorParams_default_instance_);
}
inline const ::bosdyn::api::spot::SetColorParams& MoveParams::set_color_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.set_color_params)
  return _internal_set_color_params();
}
inline ::bosdyn::api::spot::SetColorParams* MoveParams::unsafe_arena_release_set_color_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.set_color_params)
  if (_internal_has_set_color_params()) {
    clear_has_params();
    ::bosdyn::api::spot::SetColorParams* temp = _impl_.params_.set_color_params_;
    _impl_.params_.set_color_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_set_color_params(::bosdyn::api::spot::SetColorParams* set_color_params) {
  clear_params();
  if (set_color_params) {
    set_has_set_color_params();
    _impl_.params_.set_color_params_ = set_color_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.set_color_params)
}
inline ::bosdyn::api::spot::SetColorParams* MoveParams::_internal_mutable_set_color_params() {
  if (!_internal_has_set_color_params()) {
    clear_params();
    set_has_set_color_params();
    _impl_.params_.set_color_params_ = CreateMaybeMessage< ::bosdyn::api::spot::SetColorParams >(GetArenaForAllocation());
  }
  return _impl_.params_.set_color_params_;
}
inline ::bosdyn::api::spot::SetColorParams* MoveParams::mutable_set_color_params() {
  ::bosdyn::api::spot::SetColorParams* _msg = _internal_mutable_set_color_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.set_color_params)
  return _msg;
}

// .bosdyn.api.spot.RippleColorParams ripple_color_params = 40;
inline bool MoveParams::_internal_has_ripple_color_params() const {
  return params_case() == kRippleColorParams;
}
inline bool MoveParams::has_ripple_color_params() const {
  return _internal_has_ripple_color_params();
}
inline void MoveParams::set_has_ripple_color_params() {
  _impl_._oneof_case_[0] = kRippleColorParams;
}
inline ::bosdyn::api::spot::RippleColorParams* MoveParams::release_ripple_color_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.ripple_color_params)
  if (_internal_has_ripple_color_params()) {
    clear_has_params();
    ::bosdyn::api::spot::RippleColorParams* temp = _impl_.params_.ripple_color_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.ripple_color_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::RippleColorParams& MoveParams::_internal_ripple_color_params() const {
  return _internal_has_ripple_color_params()
      ? *_impl_.params_.ripple_color_params_
      : reinterpret_cast< ::bosdyn::api::spot::RippleColorParams&>(::bosdyn::api::spot::_RippleColorParams_default_instance_);
}
inline const ::bosdyn::api::spot::RippleColorParams& MoveParams::ripple_color_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.ripple_color_params)
  return _internal_ripple_color_params();
}
inline ::bosdyn::api::spot::RippleColorParams* MoveParams::unsafe_arena_release_ripple_color_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.ripple_color_params)
  if (_internal_has_ripple_color_params()) {
    clear_has_params();
    ::bosdyn::api::spot::RippleColorParams* temp = _impl_.params_.ripple_color_params_;
    _impl_.params_.ripple_color_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_ripple_color_params(::bosdyn::api::spot::RippleColorParams* ripple_color_params) {
  clear_params();
  if (ripple_color_params) {
    set_has_ripple_color_params();
    _impl_.params_.ripple_color_params_ = ripple_color_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.ripple_color_params)
}
inline ::bosdyn::api::spot::RippleColorParams* MoveParams::_internal_mutable_ripple_color_params() {
  if (!_internal_has_ripple_color_params()) {
    clear_params();
    set_has_ripple_color_params();
    _impl_.params_.ripple_color_params_ = CreateMaybeMessage< ::bosdyn::api::spot::RippleColorParams >(GetArenaForAllocation());
  }
  return _impl_.params_.ripple_color_params_;
}
inline ::bosdyn::api::spot::RippleColorParams* MoveParams::mutable_ripple_color_params() {
  ::bosdyn::api::spot::RippleColorParams* _msg = _internal_mutable_ripple_color_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.ripple_color_params)
  return _msg;
}

// .bosdyn.api.spot.FadeColorParams fade_color_params = 41;
inline bool MoveParams::_internal_has_fade_color_params() const {
  return params_case() == kFadeColorParams;
}
inline bool MoveParams::has_fade_color_params() const {
  return _internal_has_fade_color_params();
}
inline void MoveParams::set_has_fade_color_params() {
  _impl_._oneof_case_[0] = kFadeColorParams;
}
inline ::bosdyn::api::spot::FadeColorParams* MoveParams::release_fade_color_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.fade_color_params)
  if (_internal_has_fade_color_params()) {
    clear_has_params();
    ::bosdyn::api::spot::FadeColorParams* temp = _impl_.params_.fade_color_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.fade_color_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::FadeColorParams& MoveParams::_internal_fade_color_params() const {
  return _internal_has_fade_color_params()
      ? *_impl_.params_.fade_color_params_
      : reinterpret_cast< ::bosdyn::api::spot::FadeColorParams&>(::bosdyn::api::spot::_FadeColorParams_default_instance_);
}
inline const ::bosdyn::api::spot::FadeColorParams& MoveParams::fade_color_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.fade_color_params)
  return _internal_fade_color_params();
}
inline ::bosdyn::api::spot::FadeColorParams* MoveParams::unsafe_arena_release_fade_color_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.fade_color_params)
  if (_internal_has_fade_color_params()) {
    clear_has_params();
    ::bosdyn::api::spot::FadeColorParams* temp = _impl_.params_.fade_color_params_;
    _impl_.params_.fade_color_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_fade_color_params(::bosdyn::api::spot::FadeColorParams* fade_color_params) {
  clear_params();
  if (fade_color_params) {
    set_has_fade_color_params();
    _impl_.params_.fade_color_params_ = fade_color_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.fade_color_params)
}
inline ::bosdyn::api::spot::FadeColorParams* MoveParams::_internal_mutable_fade_color_params() {
  if (!_internal_has_fade_color_params()) {
    clear_params();
    set_has_fade_color_params();
    _impl_.params_.fade_color_params_ = CreateMaybeMessage< ::bosdyn::api::spot::FadeColorParams >(GetArenaForAllocation());
  }
  return _impl_.params_.fade_color_params_;
}
inline ::bosdyn::api::spot::FadeColorParams* MoveParams::mutable_fade_color_params() {
  ::bosdyn::api::spot::FadeColorParams* _msg = _internal_mutable_fade_color_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.fade_color_params)
  return _msg;
}

// .bosdyn.api.spot.IndependentColorParams independent_color_params = 42;
inline bool MoveParams::_internal_has_independent_color_params() const {
  return params_case() == kIndependentColorParams;
}
inline bool MoveParams::has_independent_color_params() const {
  return _internal_has_independent_color_params();
}
inline void MoveParams::set_has_independent_color_params() {
  _impl_._oneof_case_[0] = kIndependentColorParams;
}
inline ::bosdyn::api::spot::IndependentColorParams* MoveParams::release_independent_color_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.independent_color_params)
  if (_internal_has_independent_color_params()) {
    clear_has_params();
    ::bosdyn::api::spot::IndependentColorParams* temp = _impl_.params_.independent_color_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.independent_color_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::IndependentColorParams& MoveParams::_internal_independent_color_params() const {
  return _internal_has_independent_color_params()
      ? *_impl_.params_.independent_color_params_
      : reinterpret_cast< ::bosdyn::api::spot::IndependentColorParams&>(::bosdyn::api::spot::_IndependentColorParams_default_instance_);
}
inline const ::bosdyn::api::spot::IndependentColorParams& MoveParams::independent_color_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.independent_color_params)
  return _internal_independent_color_params();
}
inline ::bosdyn::api::spot::IndependentColorParams* MoveParams::unsafe_arena_release_independent_color_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.independent_color_params)
  if (_internal_has_independent_color_params()) {
    clear_has_params();
    ::bosdyn::api::spot::IndependentColorParams* temp = _impl_.params_.independent_color_params_;
    _impl_.params_.independent_color_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_independent_color_params(::bosdyn::api::spot::IndependentColorParams* independent_color_params) {
  clear_params();
  if (independent_color_params) {
    set_has_independent_color_params();
    _impl_.params_.independent_color_params_ = independent_color_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.independent_color_params)
}
inline ::bosdyn::api::spot::IndependentColorParams* MoveParams::_internal_mutable_independent_color_params() {
  if (!_internal_has_independent_color_params()) {
    clear_params();
    set_has_independent_color_params();
    _impl_.params_.independent_color_params_ = CreateMaybeMessage< ::bosdyn::api::spot::IndependentColorParams >(GetArenaForAllocation());
  }
  return _impl_.params_.independent_color_params_;
}
inline ::bosdyn::api::spot::IndependentColorParams* MoveParams::mutable_independent_color_params() {
  ::bosdyn::api::spot::IndependentColorParams* _msg = _internal_mutable_independent_color_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.independent_color_params)
  return _msg;
}

// .bosdyn.api.spot.AnimateParams animate_params = 1000;
inline bool MoveParams::_internal_has_animate_params() const {
  return params_case() == kAnimateParams;
}
inline bool MoveParams::has_animate_params() const {
  return _internal_has_animate_params();
}
inline void MoveParams::set_has_animate_params() {
  _impl_._oneof_case_[0] = kAnimateParams;
}
inline ::bosdyn::api::spot::AnimateParams* MoveParams::release_animate_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveParams.animate_params)
  if (_internal_has_animate_params()) {
    clear_has_params();
    ::bosdyn::api::spot::AnimateParams* temp = _impl_.params_.animate_params_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.animate_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::AnimateParams& MoveParams::_internal_animate_params() const {
  return _internal_has_animate_params()
      ? *_impl_.params_.animate_params_
      : reinterpret_cast< ::bosdyn::api::spot::AnimateParams&>(::bosdyn::api::spot::_AnimateParams_default_instance_);
}
inline const ::bosdyn::api::spot::AnimateParams& MoveParams::animate_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveParams.animate_params)
  return _internal_animate_params();
}
inline ::bosdyn::api::spot::AnimateParams* MoveParams::unsafe_arena_release_animate_params() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.MoveParams.animate_params)
  if (_internal_has_animate_params()) {
    clear_has_params();
    ::bosdyn::api::spot::AnimateParams* temp = _impl_.params_.animate_params_;
    _impl_.params_.animate_params_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveParams::unsafe_arena_set_allocated_animate_params(::bosdyn::api::spot::AnimateParams* animate_params) {
  clear_params();
  if (animate_params) {
    set_has_animate_params();
    _impl_.params_.animate_params_ = animate_params;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveParams.animate_params)
}
inline ::bosdyn::api::spot::AnimateParams* MoveParams::_internal_mutable_animate_params() {
  if (!_internal_has_animate_params()) {
    clear_params();
    set_has_animate_params();
    _impl_.params_.animate_params_ = CreateMaybeMessage< ::bosdyn::api::spot::AnimateParams >(GetArenaForAllocation());
  }
  return _impl_.params_.animate_params_;
}
inline ::bosdyn::api::spot::AnimateParams* MoveParams::mutable_animate_params() {
  ::bosdyn::api::spot::AnimateParams* _msg = _internal_mutable_animate_params();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveParams.animate_params)
  return _msg;
}

inline bool MoveParams::has_params() const {
  return params_case() != PARAMS_NOT_SET;
}
inline void MoveParams::clear_has_params() {
  _impl_._oneof_case_[0] = PARAMS_NOT_SET;
}
inline MoveParams::ParamsCase MoveParams::params_case() const {
  return MoveParams::ParamsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MoveInfo

// string name = 1;
inline void MoveInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MoveInfo::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoveInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveInfo.name)
}
inline std::string* MoveInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveInfo.name)
  return _s;
}
inline const std::string& MoveInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void MoveInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* MoveInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* MoveInfo::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveInfo.name)
  return _impl_.name_.Release();
}
inline void MoveInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.MoveInfo.name)
}

// int32 move_length_slices = 2;
inline void MoveInfo::clear_move_length_slices() {
  _impl_.move_length_slices_ = 0;
}
inline int32_t MoveInfo::_internal_move_length_slices() const {
  return _impl_.move_length_slices_;
}
inline int32_t MoveInfo::move_length_slices() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.move_length_slices)
  return _internal_move_length_slices();
}
inline void MoveInfo::_internal_set_move_length_slices(int32_t value) {
  
  _impl_.move_length_slices_ = value;
}
inline void MoveInfo::set_move_length_slices(int32_t value) {
  _internal_set_move_length_slices(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveInfo.move_length_slices)
}

// double move_length_time = 15;
inline void MoveInfo::clear_move_length_time() {
  _impl_.move_length_time_ = 0;
}
inline double MoveInfo::_internal_move_length_time() const {
  return _impl_.move_length_time_;
}
inline double MoveInfo::move_length_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.move_length_time)
  return _internal_move_length_time();
}
inline void MoveInfo::_internal_set_move_length_time(double value) {
  
  _impl_.move_length_time_ = value;
}
inline void MoveInfo::set_move_length_time(double value) {
  _internal_set_move_length_time(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveInfo.move_length_time)
}

// bool is_extendable = 3;
inline void MoveInfo::clear_is_extendable() {
  _impl_.is_extendable_ = false;
}
inline bool MoveInfo::_internal_is_extendable() const {
  return _impl_.is_extendable_;
}
inline bool MoveInfo::is_extendable() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.is_extendable)
  return _internal_is_extendable();
}
inline void MoveInfo::_internal_set_is_extendable(bool value) {
  
  _impl_.is_extendable_ = value;
}
inline void MoveInfo::set_is_extendable(bool value) {
  _internal_set_is_extendable(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveInfo.is_extendable)
}

// int32 min_move_length_slices = 13;
inline void MoveInfo::clear_min_move_length_slices() {
  _impl_.min_move_length_slices_ = 0;
}
inline int32_t MoveInfo::_internal_min_move_length_slices() const {
  return _impl_.min_move_length_slices_;
}
inline int32_t MoveInfo::min_move_length_slices() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.min_move_length_slices)
  return _internal_min_move_length_slices();
}
inline void MoveInfo::_internal_set_min_move_length_slices(int32_t value) {
  
  _impl_.min_move_length_slices_ = value;
}
inline void MoveInfo::set_min_move_length_slices(int32_t value) {
  _internal_set_min_move_length_slices(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveInfo.min_move_length_slices)
}

// int32 max_move_length_slices = 14;
inline void MoveInfo::clear_max_move_length_slices() {
  _impl_.max_move_length_slices_ = 0;
}
inline int32_t MoveInfo::_internal_max_move_length_slices() const {
  return _impl_.max_move_length_slices_;
}
inline int32_t MoveInfo::max_move_length_slices() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.max_move_length_slices)
  return _internal_max_move_length_slices();
}
inline void MoveInfo::_internal_set_max_move_length_slices(int32_t value) {
  
  _impl_.max_move_length_slices_ = value;
}
inline void MoveInfo::set_max_move_length_slices(int32_t value) {
  _internal_set_max_move_length_slices(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveInfo.max_move_length_slices)
}

// double min_time = 6;
inline void MoveInfo::clear_min_time() {
  _impl_.min_time_ = 0;
}
inline double MoveInfo::_internal_min_time() const {
  return _impl_.min_time_;
}
inline double MoveInfo::min_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.min_time)
  return _internal_min_time();
}
inline void MoveInfo::_internal_set_min_time(double value) {
  
  _impl_.min_time_ = value;
}
inline void MoveInfo::set_min_time(double value) {
  _internal_set_min_time(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveInfo.min_time)
}

// double max_time = 7;
inline void MoveInfo::clear_max_time() {
  _impl_.max_time_ = 0;
}
inline double MoveInfo::_internal_max_time() const {
  return _impl_.max_time_;
}
inline double MoveInfo::max_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.max_time)
  return _internal_max_time();
}
inline void MoveInfo::_internal_set_max_time(double value) {
  
  _impl_.max_time_ = value;
}
inline void MoveInfo::set_max_time(double value) {
  _internal_set_max_time(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveInfo.max_time)
}

// repeated .bosdyn.api.spot.MoveInfo.TransitionState entrance_states = 4;
inline int MoveInfo::_internal_entrance_states_size() const {
  return _impl_.entrance_states_.size();
}
inline int MoveInfo::entrance_states_size() const {
  return _internal_entrance_states_size();
}
inline void MoveInfo::clear_entrance_states() {
  _impl_.entrance_states_.Clear();
}
inline ::bosdyn::api::spot::MoveInfo_TransitionState MoveInfo::_internal_entrance_states(int index) const {
  return static_cast< ::bosdyn::api::spot::MoveInfo_TransitionState >(_impl_.entrance_states_.Get(index));
}
inline ::bosdyn::api::spot::MoveInfo_TransitionState MoveInfo::entrance_states(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.entrance_states)
  return _internal_entrance_states(index);
}
inline void MoveInfo::set_entrance_states(int index, ::bosdyn::api::spot::MoveInfo_TransitionState value) {
  _impl_.entrance_states_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveInfo.entrance_states)
}
inline void MoveInfo::_internal_add_entrance_states(::bosdyn::api::spot::MoveInfo_TransitionState value) {
  _impl_.entrance_states_.Add(value);
}
inline void MoveInfo::add_entrance_states(::bosdyn::api::spot::MoveInfo_TransitionState value) {
  _internal_add_entrance_states(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.MoveInfo.entrance_states)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
MoveInfo::entrance_states() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.MoveInfo.entrance_states)
  return _impl_.entrance_states_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
MoveInfo::_internal_mutable_entrance_states() {
  return &_impl_.entrance_states_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
MoveInfo::mutable_entrance_states() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.MoveInfo.entrance_states)
  return _internal_mutable_entrance_states();
}

// .bosdyn.api.spot.MoveInfo.TransitionState exit_state = 5;
inline void MoveInfo::clear_exit_state() {
  _impl_.exit_state_ = 0;
}
inline ::bosdyn::api::spot::MoveInfo_TransitionState MoveInfo::_internal_exit_state() const {
  return static_cast< ::bosdyn::api::spot::MoveInfo_TransitionState >(_impl_.exit_state_);
}
inline ::bosdyn::api::spot::MoveInfo_TransitionState MoveInfo::exit_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.exit_state)
  return _internal_exit_state();
}
inline void MoveInfo::_internal_set_exit_state(::bosdyn::api::spot::MoveInfo_TransitionState value) {
  
  _impl_.exit_state_ = value;
}
inline void MoveInfo::set_exit_state(::bosdyn::api::spot::MoveInfo_TransitionState value) {
  _internal_set_exit_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveInfo.exit_state)
}

// bool controls_arm = 8;
inline void MoveInfo::clear_controls_arm() {
  _impl_.controls_arm_ = false;
}
inline bool MoveInfo::_internal_controls_arm() const {
  return _impl_.controls_arm_;
}
inline bool MoveInfo::controls_arm() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.controls_arm)
  return _internal_controls_arm();
}
inline void MoveInfo::_internal_set_controls_arm(bool value) {
  
  _impl_.controls_arm_ = value;
}
inline void MoveInfo::set_controls_arm(bool value) {
  _internal_set_controls_arm(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveInfo.controls_arm)
}

// bool controls_legs = 9;
inline void MoveInfo::clear_controls_legs() {
  _impl_.controls_legs_ = false;
}
inline bool MoveInfo::_internal_controls_legs() const {
  return _impl_.controls_legs_;
}
inline bool MoveInfo::controls_legs() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.controls_legs)
  return _internal_controls_legs();
}
inline void MoveInfo::_internal_set_controls_legs(bool value) {
  
  _impl_.controls_legs_ = value;
}
inline void MoveInfo::set_controls_legs(bool value) {
  _internal_set_controls_legs(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveInfo.controls_legs)
}

// bool controls_body = 10;
inline void MoveInfo::clear_controls_body() {
  _impl_.controls_body_ = false;
}
inline bool MoveInfo::_internal_controls_body() const {
  return _impl_.controls_body_;
}
inline bool MoveInfo::controls_body() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.controls_body)
  return _internal_controls_body();
}
inline void MoveInfo::_internal_set_controls_body(bool value) {
  
  _impl_.controls_body_ = value;
}
inline void MoveInfo::set_controls_body(bool value) {
  _internal_set_controls_body(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveInfo.controls_body)
}

// bool controls_gripper = 12;
inline void MoveInfo::clear_controls_gripper() {
  _impl_.controls_gripper_ = false;
}
inline bool MoveInfo::_internal_controls_gripper() const {
  return _impl_.controls_gripper_;
}
inline bool MoveInfo::controls_gripper() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.controls_gripper)
  return _internal_controls_gripper();
}
inline void MoveInfo::_internal_set_controls_gripper(bool value) {
  
  _impl_.controls_gripper_ = value;
}
inline void MoveInfo::set_controls_gripper(bool value) {
  _internal_set_controls_gripper(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveInfo.controls_gripper)
}

// bool controls_lights = 17;
inline void MoveInfo::clear_controls_lights() {
  _impl_.controls_lights_ = false;
}
inline bool MoveInfo::_internal_controls_lights() const {
  return _impl_.controls_lights_;
}
inline bool MoveInfo::controls_lights() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.controls_lights)
  return _internal_controls_lights();
}
inline void MoveInfo::_internal_set_controls_lights(bool value) {
  
  _impl_.controls_lights_ = value;
}
inline void MoveInfo::set_controls_lights(bool value) {
  _internal_set_controls_lights(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveInfo.controls_lights)
}

// bool controls_annotations = 18;
inline void MoveInfo::clear_controls_annotations() {
  _impl_.controls_annotations_ = false;
}
inline bool MoveInfo::_internal_controls_annotations() const {
  return _impl_.controls_annotations_;
}
inline bool MoveInfo::controls_annotations() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.controls_annotations)
  return _internal_controls_annotations();
}
inline void MoveInfo::_internal_set_controls_annotations(bool value) {
  
  _impl_.controls_annotations_ = value;
}
inline void MoveInfo::set_controls_annotations(bool value) {
  _internal_set_controls_annotations(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.MoveInfo.controls_annotations)
}

// .bosdyn.api.spot.ChoreographerDisplayInfo display = 11;
inline bool MoveInfo::_internal_has_display() const {
  return this != internal_default_instance() && _impl_.display_ != nullptr;
}
inline bool MoveInfo::has_display() const {
  return _internal_has_display();
}
inline void MoveInfo::clear_display() {
  if (GetArenaForAllocation() == nullptr && _impl_.display_ != nullptr) {
    delete _impl_.display_;
  }
  _impl_.display_ = nullptr;
}
inline const ::bosdyn::api::spot::ChoreographerDisplayInfo& MoveInfo::_internal_display() const {
  const ::bosdyn::api::spot::ChoreographerDisplayInfo* p = _impl_.display_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::ChoreographerDisplayInfo&>(
      ::bosdyn::api::spot::_ChoreographerDisplayInfo_default_instance_);
}
inline const ::bosdyn::api::spot::ChoreographerDisplayInfo& MoveInfo::display() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.display)
  return _internal_display();
}
inline void MoveInfo::unsafe_arena_set_allocated_display(
    ::bosdyn::api::spot::ChoreographerDisplayInfo* display) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.display_);
  }
  _impl_.display_ = display;
  if (display) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveInfo.display)
}
inline ::bosdyn::api::spot::ChoreographerDisplayInfo* MoveInfo::release_display() {
  
  ::bosdyn::api::spot::ChoreographerDisplayInfo* temp = _impl_.display_;
  _impl_.display_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::ChoreographerDisplayInfo* MoveInfo::unsafe_arena_release_display() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveInfo.display)
  
  ::bosdyn::api::spot::ChoreographerDisplayInfo* temp = _impl_.display_;
  _impl_.display_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::ChoreographerDisplayInfo* MoveInfo::_internal_mutable_display() {
  
  if (_impl_.display_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::ChoreographerDisplayInfo>(GetArenaForAllocation());
    _impl_.display_ = p;
  }
  return _impl_.display_;
}
inline ::bosdyn::api::spot::ChoreographerDisplayInfo* MoveInfo::mutable_display() {
  ::bosdyn::api::spot::ChoreographerDisplayInfo* _msg = _internal_mutable_display();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveInfo.display)
  return _msg;
}
inline void MoveInfo::set_allocated_display(::bosdyn::api::spot::ChoreographerDisplayInfo* display) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.display_;
  }
  if (display) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(display);
    if (message_arena != submessage_arena) {
      display = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, display, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.display_ = display;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.MoveInfo.display)
}

// .google.protobuf.StringValue animated_move_generated_id = 16;
inline bool MoveInfo::_internal_has_animated_move_generated_id() const {
  return this != internal_default_instance() && _impl_.animated_move_generated_id_ != nullptr;
}
inline bool MoveInfo::has_animated_move_generated_id() const {
  return _internal_has_animated_move_generated_id();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& MoveInfo::_internal_animated_move_generated_id() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.animated_move_generated_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& MoveInfo::animated_move_generated_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.MoveInfo.animated_move_generated_id)
  return _internal_animated_move_generated_id();
}
inline void MoveInfo::unsafe_arena_set_allocated_animated_move_generated_id(
    ::PROTOBUF_NAMESPACE_ID::StringValue* animated_move_generated_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.animated_move_generated_id_);
  }
  _impl_.animated_move_generated_id_ = animated_move_generated_id;
  if (animated_move_generated_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.MoveInfo.animated_move_generated_id)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* MoveInfo::release_animated_move_generated_id() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.animated_move_generated_id_;
  _impl_.animated_move_generated_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* MoveInfo::unsafe_arena_release_animated_move_generated_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.MoveInfo.animated_move_generated_id)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.animated_move_generated_id_;
  _impl_.animated_move_generated_id_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* MoveInfo::_internal_mutable_animated_move_generated_id() {
  
  if (_impl_.animated_move_generated_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.animated_move_generated_id_ = p;
  }
  return _impl_.animated_move_generated_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* MoveInfo::mutable_animated_move_generated_id() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_animated_move_generated_id();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.MoveInfo.animated_move_generated_id)
  return _msg;
}
inline void MoveInfo::set_allocated_animated_move_generated_id(::PROTOBUF_NAMESPACE_ID::StringValue* animated_move_generated_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.animated_move_generated_id_);
  }
  if (animated_move_generated_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(animated_move_generated_id));
    if (message_arena != submessage_arena) {
      animated_move_generated_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, animated_move_generated_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.animated_move_generated_id_ = animated_move_generated_id;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.MoveInfo.animated_move_generated_id)
}

// -------------------------------------------------------------------

// ChoreographerDisplayInfo_Color

// int32 r = 1;
inline void ChoreographerDisplayInfo_Color::clear_r() {
  _impl_.r_ = 0;
}
inline int32_t ChoreographerDisplayInfo_Color::_internal_r() const {
  return _impl_.r_;
}
inline int32_t ChoreographerDisplayInfo_Color::r() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographerDisplayInfo.Color.r)
  return _internal_r();
}
inline void ChoreographerDisplayInfo_Color::_internal_set_r(int32_t value) {
  
  _impl_.r_ = value;
}
inline void ChoreographerDisplayInfo_Color::set_r(int32_t value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ChoreographerDisplayInfo.Color.r)
}

// int32 g = 2;
inline void ChoreographerDisplayInfo_Color::clear_g() {
  _impl_.g_ = 0;
}
inline int32_t ChoreographerDisplayInfo_Color::_internal_g() const {
  return _impl_.g_;
}
inline int32_t ChoreographerDisplayInfo_Color::g() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographerDisplayInfo.Color.g)
  return _internal_g();
}
inline void ChoreographerDisplayInfo_Color::_internal_set_g(int32_t value) {
  
  _impl_.g_ = value;
}
inline void ChoreographerDisplayInfo_Color::set_g(int32_t value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ChoreographerDisplayInfo.Color.g)
}

// int32 b = 3;
inline void ChoreographerDisplayInfo_Color::clear_b() {
  _impl_.b_ = 0;
}
inline int32_t ChoreographerDisplayInfo_Color::_internal_b() const {
  return _impl_.b_;
}
inline int32_t ChoreographerDisplayInfo_Color::b() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographerDisplayInfo.Color.b)
  return _internal_b();
}
inline void ChoreographerDisplayInfo_Color::_internal_set_b(int32_t value) {
  
  _impl_.b_ = value;
}
inline void ChoreographerDisplayInfo_Color::set_b(int32_t value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ChoreographerDisplayInfo.Color.b)
}

// double a = 4;
inline void ChoreographerDisplayInfo_Color::clear_a() {
  _impl_.a_ = 0;
}
inline double ChoreographerDisplayInfo_Color::_internal_a() const {
  return _impl_.a_;
}
inline double ChoreographerDisplayInfo_Color::a() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographerDisplayInfo.Color.a)
  return _internal_a();
}
inline void ChoreographerDisplayInfo_Color::_internal_set_a(double value) {
  
  _impl_.a_ = value;
}
inline void ChoreographerDisplayInfo_Color::set_a(double value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ChoreographerDisplayInfo.Color.a)
}

// -------------------------------------------------------------------

// ChoreographerDisplayInfo

// .bosdyn.api.spot.ChoreographerDisplayInfo.Color color = 1;
inline bool ChoreographerDisplayInfo::_internal_has_color() const {
  return this != internal_default_instance() && _impl_.color_ != nullptr;
}
inline bool ChoreographerDisplayInfo::has_color() const {
  return _internal_has_color();
}
inline void ChoreographerDisplayInfo::clear_color() {
  if (GetArenaForAllocation() == nullptr && _impl_.color_ != nullptr) {
    delete _impl_.color_;
  }
  _impl_.color_ = nullptr;
}
inline const ::bosdyn::api::spot::ChoreographerDisplayInfo_Color& ChoreographerDisplayInfo::_internal_color() const {
  const ::bosdyn::api::spot::ChoreographerDisplayInfo_Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::ChoreographerDisplayInfo_Color&>(
      ::bosdyn::api::spot::_ChoreographerDisplayInfo_Color_default_instance_);
}
inline const ::bosdyn::api::spot::ChoreographerDisplayInfo_Color& ChoreographerDisplayInfo::color() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographerDisplayInfo.color)
  return _internal_color();
}
inline void ChoreographerDisplayInfo::unsafe_arena_set_allocated_color(
    ::bosdyn::api::spot::ChoreographerDisplayInfo_Color* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ChoreographerDisplayInfo.color)
}
inline ::bosdyn::api::spot::ChoreographerDisplayInfo_Color* ChoreographerDisplayInfo::release_color() {
  
  ::bosdyn::api::spot::ChoreographerDisplayInfo_Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::ChoreographerDisplayInfo_Color* ChoreographerDisplayInfo::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ChoreographerDisplayInfo.color)
  
  ::bosdyn::api::spot::ChoreographerDisplayInfo_Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::ChoreographerDisplayInfo_Color* ChoreographerDisplayInfo::_internal_mutable_color() {
  
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::ChoreographerDisplayInfo_Color>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::bosdyn::api::spot::ChoreographerDisplayInfo_Color* ChoreographerDisplayInfo::mutable_color() {
  ::bosdyn::api::spot::ChoreographerDisplayInfo_Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ChoreographerDisplayInfo.color)
  return _msg;
}
inline void ChoreographerDisplayInfo::set_allocated_color(::bosdyn::api::spot::ChoreographerDisplayInfo_Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ChoreographerDisplayInfo.color)
}

// repeated int32 markers = 13;
inline int ChoreographerDisplayInfo::_internal_markers_size() const {
  return _impl_.markers_.size();
}
inline int ChoreographerDisplayInfo::markers_size() const {
  return _internal_markers_size();
}
inline void ChoreographerDisplayInfo::clear_markers() {
  _impl_.markers_.Clear();
}
inline int32_t ChoreographerDisplayInfo::_internal_markers(int index) const {
  return _impl_.markers_.Get(index);
}
inline int32_t ChoreographerDisplayInfo::markers(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographerDisplayInfo.markers)
  return _internal_markers(index);
}
inline void ChoreographerDisplayInfo::set_markers(int index, int32_t value) {
  _impl_.markers_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ChoreographerDisplayInfo.markers)
}
inline void ChoreographerDisplayInfo::_internal_add_markers(int32_t value) {
  _impl_.markers_.Add(value);
}
inline void ChoreographerDisplayInfo::add_markers(int32_t value) {
  _internal_add_markers(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.ChoreographerDisplayInfo.markers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ChoreographerDisplayInfo::_internal_markers() const {
  return _impl_.markers_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ChoreographerDisplayInfo::markers() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.ChoreographerDisplayInfo.markers)
  return _internal_markers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ChoreographerDisplayInfo::_internal_mutable_markers() {
  return &_impl_.markers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ChoreographerDisplayInfo::mutable_markers() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.ChoreographerDisplayInfo.markers)
  return _internal_mutable_markers();
}

// string description = 14;
inline void ChoreographerDisplayInfo::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ChoreographerDisplayInfo::description() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographerDisplayInfo.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChoreographerDisplayInfo::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ChoreographerDisplayInfo.description)
}
inline std::string* ChoreographerDisplayInfo::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ChoreographerDisplayInfo.description)
  return _s;
}
inline const std::string& ChoreographerDisplayInfo::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ChoreographerDisplayInfo::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ChoreographerDisplayInfo::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ChoreographerDisplayInfo::release_description() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ChoreographerDisplayInfo.description)
  return _impl_.description_.Release();
}
inline void ChoreographerDisplayInfo::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ChoreographerDisplayInfo.description)
}

// string image = 15;
inline void ChoreographerDisplayInfo::clear_image() {
  _impl_.image_.ClearToEmpty();
}
inline const std::string& ChoreographerDisplayInfo::image() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographerDisplayInfo.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChoreographerDisplayInfo::set_image(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ChoreographerDisplayInfo.image)
}
inline std::string* ChoreographerDisplayInfo::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ChoreographerDisplayInfo.image)
  return _s;
}
inline const std::string& ChoreographerDisplayInfo::_internal_image() const {
  return _impl_.image_.Get();
}
inline void ChoreographerDisplayInfo::_internal_set_image(const std::string& value) {
  
  _impl_.image_.Set(value, GetArenaForAllocation());
}
inline std::string* ChoreographerDisplayInfo::_internal_mutable_image() {
  
  return _impl_.image_.Mutable(GetArenaForAllocation());
}
inline std::string* ChoreographerDisplayInfo::release_image() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ChoreographerDisplayInfo.image)
  return _impl_.image_.Release();
}
inline void ChoreographerDisplayInfo::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  _impl_.image_.SetAllocated(image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_.IsDefault()) {
    _impl_.image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ChoreographerDisplayInfo.image)
}

// .bosdyn.api.spot.ChoreographerDisplayInfo.Category category = 16;
inline void ChoreographerDisplayInfo::clear_category() {
  _impl_.category_ = 0;
}
inline ::bosdyn::api::spot::ChoreographerDisplayInfo_Category ChoreographerDisplayInfo::_internal_category() const {
  return static_cast< ::bosdyn::api::spot::ChoreographerDisplayInfo_Category >(_impl_.category_);
}
inline ::bosdyn::api::spot::ChoreographerDisplayInfo_Category ChoreographerDisplayInfo::category() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographerDisplayInfo.category)
  return _internal_category();
}
inline void ChoreographerDisplayInfo::_internal_set_category(::bosdyn::api::spot::ChoreographerDisplayInfo_Category value) {
  
  _impl_.category_ = value;
}
inline void ChoreographerDisplayInfo::set_category(::bosdyn::api::spot::ChoreographerDisplayInfo_Category value) {
  _internal_set_category(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ChoreographerDisplayInfo.category)
}

// -------------------------------------------------------------------

// ChoreographySequence

// string name = 1;
inline void ChoreographySequence::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ChoreographySequence::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographySequence.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChoreographySequence::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ChoreographySequence.name)
}
inline std::string* ChoreographySequence::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ChoreographySequence.name)
  return _s;
}
inline const std::string& ChoreographySequence::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ChoreographySequence::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ChoreographySequence::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ChoreographySequence::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ChoreographySequence.name)
  return _impl_.name_.Release();
}
inline void ChoreographySequence::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ChoreographySequence.name)
}

// double slices_per_minute = 2;
inline void ChoreographySequence::clear_slices_per_minute() {
  _impl_.slices_per_minute_ = 0;
}
inline double ChoreographySequence::_internal_slices_per_minute() const {
  return _impl_.slices_per_minute_;
}
inline double ChoreographySequence::slices_per_minute() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographySequence.slices_per_minute)
  return _internal_slices_per_minute();
}
inline void ChoreographySequence::_internal_set_slices_per_minute(double value) {
  
  _impl_.slices_per_minute_ = value;
}
inline void ChoreographySequence::set_slices_per_minute(double value) {
  _internal_set_slices_per_minute(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ChoreographySequence.slices_per_minute)
}

// repeated .bosdyn.api.spot.MoveParams moves = 3;
inline int ChoreographySequence::_internal_moves_size() const {
  return _impl_.moves_.size();
}
inline int ChoreographySequence::moves_size() const {
  return _internal_moves_size();
}
inline void ChoreographySequence::clear_moves() {
  _impl_.moves_.Clear();
}
inline ::bosdyn::api::spot::MoveParams* ChoreographySequence::mutable_moves(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ChoreographySequence.moves)
  return _impl_.moves_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::MoveParams >*
ChoreographySequence::mutable_moves() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.ChoreographySequence.moves)
  return &_impl_.moves_;
}
inline const ::bosdyn::api::spot::MoveParams& ChoreographySequence::_internal_moves(int index) const {
  return _impl_.moves_.Get(index);
}
inline const ::bosdyn::api::spot::MoveParams& ChoreographySequence::moves(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographySequence.moves)
  return _internal_moves(index);
}
inline ::bosdyn::api::spot::MoveParams* ChoreographySequence::_internal_add_moves() {
  return _impl_.moves_.Add();
}
inline ::bosdyn::api::spot::MoveParams* ChoreographySequence::add_moves() {
  ::bosdyn::api::spot::MoveParams* _add = _internal_add_moves();
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.ChoreographySequence.moves)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::MoveParams >&
ChoreographySequence::moves() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.ChoreographySequence.moves)
  return _impl_.moves_;
}

// .bosdyn.api.spot.ChoreographyInfo choreography_info = 4;
inline bool ChoreographySequence::_internal_has_choreography_info() const {
  return this != internal_default_instance() && _impl_.choreography_info_ != nullptr;
}
inline bool ChoreographySequence::has_choreography_info() const {
  return _internal_has_choreography_info();
}
inline void ChoreographySequence::clear_choreography_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.choreography_info_ != nullptr) {
    delete _impl_.choreography_info_;
  }
  _impl_.choreography_info_ = nullptr;
}
inline const ::bosdyn::api::spot::ChoreographyInfo& ChoreographySequence::_internal_choreography_info() const {
  const ::bosdyn::api::spot::ChoreographyInfo* p = _impl_.choreography_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::ChoreographyInfo&>(
      ::bosdyn::api::spot::_ChoreographyInfo_default_instance_);
}
inline const ::bosdyn::api::spot::ChoreographyInfo& ChoreographySequence::choreography_info() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographySequence.choreography_info)
  return _internal_choreography_info();
}
inline void ChoreographySequence::unsafe_arena_set_allocated_choreography_info(
    ::bosdyn::api::spot::ChoreographyInfo* choreography_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.choreography_info_);
  }
  _impl_.choreography_info_ = choreography_info;
  if (choreography_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ChoreographySequence.choreography_info)
}
inline ::bosdyn::api::spot::ChoreographyInfo* ChoreographySequence::release_choreography_info() {
  
  ::bosdyn::api::spot::ChoreographyInfo* temp = _impl_.choreography_info_;
  _impl_.choreography_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::ChoreographyInfo* ChoreographySequence::unsafe_arena_release_choreography_info() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ChoreographySequence.choreography_info)
  
  ::bosdyn::api::spot::ChoreographyInfo* temp = _impl_.choreography_info_;
  _impl_.choreography_info_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::ChoreographyInfo* ChoreographySequence::_internal_mutable_choreography_info() {
  
  if (_impl_.choreography_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::ChoreographyInfo>(GetArenaForAllocation());
    _impl_.choreography_info_ = p;
  }
  return _impl_.choreography_info_;
}
inline ::bosdyn::api::spot::ChoreographyInfo* ChoreographySequence::mutable_choreography_info() {
  ::bosdyn::api::spot::ChoreographyInfo* _msg = _internal_mutable_choreography_info();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ChoreographySequence.choreography_info)
  return _msg;
}
inline void ChoreographySequence::set_allocated_choreography_info(::bosdyn::api::spot::ChoreographyInfo* choreography_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.choreography_info_;
  }
  if (choreography_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(choreography_info);
    if (message_arena != submessage_arena) {
      choreography_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, choreography_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.choreography_info_ = choreography_info;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ChoreographySequence.choreography_info)
}

// -------------------------------------------------------------------

// ChoreographyInfo

// repeated string labels = 4;
inline int ChoreographyInfo::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int ChoreographyInfo::labels_size() const {
  return _internal_labels_size();
}
inline void ChoreographyInfo::clear_labels() {
  _impl_.labels_.Clear();
}
inline std::string* ChoreographyInfo::add_labels() {
  std::string* _s = _internal_add_labels();
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.spot.ChoreographyInfo.labels)
  return _s;
}
inline const std::string& ChoreographyInfo::_internal_labels(int index) const {
  return _impl_.labels_.Get(index);
}
inline const std::string& ChoreographyInfo::labels(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographyInfo.labels)
  return _internal_labels(index);
}
inline std::string* ChoreographyInfo::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ChoreographyInfo.labels)
  return _impl_.labels_.Mutable(index);
}
inline void ChoreographyInfo::set_labels(int index, const std::string& value) {
  _impl_.labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ChoreographyInfo.labels)
}
inline void ChoreographyInfo::set_labels(int index, std::string&& value) {
  _impl_.labels_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ChoreographyInfo.labels)
}
inline void ChoreographyInfo::set_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.spot.ChoreographyInfo.labels)
}
inline void ChoreographyInfo::set_labels(int index, const char* value, size_t size) {
  _impl_.labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.spot.ChoreographyInfo.labels)
}
inline std::string* ChoreographyInfo::_internal_add_labels() {
  return _impl_.labels_.Add();
}
inline void ChoreographyInfo::add_labels(const std::string& value) {
  _impl_.labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.ChoreographyInfo.labels)
}
inline void ChoreographyInfo::add_labels(std::string&& value) {
  _impl_.labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.ChoreographyInfo.labels)
}
inline void ChoreographyInfo::add_labels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.spot.ChoreographyInfo.labels)
}
inline void ChoreographyInfo::add_labels(const char* value, size_t size) {
  _impl_.labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.spot.ChoreographyInfo.labels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ChoreographyInfo::labels() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.ChoreographyInfo.labels)
  return _impl_.labels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ChoreographyInfo::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.ChoreographyInfo.labels)
  return &_impl_.labels_;
}

// -------------------------------------------------------------------

// ChoreographerSave

// .bosdyn.api.spot.ChoreographySequence choreography_sequence = 1;
inline bool ChoreographerSave::_internal_has_choreography_sequence() const {
  return this != internal_default_instance() && _impl_.choreography_sequence_ != nullptr;
}
inline bool ChoreographerSave::has_choreography_sequence() const {
  return _internal_has_choreography_sequence();
}
inline void ChoreographerSave::clear_choreography_sequence() {
  if (GetArenaForAllocation() == nullptr && _impl_.choreography_sequence_ != nullptr) {
    delete _impl_.choreography_sequence_;
  }
  _impl_.choreography_sequence_ = nullptr;
}
inline const ::bosdyn::api::spot::ChoreographySequence& ChoreographerSave::_internal_choreography_sequence() const {
  const ::bosdyn::api::spot::ChoreographySequence* p = _impl_.choreography_sequence_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::ChoreographySequence&>(
      ::bosdyn::api::spot::_ChoreographySequence_default_instance_);
}
inline const ::bosdyn::api::spot::ChoreographySequence& ChoreographerSave::choreography_sequence() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographerSave.choreography_sequence)
  return _internal_choreography_sequence();
}
inline void ChoreographerSave::unsafe_arena_set_allocated_choreography_sequence(
    ::bosdyn::api::spot::ChoreographySequence* choreography_sequence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.choreography_sequence_);
  }
  _impl_.choreography_sequence_ = choreography_sequence;
  if (choreography_sequence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ChoreographerSave.choreography_sequence)
}
inline ::bosdyn::api::spot::ChoreographySequence* ChoreographerSave::release_choreography_sequence() {
  
  ::bosdyn::api::spot::ChoreographySequence* temp = _impl_.choreography_sequence_;
  _impl_.choreography_sequence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::ChoreographySequence* ChoreographerSave::unsafe_arena_release_choreography_sequence() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ChoreographerSave.choreography_sequence)
  
  ::bosdyn::api::spot::ChoreographySequence* temp = _impl_.choreography_sequence_;
  _impl_.choreography_sequence_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::ChoreographySequence* ChoreographerSave::_internal_mutable_choreography_sequence() {
  
  if (_impl_.choreography_sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::ChoreographySequence>(GetArenaForAllocation());
    _impl_.choreography_sequence_ = p;
  }
  return _impl_.choreography_sequence_;
}
inline ::bosdyn::api::spot::ChoreographySequence* ChoreographerSave::mutable_choreography_sequence() {
  ::bosdyn::api::spot::ChoreographySequence* _msg = _internal_mutable_choreography_sequence();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ChoreographerSave.choreography_sequence)
  return _msg;
}
inline void ChoreographerSave::set_allocated_choreography_sequence(::bosdyn::api::spot::ChoreographySequence* choreography_sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.choreography_sequence_;
  }
  if (choreography_sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(choreography_sequence);
    if (message_arena != submessage_arena) {
      choreography_sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, choreography_sequence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.choreography_sequence_ = choreography_sequence;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ChoreographerSave.choreography_sequence)
}

// string music_file = 2;
inline void ChoreographerSave::clear_music_file() {
  _impl_.music_file_.ClearToEmpty();
}
inline const std::string& ChoreographerSave::music_file() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographerSave.music_file)
  return _internal_music_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChoreographerSave::set_music_file(ArgT0&& arg0, ArgT... args) {
 
 _impl_.music_file_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ChoreographerSave.music_file)
}
inline std::string* ChoreographerSave::mutable_music_file() {
  std::string* _s = _internal_mutable_music_file();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ChoreographerSave.music_file)
  return _s;
}
inline const std::string& ChoreographerSave::_internal_music_file() const {
  return _impl_.music_file_.Get();
}
inline void ChoreographerSave::_internal_set_music_file(const std::string& value) {
  
  _impl_.music_file_.Set(value, GetArenaForAllocation());
}
inline std::string* ChoreographerSave::_internal_mutable_music_file() {
  
  return _impl_.music_file_.Mutable(GetArenaForAllocation());
}
inline std::string* ChoreographerSave::release_music_file() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ChoreographerSave.music_file)
  return _impl_.music_file_.Release();
}
inline void ChoreographerSave::set_allocated_music_file(std::string* music_file) {
  if (music_file != nullptr) {
    
  } else {
    
  }
  _impl_.music_file_.SetAllocated(music_file, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.music_file_.IsDefault()) {
    _impl_.music_file_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ChoreographerSave.music_file)
}

// double music_start_slice = 3;
inline void ChoreographerSave::clear_music_start_slice() {
  _impl_.music_start_slice_ = 0;
}
inline double ChoreographerSave::_internal_music_start_slice() const {
  return _impl_.music_start_slice_;
}
inline double ChoreographerSave::music_start_slice() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographerSave.music_start_slice)
  return _internal_music_start_slice();
}
inline void ChoreographerSave::_internal_set_music_start_slice(double value) {
  
  _impl_.music_start_slice_ = value;
}
inline void ChoreographerSave::set_music_start_slice(double value) {
  _internal_set_music_start_slice(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ChoreographerSave.music_start_slice)
}

// double choreography_start_slice = 4;
inline void ChoreographerSave::clear_choreography_start_slice() {
  _impl_.choreography_start_slice_ = 0;
}
inline double ChoreographerSave::_internal_choreography_start_slice() const {
  return _impl_.choreography_start_slice_;
}
inline double ChoreographerSave::choreography_start_slice() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ChoreographerSave.choreography_start_slice)
  return _internal_choreography_start_slice();
}
inline void ChoreographerSave::_internal_set_choreography_start_slice(double value) {
  
  _impl_.choreography_start_slice_ = value;
}
inline void ChoreographerSave::set_choreography_start_slice(double value) {
  _internal_set_choreography_start_slice(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.ChoreographerSave.choreography_start_slice)
}

// -------------------------------------------------------------------

// Animation

// string name = 1;
inline void Animation::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Animation::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Animation::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.name)
}
inline std::string* Animation::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.Animation.name)
  return _s;
}
inline const std::string& Animation::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Animation::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Animation::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Animation::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.Animation.name)
  return _impl_.name_.Release();
}
inline void Animation::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.Animation.name)
}

// repeated .bosdyn.api.spot.AnimationKeyframe animation_keyframes = 2;
inline int Animation::_internal_animation_keyframes_size() const {
  return _impl_.animation_keyframes_.size();
}
inline int Animation::animation_keyframes_size() const {
  return _internal_animation_keyframes_size();
}
inline void Animation::clear_animation_keyframes() {
  _impl_.animation_keyframes_.Clear();
}
inline ::bosdyn::api::spot::AnimationKeyframe* Animation::mutable_animation_keyframes(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.Animation.animation_keyframes)
  return _impl_.animation_keyframes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::AnimationKeyframe >*
Animation::mutable_animation_keyframes() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot.Animation.animation_keyframes)
  return &_impl_.animation_keyframes_;
}
inline const ::bosdyn::api::spot::AnimationKeyframe& Animation::_internal_animation_keyframes(int index) const {
  return _impl_.animation_keyframes_.Get(index);
}
inline const ::bosdyn::api::spot::AnimationKeyframe& Animation::animation_keyframes(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.animation_keyframes)
  return _internal_animation_keyframes(index);
}
inline ::bosdyn::api::spot::AnimationKeyframe* Animation::_internal_add_animation_keyframes() {
  return _impl_.animation_keyframes_.Add();
}
inline ::bosdyn::api::spot::AnimationKeyframe* Animation::add_animation_keyframes() {
  ::bosdyn::api::spot::AnimationKeyframe* _add = _internal_add_animation_keyframes();
  // @@protoc_insertion_point(field_add:bosdyn.api.spot.Animation.animation_keyframes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot::AnimationKeyframe >&
Animation::animation_keyframes() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot.Animation.animation_keyframes)
  return _impl_.animation_keyframes_;
}

// bool controls_arm = 3;
inline void Animation::clear_controls_arm() {
  _impl_.controls_arm_ = false;
}
inline bool Animation::_internal_controls_arm() const {
  return _impl_.controls_arm_;
}
inline bool Animation::controls_arm() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.controls_arm)
  return _internal_controls_arm();
}
inline void Animation::_internal_set_controls_arm(bool value) {
  
  _impl_.controls_arm_ = value;
}
inline void Animation::set_controls_arm(bool value) {
  _internal_set_controls_arm(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.controls_arm)
}

// bool controls_legs = 4;
inline void Animation::clear_controls_legs() {
  _impl_.controls_legs_ = false;
}
inline bool Animation::_internal_controls_legs() const {
  return _impl_.controls_legs_;
}
inline bool Animation::controls_legs() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.controls_legs)
  return _internal_controls_legs();
}
inline void Animation::_internal_set_controls_legs(bool value) {
  
  _impl_.controls_legs_ = value;
}
inline void Animation::set_controls_legs(bool value) {
  _internal_set_controls_legs(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.controls_legs)
}

// bool controls_body = 5;
inline void Animation::clear_controls_body() {
  _impl_.controls_body_ = false;
}
inline bool Animation::_internal_controls_body() const {
  return _impl_.controls_body_;
}
inline bool Animation::controls_body() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.controls_body)
  return _internal_controls_body();
}
inline void Animation::_internal_set_controls_body(bool value) {
  
  _impl_.controls_body_ = value;
}
inline void Animation::set_controls_body(bool value) {
  _internal_set_controls_body(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.controls_body)
}

// bool controls_gripper = 6;
inline void Animation::clear_controls_gripper() {
  _impl_.controls_gripper_ = false;
}
inline bool Animation::_internal_controls_gripper() const {
  return _impl_.controls_gripper_;
}
inline bool Animation::controls_gripper() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.controls_gripper)
  return _internal_controls_gripper();
}
inline void Animation::_internal_set_controls_gripper(bool value) {
  
  _impl_.controls_gripper_ = value;
}
inline void Animation::set_controls_gripper(bool value) {
  _internal_set_controls_gripper(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.controls_gripper)
}

// bool track_swing_trajectories = 16;
inline void Animation::clear_track_swing_trajectories() {
  _impl_.track_swing_trajectories_ = false;
}
inline bool Animation::_internal_track_swing_trajectories() const {
  return _impl_.track_swing_trajectories_;
}
inline bool Animation::track_swing_trajectories() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.track_swing_trajectories)
  return _internal_track_swing_trajectories();
}
inline void Animation::_internal_set_track_swing_trajectories(bool value) {
  
  _impl_.track_swing_trajectories_ = value;
}
inline void Animation::set_track_swing_trajectories(bool value) {
  _internal_set_track_swing_trajectories(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.track_swing_trajectories)
}

// bool assume_zero_roll_and_pitch = 19;
inline void Animation::clear_assume_zero_roll_and_pitch() {
  _impl_.assume_zero_roll_and_pitch_ = false;
}
inline bool Animation::_internal_assume_zero_roll_and_pitch() const {
  return _impl_.assume_zero_roll_and_pitch_;
}
inline bool Animation::assume_zero_roll_and_pitch() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.assume_zero_roll_and_pitch)
  return _internal_assume_zero_roll_and_pitch();
}
inline void Animation::_internal_set_assume_zero_roll_and_pitch(bool value) {
  
  _impl_.assume_zero_roll_and_pitch_ = value;
}
inline void Animation::set_assume_zero_roll_and_pitch(bool value) {
  _internal_set_assume_zero_roll_and_pitch(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.assume_zero_roll_and_pitch)
}

// .bosdyn.api.spot.Animation.ArmPlayback arm_playback = 17;
inline void Animation::clear_arm_playback() {
  _impl_.arm_playback_ = 0;
}
inline ::bosdyn::api::spot::Animation_ArmPlayback Animation::_internal_arm_playback() const {
  return static_cast< ::bosdyn::api::spot::Animation_ArmPlayback >(_impl_.arm_playback_);
}
inline ::bosdyn::api::spot::Animation_ArmPlayback Animation::arm_playback() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.arm_playback)
  return _internal_arm_playback();
}
inline void Animation::_internal_set_arm_playback(::bosdyn::api::spot::Animation_ArmPlayback value) {
  
  _impl_.arm_playback_ = value;
}
inline void Animation::set_arm_playback(::bosdyn::api::spot::Animation_ArmPlayback value) {
  _internal_set_arm_playback(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.arm_playback)
}

// double bpm = 7;
inline void Animation::clear_bpm() {
  _impl_.bpm_ = 0;
}
inline double Animation::_internal_bpm() const {
  return _impl_.bpm_;
}
inline double Animation::bpm() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.bpm)
  return _internal_bpm();
}
inline void Animation::_internal_set_bpm(double value) {
  
  _impl_.bpm_ = value;
}
inline void Animation::set_bpm(double value) {
  _internal_set_bpm(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.bpm)
}

// bool retime_to_integer_slices = 8;
inline void Animation::clear_retime_to_integer_slices() {
  _impl_.retime_to_integer_slices_ = false;
}
inline bool Animation::_internal_retime_to_integer_slices() const {
  return _impl_.retime_to_integer_slices_;
}
inline bool Animation::retime_to_integer_slices() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.retime_to_integer_slices)
  return _internal_retime_to_integer_slices();
}
inline void Animation::_internal_set_retime_to_integer_slices(bool value) {
  
  _impl_.retime_to_integer_slices_ = value;
}
inline void Animation::set_retime_to_integer_slices(bool value) {
  _internal_set_retime_to_integer_slices(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.retime_to_integer_slices)
}

// .bosdyn.api.spot.AnimateParams minimum_parameters = 9;
inline bool Animation::_internal_has_minimum_parameters() const {
  return this != internal_default_instance() && _impl_.minimum_parameters_ != nullptr;
}
inline bool Animation::has_minimum_parameters() const {
  return _internal_has_minimum_parameters();
}
inline const ::bosdyn::api::spot::AnimateParams& Animation::_internal_minimum_parameters() const {
  const ::bosdyn::api::spot::AnimateParams* p = _impl_.minimum_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::AnimateParams&>(
      ::bosdyn::api::spot::_AnimateParams_default_instance_);
}
inline const ::bosdyn::api::spot::AnimateParams& Animation::minimum_parameters() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.minimum_parameters)
  return _internal_minimum_parameters();
}
inline void Animation::unsafe_arena_set_allocated_minimum_parameters(
    ::bosdyn::api::spot::AnimateParams* minimum_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.minimum_parameters_);
  }
  _impl_.minimum_parameters_ = minimum_parameters;
  if (minimum_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.Animation.minimum_parameters)
}
inline ::bosdyn::api::spot::AnimateParams* Animation::release_minimum_parameters() {
  
  ::bosdyn::api::spot::AnimateParams* temp = _impl_.minimum_parameters_;
  _impl_.minimum_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::AnimateParams* Animation::unsafe_arena_release_minimum_parameters() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.Animation.minimum_parameters)
  
  ::bosdyn::api::spot::AnimateParams* temp = _impl_.minimum_parameters_;
  _impl_.minimum_parameters_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::AnimateParams* Animation::_internal_mutable_minimum_parameters() {
  
  if (_impl_.minimum_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::AnimateParams>(GetArenaForAllocation());
    _impl_.minimum_parameters_ = p;
  }
  return _impl_.minimum_parameters_;
}
inline ::bosdyn::api::spot::AnimateParams* Animation::mutable_minimum_parameters() {
  ::bosdyn::api::spot::AnimateParams* _msg = _internal_mutable_minimum_parameters();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.Animation.minimum_parameters)
  return _msg;
}
inline void Animation::set_allocated_minimum_parameters(::bosdyn::api::spot::AnimateParams* minimum_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.minimum_parameters_);
  }
  if (minimum_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(minimum_parameters));
    if (message_arena != submessage_arena) {
      minimum_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minimum_parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.minimum_parameters_ = minimum_parameters;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.Animation.minimum_parameters)
}

// .bosdyn.api.spot.AnimateParams default_parameters = 10;
inline bool Animation::_internal_has_default_parameters() const {
  return this != internal_default_instance() && _impl_.default_parameters_ != nullptr;
}
inline bool Animation::has_default_parameters() const {
  return _internal_has_default_parameters();
}
inline const ::bosdyn::api::spot::AnimateParams& Animation::_internal_default_parameters() const {
  const ::bosdyn::api::spot::AnimateParams* p = _impl_.default_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::AnimateParams&>(
      ::bosdyn::api::spot::_AnimateParams_default_instance_);
}
inline const ::bosdyn::api::spot::AnimateParams& Animation::default_parameters() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.default_parameters)
  return _internal_default_parameters();
}
inline void Animation::unsafe_arena_set_allocated_default_parameters(
    ::bosdyn::api::spot::AnimateParams* default_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default_parameters_);
  }
  _impl_.default_parameters_ = default_parameters;
  if (default_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.Animation.default_parameters)
}
inline ::bosdyn::api::spot::AnimateParams* Animation::release_default_parameters() {
  
  ::bosdyn::api::spot::AnimateParams* temp = _impl_.default_parameters_;
  _impl_.default_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::AnimateParams* Animation::unsafe_arena_release_default_parameters() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.Animation.default_parameters)
  
  ::bosdyn::api::spot::AnimateParams* temp = _impl_.default_parameters_;
  _impl_.default_parameters_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::AnimateParams* Animation::_internal_mutable_default_parameters() {
  
  if (_impl_.default_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::AnimateParams>(GetArenaForAllocation());
    _impl_.default_parameters_ = p;
  }
  return _impl_.default_parameters_;
}
inline ::bosdyn::api::spot::AnimateParams* Animation::mutable_default_parameters() {
  ::bosdyn::api::spot::AnimateParams* _msg = _internal_mutable_default_parameters();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.Animation.default_parameters)
  return _msg;
}
inline void Animation::set_allocated_default_parameters(::bosdyn::api::spot::AnimateParams* default_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default_parameters_);
  }
  if (default_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(default_parameters));
    if (message_arena != submessage_arena) {
      default_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.default_parameters_ = default_parameters;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.Animation.default_parameters)
}

// .bosdyn.api.spot.AnimateParams maximum_parameters = 11;
inline bool Animation::_internal_has_maximum_parameters() const {
  return this != internal_default_instance() && _impl_.maximum_parameters_ != nullptr;
}
inline bool Animation::has_maximum_parameters() const {
  return _internal_has_maximum_parameters();
}
inline const ::bosdyn::api::spot::AnimateParams& Animation::_internal_maximum_parameters() const {
  const ::bosdyn::api::spot::AnimateParams* p = _impl_.maximum_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::AnimateParams&>(
      ::bosdyn::api::spot::_AnimateParams_default_instance_);
}
inline const ::bosdyn::api::spot::AnimateParams& Animation::maximum_parameters() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.maximum_parameters)
  return _internal_maximum_parameters();
}
inline void Animation::unsafe_arena_set_allocated_maximum_parameters(
    ::bosdyn::api::spot::AnimateParams* maximum_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maximum_parameters_);
  }
  _impl_.maximum_parameters_ = maximum_parameters;
  if (maximum_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.Animation.maximum_parameters)
}
inline ::bosdyn::api::spot::AnimateParams* Animation::release_maximum_parameters() {
  
  ::bosdyn::api::spot::AnimateParams* temp = _impl_.maximum_parameters_;
  _impl_.maximum_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::AnimateParams* Animation::unsafe_arena_release_maximum_parameters() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.Animation.maximum_parameters)
  
  ::bosdyn::api::spot::AnimateParams* temp = _impl_.maximum_parameters_;
  _impl_.maximum_parameters_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::AnimateParams* Animation::_internal_mutable_maximum_parameters() {
  
  if (_impl_.maximum_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::AnimateParams>(GetArenaForAllocation());
    _impl_.maximum_parameters_ = p;
  }
  return _impl_.maximum_parameters_;
}
inline ::bosdyn::api::spot::AnimateParams* Animation::mutable_maximum_parameters() {
  ::bosdyn::api::spot::AnimateParams* _msg = _internal_mutable_maximum_parameters();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.Animation.maximum_parameters)
  return _msg;
}
inline void Animation::set_allocated_maximum_parameters(::bosdyn::api::spot::AnimateParams* maximum_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maximum_parameters_);
  }
  if (maximum_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maximum_parameters));
    if (message_arena != submessage_arena) {
      maximum_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maximum_parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.maximum_parameters_ = maximum_parameters;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.Animation.maximum_parameters)
}

// bool truncatable = 12;
inline void Animation::clear_truncatable() {
  _impl_.truncatable_ = false;
}
inline bool Animation::_internal_truncatable() const {
  return _impl_.truncatable_;
}
inline bool Animation::truncatable() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.truncatable)
  return _internal_truncatable();
}
inline void Animation::_internal_set_truncatable(bool value) {
  
  _impl_.truncatable_ = value;
}
inline void Animation::set_truncatable(bool value) {
  _internal_set_truncatable(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.truncatable)
}

// bool extendable = 13;
inline void Animation::clear_extendable() {
  _impl_.extendable_ = false;
}
inline bool Animation::_internal_extendable() const {
  return _impl_.extendable_;
}
inline bool Animation::extendable() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.extendable)
  return _internal_extendable();
}
inline void Animation::_internal_set_extendable(bool value) {
  
  _impl_.extendable_ = value;
}
inline void Animation::set_extendable(bool value) {
  _internal_set_extendable(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.extendable)
}

// bool neutral_start = 14;
inline void Animation::clear_neutral_start() {
  _impl_.neutral_start_ = false;
}
inline bool Animation::_internal_neutral_start() const {
  return _impl_.neutral_start_;
}
inline bool Animation::neutral_start() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.neutral_start)
  return _internal_neutral_start();
}
inline void Animation::_internal_set_neutral_start(bool value) {
  
  _impl_.neutral_start_ = value;
}
inline void Animation::set_neutral_start(bool value) {
  _internal_set_neutral_start(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.neutral_start)
}

// bool precise_steps = 15;
inline void Animation::clear_precise_steps() {
  _impl_.precise_steps_ = false;
}
inline bool Animation::_internal_precise_steps() const {
  return _impl_.precise_steps_;
}
inline bool Animation::precise_steps() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.precise_steps)
  return _internal_precise_steps();
}
inline void Animation::_internal_set_precise_steps(bool value) {
  
  _impl_.precise_steps_ = value;
}
inline void Animation::set_precise_steps(bool value) {
  _internal_set_precise_steps(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.precise_steps)
}

// bool precise_timing = 18;
inline void Animation::clear_precise_timing() {
  _impl_.precise_timing_ = false;
}
inline bool Animation::_internal_precise_timing() const {
  return _impl_.precise_timing_;
}
inline bool Animation::precise_timing() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.precise_timing)
  return _internal_precise_timing();
}
inline void Animation::_internal_set_precise_timing(bool value) {
  
  _impl_.precise_timing_ = value;
}
inline void Animation::set_precise_timing(bool value) {
  _internal_set_precise_timing(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.precise_timing)
}

// bool arm_required = 20;
inline void Animation::clear_arm_required() {
  _impl_.arm_required_ = false;
}
inline bool Animation::_internal_arm_required() const {
  return _impl_.arm_required_;
}
inline bool Animation::arm_required() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.arm_required)
  return _internal_arm_required();
}
inline void Animation::_internal_set_arm_required(bool value) {
  
  _impl_.arm_required_ = value;
}
inline void Animation::set_arm_required(bool value) {
  _internal_set_arm_required(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.arm_required)
}

// bool arm_prohibited = 22;
inline void Animation::clear_arm_prohibited() {
  _impl_.arm_prohibited_ = false;
}
inline bool Animation::_internal_arm_prohibited() const {
  return _impl_.arm_prohibited_;
}
inline bool Animation::arm_prohibited() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.arm_prohibited)
  return _internal_arm_prohibited();
}
inline void Animation::_internal_set_arm_prohibited(bool value) {
  
  _impl_.arm_prohibited_ = value;
}
inline void Animation::set_arm_prohibited(bool value) {
  _internal_set_arm_prohibited(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.arm_prohibited)
}

// bool no_looping = 21;
inline void Animation::clear_no_looping() {
  _impl_.no_looping_ = false;
}
inline bool Animation::_internal_no_looping() const {
  return _impl_.no_looping_;
}
inline bool Animation::no_looping() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.Animation.no_looping)
  return _internal_no_looping();
}
inline void Animation::_internal_set_no_looping(bool value) {
  
  _impl_.no_looping_ = value;
}
inline void Animation::set_no_looping(bool value) {
  _internal_set_no_looping(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.Animation.no_looping)
}

// -------------------------------------------------------------------

// AnimationKeyframe

// double time = 1;
inline void AnimationKeyframe::clear_time() {
  _impl_.time_ = 0;
}
inline double AnimationKeyframe::_internal_time() const {
  return _impl_.time_;
}
inline double AnimationKeyframe::time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimationKeyframe.time)
  return _internal_time();
}
inline void AnimationKeyframe::_internal_set_time(double value) {
  
  _impl_.time_ = value;
}
inline void AnimationKeyframe::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.AnimationKeyframe.time)
}

// .bosdyn.api.spot.AnimateGripper gripper = 2;
inline bool AnimationKeyframe::_internal_has_gripper() const {
  return this != internal_default_instance() && _impl_.gripper_ != nullptr;
}
inline bool AnimationKeyframe::has_gripper() const {
  return _internal_has_gripper();
}
inline void AnimationKeyframe::clear_gripper() {
  if (GetArenaForAllocation() == nullptr && _impl_.gripper_ != nullptr) {
    delete _impl_.gripper_;
  }
  _impl_.gripper_ = nullptr;
}
inline const ::bosdyn::api::spot::AnimateGripper& AnimationKeyframe::_internal_gripper() const {
  const ::bosdyn::api::spot::AnimateGripper* p = _impl_.gripper_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::AnimateGripper&>(
      ::bosdyn::api::spot::_AnimateGripper_default_instance_);
}
inline const ::bosdyn::api::spot::AnimateGripper& AnimationKeyframe::gripper() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimationKeyframe.gripper)
  return _internal_gripper();
}
inline void AnimationKeyframe::unsafe_arena_set_allocated_gripper(
    ::bosdyn::api::spot::AnimateGripper* gripper) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gripper_);
  }
  _impl_.gripper_ = gripper;
  if (gripper) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimationKeyframe.gripper)
}
inline ::bosdyn::api::spot::AnimateGripper* AnimationKeyframe::release_gripper() {
  
  ::bosdyn::api::spot::AnimateGripper* temp = _impl_.gripper_;
  _impl_.gripper_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::AnimateGripper* AnimationKeyframe::unsafe_arena_release_gripper() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimationKeyframe.gripper)
  
  ::bosdyn::api::spot::AnimateGripper* temp = _impl_.gripper_;
  _impl_.gripper_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::AnimateGripper* AnimationKeyframe::_internal_mutable_gripper() {
  
  if (_impl_.gripper_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::AnimateGripper>(GetArenaForAllocation());
    _impl_.gripper_ = p;
  }
  return _impl_.gripper_;
}
inline ::bosdyn::api::spot::AnimateGripper* AnimationKeyframe::mutable_gripper() {
  ::bosdyn::api::spot::AnimateGripper* _msg = _internal_mutable_gripper();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimationKeyframe.gripper)
  return _msg;
}
inline void AnimationKeyframe::set_allocated_gripper(::bosdyn::api::spot::AnimateGripper* gripper) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gripper_;
  }
  if (gripper) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gripper);
    if (message_arena != submessage_arena) {
      gripper = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gripper, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.gripper_ = gripper;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.AnimationKeyframe.gripper)
}

// .bosdyn.api.spot.AnimateArm arm = 3;
inline bool AnimationKeyframe::_internal_has_arm() const {
  return this != internal_default_instance() && _impl_.arm_ != nullptr;
}
inline bool AnimationKeyframe::has_arm() const {
  return _internal_has_arm();
}
inline void AnimationKeyframe::clear_arm() {
  if (GetArenaForAllocation() == nullptr && _impl_.arm_ != nullptr) {
    delete _impl_.arm_;
  }
  _impl_.arm_ = nullptr;
}
inline const ::bosdyn::api::spot::AnimateArm& AnimationKeyframe::_internal_arm() const {
  const ::bosdyn::api::spot::AnimateArm* p = _impl_.arm_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::AnimateArm&>(
      ::bosdyn::api::spot::_AnimateArm_default_instance_);
}
inline const ::bosdyn::api::spot::AnimateArm& AnimationKeyframe::arm() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimationKeyframe.arm)
  return _internal_arm();
}
inline void AnimationKeyframe::unsafe_arena_set_allocated_arm(
    ::bosdyn::api::spot::AnimateArm* arm) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arm_);
  }
  _impl_.arm_ = arm;
  if (arm) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimationKeyframe.arm)
}
inline ::bosdyn::api::spot::AnimateArm* AnimationKeyframe::release_arm() {
  
  ::bosdyn::api::spot::AnimateArm* temp = _impl_.arm_;
  _impl_.arm_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::AnimateArm* AnimationKeyframe::unsafe_arena_release_arm() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimationKeyframe.arm)
  
  ::bosdyn::api::spot::AnimateArm* temp = _impl_.arm_;
  _impl_.arm_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::AnimateArm* AnimationKeyframe::_internal_mutable_arm() {
  
  if (_impl_.arm_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::AnimateArm>(GetArenaForAllocation());
    _impl_.arm_ = p;
  }
  return _impl_.arm_;
}
inline ::bosdyn::api::spot::AnimateArm* AnimationKeyframe::mutable_arm() {
  ::bosdyn::api::spot::AnimateArm* _msg = _internal_mutable_arm();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimationKeyframe.arm)
  return _msg;
}
inline void AnimationKeyframe::set_allocated_arm(::bosdyn::api::spot::AnimateArm* arm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.arm_;
  }
  if (arm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(arm);
    if (message_arena != submessage_arena) {
      arm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arm, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.arm_ = arm;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.AnimationKeyframe.arm)
}

// .bosdyn.api.spot.AnimateBody body = 4;
inline bool AnimationKeyframe::_internal_has_body() const {
  return this != internal_default_instance() && _impl_.body_ != nullptr;
}
inline bool AnimationKeyframe::has_body() const {
  return _internal_has_body();
}
inline void AnimationKeyframe::clear_body() {
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
}
inline const ::bosdyn::api::spot::AnimateBody& AnimationKeyframe::_internal_body() const {
  const ::bosdyn::api::spot::AnimateBody* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::AnimateBody&>(
      ::bosdyn::api::spot::_AnimateBody_default_instance_);
}
inline const ::bosdyn::api::spot::AnimateBody& AnimationKeyframe::body() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimationKeyframe.body)
  return _internal_body();
}
inline void AnimationKeyframe::unsafe_arena_set_allocated_body(
    ::bosdyn::api::spot::AnimateBody* body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = body;
  if (body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimationKeyframe.body)
}
inline ::bosdyn::api::spot::AnimateBody* AnimationKeyframe::release_body() {
  
  ::bosdyn::api::spot::AnimateBody* temp = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::AnimateBody* AnimationKeyframe::unsafe_arena_release_body() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimationKeyframe.body)
  
  ::bosdyn::api::spot::AnimateBody* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::AnimateBody* AnimationKeyframe::_internal_mutable_body() {
  
  if (_impl_.body_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::AnimateBody>(GetArenaForAllocation());
    _impl_.body_ = p;
  }
  return _impl_.body_;
}
inline ::bosdyn::api::spot::AnimateBody* AnimationKeyframe::mutable_body() {
  ::bosdyn::api::spot::AnimateBody* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimationKeyframe.body)
  return _msg;
}
inline void AnimationKeyframe::set_allocated_body(::bosdyn::api::spot::AnimateBody* body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.body_;
  }
  if (body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body);
    if (message_arena != submessage_arena) {
      body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.body_ = body;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.AnimationKeyframe.body)
}

// .bosdyn.api.spot.AnimateLegs legs = 5;
inline bool AnimationKeyframe::_internal_has_legs() const {
  return this != internal_default_instance() && _impl_.legs_ != nullptr;
}
inline bool AnimationKeyframe::has_legs() const {
  return _internal_has_legs();
}
inline void AnimationKeyframe::clear_legs() {
  if (GetArenaForAllocation() == nullptr && _impl_.legs_ != nullptr) {
    delete _impl_.legs_;
  }
  _impl_.legs_ = nullptr;
}
inline const ::bosdyn::api::spot::AnimateLegs& AnimationKeyframe::_internal_legs() const {
  const ::bosdyn::api::spot::AnimateLegs* p = _impl_.legs_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::AnimateLegs&>(
      ::bosdyn::api::spot::_AnimateLegs_default_instance_);
}
inline const ::bosdyn::api::spot::AnimateLegs& AnimationKeyframe::legs() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimationKeyframe.legs)
  return _internal_legs();
}
inline void AnimationKeyframe::unsafe_arena_set_allocated_legs(
    ::bosdyn::api::spot::AnimateLegs* legs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.legs_);
  }
  _impl_.legs_ = legs;
  if (legs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimationKeyframe.legs)
}
inline ::bosdyn::api::spot::AnimateLegs* AnimationKeyframe::release_legs() {
  
  ::bosdyn::api::spot::AnimateLegs* temp = _impl_.legs_;
  _impl_.legs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::AnimateLegs* AnimationKeyframe::unsafe_arena_release_legs() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimationKeyframe.legs)
  
  ::bosdyn::api::spot::AnimateLegs* temp = _impl_.legs_;
  _impl_.legs_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::AnimateLegs* AnimationKeyframe::_internal_mutable_legs() {
  
  if (_impl_.legs_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::AnimateLegs>(GetArenaForAllocation());
    _impl_.legs_ = p;
  }
  return _impl_.legs_;
}
inline ::bosdyn::api::spot::AnimateLegs* AnimationKeyframe::mutable_legs() {
  ::bosdyn::api::spot::AnimateLegs* _msg = _internal_mutable_legs();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimationKeyframe.legs)
  return _msg;
}
inline void AnimationKeyframe::set_allocated_legs(::bosdyn::api::spot::AnimateLegs* legs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.legs_;
  }
  if (legs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(legs);
    if (message_arena != submessage_arena) {
      legs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, legs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.legs_ = legs;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.AnimationKeyframe.legs)
}

// -------------------------------------------------------------------

// AnimateGripper

// .google.protobuf.DoubleValue gripper_angle = 1;
inline bool AnimateGripper::_internal_has_gripper_angle() const {
  return this != internal_default_instance() && _impl_.gripper_angle_ != nullptr;
}
inline bool AnimateGripper::has_gripper_angle() const {
  return _internal_has_gripper_angle();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& AnimateGripper::_internal_gripper_angle() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.gripper_angle_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& AnimateGripper::gripper_angle() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateGripper.gripper_angle)
  return _internal_gripper_angle();
}
inline void AnimateGripper::unsafe_arena_set_allocated_gripper_angle(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* gripper_angle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gripper_angle_);
  }
  _impl_.gripper_angle_ = gripper_angle;
  if (gripper_angle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateGripper.gripper_angle)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* AnimateGripper::release_gripper_angle() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.gripper_angle_;
  _impl_.gripper_angle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* AnimateGripper::unsafe_arena_release_gripper_angle() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateGripper.gripper_angle)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.gripper_angle_;
  _impl_.gripper_angle_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* AnimateGripper::_internal_mutable_gripper_angle() {
  
  if (_impl_.gripper_angle_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.gripper_angle_ = p;
  }
  return _impl_.gripper_angle_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* AnimateGripper::mutable_gripper_angle() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_gripper_angle();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateGripper.gripper_angle)
  return _msg;
}
inline void AnimateGripper::set_allocated_gripper_angle(::PROTOBUF_NAMESPACE_ID::DoubleValue* gripper_angle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gripper_angle_);
  }
  if (gripper_angle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gripper_angle));
    if (message_arena != submessage_arena) {
      gripper_angle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gripper_angle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.gripper_angle_ = gripper_angle;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.AnimateGripper.gripper_angle)
}

// -------------------------------------------------------------------

// AnimateArm_HandPose

// .bosdyn.api.Vec3Value position = 1;
inline bool AnimateArm_HandPose::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool AnimateArm_HandPose::has_position() const {
  return _internal_has_position();
}
inline const ::bosdyn::api::Vec3Value& AnimateArm_HandPose::_internal_position() const {
  const ::bosdyn::api::Vec3Value* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::Vec3Value&>(
      ::bosdyn::api::_Vec3Value_default_instance_);
}
inline const ::bosdyn::api::Vec3Value& AnimateArm_HandPose::position() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateArm.HandPose.position)
  return _internal_position();
}
inline void AnimateArm_HandPose::unsafe_arena_set_allocated_position(
    ::bosdyn::api::Vec3Value* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateArm.HandPose.position)
}
inline ::bosdyn::api::Vec3Value* AnimateArm_HandPose::release_position() {
  
  ::bosdyn::api::Vec3Value* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::Vec3Value* AnimateArm_HandPose::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateArm.HandPose.position)
  
  ::bosdyn::api::Vec3Value* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3Value* AnimateArm_HandPose::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3Value>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::bosdyn::api::Vec3Value* AnimateArm_HandPose::mutable_position() {
  ::bosdyn::api::Vec3Value* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateArm.HandPose.position)
  return _msg;
}
inline void AnimateArm_HandPose::set_allocated_position(::bosdyn::api::Vec3Value* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.AnimateArm.HandPose.position)
}

// .bosdyn.api.spot.EulerZYXValue euler_angles = 3;
inline bool AnimateArm_HandPose::_internal_has_euler_angles() const {
  return orientation_case() == kEulerAngles;
}
inline bool AnimateArm_HandPose::has_euler_angles() const {
  return _internal_has_euler_angles();
}
inline void AnimateArm_HandPose::set_has_euler_angles() {
  _impl_._oneof_case_[0] = kEulerAngles;
}
inline ::bosdyn::api::spot::EulerZYXValue* AnimateArm_HandPose::release_euler_angles() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateArm.HandPose.euler_angles)
  if (_internal_has_euler_angles()) {
    clear_has_orientation();
    ::bosdyn::api::spot::EulerZYXValue* temp = _impl_.orientation_.euler_angles_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.orientation_.euler_angles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::EulerZYXValue& AnimateArm_HandPose::_internal_euler_angles() const {
  return _internal_has_euler_angles()
      ? *_impl_.orientation_.euler_angles_
      : reinterpret_cast< ::bosdyn::api::spot::EulerZYXValue&>(::bosdyn::api::spot::_EulerZYXValue_default_instance_);
}
inline const ::bosdyn::api::spot::EulerZYXValue& AnimateArm_HandPose::euler_angles() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateArm.HandPose.euler_angles)
  return _internal_euler_angles();
}
inline ::bosdyn::api::spot::EulerZYXValue* AnimateArm_HandPose::unsafe_arena_release_euler_angles() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.AnimateArm.HandPose.euler_angles)
  if (_internal_has_euler_angles()) {
    clear_has_orientation();
    ::bosdyn::api::spot::EulerZYXValue* temp = _impl_.orientation_.euler_angles_;
    _impl_.orientation_.euler_angles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnimateArm_HandPose::unsafe_arena_set_allocated_euler_angles(::bosdyn::api::spot::EulerZYXValue* euler_angles) {
  clear_orientation();
  if (euler_angles) {
    set_has_euler_angles();
    _impl_.orientation_.euler_angles_ = euler_angles;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateArm.HandPose.euler_angles)
}
inline ::bosdyn::api::spot::EulerZYXValue* AnimateArm_HandPose::_internal_mutable_euler_angles() {
  if (!_internal_has_euler_angles()) {
    clear_orientation();
    set_has_euler_angles();
    _impl_.orientation_.euler_angles_ = CreateMaybeMessage< ::bosdyn::api::spot::EulerZYXValue >(GetArenaForAllocation());
  }
  return _impl_.orientation_.euler_angles_;
}
inline ::bosdyn::api::spot::EulerZYXValue* AnimateArm_HandPose::mutable_euler_angles() {
  ::bosdyn::api::spot::EulerZYXValue* _msg = _internal_mutable_euler_angles();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateArm.HandPose.euler_angles)
  return _msg;
}

// .bosdyn.api.Quaternion quaternion = 4;
inline bool AnimateArm_HandPose::_internal_has_quaternion() const {
  return orientation_case() == kQuaternion;
}
inline bool AnimateArm_HandPose::has_quaternion() const {
  return _internal_has_quaternion();
}
inline void AnimateArm_HandPose::set_has_quaternion() {
  _impl_._oneof_case_[0] = kQuaternion;
}
inline ::bosdyn::api::Quaternion* AnimateArm_HandPose::release_quaternion() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateArm.HandPose.quaternion)
  if (_internal_has_quaternion()) {
    clear_has_orientation();
    ::bosdyn::api::Quaternion* temp = _impl_.orientation_.quaternion_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.orientation_.quaternion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::Quaternion& AnimateArm_HandPose::_internal_quaternion() const {
  return _internal_has_quaternion()
      ? *_impl_.orientation_.quaternion_
      : reinterpret_cast< ::bosdyn::api::Quaternion&>(::bosdyn::api::_Quaternion_default_instance_);
}
inline const ::bosdyn::api::Quaternion& AnimateArm_HandPose::quaternion() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateArm.HandPose.quaternion)
  return _internal_quaternion();
}
inline ::bosdyn::api::Quaternion* AnimateArm_HandPose::unsafe_arena_release_quaternion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.AnimateArm.HandPose.quaternion)
  if (_internal_has_quaternion()) {
    clear_has_orientation();
    ::bosdyn::api::Quaternion* temp = _impl_.orientation_.quaternion_;
    _impl_.orientation_.quaternion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnimateArm_HandPose::unsafe_arena_set_allocated_quaternion(::bosdyn::api::Quaternion* quaternion) {
  clear_orientation();
  if (quaternion) {
    set_has_quaternion();
    _impl_.orientation_.quaternion_ = quaternion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateArm.HandPose.quaternion)
}
inline ::bosdyn::api::Quaternion* AnimateArm_HandPose::_internal_mutable_quaternion() {
  if (!_internal_has_quaternion()) {
    clear_orientation();
    set_has_quaternion();
    _impl_.orientation_.quaternion_ = CreateMaybeMessage< ::bosdyn::api::Quaternion >(GetArenaForAllocation());
  }
  return _impl_.orientation_.quaternion_;
}
inline ::bosdyn::api::Quaternion* AnimateArm_HandPose::mutable_quaternion() {
  ::bosdyn::api::Quaternion* _msg = _internal_mutable_quaternion();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateArm.HandPose.quaternion)
  return _msg;
}

inline bool AnimateArm_HandPose::has_orientation() const {
  return orientation_case() != ORIENTATION_NOT_SET;
}
inline void AnimateArm_HandPose::clear_has_orientation() {
  _impl_._oneof_case_[0] = ORIENTATION_NOT_SET;
}
inline AnimateArm_HandPose::OrientationCase AnimateArm_HandPose::orientation_case() const {
  return AnimateArm_HandPose::OrientationCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnimateArm

// .bosdyn.api.spot.ArmJointAngles joint_angles = 1;
inline bool AnimateArm::_internal_has_joint_angles() const {
  return arm_case() == kJointAngles;
}
inline bool AnimateArm::has_joint_angles() const {
  return _internal_has_joint_angles();
}
inline void AnimateArm::set_has_joint_angles() {
  _impl_._oneof_case_[0] = kJointAngles;
}
inline void AnimateArm::clear_joint_angles() {
  if (_internal_has_joint_angles()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.arm_.joint_angles_;
    }
    clear_has_arm();
  }
}
inline ::bosdyn::api::spot::ArmJointAngles* AnimateArm::release_joint_angles() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateArm.joint_angles)
  if (_internal_has_joint_angles()) {
    clear_has_arm();
    ::bosdyn::api::spot::ArmJointAngles* temp = _impl_.arm_.joint_angles_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.arm_.joint_angles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::ArmJointAngles& AnimateArm::_internal_joint_angles() const {
  return _internal_has_joint_angles()
      ? *_impl_.arm_.joint_angles_
      : reinterpret_cast< ::bosdyn::api::spot::ArmJointAngles&>(::bosdyn::api::spot::_ArmJointAngles_default_instance_);
}
inline const ::bosdyn::api::spot::ArmJointAngles& AnimateArm::joint_angles() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateArm.joint_angles)
  return _internal_joint_angles();
}
inline ::bosdyn::api::spot::ArmJointAngles* AnimateArm::unsafe_arena_release_joint_angles() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.AnimateArm.joint_angles)
  if (_internal_has_joint_angles()) {
    clear_has_arm();
    ::bosdyn::api::spot::ArmJointAngles* temp = _impl_.arm_.joint_angles_;
    _impl_.arm_.joint_angles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnimateArm::unsafe_arena_set_allocated_joint_angles(::bosdyn::api::spot::ArmJointAngles* joint_angles) {
  clear_arm();
  if (joint_angles) {
    set_has_joint_angles();
    _impl_.arm_.joint_angles_ = joint_angles;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateArm.joint_angles)
}
inline ::bosdyn::api::spot::ArmJointAngles* AnimateArm::_internal_mutable_joint_angles() {
  if (!_internal_has_joint_angles()) {
    clear_arm();
    set_has_joint_angles();
    _impl_.arm_.joint_angles_ = CreateMaybeMessage< ::bosdyn::api::spot::ArmJointAngles >(GetArenaForAllocation());
  }
  return _impl_.arm_.joint_angles_;
}
inline ::bosdyn::api::spot::ArmJointAngles* AnimateArm::mutable_joint_angles() {
  ::bosdyn::api::spot::ArmJointAngles* _msg = _internal_mutable_joint_angles();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateArm.joint_angles)
  return _msg;
}

// .bosdyn.api.spot.AnimateArm.HandPose hand_pose = 2;
inline bool AnimateArm::_internal_has_hand_pose() const {
  return arm_case() == kHandPose;
}
inline bool AnimateArm::has_hand_pose() const {
  return _internal_has_hand_pose();
}
inline void AnimateArm::set_has_hand_pose() {
  _impl_._oneof_case_[0] = kHandPose;
}
inline void AnimateArm::clear_hand_pose() {
  if (_internal_has_hand_pose()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.arm_.hand_pose_;
    }
    clear_has_arm();
  }
}
inline ::bosdyn::api::spot::AnimateArm_HandPose* AnimateArm::release_hand_pose() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateArm.hand_pose)
  if (_internal_has_hand_pose()) {
    clear_has_arm();
    ::bosdyn::api::spot::AnimateArm_HandPose* temp = _impl_.arm_.hand_pose_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.arm_.hand_pose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::AnimateArm_HandPose& AnimateArm::_internal_hand_pose() const {
  return _internal_has_hand_pose()
      ? *_impl_.arm_.hand_pose_
      : reinterpret_cast< ::bosdyn::api::spot::AnimateArm_HandPose&>(::bosdyn::api::spot::_AnimateArm_HandPose_default_instance_);
}
inline const ::bosdyn::api::spot::AnimateArm_HandPose& AnimateArm::hand_pose() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateArm.hand_pose)
  return _internal_hand_pose();
}
inline ::bosdyn::api::spot::AnimateArm_HandPose* AnimateArm::unsafe_arena_release_hand_pose() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.AnimateArm.hand_pose)
  if (_internal_has_hand_pose()) {
    clear_has_arm();
    ::bosdyn::api::spot::AnimateArm_HandPose* temp = _impl_.arm_.hand_pose_;
    _impl_.arm_.hand_pose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnimateArm::unsafe_arena_set_allocated_hand_pose(::bosdyn::api::spot::AnimateArm_HandPose* hand_pose) {
  clear_arm();
  if (hand_pose) {
    set_has_hand_pose();
    _impl_.arm_.hand_pose_ = hand_pose;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateArm.hand_pose)
}
inline ::bosdyn::api::spot::AnimateArm_HandPose* AnimateArm::_internal_mutable_hand_pose() {
  if (!_internal_has_hand_pose()) {
    clear_arm();
    set_has_hand_pose();
    _impl_.arm_.hand_pose_ = CreateMaybeMessage< ::bosdyn::api::spot::AnimateArm_HandPose >(GetArenaForAllocation());
  }
  return _impl_.arm_.hand_pose_;
}
inline ::bosdyn::api::spot::AnimateArm_HandPose* AnimateArm::mutable_hand_pose() {
  ::bosdyn::api::spot::AnimateArm_HandPose* _msg = _internal_mutable_hand_pose();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateArm.hand_pose)
  return _msg;
}

inline bool AnimateArm::has_arm() const {
  return arm_case() != ARM_NOT_SET;
}
inline void AnimateArm::clear_has_arm() {
  _impl_._oneof_case_[0] = ARM_NOT_SET;
}
inline AnimateArm::ArmCase AnimateArm::arm_case() const {
  return AnimateArm::ArmCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ArmJointAngles

// .google.protobuf.DoubleValue shoulder_0 = 1;
inline bool ArmJointAngles::_internal_has_shoulder_0() const {
  return this != internal_default_instance() && _impl_.shoulder_0_ != nullptr;
}
inline bool ArmJointAngles::has_shoulder_0() const {
  return _internal_has_shoulder_0();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ArmJointAngles::_internal_shoulder_0() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.shoulder_0_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ArmJointAngles::shoulder_0() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ArmJointAngles.shoulder_0)
  return _internal_shoulder_0();
}
inline void ArmJointAngles::unsafe_arena_set_allocated_shoulder_0(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* shoulder_0) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shoulder_0_);
  }
  _impl_.shoulder_0_ = shoulder_0;
  if (shoulder_0) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ArmJointAngles.shoulder_0)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::release_shoulder_0() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.shoulder_0_;
  _impl_.shoulder_0_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::unsafe_arena_release_shoulder_0() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ArmJointAngles.shoulder_0)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.shoulder_0_;
  _impl_.shoulder_0_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::_internal_mutable_shoulder_0() {
  
  if (_impl_.shoulder_0_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.shoulder_0_ = p;
  }
  return _impl_.shoulder_0_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::mutable_shoulder_0() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_shoulder_0();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ArmJointAngles.shoulder_0)
  return _msg;
}
inline void ArmJointAngles::set_allocated_shoulder_0(::PROTOBUF_NAMESPACE_ID::DoubleValue* shoulder_0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shoulder_0_);
  }
  if (shoulder_0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shoulder_0));
    if (message_arena != submessage_arena) {
      shoulder_0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shoulder_0, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.shoulder_0_ = shoulder_0;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ArmJointAngles.shoulder_0)
}

// .google.protobuf.DoubleValue shoulder_1 = 2;
inline bool ArmJointAngles::_internal_has_shoulder_1() const {
  return this != internal_default_instance() && _impl_.shoulder_1_ != nullptr;
}
inline bool ArmJointAngles::has_shoulder_1() const {
  return _internal_has_shoulder_1();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ArmJointAngles::_internal_shoulder_1() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.shoulder_1_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ArmJointAngles::shoulder_1() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ArmJointAngles.shoulder_1)
  return _internal_shoulder_1();
}
inline void ArmJointAngles::unsafe_arena_set_allocated_shoulder_1(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* shoulder_1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shoulder_1_);
  }
  _impl_.shoulder_1_ = shoulder_1;
  if (shoulder_1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ArmJointAngles.shoulder_1)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::release_shoulder_1() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.shoulder_1_;
  _impl_.shoulder_1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::unsafe_arena_release_shoulder_1() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ArmJointAngles.shoulder_1)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.shoulder_1_;
  _impl_.shoulder_1_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::_internal_mutable_shoulder_1() {
  
  if (_impl_.shoulder_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.shoulder_1_ = p;
  }
  return _impl_.shoulder_1_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::mutable_shoulder_1() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_shoulder_1();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ArmJointAngles.shoulder_1)
  return _msg;
}
inline void ArmJointAngles::set_allocated_shoulder_1(::PROTOBUF_NAMESPACE_ID::DoubleValue* shoulder_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shoulder_1_);
  }
  if (shoulder_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shoulder_1));
    if (message_arena != submessage_arena) {
      shoulder_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shoulder_1, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.shoulder_1_ = shoulder_1;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ArmJointAngles.shoulder_1)
}

// .google.protobuf.DoubleValue elbow_0 = 3;
inline bool ArmJointAngles::_internal_has_elbow_0() const {
  return this != internal_default_instance() && _impl_.elbow_0_ != nullptr;
}
inline bool ArmJointAngles::has_elbow_0() const {
  return _internal_has_elbow_0();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ArmJointAngles::_internal_elbow_0() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.elbow_0_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ArmJointAngles::elbow_0() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ArmJointAngles.elbow_0)
  return _internal_elbow_0();
}
inline void ArmJointAngles::unsafe_arena_set_allocated_elbow_0(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* elbow_0) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.elbow_0_);
  }
  _impl_.elbow_0_ = elbow_0;
  if (elbow_0) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ArmJointAngles.elbow_0)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::release_elbow_0() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.elbow_0_;
  _impl_.elbow_0_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::unsafe_arena_release_elbow_0() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ArmJointAngles.elbow_0)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.elbow_0_;
  _impl_.elbow_0_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::_internal_mutable_elbow_0() {
  
  if (_impl_.elbow_0_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.elbow_0_ = p;
  }
  return _impl_.elbow_0_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::mutable_elbow_0() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_elbow_0();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ArmJointAngles.elbow_0)
  return _msg;
}
inline void ArmJointAngles::set_allocated_elbow_0(::PROTOBUF_NAMESPACE_ID::DoubleValue* elbow_0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.elbow_0_);
  }
  if (elbow_0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(elbow_0));
    if (message_arena != submessage_arena) {
      elbow_0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, elbow_0, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.elbow_0_ = elbow_0;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ArmJointAngles.elbow_0)
}

// .google.protobuf.DoubleValue elbow_1 = 4;
inline bool ArmJointAngles::_internal_has_elbow_1() const {
  return this != internal_default_instance() && _impl_.elbow_1_ != nullptr;
}
inline bool ArmJointAngles::has_elbow_1() const {
  return _internal_has_elbow_1();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ArmJointAngles::_internal_elbow_1() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.elbow_1_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ArmJointAngles::elbow_1() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ArmJointAngles.elbow_1)
  return _internal_elbow_1();
}
inline void ArmJointAngles::unsafe_arena_set_allocated_elbow_1(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* elbow_1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.elbow_1_);
  }
  _impl_.elbow_1_ = elbow_1;
  if (elbow_1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ArmJointAngles.elbow_1)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::release_elbow_1() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.elbow_1_;
  _impl_.elbow_1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::unsafe_arena_release_elbow_1() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ArmJointAngles.elbow_1)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.elbow_1_;
  _impl_.elbow_1_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::_internal_mutable_elbow_1() {
  
  if (_impl_.elbow_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.elbow_1_ = p;
  }
  return _impl_.elbow_1_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::mutable_elbow_1() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_elbow_1();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ArmJointAngles.elbow_1)
  return _msg;
}
inline void ArmJointAngles::set_allocated_elbow_1(::PROTOBUF_NAMESPACE_ID::DoubleValue* elbow_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.elbow_1_);
  }
  if (elbow_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(elbow_1));
    if (message_arena != submessage_arena) {
      elbow_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, elbow_1, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.elbow_1_ = elbow_1;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ArmJointAngles.elbow_1)
}

// .google.protobuf.DoubleValue wrist_0 = 5;
inline bool ArmJointAngles::_internal_has_wrist_0() const {
  return this != internal_default_instance() && _impl_.wrist_0_ != nullptr;
}
inline bool ArmJointAngles::has_wrist_0() const {
  return _internal_has_wrist_0();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ArmJointAngles::_internal_wrist_0() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.wrist_0_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ArmJointAngles::wrist_0() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ArmJointAngles.wrist_0)
  return _internal_wrist_0();
}
inline void ArmJointAngles::unsafe_arena_set_allocated_wrist_0(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* wrist_0) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wrist_0_);
  }
  _impl_.wrist_0_ = wrist_0;
  if (wrist_0) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ArmJointAngles.wrist_0)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::release_wrist_0() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.wrist_0_;
  _impl_.wrist_0_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::unsafe_arena_release_wrist_0() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ArmJointAngles.wrist_0)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.wrist_0_;
  _impl_.wrist_0_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::_internal_mutable_wrist_0() {
  
  if (_impl_.wrist_0_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.wrist_0_ = p;
  }
  return _impl_.wrist_0_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::mutable_wrist_0() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_wrist_0();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ArmJointAngles.wrist_0)
  return _msg;
}
inline void ArmJointAngles::set_allocated_wrist_0(::PROTOBUF_NAMESPACE_ID::DoubleValue* wrist_0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wrist_0_);
  }
  if (wrist_0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wrist_0));
    if (message_arena != submessage_arena) {
      wrist_0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wrist_0, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.wrist_0_ = wrist_0;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ArmJointAngles.wrist_0)
}

// .google.protobuf.DoubleValue wrist_1 = 6;
inline bool ArmJointAngles::_internal_has_wrist_1() const {
  return this != internal_default_instance() && _impl_.wrist_1_ != nullptr;
}
inline bool ArmJointAngles::has_wrist_1() const {
  return _internal_has_wrist_1();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ArmJointAngles::_internal_wrist_1() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.wrist_1_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ArmJointAngles::wrist_1() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.ArmJointAngles.wrist_1)
  return _internal_wrist_1();
}
inline void ArmJointAngles::unsafe_arena_set_allocated_wrist_1(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* wrist_1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wrist_1_);
  }
  _impl_.wrist_1_ = wrist_1;
  if (wrist_1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.ArmJointAngles.wrist_1)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::release_wrist_1() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.wrist_1_;
  _impl_.wrist_1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::unsafe_arena_release_wrist_1() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.ArmJointAngles.wrist_1)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.wrist_1_;
  _impl_.wrist_1_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::_internal_mutable_wrist_1() {
  
  if (_impl_.wrist_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.wrist_1_ = p;
  }
  return _impl_.wrist_1_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* ArmJointAngles::mutable_wrist_1() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_wrist_1();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.ArmJointAngles.wrist_1)
  return _msg;
}
inline void ArmJointAngles::set_allocated_wrist_1(::PROTOBUF_NAMESPACE_ID::DoubleValue* wrist_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wrist_1_);
  }
  if (wrist_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wrist_1));
    if (message_arena != submessage_arena) {
      wrist_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wrist_1, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.wrist_1_ = wrist_1;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.ArmJointAngles.wrist_1)
}

// -------------------------------------------------------------------

// AnimateBody

// .bosdyn.api.Vec3Value body_pos = 1;
inline bool AnimateBody::_internal_has_body_pos() const {
  return position_case() == kBodyPos;
}
inline bool AnimateBody::has_body_pos() const {
  return _internal_has_body_pos();
}
inline void AnimateBody::set_has_body_pos() {
  _impl_._oneof_case_[0] = kBodyPos;
}
inline ::bosdyn::api::Vec3Value* AnimateBody::release_body_pos() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateBody.body_pos)
  if (_internal_has_body_pos()) {
    clear_has_position();
    ::bosdyn::api::Vec3Value* temp = _impl_.position_.body_pos_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.position_.body_pos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::Vec3Value& AnimateBody::_internal_body_pos() const {
  return _internal_has_body_pos()
      ? *_impl_.position_.body_pos_
      : reinterpret_cast< ::bosdyn::api::Vec3Value&>(::bosdyn::api::_Vec3Value_default_instance_);
}
inline const ::bosdyn::api::Vec3Value& AnimateBody::body_pos() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateBody.body_pos)
  return _internal_body_pos();
}
inline ::bosdyn::api::Vec3Value* AnimateBody::unsafe_arena_release_body_pos() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.AnimateBody.body_pos)
  if (_internal_has_body_pos()) {
    clear_has_position();
    ::bosdyn::api::Vec3Value* temp = _impl_.position_.body_pos_;
    _impl_.position_.body_pos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnimateBody::unsafe_arena_set_allocated_body_pos(::bosdyn::api::Vec3Value* body_pos) {
  clear_position();
  if (body_pos) {
    set_has_body_pos();
    _impl_.position_.body_pos_ = body_pos;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateBody.body_pos)
}
inline ::bosdyn::api::Vec3Value* AnimateBody::_internal_mutable_body_pos() {
  if (!_internal_has_body_pos()) {
    clear_position();
    set_has_body_pos();
    _impl_.position_.body_pos_ = CreateMaybeMessage< ::bosdyn::api::Vec3Value >(GetArenaForAllocation());
  }
  return _impl_.position_.body_pos_;
}
inline ::bosdyn::api::Vec3Value* AnimateBody::mutable_body_pos() {
  ::bosdyn::api::Vec3Value* _msg = _internal_mutable_body_pos();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateBody.body_pos)
  return _msg;
}

// .bosdyn.api.Vec3Value com_pos = 2;
inline bool AnimateBody::_internal_has_com_pos() const {
  return position_case() == kComPos;
}
inline bool AnimateBody::has_com_pos() const {
  return _internal_has_com_pos();
}
inline void AnimateBody::set_has_com_pos() {
  _impl_._oneof_case_[0] = kComPos;
}
inline ::bosdyn::api::Vec3Value* AnimateBody::release_com_pos() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateBody.com_pos)
  if (_internal_has_com_pos()) {
    clear_has_position();
    ::bosdyn::api::Vec3Value* temp = _impl_.position_.com_pos_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.position_.com_pos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::Vec3Value& AnimateBody::_internal_com_pos() const {
  return _internal_has_com_pos()
      ? *_impl_.position_.com_pos_
      : reinterpret_cast< ::bosdyn::api::Vec3Value&>(::bosdyn::api::_Vec3Value_default_instance_);
}
inline const ::bosdyn::api::Vec3Value& AnimateBody::com_pos() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateBody.com_pos)
  return _internal_com_pos();
}
inline ::bosdyn::api::Vec3Value* AnimateBody::unsafe_arena_release_com_pos() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.AnimateBody.com_pos)
  if (_internal_has_com_pos()) {
    clear_has_position();
    ::bosdyn::api::Vec3Value* temp = _impl_.position_.com_pos_;
    _impl_.position_.com_pos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnimateBody::unsafe_arena_set_allocated_com_pos(::bosdyn::api::Vec3Value* com_pos) {
  clear_position();
  if (com_pos) {
    set_has_com_pos();
    _impl_.position_.com_pos_ = com_pos;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateBody.com_pos)
}
inline ::bosdyn::api::Vec3Value* AnimateBody::_internal_mutable_com_pos() {
  if (!_internal_has_com_pos()) {
    clear_position();
    set_has_com_pos();
    _impl_.position_.com_pos_ = CreateMaybeMessage< ::bosdyn::api::Vec3Value >(GetArenaForAllocation());
  }
  return _impl_.position_.com_pos_;
}
inline ::bosdyn::api::Vec3Value* AnimateBody::mutable_com_pos() {
  ::bosdyn::api::Vec3Value* _msg = _internal_mutable_com_pos();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateBody.com_pos)
  return _msg;
}

// .bosdyn.api.spot.EulerZYXValue euler_angles = 3;
inline bool AnimateBody::_internal_has_euler_angles() const {
  return orientation_case() == kEulerAngles;
}
inline bool AnimateBody::has_euler_angles() const {
  return _internal_has_euler_angles();
}
inline void AnimateBody::set_has_euler_angles() {
  _impl_._oneof_case_[1] = kEulerAngles;
}
inline ::bosdyn::api::spot::EulerZYXValue* AnimateBody::release_euler_angles() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateBody.euler_angles)
  if (_internal_has_euler_angles()) {
    clear_has_orientation();
    ::bosdyn::api::spot::EulerZYXValue* temp = _impl_.orientation_.euler_angles_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.orientation_.euler_angles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::EulerZYXValue& AnimateBody::_internal_euler_angles() const {
  return _internal_has_euler_angles()
      ? *_impl_.orientation_.euler_angles_
      : reinterpret_cast< ::bosdyn::api::spot::EulerZYXValue&>(::bosdyn::api::spot::_EulerZYXValue_default_instance_);
}
inline const ::bosdyn::api::spot::EulerZYXValue& AnimateBody::euler_angles() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateBody.euler_angles)
  return _internal_euler_angles();
}
inline ::bosdyn::api::spot::EulerZYXValue* AnimateBody::unsafe_arena_release_euler_angles() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.AnimateBody.euler_angles)
  if (_internal_has_euler_angles()) {
    clear_has_orientation();
    ::bosdyn::api::spot::EulerZYXValue* temp = _impl_.orientation_.euler_angles_;
    _impl_.orientation_.euler_angles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnimateBody::unsafe_arena_set_allocated_euler_angles(::bosdyn::api::spot::EulerZYXValue* euler_angles) {
  clear_orientation();
  if (euler_angles) {
    set_has_euler_angles();
    _impl_.orientation_.euler_angles_ = euler_angles;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateBody.euler_angles)
}
inline ::bosdyn::api::spot::EulerZYXValue* AnimateBody::_internal_mutable_euler_angles() {
  if (!_internal_has_euler_angles()) {
    clear_orientation();
    set_has_euler_angles();
    _impl_.orientation_.euler_angles_ = CreateMaybeMessage< ::bosdyn::api::spot::EulerZYXValue >(GetArenaForAllocation());
  }
  return _impl_.orientation_.euler_angles_;
}
inline ::bosdyn::api::spot::EulerZYXValue* AnimateBody::mutable_euler_angles() {
  ::bosdyn::api::spot::EulerZYXValue* _msg = _internal_mutable_euler_angles();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateBody.euler_angles)
  return _msg;
}

// .bosdyn.api.Quaternion quaternion = 4;
inline bool AnimateBody::_internal_has_quaternion() const {
  return orientation_case() == kQuaternion;
}
inline bool AnimateBody::has_quaternion() const {
  return _internal_has_quaternion();
}
inline void AnimateBody::set_has_quaternion() {
  _impl_._oneof_case_[1] = kQuaternion;
}
inline ::bosdyn::api::Quaternion* AnimateBody::release_quaternion() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateBody.quaternion)
  if (_internal_has_quaternion()) {
    clear_has_orientation();
    ::bosdyn::api::Quaternion* temp = _impl_.orientation_.quaternion_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.orientation_.quaternion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::Quaternion& AnimateBody::_internal_quaternion() const {
  return _internal_has_quaternion()
      ? *_impl_.orientation_.quaternion_
      : reinterpret_cast< ::bosdyn::api::Quaternion&>(::bosdyn::api::_Quaternion_default_instance_);
}
inline const ::bosdyn::api::Quaternion& AnimateBody::quaternion() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateBody.quaternion)
  return _internal_quaternion();
}
inline ::bosdyn::api::Quaternion* AnimateBody::unsafe_arena_release_quaternion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.AnimateBody.quaternion)
  if (_internal_has_quaternion()) {
    clear_has_orientation();
    ::bosdyn::api::Quaternion* temp = _impl_.orientation_.quaternion_;
    _impl_.orientation_.quaternion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnimateBody::unsafe_arena_set_allocated_quaternion(::bosdyn::api::Quaternion* quaternion) {
  clear_orientation();
  if (quaternion) {
    set_has_quaternion();
    _impl_.orientation_.quaternion_ = quaternion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateBody.quaternion)
}
inline ::bosdyn::api::Quaternion* AnimateBody::_internal_mutable_quaternion() {
  if (!_internal_has_quaternion()) {
    clear_orientation();
    set_has_quaternion();
    _impl_.orientation_.quaternion_ = CreateMaybeMessage< ::bosdyn::api::Quaternion >(GetArenaForAllocation());
  }
  return _impl_.orientation_.quaternion_;
}
inline ::bosdyn::api::Quaternion* AnimateBody::mutable_quaternion() {
  ::bosdyn::api::Quaternion* _msg = _internal_mutable_quaternion();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateBody.quaternion)
  return _msg;
}

inline bool AnimateBody::has_position() const {
  return position_case() != POSITION_NOT_SET;
}
inline void AnimateBody::clear_has_position() {
  _impl_._oneof_case_[0] = POSITION_NOT_SET;
}
inline bool AnimateBody::has_orientation() const {
  return orientation_case() != ORIENTATION_NOT_SET;
}
inline void AnimateBody::clear_has_orientation() {
  _impl_._oneof_case_[1] = ORIENTATION_NOT_SET;
}
inline AnimateBody::PositionCase AnimateBody::position_case() const {
  return AnimateBody::PositionCase(_impl_._oneof_case_[0]);
}
inline AnimateBody::OrientationCase AnimateBody::orientation_case() const {
  return AnimateBody::OrientationCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// AnimateLegs

// .bosdyn.api.spot.AnimateSingleLeg fl = 1;
inline bool AnimateLegs::_internal_has_fl() const {
  return this != internal_default_instance() && _impl_.fl_ != nullptr;
}
inline bool AnimateLegs::has_fl() const {
  return _internal_has_fl();
}
inline void AnimateLegs::clear_fl() {
  if (GetArenaForAllocation() == nullptr && _impl_.fl_ != nullptr) {
    delete _impl_.fl_;
  }
  _impl_.fl_ = nullptr;
}
inline const ::bosdyn::api::spot::AnimateSingleLeg& AnimateLegs::_internal_fl() const {
  const ::bosdyn::api::spot::AnimateSingleLeg* p = _impl_.fl_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::AnimateSingleLeg&>(
      ::bosdyn::api::spot::_AnimateSingleLeg_default_instance_);
}
inline const ::bosdyn::api::spot::AnimateSingleLeg& AnimateLegs::fl() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateLegs.fl)
  return _internal_fl();
}
inline void AnimateLegs::unsafe_arena_set_allocated_fl(
    ::bosdyn::api::spot::AnimateSingleLeg* fl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fl_);
  }
  _impl_.fl_ = fl;
  if (fl) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateLegs.fl)
}
inline ::bosdyn::api::spot::AnimateSingleLeg* AnimateLegs::release_fl() {
  
  ::bosdyn::api::spot::AnimateSingleLeg* temp = _impl_.fl_;
  _impl_.fl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::AnimateSingleLeg* AnimateLegs::unsafe_arena_release_fl() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateLegs.fl)
  
  ::bosdyn::api::spot::AnimateSingleLeg* temp = _impl_.fl_;
  _impl_.fl_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::AnimateSingleLeg* AnimateLegs::_internal_mutable_fl() {
  
  if (_impl_.fl_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::AnimateSingleLeg>(GetArenaForAllocation());
    _impl_.fl_ = p;
  }
  return _impl_.fl_;
}
inline ::bosdyn::api::spot::AnimateSingleLeg* AnimateLegs::mutable_fl() {
  ::bosdyn::api::spot::AnimateSingleLeg* _msg = _internal_mutable_fl();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateLegs.fl)
  return _msg;
}
inline void AnimateLegs::set_allocated_fl(::bosdyn::api::spot::AnimateSingleLeg* fl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fl_;
  }
  if (fl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fl);
    if (message_arena != submessage_arena) {
      fl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fl, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fl_ = fl;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.AnimateLegs.fl)
}

// .bosdyn.api.spot.AnimateSingleLeg fr = 2;
inline bool AnimateLegs::_internal_has_fr() const {
  return this != internal_default_instance() && _impl_.fr_ != nullptr;
}
inline bool AnimateLegs::has_fr() const {
  return _internal_has_fr();
}
inline void AnimateLegs::clear_fr() {
  if (GetArenaForAllocation() == nullptr && _impl_.fr_ != nullptr) {
    delete _impl_.fr_;
  }
  _impl_.fr_ = nullptr;
}
inline const ::bosdyn::api::spot::AnimateSingleLeg& AnimateLegs::_internal_fr() const {
  const ::bosdyn::api::spot::AnimateSingleLeg* p = _impl_.fr_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::AnimateSingleLeg&>(
      ::bosdyn::api::spot::_AnimateSingleLeg_default_instance_);
}
inline const ::bosdyn::api::spot::AnimateSingleLeg& AnimateLegs::fr() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateLegs.fr)
  return _internal_fr();
}
inline void AnimateLegs::unsafe_arena_set_allocated_fr(
    ::bosdyn::api::spot::AnimateSingleLeg* fr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fr_);
  }
  _impl_.fr_ = fr;
  if (fr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateLegs.fr)
}
inline ::bosdyn::api::spot::AnimateSingleLeg* AnimateLegs::release_fr() {
  
  ::bosdyn::api::spot::AnimateSingleLeg* temp = _impl_.fr_;
  _impl_.fr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::AnimateSingleLeg* AnimateLegs::unsafe_arena_release_fr() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateLegs.fr)
  
  ::bosdyn::api::spot::AnimateSingleLeg* temp = _impl_.fr_;
  _impl_.fr_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::AnimateSingleLeg* AnimateLegs::_internal_mutable_fr() {
  
  if (_impl_.fr_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::AnimateSingleLeg>(GetArenaForAllocation());
    _impl_.fr_ = p;
  }
  return _impl_.fr_;
}
inline ::bosdyn::api::spot::AnimateSingleLeg* AnimateLegs::mutable_fr() {
  ::bosdyn::api::spot::AnimateSingleLeg* _msg = _internal_mutable_fr();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateLegs.fr)
  return _msg;
}
inline void AnimateLegs::set_allocated_fr(::bosdyn::api::spot::AnimateSingleLeg* fr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fr_;
  }
  if (fr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fr);
    if (message_arena != submessage_arena) {
      fr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fr, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fr_ = fr;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.AnimateLegs.fr)
}

// .bosdyn.api.spot.AnimateSingleLeg hl = 3;
inline bool AnimateLegs::_internal_has_hl() const {
  return this != internal_default_instance() && _impl_.hl_ != nullptr;
}
inline bool AnimateLegs::has_hl() const {
  return _internal_has_hl();
}
inline void AnimateLegs::clear_hl() {
  if (GetArenaForAllocation() == nullptr && _impl_.hl_ != nullptr) {
    delete _impl_.hl_;
  }
  _impl_.hl_ = nullptr;
}
inline const ::bosdyn::api::spot::AnimateSingleLeg& AnimateLegs::_internal_hl() const {
  const ::bosdyn::api::spot::AnimateSingleLeg* p = _impl_.hl_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::AnimateSingleLeg&>(
      ::bosdyn::api::spot::_AnimateSingleLeg_default_instance_);
}
inline const ::bosdyn::api::spot::AnimateSingleLeg& AnimateLegs::hl() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateLegs.hl)
  return _internal_hl();
}
inline void AnimateLegs::unsafe_arena_set_allocated_hl(
    ::bosdyn::api::spot::AnimateSingleLeg* hl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hl_);
  }
  _impl_.hl_ = hl;
  if (hl) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateLegs.hl)
}
inline ::bosdyn::api::spot::AnimateSingleLeg* AnimateLegs::release_hl() {
  
  ::bosdyn::api::spot::AnimateSingleLeg* temp = _impl_.hl_;
  _impl_.hl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::AnimateSingleLeg* AnimateLegs::unsafe_arena_release_hl() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateLegs.hl)
  
  ::bosdyn::api::spot::AnimateSingleLeg* temp = _impl_.hl_;
  _impl_.hl_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::AnimateSingleLeg* AnimateLegs::_internal_mutable_hl() {
  
  if (_impl_.hl_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::AnimateSingleLeg>(GetArenaForAllocation());
    _impl_.hl_ = p;
  }
  return _impl_.hl_;
}
inline ::bosdyn::api::spot::AnimateSingleLeg* AnimateLegs::mutable_hl() {
  ::bosdyn::api::spot::AnimateSingleLeg* _msg = _internal_mutable_hl();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateLegs.hl)
  return _msg;
}
inline void AnimateLegs::set_allocated_hl(::bosdyn::api::spot::AnimateSingleLeg* hl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hl_;
  }
  if (hl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hl);
    if (message_arena != submessage_arena) {
      hl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hl, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hl_ = hl;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.AnimateLegs.hl)
}

// .bosdyn.api.spot.AnimateSingleLeg hr = 4;
inline bool AnimateLegs::_internal_has_hr() const {
  return this != internal_default_instance() && _impl_.hr_ != nullptr;
}
inline bool AnimateLegs::has_hr() const {
  return _internal_has_hr();
}
inline void AnimateLegs::clear_hr() {
  if (GetArenaForAllocation() == nullptr && _impl_.hr_ != nullptr) {
    delete _impl_.hr_;
  }
  _impl_.hr_ = nullptr;
}
inline const ::bosdyn::api::spot::AnimateSingleLeg& AnimateLegs::_internal_hr() const {
  const ::bosdyn::api::spot::AnimateSingleLeg* p = _impl_.hr_;
  return p != nullptr ? *p : reinterpret_cast<const ::bosdyn::api::spot::AnimateSingleLeg&>(
      ::bosdyn::api::spot::_AnimateSingleLeg_default_instance_);
}
inline const ::bosdyn::api::spot::AnimateSingleLeg& AnimateLegs::hr() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateLegs.hr)
  return _internal_hr();
}
inline void AnimateLegs::unsafe_arena_set_allocated_hr(
    ::bosdyn::api::spot::AnimateSingleLeg* hr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hr_);
  }
  _impl_.hr_ = hr;
  if (hr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateLegs.hr)
}
inline ::bosdyn::api::spot::AnimateSingleLeg* AnimateLegs::release_hr() {
  
  ::bosdyn::api::spot::AnimateSingleLeg* temp = _impl_.hr_;
  _impl_.hr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bosdyn::api::spot::AnimateSingleLeg* AnimateLegs::unsafe_arena_release_hr() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateLegs.hr)
  
  ::bosdyn::api::spot::AnimateSingleLeg* temp = _impl_.hr_;
  _impl_.hr_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::AnimateSingleLeg* AnimateLegs::_internal_mutable_hr() {
  
  if (_impl_.hr_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::AnimateSingleLeg>(GetArenaForAllocation());
    _impl_.hr_ = p;
  }
  return _impl_.hr_;
}
inline ::bosdyn::api::spot::AnimateSingleLeg* AnimateLegs::mutable_hr() {
  ::bosdyn::api::spot::AnimateSingleLeg* _msg = _internal_mutable_hr();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateLegs.hr)
  return _msg;
}
inline void AnimateLegs::set_allocated_hr(::bosdyn::api::spot::AnimateSingleLeg* hr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hr_;
  }
  if (hr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hr);
    if (message_arena != submessage_arena) {
      hr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hr, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hr_ = hr;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.AnimateLegs.hr)
}

// -------------------------------------------------------------------

// AnimateSingleLeg

// .bosdyn.api.spot.LegJointAngles joint_angles = 1;
inline bool AnimateSingleLeg::_internal_has_joint_angles() const {
  return leg_case() == kJointAngles;
}
inline bool AnimateSingleLeg::has_joint_angles() const {
  return _internal_has_joint_angles();
}
inline void AnimateSingleLeg::set_has_joint_angles() {
  _impl_._oneof_case_[0] = kJointAngles;
}
inline void AnimateSingleLeg::clear_joint_angles() {
  if (_internal_has_joint_angles()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.leg_.joint_angles_;
    }
    clear_has_leg();
  }
}
inline ::bosdyn::api::spot::LegJointAngles* AnimateSingleLeg::release_joint_angles() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateSingleLeg.joint_angles)
  if (_internal_has_joint_angles()) {
    clear_has_leg();
    ::bosdyn::api::spot::LegJointAngles* temp = _impl_.leg_.joint_angles_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.leg_.joint_angles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::spot::LegJointAngles& AnimateSingleLeg::_internal_joint_angles() const {
  return _internal_has_joint_angles()
      ? *_impl_.leg_.joint_angles_
      : reinterpret_cast< ::bosdyn::api::spot::LegJointAngles&>(::bosdyn::api::spot::_LegJointAngles_default_instance_);
}
inline const ::bosdyn::api::spot::LegJointAngles& AnimateSingleLeg::joint_angles() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateSingleLeg.joint_angles)
  return _internal_joint_angles();
}
inline ::bosdyn::api::spot::LegJointAngles* AnimateSingleLeg::unsafe_arena_release_joint_angles() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.AnimateSingleLeg.joint_angles)
  if (_internal_has_joint_angles()) {
    clear_has_leg();
    ::bosdyn::api::spot::LegJointAngles* temp = _impl_.leg_.joint_angles_;
    _impl_.leg_.joint_angles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnimateSingleLeg::unsafe_arena_set_allocated_joint_angles(::bosdyn::api::spot::LegJointAngles* joint_angles) {
  clear_leg();
  if (joint_angles) {
    set_has_joint_angles();
    _impl_.leg_.joint_angles_ = joint_angles;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateSingleLeg.joint_angles)
}
inline ::bosdyn::api::spot::LegJointAngles* AnimateSingleLeg::_internal_mutable_joint_angles() {
  if (!_internal_has_joint_angles()) {
    clear_leg();
    set_has_joint_angles();
    _impl_.leg_.joint_angles_ = CreateMaybeMessage< ::bosdyn::api::spot::LegJointAngles >(GetArenaForAllocation());
  }
  return _impl_.leg_.joint_angles_;
}
inline ::bosdyn::api::spot::LegJointAngles* AnimateSingleLeg::mutable_joint_angles() {
  ::bosdyn::api::spot::LegJointAngles* _msg = _internal_mutable_joint_angles();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateSingleLeg.joint_angles)
  return _msg;
}

// .bosdyn.api.Vec3Value foot_pos = 2;
inline bool AnimateSingleLeg::_internal_has_foot_pos() const {
  return leg_case() == kFootPos;
}
inline bool AnimateSingleLeg::has_foot_pos() const {
  return _internal_has_foot_pos();
}
inline void AnimateSingleLeg::set_has_foot_pos() {
  _impl_._oneof_case_[0] = kFootPos;
}
inline ::bosdyn::api::Vec3Value* AnimateSingleLeg::release_foot_pos() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateSingleLeg.foot_pos)
  if (_internal_has_foot_pos()) {
    clear_has_leg();
    ::bosdyn::api::Vec3Value* temp = _impl_.leg_.foot_pos_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.leg_.foot_pos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::Vec3Value& AnimateSingleLeg::_internal_foot_pos() const {
  return _internal_has_foot_pos()
      ? *_impl_.leg_.foot_pos_
      : reinterpret_cast< ::bosdyn::api::Vec3Value&>(::bosdyn::api::_Vec3Value_default_instance_);
}
inline const ::bosdyn::api::Vec3Value& AnimateSingleLeg::foot_pos() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateSingleLeg.foot_pos)
  return _internal_foot_pos();
}
inline ::bosdyn::api::Vec3Value* AnimateSingleLeg::unsafe_arena_release_foot_pos() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.spot.AnimateSingleLeg.foot_pos)
  if (_internal_has_foot_pos()) {
    clear_has_leg();
    ::bosdyn::api::Vec3Value* temp = _impl_.leg_.foot_pos_;
    _impl_.leg_.foot_pos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnimateSingleLeg::unsafe_arena_set_allocated_foot_pos(::bosdyn::api::Vec3Value* foot_pos) {
  clear_leg();
  if (foot_pos) {
    set_has_foot_pos();
    _impl_.leg_.foot_pos_ = foot_pos;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateSingleLeg.foot_pos)
}
inline ::bosdyn::api::Vec3Value* AnimateSingleLeg::_internal_mutable_foot_pos() {
  if (!_internal_has_foot_pos()) {
    clear_leg();
    set_has_foot_pos();
    _impl_.leg_.foot_pos_ = CreateMaybeMessage< ::bosdyn::api::Vec3Value >(GetArenaForAllocation());
  }
  return _impl_.leg_.foot_pos_;
}
inline ::bosdyn::api::Vec3Value* AnimateSingleLeg::mutable_foot_pos() {
  ::bosdyn::api::Vec3Value* _msg = _internal_mutable_foot_pos();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateSingleLeg.foot_pos)
  return _msg;
}

// .google.protobuf.BoolValue stance = 3;
inline bool AnimateSingleLeg::_internal_has_stance() const {
  return this != internal_default_instance() && _impl_.stance_ != nullptr;
}
inline bool AnimateSingleLeg::has_stance() const {
  return _internal_has_stance();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& AnimateSingleLeg::_internal_stance() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.stance_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& AnimateSingleLeg::stance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.AnimateSingleLeg.stance)
  return _internal_stance();
}
inline void AnimateSingleLeg::unsafe_arena_set_allocated_stance(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* stance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stance_);
  }
  _impl_.stance_ = stance;
  if (stance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.AnimateSingleLeg.stance)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* AnimateSingleLeg::release_stance() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.stance_;
  _impl_.stance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* AnimateSingleLeg::unsafe_arena_release_stance() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.AnimateSingleLeg.stance)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.stance_;
  _impl_.stance_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* AnimateSingleLeg::_internal_mutable_stance() {
  
  if (_impl_.stance_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.stance_ = p;
  }
  return _impl_.stance_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* AnimateSingleLeg::mutable_stance() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_stance();
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.AnimateSingleLeg.stance)
  return _msg;
}
inline void AnimateSingleLeg::set_allocated_stance(::PROTOBUF_NAMESPACE_ID::BoolValue* stance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stance_);
  }
  if (stance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stance));
    if (message_arena != submessage_arena) {
      stance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stance_ = stance;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.AnimateSingleLeg.stance)
}

inline bool AnimateSingleLeg::has_leg() const {
  return leg_case() != LEG_NOT_SET;
}
inline void AnimateSingleLeg::clear_has_leg() {
  _impl_._oneof_case_[0] = LEG_NOT_SET;
}
inline AnimateSingleLeg::LegCase AnimateSingleLeg::leg_case() const {
  return AnimateSingleLeg::LegCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LegJointAngles

// double hip_x = 1;
inline void LegJointAngles::clear_hip_x() {
  _impl_.hip_x_ = 0;
}
inline double LegJointAngles::_internal_hip_x() const {
  return _impl_.hip_x_;
}
inline double LegJointAngles::hip_x() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LegJointAngles.hip_x)
  return _internal_hip_x();
}
inline void LegJointAngles::_internal_set_hip_x(double value) {
  
  _impl_.hip_x_ = value;
}
inline void LegJointAngles::set_hip_x(double value) {
  _internal_set_hip_x(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LegJointAngles.hip_x)
}

// double hip_y = 2;
inline void LegJointAngles::clear_hip_y() {
  _impl_.hip_y_ = 0;
}
inline double LegJointAngles::_internal_hip_y() const {
  return _impl_.hip_y_;
}
inline double LegJointAngles::hip_y() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LegJointAngles.hip_y)
  return _internal_hip_y();
}
inline void LegJointAngles::_internal_set_hip_y(double value) {
  
  _impl_.hip_y_ = value;
}
inline void LegJointAngles::set_hip_y(double value) {
  _internal_set_hip_y(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LegJointAngles.hip_y)
}

// double knee = 3;
inline void LegJointAngles::clear_knee() {
  _impl_.knee_ = 0;
}
inline double LegJointAngles::_internal_knee() const {
  return _impl_.knee_;
}
inline double LegJointAngles::knee() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LegJointAngles.knee)
  return _internal_knee();
}
inline void LegJointAngles::_internal_set_knee(double value) {
  
  _impl_.knee_ = value;
}
inline void LegJointAngles::set_knee(double value) {
  _internal_set_knee(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LegJointAngles.knee)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace spot
}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::spot::SequenceInfo_SavedState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::SequenceInfo_SavedState>() {
  return ::bosdyn::api::spot::SequenceInfo_SavedState_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::DeleteSequenceResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::DeleteSequenceResponse_Status>() {
  return ::bosdyn::api::spot::DeleteSequenceResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::SaveSequenceResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::SaveSequenceResponse_Status>() {
  return ::bosdyn::api::spot::SaveSequenceResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::ModifyChoreographyInfoResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::ModifyChoreographyInfoResponse_Status>() {
  return ::bosdyn::api::spot::ModifyChoreographyInfoResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::ClearAllSequenceFilesResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::ClearAllSequenceFilesResponse_Status>() {
  return ::bosdyn::api::spot::ClearAllSequenceFilesResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::UploadAnimatedMoveResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::UploadAnimatedMoveResponse_Status>() {
  return ::bosdyn::api::spot::UploadAnimatedMoveResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::ExecuteChoreographyResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::ExecuteChoreographyResponse_Status>() {
  return ::bosdyn::api::spot::ExecuteChoreographyResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::StartRecordingStateResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::StartRecordingStateResponse_Status>() {
  return ::bosdyn::api::spot::StartRecordingStateResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::DownloadRobotStateLogRequest_LogType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::DownloadRobotStateLogRequest_LogType>() {
  return ::bosdyn::api::spot::DownloadRobotStateLogRequest_LogType_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::DownloadRobotStateLogResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::DownloadRobotStateLogResponse_Status>() {
  return ::bosdyn::api::spot::DownloadRobotStateLogResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::MoveInfo_TransitionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::MoveInfo_TransitionState>() {
  return ::bosdyn::api::spot::MoveInfo_TransitionState_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::ChoreographerDisplayInfo_Category> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::ChoreographerDisplayInfo_Category>() {
  return ::bosdyn::api::spot::ChoreographerDisplayInfo_Category_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::Animation_ArmPlayback> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::Animation_ArmPlayback>() {
  return ::bosdyn::api::spot::Animation_ArmPlayback_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_2fchoreography_5fsequence_2eproto
